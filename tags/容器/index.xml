
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 容器</title>
    <link>https://jimmysong.io/tags/%E5%AE%B9%E5%99%A8/</link>
    <description>Recent content in 容器 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    
      <follow_challenge>
        <feedId>51621818828612637</feedId>
        <userId>59800919738273792</userId>
      </follow_challenge>
    
    
    <lastBuildDate>Thu, 12 Sep 2024 16:35:35 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>使用 eBPF 检测和优化 Linux 容器的噪声邻居问题</title>
      <link>https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/</link>
      <pubDate>Thu, 12 Sep 2024 16:35:35 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/</guid>
      <description>
        
        
        &lt;p&gt;Netflix 的计算与性能工程团队定期调查我们多租户环境中的性能问题。首先是确定问题是源自应用程序还是底层基础设施。一个经常复杂化这一过程的问题是“噪声邻居”问题。在我们的多租户计算平台 &lt;a href=&#34;https://netflixtechblog.com/titus-the-netflix-container-management-platform-is-now-open-source-f868c9fb5436&#34; title=&#34;Titus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Titus&lt;/a&gt;，“噪声邻居”指的是大量使用服务器资源的容器或系统服务，导致相邻容器的性能下降。我们通常关注 CPU 利用率，因为它是我们工作负载中噪声邻居问题的最常见来源。&lt;/p&gt;
&lt;p&gt;检测噪声邻居的影响是复杂的。传统的性能分析工具如 &lt;a href=&#34;https://www.brendangregg.com/perf.html&#34; title=&#34;perf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf&lt;/a&gt; 可能会引入显著的开销，从而加剧性能下降。此外，这些工具通常在事后部署，对有效调查来说已经太迟了。另一个挑战是，调试噪声邻居问题需要相当的底层专业知识和专门的工具。在这篇博客文章中，我们将展示我们如何利用 &lt;a href=&#34;https://ebpf.io/&#34; title=&#34;eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 实现 Linux 调度器的持续、低开销的检测，有效地自助监控噪声邻居问题。你将学习到 Linux 内核检测如何改善你的基础设施可观测性，并带来更深入的洞察和增强的监控。&lt;/p&gt;
&lt;h2 id=&#34;持续检测-linux-调度器&#34;&gt;持续检测 Linux 调度器&lt;/h2&gt;
&lt;p&gt;为了确保我们依赖低延迟响应的工作负载的可靠性，我们对每个容器的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Run_queue&#34; title=&#34;run queue&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;run queue&lt;/a&gt; 延迟进行了检测，这个指标衡量进程在调度队列中等待被派发到 CPU 的时间。在此队列中的长时间等待可能是性能问题的征兆，尤其是当容器没有使用其全部 CPU 分配时。持续的检测对于抓住这类问题至关重要，而 eBPF 通过最小的开销进入 Linux 调度器，使我们能够有效地监控 run queue 延迟。&lt;/p&gt;
&lt;p&gt;为了发出 run queue 延迟指标，我们利用了三个 eBPF 钩子：&lt;code&gt;sched_wakeup&lt;/code&gt;、&lt;code&gt;sched_wakeup_new&lt;/code&gt; 和 &lt;code&gt;sched_switch&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f1_hu18183563338868081835.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f1.png&#34; data-img=&#34;/trans/noisy-neighbor-detection-with-ebpf/f1.png&#34; data-width=&#34;1778&#34; data-height=&#34;1000&#34; alt=&#34;image&#34; data-caption=&#34;图 1：测量和检测 run queue 延迟的图示&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 1：测量和检测 run queue 延迟的图示&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;sched_wakeup&lt;/code&gt; 和 &lt;code&gt;sched_wakeup_new&lt;/code&gt; 钩子在进程状态从“睡眠”变为“可运行”时调用。它们让我们识别出进程准备运行并等待 CPU 时间的时刻。在此事件中，我们生成一个时间戳，并使用进程 ID 作为键，将其存储在 eBPF 哈希图中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_TASK_ENTRIES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;runq_enqueued&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tp_btf/sched_wakeup&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tp_sched_wakeup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_ktime_get_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runq_enqueued&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_NOEXIST&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相反，&lt;code&gt;sched_switch&lt;/code&gt; 钩子在 CPU 在进程间切换时触发。这个钩子提供了当前利用 CPU 的进程和即将接管的进程的指针。我们使用即将执行任务的进程 ID (PID) 来获取之前存储的时间戳。然后，我们通过简单地减去时间戳来计算 run queue 延迟。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tp_btf/sched_switch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tp_sched_switch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next_pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取下一个任务入队的时间戳
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tsp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runq_enqueued&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tsp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 未记录入队
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在删除存储的时间戳前计算 runq 延迟
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_ktime_get_ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;runq_lat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 从 enqueued 图中删除 PID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;bpf_map_delete_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runq_enqueued&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next_pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;eBPF 的一个优势是它能提供指向实际内核数据结构的指针，这些结构代表进程或线程，也称为内核术语中的任务。这一特性使得我们能够访问关于进程存储的大量信息。我们需要进程的 cgroup ID 以将其与容器关联，但是进程结构中的 cgroup 信息受到 &lt;a href=&#34;https://elixir.bootlin.com/linux/v6.6.16/source/include/linux/sched.h#L1225&#34; title=&#34;RCU (Read Copy Update) 锁&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RCU (Read Copy Update) 锁&lt;/a&gt; 的保护。&lt;/p&gt;
&lt;p&gt;为了安全地访问这些受 RCU 保护的信息，我们可以利用 eBPF 中的 &lt;a href=&#34;https://docs.kernel.org/bpf/kfuncs.html&#34; title=&#34;kfuncs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kfuncs&lt;/a&gt;。kfuncs 是可以从 eBPF 程序调用的内核函数。这些函数确保我们的 eBPF 程序在检索任务结构中的 cgroup ID 时保持安全和高效。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_rcu_read_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__ksym&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_rcu_read_unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__ksym&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_task_cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;task_struct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;css_set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;bpf_rcu_read_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cgroups&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroups&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dfl_cgrp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;bpf_rcu_read_unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据准备好后，我们必须将其打包并发送到用户空间。为此，我们选择了 eBPF &lt;a href=&#34;https://nakryiko.com/posts/bpf-ringbuf/&#34; title=&#34;环形缓冲区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;环形缓冲区&lt;/a&gt;。它既高效又高性能，且用户友好。它可以处理变长数据记录，并允许数据读取而无需额外的内存复制或系统调用。然而，大量数据点使得用户空间程序的 CPU 使用过多，所以我们在 eBPF 中实施了速率限制以采样数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_RINGBUF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RINGBUF_SIZE_BYTES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_PERCPU_HASH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_TASK_ENTRIES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id_to_last_event_ts&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nc&#34;&gt;runq_event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev_cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;runq_lat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tp_btf/sched_switch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tp_sched_switch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// ....
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 上述代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ....
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev_cgroup_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_task_cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_task_cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 按每个 cgroup ID 每个 CPU 进行速率限制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 平衡可观测性与性能开销
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_ts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroup_id_to_last_event_ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;last_ts_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;last_ts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在进行更多工作之前检查考虑中的 cgroup ID 的速率限制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;last_ts_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RATE_LIMIT_NS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 速率限制超出，丢弃事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;runq_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_ringbuf_reserve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev_cgroup_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev_cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runq_lat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;runq_lat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;bpf_ringbuf_submit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 更新当前 cgroup ID 的最后一个事件时间戳
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroup_id_to_last_event_ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgroup_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_ANY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在 Go 开发的用户空间应用程序处理环形缓冲区中的事件，以向我们的度量后端 &lt;a href=&#34;https://netflixtechblog.com/introducing-atlas-netflixs-primary-telemetry-platform-bd31f4d8ed9a&#34; title=&#34;Atlas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atlas&lt;/a&gt; 发出度量。每个事件包含一个带有 cgroup ID 的 run queue 延迟样本，我们将其与主机上运行的容器关联。如果没有发现这种关联，我们会将其分类为系统服务。当 cgroup ID 与容器关联时，我们会为该容器发出百分位计时器 Atlas 度量（&lt;code&gt;runq.latency&lt;/code&gt;）。我们还增加了一个计数器度量（&lt;code&gt;sched.switch.out&lt;/code&gt;）来监控容器进程的抢占情况。通过访问被抢占进程的 &lt;code&gt;prev_cgroup_id&lt;/code&gt;，我们可以为度量标记抢占的原因，无论是同一容器（或 cgroup）内的进程、另一个容器的进程还是系统服务的进程。&lt;/p&gt;
&lt;p&gt;值得强调的是，&lt;code&gt;runq.latency&lt;/code&gt; 度量和 &lt;code&gt;sched.switch.out&lt;/code&gt; 度量都需要确定容器是否受到噪声邻居的影响，这是我们旨在实现的目标。单独依赖 &lt;code&gt;runq.latency&lt;/code&gt; 度量可能会导致误解。例如，如果容器处于或超过其 cgroup CPU 限制，调度器将对其进行限制，导致队列中的延迟明显增加。如果我们只考虑这个度量，我们可能错误地将性能下降归咎于噪声邻居，而实际上是因为容器触及了其 CPU 配额。然而，当两个度量同时出现尖峰，尤其是当原因是不同容器或系统进程时，明显表明了噪声邻居问题。&lt;/p&gt;
&lt;h2 id=&#34;噪声邻居的故事&#34;&gt;噪声邻居的故事&lt;/h2&gt;
&lt;p&gt;以下是一台运行单个容器的服务器的 &lt;code&gt;runq.latency&lt;/code&gt; 度量，该容器拥有充足的 CPU 容量。99 百分位平均为 83.4 微秒（微秒），作为我们的基准。尽管有些尖峰达到 400 微秒，但延迟仍在可接受的参数范围内。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f2_hu4917787928732110742.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f2.png&#34; data-img=&#34;/trans/noisy-neighbor-detection-with-ebpf/f2.png&#34; data-width=&#34;2000&#34; data-height=&#34;838&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;container1 的 99 百分位 runq.latency 平均为 83 微秒（微秒），尖峰可达 400 微秒，没有相邻容器。这作为一个容器在主机上未争夺 CPU 的基准。&lt;/p&gt;
&lt;p&gt;在 10:35，启动 &lt;code&gt;container2&lt;/code&gt;，它充分利用了主机上的所有 CPU，导致 &lt;code&gt;container1&lt;/code&gt; 的 P99 run queue 延迟出现了 131 毫秒的尖峰（131,000 微秒）。如果用户空间应用程序正在服务 HTTP 流量，则这一尖峰将在用户空间应用程序中可见。如果用户空间应用程序所有者报告了无法解释的延迟尖峰，我们可以通过 run queue 延迟度量迅速识别噪声邻居问题。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f3_hu4886606822886195327.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f3.png&#34; data-img=&#34;/trans/noisy-neighbor-detection-with-ebpf/f3.png&#34; data-width=&#34;2000&#34; data-height=&#34;916&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;在 10:35 启动的 container2 充分利用了主机上的所有 CPU，&lt;strong&gt;导致 container1 的 P99 run queue 延迟出现了 131 毫秒的尖峰&lt;/strong&gt;，因为系统进程的抢占增加。这表明存在一个噪声邻居问题，即系统服务与容器竞争 CPU 时间。我们的度量显示，噪声邻居实际上是系统进程，可能是由 &lt;code&gt;container2&lt;/code&gt; 消耗所有可用 CPU 容量触发的。&lt;/p&gt;
&lt;h2 id=&#34;优化-ebpf-代码&#34;&gt;优化 eBPF 代码&lt;/h2&gt;
&lt;p&gt;我们开发了一个名为 &lt;a href=&#34;https://netflixtechblog.com/announcing-bpftop-streamlining-ebpf-performance-optimization-6a727c1ae2e5&#34; title=&#34;bpftop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftop&lt;/a&gt; 的开源 eBPF 进程监控工具，用来测量此内核热路径中 eBPF 代码的开销。我们使用 &lt;code&gt;bpftop&lt;/code&gt; 进行的性能分析显示，检测仪增加的开销不到每个 &lt;code&gt;sched_*&lt;/code&gt; 钩子 600 纳秒。我们对在容器中运行的 Java 服务进行了性能分析，发现检测代码未引入显著开销。开启与关闭 run queue 检测代码的性能差异在毫秒级不可测。&lt;/p&gt;
&lt;p&gt;在我们对内核中如何测量 eBPF 统计信息的研究中，我们发现了一个改进计算的机会。我们提交了这个 &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ce09cbdd988887662546a1175bcfdfc6c8fdd150&#34; title=&#34;patch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;patch&lt;/a&gt;，并包括在 Linux 内核 6.10 版本中。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/trans/noisy-neighbor-detection-with-ebpf/f4.gif&#34; data-img=&#34;/trans/noisy-neighbor-detection-with-ebpf/f4.gif&#34; data-width=&#34;1231&#34; data-height=&#34;255&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;通过试错和使用 &lt;code&gt;bpftop&lt;/code&gt;，我们确定了几种优化，帮助保持了我们 eBPF 代码的低开销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们发现 &lt;code&gt;BPF_MAP_TYPE_HASH&lt;/code&gt; 存储入队时间戳时最为高效。使用 &lt;code&gt;BPF_MAP_TYPE_TASK_STORAGE&lt;/code&gt; 会导致性能下降近一倍。&lt;code&gt;BPF_MAP_TYPE_PERCPU_HASH&lt;/code&gt; 的性能略低于 &lt;code&gt;BPF_MAP_TYPE_HASH&lt;/code&gt;，这是意料之外的，需要进一步调查。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_LRU_HASH&lt;/code&gt; 映射的操作比常规哈希映射慢 40-50 纳秒。由于 PID 流失引起的空间问题，我们最初使用了它们来存储入队时间戳。最终，我们选择了增大尺寸的 &lt;code&gt;BPF_MAP_TYPE_HASH&lt;/code&gt;，以降低这一风险。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_CORE_READ&lt;/code&gt; 帮助每次调用增加 20-30 纳秒。在特别是那些“BTF 启用”的原始跟踪点（&lt;code&gt;tp_btf/*&lt;/code&gt;）的情况下，直接访问任务结构成员是安全且更高效的。Andrii Nakryiko 在这篇 &lt;a href=&#34;https://nakryiko.com/posts/bpf-core-reference-guide/#btf-enabled-bpf-program-types-with-direct-memory-reads&#34; title=&#34;博客文章&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客文章&lt;/a&gt; 中推荐了这种方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sched_switch&lt;/code&gt;、&lt;code&gt;sched_wakeup&lt;/code&gt; 和 &lt;code&gt;sched_wakeup_new&lt;/code&gt; 都会因内核任务触发，这些任务的 PID 为 0。我们发现监控这些任务是不必要的，因此我们实施了几种提前退出条件和条件逻辑，以防在处理内核任务时执行代价高昂的操作，如访问 BPF 映射。值得注意的是，内核任务就像任何常规进程一样通过调度队列操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;我们的发现突出了使用 eBPF 对 Linux 内核进行低开销持续检测的价值。我们已将这些度量整合到客户仪表板中，使其能够提供可操作的洞察，并指导多租户性能讨论。我们现在也可以使用这些度量来完善 CPU 隔离策略，以最小化噪声邻居的影响。此外，这些度量使我们深入了解了 Linux 调度器。&lt;/p&gt;
&lt;p&gt;这项工作还加深了我们对 eBPF 技术的理解，并强调了像 &lt;code&gt;bpftop&lt;/code&gt; 这样的工具对优化 eBPF 代码的重要性。随着 eBPF 的采用增加，我们预见更多的基础设施可观测性和业务逻辑将转向使用它。在这方面有一个前景广阔的项目是 &lt;a href=&#34;https://github.com/sched-ext/scx&#34; title=&#34;sched_ext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sched_ext&lt;/a&gt;，它有潜力革新调度决策的制定方式，并根据特定工作负载需求进行定制。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>如何在 Docker 容器中运行 GUI 应用程序</title>
      <link>https://jimmysong.io/trans/run-gui-applications-as-containers-with-x11docker/</link>
      <pubDate>Tue, 19 Sep 2023 12:03:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/run-gui-applications-as-containers-with-x11docker/</guid>
      <description>
        
        
        &lt;p&gt;作为开发人员，您可能需要使用 GUI 容器进行工作。如果是这种情况，您会很快发现，传统的 Docker 运行时引擎并不支持运行 GUI 应用程序（除非它们是基于 Web 的类型）。当您想要开发容器化的 GUI 应用程序时，您该怎么办呢？&lt;/p&gt;
&lt;p&gt;幸运的是，有许多第三方应用程序可以在桌面上轻松启动 GUI 容器。正如您可能预期的那样，这需要一个桌面环境（否则，您将在更传统的基于服务器的设置上进行开发）。其中一个应用程序叫做 &lt;a href=&#34;https://github.com/mviereck/x11docker&#34; title=&#34;x11docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x11docker&lt;/a&gt;。顾名思义，此应用程序与 Linux X 显示服务器配合使用（这意味着您需要一个 Linux 发行版才能使其正常工作）。&lt;/p&gt;
&lt;p&gt;x11docker 应用程序包括以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU 硬件加速&lt;/li&gt;
&lt;li&gt;PulseAudio 或 ALSA 声音&lt;/li&gt;
&lt;li&gt;剪贴板共享&lt;/li&gt;
&lt;li&gt;打印机和摄像头访问&lt;/li&gt;
&lt;li&gt;持久的主目录&lt;/li&gt;
&lt;li&gt;Wayland 支持&lt;/li&gt;
&lt;li&gt;语言区域设置创建&lt;/li&gt;
&lt;li&gt;容器内的多个 init 系统和 DBus&lt;/li&gt;
&lt;li&gt;支持多个容器运行时和后端（包括 Podman）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可能会问：“X11 不安全吗？”是的，确实。幸运的是，x11docker 通过使用多个 X 服务器来避免 X 服务器泄漏。因此，您可以放心使用该工具，而不必担心会暴露自己、系统或容器给典型的 X11 服务器弱点。&lt;/p&gt;
&lt;p&gt;需要记住的一件事是，x11docker 创建了一个非特权容器用户。该用户的密码为 x11docker，并限制了容器的功能。因此，某些应用程序可能无法按预期方式运行。例如，当尝试从容器内运行 Tor 浏览器时，它无法访问 /dev/stdout，这意味着容器将无法运行。但并不是所有容器都是如此。我将用 VLC 媒体播放器进行演示，该播放器可以按预期运行。&lt;/p&gt;
&lt;p&gt;接下来，我将向您展示如何在运行中的基于 Ubuntu 的桌面操作系统实例上安装 x11docker。当然，首先您必须安装 Docker 运行时引擎。为此，我将向您展示两种不同的方法。&lt;/p&gt;
&lt;p&gt;准备好了吗？我们开始吧。&lt;/p&gt;
&lt;h2 id=&#34;所需的工具&#34;&gt;所需的工具&lt;/h2&gt;
&lt;p&gt;正如我已经提到的，您需要运行中的基于 Ubuntu 的 Linux 桌面发行版实例。您还需要一个具有 sudo 权限的用户。就这些。&lt;/p&gt;
&lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h2&gt;
&lt;p&gt;首先，我们将使用传统的方法安装 Docker 运行时引擎。首先要做的是使用以下命令将官方 Docker GPG 添加到系统中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL &amp;lt;https://download.docker.com/linux/ubuntu/gpg&amp;gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们必须添加 Docker 仓库，以便安装软件。使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] &amp;lt;https://download.docker.com/linux/ubuntu&amp;gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; stable&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/apt/sources.list.d/docker.list &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;gt&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加仓库后，我们将使用以下命令安装一些依赖项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用以下命令更新 apt：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，我们可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了能够在不使用 &lt;em&gt;sudo&lt;/em&gt; 的情况下运行 Docker 命令（这可能存在安全风险），请使用以下命令将您的用户添加到 docker 用户组中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo usermod -aG docker &lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注销并重新登录以使更改生效。&lt;/p&gt;
&lt;p&gt;如果您希望采用快速方式，可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install curl wget uidmap -y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget -qO- https://get.docker.com/ &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要能够以无特权方式运行 Docker，请执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dockerd-rootless-setuptool.sh install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何安装-x11docker&#34;&gt;如何安装 x11docker&lt;/h2&gt;
&lt;p&gt;在安装 x11docker 之前，我们必须安装一些依赖项。可以使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install xpra xserver-xephyr xinit xauth xclip x11-xserver-utils x11-utils -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，使用以下命令安装 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL https://raw.githubusercontent.com/mviereck/x11docker/master/x11docker &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo bash -s -- --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，您可以使用以下命令更新 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo x11docker --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何使用-x11docker&#34;&gt;如何使用 x11docker&lt;/h2&gt;
&lt;p&gt;安装了 x11docker 之后，就可以开始测试了。让我们使用 VLC 应用程序容器进行测试。首先，使用以下命令拉取镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;拉取镜像后，使用以下命令（借助 x11docker）运行 VLC：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x11docker --pulseaudio --share&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/Videos jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您应该会看到 VLC 窗口打开，准备好供使用（图 1）。它的速度比直接安装在您的桌面上要慢一些，但除此之外，它应该按预期工作。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/run-gui-applications-as-containers-with-x11docker/docker_hu12054510246373509198.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/run-gui-applications-as-containers-with-x11docker/docker.jpg&#34; data-img=&#34;/trans/run-gui-applications-as-containers-with-x11docker/docker.jpg&#34; data-width=&#34;621&#34; data-height=&#34;486&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;当然，如果您是开发人员，这对您帮助不大，因为您想要开发自己的容器。您可以始终创建要使用的映像，对其进行标记，将其推送到您选择的存储库，使用 docker pull 命令将其拉到开发系统上，然后使用 x11docker 部署容器。&lt;/p&gt;
&lt;p&gt;就是这样。现在，您可以通过 x11docker 在 Docker 容器中运行 GUI 应用程序了。借助自己的图像部署自己的定制容器，看看它的工作原理。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>Docker 多平台构建指南：构建 WebAssembly 镜像</title>
      <link>https://jimmysong.io/blog/docker-multi-platform-image-building/</link>
      <pubDate>Tue, 25 Apr 2023 19:09:28 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/docker-multi-platform-image-building/</guid>
      <description>
        
        
        &lt;p&gt;Docker 多平台构建是一种用于构建 Docker 镜像以在多种 CPU 架构和操作系统上运行的技术。它可以让用户在一个 Dockerfile 中定义一个通用的构建过程，然后使用 Docker CLI 命令将其构建为多个不同平台的镜像。这些镜像可以在不同的计算机、云平台和容器编排系统上运行，从而为用户提供更广泛的部署选项。&lt;/p&gt;
&lt;p&gt;在多平台构建中，用户需要使用 Docker Buildx 插件来构建镜像。Docker Buildx 可以构建并输出多个不同平台的镜像，包括 x86、ARM、IBM Power 等。用户可以使用该插件创建多种平台的构建环境，并使用这些环境构建镜像。&lt;/p&gt;
&lt;p&gt;需要注意的是，多平台构建需要在支持多平台的 Docker 主机上进行。在这种主机上，Docker 可以使用 QEMU 等模拟器来模拟其他平台的环境，从而实现构建多种平台的镜像。&lt;/p&gt;
&lt;h2 id=&#34;what-is-docker-buildx&#34;&gt;什么是 docker buildx?&lt;/h2&gt;
&lt;p&gt;Docker Buildx 是 Docker 的一个插件，它提供了一种简单、高效的方式来构建和打包 Docker 镜像。它能够在多个平台上构建和输出 Docker 镜像，包括 Linux、Windows、macOS 等，支持 CPU 架构和操作系统等多种参数的设置。&lt;/p&gt;
&lt;p&gt;Docker Buildx 在构建镜像时使用了 &lt;a href=&#34;https://docs.docker.com/build/buildkit/&#34; title=&#34;BuildKit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildKit&lt;/a&gt;，这是 Docker 官方推出的一个基于 Go 语言实现的高性能构建引擎。BuildKit 提供了更快的构建速度、更小的镜像体积、更好的缓存管理等优势，也可以在 Docker Buildx 之外使用。&lt;/p&gt;
&lt;p&gt;使用 Docker Buildx，可以将不同平台上的 Docker 镜像构建合并到一个 manifest 中，使得用户只需要下载一个 manifest，就可以获取多个平台的镜像。这为跨平台开发和分发应用程序提供了很大的便利。&lt;/p&gt;
&lt;h2 id=&#34;docker-buildx-principles&#34;&gt;Docker buildx 实现多平台构建的原理&lt;/h2&gt;
&lt;p&gt;Docker &lt;a href=&#34;https://github.com/docker/buildx&#34; title=&#34;buildx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;buildx&lt;/a&gt; 实现多平台镜像构建的原理是基于 Docker 的多架构支持。Docker 可以在一个主机上运行多个容器，每个容器运行在自己的隔离环境中，相互独立。而 Docker 镜像则是用于创建容器的基础文件系统。&lt;/p&gt;
&lt;p&gt;在 Docker 中，不同的 CPU 架构和操作系统可以使用不同的 base image（基础镜像）进行构建。而 Docker buildx 可以自动识别当前主机的架构和操作系统，并选择合适的 base image 进行构建。在构建过程中，Docker buildx 会使用 BuildKit 引擎进行构建，支持多平台的交叉编译和镜像打包。&lt;/p&gt;
&lt;p&gt;在构建完成后，Docker buildx 会将不同平台上的镜像打包成一个 manifest 文件，其中包含了所有平台的镜像信息。用户可以通过 Docker CLI 命令或者 Docker registry 接口来操作 manifest 文件，获取不同平台上的镜像。对于不支持多架构的 Docker 版本，可以通过安装 Docker CLI 的 experimental 版本来使用 Docker buildx。&lt;/p&gt;
&lt;p&gt;Docker buildx 利用了 Docker 的多架构支持和 BuildKit 引擎，实现了跨平台的 Docker 镜像构建和分发。&lt;/p&gt;
&lt;h2 id=&#34;docker-buildkit&#34;&gt;Docker BuildKit 引擎简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/build/buildkit/&#34; title=&#34;BuildKit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildKit&lt;/a&gt; 是 Docker 官方推出的一个高性能的构建引擎，它可以用于构建 Docker 镜像、构建应用程序以及执行其他构建任务。BuildKit 引擎采用了分布式的架构，可以并行地执行多个构建任务，提高构建效率。&lt;/p&gt;
&lt;p&gt;BuildKit 引擎的主要特点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高性能：BuildKit 引擎采用了高效的缓存管理机制，能够快速地执行增量构建，减少构建时间。同时，它还能够自动优化构建过程，选择最佳的构建路径和策略，进一步提高构建性能。&lt;/li&gt;
&lt;li&gt;多平台支持：BuildKit 引擎支持多种 CPU 架构和操作系统，能够在不同平台上构建和输出 Docker 镜像。在 Docker buildx 中，BuildKit 引擎可以自动识别当前主机的架构和操作系统，并选择合适的构建方案。&lt;/li&gt;
&lt;li&gt;模块化设计：BuildKit 引擎采用了模块化的设计，可以根据需要动态加载和卸载不同的模块。这使得 BuildKit 引擎更加灵活和可扩展，可以支持各种不同的构建任务。&lt;/li&gt;
&lt;li&gt;安全性：BuildKit 引擎采用了安全的构建方式，可以自动执行一系列的安全检查，确保构建过程中不会引入漏洞或其他安全问题。同时，BuildKit 引擎还支持签名和加密等安全功能，保护用户的构建数据和镜像。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;platforms&#34;&gt;Docker buildx 支持哪些平台？&lt;/h2&gt;
&lt;p&gt;Docker buildx 支持的平台主要包括以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。&lt;/li&gt;
&lt;li&gt;Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。&lt;/li&gt;
&lt;li&gt;macOS：支持 Intel、Apple M1 架构。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了以上平台外，Docker buildx 还支持构建和输出多种其他平台的 Docker 镜像，包括 FreeBSD、Solaris 等。用户可以通过指定对应的 &lt;code&gt;platform&lt;/code&gt; 参数来构建和输出不同平台的 Docker 镜像，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个命令将会构建一个同时支持 x86_64 和 ARM64 架构的 Docker 镜像。用户也可以通过指定不同的 buildx 构建配置来支持更多的平台，例如使用 qemu-user-static 等模拟器来支持其他的 CPU 架构。总之，Docker buildx 的多平台支持非常强大，为跨平台开发和分发应用程序提供了便利。&lt;/p&gt;
&lt;h2 id=&#34;arch&#34;&gt;Docker buildx 引擎的架构与组成&lt;/h2&gt;
&lt;p&gt;Docker buildx 引擎的架构是一个分布式的构建系统，通过多阶段、多组件的设计，实现了高性能、多平台支持、安全性等优点，为 Docker 镜像构建和应用程序构建提供了强大的支持。它由以下几个主要组成部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CLI：提供了命令行接口，用户可以通过命令行来执行构建任务、管理构建配置等操作。&lt;/li&gt;
&lt;li&gt;BuildKit 引擎：作为 Docker buildx 的构建引擎，它负责执行构建任务，生成 Docker 镜像等。BuildKit 引擎具有高性能、多平台支持、安全性等优点。&lt;/li&gt;
&lt;li&gt;构建器（Builder）：构建器是一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。在 Docker buildx 中，可以配置多个构建器，以支持多个平台和多个构建环境。&lt;/li&gt;
&lt;li&gt;并行器（Scheduler）：并行器是负责协调和管理多个构建器的组件，它可以自动选择最佳的构建器执行构建任务，并将任务分配给合适的构建器。并行器还可以执行构建任务的并行处理，提高构建效率。&lt;/li&gt;
&lt;li&gt;缓存管理器（Cache Manager）：缓存管理器是负责管理构建过程中的缓存数据，可以快速执行增量构建，减少构建时间。在 Docker buildx 中，缓存管理器可以自动选择合适的缓存方案，包括本地缓存和远程缓存等。&lt;/li&gt;
&lt;li&gt;输出器（Exporter）：输出器负责将构建生成的 Docker 镜像输出到指定的仓库或者本地文件系统中。在 Docker buildx 中，输出器可以自动识别当前平台和目标平台，选择合适的镜像格式和输出路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;command&#34;&gt;docker buildx 命令的使用&lt;/h2&gt;
&lt;p&gt;使用 docker buildx 命令可以方便地进行 Docker 镜像的构建和输出。下面是一些常用的 docker buildx 命令及其用法：&lt;/p&gt;
&lt;p&gt;查看当前的 buildx 构建器列表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建新的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx create --name mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切换到指定名称的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx use mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;设置 buildx 构建器的平台支持&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx inspect --bootstrap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx inspect --platform
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;构建 Docker 镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --tag myimage .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出 Docker 镜像到本地文件系统&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --output&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出 Docker 镜像到 Docker Hub 或其他远程仓库&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --tag myrepo/myimage --push .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除指定名称的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx rm mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了以上命令外，docker buildx 还支持许多其他的参数和选项，例如设置构建缓存、并行处理、构建标签等。用户可以通过查看官方文档或者使用 &amp;ndash;help 选项来了解更多详情。&lt;/p&gt;
&lt;h2 id=&#34;builder&#34;&gt;理解 buildx 构建器&lt;/h2&gt;
&lt;p&gt;在 Docker 中，构建器（Builder）是指一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。Docker buildx 构建器是指使用 BuildKit 引擎的多平台构建器，可以通过 Docker CLI 命令进行管理和操作。在使用 Docker buildx 构建器时，用户可以配置多个构建器，以支持多个平台和多个构建环境。&lt;/p&gt;
&lt;p&gt;用户可以通过创建、切换、查看和删除构建器，来管理和维护 Docker buildx 的构建环境。构建器的主要作用是提供一个干净、独立的构建环境，避免构建过程中的依赖冲突和环境污染。此外，构建器还可以方便地进行版本管理和共享，以便多个用户或者团队协同构建 Docker 镜像。&lt;/p&gt;
&lt;p&gt;Docker buildx 构建器还支持多平台构建，用户可以在同一个构建器中设置多个平台，以便生成跨平台的 Docker 镜像。通过 Docker buildx 构建器，用户可以轻松实现 Docker 镜像的多平台构建，提高构建效率和应用程序的兼容性。&lt;/p&gt;
&lt;h2 id=&#34;where-is-my-images&#34;&gt;为什么本地看不到 Docker buildx 构建的镜像？&lt;/h2&gt;
&lt;p&gt;这通常是因为你当前使用的 Docker context 不支持编译出来的镜像架构。例如 &lt;a href=&#34;https://orbstack.dev/&#34; title=&#34;Orbstack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Orbstack&lt;/a&gt;，虽然它支持编译跨平台的镜像，但是执行 &lt;code&gt;docker buildx&lt;/code&gt; 构建出来的镜像不会直接保存在本地的 Docker 镜像仓库中，而是保存在构建器（Builder）的缓存中。这是因为 Docker buildx 采用了分层构建的方式，构建出的每一层镜像都可以被重用，以减少构建时间和磁盘空间的占用。&lt;/p&gt;
&lt;p&gt;你应该使用 &lt;code&gt;docker context&lt;/code&gt; 命令切换会 Docker 默认的上下文环境再执行构建，这样构建出来的跨平台镜像就可以在本地看见了。&lt;/p&gt;
&lt;h2 id=&#34;local-storage&#34;&gt;如何将多平台镜像保存到本地？&lt;/h2&gt;
&lt;p&gt;要将 Docker buildx 构建的多平台镜像保存到本地，可以使用 &lt;code&gt;--output&lt;/code&gt; 选项指定输出类型为 &lt;code&gt;type=local&lt;/code&gt;，并指定输出目录，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 --output &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述命令将构建包含 &lt;code&gt;linux/amd64&lt;/code&gt; 和 &lt;code&gt;linux/arm64&lt;/code&gt; 两种平台的镜像，并将输出类型设置为本地（&lt;code&gt;type=local&lt;/code&gt;），输出目录为 &lt;code&gt;./output&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;构建完成后，输出目录中会生成多个子目录，每个子目录分别对应一个平台，其中包含该平台下的镜像文件。&lt;/p&gt;
&lt;p&gt;如果只想保存其中一个平台的镜像，可以在 &lt;code&gt;--output&lt;/code&gt; 选项中指定要保存的平台，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 --output &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output/linux/amd64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述命令将只保存 &lt;code&gt;linux/amd64&lt;/code&gt; 平台的镜像，输出到 &lt;code&gt;./output/linux/amd64&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;--output&lt;/code&gt; 选项只支持部分输出类型，如果要将镜像保存到其他类型的输出（例如 tar 包、OCI 存储、Docker registry 等），需要使用其他的输出插件和选项。具体细节可以参考 &lt;a href=&#34;https://docs.docker.com/build/building/multi-platform/&#34; title=&#34;Docker 官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;wasm&#34;&gt;如何使用构建 Wasm 镜像？&lt;/h2&gt;
&lt;p&gt;WebAssembly 是一种中间代码格式，需要使用编译器将源代码编译为 WebAssembly 格式的二进制文件，再将其打包成镜像。以下是构建 WebAssembly 镜像的一般步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写 WebAssembly 源代码，并使用编译器将其编译为 WebAssembly 格式的二进制文件。例如使用 Rust 编写代码，并使用 Cargo 编译出 &lt;code&gt;.wasm&lt;/code&gt; 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写 Dockerfile 将 Wasm 二进制文件添加到空镜像中。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# syntax=docker/dockerfile:1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; ./target/wasm32-wasi/debug/hello-wasm.wasm /hello.wasm&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hello.wasm&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;docker buildx&lt;/code&gt; 命令构建镜像，例如 &lt;code&gt;docker buildx build --platform wasi/wasm32 -t jimmysong/hello-wasm .&lt;/code&gt;  将在本地构建。若你想将该镜像同时同时推送到 Docker Hub，可以在命令中加上 &lt;code&gt;--push&lt;/code&gt;标志。基于 WebAssembly 平台的镜像并上传到 Docker Hub。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;notice&#34;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;除了构建多平台镜像、导出和加载镜像外，还有一些 Docker buildx 命令的常用操作及注意事项，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-progress&lt;/code&gt; 选项：可以使用 &lt;code&gt;-progress&lt;/code&gt; 选项指定构建过程的输出格式，包括 &lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;plain&lt;/code&gt;、&lt;code&gt;tty&lt;/code&gt; 三种格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-no-cache&lt;/code&gt; 选项：可以使用 &lt;code&gt;-no-cache&lt;/code&gt; 选项禁用构建过程中的缓存机制，强制重新构建镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-push&lt;/code&gt; 选项：可以使用 &lt;code&gt;-push&lt;/code&gt; 选项将构建的镜像推送到 Docker registry 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tag&lt;/code&gt; 选项：可以使用 &lt;code&gt;-tag&lt;/code&gt; 选项为构建的镜像指定标签。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-file&lt;/code&gt; 选项：可以使用 &lt;code&gt;-file&lt;/code&gt; 选项指定 Dockerfile 文件的路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-build-arg&lt;/code&gt; 选项：可以使用 &lt;code&gt;-build-arg&lt;/code&gt; 选项传递构建参数给 Dockerfile 中的指令。&lt;/li&gt;
&lt;li&gt;构建上下文的注意事项：构建上下文指的是 Dockerfile 文件所在的目录，以及构建过程中需要用到的其他文件。在构建过程中需要尽量减少构建上下文的大小，避免构建过程中传输大量不必要的文件。可以使用 &lt;code&gt;.dockerignore&lt;/code&gt; 文件排除不需要传输的文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，Docker buildx 是一个比较新的命令，不同版本的 Docker Engine 可能会存在差异，因此在使用时需要注意查阅官方文档，并根据实际情况进行操作。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>2022 年容器生态系统的 9 大趋势洞察</title>
      <link>https://jimmysong.io/trans/container-insights-2022/</link>
      <pubDate>Mon, 07 Nov 2022 10:16:27 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/container-insights-2022/</guid>
      <description>
        
        
        &lt;p&gt;这项研究建立在 Datadog 以前版本的&lt;a href=&#34;https://www.datadoghq.com/container-report-2021/&#34; title=&#34;容器使用报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;容器使用报告&lt;/a&gt;、&lt;a href=&#34;https://www.datadoghq.com/container-orchestration-2018/&#34; title=&#34;容器编排报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;容器编排报告&lt;/a&gt;和&lt;a href=&#34;https://www.datadoghq.com/docker-adoption/&#34; title=&#34;Docker 研究报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 研究报告&lt;/a&gt;的基础上。&lt;/p&gt;
&lt;p&gt;现代工程团队继续扩展他们对容器的使用，如今基于容器的微服务应用程序无处不在。不断增长的容器使用正在推动组织采用互补技术来简化他们操作集群的方式，而这种不断扩展的容器环境给组织带来了安全挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在本报告中，我们检查了数万 Datadog 客户&lt;/strong&gt;运行的超过&lt;strong&gt;15 亿个容器&lt;/strong&gt;，以了解容器生态系统的状态。继续阅读，了解从最新的实际使用数据中收集的更多见解和趋势。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“这项调查表明，容器和 Kubernetes 革命正在不断发展壮大。结果揭示了使用容器和 Kubernetes 的云原生组织不仅发展得更快，而且获得了更大的信心——在比以往任何时候都更关键的生产环境中构建和部署更大型的应用程序和工作负载。&lt;/p&gt;
&lt;p&gt;得益于云原生生态系统中超过 175,000 名贡献者所推动的创新，云原生组织已为前进的道路做好了准备。他们正在创造可以让各种规模的工程团队都可以构建和运行应用程序的技术，以满足当今应用程序的需求。”&lt;/p&gt;
&lt;p&gt;— Priyanka Sharma，云原生计算基金会执行董事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-1kubernetes-继续成为最受欢迎的容器管理系统&#34;&gt;趋势 1：Kubernetes 继续成为最受欢迎的容器管理系统&lt;/h2&gt;
&lt;p&gt;Kubernetes 比以往任何时候都更受欢迎。如今，近一半的容器组织运行 Kubernetes 来在不断发展的生态系统中部署和管理容器。Amazon Elastic Kubernetes Services (Amazon EKS) Blueprints 和 Amazon EKS Anywhere 等工具以及其他托管 Kubernetes 服务使团队可以轻松地在云中和本地运行 Kubernetes 集群。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757_hu1112805345294683638.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;“在 AWS，我们致力于为客户提供简化的 Kubernetes 体验，以便他们可以轻松管理和扩展集群，同时受益于完全托管的 AWS 服务的安全性和弹性。Amazon EKS Blueprints 和 Amazon EKS Anywhere 等新功能使客户能够更快、更轻松地跨 AWS 和本地环境配置和部署 Kubernetes 集群，因此他们可以在任何需要的地方获得相同、一致的 Amazon EKS 体验，以最好地支持他们的应用程序和最终用户。”&lt;/p&gt;
&lt;p&gt;— Barry Cooks，Amazon Web Services Kubernetes 副总裁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-2无服务器容器技术在所有主要公共云中继续流行&#34;&gt;趋势 2：无服务器容器技术在所有主要公共云中继续流行&lt;/h2&gt;
&lt;p&gt;所有主要云提供商（包括 AWS App Runner、AWS Fargate、Azure Container Apps、Azure Container Instances (ACI) 和 Google Cloud Run）对无服务器容器技术的使用率从 2020 年的 21% 增加到 2022 年的 36%（年初至今）。这与我们在之前的研究中看到的增长相呼应，其中包括 Amazon ECS 用户转向 AWS Fargate。&lt;/p&gt;
&lt;p&gt;客户将减少配置和管理底层基础设施的需求列为容器采用无服务器技术的主要原因之一。那些不使用无服务器技术的客户更喜欢从管理自己的基础架构中获得的控制力和灵活性。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff_hu15847146681977651338.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-3多个云提供商的使用随着组织规模的增加而增加&#34;&gt;趋势 3：多个云提供商的使用随着组织规模的增加而增加&lt;/h2&gt;
&lt;p&gt;我们的数据显示，超过 30% 的使用 1,000 台或更多主机的容器组织在多个云中工作，并且组织运行的容器越少，多云使用率最低。此外，我们发现多云组织平均拥有比单云组织更多的容器。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750_hu15946864826546565745.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-4kubernetes-ingress-使用率正在上升&#34;&gt;趋势 4：Kubernetes Ingress 使用率正在上升&lt;/h2&gt;
&lt;p&gt;为了大规模管理来自集群外部的请求，管理员经常使用 Ingress 来配置到集群中多个服务的路由。如今，超过 35% 的组织使用 Ingress，自 2020 年 8 月 Kubernetes 1.19 版本发布以来，Ingress 已经普遍可用。&lt;/p&gt;
&lt;p&gt;随着我们的客户操作更多的集群和 Pod，他们在路由和网络管理方面面临着越来越复杂的问题。许多 Kubernetes 的早期采用者使用云提供的负载均衡器将流量路由到他们的服务。但 Ingress 通常更具成本效益，并且自发布以来其采用率稳步提高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; title=&#34;Kubernetes Gateway API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Gateway API&lt;/a&gt;（于 2022 年 7 月完成测试版）是容器网络管理发展的下一步。Gateway API 提供高级网络功能，包括使用自定义资源和使用 API 资源对组织角色建模的面向角色的设计。我们期待看到 Gateway API 是否会取代 Ingress，或者这两种技术是否并排使用。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs_hu6134349331553630121.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-5服务网格仍处于早期阶段istio-主导使用&#34;&gt;趋势 5：服务网格仍处于早期阶段，Istio 主导使用&lt;/h2&gt;
&lt;p&gt;服务网格提供服务发现、负载均衡、超时和重试，并允许管理员管理集群的安全性并监控其性能。我们之前的研究说明了服务网格的早期采用，我们看到的初始模式基本上没有变化。在我们的客户中，我们主要看到 Istio 和 Linkerd，其中 Istio 的受欢迎程度是 Linkerd 的三倍多。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3_hu10769435947553115440.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;“服务网格已经证明了为企业中的流量提供一致的安全性、可观测性和控制的价值。Istio 已明确将自己确立为领先的网格解决方案，我为社区为实现这一目标所做的工作感到自豪。最近完成的对 CNCF 的 Istio 捐赠将在这一成功的基础上发展壮大我们的社区。”&lt;/p&gt;
&lt;p&gt;——Louis Ryan，Istio 的联合创始人兼谷歌首席工程师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-6大多数主机使用超过-18-个月的-kubernetes-版本&#34;&gt;趋势 6：大多数主机使用超过 18 个月的 Kubernetes 版本&lt;/h2&gt;
&lt;p&gt;Kubernetes 每年发布三个新版本，为用户提供新功能、安全改进和错误修复。我们在之前的研究中看到，用户通常更愿意等待一年多才能采用这些新版本。我们从轶事中了解到，一些客户延迟的原因是为了确保他们的集群的稳定性和与 API 版本的兼容性。如今，使用最多的版本是 v1.21，它于 2021 年 4 月发布，并于今年早些时候正式过了生命周期终结日。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5_hu292296945437327998.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-7超过-30-的运行-containerd-的主机使用不受支持的版本&#34;&gt;趋势 7：超过 30% 的运行 containerd 的主机使用不受支持的版本&lt;/h2&gt;
&lt;p&gt;先前的研究表明 containerd 的使用有所增加，这是组织可以采用的符合 CRI 的运行时之一，因为 Dockershim 正在被弃用。我们发现只有大约 69% 的 containerd 主机使用的是 1.5 或 1.6 版本，这是积极支持的版本。值得注意的是，大约 31% 的 containerd 主机正在使用 1.4 或更早的版本，这些版本已经过了生命周期的终结日。&lt;/p&gt;
&lt;p&gt;运行较旧的软件版本会带来有关安全性和合规性的问题，并且在容器运行时的情况下，会带来容器逃逸等漏洞的风险。许多主机使用不受支持的容器运行时版本这一事实凸显了组织在运行适当的工具以维护容器安全性和合规性方面面临的挑战。无服务器容器技术降低了过时运行时的风险和手动更新的负担，这可能是我们看到所有云都转向无服务器容器的原因之一。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y_hu9297096922906586071.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-8访问管理正在改进但仍然是一个挑战&#34;&gt;趋势 8：访问管理正在改进，但仍然是一个挑战&lt;/h2&gt;
&lt;p&gt;Kubernetes 管理员使用基于角色的访问控制 (RBAC) 来允许主体（用户、组或服务账户）访问或修改集群中的资源。根据安全最佳实践，主体应该只有必要的权限，并且管理员在授予与升级风险相关的 RBAC 权限时必须谨慎。其中包括允许主体列出所有机密或创建工作负载、证书或令牌请求的权限，这些请求可以允许他们修改自己的权限。&lt;/p&gt;
&lt;p&gt;好消息是，随着组织部署更多集群，这些集群中使用过度宽松特权的百分比正在下降。我们怀疑随着组织采用权限审计等安全实践和自动化 RBAC 扫描仪等工具，这一数字正在下降。但是，我们发现大约 40% 的集群仍然使用宽松的权限，这会带来安全风险。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l_hu5740461901553145809.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;趋势-9nginxredis-和-postgres-再次成为最受欢迎的容器镜像&#34;&gt;趋势 9：NGINX、Redis 和 Postgres 再次成为最受欢迎的容器镜像&lt;/h2&gt;
&lt;p&gt;截至 2022 年 9 月，最流行的现成容器镜像是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NGINX：这又是最流行的容器镜像。NGINX 为近 50% 的使用容器的组织提供缓存、负载平衡和代理功能。&lt;/li&gt;
&lt;li&gt;Redis：组织可以在容器中部署 Redis，用作键值数据存储、缓存或消息代理。&lt;/li&gt;
&lt;li&gt;Postgres：这个关系数据库的使用比去年略有增长。&lt;/li&gt;
&lt;li&gt;Elasticsearch：这个高性能的文档存储和搜索引擎仍然是最流行的镜像之一。&lt;/li&gt;
&lt;li&gt;Kafka：组织可以通过在容器中部署 Kafka 轻松地将事件流功能添加到应用程序中。&lt;/li&gt;
&lt;li&gt;RabbitMQ：RabbitMQ 在基于微服务的应用程序中支持解耦架构。&lt;/li&gt;
&lt;li&gt;MongoDB：MongoDB 仍然是最流行的 NoSQL 数据库之一。&lt;/li&gt;
&lt;li&gt;MySQL：这个开源数据库的排名比以前低。但是 MySQL 的性能和可扩展性使其在最流行的容器镜像列表中持续占有一席之地。&lt;/li&gt;
&lt;li&gt;Calico：Calico 是一个网络提供商，让管理员可以管理其 Kubernetes 集群内网络的安全性。&lt;/li&gt;
&lt;li&gt;GitLab：为了帮助团队采用和维护 DevOps 实践，GitLab 提供了存储库管理、问题跟踪和 CI/CD 管道。&lt;/li&gt;
&lt;li&gt;Vault：团队可以使用 Vault 来简化机密管理并帮助维护安全的应用程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh_hu12643890304646640527.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;在 Kubernetes StatefulSets 中，我们发现 Redis、Postgres、Elasticsearch、RabbitMQ 和 Kafka 是最常部署的镜像。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d_hu1944301267502364044.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d.jpg&#34; data-img=&#34;/trans/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d.jpg&#34; data-width=&#34;750&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;

      </description>
    </item>
    
  </channel>
</rss>
