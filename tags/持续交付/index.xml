<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 持续交付</title>
    <link>https://jimmysong.io/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/</link>
    <description>Recent content in 持续交付 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>rootsongjc@gmail.com (Jimmy Song)</managingEditor>
    <webMaster>rootsongjc@gmail.com (Jimmy Song)</webMaster>
    <lastBuildDate>Fri, 30 Nov 2018 19:06:35 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/index.xml" rel="self" type="application/rss+xml" />
    
    
      
         
        
                                                         
                                                         
                           
    <item>
      <title>软件定义交付（SDD）宣言</title>
      <link>https://jimmysong.io/blog/software-defined-delivery-manifesto/</link>
      <pubDate>Fri, 30 Nov 2018 19:06:35 +0800</pubDate>
      <author>rootsongjc@gmail.com (Jimmy Song)</author>
      <guid>https://jimmysong.io/blog/software-defined-delivery-manifesto/</guid>
      <description>
        
        
        &lt;p&gt;今天给大家分享的是《软件定义交付宣言》，该宣言发出已经有一周多时间了，目前该宣言的官方网站（&lt;code&gt;https://sdd-manifesto.org/&lt;/code&gt; 已停止维护）还在联署签名中。&lt;/p&gt;
&lt;p&gt;云原生通过不可变基础设施与声明式配置，作为了软件定义交付的基础，再假以持续交付工具可以极大的提高软件交付效率，本宣言的起草者中包含众多云原生理念的鉴定拥护者如 Kenny Bastani、Matt Stine 等。&lt;/p&gt;
&lt;p&gt;该宣言通过 GitHub 协作草拟（&lt;a href=&#34;https://github.com/sdd-manifesto/manifesto&#34; title=&#34;https://github.com/sdd-manifesto/manifesto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/sdd-manifesto/manifesto&lt;/a&gt;），仍未达到 1.0 版本。下面是《软件定义交付宣言》的中文版。&lt;/p&gt;
&lt;h2 id=&#34;软件定义交付宣言&#34;&gt;软件定义交付宣言&lt;/h2&gt;
&lt;p&gt;我们从日常生产和实践中认识到软件塑造了我们的世界。我们认识到代码才是指定精确操作的最佳方式。我们认识到代码仅在被交付时才有用。&lt;/p&gt;
&lt;p&gt;开发的软件被能够被交付出去就软件本身存在的目的。现在是时候将我们的核心技能应用到实际的工作中去了。是时候对交付去做出 &lt;em&gt;设计&lt;/em&gt; 了。我们将区别人类和计算机在交付工作中承担的作用：人类做决策，计算机来完成自动化任务。&lt;/p&gt;
&lt;p&gt;每一次交付工作本质上都是独一无二的。应用程序、组织、部署环境和团队组合千差万别。我们认识到每个团队都需要能够理解这种交付的独特性和对交付做自动化。我们认识到，虽然持续交付对满足业务需求至关重要，但自动执行所有重复任务也非常重要。&lt;/p&gt;
&lt;p&gt;我们使用与加速应用程序开发类似的方式来加速软件交付：使用现代架构和编程语言，通用功能的框架、库和服务。&lt;/p&gt;
&lt;p&gt;交付基础设施现在是可编程的，我们将对其进行编程。&lt;/p&gt;
&lt;h2 id=&#34;软件定义交付是指&#34;&gt;软件定义交付是指&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;核心&lt;/strong&gt;：交付是每个软件团队和组织的基础和战略能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优先&lt;/strong&gt;：交付的代码是生产代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;战略&lt;/strong&gt;：决定团队和组织层面的策略；在代码中实现精确控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不断发展&lt;/strong&gt;：不断改进交付。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工程设计&lt;/strong&gt;：强大，可测试的代码。70 年代的脚本语言是不够的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;现代软件架构&lt;/strong&gt;：事件驱动和可扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;现代编程语言&lt;/strong&gt;：逻辑最好用代码指定，而不是图片或 GUI。脚本不好扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于模型&lt;/strong&gt;：由软件领域的模型支持，具有对代码的理解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可测试&lt;/strong&gt;：在生产之前启用小规模应用以发现错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;协作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从群众中来&lt;/strong&gt;：所有人都可以在代码中表述自己的专业知识，这对大家都有利。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;到软件中去&lt;/strong&gt;：使用最好的工具，但将它们结合起来之后就是独一无二的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在人与软件之间&lt;/strong&gt;：协同自动化可以增强我们的感知和帮助我们做决策。将信息落实到行动，使我们能够体察软件的自动化行为。通过代码来区分团队的共享交付目标集及其实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加速&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通过自动化&lt;/strong&gt;：自动执行重复任务，加快了工作速度还可以避免错误发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过重用&lt;/strong&gt;：在开发人员、团队和组织之间共享通用功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可观测性&lt;/strong&gt;：通常用于观察和排除作为生产系统的交付过程中发生的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跟踪&lt;/strong&gt;：观察系统中的活动并跟踪操作之间的关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试&lt;/strong&gt;：检查和与交付流程交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指标&lt;/strong&gt;：在整个交付流程的活动中获取指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt;：(姓氏按字母顺序排列）：本宣言由 Kenny Bastani、Marc Holmes、Rod Johnson、Jessica Kerr、Mik Kersten、Russ Miles、Erin Schnabel、Matt Stine 及其他社区成员草拟。&lt;/p&gt;
&lt;p&gt;©2018，上述作者和本声明可以任何形式自由复制，但需全文复制本声明。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>适用于 Kubernetes 的应用开发与部署流程详解</title>
      <link>https://jimmysong.io/blog/deploy-applications-in-kubernetes/</link>
      <pubDate>Thu, 20 Jul 2017 19:41:53 +0800</pubDate>
      <author>rootsongjc@gmail.com (Jimmy Song)</author>
      <guid>https://jimmysong.io/blog/deploy-applications-in-kubernetes/</guid>
      <description>
        
        
        &lt;p&gt;本文已归档在&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; title=&#34;kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-handbook&lt;/a&gt;中的第 3 章【用户指南】中，一切更新以 kubernetes-handbook 中为准。&lt;/p&gt;
&lt;p&gt;为了详细说明，我特意写了两个示例程序放在 GitHub 中，模拟应用开发流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/k8s-app-monitor-test&#34; title=&#34;k8s-app-monitor-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s-app-monitor-test&lt;/a&gt;：生成模拟的监控数据，发送 http 请求，获取 json 返回值&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/k8s-app-monitor-agent&#34; title=&#34;K8s-app-monitor-agent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;K8s-app-monitor-agent&lt;/a&gt;：获取监控数据并绘图，访问浏览器获取图表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 文档见&lt;a href=&#34;https://github.com/rootsongjc/k8s-app-monitor-test&#34; title=&#34;k8s-app-monitor-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s-app-monitor-test&lt;/a&gt;中的&lt;code&gt;api.html&lt;/code&gt;文件，该文档在 API blueprint 中定义，使用&lt;a href=&#34;https://github.com/danielgtaylor/aglio&#34; title=&#34;aglio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aglio&lt;/a&gt;生成，打开后如图所示：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-test-api-doc_hu73bc232b740be39d3b06697e0b199e1b_39338_958x941_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-test-api-doc.jpg&#34; data-img=&#34;/blog/deploy-applications-in-kubernetes/k8s-app-monitor-test-api-doc.jpg&#34; data-width=&#34;958&#34; data-height=&#34;941&#34; alt=&#34;image&#34; data-caption=&#34;API 文档&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;API 文档&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;关于服务发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K8s-app-monitor-agent&lt;/code&gt;服务需要访问&lt;code&gt;k8s-app-monitor-test&lt;/code&gt;服务，这就涉及到服务发现的问题，我们在代码中直接写死了要访问的服务的内网 DNS 地址（kubedns 中的地址，即&lt;code&gt;k8s-app-monitor-test.default.svc.cluster.local&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;我们知道 Kubernetes 在启动 Pod 的时候为容器注入环境变量，这些环境变量在所有的 namespace 中共享（环境变量是不断追加的，新启动的 Pod 中将拥有老的 Pod 中所有的环境变量，而老的 Pod 中的环境变量不变）。但是既然使用这些环境变量就已经可以访问到对应的 service，那么获取应用的地址信息，究竟是使用变量呢？还是直接使用 DNS 解析来发现？&lt;/p&gt;
&lt;p&gt;答案是使用 DNS，详细说明见&lt;a href=&#34;https://jimmysong.io/blog/exploring-kubernetes-env-with-docker/&#34; title=&#34;Kubernetes 中的服务发现与 Docker 容器间的环境变量传递源码探究&#34;&gt;Kubernetes 中的服务发现与 Docker 容器间的环境变量传递源码探究&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打包镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我使用 wercker 自动构建，构建完成后自动打包成 docker 镜像并上传到 docker hub 中（需要提前在 docker hub 中创建 repo），如何使用 wercker 做持续构建与发布，并集成 docker hub 插件请参考&lt;a href=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/&#34; title=&#34;使用 Wercker 进行持续构建与发布&#34;&gt;使用 Wercker 进行持续构建与发布&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://app.wercker.com/jimmysong/k8s-app-monitor-agent/&#34; title=&#34;查看详细构建流程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看详细构建流程&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent-wercker_hub9c0e50fdb57d51b987a72e16255d0e2_82839_3316x1536_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent-wercker.jpg&#34; data-img=&#34;/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent-wercker.jpg&#34; data-width=&#34;3316&#34; data-height=&#34;1536&#34; alt=&#34;image&#34; data-caption=&#34;wercker&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;wercker&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;生成了如下两个 docker 镜像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jimmysong/k8s-app-monitor-test:latest&lt;/li&gt;
&lt;li&gt;jimmysong/k8s-app-monitor-agent:latest&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;启动服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 kubernetes 应用启动所用的 yaml 配置文件都保存在那两个 GitHub 仓库的&lt;code&gt;manifest.yaml&lt;/code&gt;文件中。&lt;/p&gt;
&lt;p&gt;分别在两个 GitHub 目录下执行&lt;code&gt;kubectl create -f manifest.yaml&lt;/code&gt;即可启动服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外部访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务启动后需要更新 ingress 配置，在&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook/blob/master/manifests/traefik-ingress/ingress.yaml&#34; title=&#34;ingress.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress.yaml&lt;/a&gt;文件中增加以下几行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;k8s-app-monitor-agent.jimmysong.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;k8s-app-monitor-agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;保存后，然后执行&lt;code&gt;kubectl replace -f ingress.yaml&lt;/code&gt;即可刷新 ingress。&lt;/p&gt;
&lt;p&gt;修改本机的&lt;code&gt;/etc/hosts&lt;/code&gt;文件，在其中加入以下一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;172.20.0.119 k8s-app-monitor-agent.jimmysong.io&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然你也可以加入到 DNS 中，为了简单起见我使用 hosts。&lt;/p&gt;
&lt;p&gt;详见&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook/blob/master/practice/edge-node-configuration.md&#34; title=&#34;边缘节点配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;边缘节点配置&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在浏览器中访问 &lt;a href=&#34;http://k8s-app-monitor-agent.jimmysong.io&#34; title=&#34;http://k8s-app-monitor-agent.jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://k8s-app-monitor-agent.jimmysong.io&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent_hu578b91404b6091d13500e74302b80bca_56093_1015x579_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent.jpg&#34; data-img=&#34;/blog/deploy-applications-in-kubernetes/k8s-app-monitor-agent.jpg&#34; data-width=&#34;1015&#34; data-height=&#34;579&#34; alt=&#34;image&#34; data-caption=&#34;图表&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图表&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;刷新页面将获得新的图表。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/&#34; title=&#34;使用 Wercker 进行持续构建与发布&#34;&gt;使用 Wercker 进行持续构建与发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://app.wercker.com/jimmysong/k8s-app-monitor-agent/&#34; title=&#34;示例的项目代码服务器端&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;示例的项目代码服务器端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/k8s-app-monitor-agent&#34; title=&#34;示例项目代码前端&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;示例项目代码前端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/&#34; title=&#34;kubernetes-handbok&#34;&gt;kubernetes-handbok&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook/blob/master/practice/edge-node-configuration.md&#34; title=&#34;边缘节点配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;边缘节点配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
