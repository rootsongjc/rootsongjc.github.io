<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Envoy - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/envoy/" />
  <meta property="og:title" content="Envoy | Jimmy Song" />
  <meta property="twitter:title" content="Envoy | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/envoy/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Envoy
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/09/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy 代理如何处理用户请求以实现追踪', '深入探讨 Envoy 代理在云原生环境中如何处理用户请求，实现分布式追踪，提升应用可观测性。', '\n在云原生环境中，提升对应用程序的可观测性以更好地理解用户体验是至关重要的。然而，单纯依靠指标和日志无法提供个别案例的具体细节。这时，追踪（Tracing）技术就显得尤为重要。\n\n## 追踪的基本原理\n\n追踪通过为每个用户请求附加一个关联 ID，向开发人员提供完整的用户体验上下文。这个关联 ID 就像一根线，将跨越多个服务的追踪串联起来，从而实现全面的可观测性。\n\n下图展示了 Envoy 处理用户请求的流程。\n\n\u0060\u0060\u0060mermaid \u0022用户请求与 Envoy 代理的处理流程图\u0022\nsequenceDiagram\n    participant 用户\n    participant Envoy\n    participant 应用程序\n    participant 后端\n\n    %% 用户发送带有各种头部的初始请求\n    用户-\u003e\u003eEnvoy: 用户请求（包含头部：Host, X-User-Identity, X-B3-TraceId）\n\n    %% Envoy 将请求转发给应用程序\n    Envoy-\u003e\u003e应用程序: 转发请求（带头部）\n\n    %% 应用程序处理请求并发出外部请求\n    应用程序-\u003e\u003eEnvoy: 外部请求（发往后端，带头部）\n    Envoy-\u003e\u003e后端: 转发请求（X-B3-TraceId: 1234, X-User-Identity）\n\n    %% 后端对外部请求做出响应\n    后端-\u003e\u003eEnvoy: 对应用程序请求的响应\n    Envoy-\u003e\u003e应用程序: 转发响应\n\n    %% 应用程序处理响应并将响应发送回用户\n    应用程序-\u003e\u003eEnvoy: 对用户请求的响应\n    Envoy-\u003e\u003e用户: 转发响应（给原始用户请求）\n\n    %% 处理多个并发请求\n    用户-\u003e\u003eEnvoy: 多个并发请求\n    Envoy-\u003e\u003e应用程序: 转发多个请求\n    应用程序-\u003e\u003eEnvoy: 转发响应\n    Envoy-\u003e\u003e用户: 多个并发响应\n\u0060\u0060\u0060\n\n![用户请求与 Envoy 代理的处理流程图](98285f54b4811bd9ece87523444f4e02.svg)\n\n**追踪**可以通过为每个用户请求附加一个关联 ID，向开发人员提供完整的用户体验上下文。这个关联 ID 就像一根线，将跨越多个服务的追踪串联起来。\n\n尽管所有请求都会经过 Envoy 代理，但 Envoy 无法独立提供完整的追踪信息。它只看到应用程序作为网络的一部分，无法洞察内部处理。这使得 Envoy 无法区分入站请求和出站请求是否来自同一个用户，因此无法自动转发追踪上下文。\n\n## 服务网格中的请求上下文\n\nEnvoy 可以在 Istio 服务网格中作为 Sidecar 或 Waypoint 代理，下图展示了 Envoy 在服务网格中如何处理请求上下文的。\n\n### 1. 用户请求的开始\n\n追踪涉及通过多个服务跟踪路径，以理解用户体验的完整上下文。追踪从一个用户请求开始，该请求被分配了一个关联 ID。\n\n\u0060\u0060\u0060mermaid \u0022用户请求的开始\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: 请求（包含Headers）\n    Note right of User: Headers:\u003cbr\/\u003e- Host: example.com\u003cbr\/\u003e- X-User-Identity: Base64 Token\u003cbr\/\u003e- X-B3-TraceId: 1234\n\u0060\u0060\u0060\n\n![用户请求的开始](51fd90d791099a4f158c823a821fba6d.svg)\n\n### 2. 请求通过 Envoy 代理\n\nEnvoy 位于应用程序旁边，所有进入的请求都会经过 Envoy。\n\n\u0060\u0060\u0060mermaid \u0022用户请求的开始\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: 发起请求\n    Envoy-\u003e\u003eApplication: 转发请求\n\u0060\u0060\u0060\n\n![用户请求的开始](aebbb0ea064ee93575ec5a1ec9bdf329.svg)\n\n### 3. Envoy 附加额外的 Headers\n\nEnvoy 可以在请求中附加额外的 Headers，以收集关于应用程序内部发生情况的信息。\n\n\u0060\u0060\u0060mermaid \u0022Envoy 附加额外的 Headers\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: 转发请求（附加Headers）\n    Note right of Envoy: 附加Headers:\u003cbr\/\u003e- X-Forwarded-For\u003cbr\/\u003e- X-Forwarded-Client-Cert\n\u0060\u0060\u0060\n\n![Envoy 附加额外的 Headers](7ab35160ac9d07cfdcaa9436b8706548.svg)\n\n### 4. 应用程序处理请求并调用后端服务\n\n应用程序在处理请求的过程中，可能需要联系其他系统来处理该请求。比如外部的认证和授权服务。\n\n\u0060\u0060\u0060mermaid \u0022应用程序处理请求并调用后端服务\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy（出站）\n    participant Backend\n    Application-\u003e\u003eEnvoy2: 调用后端请求\n    Envoy2-\u003e\u003eBackend: 转发请求\n\u0060\u0060\u0060\n\n![应用程序处理请求并调用后端服务](d1016c81280b99d35a642a80caa3af52.svg)\n\n### 5. 应用程序需要复制关联 ID\n\n应用程序知道出站请求是代表哪个入站请求发起的（例如 Trace ID 为 1234 的请求）。但是，Envoy 并不知道这一点。因此，应用程序需要将关联 ID 等上下文从入站请求复制到出站请求中。\n\n\u0060\u0060\u0060mermaid \u0022应用程序需要复制关联 ID\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy（出站）\n    participant Backend\n    Application-\u003e\u003eEnvoy2: 调用后端请求（复制Headers）\n    Note right of Application: 复制Headers:\u003cbr\/\u003e- X-B3-TraceId: 1234\u003cbr\/\u003e- X-User-Identity: Base64 Token\n    Envoy2-\u003e\u003eBackend: 转发请求\n\u0060\u0060\u0060\n\n![应用程序需要复制关联 ID](1409785fdd6f8909dffee3c5bd1b44ba.svg)\n\n### 6. 多个请求的并发处理\n\n在实际场景中，应用程序同时处理多个用户请求，这导致了并发性。由于 Envoy 只能看到网络层面的请求和响应，无法区分这些请求之间的因果关系。\n\n\u0060\u0060\u0060mermaid \u0022多个请求的并发处理\u0022\nsequenceDiagram\n    participant User1\n    participant User2\n    participant Envoy\n    participant Application\n    User1-\u003e\u003eEnvoy: 请求1\n    User2-\u003e\u003eEnvoy: 请求2\n    Envoy-\u003e\u003eApplication: 转发请求1\n    Envoy-\u003e\u003eApplication: 转发请求2\n    Application-\u003e\u003eEnvoy: 响应请求1的出站请求\n    Application-\u003e\u003eEnvoy: 响应请求2的出站请求\n\u0060\u0060\u0060\n\n![多个请求的并发处理](2aebfd544f726da5fe6f4389aed924bd.svg)\n\n### 7. Envoy 的局限性\n\n因为 Envoy 无法看到应用程序内部的处理逻辑，它只能看到一系列的网络请求和响应，无法知道哪些出站请求是由哪些入站请求触发的。\n\n\u0060\u0060\u0060mermaid \u0022Envoy 的局限性\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: 多个请求\n    Application-\u003e\u003eEnvoy: 多个响应\n    Note over Envoy: 无法区分请求的因果关系\n\u0060\u0060\u0060\n\n![Envoy 的局限性](d048f6f9fc9af6f29a9f2e4bfe599613.svg)\n\n## 需要应用程序的参与\n\n由于 Envoy 无法自动转发追踪上下文，应用程序本身需要负责将入站请求的 Headers 复制到出站请求中，以保持追踪信息的完整性。\n\n### 应用程序复制 Headers\n\n应用程序在处理入站请求时，需要将必要的 Headers（如关联 ID、用户身份等）复制到任何出站请求中。\n\n\u0060\u0060\u0060mermaid \u0022应用程序复制 Headers\u0022\nsequenceDiagram\n    participant Application\n    participant Backend\n    Application-\u003e\u003eBackend: 出站请求（包含复制的Headers）\n\u0060\u0060\u0060\n\n![应用程序复制 Headers](d1f00ba65d1c61edf996a19a6b5145d7.svg)\n\n### 响应返回给用户\n\n应用程序完成对用户请求的处理后，将响应返回给用户。\n\n\u0060\u0060\u0060mermaid \u0022响应返回给用户\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy\n    participant User\n    Application-\u003e\u003eEnvoy: 响应\n    Envoy-\u003e\u003eUser: 转发响应\n\u0060\u0060\u0060\n\n![响应返回给用户](ed0816d0cb881c7c7d5eb19e6d0826bf.svg)\n\n## 解决方案与推荐\n\n为了确保追踪信息的完整性，应用程序需要主动复制和传递追踪相关的 Headers。这可以通过集成如 [Apache SkyWalking](https:\/\/skywalking.apache.org\/) 的工具来实现，SkyWalking 不仅支持分布式追踪，还包括性能监控、日志分析等功能。利用 SkyWalking 的库和代理，可以简化 Headers 的复制和追踪信息的传递。\n\n关于如何在 Istio 中使用 SkyWalking 实现分布式追踪详见[这篇博客](\/blog\/distributed-tracing-with-skywalking-in-istio\/)。\n\n## 总结\n\n- **追踪的重要性**：追踪为开发人员提供了用户请求的完整上下文，帮助更好地理解和改进用户体验。\n- **Envoy 的局限性**：Envoy 只能看到网络层面的请求和响应，无法跟踪请求的因果关系，因此无法自动转发追踪上下文。\n- **应用程序的角色**：应用程序需要主动复制和传递追踪相关的 Headers，以确保追踪信息的完整性。\n- **推荐的工具**：使用 SkyWalking 等追踪工具的库，可以简化在应用程序中实现 Headers 复制的过程。\n\n## 参考\n\n- [How the Envoy proxy handles a user request - tetrate.io](https:\/\/tetrate.io\/blog\/how-the-envoy-proxy-handles-a-user-request\/)\n- [如何在 Istio 中使用 SkyWalking 进行分布式追踪？- jimmysong.io](https:\/\/jimmysong.io\/blog\/distributed-tracing-with-skywalking-in-istio\/)\n', '\/blog\/envoy-tracing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入探讨 Envoy 代理在云原生环境中如何处理用户请求，实现分布式追踪，提升应用可观测性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/08/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('集成 Envoy Gateway 作为 Istio 服务网格中的入口网关', '本文介绍了如何将 Envoy Gateway 作为 Istio 服务网格中的入口网关集成，增强应用的安全性和可访问性。', '\n[Istio](https:\/\/istio.io) 提供了对入口网关的强大而灵活的支持，利用 Envoy 代理在其 sidecar 模式下运行。尽管 Istio 专注于管理集群内服务之间的通信，[Envoy Gateway](https:\/\/gateway.envoyproxy.io) 旨在将应用程序暴露给外部世界，处理用户请求，并支持高级功能，如 OIDC 单点登录。通过结合 Istio 服务网格的功能和 Envoy Gateway 的高级网关功能，可以增强整体应用程序的可访问性和安全性。\n\n下图显示了 Istio 网格中入口网关的流量路径。\n\n![Istio 入口网关流量路径](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-ingress-sidecar.svg)\n\n下一个图表显示了在引入 Envoy Gateway 后，流量如何从 Istio 网格的边缘流入内部网络。\n\n![引入 Envoy Gateway 后的流量路径](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-teg-integration.svg)\n\n### 准备 Envoy Gateway 与 Istio 之间的互操作性\n\n要将 Envoy Gateway 用作 Istio 的入口网关，请考虑以下关键点：\n\n- 在 Istio 安装期间避免启用入口网关。我们将手动安装并配置 Envoy Gateway 作为入口网关。\n- 由于 Istio 和 Envoy Gateway 都使用 Envoy 作为代理，确保 Istio 将 Envoy sidecar 注入到 Envoy Gateway 的网关 Pod 中，以允许与 Istio 的数据平面安全通信。\n- 配置由 Envoy Gateway 创建的 Envoy 代理的路由类型为 \u0060Service\u0060 而不是 \u0060Endpoint\u0060，以确保正确路由。\n\n按照 [快速启动文档](https:\/\/gateway.envoyproxy.io\/docs\/tasks\/quickstart\/) 安装 Envoy Gateway。标记 Envoy Gateway 的命名空间以确保数据平面获得 Istio sidecar 注入：\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 的 sidecar 以不拦截进入网关的流量。注入的 sidecar 确保 Envoy Gateway 的组件及其创建的代理被包含在 Istio 网格中，并安装正确的证书以进行安全通信。\n\n{{\u003cinclude_code file=\u0022control-plane-tls.yaml\u0022\u003e}}\n\n应用补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 不拦截入站流量：\n\n{{\u003cinclude_code file=\u0022teg-sidecars-no-inbound.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\n修改 GatewayClass 配置以将 sidecar 配置应用于 Envoy Gateway 数据平面中的所有 \u0060EnvoyProxy\u0060：\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\n应用补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### 安装 Istio\n\n使用 minimal 配置文件部署 Istio 以避免部署入口网关：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### 重启 Envoy Gateway 控制平面\n\n在 Istio 的 sidecar 注入准备好后，重启所有 Envoy Gateway 控制平面的 pod：\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis;\n\tdo kubectl rollout restart deployment -n envoy-gateway-system $d;\ndone\n\u0060\u0060\u0060\n\n### 部署测试应用程序\n\n在安装 Istio 后部署测试应用程序，以确保它们也接收到 sidecar 注入：\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### 配置 Envoy Gateway\n\n现在配置 Envoy Gateway 以处理边缘流量：\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\n部署应用网关，包括以下容器：\n\n- \u0060istio-init\u0060：由 Istio 注入以修改 pod iptables。\n- \u0060envoy\u0060：由 Envoy Gateway 控制，充当入口网关。\n- \u0060istio-proxy\u0060：由 Istio 注入，负责与内部集群 pod 的通信。\n- \u0060shutdown-manager\u0060：由 Envoy Gateway 控制，负责 pod 生命周期管理。\n\n创建一个 HTTP 路由：\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\n应用路由配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### 发送测试请求\n\n获取网关的负载平衡器 IP 地址并发送测试请求：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\n你应该能看到来自 \u0060httpbin\u0060 服务的正确响应：\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### 启用严格 mTLS\n\n通过应用以下配置启用严格 mTLS：\n\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n\n### 为网关启用 TLS\n\n创建服务签名的根证书和私钥：\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\n为 \u0060www.example.com\u0060 创建证书和私钥：\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n为入口网关创建一个密钥：\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential --key=example_certs\/www.example.com.key --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n配置入口网关：\n\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\n发送测试请求：\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\n你应该可以通过 HTTPS 在网格内访问 \u0060httpbin\u0060 服务。\n\n### 结论\n\n通过将 Envoy Gateway 集成为 Istio 服务网格中的入口网关，你可以利用两者的优势：Istio 的强大服务网格能力和 Envoy Gateway 的高级网关功能。这种设置增强了你的应用程序的安全性、可扩展性和灵活性，提供了无缝且安全的用户体验。通过仔细的配置和正确的工具，管理服务网格内外的流量变得更加高效和有效，确保你的应用程序始终可访问并且安全。\n', '\/blog\/envoy-gateway-integration-istio-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何将 Envoy Gateway 作为 Istio 服务网格中的入口网关集成，增强应用的安全性和可访问性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案', '深入了解 Tetrate Enterprise Gateway (TEG) 及其如何与 Istio 服务网格集成 —— 一种基于 Envoy 的企业级网关解决方案，包括它的架构、基本功能以及如何在 Kubernetes 中使用 TEG 来暴露和管理应用。', '\n## TEG 简介\n\nTetrate Enterprise Gateway（TEG）是基于 [Envoy Gateway](https:\/\/gateway.envoyproxy.io\/) (EG) 的企业级解决方案，专门针对 Envoy Proxy 设计，通过 [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 提供更易于消费的 Envoy 代理配置和管理包。TEG 结合了 Kubernetes Gateway API 的特性，支持在 Kubernetes 中轻松暴露服务和应用程序。\n\nTEG 相对于 Envoy Gateway 的主要新增特性包括：\n\n1. **全局速率限制（Rate Limiting）**：TEG 支持基于 IP 5-tuple、请求头等进行流量控制，需要通过 Redis 实例管理。\n2. **WAF 功能（Web Application Firewall）**：TEG 提供了与 \u0060mod_security\u0060 兼容的 WAF 功能，增强了安全防护能力。\n3. **OIDC\/OAuth2认证**：支持在网关级别进行 OIDC\/OAuth2 认证，应用程序可以按路由配置认证方式。\n4. **使用 Kubernetes Gateway API**：相较于其他 API，Kubernetes Gateway API 的设计更加现代，结合了众多 Ingress 实现的经验，将网关的配置与流量的路由分离，使平台所有者可以管理网关，而应用团队可以掌控流量路由。\n\nTEG 将 Envoy 的高级网络流量处理能力带入 Kubernetes 环境，提供了一种简化的方法来部署和管理负载平衡、API 网关功能、安全控制等，同时支持现代的、开放的应用程序暴露 API，如 Kubernetes Gateway API。这些特性使 TEG 成为一个功能丰富、易于管理的企业级网关解决方案。\n\n## TEG 的能力\n\nTetrate Enterprise Gateway for Envoy (TEG) 构建于 Envoy Gateway 项目之上，提供了一种易于使用和操作的入口，具有先进的按请求流量控制功能、与现有环境的轻松集成，以及一流的可观测性，以理解应用流量和入口健康状况。\n\n### 易于安装、操作和升级\n\nTEG 从头到尾注重易用性：从首次安装到启用应用团队，从故障排查到执行升级。TEG 的初始安装只需几分钟，你就可以开始使用高级功能，如速率限制、单点登录和金丝雀流量路由。TEG 还简化了运维流程，与你现有的指标、跟踪和日志记录管道相适应，我们还提供了一个完整的、预配置的可观测性堆栈，以评估 EG 产生的数据，并帮助你计划如何将 TEG 集成到你的现有指标堆栈中。\n\n### 操作性：一流的功能\n\nTEG 由在生产环境中运行大型、关键系统的经验丰富团队构建。TEG 简化了漏洞检查和持续升级过程，与你现有的指标和跟踪提供商轻松集成，并为你现有的 Grafana 部署提供了一套强大的入口可观测性仪表板。\n\n### 与现有的环境集成\n\nTEG 不仅适用于绿地部署的启动，还可以直接与传统环境以及现代云原生环境集成。它可以帮助你在现有的应用生态系统和你正在构建的云原生目标之间架起桥梁。\n\n### 引入现有的可观测性堆栈\n\n你的组织可能已经有一个可观测性系统，你的应用和运营团队已经训练有素地使用它。TEG 可以轻松地嵌入到现有的基础设施中，并在你的组织中运行。TEG 将使 Envoy 的丰富指标集导出，让你的应用团队对其应用流量的行为有最佳的洞察，并看到他们所做配置更改的效果。TEG 还为运行它的平台团队提供了仪表板和警报功能，使你能够自信地操作并快速解决发现的问题。\n\n### 简单的负载平衡\n\nEnvoy 非常强大，但要使其启动并运行简单用例可能很难——像 Istio 这样的系统提供 Envoy 入口管理作为更广泛功能套件的一部分，也附带了许多与简单、流畅的操作体验相冲突的额外功能。这就是 Envoy Gateway 存在的原因：使 Envoy 的强大功能易于用于入口用例。\n\n### 简单的 API 网关\n\n组织中绝大多数 API 网关的使用归结为三件事：认证发起请求的用户；限制用户对服务的访问；在此 API 端点的服务实例之间进行负载平衡。TEG 简化了在传统和云原生环境中完成这三项任务的过程。\n\n## TEG 的架构\n\n下图展示的是 TEG 的架构图。\n\n![TEG 架构图](teg-architecture.svg)\n\n从架构图中可以看出，Tetrate Enterprise Gateway for Envoy (TEG) 的架构设计包括以下主要组件和流程：\n\n### 主要组件\n\n1. **Kubernetes Cluster**\n   - **Envoy Gateway**：作为控制平面，配置和管理 Envoy 代理，消费 Kubernetes Gateway API 的配置。\n   - **Metrics Collection**：使用 Prometheus 或 OpenTelemetry (OTEL) 作为指标收集点，用于监控 Envoy Proxy 的性能和健康状态。\n\n2. **Envoy Proxy**\n   - 作为数据平面，直接处理所有进入的流量，支持基于 Kubernetes Gateway API 的配置。\n\n3. **Coraza WAF**\n   - 作为 TEG 的一部分部署，执行 WAF 规则以保护应用免受恶意请求攻击。\n\n4. **Redis Rate Limit Store**\n   - 作为全局速率限制的存储解决方案，用于跨所有 Envoy 实例维护统一的速率限制计数。\n\n5. **Your OIDC Server**\n   - 处理 OAuth2.0 和 OIDC 认证流程，确保只有经过认证的用户可以访问特定的路由和服务。\n\n### 工作流程\n\n1. **流量入口**\n   - 所有外部流量首先通过上游的负载均衡器，然后被路由到 Envoy Proxy。\n\n2. **Envoy Proxy 处理**\n   - Envoy Proxy 根据 Kubernetes Cluster 中的 Envoy Gateway 的配置处理流量。\n   - 配置信息包括路由规则、安全策略（如 WAF 和速率限制）等。\n\n3. **安全和认证**\n   - **Coraza WAF**：在流量到达应用前，根据配置的 WAF 规则进行检查和过滤，提高安全性。\n   - **OIDC 认证**：OIDC Server 处理认证，Envoy Proxy 根据 OIDC Server 的验证结果决定是否允许访问。\n\n4. **速率限制**\n   - 使用 Redis 存储进行速率限制，Envoy Proxy 将根据从 Redis 获取的数据执行速率限制策略。\n\n5. **性能监控**\n   - Envoy Proxy 的性能和健康状态通过集成的指标收集系统（Prometheus 或 OTEL）进行监控。\n\n### 配置和管理\n\n- 用户可以通过 Kubernetes Gateway API 定义和应用 Envoy Proxy 的配置。\n- 这包括定义专用网关的具体配置，如安全规则、路由策略等。\n\n这种架构设计利用了 Kubernetes 的灵活性和扩展性，并通过 Envoy 提供了强大的流量管理和安全功能。\n\n## 部署 TEG\n\n执行下面的命令部署 TEG V0.0.0：\n\n\u0060\u0060\u0060bash\nexport REGISTRY=\u0022oci:\/\/docker.io\/tetrate\u0022\nexport CHART_VERSION=\u0022v0.0.0-latest\u0022\nhelm install teg ${REGISTRY}\/teg-envoy-gateway-helm \\\n --version ${CHART_VERSION} \\\n -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n检查部署：\n\n\u0060\u0060\u0060bash\nkubectl get pod -n envoy-gateway-system\n\u0060\u0060\u0060\n\n你将看到下面的结果：\n\n\u0060\u0060\u0060\nNAMESPACE              NAME                                                       READY   STATUS    RESTARTS        AGE\nenvoy-gateway-system   envoy-gateway-596dfbcb88-tx7xb                             1\/1     Running   0               3m55s\nenvoy-gateway-system   envoy-ratelimit-674b8c955c-jhlfn                           2\/2     Running   2 (3m48s ago)   3m54s\nenvoy-gateway-system   teg-envoy-gateway-64fd8c8fbb-59b4l                         1\/1     Running   0               3m55s\nenvoy-gateway-system   teg-redis-86bb7d9b9d-27n44                                 1\/1     Running   0               3m55s\n\u0060\u0060\u0060\n\n部署示例应用：\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n部署 Envoy Proxy：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: dedicated-gateway\n  namespace: httpbin\nspec:\n  gatewayClassName: teg\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\nEOF\n\u0060\u0060\u0060\n\n然后你会在 \u0060envoy-gateway-system\u0060 命名空间下看到一个新的 Envoy 代理。\n\n部署 HTTPRoute，给网关配置路由：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\n  namespace: httpbin\nspec:\n  parentRefs:\n    - group: gateway.networking.k8s.io\n      kind: Gateway\n      name: dedicated-gateway\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \/httpbin\/\n      filters:\n        - type: URLRewrite\n          urlRewrite:\n            path:\n              type: ReplacePrefixMatch\n              replacePrefixMatch: \/\n      backendRefs:\n        - group: \u0022\u0022\n          kind: Service\n          name: httpbin\n          port: 8000\nEOF\n\u0060\u0060\u0060\n\n这个路由配置中有一个 URLRewrite filter，重写 URL 前缀，去掉了 \u0060\/httpbin\/\u0060 部分。\n\n发送流量测试：\n\n\u0060\u0060\u0060bash\nexport DEDICATED_GATEWAY_IP=$(kubectl get gateway\/dedicated-gateway -n httpbin -o jsonpath=\u0027{.status.addresses[0].value}\u0027)\ncurl -i http:\/\/${DEDICATED_GATEWAY_IP}\/httpbin\/get\n\u0060\u0060\u0060\n\n{{\u003ccallout note \u0022为什么使用 \u0060\/httpbin\/get\u0060?\u0022\u003e}}\n\n在通过 Tetrate Enterprise Gateway for Envoy (TEG) 暴露 \u0060httpbin\u0060 应用时，选择 \u0060\/httpbin\/get\u0060 作为访问路径的原因主要是为了在同一个 Envoy 网关下能够同时支持多个应用或服务，并能根据不同的路径将流量正确地路由到指定的服务。\n\n这种路径前缀的设置方法允许系统管理员或开发人员为每个服务配置独立的路径前缀，从而通过单一的入口点（即 Envoy 网关）来管理对多个后端服务的访问。这样的配置增加了路由的灵活性，使得在不更改现有服务配置的情况下，轻松地扩展或修改服务的暴露方式。\n\n{{\u003c\/callout\u003e}}\n\n## 作为 Istio 的入口网关\n\nIstio 提供了成熟且灵活的入口网关支持，基于与 Tetrate Enterprise Gateway（TEG）相同的 Envoy 代理。Istio 主要专注于处理集群内服务之间的通信。相较之下，TEG 设计用于向外界暴露应用，处理人类用户的请求，并支持如 OIDC 单点登录等高级功能。通过结合 Istio 网格和 TEG 的高级网关功能，两者可以共同使用，以提升整体应用的可访问性和安全性。\n\n以下图示展示了 Istio 网格中入口网关的流量路径。\n\n![Istio 中入口网关的流量路径](istio-ingress-sidecar.svg)\n\n下图展示了在引入 TEG 之后，流量如何从 Istio 网格边缘进入到内部。\n\n![引入 TEG 后流量从 Istio 网格边缘进入内部的流量路径](istio-teg-integration.svg)\n\n将 TEG 集成到 Istio 网格中，通过在 TEG 上配置 sidecar 来颁发证书，同时避免 sidecar 拦截 TEG 中的流量。然后通过 Envoy Gateway 控制入口网关的流量路径。\n\n### 为 TEG 与 Istio 的互操作做准备\n\n为了使 TEG 作为 Istio 的入口网关，应注意以下关键点：\n\n- 在安装 Istio 时，避免启用 Ingress Gateway。我们将手动安装并配置 TEG 作为 Istio 的入口网关。\n- 由于 Istio 和 TEG 都使用 Envoy 作为代理，我们需要让 Istio 为 TEG 的网关 Pod 注入 Envoy sidecar，以便 TEG 可以安全地与 Istio 数据平面通信。\n- 配置 Envoy Gateway 创建的 Envoy 代理的[路由类型](https:\/\/gateway.envoyproxy.io\/latest\/api\/extension_types\/#routingtype)为 \u0060Service\u0060 而非 \u0060Endpoint\u0060，确保 Envoy 代理能正确找到路由。\n\n为 TEG 的命名空间添加标签，以确保数据平面获得 Istio sidecar 的注入。\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\n我们还需要配置 TEG 的 sidecar，使其不处理进入网关的 Envoy 流量。注入 sidecar 的目的是使 Envoy Gateway 的组件及其创建的代理能够被纳入 Istio 网格，并挂载正确的证书进行安全通信。\n\n{{\u003c include_code file=\u0022control-plane-tls.yaml\u0022 \u003e}}\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway \\\n     --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 中的 sidecar 不拦截流量：\n\n{{\u003c include_code file=\u0022teg-sidecars-no-inbound.yaml\u0022 \u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\n修改 GatewayClass 的配置，将上述 sidecar 配置应用到 Envoy Gateway 数据平面的所有 \u0060EnvoyProxy\u0060 上：\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### 安装 Istio\n\n使用 minimal profile 部署 Istio，从而不部署 Ingress Gateway：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### 重启 TEG 控制平面\n\n现在 Istio 的 sidecar 注入已准备就绪，我们将重启所有 TEG 控制平面 Pod，它们将带有 sidecar 重新启动。\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis; \\\n    do kubectl rollout restart deployment -n envoy-gateway-system $d; \\\n    done\n\u0060\u0060\u0060\n\n### 部署测试应用\n\n此步应在安装 Istio 之后进行，以确保它们也获得 sidecar 的注入。\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### 配置 TEG\n\n现在我们配置 TEG 处理边缘流量。\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\n部署应用网关，包含以下容器：\n\n- \u0060istio-init\u0060：由 Istio 注入，负责修改 pod 中的 iptables\n- \u0060envoy\u0060：由 TEG 控制，作为入口网关\n- \u0060istio-proxy\u0060：由 Istio 注入，负责与集群内部 pod 联系\n- \u0060shutdown-manager\u0060：由 TEG 控制，负责 Pod 启停\n\n创建 HTTP 路由：\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### 发送测试请求\n\n获取网关的负载均衡器 IP 地址，并发送测试请求：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\n你将看到来自 \u0060httpbin\u0060 服务的正确响应，如下所示：\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### 启用严格的 mTLS\n\n运行下面的命令启用严格的 mTLS：\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n### 为网关启用 TLS\n\n创建用于服务签名的根证书和私钥：\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\n为 \u0060www.example.com\u0060 创建证书和私钥：\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n为入口网关创建 secret：\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential \\\n  --key=example_certs\/www.example.com.key \\\n  --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n配置入口网关：\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\n发送测试请求：\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 \\\n  --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\n你将可以通过 HTTPS 访问网格内的 \u0060httpbin\u0060 服务。\n\n## 总结\n\nTetrate Enterprise Gateway 为企业提供了一种强大的网关解决方案，能够在云原生环境中高效地暴露和管理应用服务。通过其基于 Envoy 的架构和对 Kubernetes Gateway API 的支持，TEG 不仅确保了高性能的流量管理，还大幅简化了网关的部署和维护。无论是面对复杂的安全需求还是高流量的业务场景，TEG 都能提供可靠的支持，帮助企业实现其业务连续性和技术创新。\n\n## 参考\n\n- [Using TEG in Conjunction with an Istio Service Mesh - docs.tetrate.io](https:\/\/docs.tetrate.io\/envoy-gateway\/v0.0.0-latest\/howto\/eg-and-istio)\n', '\/blog\/explore-tetrate-enterprise-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入了解 Tetrate Enterprise Gateway (TEG) 及其如何与 Istio 服务网格集成 —— 一种基于 Envoy 的企业级网关解决方案，包括它的架构、基本功能以及如何在 Kubernetes 中使用 TEG 来暴露和管理应用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/exploring-envoy-1-31-features-performance/">探索 Envoy 1.31.0：新特性与性能提升全解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('探索 Envoy 1.31.0：新特性与性能提升全解析', '探索 Envoy 1.31.0 的重大更新：HTTP\/3 优化、Proxy Protocol 支持，及 Redis 命令扩展。', '\n今天 Envoy Proxy 1.31.0 发布，这是今年继 1.29、1.30 以来发布的第三个大版本。Envoy Proxy 1.31.0 的发布标志着此开源网络代理项目在性能优化和功能增强方面又迈出了重要一步。此版本包括了一系列引人注目的新特性、行为变化和新配置选项，下面我们将逐一解析这些更新，帮助你充分利用 Envoy 的最新能力。\n\n## 新特性\n\n1. **HTTP\/3 \u0022Happy Eyeballs\u0022 特性**: HTTP\/3的支持现在更为智能，新加入的“happy eyeballs”算法可以在多个 IP 地址族中更快找到最优连接路径，提升连接的可靠性和速度。\n2. **Proxy Protocol 类型元数据支持**: 在代理协议监听器中，默认现在会填充类型化的元数据，为高级路由和策略实施提供更多的灵活性和精确控制。\n3. **Redis 命令支持**: Envoy 现在支持所有 Bloom 1.0.0 的 Redis 命令，扩展了与 Redis 交互的能力，尤其适用于需要高级数据结构操作的场景。\n\n{{\u003ccallout note \u0022Happy Eyeballs\u0022\u003e}}\n\nHappy Eyeballs（快乐的眼睛）是一种网络算法，主要用于当一个设备同时支持 IPv4 和 IPv6 时，快速决定应该使用哪种 IP 协议来建立连接。该算法通过几乎同时启动两个连接尝试——一个使用 IPv4，另一个使用 IPv6——并使用哪个首先成功建立的连接，从而减少了连接延迟。\n\n在 HTTP\/3 中应用 Happy Eyeballs 特性，尤其是 Envoy 1.31 版本中的实现，可以改进服务在支持多种网络协议的环境中的表现。例如，如果一个服务的 IPv4 连接速度比 IPv6 快，Envoy 会偏好 IPv4，反之亦然。这样做的好处是减少了尝试连接的总时间，提高了用户体验和服务效率。\n\n{{\u003c\/callout\u003e}}\n\n## 行为变化\n\n1. **Thread Local 存储变更**: \u0060SlotImpl\u0060 类的行为更新，其析构函数现可在任何线程上被调用，提高了线程局部存储的灵活性。\n2. **HTTP\/2 和 QUIC 性能提升**: 默认启用新的 HTTP\/2 编解码器和对 HTTP\/3 的优化，包括性能改进和新的连接尝试机制，显著提升了性能和稳定性。\n\n## 弃用与移除\n此版本中，多个旧有的配置和运行时标志被正式弃用和移除，以清理代码库并提升维护效率。这包括一些老旧的 TLS 和 HTTP 配置选项，用户应检查并更新他们的配置以免受到影响。\n\n## 结论\n\nEnvoy 1.31.0 的发布提供了许多值得关注的新特性和改进，不仅增强了其作为现代微服务架构核心组件的地位，也进一步证明了其作为业界领先代理解决方案的能力。无论是在性能提升还是功能拓展方面，Envoy 1.31.0 都为用户带来了实质性的好处。\n\n确保查看完整[更新文档](https:\/\/github.com\/envoyproxy\/envoy\/releases\/tag\/v1.31.0)，了解所有详细的配置指南和更新说明，以充分利用 Envoy 1.31.0 的潜力。\n\nEnvoy 的每次更新都是基于社区的反馈和贡献，我们期待看到你如何利用这些新特性来优化你的应用和服务。如果你有任何问题或需要帮助，欢迎在 Slack 或 GitHub 上与社区交流。\n', '\/blog\/exploring-envoy-1-31-features-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Envoy 1.31.0 的重大更新：HTTP/3 优化、Proxy Protocol 支持，及 Redis 命令扩展。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-contributor-guide/">如何参与 Envoy Gateway 社区：贡献或提交代码指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何参与 Envoy Gateway 社区：贡献或提交代码指南', '本指南提供了如何参与 Envoy Gateway 开源项目的详细步骤，包括设置开发环境、代码贡献、PR 流程以及与社区互动的方法。', '\nEnvoy Gateway 是由 Envoy Proxy 社区推动的一个开源 API 网关项目，结合了 Contour、Emissary 等项目力量。这个指南将帮助你理解如何贡献代码和参与社区。\n\n## 开始之前\n\n了解项目的[目标和愿景](https:\/\/github.com\/envoyproxy\/gateway\/blob\/main\/GOALS.md)是非常重要的。Envoy Gateway 旨在作为一个独立或基于 Kubernetes 的应用程序网关，使用 Gateway API 资源来管理 Envoy 代理。\n\n## 如何参与\n\n### 1. 沟通协作\n\n在开发前，建议通过[GitHub](https:\/\/github.com\/envoyproxy\/gateway)或[Slack](https:\/\/communityinviter.com\/apps\/envoyproxy\/envoy)与社区交流。始终创建一个 GitHub Issue 来讨论你的想法。\n\n### 2. 贡献准则\n\n遵守[贡献准则](https:\/\/gateway.envoyproxy.io\/contributions\/contributing\/)，它包括代码规范和社区行为准则。\n\n### 3. 提交代码\n\n- **签署 DCO**：确保你的提交信息包含 DCO 签名。\n- **创建 PR**：Fork 仓库后，提交 PR。确保通过所有自动化测试。\n- **代码审查**：PR 会被维护人员审查，一旦满足条件，将会被合并。\n\n## 构建和测试指南\n\n### 环境准备\n\n- **必需工具**：\n  - Go（版本 1.22\u002b）\n  - Make（版本 4.0\u002b）\n  - Docker（可选，版本 20.10.16\u002b，用于构建镜像）\n  - Python3\n- **设置步骤**：确保所有工具均已安装并配置好环境变量。\n\n### 代码构建\n\n- **构建命令**：\n  - 构建全部二进制文件：\u0060make build\u0060\n  - 仅构建 Envoy Gateway：\u0060make build BINS=\u0022envoy-gateway\u0022\u0060\n  - 构建控制工具 \u0060egctl\u0060：\u0060make build BINS=\u0022egctl\u0022\u0060\n\n### 测试\n\n- **运行测试**：执行 \u0060make test\u0060 来进行 Go 语言的测试。\n- **生成测试数据**：执行 \u0060make testdata\u0060 来生成 YAML 格式的测试数据。\n\n### Lint 检查\n\n- **执行 Lint**：运行 \u0060make lint\u0060 确保代码风格和标准一致性（注意修正现有的拼写错误）。\n\n### 镜像操作\n\n- **构建镜像**：\u0060IMAGE=docker.io\/\u003cdockerhub-id\u003e\/gateway-dev make image\u0060\n- **推送多架构镜像**：\u0060IMAGE=docker.io\/\u003cdockerhub-id\u003e\/gateway-dev make push-multiarch\u0060\n\n### 部署和调试\n\n- **本地集群创建**：使用 \u0060make create-cluster\u0060 在 Kind 上创建测试\/开发用的集群。\n- **部署到 Kubernetes**：使用 \u0060IMAGE=docker.io\/\u003cdockerhub-id\u003e\/gateway-dev TAG=\u003cimage-tag\u003e make kube-deploy\u0060 将 Envoy Gateway 部署至 Kubernetes。\n- **部署示例应用**：执行 \u0060make kube-demo\u0060 部署 demo 后端服务及相关网络资源。\n- **删除部署**：执行 \u0060make kube-demo-undeploy\u0060 删除示例应用。执行 \u0060make kube-undeploy\u0060 删除 Envoy Gateway。\n\n{{\u003ccallout note \u0022Kind 中运行的 Pod 列表\u0022\u003e}}\n当你完成 Envoy Gateway 和示例应用部署后，运行 \u0060kubectl get pod -A\u0060 命令，你将看到如下所示的 Pod 列表。\n{{\u003cdetail \u0022查看 Kind 中运行的 Pod\u0022\u003e}}\n     NAMESPACE              NAME                                                  READY   STATUS    RESTARTS      AGE\n     default                backend-96f75bbf-tcdf7                                1\/1     Running   1 (97s ago)   13h\n     envoy-gateway-system   envoy-default-eg-e41e7b31-668f754989-wb7xr            2\/2     Running   2 (97s ago)   13h\n     envoy-gateway-system   envoy-gateway-b457dc69b-l77cr                         1\/1     Running   2 (97s ago)   13h\n     kube-system            coredns-5dd5756b68-b494d                              1\/1     Running   1 (97s ago)   14h\n     kube-system            coredns-5dd5756b68-j46bx                              1\/1     Running   1 (97s ago)   14h\n     kube-system            etcd-envoy-gateway-control-plane                      1\/1     Running   1 (97s ago)   14h\n     kube-system            kindnet-sq4b4                                         1\/1     Running   1 (97s ago)   14h\n     kube-system            kube-apiserver-envoy-gateway-control-plane            1\/1     Running   1 (97s ago)   14h\n     kube-system            kube-controller-manager-envoy-gateway-control-plane   1\/1     Running   2 (97s ago)   14h\n     kube-system            kube-proxy-4x72s                                      1\/1     Running   1 (97s ago)   14h\n     kube-system            kube-scheduler-envoy-gateway-control-plane            1\/1     Running   2 (97s ago)   14h\n     local-path-storage     local-path-provisioner-6f8956fb48-shjcz               1\/1     Running   2 (59s ago)   14h\n     metallb-system         controller-5c6b6c8447-kjl4n                           1\/1     Running   2 (59s ago)   14h\n     metallb-system         speaker-6zlrb                                         1\/1     Running   1 (97s ago)   14h\n{{\u003c\/detail\u003e}}\n{{\u003c\/callout\u003e}}\n\n### 调试 Envoy 配置\n\n- **端口转发设置**：\n  \u0060\u0060\u0060bash\n  export ENVOY_DEPLOYMENT=$(kubectl get deploy -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\n  kubectl port-forward deploy\/${ENVOY_DEPLOYMENT} -n envoy-gateway-system 19000:19000\n    \u0060\u0060\u0060\n- **访问**：在浏览器中打开 \u0060http:\/\/localhost:19000\u0060 访问 Envoy 管理界面进行配置调试。\n- **网络环境适配**：在中国大陆进行构建和推送镜像时，可能需要设置 Docker 代理以确保依赖的镜像能够下载。详细操作可参考[设置 Docker 代理](https:\/\/docs.docker.com\/network\/proxy\/)。\n\n{{\u003ccallout warning 注意事项\u003e}}\n若你在中国大陆的网络环境下构建和推送镜像，需要为 Docker 设置代理，否则你将无法下载一些依赖镜像。你可以将它们下载到本地后再用 \u0060kind load\u0060 命令加载到 kind 里。需要下载和加载到 kind 里的镜像见下面的代码。\n\n{{\u003cdetail \u0022pull-and-load-images-for-kind.sh\u0022\u003e}}\n\n{{\u003c include_code file=\u0022pull-and-load-images-for-kind.sh\u0022 \u003e}}\n\n{{\u003c\/detail\u003e}}\n\n{{\u003c\/callout\u003e}}\n\n### 更多资源\n\n想深入了解如何进行高级测试和贡献，详见 [Envoy Gateway 开发文档](https:\/\/gateway.envoyproxy.io\/contributions\/develop\/)。\n\n加入我们，与全球开发者共同推进 Envoy Gateway 的成长，同时提升你的开发技能和对开源社区的理解。\n\n## 加入 Envoy Gateway 中文交流群\n\n为了便于中文和中国时区的用户交流，Envoy Gateway 社区成立的微信群，详见[通知](\/notice\/envoy-gateway-group\/)，该群成立于 2023 年 4 月，目前已有 400 多名成员。你可以联系[联系我](\/contact\/)、[刘训灼](https:\/\/www.liuxunzhuo.com\/)、[赵化冰](https:\/\/zhaohuabing.com\/)等入群。\n\n## 参考\n\n- [Envoy Gateway Developer Guide - gateway.envoyproxy.io](https:\/\/gateway.envoyproxy.io\/contributions\/develop\/)', '\/blog\/envoy-gateway-contributor-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本指南提供了如何参与 Envoy Gateway 开源项目的详细步骤，包括设置开发环境、代码贡献、PR 流程以及与社区互动的方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-delta-xds-for-envoy/">Envoy xDS 及 Istio 中的配置分发流程介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy xDS 及 Istio 中的配置分发流程介绍', '本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。', '\n在 Istio 项目的早期采用全局状态（State of the World，简称 SotW）的方式推送配置给 Envoy 代理。一旦有一个服务变更，就要将全局配置推送给所有 Sidecar，造成巨大的网络负担及控制平面的性能损耗。Istio 社区从几年前就开始开发增量 xDS 以解决此问题，并在最近几个 Istio 版本中支持了增量 xDS。在最近的 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)中，增量 xDS 成为默认开启的功能。本文将为你介绍 xDS、增量 xDS 及 Istio 的配置分发方式。\n\n## 什么是 xDS？{#what-is-xds}\n\nxDS（Extensible Discovery Service）是一种通信协议，用于在微服务架构中管理服务发现和动态配置。这种机制被广泛用于 Envoy 代理和 Istio 服务网格中，以管理各种类型的资源配置，如路由、服务发现、负载均衡设置等。\n\n### xDS 包含哪些发现服务？{#xds-services}\n\nxDS 包括以下主要的发现服务，每种服务都负责不同类型的网络资源配置：\n\n1. **LDS（Listener Discovery Service）**：管理 Envoy 监听器的配置，这些监听器定义了如何接收和处理入站连接。\n2. **RDS（Route Discovery Service）**：提供路由信息，定义了如何根据指定规则将请求路由到不同的服务。\n3. **CDS（Cluster Discovery Service）**：管理集群信息，集群代表一组逻辑上类似的后端服务实例。\n4. **EDS（Endpoint Discovery Service）**：提供具体服务实例的网络地址，这些服务实例组成了 CDS 中定义的集群。\n5. **SDS（Secret Discovery Service）**：管理安全相关的配置，如 TLS 证书和私钥。\n6. **VHDS（Virtual Host Discovery Service）**：为 RDS 提供虚拟主机配置，允许动态更新虚拟主机而不重启连接。\n7. **SRDS（Scoped Route Discovery Service）**：管理路由作用域，提供基于不同条件（如请求头部）的动态路由选择。\n8. **RTDS（Runtime Discovery Service）**：提供运行时配置，这些配置可用于实验性功能或精细调整系统行为。\n9. **ECDS（Extension Config Discovery Service）**：为特定过滤器提供动态配置更新的服务。目前，网络过滤器、HTTP 过滤器和监听器过滤器都支持 ECDS。\n\n这些服务共同支持动态配置的分发和更新，使得基于 Envoy 的应用架构能够实时适应变化，提高可扩展性和灵活性。每种服务的实现可以独立进行，也可以通过聚合方式（如 ADS）进行统一管理。CNCF 也成立了 [xDS API 工作组](https:\/\/github.com\/cncf\/xds)来推动 xDS API 为 L4\/L7 数据平面配置提供事实上的标准，类似于 SDN 中 OpenFlow 在 L2\/L3\/L4 中所扮演的角色。\n\n{{\u003ccallout note 提示\u003e}}\n关于 xDS  协议的详细介绍，如 xDS 协议的 RPC 服务和变体方法，以及 xDS 请求流程，请参考 [Envoy 代理文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n{{\u003c\/callout\u003e}}\n\n### xDS 协议的变体 {#xds-variants}\n\nxDS 协议主要包括以下变体：\n1. **State of the World (SotW)**：单独的 gRPC 流为每种资源类型提供完整数据，通常在 Envoy 代理初次启动时使用，也是 Istio 最早使用的 xDS 协议类型。\n2. **增量 xDS（Delta xDS）**：为每种资源类型提供变化的部分数据，从 2021 年开始开发，在 Istio 1.22 版本中开始默认开启。\n3. **聚合发现服务（ADS）**：一个 gRPC 流聚合所有资源类型的数据。\n4. **增量 ADS（Delta ADS）**：一个 gRPC 流聚合所有资源类型的增量数据。\n\n下表概述了 xDS 协议的四种变体，包括对每个变体的解释、使用场景以及优缺点的对比。这些变体为不同的网络环境和服务需求提供了多种选择，可以根据具体情况选择最合适的协议变体以优化服务的性能和资源使用。\n\n{{\u003ctable \u0022xDS 协议的四种变体介绍\u0022\u003e}}\n| 变体类型  | 解释                                                         | 使用场景                                                     | 优点                                                     | 缺点                                                         |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW      | 每次都发送所有配置数据，不论是否有变化。                     | 适用于配置较少变化的稳定环境。                               | 简单易实现，易于理解和维护。                             | 数据传输量大，不适合频繁更新配置的环境。                     |\n| Delta xDS | 只传输变更的配置数据，而不是全部数据。                       | 适用于配置频繁变化，需要快速响应变更的环境。                 | 减少了不必要的数据传输，提高了效率。                     | 实现复杂，需要客户端和服务端管理配置状态。                   |\n| ADS       | 通过单一的 gRPC 流来管理所有配置数据，无需为每种资源类型建立独立的连接。 | 适用于需要同时管理多种类型资源的复杂服务架构。               | 减少了网络连接数，简化了资源管理。                       | 对于网络或服务质量差的情况，单点故障可能导致所有配置更新失败。 |\n| Delta ADS | 结合了 ADS 和增量 xDS 的优点，通过一个 gRPC 流聚合并且只传输变化部分的资源。 | 适用于既需要管理多种资源类型，又需要频繁更新配置的极其动态的环境。 | 提供了最大的灵活性和效率，适合大规模和高动态的服务架构。 | 实现最为复杂，对于配置管理的逻辑要求高，需要精确控制资源的变更和传输。 |\n\n{{\u003c\/table\u003e}}\n\n使用 xDS 协议的服务网格可以更灵活地管理微服务之间的通信和配置，减少了配置变更的延迟，提高了系统的响应速度和可靠性。\n\n在 Istio 中，DiscoveryServer 作为 Envoy 的 xDS API 的实现，负责监听 gRPC 接口并根据 Envoy 的需求动态推送配置。它能够处理各种资源类型的请求，并根据服务的变更实时更新 Envoy 配置。此外，它还支持安全特性，如验证客户端证书，确保只有合法的服务实例可以接收配置数据。\n\n### xDS 变体的配置示例 {#xds-config}\n\n使用 xDS 协议的变体通常涉及在 Envoy 代理或与之类似的服务网格配置中指定 xDS 服务器的详细信息。虽然不同的服务网格和代理服务器的配置细节可能有所不同，下面是一些通用的 YAML 配置示例，说明如何指定 xDS 服务器以及如何使用这些协议变体。\n\n#### State of the World (SotW)\n\n在 Envoy 的配置中，你可以通过静态资源或通过 API 动态获取资源的方式来使用 SotW。这里是一个简单的 Envoy 配置示例，显示了如何静态定义集群和监听器：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n####  增量 xDS {#axds}\n\n增量 xDS 的配置需要在 xDS 服务端支持增量协议，并在客户端配置中指定使用增量 xDS。Envoy 启动配置中需要添加 API 版本来启用增量 xDS：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### 聚合发现服务 (ADS) {#ads}\n\n使用 ADS 时，所有资源类型的配置通过一个单一的 API 端点聚合。这在 Envoy 配置中指定：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n  lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n####  增量 ADS {#adds}\n\n增量 ADS 通过在 ADS 配置中指定增量 API 类型，可以实现更为细粒度的更新：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n这些配置示例需要根据你的具体环境和需求进行调整。更多细节和高级配置，你可以参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype)。\n\n## Istio 如何发送配置给 Envoy sidecar？\n\n得益于 xDS 协议，如 Istio、Envoy Gateway 等可以通过 API 远程动态分发配置到 Envoy 代理。下图展示了 Istio 的配置分发流程（Sidecar 模式）。\n\n\u0060\u0060\u0060mermaid \u0022Istio 的配置分发流程图\u0022\nflowchart TB\n    Declarative_Configuration[声明式配置] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio 的配置分发流程图](0fa133ccdbeb372a413ad1ecc99ff9f0.svg)\n\nIstio 中配置分发的主要流程说明：\n\n1. **声明式配置**：用户通过 YAML 文件或其他配置管理工具定义服务网格的配置。这些配置可以包括路由规则、安全策略、遥测设置等。\n2. **Kubernetes**：Istio 配置文件被提交到 Kubernetes 集群中，通常是通过 \u0060kubectl apply\u0060 命令或其他 CI\/CD 工具。Kubernetes 接收到配置文件并将其存储在 etcd 数据库中。\n3. **Istiod**：Istiod 是 Istio 的控制平面组件，负责管理和分发配置。它监听从 Kubernetes API 服务器中传入的事件，获取相关配置变更，并对其进行处理。Istiod 解析配置文件，生成相应的路由规则和策略，并通过 xDS API 将这些配置分发到数据平面（Envoy 代理）。\n4. **xDS API**：Istiod 使用 xDS API 将配置下发到各个 Envoy 代理中。\n5. **Envoy Proxy**：Envoy 是 Istio 的数据平面组件，运行在每个服务的旁路（sidecar）容器中，拦截并管理所有入站和出站流量。Envoy 代理通过 xDS API 接收来自 Istiod 的配置，并根据这些配置进行流量管理、策略执行和遥测数据收集。\n6. **Pod**：每个服务实例运行在一个 Pod 中，Pod 内部包含一个应用容器和一个 Envoy 代理容器。Envoy 代理拦截应用容器的所有网络流量，并根据配置进行处理。\n\n这个配置分发流程确保了 Istio 能够动态管理和配置服务网格中的所有服务实例，提供一致的流量管理和策略执行。\n\n## xDS 的发展与 Istio 中的 Delta xDS 实现\n\n起初，xDS 采用了“全局状态”（State of the World，简称 SotW）的设计，这意味着任何一个配置的更改都需要向 Envoy 发送所有配置的完整状态。这种方法在网络和控制平面上造成了巨大的负担，尤其是在大规模服务部署时。\n\n在 2021 年的 EnvoyCon 上，Aditya Prerepa 和 John Howard 分享了 Istio 如何实现 Delta xDS，这是一种增量式的 xDS 实现。与传统的 SotW xDS 相比，Delta xDS 只发送变更的配置，显著减少了需要通过网络发送的配置数据量，从而提高了效率和性能。这种方法特别适用于那些配置频繁变更的环境，因为它只更新变化的部分而不是整个配置。\n\n在实现 Delta xDS 的过程中，Istio 团队面临了多个挑战，包括如何确保配置更新的正确性以及避免潜在的资源泄漏。他们通过采用干运行（Dry-run）模式来并行运行 SotW 和 Delta 生成器，逐步发现并修复了实现中的缺陷。此外，他们还引入了新的 Envoy 类型，如虚拟主机发现服务（Virtual Host Discovery Service），以支持更细粒度的配置分发。\n\n### Delta xDS 增量配置\n\n下图展示了 Delta xDS 增量配置的流程。\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS 增量配置流程图\u0022\nsequenceDiagram\n    participant CP as 控制平面\n    participant P as 代理\n    CP-\u003e\u003eP: 初始完整配置\n    P-\u003e\u003eCP: 订阅配置变更\n    Note over CP,P: 发生任何配置变更\n    CP-\u003e\u003eP: 检查配置变更\n    CP-\u003e\u003eP: 计算差异\n    CP-\u003e\u003eP: 仅发送差异\n    Note over P: 代理使用差异进行更新\n\u0060\u0060\u0060\n\n![Delta xDS 增量配置流程图](835038abb9bb83ba223974c525293468.svg)\n\nDelta xDS 配置流程如下：\n\n1. **初始完整配置**：控制平面向代理发送初始完整配置，此时使用的是 StoW 模式。\n2. **订阅配置变更**：代理从控制平面订阅配置变更。\n4. **检查配置变更**：控制平面检查相对于代理已知状态的配置变更。\n5. **计算差异**：控制平面计算当前配置与代理持有的前一配置之间的差异（增量）。\n6. **仅发送差异**：控制平面仅发送变更的配置（差异）给代理，代理应用这些差异增量更新其配置。\n\n该流程确保只有必要的变更被传输和应用，提高了效率并减少了网络和代理资源的负载。\n\n### SotW vs Delta xDS\n\n虽然 Delta xDS 解决了在大规模网络下的配置分发的性能问题，但是 SotW 模式依然有它存在的意义，比如在初次下发配置的情况下。下表对比了 Istio 中的两种配置分发方式：SotW (State of the World) 和 Delta xDS。\n\n{{\u003ctable \u0022Istio 中的全局状态和增量 xDS 配置分发方式对比\u0022\u003e}}\n| 对比项         | SotW                                                     | Delta XDS                                    |\n| -------------- | -------------------------------------------------------- | -------------------------------------------- |\n| **数据传输量** | 每次传输完整的配置数据，不管配置是否有变更。             | 仅传输发生变化的配置数据，减少了数据传输量。 |\n| **效率**       | 在小型或变更少的环境中效率可接受。                       | 在大型环境或频繁变更的环境中更高效。         |\n| **复杂性**     | 实现简单，易于理解和维护。                               | 实现较为复杂，需要精细的变更跟踪和管理。     |\n| **资源消耗**   | 可能因为重复发送大量未变更的数据而增加服务器和网络负载。 | 更低的资源消耗，因为只处理变更的部分。       |\n| **实时性**     | 配置更新后立即发送全量配置，实时性高。                   | 只发送变更部分，响应更快，减少处理时间。     |\n| **适用场景**   | 适合配置变动不频繁的小型至中型部署。                     | 适合配置频繁变更或大规模部署的场景。         |\n{{\u003c\/table\u003e}}\n\n这个表格从数据传输量、效率、复杂性、资源消耗、实时性以及适用场景等多个角度对 SotW 和 Delta XDS 进行了对比，有助于在不同的使用环境中做出合适的选择。\n\n## 总结\n\n在这篇文章中我分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。随着 Delta xDS 在 Istio 1.22 版本中成为默认配置，这将有助于用户在大规模网络环境下轻松使用 Istio。\n\n## 参考\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-oidc/">如何使用 Envoy Gateway 在 API 网关侧基于 OIDC 实现单点登录？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Envoy Gateway 在 API 网关侧基于 OIDC 实现单点登录？', '本文详细介绍了如何配置 Envoy Gateway 使用 OIDC 实现单点登录。通过 Auth0 作为身份提供商，演示如何在 API 网关端实现安全、高效的单点登录，提升用户体验和系统安全性。', '\n在[微服务中常见的认证方式详解](\/blog\/microservice-auth-methods\/)这篇博客中我们介绍到了 OAuth 2.0 认证，该身份认证协议有多种实现方式，其中最流行的就是 OpenID Connect（OIDC）认证。OIDC 能够为用户提供身份验证和授权。本文将介绍如何使用 Envoy Gateway 在 API 网关级别实现 OIDC 认证。\n\n## Envoy Gateway 支持的认证方式 {#auth-methods}\n\nEnvoy Gateway 是一个使用 Envoy 实现的高性能的 API 网关，支持多种认证方式来保护 API 和微服务：\n\n1. **JWT 认证**: 使用 JSON Web Tokens（JWT）进行认证。\n2. **mTLS（双向 TLS）**: 使用双向 TLS 确保客户端和服务器之间的安全通信。\n3. **HTTP Basic 认证**: 使用用户名和密码进行基本认证。\n4. **OIDC 认证**: 使用 OpenID Connect 协议进行身份验证和授权。\n5. **外部认证**：外部认证调用外部 HTTP 或 gRPC 服务来检查传入的 HTTP 请求是否经过认证。\n\n本文重点介绍如何在 Envoy Gateway 中配置和使用 OIDC 认证从而在网关侧实现单点登录。\n\n## 什么是 OIDC？{#what-is-oidc}\n\nOpenID Connect（OIDC）是一个基于 [OAuth 2.0](\/blog\/microservice-auth-methods\/#oauth-20) 的身份验证协议。它允许客户端通过认证服务器验证用户身份，并获取有关用户的信息。\n\nOIDC 认证流程如下图所示：\n\n\u0060\u0060\u0060mermaid \u0022OIDC 认证流程图\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant ResourceServer\n\n    User -\u003e\u003e Client: 请求访问受保护资源\n    Client -\u003e\u003e AuthServer: 请求认证（带有客户端 ID）\n    AuthServer -\u003e\u003e User: 请求用户登录\n    User -\u003e\u003e AuthServer: 用户登录并授权\n    AuthServer -\u003e\u003e Client: 返回授权码\n    Client -\u003e\u003e AuthServer: 交换授权码获取访问令牌和 ID 令牌\n    AuthServer -\u003e\u003e Client: 返回访问令牌和 ID 令牌\n    Client -\u003e\u003e ResourceServer: 请求受保护资源（带有访问令牌）\n    ResourceServer -\u003e\u003e AuthServer: 验证访问令牌\n    AuthServer -\u003e\u003e ResourceServer: 验证成功\n    ResourceServer -\u003e\u003e Client: 返回受保护资源\n    Client -\u003e\u003e User: 返回受保护资源\n\u0060\u0060\u0060\n\n![OIDC 认证流程图](83b3c4d30c57805947a314f67c7aa8c1.svg)\n\nOIDC 为 OAuth 2.0 增加了身份验证层，通过引入 ID Token 和标准化的 UserInfo Endpoint，使 OAuth 2.0 不仅能够用于授权，还可以用于安全地验证用户身份，从而实现单点登录（SSO）和用户身份信息的获取。\n\n## 为什么要实现单点登录？{#why-sso}\n\n单点登录（Single Sign-On, SSO）是一种身份验证方式，它允许用户使用一个账户登录多个独立的应用系统，通过一次身份验证即可无缝访问所有相关应用，减少重复输入用户名和密码的麻烦，从而提升用户体验。SSO 集中管理用户身份和认证，增强了系统安全性，并简化了 IT 管理流程。\n\n对于微服务架构，SSO 尤其重要，因为它在各个微服务之间实现统一的认证和授权，避免了每个服务单独实现身份验证逻辑的需求，减少了用户重复登录的麻烦，并提高了用户体验。集中管理的方式还可以统一应用安全策略，更有效地监控和响应安全事件，提升系统的整体安全性。同时，通过使用标准化的令牌（如 JWT），SSO 简化了微服务之间的身份验证过程，提高了开发效率，让开发人员能够专注于业务逻辑的实现。\n\n## 示例：使用 Envoy Gateway 和 Auth0 的单点登录 {#demo}\n\n接下来我们将使用 Auth0 作为身份供应商，演示如何使用 Envoy Gateway 在 API 网关端实现单点登录。\n\n你可以在 [Bilibili](https:\/\/www.bilibili.com\/video\/BV11m421K7ZW\/?share_source=copy_web\u0026vd_source=87728cb6b1b0090fc617caf07a40b236) 上查看该示例演示。\n\n{{\u003c responsive_video src=\u0022\/\/player.bilibili.com\/player.html?isOutside=true\u0026aid=1604968380\u0026bvid=BV11m421K7ZW\u0026cid=1557352862\u0026p=1\u0022 aspectRatio=\u002262.5%\u0022 \u003e}}\n\n### 基于 Auth0 实现单点登录 {#auth0-sequence}\n\n首先我们先说明下示例中 Envoy Gateway 基于 Auth0 实现单点登录的详细流程，如下图所示。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 基于 Auth0 实现单点登录的流程图\u0022\nsequenceDiagram\n    participant 用户\n    participant 浏览器\n    participant Envoy Gateway\n    participant Auth0\n    participant 应用程序\n\n    用户 -\u003e\u003e 浏览器: 打开 https:\/\/www.example.com\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e 浏览器: 在 cookie 中未找到 ID token\n    Envoy Gateway -\u003e\u003e 浏览器: 重定向到 Auth0\n    浏览器 -\u003e\u003e Auth0: 请求 \/authorize?response_type=code\u0026client_id=${CLIENT_ID}\u0026redirect_uri=https:\/\/www.example.com\/myapp\/oauth2\/callback\n    Auth0 -\u003e\u003e 浏览器: 重定向到用户登录页面\n    浏览器 -\u003e\u003e 用户: 输入用户名和密码\n    用户 -\u003e\u003e 浏览器: 用户登录\n    浏览器 -\u003e\u003e Auth0: 提交凭证\n    Auth0 -\u003e\u003e 浏览器: 重定向到 https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\u0026state=xxx\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\n    Envoy Gateway -\u003e\u003e Auth0: 使用代码交换 ID Token\n    Envoy Gateway -\u003e\u003e 浏览器: 设置 cookie: ID Token\n    Envoy Gateway -\u003e\u003e 浏览器: 重定向到 https:\/\/www.example.com\n    浏览器 -\u003e\u003e Envoy Gateway: 请求 https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e Envoy Gateway: 验证 ID Token\n    Envoy Gateway -\u003e\u003e 应用程序: 路由到 Backend service\n\u0060\u0060\u0060\n\n![Envoy Gateway 基于 Auth0 实现单点登录的流程图](0f2852499a637280acfa600e992fd2c8.svg)\n\n步骤说明：\n\n1. **用户访问网站**：用户通过浏览器访问 \u0060https:\/\/www.example.com\u0060。\n2. **请求转发**：浏览器向 Envoy Gateway 发送 GET 请求。\n3. **检查 ID 令牌**：Envoy Gateway 检查用户请求的 cookie 是否包含有效的 ID 令牌。\n4. **重定向到身份提供商**：如果没有找到 ID 令牌，Envoy Gateway 将用户重定向到身份提供商（Identity Provider，IdP）的授权端点，在这里是 Auth0，关于 Auth0 如何实现 Login 的详细信息请查看 [Auth0 文档](https:\/\/auth0.com\/docs\/api\/authentication#login)。\n5. **用户登录**：用户在身份提供商的登录页面输入用户名和密码，并提交凭证进行登录。\n6. **获取授权码**：用户成功登录后，身份提供商将用户重定向回 Envoy Gateway，并在 URL 中包含授权码。\n7. **交换 ID 令牌**：Envoy Gateway 使用授权码向身份提供商请求 ID 令牌。\n8. **设置 Cookie**：身份提供商返回 ID 令牌，Envoy Gateway 将其设置为用户的 cookie。\n9. **重定向**：Envoy Gateway 将 URL 重定向到 \u0060https:\/\/www.example.com\u0060。\n10. **验证 ID 令牌**：Envoy Gateway 验证用户请求中的 ID 令牌。\n11. **路由请求**：验证通过后，Envoy Gateway 将请求路由到后端应用（App）。\n\n通过上述流程，Envoy Gateway 实现了单点登录功能。用户的 HTTP 请求在没有得到授权的情况下都会被转发单点登录页面。除了 Auth0 以外，Envoy Gateway 还支持多个身份提供商，如 Azure AD、Keycloak、Okta、OneLogin、Salesforce、UAA 等。\n\n下面我们将按照时序图中的流程配置 Auth0 和 Envoy Gateway。\n\n### 在 Auth0 上创建应用 {#auth0}\n\n请参考以下步骤在 Auth0 上设置一个 Regular Web Application：\n\n1. 访问 [Auth0](https:\/\/auth0.com\/) 并注册一个免费账户。\n2. 创建一个新的应用，并选择常规 Web 应用程序。\n3. 在应用设置中，记录或设置以下字段：\n   - **Domain** ：\u0060{DOMAIN}\u0060\n   - **Client ID**：\u0060{CLIENT_ID}\u0060\n   - **Client Secret**：\u0060{CLIENT_SECRET}\u0060\n   - **Allowed Callback URLs**：\u0060https:\/\/www.example.com\/oauth2\/myapp\/callback\u0060\n   - **Allowed Logout URLs**：\u0060https:\/\/www.example.com\/myapp\/logout\u0060\n\n记住上面的 Auth0 字段，我们将用它们来配置 Envoy Gateway 的安全策略。\n\n{{\u003ccallout note 提示\u003e}}\n这里的 Logout URL 不起实际作用，应为在我们的下面示例中的 backend 服务并没有实现 Auth0 的 logout 接口。我们只是按照习惯在此添加该字段，以待未来实现。\n{{\u003c\/callout\u003e}}\n\n下面展示的是 Auth0 的配置页面截图，在设置好用户后并创建普通 Web 应用后，你只需要配置这两个地方。\n\n![Auth0 配置页面 1](auth0-1.webp)\n\n![Auth0 配置页面 2](auth0-2.webp)\n\n以上就是 Auth0 的全部配置，接下来我们将安装和配置 Envoy Gateway。\n\n### 安装 Envoy Gateway {#install-envoy-gateway}\n\n参考 [Envoy Gateway 快速开始](\/blog\/envoy-gateway-introduction\/#envoy-gateway-quick-start)在 minikube 上安装 Envoy Gateway：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n参考安全网关，为 Envoy Gateway 配置 TLS：\n\n\u0060\u0060\u0060bash\n# 创建根证书和私钥来签署证书\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example.com.key -out example.com.crt\n\n# 为 www.example.com 创建证书和私钥\nopenssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj \u0022\/CN=www.example.com\/O=example organization\u0022\nopenssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in www.example.com.csr -out www.example.com.crt\n\n# 将证书\/密钥存储在 Secret 中\nkubectl create secret tls example-cert --key=www.example.com.key --cert=www.example.com.crt\n\u0060\u0060\u0060\n\n更新快速开始中创建的网关，使其包含 \u0060443\u0060 端口并引用 \u0060example-cert\u0060 Secret 的 HTTPS Listener：\n\n\u0060\u0060\u0060bash\necho \u0027[\n  {\n    \u0022op\u0022: \u0022add\u0022,\n    \u0022path\u0022: \u0022\/spec\/listeners\/-\u0022,\n    \u0022value\u0022: {\n      \u0022name\u0022: \u0022https\u0022,\n      \u0022protocol\u0022: \u0022HTTPS\u0022,\n      \u0022port\u0022: 443,\n      \u0022tls\u0022: {\n        \u0022mode\u0022: \u0022Terminate\u0022,\n        \u0022certificateRefs\u0022: [\n          {\n            \u0022kind\u0022: \u0022Secret\u0022,\n            \u0022group\u0022: \u0022\u0022,\n            \u0022name\u0022: \u0022example-cert\u0022\n          }\n        ]\n      }\n    }\n  }\n]\u0027 | kubectl patch gateway eg --type=json --patch-file \/dev\/stdin\n\u0060\u0060\u0060\n\n创建 HTTPRoute，为 \u0060\/myapp\u0060 端点增加一条到\u0060backend\u0060 服务的路由：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: myapp\nspec:\n  parentRefs:\n  - name: eg\n  hostnames: [\u0022www.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/myapp\n    backendRefs:\n    - name: backend\n      port: 3000\nEOF\n\u0060\u0060\u0060\n\n### 配置 Envoy Gateway 的 OIDC 认证 {#envoy-gateway-oidc}\n\n创建一个 Kubernetes Secret，用于存储 OAuth Client 的 Client Secret：\n\n\u0060\u0060\u0060bash\nkubectl create secret generic auth0-client-secret --from-literal=client-secret=${CLIENT_SECRET}\n\u0060\u0060\u0060\n\n{{\u003ccallout note 注意\u003e}}\n将 \u0060${CLIENT_SECRET}\u0060 替换成你的 Auth0 Client Secret。\n{{\u003c\/callout\u003e}}\n\n创建一个安全策略（SecurityPolicy）：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.envoyproxy.io\/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: oidc-example\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: eg\n  oidc:\n    provider:\n      issuer: \u0022https:\/\/${DOMAIN}\u0022\n    clientID: \u0022${CLIENT_ID}\u0022\n    clientSecret:\n      name: \u0022auth0-client-secret\u0022\n    redirectURL: \u0022https:\/\/www.example.com\/myapp\/oauth2\/callback\u0022\n    logoutPath: \u0022\/myapp\/logout\u0022\nEOF\n\u0060\u0060\u0060\n\n**注意事项**\n\n- 此处的 \u0060issuer\u0060 应该填写成 Auth0 Domain。\n- \u0060redirectURL\u0060 的值需要出现在 Auth0 配置的 Allowed Callback URLs 中。\n- \u0060logoutPath\u0060 是必须的，即使其 URL 端点并为实现 logout 逻辑。\n\n在这个示例中我们为 Envoy Gateway 网关设置了 OIDC，修改 \u0060targetRef\u0060 到 HTTPRoute，也可以为单个路由设置 OIDC。关于 ODIC 的具体配置，请参考 Envoy Gateway API 文档。\n\n### 验证单点登录：登入 {#login}\n\n将 \u0060www.example.com\u0060 添加到本地的 \u0060\/etc\/hosts\u0060 文件中：\n\n\u0060\u0060\u0060bash\necho \u0022127.0.0.1 www.example.com\u0022 | sudo tee -a \/etc\/hosts\n\u0060\u0060\u0060\n\n配置应用程序的端口转发，以便你可以在本地通过域名访问示例应用：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\n\nsudo kubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 443:443\n\u0060\u0060\u0060\n\n现在在浏览器中访问 \u003chttps:\/\/www.example.com\u003e，跳过证书风险提示，页面将跳转到 Auth0 的登录界面，如下图所示，选择使用 Google 账户登录。\n\n![登录界面](login.webp)\n\n在登录完成后，浏览器将跳转会 \u003chttps:\/\/www.example.com\u003e 页面，并展示 HTTP 请求结果，如下面的 JSON 代码所示。\n\n\u0060\u0060\u0060json\n{\n  \u0022path\u0022: \u0022\/\u0022,\n  \u0022host\u0022: \u0022www.example.com\u0022,\n  \u0022method\u0022: \u0022GET\u0022,\n  \u0022proto\u0022: \u0022HTTP\/1.1\u0022,\n  \u0022headers\u0022: {\n    \/*Omit*\/\n    \u0022Authorization\u0022: [\n      \u0022Bearer eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ\u0022\n    ],\n    \u0022Cookie\u0022: [\n      \u0022OauthHMAC-167a6c5=RPdscXEBap0NeSIppJXoxkHt0qvMz4fNHXo2uvgDgIY=; OauthExpires-167a6c5=1716540771; BearerToken-167a6c5=eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ; IdToken-167a6c5=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFKWkxWbnNrai0tYmhsNlJzVm51OCJ9.eyJpc3MiOiJodHRwczovL2Rldi1hd2hqbXkzOGdnNXF6eDd1LnVzLmF1dGgwLmNvbS8iLCJhdWQiOiJUZzhlNWVoa0xKM2hka3cxTzREMTBQd21QeTcxZHZtdiIsImlhdCI6MTcxNjQ1NDM3MSwiZXhwIjoxNzE2NDkwMzcxLCJzdWIiOiJnb29nbGUtb2F1dGgyfDExMjc0NDc3OTAyMjMzMTA0ODY0MCIsInNpZCI6IjRlSjhDZnZuZjd5Mm1kaE94QXBTY0JiUEhjOS1rZUVLIn0.r9dwIy_HeiO5_I3UlohLkeRES5FGoxqQnwmcA00cA_kdc5mUxgeVopXIhBUjJnTKv7bOUVJvFw21ew4gqVRJfllDyG-s_XfhSW1-lEXmCc2bGYDtOzva6k2S_VRgyMKfG04_DWFuTgO_pLtix28aYq8cGzKJ_VglT_KgRhoktzJu4Js5iCv9JPnydRJmpvRJwX3tDv_Q3mmUSazaLkhOTdiBJFrGlS07qEzJ_iWANZgR8uDNhpXdmlcqpb3MZkkMulr5-jXIgEhBQKpw28tUiSlzh6EpAVuBH9T1w8bUmFRzCc6JPPamJRfflYW5onNgYHDfcU0RpvpsCHRHRAZbdA\u0022\n    ],\n    \/*Omit*\/\n    \u0022User-Agent\u0022: [\n      \u0022Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/125.0.0.0 Safari\/537.36\u0022\n    ],\n    \u0022X-Envoy-Internal\u0022: [\n      \u0022true\u0022\n    ],\n    \u0022X-Forwarded-For\u0022: [\n      \u002210.244.0.51\u0022\n    ],\n    \u0022X-Forwarded-Proto\u0022: [\n      \u0022https\u0022\n    ],\n    \u0022X-Request-Id\u0022: [\n      \u0022c1e64057-c5c8-4fb2-a304-25c291eeed32\u0022\n    ]\n  },\n  \u0022namespace\u0022: \u0022default\u0022,\n  \u0022ingress\u0022: \u0022\u0022,\n  \u0022service\u0022: \u0022\u0022,\n  \u0022pod\u0022: \u0022backend-55d64d8794-4qvgd\u0022\n}\n\u0060\u0060\u0060\n\n此时通过 Chrome 浏览器的  *Inspector - Application - Cookies* 查看到 ID Token 如下图所示：\n\n![在 Chrome Inspector 中查看 ID Token](inspector.webp)\n\n编写代码 Python 代码，\u0060validate_id_token.py\u0060，解析 ID Token 并验证其有效性：\n\n{{\u003c include_code file=\u0022validate_id_token.py\u0022 \u003e}}\n\n安装依赖的包：\n\n\u0060\u0060\u0060bash\npip install pyjwt requests\n\u0060\u0060\u0060\n\n运行代码：\n\n\u0060\u0060\u0060bash\npython validate_id_token.py ${ID_TOKEN}\n\u0060\u0060\u0060\n\n你将看到类似下面的输出：\n\n\u0060\u0060\u0060ini\nToken is valid. Decoded payload:\niss: https:\/\/dev-awhjmy38gg5qzx7u.us.auth0.com\/\naud: Tg8e5ehkLJ3hdkw1O4D10PwmPy71dvmv\niat: 1716470905\nexp: 1716506905\nsub: google-oauth2|112744779022331048640\nsid: 4W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\n\u0060\u0060\u0060\n\n通过该 ID Token 的值可以得出：\n\n- 该令牌由 Auth0 签发（\u0060iss\u0060 字段）。\n- 该令牌的受众是特定的应用或 API（\u0060aud\u0060 字段），对于 Auth0，这个值是 Client ID。\n- 令牌是在 2024 年 5 月 23 日 04:08:25 UTC 签发的（\u0060iat\u0060 字段），并将在 2024 年 5 月 23 日 14:08:25 UTC 过期（\u0060exp\u0060 字段）。\n- 令牌所代表的主体（用户）的唯一标识符是 \u0060google-oauth2|112744779022331048640\u0060（\u0060sub\u0060 字段）。在这里，这个标识符表明使用 Google OAuth2 登录的用户\n- 会话 ID 是 \u00604W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\u0060（\u0060sid\u0060 字段），用于会话管理。\n\n### 验证单点登录：登出 {#logout}\n\n由于我们的示例应用中没有实现 Auth0 的 Logout 逻辑，所以我们需要通过 HTTP 请求明确告知 Auth0 要 logout，在浏览器中访问该 URL：\n\n\u0060\u0060\u0060bash\nhttps:\/\/${DOMAIN}\/v2\/logout?client_id=${CLIENT_ID}\n\u0060\u0060\u0060\n\n请将 \u0060${DOMAIN}\u0060 和 \u0060${CLIENT_ID\u0060 修改为你的 Auth0 应用程序的[配置项](#auth0)。关于 Auth0 如何登出 OIDC 端点的详细说明请查看 [Auth0 文档](https:\/\/auth0.com\/docs\/api\/authentication#logout)。\n\n登出后，页面将再次跳转到登录页面，在登录后，页面将重定向到 \u003chttps:\/\/www.example.com\u003e。\n\n## 总结 {#summary}\n\n通过以上步骤，你可以在 Envoy Gateway 中实现 OIDC 认证，确保 API 的安全性。这种方法不仅能提供灵活的身份验证机制，还能简化应用程序的身份管理。通过集成 Auth0 等身份提供商，Envoy Gateway 可以轻松实现单点登录，提升用户体验和系统安全性。未来，你可以根据需求进一步配置和优化 Envoy Gateway，充分利用其强大的认证和授权功能，以满足更复杂的安全要求和业务需求。\n\n## 参考 {#reference}\n\n- Envoy Gateway OIDC Authentication - gateway.envoyproxy.io\n- [Log Users Out of Auth0 with OIDC Endpoint - auth0.com](https:\/\/auth0.com\/docs\/authenticate\/login\/logout\/log-users-out-of-auth0)\n', '\/blog\/envoy-gateway-oidc\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何配置 Envoy Gateway 使用 OIDC 实现单点登录。通过 Auth0 作为身份提供商，演示如何在 API 网关端实现安全、高效的单点登录，提升用户体验和系统安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-introduction/">Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口', '本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。', '\n在 Kubernetes 环境下选择正确的网络通信工具至关重要。根据[Tetrate 的讨论](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/)，选择取决于网络通信的类型：南北向流量还是东西向流量。对于主要处理外部请求的服务，Envoy Gateway 是理想选择，它不仅高效管理流量，还能在你向微服务架构过渡时提供无缝集成。\n\n本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。\n\n## Envoy Gateway 及其在服务网格中的角色概述 {#overview}\n\nEnvoy Gateway 是一个围绕 Envoy Proxy 构建的 Kubernetes 原生 API 网关，它旨在降低用户采用 Envoy 作为 API 网关的难度，并为供应商建立 API 网关（例如 [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/)）增值产品奠定基础。\n\nEnvoy Gateway 不仅是管理南北流量的理想选择，也可作为连接和保护服务网格中服务的关键组件。它还通过提供安全的数据传输、流量路由、负均衡及故障恢复等功能，增强了微服务之间的通信效率和安全性。Envoy Gateway 利用其内置的 Envoy Proxy 技术，可以处理大量的并发连接和复杂的流量管理策略，同时保持较低的延迟和高吞吐量。\n\n此外，Envoy Gateway 与 Kubernetes Gateway API 的紧密集成使得它能够以声明式的方式进行配置和管理，极大简化了服务网格中网关的部署和更新过程。这种集成不仅提升了操作效率，还使得 Envoy Gateway 能够在不增加额外复杂性的前提下，与服务网格如 Istio 这样的解决方案无缝协作。\n\n下图展示了 Envoy Gateway 与服务网格的关系。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 与服务网格的关系\u0022\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes 集群\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022服务\u0022]\n        pods[\u0022Pod\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022管理南北向流量\u0022 --\u003e svcs\n        eg -- \u0022由...配置\u0022 --\u003e gwapi\n        gwapi -. \u0022定义路由规格\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022服务网格\u0022]\n        smc[\u0022服务网格控制平面（如 Istio、Linkerd）\u0022]\n        smp[\u0022服务网格数据平面（Envoy Sidecars）\u0022]\n        smc -- \u0022配置\u0022 --\u003e smp\n        smp -- \u0022处理东西向流量\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022是...的一部分\u0022 .-\u003e SM\n    svcs -- \u0022连接到\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Envoy Gateway 与服务网格的关系](8691fed7a410e3a8f45252cc5c8e11db.svg)\n\n在 Kubernetes 集群中，Envoy Gateway 负责管理南北向流量，即进出集群的流量，并通过 Kubernetes Gateway API 进行配置，后者定义了服务的路由规格。集群内服务直接连接到 Pods。服务网格部分，由控制平面（如 Istio 或 Linkerd）配置数据平面中的 Envoy Sidecars，这些 Sidecars 负责处理集群内部的东西向流量。在这个系统中，Envoy Gateway 可以与服务网格相互协作，但它们各自独立地管理不同方向的流量。\n\n设想一下，Envoy Gateway 像是一个城市的主要入口（比如海关），所有的数据流，就像各种车辆，都得通过这个大门进出。它就像一个严格的守门员，负责审查、指导，确保每个数据包，就像每个乘客，都能被准确地送到目的地。在 Kubernetes 这座城市中，Envoy Gateway 管理着所有进城的流量，它确保数据流可以安全、高效地进入城市，并被准确地送达给城市内部的服务。\n\n进入城市之后，服务网格就接管了，这就像城市内部的一系列交通网络。服务网格中的 Envoy sidecars 就好比是这座城市内部的出租车或者公交车，负责把数据包从海带到它们在城市内部的具体目的地。Envoy Gateway 负责将外部请求顺利引入，之后服务网格负责在集群内部继续高效地处理这些请求。\n\nEnvoy Gateway 对 Kubernetes Gateway API 的支持，可以看作是对我们城市交通信号系统的一个重大升级。这不仅为进入城市的数据流提供了更加清晰和个性化的指引，而且让整个城市的交通运行更加智能化。\n\n## Envoy Gateway 的核心功能和优势 {#pros}\n\nEnvoy Gateway 提供了几个核心功能，使其成为 API 网关的突出选择：\n\n- **简化配置**：通过与 Kubernetes Gateway API 直接集成，Envoy Gateway 允许开发者使用 Kubernetes 自定义资源以声明方式配置路由规则、安全策略和流量管理。\n- **性能和可扩展性**：基于经过实战测试的 Envoy Proxy，它提供卓越的性能和可扩展性，轻松处理数千个服务和每秒数百万个请求。\n- **安全功能**：内置支持各种安全措施，如 SSL\/TLS 终止、OAuth2、OIDC 认证以及细粒度访问控制。\n- **可观测性**：提供全面的监控能力，包括详细的度量、日志和追踪，这对于诊断和理解流量行为至关重要。\n\n## 与 Gateway API 的关系 {#gateway-api}\n\n在 Kubernetes 环境中引入的 Gateway API 为集成和配置 Ingress 网关提供了一种新的强大方法，它与传统的 Ingress 相比具有更高的灵活性和功能性。正如我在 [Gateway API：Kubernetes 和服务网格入口中网关的未来](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 中所讨论的，Gateway API 通过区分角色和提供跨命名空间支持，更适应多云环境，且已被多数 API 网关采用。这种 API 设计支持了 ingress 网关（南北向流量）与服务网格（东西向流量，跨集群路由）的融合，使得 Envoy Gateway 成为 Kubernetes 和服务网格中统一未来的网关解决方案。通过引入 Gateway API，Envoy Gateway 强化了其作为云原生环境中前沿代理的角色，使得用户能够更灵活地管理其流量和策略。\n\nKubernetes Gateway API 是 Envoy Gateway 的基石，它提供了一种更具表达性、灵活性和以角色为导向的方式来配置 Kubernetes 生态系统中的网关和路由。该 API 提供了如 GatewayClass、Gateway、HTTPRoute 等自定义资源定义（CRD），Envoy Gateway 利用这些资源创建用户友好且一致的配置模型，与 Kubernetes 的原生原则保持一致。\n\n{{\u003ccallout note \u0022什么是 API Gateway？\u0022\u003e}}\n\nAPI Gateway 是对 API 的全面管理和托管服务。它作为应用程序与后端服务之间的中间层，不仅处理创建、维护、发布、运行和下线等生命周期事件，还承担着更多关键职能。一个完善的 API Gateway 应该提供以下功能来丰富和扩展其基本定义：\n\n1. **流量控制**：API Gateway 应能够处理并控制到后端服务的流量，包括请求路由、负载均衡、熔断机制以及速率限制，以保证后端服务的稳定性和高可用性。\n2. **安全性保障**：应具备鉴权、授权和加密功能，能够有效地管理和保护 API 的安全。这涉及到身份验证机制、API 密钥管理、OAuth、JWT、mTLS 等，以确保只有授权的用户和服务能够访问 API。\n3. **监控和分析**：提供实时监控和日志记录功能，能够跟踪 API 的使用情况、性能指标、异常检测和分析流量模式，从而优化 API 的性能和响应能力。\n4. **变更管理**：支持对 API 变更进行管理，包括版本控制和渐进式部署（如蓝绿部署或金丝雀发布），以无缝过渡新版本且最小化对最终用户的影响。\n5. **请求和响应的转换**：允许对传入和传出的 API 调用进行转换，比如从 REST 到 GraphQL 的转换，或是添加、删除和修改请求头和响应头。\n6. **跨域资源共享（CORS）支持**：管理和控制跨域请求，允许不同域的前端应用安全地调用后端 API。\n7. **配额和计费**：为 API 使用设定配额限制，同时支持计费功能，以适用于商业化的 API 提供。\n8. **用户友好的开发者门户**：提供一个面向开发者的门户，使得第三方开发者可以轻松地发现、测试和集成 API。\n9. **协议支持**：支持各种网络协议，包括 HTTP\/HTTPS、WebSocket、gRPC 等，确保与多种客户端和服务的兼容性。\n10. **插件化和扩展性**：允许通过插件或中间件来扩展 API Gateway 的功能，使其可以根据业务需求灵活适配各种中间件服务。\n11. **服务治理**：集成服务注册和发现机制，以适应微服务架构下服务的动态性。\n\n综上所述，API Gateway 的角色远远超越了简单的 API 生命周期管理。它是实现微服务架构、确保服务安全性、提高运维效率和优化用户体验的关键组件。通过这些广泛的功能，API Gateway 成为现代云原生应用不可或缺的一部分。\n\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 架构概览 {#arch}\n\nEnvoy Gateway 的架构设计旨在轻量级和简洁。它包括一个动态配置运行作为数据平面的 Envoy 代理的控制平面。这种关注点的分离确保了网关可以随着流量的增长而扩展，而不影响控制平面的效率。\n\nEnvoy Gateway 的架构图如下所示。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n在这个架构图的核心是 Envoy Gateway，它是 Envoy 代理的执行实例，负责处理从 Kubernetes 集群进出的所有流量。初始启动时，Envoy Gateway 通过配置文件提供静态配置，建立其操作的基本参数。\n\nEnvoy Gateway 配置的动态方面由提供者处理，该提供者定义了网关与 Kubernetes 或其他动态配置输入源的交互。资源监视器负责监视 Kubernetes 资源的更改，特别关注与自定义资源定义（CRD）相关的 CRUD 操作。\n\n随着更改的发生，资源转换器介入将这些外部资源转换为 Envoy Gateway 可以理解的形式。这一转换过程进一步由特定于提供者的基础设施管理器促进，后者负责管理与特定云或基础设施提供商相关的资源，塑造中间表示形式的基础设施，这对于网关的功能至关重要。\n\n然后，该中间表示形式转变为 xDS 中间表示形式，作为 Envoy 理解和执行的最终 xDS 配置的先导。xDS 翻译器承担将这种中间表示形式转换为具体的 xDS 配置的角色。\n\n这些配置由 xDS 服务器交付并执行，该服务器作为服务，根据其收到的 xDS 配置，认真管理 Envoy 实例。Envoy 作为实际运行的代理，最终从 xDS 服务器接收这些配置，解释并实现它们以有效管理流量请求。\n\n最终，所有请求经过 Envoy 的处理后被重定向到了 Envoy Gateway 路由的流量的最终目的地，也就是后端服务。\n\n## 与其他网关的比较 {#comparations}\n\n与 Istio 的入口网关或 NGINX Ingress 等其他流行解决方案相比，Envoy Gateway 凭借其与 Kubernetes 的原生集成以及利用 Envoy 全部潜力的专注，而脱颖而出。下图从多方面对比了目前流行的一些开源的 API 网关。\n\n{{\u003ctable \u0022开源 API 网关对比\u0022\u003e}}\n| API 网关      | 支持的认证和授权策略                                         | 支持的服务发现组件                     | 支持的协议                       | 控制平面配置分发方法 | 支持的插件扩展机制   | 组织隶属               |\n| ------------- | ------------------------------------------------------------ | -------------------------------------- | -------------------------------- | -------------------- | -------------------- | -------------------------- |\n| Envoy Gateway | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                        | HTTP, HTTPS, gRPC                | xDS                  | 基于 Envoy Filter | CNCF                       |\n| Kuma          | mTLS, JWT                                                    | Kubernetes, Consul                     | HTTP, HTTPS, gRPC, TCP           | REST, gRPC           | 基于 Lua, Go       | CNCF                       |\n| NGINX Ingress | RBAC                                                         | Kubernetes                             | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD       | 基于 Nginx 模块    | N\/A                        |\n| APISIX        | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID 等 | Kubernetes, DNS, Consul, Nacos, Eureka | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI    | 基于 Lua, Wasm    | Apache Software Foundation |\n| Kong          | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI   | 基于 Lua          | N\/A                        |\n| Emissary      | Basic Auth                                                   | Kubernetes                             | HTTP, HTTPS, gRPC                | Kubernetes CRD       | 基于 Lua, Go      | CNCF                       |\n{{\u003c\/table\u003e}}\n\n## 快速开始使用 Envoy Gateway {#envoy-gateway-quick-start}\n\n要快速上手 Envoy Gateway，你可以通过以下简化步骤快速搭建一个本地实验环境。首先，启动一个本地 Kubernetes 集群：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\n接下来，部署 Gateway API CRD 和 Envoy Gateway 本身：\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n然后，安装网关配置并部署一个示例应用：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n为了暴露 LoadBalancer 服务，这里我们使用端口转发作为示例。你也可以选择使用 \u0060minikube tunnel\u0060 或安装 [MetalLB](https:\/\/metallb.universe.tf\/installation\/) 作为负载均衡器：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\n通过以下命令测试你的 Envoy Gateway 是否正常工作：\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\n想了解更多详细的安装和配置步骤，请访问 Envoy Gateway 网站。通过这些步骤，你可以快速开始探索 Envoy Gateway 的功能。\n\n## 总结 {#summary}\n\nEnvoy Gateway 不仅优化了云原生时代的七层网关配置，而且为从边缘网关向服务网格过渡提供了一个平滑的道路。由于服务网格的推广面临一些挑战，如对应用的侵入性和运维团队推动问题，边缘网关则更易于被开发团队接受。Envoy Gateway 采用简化的 Kubernetes Gateway API，提高了流量管理和可观测性的能力。此外，Envoy Gateway 到 Istio 的过渡对于已熟悉 Envoy 功能的团队来说，将是一个自信的技术进步，同时还支持从标准的 Kubernetes Gateway API 到 Istio Ingress Gateway 的无缝切换，或者作为一个定制解决方案继续与 Istio 协作。这些特点使得 Envoy Gateway 成为一个在云原生时代值得投资的网关选择。\n\n请继续关注本系列博客的后续部分，我们将深入探讨如何配置和优化 Envoy Gateway，提供实用指南并展示更广泛的实际应用案例。\n', '\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/tetrate-vulnerability-scaner/">TVS：Istio 和 Envoy CVE 扫描解决方案</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('TVS：Istio 和 Envoy CVE 扫描解决方案', '本文将介绍 Tetrate 新推出的工具——Tetrate Vulnerability Scanner (TVS)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。', '\n本文将介绍 Tetrate 新推出的工具——[Tetrate Vulnerability Scanner (TVS)](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。在深入了解 TVS 的具体功能前，我们先简要回顾 CVE 的概念及其在软件安全性中的核心作用。\n\n## CVE 概览\n\nCVE，即通用漏洞和暴露，是一个公开的漏洞数据库，由 MITRE 公司负责维护。它旨在为软件中的漏洞提供一个标准化的命名体系，包含了漏洞的标识号、详细描述及参考链接。虽然 CVE 本身不提供漏洞的严重性评分，但它为网络安全专家、开发人员和企业提供了一个获取关键安全信息的重要平台。每个 CVE 记录的唯一标识号便于追踪漏洞相关信息，诸如受影响的软件系统、修复措施等。例如，2021 年著名的 Log4j 漏洞（CVE-2021-44228）由于影响广泛，严重程度评级为 10。\n\n## CVE 的实用场景\n\n一个典型的 CVE 使用案例是将 CVE 扫描功能集成到 CI\/CD 管道中，以自动化安全测试，从而阻止带有已知漏洞的代码合并到代码库并接收警报。这一过程有助于确保应用程序不会使用带有漏洞的包或库，从而提高了软件的安全性。\n\n例如 Github 将 CVE 检测和处理作为[供应链安全](https:\/\/docs.github.com\/en\/code-security\/supply-chain-security\/understanding-your-software-supply-chain\/about-supply-chain-security#what-is-dependabot)的关键一环，如果你在 Github 上托管了开源项目，并开启了 Dependabot，每当你的 PR 或 commit 存在漏洞时，你就可能收到类似下面的 CVE 通知：[jQuery Cross Site Scripting vulnerability](https:\/\/github.com\/advisories\/GHSA-257q-pv89-v3xv)。收到通知后你可以选择容忍该漏洞或者应用 patch。下图展示了 CVE 的处理流程。\n\n\u0060\u0060\u0060mermaid \u0022CVE 的处理流程\u0022\ngraph TD\n    A([Start]) --\u003e B(Discover Vulnerability)\n    B --\u003e|Security Researchers| C{Is it a new vulnerability?}\n    C --\u003e|Yes| D[Assign CVE ID]\n    C --\u003e|No| E[Refer to existing CVE entry]\n    D --\u003e|\u0022CVE Numbering Authorities (CNAs)\u0022| F[Publicly disclose details]\n    F --\u003e|Vendors\/Project Owners| G{Is patch available?}\n    G --\u003e|Yes| H[Develop and Release Patch]\n    G --\u003e|No| I[Issue Workaround or Mitigation Steps]\n    H --\u003e J[Deploy Patch]\n    I --\u003e J\n    J --\u003e|End Users\/System Administrators| K[Apply Patch or Mitigation]\n    K --\u003e L[Monitor for Issues\/Compliance]\n    L --\u003e M([End])\n\u0060\u0060\u0060\n\n![CVE 的处理流程](ba0a0031313b5067534b47482f51d78a.svg)\n\n\n\n\n\n## TVS 功能介绍\n\nIstio 经常在其官网发布 CVE 通知，例如 [ISTIO-SECURITY-2024-001](https:\/\/istio.io\/latest\/news\/security\/istio-security-2024-001\/)。以前，你必须手动跟踪这些通知，但现在你可以使用 TVS 自动执行 CVE 扫描任务，从而显着减少安全团队的工作量。\n\n目前 TVS 仅提供命令行工具，未来将作为服务集成到 TIS 中。下图展示了 TVS 运行结果。\n\n![TVS CLI](tvs.jpg)\n\n下图说明了 TVS 的工作流程。\n\n\u0060\u0060\u0060mermaid \u0022TVS 的工作流程示意图\u0022\ngraph TD\n    A([Start]) --\u003e B(Istio Containers Installed)\n    B --\u003e C(Collect SHA Digests)\n    C --\u003e D(Send Digests to Tetrate\u0027s APIs)\n    D --\u003e E{Is CVE Detected?}\n    E --\u003e|Yes| F[Log SHA Digests Without Personal Info]\n    E --\u003e|No| G[End, No Action Required]\n    F --\u003e H[Notify Users]\n    H --\u003e I[Apply Patches\/Workarounds]\n    I --\u003e J([End])\n\u0060\u0060\u0060\n\n![TVS 的工作流程示意图](9232ba9319ac498b7fcf50bb60bff86b.svg)\n\n\n\n1. 在 Istio 容器安装后开始。\n2. 收集安装的 Istio 容器的 SHA 摘要。\n3. 将摘要发送到 Tetrate 的 API。\n4. API 检测是否存在 CVE。\n   - 如果检测到 CVE，记录 SHA 摘要但不包含任何个人信息，并通知用户。\n   - 如果未检测到 CVE，则不需要采取任何行动。\n5. 用户收到通知后，应用补丁或缓解措施。\n6. 流程结束。\n\n所有人都可以免费下载和使用 TVS，不过在执行 CVE 扫描之前你需要先注册，详见 [TIS 文档](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)。\n\n## 供应链安全建议\n\n有[报告](https:\/\/www.slim.ai\/blog\/container-report-2023)指出，现在即使最流行的容器最新版本也有数百个 CVE，下面是为了保证的一些建议：\n\n- 尽早开始漏洞扫描和处理，而不是等到最后\n- 在 CI\/CD 中集成漏洞扫描工具\n- 定期更新 Istio 和 Envoy 到最新版本\n- 使用 Istio 官方推出的 [distroless 镜像](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/security\/harden-docker-images\/)，可以有效的减少攻击面并包含尽可能少的漏洞\n- 遵循 CNCF 推出的[软件供应链最佳实践](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/supply-chain-security\/supply-chain-security-paper\/sscsp.md)\n- 遵循 [Istio 安全最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n\n## TVS 的独特价值\n\nTVS 通过其命令行工具提供简便的 CVE 扫描操作，未来还计划在 Kubernetes 和 Tetrate Istio Subscription (TIS) 中集成，以进一步简化 Istio 和 Envoy 的 CVE 管理过程。TIS 提供自 Istio 发布起 14 个月内的 CVE 补丁和向后兼容支持，帮助用户及时获得安全更新，同时保持系统的稳定运行。\n\nTVS 为所有用户免费开放下载使用，使用前需进行简单的注册。更多信息请参阅 [TIS 文档](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)。\n\n通过采纳 TVS 这一自动化的 CVE 扫描工具，企业能够更有效地识别和处理 Istio 及 Envoy 中的安全漏洞，提升基础设施的安全性，同时减轻安全团队的负担，推动安全管理流程的高效运作。\n', '\/blog\/tetrate-vulnerability-scaner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将介绍 Tetrate 新推出的工具——Tetrate Vulnerability Scanner (TVS)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/preserve-source-ip-in-istio/">维持请求的透明度：在 Istio 中保留客户端请求的源 IP</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('维持请求的透明度：在 Istio 中保留客户端请求的源 IP', '本文专注于如何在 Istio 服务网格中保持客户端源 IP 的透明性。', '\n本博文解析了在 Istio 服务网格中服务端获取客户端源 IP 的挑战，并提供了解决方案。将探讨以下问题：\n\n- 数据包传输中源 IP 丢失的原因；\n- 如何确定客户端源 IP；\n- 在南北向和东西向请求中传递源 IP 的策略；\n- 针对 HTTP 和 TCP 协议的处理方法。\n\n## 源 IP 保留的重要性\n\n保留客户端源 IP 的主要理由包括：\n\n- **访问控制策略**：基于源 IP 执行身份验证或安全策略；\n- **负载均衡**：实现基于客户端 IP 的请求路由；\n- **数据分析**：包含真实源地址的访问日志和监控指标，助力开发人员进行分析。\n\n## 保留源 IP 的含义\n\n保留源 IP 指的是在请求从客户端发出、经过负载均衡器或反向代理后，避免真实的客户端源 IP 被替换的情况。\n\n以下是源 IP 地址丢失的流程示例：\n\n\u0060\u0060\u0060mermaid \u0022源 IP 地址丢失的流程\u0022\nsequenceDiagram\n    participant C as Client\n    participant LB as Load Balancer\n    participant IG as Ingress Gateway\n    participant S as Server\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Altered Request (IP Changed)\n    IG-\u003e\u003eS: Forwarded Request\n    Note over IG,S: Source IP Lost\n\u0060\u0060\u0060\n\n![源 IP 地址丢失的流程](9a331cc374c51421ecb64e58b25a6c4d.svg)\n\n\n\n上面图只是最常见的一种情况。本文考虑到以下几种情况：\n\n1. 南北向流量：客户端通过负载均衡器（网关）访问服务端\n   1. 只有一层网关\n   2. 两层或两层以上网关\n2. 东西向流量：网格内部的服务间访问\n3. 协议：HTTP 和 TCP\n\n## 如何确认客户端源 IP？\n\n在 Istio 服务网格中，Envoy 代理通常会将客户端 IP 添加到 HTTP 请求的 \u0022X-Forwarded-For\u0022 头部中。以下是确认客户端 IP 的步骤：\n\n1. **检查 x-forwarded-for 头部**：包含请求路径上各代理的 IP 地址。\n2. **选择最后一个 IP**：通常，最后一个 IP 是最接近服务器的客户端 IP。\n3. **验证 IP 的可信性**：检查代理服务器的信任度。\n4. **使用 x-envoy-external-address**：Envoy 可以设置此头部，包含客户端真实 IP。\n\n详情请见 Envoy 文档中对 [\u0060x-forwarded-for\u0060 标头](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#config-http-conn-man-headers-x-forwarded-for)的说明。对于 TCP\/IP 连接，可以通过协议字段解析客户端 IP。\n\n## 测试环境\n\n**GKE**\n\n- Client Version: v1.28.4\n- Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3\n- Server Version: v1.27.7-gke.1121000\n\n**Istio**\n\n- client version: 1.20.1\n- control plane version: 1.20.1\n- data plane version: 1.20.1 (12 proxies)\n\n**CNI**\n\n我们使用了 Cilium CNI，但是没有开启无 kube-proxy 模式。\n\n- cilium-cli: v0.15.18 compiled with go1.21.5 on darwin\/amd64\n- cilium image (default): v1.14.4\n- cilium image (stable): unknown\n- cilium image (running): 1.14.5\n\n**Node**\n\n| 节点名称                                | 内部 IP     | 备注                         |\n| --------------------------------------- | ----------- | ---------------------------- |\n| gke-cluster1-default-pool-5e4152ba-t5h3 | 10.128.0.53 |                              |\n| gke-cluster1-default-pool-5e4152ba-ubc9 | 10.128.0.52 |                              |\n| gke-cluster1-default-pool-5e4152ba-yzbg | 10.128.0.54 | Ingress Gateway Pod 所在节点 |\n\n执行测试的本地客户端电脑的公网 IP：123.120.247.15\n\n## 部署测试示例\n\n下图展示了测试方式：\n\n\u0060\u0060\u0060mermaid \u0022测试方式\u0022\nsequenceDiagram\n    participant C as Client\n    participant LB as Load Balancer\n    participant IG as Ingress Gateway\n    participant S as Source IP App\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Forward Request \n    IG-\u003e\u003eS: Forwarded Request\n\u0060\u0060\u0060\n\n![测试方式](8cd62d9391e2e4fb0b4b257075c64426.svg)\n\n\n\n首先参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/)部署 Istio，然后为 default 命名空间开启 sidecar 自动注入：\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\n\u0060\u0060\u0060\n\n在 Istio 中部署 echo-server 应用测试。echo-server 是一个基于 Nginx 的服务器，用于回显客户端发送的请求信息，例如请求头、客户端地址、请求方法等。\n\n\u0060\u0060\u0060bash\nkubectl create deployment echo-server --image=registry.k8s.io\/echoserver:1.4\nkubectl expose deployment echo-server --name=clusterip --port=80 --target-port=8080\n\u0060\u0060\u0060\n\n创建 Ingress Gateway：\n\n\u0060\u0060\u0060bash\ncat\u003econfig.yaml\u003c\u003cEOF\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: clusterip-gateway\nspec:\n  selector:\n    istio: ingressgateway # 根据你的环境选择适当的 selector\n  servers:\n    - port:\n        number: 80\n        name: http\n        protocol: HTTP\n      hosts:\n        - \u0022clusterip.jimmysong.io\u0022 # 替换成你想要使用的主机名\n---\napiVersion:  networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: clusterip-virtualservice\nspec:\n  hosts:\n    - \u0022clusterip.jimmysong.io\u0022 # 替换成与 Gateway 中相同的主机名\n  gateways:\n    - clusterip-gateway # 这里使用 Gateway 的名称\n  http:\n    - route:\n        - destination:\n            host: clusterip.default.svc.cluster.local # 替换成你的 Service 的实际主机名\n            port:\n              number: 80 # Service 的端口\nEOF\nkubectl apply -f config.yaml\n\u0060\u0060\u0060\n\n查看 Ingress Gateway 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/istio-ingressgateway -n istio-system\n\u0060\u0060\u0060\n\n查看 Sleep Pod 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/sleep -n default -c istio-proxy\n\u0060\u0060\u0060\n\n查看 Source IP App 中的 Envoy 日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -f deployment\/echo-server -n default -c istio-proxy\n\u0060\u0060\u0060\n\n获取网关公网 IP：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_IP=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n在本地使用 curl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n### 资源 IP\n\n当部署好测试应用后，你需要获取与以下资源的 IP 地址。在接下来的实验环节中将会用到。\n\n**Pod**\n\n下面是初始状况下的 Pod IP，随着对 Deployment 的补丁，Pod 会重建，名称和 IP 地址都会变。\n\n| Pod 名称                              | Pod IP      |\n| ------------------------------------- | ----------- |\n| echo-server-6d9f5d97d7-fznrq          | 10.32.1.205 |\n| sleep-9454cc476-2dskx                 | 10.32.3.202 |\n| istio-ingressgateway-6c96bdcd74-zh46d | 10.32.1.221 |\n\n**Service**\n\n| Service 名称         | Cluster IP  | External IP   |\n| -------------------- | ----------- | ------------- |\n| clusterip            | 10.36.8.86  | -             |\n| sleep                | 10.36.14.12 | -             |\n| istio-ingressgateway | 10.36.4.127 | 35.188.212.88 |\n\n## 南北向流量\n\n我们首先考虑客户端位于 Kubernetes 集群外，通过负载均衡器来访问集群内部服务的情况。\n\n### 测试 1：Cluster 流量策略、iptables 流量劫持\n\n这是通过以上步骤部署完测试应用后的默认情况，也是大家遇到的所谓的源 IP 地址丢失的情况。\n\ncurl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n\n{{\u003chighlight text \u0022linenos=table,hl_lines=2 21 23\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip.jimmysong.io:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip.jimmysong.io\nuser-agent=curl\/8.4.0\nx-b3-parentspanid=03c124c5f910001a\nx-b3-sampled=1\nx-b3-spanid=103dc912ec14f3b4\nx-b3-traceid=140ffa034822077f03c124c5f910001a\nx-envoy-attempt-count=1\nx-envoy-internal=true\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=79253e34e1c28d389e9bfb1a62ffe8944b2c3c369b46bf4a9faf055b55dedb7f;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\nx-forwarded-for=10.128.0.54\nx-forwarded-proto=http\nx-request-id=b3c05e22-594e-98da-ab23-da711a8f53ec\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n\n{{\u003c\/detail\u003e}}\n\n你只需要关注 \u0060client_address\u0060 和 \u0060x-forwarded-for\u0060 这两个结果即可。下文的 curl 测试结果中将省略其他信息。\n\n{{\u003ccallout note 说明\u003e}}\n\n该结果中字段的含义：\n\n- \u0060client_address\u0060：通过解析 TCP\/IP 协议而获取的客户端 IP 地址，在 Envoy 中称为 remote address。\n- \u0060x-forwarded-for\u0060：\u0060x-forwarded-for\u0060 (XFF) 是一个标准的代理头部，用于指示请求在从客户端到服务器的过程中经过的 IP 地址。一个合规的代理会在代理请求之前将最近客户端的 IP 地址添加到 XFF 列表中。详见 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)。\n\n{{\u003c\/callout\u003e}}\n\n从测试结果中我们可以看出，源 IP 地址变成了 Ingress  Gateway  Pod 所在节点的 IP 地址（\u006010.128.0.54\u0060）。\n\n下图展示是两个 Pod 中的数据包流量路径。\n\n\u0060\u0060\u0060mermaid \u0022两个 Pod 中的数据包流量路径\u0022\ngraph LR\nsubgraph IngressGatewayPod[Ingress Gateway Pod]\nA[\u0022Downstream Remote (Ingress Gateway Node)\u003cbr\u003e10.128.0.54:56532\u0022] --\u003e B\n    B[\u0022Downstream Local (Ingresss Gateway Pod)\u003cbr\u003e10.32.1.221:8080\u0022]--\u003eC\n    C[\u0022Upstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:59842\u0022]\n    C --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\n    E[\u0022Downstream Remote (Ingress Gateway Pod)\u003cbr\u003e10.128.0.54:0\u0022] --\u003e F\n    F[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    G[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:60481\u0022]\n    H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    F --\u003e G\n    G --\u003e H\nend\nIngressGatewayPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![两个 Pod 中的数据包流量路径](80963dcc68a315cb631ee687bb10a409.svg)\n\n\n\n对于这种情况，要想保留源 IP 其实很简单，而且也是 Kubernetes 提供的标准选项。\n\n### 源 IP 地址是如何丢失的？\n\n下图展示客户端的源 IP 是如何在请求过程中丢失的。\n\n\u0060\u0060\u0060mermaid \u0022客户端的源 IP 是如何在请求过程中丢失的\u0022\nsequenceDiagram\n    participant C as Client\u003cbr\u003e123.120.247.15\n    participant LB as Load Balancer\u003cbr\u003e35.188.212.88\n    box Node \u003cbr\u003e10.128.0.54\n    participant IG as Ingress Gateway\u003cbr\u003e10.32.1.221\n    end\n    participant S as Source IP App Pod\u003cbr\u003e10.32.1.205\n    C-\u003e\u003eLB: Initial Request\n    LB-\u003e\u003eIG: Altered Request (IP Changed)\u003cbr\u003eSNAT: 123.120.234.15 -\u003e 10.128.0.54\n    IG-\u003e\u003eS: Forwarded Request\n    Note over IG,S: Source IP Lost\n\u0060\u0060\u0060\n\n![客户端的源 IP 是如何在请求过程中丢失的](3aeef9eef475587bbca6edb88a134f69.svg)\n\n\n\n因为负载均衡器将数据包发送到 Kubernetes 集群中的任意节点，在此过程中会进行 SNAT，导致最终发送到 Server Pod 中的客户端源 IP 丢失。\n\n### 如何保留客户端源 IP\n\n你可以通过设置 service 中的 \u0060externalTrafficPolicy\u0060 字段为 \u0060Local\u0060 控制负载均衡器保留源 IP。\n\n**externalTrafficPolicy**\n\n\u0060externalTrafficPolicy\u0060 是一个[标准 Service 选项](https:\/\/kubernetes.io\/docs\/tasks\/access-application-cluster\/create-external-load-balancer\/#preserving-the-client-source-ip)，用于定义传入 Kubernetes 节点的流量是否进行负载均衡以及如何进行负载均衡。\u0060Cluster\u0060 是默认策略，但 \u0060Local\u0060 通常用于保留传入集群节点的流量的来源 IP。\u0060Local\u0060 会在集群节点上有效停用负载均衡，以使本地 Pod 接收的流量看到原始来源 IP 地址。\n\n\u0060\u0060\u0060mermaid \u0022externalTrafficPolicy\u0022\ngraph TD;\n    A[Client Request] --\u003e|Sent to Service| B[Load Balancer]\n    B --\u003e|externalTrafficPolicy: Local| C[Node with Service Endpoint]\n    C --\u003e|Source IP Preserved| D[Service Handling Request]\n    B --\u003e|\u0022externalTrafficPolicy: Cluster (Default)\u0022| E[Any Node in Cluster]\n    E --\u003e|Source IP Altered| D\n\u0060\u0060\u0060\n\n![externalTrafficPolicy](02f4d9919bbd6f3d5fc5682c3793896a.svg)\n\n\n\n也就是说将 \u0060externalTrafficPolicy\u0060 设置为 \u0060Local\u0060 就可以让数据包绕过节点上的 kube-proxy，而直达目标 Pod。但是大多数人在 Kubernetes 中创建 Service 时都没有设置 \u0060externalTrafficPolicy\u0060，所以使用了默认的 \u0060Cluster\u0060 策略。\n\n既然 Service 采用 Local 外部流量策略可以保留客户端的源 IP 地址，那为什么 Kubernetes 不默认采用呢？\n\n{{\u003ccallout note 说明\u003e}}\n\n通过 Local 模式暴露服务以获取客户端源 IP 是一种对可靠性的妥协，如果大家有更好的方案欢迎推荐给我。\n\n{{\u003c\/callout\u003e}}\n\nKubernetes 默认将 Service 的 \u0060externalTrafficPolicy\u0060 设置为 \u0060Cluster\u0060 而非 \u0060Local\u0060，主要是基于以下考虑：\n\n1. **负载均衡**：确保流量在所有节点之间平均分配，避免单个节点过载。\n2. **高可用性**：允许流量被集群中任何节点接收，提高服务的可用性。\n3. **简化配置**：\u0060Cluster\u0060 模式降低了网络配置的复杂性。\n4. **性能优化**：避免由于保留客户端源 IP 而引起的潜在性能问题。\n5. **通用性**：兼容多种网络环境和集群配置，适应更广泛的使用场景。\n\n### 测试 2：Local 流量策略、iptables 流量劫持\n\n将 Ingress Gateway Service  设置为 Local 外部流量策略：\n\n\u0060\u0060\u0060bash\nkubectl patch svc istio-ingressgateway -p \u0027{\u0022spec\u0022:{\u0022externalTrafficPolicy\u0022:\u0022Local\u0022}}\u0027 -n istio-system\n\u0060\u0060\u0060\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 $GATEWAY_IP\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n\n{{\u003chighlight text \u0022linenos=table,hl_lines=2 21 23\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip.jimmysong.io:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip.jimmysong.io\nuser-agent=curl\/8.4.0\nx-b3-parentspanid=060c393adb561603\nx-b3-sampled=1\nx-b3-spanid=8df3e10078cc826b\nx-b3-traceid=cf26040ae9536702060c393adb561603\nx-envoy-attempt-count=1\nx-envoy-external-address=123.120.247.15\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=79253e34e1c28d389e9bfb1a62ffe8944b2c3c369b46bf4a9faf055b55dedb7f;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\nx-forwarded-for=123.120.247.15\nx-forwarded-proto=http\nx-request-id=35bc2123-0971-9a9c-84c1-2aeee233a268\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n通过 Envoy 日志可以得出现在的数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 1\u0022\ngraph LR\nsubgraph IngressGatewayPod[Ingress Gateway Pod]\n    B[\u0022Downstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:8080\u0022]\n    C[\u0022Upstream Local (Ingress Gateway Pod)\u003cbr\u003e10.32.1.221:59842\u0022]\nA[\u0022Downstream Remote (Client)\u003cbr\u003e123.120.247.15:62650\u0022] --\u003e B\nB --\u003e C\nC --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\n    F[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\n    G[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:58639\u0022]\n    H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.205:8080\u0022]\nE[\u0022Downstream Remote (Client)\u003cbr\u003e123.120.247.15:0\u0022] --\u003e F\nF --\u003e G\nG --\u003e H\nend\nIngressGatewayPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![数据包路径 1](566a610667551fdcd025fc541c3d1fe7.svg)\n\n客户端源 IP 被正确识别为 \u0060123.120.247.15\u0060。\n\n## 东西向流量\n\n在 Istio 默认配置的情况下，对于东西向流量，服务端也无法获取正确的客户端源 IP。\n\n### 测试 3：Local 流量策略、tproxy 流量劫持\n\n将 Source IP App 中的流量拦截方式从 iptables 修改为 [tproxy](\/blog\/what-is-tproxy\/)：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment -n default echo-server -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022sidecar.istio.io\/interceptionMode\u0022:\u0022TPROXY\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：此时 Source IP App 的 Pod 将会重建，新的 Pod 名称是 \u0060echo-server-686d564647-r7nlq\u0060，IP 地址是 10.32.1.140。\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deployment\/sleep -it -- curl clusterip\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n{{\u003chighlight text \u0022linenos=table,hl_lines=2\u0022\u003e}}\nCLIENT VALUES:\nclient_address=10.32.3.202\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip\nuser-agent=curl\/8.5.0\nx-b3-parentspanid=3c07f3b87cc547dd\nx-b3-sampled=1\nx-b3-spanid=97844ebdde748bfc\nx-b3-traceid=90f57b0fb260dfbf3c07f3b87cc547dd\nx-envoy-attempt-count=1\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=25af59fcf9fbe745eb75a318c47d55059d75914632d2536a43a80d342eaed27c;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\nx-forwarded-proto=http\nx-request-id=e9b27bde-3cf6-9d8b-8f23-1cb0fa35d405\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n下图展示了数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 2\u0022\ngraph LR\nsubgraph SleepPod[Sleep Pod]\nA[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:38394\u0022] --\u003e B\nB[\u0022Downstream Local (Clusterip Service)\u003cbr\u003e10.36.8.86:80\u0022] --\u003e C\nC[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:33786\u0022] --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022]\nend\nsubgraph SourceIPAppPod[Source IP App Pod]\nE[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:33786\u0022] --\u003e F\nF[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022] --\u003e G\nG[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:34173\u0022] --\u003e H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.140:8080\u0022]\nend\nSleepPod--\u003eSourceIPAppPod\n\u0060\u0060\u0060\n\n![数据包路径 2](72c7107f23253c70fabc41ed04a0140f.svg)\n\n客户端 IP 被正确识别为 \u006010.32.3.202\u0060。\n\n### 测试 4：Local 流量策略、iptables 流量劫持\n\n将 Source IP App 中的流量拦截方式恢复为 redirect：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment -n default echo-server -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022sidecar.istio.io\/interceptionMode\u0022:\u0022REDIRECT\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：此时 Source IP App 的 Pod 将会重建，新的 Pod 名称是 \u0060echo-server-6d9f5d97d7-bgpk6\u0060，IP 地址是 10.32.1.123。\n\nCurl 测试：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deployment\/sleep -it -- curl clusterip\n\u0060\u0060\u0060\n\n{{\u003cdetail \u0022查看结果\u0022\u003e}}\n{{\u003chighlight text \u0022linenos=table,hl_lines=2\u0022\u003e}}\nCLIENT VALUES:\nclient_address=127.0.0.6\ncommand=GET\nreal path=\/\nquery=nil\nrequest_version=1.1\nrequest_uri=http:\/\/clusterip:8080\/\n\nSERVER VALUES:\nserver_version=nginx: 1.10.0 - lua: 10001\n\nHEADERS RECEIVED:\naccept=*\/*\nhost=clusterip\nuser-agent=curl\/8.5.0\nx-b3-parentspanid=6123380e58ca0ce7\nx-b3-sampled=1\nx-b3-spanid=633848c0065ec91e\nx-b3-traceid=dbcda8b3673e70a46123380e58ca0ce7\nx-envoy-attempt-count=1\nx-forwarded-client-cert=By=spiffe:\/\/cluster.local\/ns\/default\/sa\/default;Hash=25af59fcf9fbe745eb75a318c47d55059d75914632d2536a43a80d342eaed27c;Subject=\u0022\u0022;URI=spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\nx-forwarded-proto=http\nx-request-id=b05e07e1-08ba-9449-90a9-a4a98277a8c0\nBODY:\n-no body in request-\n{{\u003c\/highlight\u003e}}\n{{\u003c\/detail\u003e}}\n\n下图展示了数据包路径：\n\n\u0060\u0060\u0060mermaid \u0022数据包路径 3\u0022\ngraph LR\nsubgraph Sleep[Sleep Pod]\nA[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:34238\u0022] --\u003e B\nB[\u0022Downstream Local (Clusterip Service)\u003cbr\u003e10.36.8.86:80\u0022] --\u003e C\nC[\u0022Upstream Local (Sleep Pod)\u003cbr\u003e10.32.3.202:52776\u0022] --\u003e D[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022]\nend\nsubgraph SourceIPApp[Source IP App Pod]\nE[\u0022Downstream Remote (Sleep Pod)\u003cbr\u003e10.32.3.202:52776\u0022] --\u003e F\nF[\u0022Downstream Local (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022] --\u003e G\nG[\u0022Upstream Local (InboundPassthroughClusterIpv4)\u003cbr\u003e127.0.0.6:49803\u0022] --\u003e H[\u0022Upstream Host (Source IP App Pod)\u003cbr\u003e10.32.1.123:8080\u0022]\nend\nSleep --\u003eSourceIPApp\n\u0060\u0060\u0060\n\n![数据包路径 3](8993fe075c1e3ecc7c42eefb98fccb21.svg)\n\n客户端源 IP 被识别为 \u0060127.0.0.6\u0060。\n\n## 单层代理场景总结\n\n在单层代理的情况下，只需要将 Ingress Gateway 的 Service 的 \u0060externalTrafficPolicy\u0060 设置为 \u0060Local\u0060 即可保留客户端源 IP。将目标服务的流量拦截模式修改为 \u0060TPROXY\u0060 即可以保留东西向请求中的源 IP。\n\n## 多层代理\n\n如果流量在进入 Istio Mesh 前已经经过的多层代理转发，每次流量经过代理时，代理解析 HTTP 流量并将其自身的 IP 地址追加到 \u0060x-forwarded-for\u0060 标头中。那么可以使用 \u0060numTrustedProxies\u0060 配置您信任的代理跳数，请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for) 了解如何确定 \u0060X-Forwarded-For\u0060 标头和受信任的客户端地址。\n\n实际上我们很难确定流量在到达 Istio Mesh 时究竟经过了几层代理，但你可以根据 \u0060x-forwarded-for\u0060 标头了解流量的转发路径。\n\n下图展示了 Envoy 如何根据 \u0060x-forwarded-for\u0060 标头和 \u0060xff_num_trusted_hops\u0060（对应 Istio 中的 \u0060numTrustedProxies\u0060 配置）来确认源 IP 的流程。详见 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)。\n\n\u0060\u0060\u0060mermaid \u0022多层代理\u0022\ngraph TD\n    A[Start] --\u003e|use_remote_address is false| B[Check XFF]\n    A --\u003e|use_remote_address is true| G[Check xff_num_trusted_hops]\n    B --\u003e|XFF contains at least one IP| C[Use last IP in XFF]\n    B --\u003e|XFF is empty| D[Use immediate downstream IP]\n    G --\u003e|xff_num_trusted_hops \u003e 0| H[\u0022Use (N)th IP from right in XFF\u0022]\n    G --\u003e|xff_num_trusted_hops \u003c= 0| D\n    H --\u003e|XFF contains \u003e= N addresses| I[Use Nth address from right]\n    H --\u003e|XFF contains \u003c N addresses| D\n\u0060\u0060\u0060\n\n![多层代理](b82caafefa304b53c996da072373043a.svg)\n\n\n\n执行下面的命令为入口网关开启受信代理数量配置：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{\\\u0022gatewayTopology\\\u0022:{\\\u0022numTrustedProxies\\\u0022: 2,\\\u0022forwardClientCertDetails\\\u0022:\\\u0022SANITIZE_SET\\\u0022}}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n当 Istio Gateway 收到这个请求时，它将 \u0060X-Envoy-External-Address\u0060 头设置为您 curl 命令中 \u0060X-Forwarded-For\u0060 头中的倒数第二个地址（\u0060numTrustedProxies: 2\u0060）。根据 Istio 的文档，Gateway 在将其转发到服务端负载之前，会将自己的 IP 附加到 \u0060X-Forwarded-For\u0060 头中。但实际情况是标头中只有客户端源 IP 和 External Gateway Pod IP。\n\n你可以执行下面的命令取消这个补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n## TCP 流量\n\n上文所说的使用标头获取客户端源 IP 的方式只适用于 L7 网络，对于 L4 网络的 TCP 流量可以使用 Proxy 协议。\n\nProxy 协议是一种网络协议，它在 TCP 连接的起始处添加了一个协议头部，用于传递连接过程中的一些元数据，如客户端的真实 IP 地址和端口号。这对于在负载均衡器（LB）后部署的应用程序非常有用，因为负载均衡器通常会更改客户端的原始 IP 地址成 LB 的地址，导致服务端无法知晓客户端的真实 IP。很多代理软件都支持 Proxy Protocol，比如 [Envoy](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/listeners\/listener_filters\/proxy_protocol) 和 HAProxy、NGINX 等。\n\n你可以使用下面的命令为 Ingress Gateway 打上补丁，以支持 Proxy 协议：\n\n\u0060\u0060\u0060\nkubectl patch deployment istio-ingressgateway -n istio-system -p \u0027{\u0022spec\u0022:{\u0022template\u0022:{\u0022metadata\u0022:{\u0022annotations\u0022:{\u0022proxy.istio.io\/config\u0022:\u0022{\\\\\u0022gatewayTopology\\\\\u0022:{\\\\\u0022proxyProtocol\\\\\u0022:{}}}\u0022}}}}}\u0027\n\u0060\u0060\u0060\n\n注意：不是所有的公有云中的 Kubernetes  中 \u0060LoadBalancer\u0060 类型的 Service 创建的的负载均衡器都支持该配置。比如 GKE 中就不支持。在 AWS NLB 中开启 Proxy 协议请参考[该博客](https:\/\/istio.io\/latest\/blog\/2020\/show-source-ip\/)。\n\nEnvoy 并不建议使用 Proxy 协议，因为它：\n\n- 只支持 TCP 协议\n- 必须上游主机支持\n- 可能影响性能\n\n关于 Envoy 对 Proxy 协议的支持请参考[该文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_features\/ip_transparency#proxy-protocol)。\n\n## 应用场景示例\n\n下面是常见的两个源 IP 地址的应用场景。\n\n### 基于源 IP 地址的访问控制\n\n在 Istio 的入口网关配置基于源 IP 的访问控制策略。这通过设置入口网关的授权策略，根据源 IP 地址实现访问限制。\n\n下图展示了基于源 IP 地址的访问控制流程图。\n\n\u0060\u0060\u0060mermaid \u0022基于源 IP 地址的访问控制流程图\u0022\nsequenceDiagram\n    participant C as Client\n    participant P1 as Proxy 1\n    participant P2 as Proxy 2\n    participant Pn as Proxy N\n    participant IG as Ingress Gateway\n    participant S as Service\n\n    C-\u003e\u003e\u002bP1: Request with Source IP\n    P1-\u003e\u003e\u002bP2: Forward Request\n    P2-\u003e\u003e\u002bPn: Forward Request\n    Pn-\u003e\u003e\u002bIG: Forward Request\n    Note over IG: numTrustedProxies Set\n    IG-\u003e\u003e\u002bS: Forwarded Request\n    Note over IG: Authorization Policy Based on Source IP\n\u0060\u0060\u0060\n\n![基于源 IP 地址的访问控制流程图](635bc14feb9b6939b3319929849cd0b5.svg)\n\n\n\n#### 场景假设\n\n假设请求经过三个代理，其 IP 地址分别为 \u00601.1.1.1\u0060、\u00602.2.2.2\u0060 和 \u00603.3.3.3\u0060。在 Ingress Gateway 中，\u0060numTrustedProxies\u0060 被设置为 2，因此 Istio 信任的源 IP 为 \u00602.2.2.2\u0060（即 \u0060x-envoy-external-address\u0060）。\n\n\u0060\u0060\u0060bash\ncurl -H \u0022Host: clusterip.jimmysong.io\u0022 -H \u0027X-Forwarded-For: 1.1.1.1,2.2.2.2,3.3.3.3\u0027 $GATEWAY_IP\n\u0060\u0060\u0060\n\n#### 屏蔽特定源 IP\n\n若需屏蔽来自 \u00602.2.2.2\u0060 的请求，可以使用以下授权策略：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: ingress-policy\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      app: istio-ingressgateway\n  action: DENY\n  rules:\n    - from:\n        - source:\n            remoteIpBlocks:\n            - \u00222.2.2.2\/24\u0022\n\u0060\u0060\u0060\n\n#### 使用最终客户端 IP\n\n如果希望识别与 Istio Mesh 直连的客户端 IP（即 \u0060x-forwarded-for\u0060 中的最后一个 IP，例如 \u0060123.120.234.15\u0060），则需要用 \u0060ipBlocks\u0060 配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: ingress-policy\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      app: istio-ingressgateway\n  action: DENY\n  rules:\n    - from:\n        - source:\n            ipBlocks:\n            - \u0022123.120.234.15\/24\u0022\n\u0060\u0060\u0060\n\n这种方法通过配置 Istio 的入口网关授权策略，可以有效地实现基于源 IP 的访问控制。它允许管理员根据不同的需求（如屏蔽特定 IP 或信任最终客户端 IP）灵活设定规则，从而增强了服务的安全性和灵活性。\n\n### 基于源 IP 地址的负载均衡\n\n要在 Istio 中根据源 IP 地址配置负载均衡策略，你需要使用 \u0060DestinationRule\u0060 资源，并指定 \u0060LOAD_BALANCER_POLICY_CONSISTENT_HASH\u0060 策略。这种策略允许您根据一致性哈希算法为流量分配目标，可以基于源 IP 地址来实现会话亲和性（session affinity），确保来自同一源 IP 的请求被路由到相同的目标。\n\n#### 源 IP 地址负载均衡示例\n\n下面是一个示例配置，展示了如何使用 \u0060DestinationRule\u0060 来根据源 IP 地址实现负载均衡：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: example-destination-rule\nspec:\n  host: example-service\n  trafficPolicy:\n    loadBalancer:\n      consistentHash:\n        httpHeaderName: x-forwarded-for # 这通常包含源 IP 地址，适用于经过代理或负载均衡器转发的流量。\n\u0060\u0060\u0060\n\n注意，如果直接连接到 Istio Ingress Gateway 而不经过其他代理，你可能需要根据实际情况调整 \u0060httpHeaderName\u0060 或使用其他哈希键，例如 \u0060useSourceIp\u0060，如下所示：\n\n\u0060\u0060\u0060yaml\nspec:\n  trafficPolicy:\n    loadBalancer:\n      consistentHash:\n        useSourceIp: true\n\u0060\u0060\u0060\n\n{{\u003ccallout note 注意\u003e}}\n\n- 使用源 IP 地址作为负载均衡的键时，请确保您理解这可能如何影响流量分布，特别是在源 IP 地址分布不均匀的情况下。\n- 正如上文所述，在某些环境中，原始的源 IP 可能会被网络设备（如负载均衡器或 NAT 设备）修改，需要确保 \u0060x-forwarded-for\u0060 头或其他相应机制能准确反映原始的客户端 IP。\n\n{{\u003c\/callout\u003e}}\n\n## 总结\n\n- 保留源 IP 对于实施访问控制、负载均衡和数据分析至关重要。\n- Envoy 代理使用 \u0060X-Forwarded-For\u0060 头部来处理 HTTP 请求中的客户端源 IP。\n- 通过设置 \u0060externalTrafficPolicy\u0060 和选择合适的流量劫持方式（\u0060REDIRECT\u0060 或 \u0060TPROXY\u0060），可以在南北向和东西向流量中正确获取客户端源 IP。\n- 处理经过多层代理的流量时，\u0060numTrustedProxies\u0060 配置是关键。\n- 对于 TCP 流量，Proxy 协议是一个有效的解决方案。\n\n## 参考\n\n- [x-forwarded-for - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#x-forwarded-for)\n- [Proxy protocol on AWS NLB and Istio ingress gateway - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/show-source-ip\/)\n- [Configuring Gateway Network Topology - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/network-topologies\/)\n- [IP Transparency - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_features\/ip_transparency)\n- [Using Source IP - kubernetes.io](https:\/\/kubernetes.io\/docs\/tutorials\/services\/source-ip\/)\n- [Proxy Protocol - github.com](https:\/\/github.com\/haproxy\/haproxy\/blob\/master\/doc\/proxy-protocol.txt)\n', '\/blog\/preserve-source-ip-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文专注于如何在 Istio 服务网格中保持客户端源 IP 的透明性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/envoy/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/envoy/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/envoy/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/envoy/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/envoy/page/3/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(81)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/building-private-ai-knowledge-base-anythingllm/">探索 AnythingLLM：借助开源 AI 打造私有化智能知识库</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/migrate-to-istio-telemetry-api/">从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
