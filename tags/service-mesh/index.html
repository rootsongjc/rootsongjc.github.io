<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/service-mesh/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-22/">深入解析 Istio 1.22：新特性和实际应用建议</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio 1.22：新特性和实际应用建议', '探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。', '\n最近 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)包含大量的重大更新，本文将为你分享这个发布带来的新特性及应用建议。\n\n## Ambient 模式进入 Beta 阶段\n\n虽然 Ambient 模式现已进入 Beta 阶段，但这并不意味着我们可以完全告别 Sidecar。尽管 Istio 官方宣称 Ambient 模式可以简化操作并显著减少内存和 CPU 使用，但它仍然存在局限性和潜在的复杂性问题。例如，虽然取消了 Sidecar，但需引入新的 ztunnel 和 waypoint 组件，这可能带来新的挑战。关于 Ambient 模式进入 Beta 模式的详细信息请参阅 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/)。\n\n**Ambient 模式带来的新的挑战**\n\n- Ambient mode 对 L7 流量的管理仍未成熟\n- mTLS 被强制在 namespace 级别开启，也就是说使用 Ambient 模式你无法关闭 mTLS\n- Ambient 模式的无宕机升级仍未解决\n- 缺少 与 Sidecar 模式共存和迁移的最佳实践\n\n关于 Sidecar 模式和 Ambient 模式的对比，详见 [Istio Ambient 模式的局限性解析](\/blog\/istio-ambient-mode-limitations\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n如果是刚开始使用 Istio，尤其是你只需要为服务自动开启 mTLS 的情况下，当前阶段可以尝试使用 Ambient 模式。但是对于 L7 功能，建议等到 Ambient 模式完全成熟后再考虑生产上使用。\n{{\u003c\/callout\u003e}}\n\n## Istio API 升级\n\nIstio Istio 1.22 版本中，关键 API 如流量管理、安全、Telemetry 相关的 API 都已正式升级到 \u0060v1\u0060 版本。你只需要将原有配置的 API 版本修改为 \u0060v1\u0060 即可，除此之外不需要任何更改。这些 API 早已成熟，你可以放心的使用 \u0060v1\u0060 版本，对于对稳定性要求较高的环境，Istio 添加了[验证准入策略](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/)确保只有 \u0060v1\u0060 API 和字段可以在 Istio API 中使用。\n\n例如下面的 AuthorizationPolicy 示例。\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\n其他扩展类的 API 如 \u0060EnvoyFilter\u0060、\u0060WasmPlugin\u0060、\u0060ProxyConfig\u0060 还未成熟，因此还停留在 alpha 或 beta 阶段。关于 API 升级的更多信息，请参考 [v1 API 博客](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于常用功能可以放心使用 \u0060v1\u0060 API，扩展类 API 尚未稳定为了保证系统稳定性，可以开启验证准入策略。\n{{\u003c\/callout\u003e}}\n\n## Gateway API 升级\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 已更新至版本 1.1.0，现已普遍可用。这一更新扩展了 Istio 的流量管理能力，但需要注意 Istio 原生 API 与 Gateway API 的兼容性问题。在迁移到新 API 时应谨慎，以避免依赖尚未完全成熟的特性。更多详情，请查看 [Gateway API v1.1 博客](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于已经稳定使用 Istio API 的现有部署，可以继续使用，尤其是在需要使用到高级功能的场景下。对于新部署优先考虑使用稳定版的 Gateway API，以利用其现代化的流量管理功能。因为二者现存的兼容性问题，不要冒然迁移到 Gateway API，否则得不偿失。\n{{\u003c\/callout\u003e}}\n\n## 增量 xDS 默认启动\n\nIstio 1.22 版本默认启用了增量 xDS，这是一个优化配置分发的机制。与传统的 State of the World（SotW）模式相比，增量 xDS 仅将变更的配置发送给 Envoy 代理，从而显著减少了网络传输的数据量和控制平面的资源消耗。这一变更尤其适用于配置频繁更新的大规模部署环境，能够提高配置更新的效率和性能。此外，增量 xDS 还有助于在网络环境复杂或配置动态变化的情况下，更高效地管理服务网格的配置更新。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n增量 xDS 早在 Istio 的几个版本前就已经开发完成，只是没有默认开启，现在该功能已经稳定，可以放心使用。\n{{\u003c\/callout\u003e}}\n\n更多关于 xDS 的介绍请参考[Envoy xDS 及 Istio 中的配置分发流程介绍](\/blog\/istio-delta-xds-for-envoy\/)。\n\n### AuthorizationPolicy 的路径模板支持通配符\n\n在 Istio 1.22 中，\u0060AuthorizationPolicy\u0060 新增了对[路径模板](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation)的支持，极大增强了路径匹配的灵活性和精确性。而在此之前，\u0060AuthorizationPolicy\u0060 的路径配置并不支持通配符。此功能允许使用基于 Envoy 的 URI 模板匹配来定义 HTTP 请求中的路径。路径可以包括简单的通配符（\u0060*\u0060 和 \u0060**\u0060）或具名变量，从而精确匹配单个或多个路径组件。例如，路径模板 \u0060\/foo\/{*}\u0060 能匹配 \u0060\/foo\/bar\u0060 但不匹配 \u0060\/foo\/bar\/baz\u0060，而 \u0060\/foo\/{**}\/\u0060 则可以匹配任何以 \u0060\/foo\/\u0060 开头的路径。这种灵活的路径模板设计，特别适用于动态和复杂的路由规则，进一步加强了 Istio 的安全策略工具箱。\n\n下图展示了 AuthorizationPolicy 的路径匹配的通配符规则。\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy 的路径匹配通配符规则\u0022\ngraph LR\n    A[AuthorizationPolicy 路径匹配] --\u003e B(定义路径模板)\n    B --\u003e C{路径模板操作符}\n    C --\u003e D[\u0022*（匹配单个段）\u0022]\n    C --\u003e E[\u0022**（匹配多个段）\u0022]\n    C --\u003e F[\u0022{name}（命名变量匹配单个段）\u0022]\n    C --\u003e G[\u0022{name=**}（命名变量匹配多个段）\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} 匹配 \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ 匹配 \/foo\/bar\/、\/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} 匹配 \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd 匹配 \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy 的路径匹配通配符规则](f96fd4f3843d3d7b7c13b0a5083f00f4.svg)\n\n了解更多关于路径模板的具体应用和规则，你可以参考 [Envoy 的官方文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto)。\n\n{{\u003ccallout note \u0022提示\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 中的路径匹配终于支持模板了，你不需要再在配置中一个一个地手动加入路径了。\n{{\u003c\/callout\u003e}}\n\n## 总结\n\nIstio 1.22 版本引入了多项重要更新和改进，尽管某些特性被广泛宣传，但在实际使用中需要进行详细评估和适当的测试。希望本篇博客能帮助你更深入地理解和应用这些新特性，以在实际操作中获得最佳效果。\n\n## 参考\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)', '\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-introduction/">Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口', '本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。', '\n在 Kubernetes 环境下选择正确的网络通信工具至关重要。根据[Tetrate 的讨论](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/)，选择取决于网络通信的类型：南北向流量还是东西向流量。对于主要处理外部请求的服务，Envoy Gateway 是理想选择，它不仅高效管理流量，还能在你向微服务架构过渡时提供无缝集成。\n\n本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。\n\n## Envoy Gateway 及其在服务网格中的角色概述 {#overview}\n\nEnvoy Gateway 是一个围绕 Envoy Proxy 构建的 Kubernetes 原生 API 网关，它旨在降低用户采用 Envoy 作为 API 网关的难度，并为供应商建立 API 网关（例如 [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/)）增值产品奠定基础。\n\nEnvoy Gateway 不仅是管理南北流量的理想选择，也可作为连接和保护服务网格中服务的关键组件。它还通过提供安全的数据传输、流量路由、负均衡及故障恢复等功能，增强了微服务之间的通信效率和安全性。Envoy Gateway 利用其内置的 Envoy Proxy 技术，可以处理大量的并发连接和复杂的流量管理策略，同时保持较低的延迟和高吞吐量。\n\n此外，Envoy Gateway 与 Kubernetes Gateway API 的紧密集成使得它能够以声明式的方式进行配置和管理，极大简化了服务网格中网关的部署和更新过程。这种集成不仅提升了操作效率，还使得 Envoy Gateway 能够在不增加额外复杂性的前提下，与服务网格如 Istio 这样的解决方案无缝协作。\n\n下图展示了 Envoy Gateway 与服务网格的关系。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 与服务网格的关系\u0022\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes 集群\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022服务\u0022]\n        pods[\u0022Pod\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022管理南北向流量\u0022 --\u003e svcs\n        eg -- \u0022由...配置\u0022 --\u003e gwapi\n        gwapi -. \u0022定义路由规格\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022服务网格\u0022]\n        smc[\u0022服务网格控制平面（如 Istio、Linkerd）\u0022]\n        smp[\u0022服务网格数据平面（Envoy Sidecars）\u0022]\n        smc -- \u0022配置\u0022 --\u003e smp\n        smp -- \u0022处理东西向流量\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022是...的一部分\u0022 .-\u003e SM\n    svcs -- \u0022连接到\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Envoy Gateway 与服务网格的关系](8691fed7a410e3a8f45252cc5c8e11db.svg)\n\n在 Kubernetes 集群中，Envoy Gateway 负责管理南北向流量，即进出集群的流量，并通过 Kubernetes Gateway API 进行配置，后者定义了服务的路由规格。集群内服务直接连接到 Pods。服务网格部分，由控制平面（如 Istio 或 Linkerd）配置数据平面中的 Envoy Sidecars，这些 Sidecars 负责处理集群内部的东西向流量。在这个系统中，Envoy Gateway 可以与服务网格相互协作，但它们各自独立地管理不同方向的流量。\n\n设想一下，Envoy Gateway 像是一个城市的主要入口（比如海关），所有的数据流，就像各种车辆，都得通过这个大门进出。它就像一个严格的守门员，负责审查、指导，确保每个数据包，就像每个乘客，都能被准确地送到目的地。在 Kubernetes 这座城市中，Envoy Gateway 管理着所有进城的流量，它确保数据流可以安全、高效地进入城市，并被准确地送达给城市内部的服务。\n\n进入城市之后，服务网格就接管了，这就像城市内部的一系列交通网络。服务网格中的 Envoy sidecars 就好比是这座城市内部的出租车或者公交车，负责把数据包从海带到它们在城市内部的具体目的地。Envoy Gateway 负责将外部请求顺利引入，之后服务网格负责在集群内部继续高效地处理这些请求。\n\nEnvoy Gateway 对 Kubernetes Gateway API 的支持，可以看作是对我们城市交通信号系统的一个重大升级。这不仅为进入城市的数据流提供了更加清晰和个性化的指引，而且让整个城市的交通运行更加智能化。\n\n## Envoy Gateway 的核心功能和优势 {#pros}\n\nEnvoy Gateway 提供了几个核心功能，使其成为 API 网关的突出选择：\n\n- **简化配置**：通过与 Kubernetes Gateway API 直接集成，Envoy Gateway 允许开发者使用 Kubernetes 自定义资源以声明方式配置路由规则、安全策略和流量管理。\n- **性能和可扩展性**：基于经过实战测试的 Envoy Proxy，它提供卓越的性能和可扩展性，轻松处理数千个服务和每秒数百万个请求。\n- **安全功能**：内置支持各种安全措施，如 SSL\/TLS 终止、OAuth2、OIDC 认证以及细粒度访问控制。\n- **可观测性**：提供全面的监控能力，包括详细的度量、日志和追踪，这对于诊断和理解流量行为至关重要。\n\n## 与 Gateway API 的关系 {#gateway-api}\n\n在 Kubernetes 环境中引入的 Gateway API 为集成和配置 Ingress 网关提供了一种新的强大方法，它与传统的 Ingress 相比具有更高的灵活性和功能性。正如我在 [Gateway API：Kubernetes 和服务网格入口中网关的未来](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 中所讨论的，Gateway API 通过区分角色和提供跨命名空间支持，更适应多云环境，且已被多数 API 网关采用。这种 API 设计支持了 ingress 网关（南北向流量）与服务网格（东西向流量，跨集群路由）的融合，使得 Envoy Gateway 成为 Kubernetes 和服务网格中统一未来的网关解决方案。通过引入 Gateway API，Envoy Gateway 强化了其作为云原生环境中前沿代理的角色，使得用户能够更灵活地管理其流量和策略。\n\nKubernetes Gateway API 是 Envoy Gateway 的基石，它提供了一种更具表达性、灵活性和以角色为导向的方式来配置 Kubernetes 生态系统中的网关和路由。该 API 提供了如 GatewayClass、Gateway、HTTPRoute 等自定义资源定义（CRD），Envoy Gateway 利用这些资源创建用户友好且一致的配置模型，与 Kubernetes 的原生原则保持一致。\n\n{{\u003ccallout note \u0022什么是 API Gateway？\u0022\u003e}}\n\nAPI Gateway 是对 API 的全面管理和托管服务。它作为应用程序与后端服务之间的中间层，不仅处理创建、维护、发布、运行和下线等生命周期事件，还承担着更多关键职能。一个完善的 API Gateway 应该提供以下功能来丰富和扩展其基本定义：\n\n1. **流量控制**：API Gateway 应能够处理并控制到后端服务的流量，包括请求路由、负载均衡、熔断机制以及速率限制，以保证后端服务的稳定性和高可用性。\n2. **安全性保障**：应具备鉴权、授权和加密功能，能够有效地管理和保护 API 的安全。这涉及到身份验证机制、API 密钥管理、OAuth、JWT、mTLS 等，以确保只有授权的用户和服务能够访问 API。\n3. **监控和分析**：提供实时监控和日志记录功能，能够跟踪 API 的使用情况、性能指标、异常检测和分析流量模式，从而优化 API 的性能和响应能力。\n4. **变更管理**：支持对 API 变更进行管理，包括版本控制和渐进式部署（如蓝绿部署或金丝雀发布），以无缝过渡新版本且最小化对最终用户的影响。\n5. **请求和响应的转换**：允许对传入和传出的 API 调用进行转换，比如从 REST 到 GraphQL 的转换，或是添加、删除和修改请求头和响应头。\n6. **跨域资源共享（CORS）支持**：管理和控制跨域请求，允许不同域的前端应用安全地调用后端 API。\n7. **配额和计费**：为 API 使用设定配额限制，同时支持计费功能，以适用于商业化的 API 提供。\n8. **用户友好的开发者门户**：提供一个面向开发者的门户，使得第三方开发者可以轻松地发现、测试和集成 API。\n9. **协议支持**：支持各种网络协议，包括 HTTP\/HTTPS、WebSocket、gRPC 等，确保与多种客户端和服务的兼容性。\n10. **插件化和扩展性**：允许通过插件或中间件来扩展 API Gateway 的功能，使其可以根据业务需求灵活适配各种中间件服务。\n11. **服务治理**：集成服务注册和发现机制，以适应微服务架构下服务的动态性。\n\n综上所述，API Gateway 的角色远远超越了简单的 API 生命周期管理。它是实现微服务架构、确保服务安全性、提高运维效率和优化用户体验的关键组件。通过这些广泛的功能，API Gateway 成为现代云原生应用不可或缺的一部分。\n\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 架构概览 {#arch}\n\nEnvoy Gateway 的架构设计旨在轻量级和简洁。它包括一个动态配置运行作为数据平面的 Envoy 代理的控制平面。这种关注点的分离确保了网关可以随着流量的增长而扩展，而不影响控制平面的效率。\n\nEnvoy Gateway 的架构图如下所示。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n在这个架构图的核心是 Envoy Gateway，它是 Envoy 代理的执行实例，负责处理从 Kubernetes 集群进出的所有流量。初始启动时，Envoy Gateway 通过配置文件提供静态配置，建立其操作的基本参数。\n\nEnvoy Gateway 配置的动态方面由提供者处理，该提供者定义了网关与 Kubernetes 或其他动态配置输入源的交互。资源监视器负责监视 Kubernetes 资源的更改，特别关注与自定义资源定义（CRD）相关的 CRUD 操作。\n\n随着更改的发生，资源转换器介入将这些外部资源转换为 Envoy Gateway 可以理解的形式。这一转换过程进一步由特定于提供者的基础设施管理器促进，后者负责管理与特定云或基础设施提供商相关的资源，塑造中间表示形式的基础设施，这对于网关的功能至关重要。\n\n然后，该中间表示形式转变为 xDS 中间表示形式，作为 Envoy 理解和执行的最终 xDS 配置的先导。xDS 翻译器承担将这种中间表示形式转换为具体的 xDS 配置的角色。\n\n这些配置由 xDS 服务器交付并执行，该服务器作为服务，根据其收到的 xDS 配置，认真管理 Envoy 实例。Envoy 作为实际运行的代理，最终从 xDS 服务器接收这些配置，解释并实现它们以有效管理流量请求。\n\n最终，所有请求经过 Envoy 的处理后被重定向到了 Envoy Gateway 路由的流量的最终目的地，也就是后端服务。\n\n## 与其他网关的比较 {#comparations}\n\n与 Istio 的入口网关或 NGINX Ingress 等其他流行解决方案相比，Envoy Gateway 凭借其与 Kubernetes 的原生集成以及利用 Envoy 全部潜力的专注，而脱颖而出。下图从多方面对比了目前流行的一些开源的 API 网关。\n\n{{\u003ctable \u0022开源 API 网关对比\u0022\u003e}}\n| API 网关      | 支持的认证和授权策略                                         | 支持的服务发现组件                     | 支持的协议                       | 控制平面配置分发方法 | 支持的插件扩展机制   | 组织隶属               |\n| ------------- | ------------------------------------------------------------ | -------------------------------------- | -------------------------------- | -------------------- | -------------------- | -------------------------- |\n| Envoy Gateway | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                        | HTTP, HTTPS, gRPC                | xDS                  | 基于 Envoy Filter | CNCF                       |\n| Kuma          | mTLS, JWT                                                    | Kubernetes, Consul                     | HTTP, HTTPS, gRPC, TCP           | REST, gRPC           | 基于 Lua, Go       | CNCF                       |\n| NGINX Ingress | RBAC                                                         | Kubernetes                             | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD       | 基于 Nginx 模块    | N\/A                        |\n| APISIX        | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID 等 | Kubernetes, DNS, Consul, Nacos, Eureka | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI    | 基于 Lua, Wasm    | Apache Software Foundation |\n| Kong          | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI   | 基于 Lua          | N\/A                        |\n| Emissary      | Basic Auth                                                   | Kubernetes                             | HTTP, HTTPS, gRPC                | Kubernetes CRD       | 基于 Lua, Go      | CNCF                       |\n{{\u003c\/table\u003e}}\n\n## 快速开始使用 Envoy Gateway {#envoy-gateway-quick-start}\n\n要快速上手 Envoy Gateway，你可以通过以下简化步骤快速搭建一个本地实验环境。首先，启动一个本地 Kubernetes 集群：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\n接下来，部署 Gateway API CRD 和 Envoy Gateway 本身：\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n然后，安装网关配置并部署一个示例应用：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n为了暴露 LoadBalancer 服务，这里我们使用端口转发作为示例。你也可以选择使用 \u0060minikube tunnel\u0060 或安装 [MetalLB](https:\/\/metallb.universe.tf\/installation\/) 作为负载均衡器：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\n通过以下命令测试你的 Envoy Gateway 是否正常工作：\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\n想了解更多详细的安装和配置步骤，请访问 Envoy Gateway 网站。通过这些步骤，你可以快速开始探索 Envoy Gateway 的功能。\n\n## 总结 {#summary}\n\nEnvoy Gateway 不仅优化了云原生时代的七层网关配置，而且为从边缘网关向服务网格过渡提供了一个平滑的道路。由于服务网格的推广面临一些挑战，如对应用的侵入性和运维团队推动问题，边缘网关则更易于被开发团队接受。Envoy Gateway 采用简化的 Kubernetes Gateway API，提高了流量管理和可观测性的能力。此外，Envoy Gateway 到 Istio 的过渡对于已熟悉 Envoy 功能的团队来说，将是一个自信的技术进步，同时还支持从标准的 Kubernetes Gateway API 到 Istio Ingress Gateway 的无缝切换，或者作为一个定制解决方案继续与 Istio 协作。这些特点使得 Envoy Gateway 成为一个在云原生时代值得投资的网关选择。\n\n请继续关注本系列博客的后续部分，我们将深入探讨如何配置和优化 Envoy Gateway，提供实用指南并展示更广泛的实际应用案例。\n', '\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/automate-istio-ca-rotation-in-production-at-scale/">[译] 使用 Kyverno 更轻松地保护服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kyverno.io/blog/2024/02/04/securing-services-meshes-easier-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Kyverno 更轻松地保护服务网格', '利用 Kyverno 为服务网格提供更好的 Pod 安全性。', '如今在 Kubernetes 中，服务网格已经变得司空见惯，有些平台甚至默认将其构建到集群中。服务网格无疑在多种方面提供了诸多好处，这些好处众所周知，但也众所周知，它们显著增加了集群的复杂性。除了增加了复杂性之外，服务网格在强制执行 Pod 安全性方面也带来了（臭名昭著的）问题，因为它们需要提升的权限可能对其他准入控制器造成难以处理的困扰，例如 Kubernetes 自身的 Pod 安全准入控制器。在本文中，我们将更详细地解释这个问题以及在使用服务网格时 Kyverno 如何成为真正的救星，同时为你预览一下即将到来的 Kyverno 1.12 版本中的一些东西，这将使安全服务网格变得轻而易举！\n\n## 介绍\n\n服务网格[为 Kubernetes 应用程序提供了许多好处](https:\/\/konghq.com\/learning-center\/service-mesh\/what-is-a-service-mesh)，包括更好的负载均衡、双向 TLS、可观测性等。很可能你现在就在你的某个集群中使用了服务网格。最流行的开源服务网格包括 [Istio](https:\/\/istio.io\/) 和 [Linkerd](https:\/\/linkerd.io\/)。所有服务网格的工作方式基本相同，我们不会在这篇博文中深入探讨。一个显著的点是，为了将流量定向到其“旁路”代理并从其“旁路”代理，需要对底层 Linux 节点的 iptables 规则进行一些调整。这些调整或配置修改是服务网格重写网络堆栈路由规则的结果。为了做到这一点，像 Istio 和 Linkerd 这样的网格使用一个 [initContainer](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/pods\/init-containers\/) 在任何其他容器启动之前执行此操作。为了使该 initContainer 起作用，它需要一些权限，这往往在注重安全的集群中是困难的。至少，这些 initContainer 必须添加两个[Linux 权限](https:\/\/man7.org\/linux\/man-pages\/man7\/capabilities.7.html)，以允许它们对网络堆栈进行修改：\u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060。这些 initContainer 甚至可能以 root 用户身份运行，这在容器世界是绝对不允许的。\n\n例如，Linkerd 2.14 将在应该成为其网格的任何 Pod 中注入类似以下的 initContainer（为简洁起见，省略了一些字段）。\n\n\u0060\u0060\u0060yaml\ninitContainers:\n  - image: cr.l5d.io\/linkerd\/proxy-init:v2.2.3\n    name: linkerd-init\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        add:\n          - NET_ADMIN\n          - NET_RAW\n      privileged: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 65534\n      seccompProfile:\n        type: RuntimeDefault\n\u0060\u0060\u0060\n\n事实上，这些服务网格 initContainer 需要的额外权限被 Kubernetes 官方的 [Pod 安全标准](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/) 所禁止。这个事实本身并不是主要问题，而是根据使用的策略引擎，为这些特殊的 initContainer 提供许可是非常困难甚至根本不可能的。我们每周都在 [Kyverno 社区](https:\/\/kyverno.io\/community\/)听到用户的痛苦，似乎那些最严重受到影响的用户是那些使用 [Pod 安全准入](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-admission\/) 的人，这是实现 Pod 安全标准的进程中的准入控制器。这已经成为一个显著的问题，以至于 Istio 和 Linkerd [都尝试过](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/) 解决它（或者更准确地说，解决它的方法） ，通过提供另一种选择：一个自定义的 CNI 插件。\n\n## CNI 插件\n\n这些 CNI 插件适用于许多情况，但总的来说，它们大都是以牺牲一个问题来解决另一个问题。毕竟，iptables 规则仍然 **必须** 被重写，而网格中的某些东西仍然 **必须** 负责执行这个任务。在这两种情况下，CNI 插件实现了一个 DaemonSet，该 DaemonSet 运行一个特权容器，以在每个节点上执行这些修改，从而避免了在每个 Pod 中都需要一个 initContainer 的需求。这确实有它的优点，但也有缺点。\n\n- DaemonSet 更具特权，因为它需要 hostPath 卷，并将配置文件和二进制文件复制到每个节点。\n- 它需要了解 CNI 插件，这是专门的知识。\n- 增加了更多的操作和自动化复杂性。\n- 与其他 CNI 插件可能发生冲突，因为它们彼此不知道，并且确定如何链接多个插件不是标准化的。\n- 在水平集群缩放或节点重启期间可能会出现潜在的竞争条件，因为 DaemonSet Pod 可能在工作负载 Pod 之前启动。\n\n## 问题的关键\n\n但是为什么解决 initContainer 问题会是一个真正的问题呢？答案在于排除。排除，或者你如何免除某些资源不适用于策略，这是区分良好的准入控制器和优秀准入控制器的关键之一。目标是在尽可能不影响你确实需要的事物的同时，提供尽可能强大的 Pod 安全姿态。你希望能够将“好”与“坏”分开，而你的服务网格绝对属于“好”的范畴。但就像筛子筛沙子一样，你必须小心过滤掉“坏”的部分，使你只剩下“好”的部分。在上述 initContainer 示例中，你绝对不希望非服务网格 Pod 添加 \u0060NET_ADMIN\u0060 权限，因为那样会给予它们对网络堆栈的不受限制的访问，从而可能导致窥探和伪装等问题。减少漏斗大小的选项如下，从大到小排序。\n\n- 在整个集群中禁用 Pod 安全\n  - 这显然是一个不可行的方案，所以不需要进一步讨论。\n- 在受影响的 Namespace 中禁用 Pod 安全\n  - 因为我们谈论的是每个必须参与网格的 Pod 中都有一个 initContainer，这基本上意味着你必须在集群的大多数 Namespace 中禁用 Pod 安全，这实际上就像第一种选项一样——行不通。\n- 在包含此检查的配置文件中禁用此配置文件（如果适用）\n  - Pod 安全标准组织成称为配置文件的集合，每个配置文件包含多个控制。控制是关于*应该*检查哪些字段以及允许或不允许哪些值的命令。你可以找到包含此控制的配置文件，并禁用整个配置文件，但这显然会禁用同一配置文件中的其他控制。这也不是很好。并非所有策略准入控制器都提供此功能。\n- 在 Pod 上禁用此控制\n  - 请求 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 的这些 initContainer 违反了[Pod 安全标准的基线配置文件中的“Capabilities”控制](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#baseline)，这是 Pod 安全的基本配置文件（受限制配置文件建立在基线配置文件之上）。你可以简单地不在使用这种 initContainer 的任何 Pod 中检查此控制，但这也不好，因为那样一个恶意容器也可以添加 \u0060NET_ADMIN\u0060。你可能正在执行所有其他控制，但是简单地关闭一个控制还是太多。\n- 在一个镜像上禁用此控制\n  - 如果你已经达到了这个级别，那么你做得很好。你可以简单地不在与某种模式匹配的镜像上检查这些特权能力。但我们还可以做得更好。（顺便说一句，基于 initContainer 的名称这样做并不完全安全，因为一些恶意用户可能创建一个名为 \u0060istio-init\u0060 的 initContainer，该 initContainer 使用了一个名为 \u0060ubuntu:latest\u0060 的镜像。）\n- 在一个镜像上以及在 Pod 中的一个位置上禁用此控制\n  - 现在我们来谈谈。我们可以将一个豁免隔离到仅限于特定的镜像和 Pod 中的特定位置。例如，我们可以在 \u0060initContainers[]\u0060 数组中发现 \u0060istio\/proxyv2\u0060 镜像时，豁免 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 权限检查。如果同一镜像在主要的 \u0060containers[]\u0060 列表中使用，它将导致整个 Pod 被拒绝。\n\n许多人遇到此问题的原因之一是 Pod 安全准入（PSA）。使用 PSA，你可以实现的最精细的粒度是从顶部的第三个项目：禁用包含此检查的配置文件。由于受限制的配置文件包含基线配置文件，因此在 Namespace 上禁用基线配置文件本质上等同于不执行 Pod 安全检查。这个限制是创建 CNI 插件解决方案的主要原因。如果服务网格可以将对这些提升权限的需求分离到只有一个控制器（一个 DaemonSet）中，并且该控制器仅在一个 Namespace 中运行，那么我们基本上可以将该 Namespace 隔离为一个豁免区域。\n\n## Kyverno 中的策略\n\n在 Kyverno 中，您有几种选项来实施 Pod 安全标准。第一种和“原始”的方法是针对 Pod 安全标准中的每个控制编写一个 \u0060validate\u0060 规则。Kyverno 已经提供了完整的这些策略，打包为一个 [Helm 图表](https:\/\/github.com\/kyverno\/kyverno\/tree\/main\/charts\/kyverno-policies)，这些策略也可以作为 [单独的策略](https:\/\/kyverno.io\/policies\/?policytypes=Pod%20Security%20Standards%20(Baseline)%2BPod%20Security%20Standards%20(Restricted)) 使用。例如，基线配置文件中的“Capabilities”控制可以在[此处](https:\/\/kyverno.io\/policies\/pod-security\/baseline\/disallow-capabilities\/disallow-capabilities\/)找到。在这种策略样式中，您可以尽可能地细化。稍微的缺点是，当涉及到预构建的 Pod 安全标准时，它们需要在这些服务网格 initContainers 上进行一些修改。虽然其中一些修改相当温和，但其他可能需要更极端的修改。\n\n例如，以下是为了允许这些服务网格 initContainers 而进行的相同“Capabilities”检查可能的样子。\n\n\u003e 由于 Kyverno 在策略编写方面非常灵活，几乎总会有多种编写相同声明的方式，所以如果您已经这样做了而结果有所不同，请不用担心。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: disallow-capabilities\nspec:\n  validationFailureAction: Enforce\n  background: true\n  rules:\n    - name: adding-capabilities-service-mesh\n      match:\n        any:\n        - resources:\n            kinds:\n              - Pod\n      preconditions:\n        all:\n        - key: \u0022{{ request.operation || \u0027BACKGROUND\u0027 }}\u0022\n          operator: NotEquals\n          value: DELETE\n      validate:\n        message: \u003e-\n          Any capabilities added beyond the allowed list (AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER,\n          FSETID, KILL, MKNOD, NET_BIND_SERVICE, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT)\n          are disallowed. Service mesh initContainers may only add NET_ADMIN and NET_RAW to this list.     \n        foreach:\n          - list: request.object.spec.initContainers[]\n            preconditions:\n              all:\n              - key: \u0022{{ element.image }}\u0022\n                operator: AnyIn\n                value:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                operator: AnyNotIn\n                value: [\u0022NET_ADMIN\u0022,\u0022NET_RAW\u0022,\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n          - list: request.object.spec.[ephemeralContainers, containers][]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n\u0060\u0060\u0060\n\n请随时在 [Kyverno Playground](https:\/\/playground.kyverno.io\/#\/) 中试用一下，看看效果。里面包含了 Istio 和 Linkerd 的示例 Pod，所以尝试取消注释并复制元素来测试一下。\n\n由于 Istio 的 initContainer 需要比 Linkerd 的更多权限，因此还需要对一些其他策略进行一些轻微的修改，这些修改可以在[受限配置文件](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#restricted) 中找到。例如，以下是一个 [Kyverno Playground 链接](https:\/\/playground.kyverno.io\/#\/)，展示了如何修改 [require-run-as-nonroot 策略](https:\/\/kyverno.io\/policies\/pod-security\/restricted\/require-run-as-nonroot\/require-run-as-nonroot\/) 来豁免 \u0060istio-init\u0060。\n\n像上面展示的个别 Kyverno 策略允许最大的灵活性，但在 Kyverno 中实现 Pod 安全标准还有一种更简单的方式。实施这些标准的第二种方式是使用我们称之为“子规则”的方式来实现 \u0060validate\u0060 样式策略。[在这种样式](https:\/\/kyverno.io\/docs\/writing-policies\/validate\/#pod-security) 中，\u0060podSecurity\u0060 元素用于特指这些 Pod 安全标准。在幕后，Kyverno 使用与 Kubernetes 的 Pod 安全 Admission 完全相同的库，但使用不同的“包装器”使其应用更加灵活。\n\n例如，使用这种类型的子规则将允许您轻松实施 Pod 安全标准的整个基线配置文件，并在其中排除这些服务网格图像，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n  - name: baseline-service-mesh\n    match:\n      any:\n      - resources:\n          kinds:\n          - Pod\n    validate:\n      podSecurity:\n        level: baseline  ## 强制执行基线配置文件\n        version: latest  ## 强制执行此配置文件的最新版本\n        exclude:         ##\n\n 排除特定控制，可选特定图像\n        - controlName: Capabilities\n          images:\n          - \u0022*\/istio\/proxyv2*\u0022\n          - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这里的 \u0060exclude[]\u0060 块命名了我们到目前为止一直在讨论的“Capabilities”控制，\u0060images[]\u0060 字段命名了应该被排除的两个特定的服务网格图像。通过这种能力，您可以获得类似 PSA 的行为，但是具有简单不可能实现的细粒度。\n\n这两个选项为您提供了丰富的选择，但它们都涉及直接修改策略。还有另一种选择，允许将异常与策略本身分离，这就是 [策略异常](https:\/\/kyverno.io\/docs\/writing-policies\/exceptions\/)。例如，您可以编写一个策略异常资源，豁免给定 Pod 在特定策略中的特定规则。这对于开发人员自助服务特别有用，因为它允许其他用户请求异常，而无需查看 Kyverno 策略。但是，在 1.11 中，这在某些情况下还不够细粒度，因此在 Kyverno 1.12 中进行了一些很好的升级。接下来将更多介绍。\n\n## 1.12 中的增强功能\n\n在即将推出的 Kyverno 1.12 中，我们正在进行一些令人兴奋的增强，这些增强将使针对诸如服务网格容器等用例的排除变得更加容易。\n\n1.12 中的第一个增强功能是通过列出特定字段及其值来进一步分类 podSecurity 子规则的排除。这使您既可以使用简单的策略语言，又可以达到最低级别的细粒度。例如，这是您将能够强制执行 Pod 安全标准的整个基线配置文件，但仅从特定的 initContainers 列表中排除 Istio 和 Linkerd 图像的方法。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n    - name: baseline-service-mesh\n      match:\n        any:\n          - resources:\n              kinds:\n                - Pod\n      validate:\n        podSecurity:\n          level: baseline\n          version: latest\n          exclude:\n            - controlName: Capabilities\n              images:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              restrictedField: spec.initContainers[*].securityContext.capabilities.add\n              values:\n                - NET_ADMIN\n                - NET_RAW\n\u0060\u0060\u0060\n\n第二个增强功能是对策略异常的增强，使其具有 podSecurity 意识性，即您将能够在 PolicyException 资源中豁免策略异常的特定控制名称。例如，以下是您将能够在 Kyverno 1.12 中为先前的 \u0060validate.podSecurity\u0060 子规则创建的 PolicyException，使您可以将这些排除与只在 \u0060staging\u0060 命名空间中创建的 Pod 分离开来。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v2beta1\nkind: PolicyException\nmetadata:\n  name: pod-security-exception\n  namespace: kyverno\nspec:\n  exceptions:\n  - policyName: pod-security-standards\n    ruleNames:\n    - baseline-service-mesh\n  match:\n    any:\n    - resources:\n        namespaces:\n        - staging\n  podSecurity:\n    - controlName: Capabilities\n      images:\n        - \u0022*\/istio\/proxyv2*\u0022\n        - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这将在未来进一步增强，适用于特定容器。查看并关注 [此处的问题](https:\/\/github.com\/kyverno\/kyverno\/issues\/8570) 获取详情。\n\n## 结语\n\n本文介绍了一些有关服务网格的内容，以及为什么使用 initContainers 以及它们带来的安全问题。我们介绍了 Kyverno 如何以最精细的方式解决这些问题，同时提供了下一个版本的一瞥，以及如何使此过程更加简单。如果您有任何其他问题或反馈，请与 Kyverno 项目 [联系](https:\/\/kyverno.io\/community\/#get-in-touch)！\n', '\/trans\/automate-istio-ca-rotation-in-production-at-scale\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">利用 Kyverno 为服务网格提供更好的 Pod 安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/securing-services-meshes-easier-with-kyverno/">[译] 使用 Kyverno 更轻松地保护服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kyverno.io/blog/2024/02/04/securing-services-meshes-easier-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Kyverno 更轻松地保护服务网格', '利用 Kyverno 为服务网格提供更好的 Pod 安全性。', '\n如今在 Kubernetes 中，服务网格已经变得司空见惯，有些平台甚至默认将其构建到集群中。服务网格无疑在多种方面提供了诸多好处，这些好处众所周知，但也众所周知，它们显著增加了集群的复杂性。除了增加了复杂性之外，服务网格在强制执行 Pod 安全性方面也带来了（臭名昭著的）问题，因为它们需要提升的权限可能对其他准入控制器造成难以处理的困扰，例如 Kubernetes 自身的 Pod 安全准入控制器。在本文中，我们将更详细地解释这个问题以及在使用服务网格时 Kyverno 如何成为真正的救星，同时为你预览一下即将到来的 Kyverno 1.12 版本中的一些东西，这将使安全服务网格变得轻而易举！\n\n## 介绍\n\n服务网格[为 Kubernetes 应用程序提供了许多好处](https:\/\/konghq.com\/learning-center\/service-mesh\/what-is-a-service-mesh)，包括更好的负载均衡、双向 TLS、可观测性等。很可能你现在就在你的某个集群中使用了服务网格。最流行的开源服务网格包括 [Istio](https:\/\/istio.io\/) 和 [Linkerd](https:\/\/linkerd.io\/)。所有服务网格的工作方式基本相同，我们不会在这篇博文中深入探讨。一个显著的点是，为了将流量定向到其“旁路”代理并从其“旁路”代理，需要对底层 Linux 节点的 iptables 规则进行一些调整。这些调整或配置修改是服务网格重写网络堆栈路由规则的结果。为了做到这一点，像 Istio 和 Linkerd 这样的网格使用一个 [initContainer](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/pods\/init-containers\/) 在任何其他容器启动之前执行此操作。为了使该 initContainer 起作用，它需要一些权限，这往往在注重安全的集群中是困难的。至少，这些 initContainer 必须添加两个[Linux 权限](https:\/\/man7.org\/linux\/man-pages\/man7\/capabilities.7.html)，以允许它们对网络堆栈进行修改：\u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060。这些 initContainer 甚至可能以 root 用户身份运行，这在容器世界是绝对不允许的。\n\n例如，Linkerd 2.14 将在应该成为其网格的任何 Pod 中注入类似以下的 initContainer（为简洁起见，省略了一些字段）。\n\n\u0060\u0060\u0060yaml\ninitContainers:\n  - image: cr.l5d.io\/linkerd\/proxy-init:v2.2.3\n    name: linkerd-init\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        add:\n          - NET_ADMIN\n          - NET_RAW\n      privileged: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 65534\n      seccompProfile:\n        type: RuntimeDefault\n\u0060\u0060\u0060\n\n事实上，这些服务网格 initContainer 需要的额外权限被 Kubernetes 官方的 [Pod 安全标准](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/) 所禁止。这个事实本身并不是主要问题，而是根据使用的策略引擎，为这些特殊的 initContainer 提供许可是非常困难甚至根本不可能的。我们每周都在 [Kyverno 社区](https:\/\/kyverno.io\/community\/)听到用户的痛苦，似乎那些最严重受到影响的用户是那些使用 [Pod 安全准入](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-admission\/) 的人，这是实现 Pod 安全标准的进程中的准入控制器。这已经成为一个显著的问题，以至于 Istio 和 Linkerd [都尝试过](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/) 解决它（或者更准确地说，解决它的方法） ，通过提供另一种选择：一个自定义的 CNI 插件。\n\n## CNI 插件\n\n这些 CNI 插件适用于许多情况，但总的来说，它们大都是以牺牲一个问题来解决另一个问题。毕竟，iptables 规则仍然 **必须** 被重写，而网格中的某些东西仍然 **必须** 负责执行这个任务。在这两种情况下，CNI 插件实现了一个 DaemonSet，该 DaemonSet 运行一个特权容器，以在每个节点上执行这些修改，从而避免了在每个 Pod 中都需要一个 initContainer 的需求。这确实有它的优点，但也有缺点。\n\n- DaemonSet 更具特权，因为它需要 hostPath 卷，并将配置文件和二进制文件复制到每个节点。\n- 它需要了解 CNI 插件，这是专门的知识。\n- 增加了更多的操作和自动化复杂性。\n- 与其他 CNI 插件可能发生冲突，因为它们彼此不知道，并且确定如何链接多个插件不是标准化的。\n- 在水平集群缩放或节点重启期间可能会出现潜在的竞争条件，因为 DaemonSet Pod 可能在工作负载 Pod 之前启动。\n\n## 问题的关键\n\n但是为什么解决 initContainer 问题会是一个真正的问题呢？答案在于排除。排除，或者你如何免除某些资源不适用于策略，这是区分良好的准入控制器和优秀准入控制器的关键之一。目标是在尽可能不影响你确实需要的事物的同时，提供尽可能强大的 Pod 安全姿态。你希望能够将“好”与“坏”分开，而你的服务网格绝对属于“好”的范畴。但就像筛子筛沙子一样，你必须小心过滤掉“坏”的部分，使你只剩下“好”的部分。在上述 initContainer 示例中，你绝对不希望非服务网格 Pod 添加 \u0060NET_ADMIN\u0060 权限，因为那样会给予它们对网络堆栈的不受限制的访问，从而可能导致窥探和伪装等问题。减少漏斗大小的选项如下，从大到小排序。\n\n- 在整个集群中禁用 Pod 安全\n  - 这显然是一个不可行的方案，所以不需要进一步讨论。\n- 在受影响的 Namespace 中禁用 Pod 安全\n  - 因为我们谈论的是每个必须参与网格的 Pod 中都有一个 initContainer，这基本上意味着你必须在集群的大多数 Namespace 中禁用 Pod 安全，这实际上就像第一种选项一样——行不通。\n- 在包含此检查的配置文件中禁用此配置文件（如果适用）\n  - Pod 安全标准组织成称为配置文件的集合，每个配置文件包含多个控制。控制是关于*应该*检查哪些字段以及允许或不允许哪些值的命令。你可以找到包含此控制的配置文件，并禁用整个配置文件，但这显然会禁用同一配置文件中的其他控制。这也不是很好。并非所有策略准入控制器都提供此功能。\n- 在 Pod 上禁用此控制\n  - 请求 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 的这些 initContainer 违反了[Pod 安全标准的基线配置文件中的“Capabilities”控制](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#baseline)，这是 Pod 安全的基本配置文件（受限制配置文件建立在基线配置文件之上）。你可以简单地不在使用这种 initContainer 的任何 Pod 中检查此控制，但这也不好，因为那样一个恶意容器也可以添加 \u0060NET_ADMIN\u0060。你可能正在执行所有其他控制，但是简单地关闭一个控制还是太多。\n- 在一个镜像上禁用此控制\n  - 如果你已经达到了这个级别，那么你做得很好。你可以简单地不在与某种模式匹配的镜像上检查这些特权能力。但我们还可以做得更好。（顺便说一句，基于 initContainer 的名称这样做并不完全安全，因为一些恶意用户可能创建一个名为 \u0060istio-init\u0060 的 initContainer，该 initContainer 使用了一个名为 \u0060ubuntu:latest\u0060 的镜像。）\n- 在一个镜像上以及在 Pod 中的一个位置上禁用此控制\n  - 现在我们来谈谈。我们可以将一个豁免隔离到仅限于特定的镜像和 Pod 中的特定位置。例如，我们可以在 \u0060initContainers[]\u0060 数组中发现 \u0060istio\/proxyv2\u0060 镜像时，豁免 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 权限检查。如果同一镜像在主要的 \u0060containers[]\u0060 列表中使用，它将导致整个 Pod 被拒绝。\n\n许多人遇到此问题的原因之一是 Pod 安全准入（PSA）。使用 PSA，你可以实现的最精细的粒度是从顶部的第三个项目：禁用包含此检查的配置文件。由于受限制的配置文件包含基线配置文件，因此在 Namespace 上禁用基线配置文件本质上等同于不执行 Pod 安全检查。这个限制是创建 CNI 插件解决方案的主要原因。如果服务网格可以将对这些提升权限的需求分离到只有一个控制器（一个 DaemonSet）中，并且该控制器仅在一个 Namespace 中运行，那么我们基本上可以将该 Namespace 隔离为一个豁免区域。\n\n## Kyverno 中的策略\n\n在 Kyverno 中，您有几种选项来实施 Pod 安全标准。第一种和“原始”的方法是针对 Pod 安全标准中的每个控制编写一个 \u0060validate\u0060 规则。Kyverno 已经提供了完整的这些策略，打包为一个 [Helm 图表](https:\/\/github.com\/kyverno\/kyverno\/tree\/main\/charts\/kyverno-policies)，这些策略也可以作为 [单独的策略](https:\/\/kyverno.io\/policies\/?policytypes=Pod%20Security%20Standards%20(Baseline)%2BPod%20Security%20Standards%20(Restricted)) 使用。例如，基线配置文件中的“Capabilities”控制可以在[此处](https:\/\/kyverno.io\/policies\/pod-security\/baseline\/disallow-capabilities\/disallow-capabilities\/)找到。在这种策略样式中，您可以尽可能地细化。稍微的缺点是，当涉及到预构建的 Pod 安全标准时，它们需要在这些服务网格 initContainers 上进行一些修改。虽然其中一些修改相当温和，但其他可能需要更极端的修改。\n\n例如，以下是为了允许这些服务网格 initContainers 而进行的相同“Capabilities”检查可能的样子。\n\n\u003e 由于 Kyverno 在策略编写方面非常灵活，几乎总会有多种编写相同声明的方式，所以如果您已经这样做了而结果有所不同，请不用担心。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: disallow-capabilities\nspec:\n  validationFailureAction: Enforce\n  background: true\n  rules:\n    - name: adding-capabilities-service-mesh\n      match:\n        any:\n        - resources:\n            kinds:\n              - Pod\n      preconditions:\n        all:\n        - key: \u0022{{ request.operation || \u0027BACKGROUND\u0027 }}\u0022\n          operator: NotEquals\n          value: DELETE\n      validate:\n        message: \u003e-\n          Any capabilities added beyond the allowed list (AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER,\n          FSETID, KILL, MKNOD, NET_BIND_SERVICE, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT)\n          are disallowed. Service mesh initContainers may only add NET_ADMIN and NET_RAW to this list.     \n        foreach:\n          - list: request.object.spec.initContainers[]\n            preconditions:\n              all:\n              - key: \u0022{{ element.image }}\u0022\n                operator: AnyIn\n                value:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                operator: AnyNotIn\n                value: [\u0022NET_ADMIN\u0022,\u0022NET_RAW\u0022,\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n          - list: request.object.spec.[ephemeralContainers, containers][]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n\u0060\u0060\u0060\n\n请随时在 [Kyverno Playground](https:\/\/playground.kyverno.io\/#\/) 中试用一下，看看效果。里面包含了 Istio 和 Linkerd 的示例 Pod，所以尝试取消注释并复制元素来测试一下。\n\n由于 Istio 的 initContainer 需要比 Linkerd 的更多权限，因此还需要对一些其他策略进行一些轻微的修改，这些修改可以在[受限配置文件](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#restricted) 中找到。例如，以下是一个 [Kyverno Playground 链接](https:\/\/playground.kyverno.io\/#\/)，展示了如何修改 [require-run-as-nonroot 策略](https:\/\/kyverno.io\/policies\/pod-security\/restricted\/require-run-as-nonroot\/require-run-as-nonroot\/) 来豁免 \u0060istio-init\u0060。\n\n像上面展示的个别 Kyverno 策略允许最大的灵活性，但在 Kyverno 中实现 Pod 安全标准还有一种更简单的方式。实施这些标准的第二种方式是使用我们称之为“子规则”的方式来实现 \u0060validate\u0060 样式策略。[在这种样式](https:\/\/kyverno.io\/docs\/writing-policies\/validate\/#pod-security) 中，\u0060podSecurity\u0060 元素用于特指这些 Pod 安全标准。在幕后，Kyverno 使用与 Kubernetes 的 Pod 安全 Admission 完全相同的库，但使用不同的“包装器”使其应用更加灵活。\n\n例如，使用这种类型的子规则将允许您轻松实施 Pod 安全标准的整个基线配置文件，并在其中排除这些服务网格图像，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n  - name: baseline-service-mesh\n    match:\n      any:\n      - resources:\n          kinds:\n          - Pod\n    validate:\n      podSecurity:\n        level: baseline  ## 强制执行基线配置文件\n        version: latest  ## 强制执行此配置文件的最新版本\n        exclude:         ##\n\n 排除特定控制，可选特定图像\n        - controlName: Capabilities\n          images:\n          - \u0022*\/istio\/proxyv2*\u0022\n          - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这里的 \u0060exclude[]\u0060 块命名了我们到目前为止一直在讨论的“Capabilities”控制，\u0060images[]\u0060 字段命名了应该被排除的两个特定的服务网格图像。通过这种能力，您可以获得类似 PSA 的行为，但是具有简单不可能实现的细粒度。\n\n这两个选项为您提供了丰富的选择，但它们都涉及直接修改策略。还有另一种选择，允许将异常与策略本身分离，这就是 [策略异常](https:\/\/kyverno.io\/docs\/writing-policies\/exceptions\/)。例如，您可以编写一个策略异常资源，豁免给定 Pod 在特定策略中的特定规则。这对于开发人员自助服务特别有用，因为它允许其他用户请求异常，而无需查看 Kyverno 策略。但是，在 1.11 中，这在某些情况下还不够细粒度，因此在 Kyverno 1.12 中进行了一些很好的升级。接下来将更多介绍。\n\n## 1.12 中的增强功能\n\n在即将推出的 Kyverno 1.12 中，我们正在进行一些令人兴奋的增强，这些增强将使针对诸如服务网格容器等用例的排除变得更加容易。\n\n1.12 中的第一个增强功能是通过列出特定字段及其值来进一步分类 podSecurity 子规则的排除。这使您既可以使用简单的策略语言，又可以达到最低级别的细粒度。例如，这是您将能够强制执行 Pod 安全标准的整个基线配置文件，但仅从特定的 initContainers 列表中排除 Istio 和 Linkerd 图像的方法。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n    - name: baseline-service-mesh\n      match:\n        any:\n          - resources:\n              kinds:\n                - Pod\n      validate:\n        podSecurity:\n          level: baseline\n          version: latest\n          exclude:\n            - controlName: Capabilities\n              images:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              restrictedField: spec.initContainers[*].securityContext.capabilities.add\n              values:\n                - NET_ADMIN\n                - NET_RAW\n\u0060\u0060\u0060\n\n第二个增强功能是对策略异常的增强，使其具有 podSecurity 意识性，即您将能够在 PolicyException 资源中豁免策略异常的特定控制名称。例如，以下是您将能够在 Kyverno 1.12 中为先前的 \u0060validate.podSecurity\u0060 子规则创建的 PolicyException，使您可以将这些排除与只在 \u0060staging\u0060 命名空间中创建的 Pod 分离开来。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v2beta1\nkind: PolicyException\nmetadata:\n  name: pod-security-exception\n  namespace: kyverno\nspec:\n  exceptions:\n  - policyName: pod-security-standards\n    ruleNames:\n    - baseline-service-mesh\n  match:\n    any:\n    - resources:\n        namespaces:\n        - staging\n  podSecurity:\n    - controlName: Capabilities\n      images:\n        - \u0022*\/istio\/proxyv2*\u0022\n        - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这将在未来进一步增强，适用于特定容器。查看并关注 [此处的问题](https:\/\/github.com\/kyverno\/kyverno\/issues\/8570) 获取详情。\n\n## 结语\n\n本文介绍了一些有关服务网格的内容，以及为什么使用 initContainers 以及它们带来的安全问题。我们介绍了 Kyverno 如何以最精细的方式解决这些问题，同时提供了下一个版本的一瞥，以及如何使此过程更加简单。如果您有任何其他问题或反馈，请与 Kyverno 项目 [联系](https:\/\/kyverno.io\/community\/#get-in-touch)！\n', '\/trans\/securing-services-meshes-easier-with-kyverno\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">利用 Kyverno 为服务网格提供更好的 Pod 安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-configure-global-rate-limits-by-path-in-istio/">[译] 如何在 Istio 中按路径配置全局速率限制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/02/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-configure-global-rate-limits-by-path-in-istio/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中按路径配置全局速率限制', '这篇文章介绍了如何在 Istio 中根据请求路径配置全局限流。解释了 Envoy 限流过滤器和外部限流服务的工作原理，并通过例子展示了如何使用多个 rate limit action 来实现 OR 逻辑限流 certain paths。', '\n本文是为那些刚开始使用 Istio 速率限制功能，希望了解基于请求路径的速率限制如何工作的人而写的。它源于我的实践，并澄清了关于\u0060rate_limit\u0060操作中 AND\/OR 操作的困惑。我花了比预期更多的时间来弄清楚我将在这里为你总结的内容，以便你在几分钟内学习。\n\n## 基础知识\n\nIstio 在 Envoy 之上运行，而我们将讨论的主要技术是 Envoy。Envoy 有在代理本身上实现的本地速率限制和在 L4 或 L7 上调用外部服务的全局速率限制的选项。\n\n## 外部速率限制服务\n\n外部速率限制服务（RLS）与 Redis 数据库配合使用，通过 gRPC 与 envoy 实例连接。该 RLS 是由 [filter](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_filters\/rate_limit_filter#rate-limit) 在 HTTP 路由过滤器之前的侦听器链中添加而被调用的。\n\n这个外部过滤器将描述符组织成域组。每个描述符都是一个键值对，由速率限制过滤器填充，并传递给 RLS 供其在规则执行逻辑中使用。请参阅 https:\/\/github.com\/envoyproxy\/ratelimit#overview 进行实现。\n\nRLS 需要由集群操作员（你）安装和管理，并且不会随 Istio 一起提供，尽管可以在你安装时从 Istio 包的示例目录中找到它。\n\n## Envoy HTTP 速率限制过滤器\n\nEnvoy 的设置由应用于入口网关的两个 Envoy 配置组成，一个在侦听器组件中添加速率限制过滤器，另一个在动态路由组件中定义虚拟主机级别的操作。\n\n![Envoy HTTP 速率限制过滤器](f1.jpg)\n\n带有速率限制过滤器的侦听器组件 filter_chains.filters[] 在路由器之前。\n\n![虚拟主机“httpbin.com:80”的路由组件中的速率限制操作](f2.jpg)\n\n*注意：你可以通过以下方式从任何 envoy 代理（当然是网关）获取此转储：*\n\n\u0060\u0060\u0060\nk exec \u003cPOD\u003e -c istio-proxy -- curl \u0027localhost:15000\/config_dump\u0027 \u003e config_dump.json\n\u0060\u0060\u0060\n\n侦听器过滤器配置了如何到达 RLS、它正在监视的域以及一些其他设置。当满足路由中定义的操作时，此过滤器将访问在路由中定义的操作，并触发到 RLS 上游的 gRPC 调用，其中包括域、描述符键和值，以便它返回一个判断。\n\n## Istio 中按请求路径设置速率限制的示例\n\n你需要按照[此](https:\/\/istio.io\/latest\/docs\/tasks\/policy-enforcement\/rate-limit\/)开始。花点时间分析基于前文介绍的配置。供你参考，我使用的是你也可以在 Istio 包的示例目录中访问的 \u0060httpbin\u0060 服务。\n\n### 错误的方法\n\n所以，我希望根据两个路径 \u0060\/delay\u0060 和 \u0060\/status\u0060 进行速率限制。看起来很容易，所以我配置了我的 Envoy Filter 和 RLS 如下：\n\n\u0060\u0060\u0060yaml\n# EnvoyFilter 配置路由操作\n      patch:\n        operation: MERGE\n        value:\n          rate_limits:\n            - actions:\n              - header_value_match:\n                  descriptor_key: \u0022PATH\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*delay.*\u0022\n              - header_value_match:\n                  descriptor_key: \u0022PATH\u0022\n                  descriptor_value: \u0022no\n\n\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*status.*\u0022\n# RLS configmap\n...\ndata:\n  config.yaml: |\n    domain: tetrate-ratelimit\n    descriptors:\n      - key: PATH\n        value: \u0022yes\u0022\n        rate_limit:\n          unit: minute\n          requests_per_unit: 3\n      - key: PATH\n        value: \u0022no\u0022\n        rate_limit:\n          unit: minute\n          requests_per_unit: 1\n\u0060\u0060\u0060\n\n有了这个，我期望通过调用以下命令来使其工作：\n\n\u0060\u0060\u0060\ncurl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -o \/dev\/null\n\u0060\u0060\u0060\n\n但是 RLS 甚至没有注意到这个调用，所以速率限制没有发生：\n\n\u0060\u0060\u0060\n# k logs -n default -f ratelimit-57bf5688c-f8q5k\ntime=\u00222023-11-29T17:34:10Z\u0022 level=debug msg=\u0022[gostats] Flush() called, all stats would be flushed\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.mallocs: 460\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.frees: 26\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.totalAlloc: 15624\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing gauge ratelimit.go.sys: 0\u0022\n\u0060\u0060\u0060\n\n*为了设置调试模式，你可以编辑 ratelimit-server 部署的容器参数。在那里，你将找到日志级别标志。*\n\n我尝试了所有种类的组合在 \u0060rate_limits.actions\u0060 设置中，使用 \u0060string_match\u0060 和 \u0060prefix_match\u0060 替代了 \u0060safe_regex_match\u0060，但没有成功。\n\n还尝试使用单个 \u0060descriptor_key\u0060，不同的值以及甚至不设置它并使用默认的 \u0060header_match\u0060。\n\n## 顿悟时刻\n\n我发现过滤器没有发送任何东西到 RLS，因为前者在任何请求上都保持沉默。然后，通过文档我读到：\n\n\u003e \u0022如果操作不能添加描述符条目，则不会为配置生成描述符\u0022，见[这里](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/route\/v3\/route_components.proto#config-route-v3-ratelimit)。\n\n然后，发起调用：\n\n\u0060\u0060\u0060\ncurl http:\/\/127.0.0.1:8080\/status\/delay -H\u0022host: httpbin.com\u0022 -v -o \/dev\/null\n\u0060\u0060\u0060\n\n结果如下：\n\n\u0060\u0060\u0060\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022got descriptor: (PATH=yes),(PATH=no)\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022starting get limit lookup\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022looking up key: PATH_yes\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022found rate limit: PATH_yes\u0022\n\u0060\u0060\u0060\n\n所以，只有当我的路径满足 *两个* \u0060header_value_match\u0060 时，描述符才会传递给 RLS。我的当前配置正如一个 AND 运算符一样工作。\n\n然后，一切都归结为：*如何在 rate_limit 操作中设置 OR 逻辑而不是 AND？*\n\n## 解决方案\n\n原始配置略有变化，如下：\n\n\u0060\u0060\u0060\n# EnvoyFilter 配置路由操作   \n        value:\n          rate_limits:\n            - actions: # 任何操作在此处\n              - header_value_match:\n                  descriptor_key: \u0022PATH_DELAY\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*delay.*\u0022\n            - actions:\n              - header_value_match:\n                  descriptor_key: \u0022PATH_STATUS\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*status.*\u0022\n\u0060\u0060\u0060\n\n看起来像一个有效的配置，就像：\n\n\u0060\u0060\u0060\n❯ curl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -s -o \/dev\/null \n*   Trying 127.0.0.1:8080...\n* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)\n\u003e GET \/delay\/1 HTTP\/1.1\n\u003e Host: httpbin.com\n\u003e User-Agent: curl\/7.81.0\n\u003e Accept: *\/*\n\u003e \n* Mark bundle as not supporting multiuse\n\u003c HTTP\/1.1 200 OK\n\u003c server: istio-envoy\n\u003c date: Wed, 29 Nov 2023 20:17:02 GMT\n\u003c content-type: application\/json\n\u003c content-length: 703\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 1005\n\u003c \n{ [703 bytes data]\n* Connection #0 to host 127.0.0.1 left intact\n\n❯ curl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -s -o \/dev\/null \n*   Trying 127.0.0.1:8080...\n* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)\n\u003e GET \/delay\/1 HTTP\/1.1\n\u003e Host: httpbin.com\n\u003e User-Agent: curl\/7.81.0\n\u003e Accept: *\/*\n\u003e \n* Mark bundle as not supporting multiuse\n\u003c HTTP\/1.1 429 Too Many Requests \u003c---------- 参见\n\u003c x-envoy-ratelimited: true\n\u003c date: Wed, 29 Nov 2023 20:17:06 GMT\n\u003c server: istio-envoy\n\u003c content-length: 0\n\u003c \n* Connection #0 to host 127.0.0.1 left intact\n\u0060\u0060\u0060\n\n和 RLS 日志：\n\n\u0060\u0060\u0060\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022starting cache lookup\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022looking up cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580 current: 1\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022returning normal response\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022[gostats] flushing time ratelimit_server.ShouldRateLimit.response_time: 0.000000\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022got descriptor: (PATH_DELAY=yes)\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022starting get limit lookup\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022looking up key: PATH_DELAY_yes\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022found rate limit: PATH_DELAY_yes\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022applying limit: 1 requests per MINUTE, shadow_mode: false\u0022\n\u0060\u0060\u0060\n\n相信我，\u0060\/status\u0060 的限制也是存在的。\n\nAND\/OR逻辑用于速率限制 \u0060rate_limits\u0060 配置在其数组中支持多个位置，因此 AND\/OR 逻辑操作取决于动作是否嵌套到相同的 \u0060actions\u0060 子集中。\n\n------\n\n**注意**：可能有一种更安全、更有效的路径匹配方式，而不是像这个例子中那样打开正则表达式。它很简单，所以我们专注于主题。\n', '\/trans\/how-to-configure-global-rate-limits-by-path-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了如何在 Istio 中根据请求路径配置全局限流。解释了 Envoy 限流过滤器和外部限流服务的工作原理，并通过例子展示了如何使用多个 rate limit action 来实现 OR 逻辑限流 certain paths。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/scaling-cilium-to-new-heights-with-xds/">[译] Cilium 的控制平面升级之路：xDS API 的引入与应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.solo.io/blog/scaling-cilium-to-new-heights-with-xds/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cilium 的控制平面升级之路：xDS API 的引入与应用', '本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。', '\n在这篇博客中，我们将探讨当前的 Cilium 控制平面设计，[大规模部署可能出现的限制的位置和原因](https:\/\/github.com\/cilium\/cilium\/issues\/30283)，以及社区如何使用 CNCF 的 [通用数据平面 (xDS) API](https:\/\/github.com\/cncf\/xds) 推进这个架构。\n\n## 了解 Cilium 的控制平面架构\n\nCilium 遵循基于“数据平面”和“控制平面”的常见网络架构。在 Cilium 中，数据平面部署在每个主机（或 Kubernetes 节点）上，包括用于处理 L3\/L4 连接和策略的 eBPF 程序。为了简化起见，对于完整性，Cilium 还在其数据平面中使用 Envoy 代理处理 L7 策略，但我们将省略这部分。\n\n![](f1.jpg)\n\nCilium 控制平面以 cilium-agent 守护程序的形式实现，部署在每个 Kubernetes 节点上。每个 cilium-agent 都是控制平面的单独、独立的实例。\n\ncilium-agent 连接到 Kubernetes API 服务器，监视配置更改，然后使用它来配置数据平面。cilium-agent 还将配置写入 Kubernetes API，表示正在其各自节点上创建的端点或标识。\n\n例如，当在 Kubernetes 节点上启动一个 Pod 时，cilium-agent 负责编写一个 CiliumEndpoint 自定义资源（CR），并可能是一个表示 Pod 网络标识的 CiliumIdentity CR。cilium-agent 还会更新与标识和端点映射相关的节点上的 eBPF 映射。其他 Kubernetes 节点上的 cilium-agent 也会监视这些新的 CiliumEndpoint 和 CiliumIdentity CR 的创建，并更新其本地的 eBPF 数据平面以执行策略。这种机制能够协调每个节点上的全局策略执行配置，以便所有节点看到相同的执行行为。\n\n![](f2.jpg)\n\n## 构建控制平面的最佳实践\n\n我们以前 [曾多次在博客中](https:\/\/www.solo.io\/blog\/building-a-control-plane-for-envoy\/) [讨论过构建](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) [可扩展、安全、高效的控制平面的最佳实践](https:\/\/www.solo.io\/blog\/why-the-control-plane-matters\/)。在深入研究如何扩展 Cilium 的控制平面之前，我们应该回顾一些这些最佳实践。\n\n网络架构中的数据平面应该尽可能简单，性能高，以及高效完成它需要做的事情：在本例中，来回传输字节，实施策略，并执行安全性。控制平面的作用是保护数据平面免受复杂性的干扰，以及任何分散数据平面核心任务的事物。\n\n另一方面，用户需要能够以最适合他们用户体验的形式指定配置和策略。很多时候，通过某种 [特定领域的配置格式](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) 来实现。然后需要将这种更高级别的用户配置与基础设施状态相结合，并将其转化为较低级别的数据平面格式。转译是一半的战斗。还需要将较低级别的配置分发到数据平面，并高效地执行。这就是控制平面出现在画面中的地方。\n\n![](f3.jpg)\n\n控制平面允许配置解耦并与平台的其他部分集成，这些部分随后可以通知数据平面。在许多方面，这个图表与我们构建应用程序时使用的 [三层架构](https:\/\/learn.microsoft.com\/en-us\/azure\/architecture\/guide\/architecture-styles\/n-tier) 类似：表示层，解耦的业务逻辑层和数据存储。\n\n![](f4.jpg)\n\n在网络架构的情况下，控制平面层将处理读取\/写入 Kubernetes API 和创建网络标识等敏感数据。由于它是一个单独的层，我们可以对其进行安全和硬化处理，并消除数据平面需要执行这些任务的权限。在许多情况下，虽然开始时更简单，但合并一些层会导致效率低下、安全问题和扩展\/耦合问题。\n\n## Cilium 控制平面架构的扩展考虑\n\n集群中的每个 cilium-agent 负责将全局集群配置更新到其本地数据平面配置。每个 cilium-agent 可能会监视多达 15 种 CRD 类型。\n\n随着集群在节点、Pod、命名空间和网络策略方面的规模增长，每个 cilium-agent 需要执行的工作量也会增加。为了服务和更新所有这些状态，会对 Kubernetes apiserver 造成压力，可能导致 [问题](https:\/\/github.com\/cilium\/cilium\/issues\/29127)。\n\n![](f5.jpg)\n\n在大规模部署中，这种对 Kubernetes API 服务器的压力可能最终会减慢 *甚至导致* 集群中的所有操作。\n\n在查看集群中的常见操作以及 cilium-agent 处理它的方式时，全局配置状态对每个节点的影响确实开始放大：工作负载和命名空间被标记、重新标记或取消标记。\n\ncilium-agent 负责为调度到其节点上的 Pod 编写 CiliumEndpoint 和 CiliumIdentity 资源。由于这些资源依赖于 Pod 和命名空间标签的组合，标签的更改将导致所有依赖资源的更新。这会导致大量的写操作和相应的读取操作，因为此状态随后会传播到所有 cilium-agent，它们必须做出反应并重新配置其本地数据平面。\n\n\u0060\u0060\u0060yaml\napiVersion: cilium.io\/v2\nkind: CiliumIdentity\nname: \u002250568\u0022\nmetadata:\n  labels:\n    app: sleep\n    io.cilium.k8s.policy.cluster: default\n    io.cilium.k8s.policy.serviceaccount: sleep-v1\n    io.kubernetes.pod.namespace: default\n    version: v1\nsecurity-labels:\n  k8s:app: sleep\n  k8s:io.cilium.k8s.namespace.labels.team: loyalty\n  k8s:io.cilium.k8s.namespace.labels.version: v10.45\nk8s:io.cilium.k8s.namespace.labels.kubernetes.io\/metadata.name: default\n  k8s:io.cilium.k8s.policy.cluster: default\n  k8s:io.cilium.k8s.policy.serviceaccount: sleep-v1\n  k8s:io.kubernetes.pod.namespace: default\n  k8s:version: v1\n\u0060\u0060\u0060\n\n**代码清单 1：\u0060CiliumIdentity\u0060 资源结合了 *Pod* 和 *命名空间* 标签。对任一者的更改都会强制重新计算并生成新的 \u0060CiliumIdentity\u0060。**\n\n对集群中的命名空间进行标记等操作对于 Cilium 可能非常昂贵，并且有可能导致 API 服务器操作减慢到爬行的程度（[请参阅用于标识目的包括\/排除标签的建议](https:\/\/docs.cilium.io\/en\/stable\/operations\/performance\/scalability\/identity-relevant-labels\/)）。例如，在中等规模集群中更改命名空间的标签可能会导致足够多的 cilium-agent 导致 Kubernetes API 服务器响应延迟约 **4 分钟**。这将有效地使集群上的所有操作停滞不前。\n\n考虑以下环境：\n\n- 200 个节点的 Kubernetes 集群\n- 5 个命名空间\n- 每个命名空间有 50 个部署\n- 每个部署有 80 个副本（总共 20,000 个 Pod）\n\n在一次更新跨命名空间的标签的测试中，我们看到 CPU 利用率急剧上升，约为 150%，并且内存在整个集群的所有节点上升到约 1 GB。\n\n![图 1：所有节点上的 CPU 和内存峰值](g1.jpg)\n\n在整个集群的所有节点上同时提高 CPU 和内存是不希望看到的行为，然而更严重的是 cilium-agent 事件的读写如何影响 Kubernetes API 服务器的延迟。在下图中，我们看到延迟增长到 3 到 4 *分钟*。这肯定会导致各种类型的停机！不幸的是，由于这种控制平面架构，通过增加容量来处理扩展问题的典型方法不起作用；实际上，添加更多节点和\/或更多工作负载会放大这种行为。\n\n![图 2：Kubernetes API 服务器延迟增加到 3 - 4 分钟](g2.jpg)\n\n## 减轻 Kubernetes API 服务器的压力\n\n对于较大的 Cilium 集群，您可以通过使用[专用的键值存储](https:\/\/docs.cilium.io\/en\/latest\/kvstore\/) 来减轻 Kubernetes API 服务器上的压力。键值存储用于存储工作负载标识、端点和 IP 到标识映射等内容。Cilium 不再将此信息存储在 Kubernetes 自定义资源（CRD）中，而是在其自己的数据库中直接监视、操作和写入对象。Cilium Helm 图表支持将 etcd 作为专用键值存储来进行安装，以满足此目的。\n\n随着集群的增长，使用 kv-store 来卸载 Cilium 对象的读\/写操作可能是一个好主意，而不是给 Kubernetes API 服务器施加压力。\n\n注意：Cilium 还进行了其他优化，以减轻 Kubernetes API 服务器的压力，例如策略状态更新。有关更多信息，请参阅[k8s-events-handover 文档](https:\/\/docs.cilium.io\/en\/stable\/internals\/cilium_operator\/#policy-status-update)。\n\n如果我们在存在 kv-store 的情况下重新运行先前的测试，我们会看到对 Kubernetes API 服务器的压力减轻，尽管 CPU 可能没有减轻。\n\n![图 3：所有节点上的 CPU 峰值，内存保持在 300-400 MB 范围内](g3.jpg)\n\n与先前情况下的 150% CPU 消耗不同，CPU 在大约 100% 左右波动，而内存保持在大约 300 到 400 MB 的范围内。这是因为对每个 Pod 和每个标识（Cilium 在更改标签时创建所有新标识，并且必须更新引用旧标识的所有 eBPF 映射的 CiliumEndpoint 和 CiliumIdentity 对象的重新计算和生成需要 CPU 计算资源来完成，无论使用何种后备存储（CRD、kv-store 等）。\n\n如果我们观察 kv-store，我们会看到在此命名空间标签事件期间，事件操作\/秒和延迟会急剧上升：\n\n![图 4：kv-store 上的事件操作和延迟在此命名空间标签事件期间急剧上升](g4.jpg)\n\n在这种特殊情况下，我们看到 kv-store 承受了相当大的负载，通过事件 IO，我们看到 kv-store 调用的延迟降低到约 15 秒左右。总之，这对于整个集群操作而言要好得多，而不是用请求使 Kubernetes API 服务器饱和。事实上，在图 5 中，我们可以看到 Kubernetes API 服务器的延迟保持在 10 到 40 毫秒的可接受范围内，而在先前的示例中，延迟升高到 4 分钟。\n\n![图 5：Kubernetes API Server 延迟在 10 到 40ms 之间](g5.jpg)\n\n使用 kv-store 后端来存储 Cilium 对象是一种缓解 Kubernetes API 服务器压力的好方法，但它也有其缺点。现在有两个持久存储需要维护，而且随着规模的增加，运维负担也增加。在生产环境中运行数据库或持久存储（总体来说）以支持规模化并非易事。如果失去一致性，恢复过程是必需的，因为现在有两个“真相源”。许多平台完全管理 Kubernetes API 服务器及其存储，但 kv-store 并不是如此。由于绝大多数负载是读取操作，缓存将在减少运维复杂性的同时产生相同的改进。\n\n## 使用 xDS 改进 Cilium 的控制平面扩展、安全性和效率\n\n如果我们可以兼顾两全呢？既减轻 Kubernetes API 服务器的压力，又消除维护单独数据存储的昂贵生产操作的需要？甚至可能解决一些其他尚未解决的 Cilium 扩展和安全性问题？\n\n在 Solo.io，我们很高兴为 Cilium 社区中更广泛的 xDS 工作作出贡献，并帮助推动该项目朝着可扩展、安全和高效的控制平面迈进。使用[xDS 协议](https:\/\/github.com\/cncf\/xds)使我们能够在集群中扩展到数千甚至数万个节点。这种方法解决了上面讨论的许多问题，以及其他问题，如单节点妥协影响范围和规模上的 CiliumIdentity 重复。让我们看看它是如何工作的。\n\n[xDS 协议](https:\/\/github.com\/cncf\/xds)最初是一种动态配置[Envoy 代理](https:\/\/www.envoyproxy.io\/)的方式，但是它建立的理念是可以用来支持“通用数据平面”。该协议已成为在多个节点之间同步状态的有效方式，[现在由 CNCF 工作组管理](https:\/\/github.com\/cncf\/xds)。\n\n最终，我们希望消除每个 cilium-agent 所做的冗余工作，将诸如标识创建之类的复杂且权限敏感的操作集中在一起，并以高效的方式为代理提供状态，同时不损害 Kubernetes 作为整体的可靠性。\n\n为了做到这一点，我们将不再让每个 cilium-agent 充当独立的控制平面，而是考虑让 cilium-agent 充当智能集中控制平面的简单只读客户端。控制平面将保护代理免受复杂和权限敏感的操作。\n\ncilium-agent（现在属于数据平面的一部分）与控制平面之间的通信将采用[xDS 协议](https:\/\/github.com\/cncf\/xds)。数据平面不允许从数据平面到控制平面的写操作，因此 cilium-agent 不需要对后端存储（CRD\/kv-store）具有写入访问权限。xDS 控制平面服务可以得到安全加固，是唯一需要支持对 Kubernetes API 服务器进行读\/写操作的组件。\n\n![](f6.jpg)\n\n这种架构减轻了 Kubernetes API 服务器的负载，并且不需要任何外部管理的数据存储。它看起来也更接近之前讨论的三层控制平面架构。\n\n![图 6：xDS 实现的初始测试显示 CPU 和内存使用的预期行为](g6.jpg)\n\n在这种架构中，我们确实看到了 xDS 控制平面 pods 中的 CPU 和内存开销，正如预期的那样，每个节点仍然需要处理 eBPF 数据平面的一些 CPU\/内存处理开销。\n\n这种模型带来的其他好处包括在节点受损时更小的影响范围，以及消除了 cilium-agent 创建的重复标识。在原始架构（CRD 或 kv-store）中，每个节点都有一个完整的控制平面，需要特殊权限来读取和写入\u0060\u0060CiliumEndpoints\u0060\u0060和\u0060\u0060CiliumIdentity\u0060\u0060。如果某个节点上的 cilium-agent 受到妥协，那么整个控制平面将受到威胁，并使攻击者能够影响其他节点。这可能导致整个集群妥协。在 xDS 模型中，cilium-agent 被允许从控制平面读取数据（不允许写入），单个 cilium-agent 的妥协不会给予对整个控制平面或集群的访问权限。正如前面提到的，xDS 控制平面被视为特权组件，可以进行锁定和安全设置，甚至可以完全在集群之外运行。\n\nxDS 方法的另一个好处是通过集中标识创建来消除 Cilium 中重复标识的生成。在现有模型中，每个 cilium-agent 都独立充当控制平面，与其他节点隔离，正如在现有模型中，它试图做出可能是重复的决策。例如，当 Pod 分配到节点时，CNI 负责设置网络端点，当 cilium-agent 识别到一个新的端点，它没有现有的\u0060\u0060CiliumIdentity\u0060\u0060时，它将尝试创建它。如果命名空间标签发生更改并且需要重新计算所有标识，那么也会发生相同的情况。由于标识创建在多个节点上独立进行，因此有很大机会为相同标识创建多个\u0060\u0060CiliumIdentity\u0060\u0060（在极端情况下，[如此描述的易于重现](https:\/\/docs.google.com\/document\/d\/1Hcc_2mB9OOUxrqQgZ-gSYDPnLYE_If_TCzVbUGDOdGM\/edit?pli=1#heading=h.yzvq0akbw7z9)）。在 xDS 方法中，\u0060\u0060CiliumIdentity\u0060\u0060在集中创建，从而消除了这种情况。\n\n## 结论\n\nCilium 在 eBPF 基础上构建了强大的数据平面，但要使 Cilium 在规模上有效运行，我们可以利用 xDS 协议来改进控制平面架构。xDS 是一种高效的协议，允许我们利用多年来学到的构建控制平面的最佳实践。事实上，如果我们将 xDS 控制平面 [直接构建到 cilium-operator 中](https:\/\/docs.google.com\/document\/d\/1U4pO_dTaHERKOtrneNA8njW19HSVbq3sBM3x8an4878\/edit#heading=h.ghzkbpzc9oea)，那么从这个实施中不会增加新的复杂性。\n', '\/trans\/scaling-cilium-to-new-heights-with-xds\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/doordash-service-mesh/">[译] DoorDash 的服务网格之旅：如何实现高效的区域感知路由</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://doordash.engineering/2024/01/16/staying-in-the-zone-how-doordash-used-a-service-mesh-to-manage-data-transfer-reducing-hops-and-cloud-spend/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('DoorDash 的服务网格之旅：如何实现高效的区域感知路由', '本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。', '\nDoorDash 从单体应用架构演变为基于[单元（cells）](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)和[微服务（microservices）](https:\/\/doordash.engineering\/2020\/12\/02\/how-doordash-transitioned-from-a-monolith-to-microservices\/)架构后，获得了许多好处。新的架构降低了开发、测试和部署所需的时间，同时提高了可伸缩性和用户体验，包括商家、送餐员和消费者。然而，随着微服务和后端数量的增加，DoorDash 注意到了跨可用区（AZ）的数据传输成本上升。这些数据传输成本 — [在发送和接收时发生](https:\/\/aws.amazon.com\/blogs\/architecture\/overview-of-data-transfer-costs-for-common-architectures\/) — 允许 DoorDash 为其最终用户提供高可用性的服务，可以抵御一个或多个 AZ 的降级。\n\n成本上升促使我们的工程团队调查了以更高效的方式提供相同级别的服务的替代方法。在本博客文章中，我们描述了 DoorDash 使用服务网格实现数据传输成本节省而不牺牲服务质量的过程。\n\n## DoorDash 流量架构\n\n在我们深入解决方案之前，让我们回顾一下 DoorDash 的流量基础设施。\n\n*基于单元的架构：* 如下图所示，我们的流量架构遵循[基于单元的设计](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)。所有微服务 Pod 都部署在多个隔离的单元中。每个服务在每个单元中都有一个 Kubernetes 部署。为了确保单元之间的隔离，不允许单元间的流量。这种方法使我们能够减小单个单元故障的影响范围。对于单例服务或尚未迁移到单元架构的服务，部署在一个全局单元中。内部的[Envoy](https:\/\/www.envoyproxy.io\/)路由器允许全局单元与复制的单元之间进行通信。\n\n*Kubernetes 集群部署：* 每个单元由多个 Kubernetes 集群组成；每个微服务都专门部署在给定单元内的一个集群中。这个设计确保了可伸缩性和可靠性，同时与我们的基于单元的架构保持一致。\n\n![图 1：基于单元的多集群部署](f1.jpg)\n\n*高可用性：* 为了增强可用性和容错性，每个 Kubernetes 集群都部署在多个 AZ 中。这个做法最大程度地减少了由于一个或多个 AZ 中断引起的中断。\n\n*平面网络中的直接通信：* 利用[AWS-CNI](https:\/\/github.com\/aws\/amazon-vpc-cni-k8s)，在一个单元中的不同集群中的微服务 Pod 可以直接通信。这种平面网络架构简化了通信路径，促进了微服务之间的高效交互。\n\n*自定义多集群服务发现：* 我们的自定义服务发现解决方案，DoorDash 数据中心服务发现（DDSD），提供了一个自定义的 DNS 域，以支持多集群通信。客户端使用 DNS 名称动态发现所需服务的所有 Pod IP 地址。DDSD 的功能类似于 Kubernetes 的[无头服务](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/service\/#headless-services)，但它也适用于集群间通信。例如，不同集群中的客户端可以使用*payment-service.service.prod.ddsd*来检索与支付服务相关联的所有 Pod IP 地址。\n\n*客户端负载平衡：* 服务网格负责客户端负载平衡。对于未加入服务网格的服务，负载平衡发生在客户端应用程序端。\n\n图 2 描述了上述四个特征：\n\n![图 2：单元内和跨 AZ 通信模式](f2.jpg)\n\n*服务网格架构：* 如图 3 所示，DoorDash 的服务网格部署在每个单元中，采用了一种边车容器设计模式，利用[Envoy](https:\/\/www.envoyproxy.io\/)代理作为数据平面。我们建立了我们自己的基于[xDS 的](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)控制平面来管理 Envoy 配置。边车容器作为一种即插即用的解决方案，可以在不需要对应用程序代码进行任何修改的情况下，无缝地拦截、控制和转换进出 DoorDash 微服务的所有 HTTP1\/HTTP2\/gRPC 流量。\n\n![图 3：服务网格高级架构](f3.jpg)\n\n虽然 DoorDash 的流量架构具有独特的组件，但我们认为我们在网络流量效率方面遇到的挑战和经验可以广泛应用于其他架构。\n\n## DoorDash 的常见数据传输模式\n\n对于跨可用区的流量，我们将我们的流量模式分类如下：\n\n*HTTP1\/HTTP2\/gRPC流量：* 在同一单元内的微服务之间进行直接的 Pod 到 Pod 通信；在全局单元中的微服务与涉及到调用路径中的额外跃点的单元之间的流量 — 例如内部路由器 — 增加了跨可用区流量的可能性。\n\n*存储流量：* 包括来自微服务到有状态系统（如 Aurora PostgreSQL、CockroachDB、Redis 和 Kafka）的流量。\n\n*内部基础设施流量：* 内部 Kubernetes 流量，例如[coredns](https:\/\/github.com\/coredns\/coredns)流量或[Kubernetes 控制平面组件](https:\/\/kubernetes.io\/docs\/concepts\/overview\/components\/#control-plane-components)之间的通信。这种类型的流量通常使用 Kubernetes 内部 DNS 而不是 DDSD。\n\n## 初步假设\n\n我们认为，由于我们的微服务架构，同一单元内的 HTTP1\/HTTP2\/gRPC 流量是跨可用区数据传输成本的最大来源。我们还确定服务网格可能通过[Envoy 中的该功能](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/load_balancing\/zone_aware)实现所有微服务的区域感知路由。了解了这两点后，我们优先研究和优化 HTTP1\/HTTP2\/gRPC 流量模式，以提高效率而不降低服务质量。\n\n## 解决 HTTP1\/HTTP2\/gRPC 流量成本问题\n\n最初，服务之间的流量在不同的 AZ 之间均匀分布，如图 4 所示。有了 Envoy 的区域感知路由功能，调用者服务现在更倾向于将流量引导到同一 AZ 中的被调用者服务，如图 5 所示，从而降低了跨可用区的数据传输成本。\n\n![图 4：Pod 之间的简单轮询负载平衡](f4.jpg)\n\n![图 5：区域感知路由](f5.jpg)\n\n为了启用 Envoy 的区域感知路由功能，我们在服务网格的控制平面中进行了更改，将服务发现类型从[STRICT_DNS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#strict-dns)切换到终端发现服务（[EDS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#endpoint-discovery-service-eds)）。如下图所示，对于 DDSD 域，控制平面现在会动态地将来自每个 Envoy 集群的 EDS 资源发送回 Envoy 边车容器。EDS 资源包括 Pod IP 地址及其 AZ 信息。\n\n\u0060\u0060\u0060yaml\nresources:\n - \u0022@type\u0022: type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\n   cluster_name: payment-service.service.prod.ddsd\n   endpoints:\n     - locality:\n         zone: us-west-2a\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 1.1.1.1\n                 port_value: 80\n     - locality:\n         zone: us-west-2b\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 2.2.2.2\n                 port_value: 80\n     - locality:\n         zone: us-west-2c\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 3.3.3.3\n                 port_value: 80\n\u0060\u0060\u0060\n\n*图 6：一个 EDS 响应的示例*\n\n通过 EDS 响应中提供的数据，Envoy 获取了调用者服务和被调用者服务的 AZ 分布。这些信息使 Envoy 能够[计算](https:\/\/github.com\/envoyproxy\/envoy\/blob\/v1.28.0\/source\/common\/upstream\/load_balancer_impl.cc#L520)Pod 之间的权重。尽管仍然优先通过本\n\n地 AZ 发送流量，但为了确保均衡分布并避免过载任何单个 Pod，一些流量可能仍然会引导到跨越 AZ，如图 7 所示。\n\n![图 7：优先使用本地 AZ，同时确保流量均衡](f7.jpg)\n\n这种路由解决方案具有多种好处，包括：\n\n- 在服务不均匀分布在不同 AZ 的情况下仍然保持流量平衡\n- 可以动态设置 Pod 之间的流量权重，消除手动操作\n- 减少单个或多个 AZ 中断的影响范围\n- 减少流量延迟 — 调用者服务连接到更近的被调用者服务\n\n我们的解决方案在服务 Pod 均匀部署在可用区时变得更加有效。为实现这一目标，我们利用了[topologySpreadConstraints](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/)，并将[maxSkew](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/#spread-constraint-definition)设置为 1，当 Unsatisfiable 时设置为 ScheduleAnyway，如图 8 所示。这意味着 Kubernetes 调度器将仍然调度 Pod，即使条件未满足，优先选择最小化偏差的节点。\n\n这种方法确保了 Pod 仍然被调度；否则将会减少装箱量，增加空闲计算量，并最终影响了区域感知的与流量相关的成本减少。在我们的生产系统中，我们观察到有 10% 的流量是根据这个 topologySpreadConstraints 策略跨可用区发送的。\n\n\u0060\u0060\u0060yaml\ntopologySpreadConstraints:\n  - maxSkew: 1\n    topologyKey: topology.kubernetes.io\/zone\n    whenUnsatisfiable: ScheduleAnyway\n\u0060\u0060\u0060\n\n*图 8：配置以均匀部署 Pod 在可用区之间*\n\n随着我们逐渐推出上述更改，我们看到了 AWS 跨可用区传输费用的改进。即便如此，我们预期的减少要更大。因此，我们着手调查为什么我们没有节省多少预期的费用。\n\n## 大海捞针：更好地了解跨可用区的流量\n\n我们通过验证[Envoy 在可用区之间的指标](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats#config-cluster-manager-cluster-per-az-stats)和应用程序日志，确认了区域感知路由正在按预期工作，但我们需要更多的可见性来确定数据传输成本降低的根本原因低于预期。这促使我们使用了多种可观测性工具，包括[VPC 流量日志](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html)，[ebpf 代理指标](https:\/\/doordash.engineering\/2023\/08\/15\/bpfagent-ebpf-for-monitoring-at-doordash\/)和 Envoy 网络字节指标，以纠正这种情况。\n\n使用 VPC 流量日志，我们将[srcaddr 和 dstaddr IP 地址](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html#flow-logs-fields)映射到部署在我们的 AWS 帐户结构中的相应子网。这个映射提供了一个汇总规则，让我们理解托管云足迹的不同部分之间的出口\/入口流量模式，包括用于生产 Kubernetes 集群、存储解决方案、缓存和消息代理的子网，如表 1 所示。我们确认，我们跨可用区传输费用的最大来源是每个单元内的非存储流量。其中约有 20% 的费用是由于流量传输到用于我们事件接收流水线（[Iguazu](https:\/\/doordash.engineering\/2022\/08\/02\/building-scalable-real-time-event-processing-with-kafka-and-flink\/)）的一个弹性负载均衡器（ELB）引起的。\n\n![表 1：使用 VPC 流量日志进行跨可用区流量归因](t1.jpg)\n\n此外，我们检查了服务网格 HTTP1\/HTTP2\/gRPC 指标，特别是用于所有请求和响应的连接字节，包括入口和出口流量。来自服务网格 Envoy 代理的最重要的指标是[来自 Envoy 侦听器和集群的 cx_rx_bytes_total 和 cx_tx_bytes_total](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats.html#general)。但是，由于当时并非所有服务都已加入到服务网格中，因此我们依赖于 BPFAgent 的指标，该指标在每个生产 Kubernetes 节点上都全球部署，以增加对总网络字节的可见性。使用这两个来源的指标，我们发现了 90% 的流量是 HTTP1\/HTTP2\/gRPC 流量；其中 45% 的流量已经加入了服务网格，并且该部分流量的 91% 被发送到 Iguazu！\n\n## 环环相扣：Iguazu 的流量流动\n\n在分析了如图 9 所示的 Iguazu 流量流动之后，我们意识到在调用者和被调用者服务或 Pod 之间存在多个中间跃点。当流量从调用者服务传输到 Iguazu 时，它首先经过 ELBs，然后着陆在全球单元中不同 Kubernetes 集群中的一个工作节点上。因为[externalTrafficPolicy](https:\/\/kubernetes.io\/docs\/tasks\/access-application-cluster\/create-external-load-balancer\/#preserving-the-client-source-ip)配置为集群，*iptables*会将流量重定向到另一个节点以确保负载均衡。\n\n![图 9：Iguazu 的原始流量流动](f9.jpg)\n\n我们观察到以下数据传输行为：\n\n- 向 ELBs 发送流量的客户端仍然直接使用 ELB DNS 名称。因为客户端没有使用内部的 DDSD 域，所以 Envoy 集群中的服务发现类型仍然是 STRICT_DNS，而不是 EDS，这是启用区域感知路\n\n由的先决条件。这意味着 Envoy Sidecar 容器使用简单的轮询方法来将流量分发给 ELBs。\n- 在 ELBs 到 Cluster 2 的 Kubernetes 工作节点的流量的情况下，禁用了跨可用区的负载均衡。\n- 当流量从 Iguazu ELB 到达 Kubernetes 工作节点时，*iptables*会将其进一步重定向到随机节点，这也增加了跨可用区流量的概率。\n\n考虑到 Iguazu 调用图内部的多个跃点的复杂性，我们决定将 Iguazu 服务迁移到与其客户端部署在同一单元的地方。我们还配置了所有客户端 Envoy Sidecar 的[路由规则](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/rds)，将流量路由到新集群中的 Iguazu Pod，而不需要我们的工程师对其服务进行任何代码或配置更改。这使我们能够为 Iguazu 流量启用直接的 Pod 间通信，实现区域感知路由，同时减少了 ELBs 处理的流量量，如图 10 所示。\n\n![图 10：Iguazu 的新流量流动](f10.jpg)\n\n这些操作使 DoorDash 的数据传输成本以及 ELB 成本受到了很大的打击，以至于我们的云服务提供商与我们联系，询问我们是否遇到了与生产相关的问题。\n\n## 吸取的教训\n\n在我们的旅程中，我们获得了一些关键的发现，包括：\n\n- 云服务提供商的数据传输定价比起初看起来更加复杂。值得投入时间来理解定价模型，以构建正确的效率解决方案。\n- 要全面了解\/查看所有跨可用区的流量是具有挑战性的。然而，将来自不同来源的网络字节指标结合起来，足以识别热点，一旦解决，可以在使用和成本方面产生实质性影响。\n- Envoy 的区域感知路由可以将流量发送到其本地可用区，同时通过平衡流量自动确保弹性。\n- 随着微服务调用图中跃点数量的增加，数据被传输到跨可用区的可能性增加，增加了确保所有跃点支持区域感知路由的复杂性。\n- 如果你考虑使用服务网格来管理流量，你也可以利用它来提高效率。\n- 要了解更多关于 DoorDash 的服务网格之旅的信息，请查看 Hochuen 的 KubeCon \u002b CloudNativeCon North America 2023[服务网格会议](https:\/\/www.youtube.com\/watch?v=I6E_7f40YP0)。\n\n## 未来的工作\n\n我们已经列出了我们希望实施的解决方案增强功能的列表，包括：\n\n- 简化从不同来源收集指标并提供成本和使用情况的统一概述的过程。\n- 启用内部 Envoy 路由器的区域感知路由功能。\n- 使解决方案更具可扩展性，以支持 DDSD 之外的其他域的 HTTP1\/HTTP2\/gRPC 流量。\n- 使用 Kubernetes 网络代理 kube-proxy 为内部基础设施流量启用[拓扑感知路由](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/topology-aware-routing\/)功能。\n- 探索优化的路由，用于与 DoorDash 的有状态系统（例如 PostgreSQL、CRDB、Redis 和 Kafka）之间的大数据传输操作。这将允许流量在有意义的情况下保持在单一 AZ 泳道中，进一步降低成本。\n\n## 致谢\n\n我们感谢**Darshit Gavhane**和**Allison Cheng**将所有 Iguazu 服务迁移到客户端正在运行的同一单元，以及**Steve Hoffman**和**Sebastian Yates**在旅程中的建议和指导。\n', '\/trans\/doordash-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/osm-deprecated/">[译] OSM（Open Service Mesh）项目将停止更新，团队将协力 Istio 服务网格开发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/05/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://openservicemesh.io/blog/osm-project-update/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('OSM（Open Service Mesh）项目将停止更新，团队将协力 Istio 服务网格开发', '开放服务网格（OSM）宣布停止更新，将与 Istio 社区更加紧密地合作，以加速实现下一代服务网格技术的发展。服务网格社区的发展，如 Kubernetes Gateway API 和 GAMMA，进一步凸显了服务网格在当今云原生栈中的关键重要性和成熟度。OSM 团队将与 Istio 社区合作，包括利用 Kubernetes 的 ClusterTrustBundles 功能增强 Istio 的网格证书管理体验，提出“安全模式”功能方法，改进 Istio 的遥测体验，并与 Istio 新宣布的无 Sidecar 环境网格模式进行合作。', '\n开放服务网格（OSM）于 2020 年 8 月推出，并于此后不久加入了 CNCF。自那以后，OSM 一直在与社区紧密合作，提供一个使用可互操作的服务网格 API 集合的简化操作服务网格体验，这些 API 集合通过[服务网格接口（SMI）](https:\/\/smi-spec.io\/)实现。\n\n服务网格社区涌现了大量的兴奋、进步和共享的想法，这些想法与 OSM 的指导原则相一致。OSM 的宪章一直是提供一个聚焦于易于消费和操作的服务网格体验。同样，另一个服务网格社区项目 Istio 也简化了操作，并且 Istio 项目继续发展和支持一组新的用例和功能，以推进未来各种工作负载，例如无 Sidecar 模式。随着 [Istio 项目加入 CNCF 的宣布](https:\/\/istio.io\/latest\/blog\/2022\/istio-accepted-into-cncf\/)，OSM 团队很高兴能够与 Istio 社区更加紧密地合作。这种合作将导致 OSM 项目在与 CNCF 的档案工作中向着 Istio 项目进行重点资源的集中。\n\n## 服务网格成熟度\n\n随着云原生采用的势头不断增强，用户需要服务网格提供的核心功能和可扩展性来支持他们的云原生微服务。增强功能，如 [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 和 [用于网格管理和管控的网关 API（GAMMA）](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/)，进一步凸显了服务网格在当今云原生栈中的关键重要性和成熟度。\n\n因此，服务网格正在发展以满足未来云原生工作负载的需求，这是 OSM 团队在项目路线图和技术决策方面的关注点。我们看到社区继续致力于为服务网格用户提供简化的操作体验是一个重要的投资领域，无论是在时间还是资源方面。随着社区在诸如 Gateway API 之类的功能上进行投资，例如通过 GAMMA 为标准的一组服务网格 API 和无 Sidecar 代理模式，我们认为这些是激发集体努力的领域。这些社区主导的举措为增强协作提供了坚实的基础，并创造了一个更可持续的服务网格生态系统。\n\n## 前进的道路\n\nOSM 维护人员很高兴与 Istio 社区以及 Gateway API 和 GAMMA 的项目合作，在 CNCF 提供的强大治理和协作生态系统下开展合作。Istio 项目继续发展以支持一组新的用例和功能，例如带[环境网格（Ambient Mesh）的宣布](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)的无 Sidecar 模式。\n\nOSM 团队一直致力于满足社区需求，提供亟需的服务网格功能，以解决当前问题并开发下一代服务网格技术。这个决定将使团队帮助加速实现这一目标。**此外，将不再发布 OSM 的新版本。**\n\n目前，与 Istio 的即刻兴趣和合作包括利用 Kubernetes 的 ClusterTrustBundles 功能增强 Istio 的网格证书管理体验（[RFC：ClusterTrustBundle 与 Istio 的集成](https:\/\/docs.google.com\/document\/d\/1eVKo57JVQ8QGjqRkMYGHDraS_vANJf3tTUWqqbvcylQ\/edit)），提出“安全模式”功能方法，为 Istio 提供一种简化的方式，以对最稳定的 API 进行任务关键型企业环境的防护（[提案：Istio 安全模式](https:\/\/docs.google.com\/document\/d\/1aaORW2Ak4Vfpr-N68Q04qS7iskDdF3v7lcZFQsFA_L0\/edit)），改进 Istio 的遥测体验，并与 Istio 新宣布的无 Sidecar 环境网格模式进行合作。鉴于有许多共享目标，OSM 团队认为这是一种有效和高效的协作方式，可以推动社区向前发展。我们很高兴宣布这一努力，并期待更多贡献者和维护者加入塑造下一代服务网格的发展。如果您尚未加入 Istio 的 CNCF Slack 频道，请考虑加入，成为当前和未来讨论 Istio 的一部分。\n', '\/trans\/osm-deprecated\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">开放服务网格（OSM）宣布停止更新，将与 Istio 社区更加紧密地合作，以加速实现下一代服务网格技术的发展。服务网格社区的发展，如 Kubernetes Gateway API 和 GAMMA，进一步凸显了服务网格在当今云原生栈中的关键重要性和成熟度。OSM 团队将与 Istio 社区合作，包括利用 Kubernetes 的 ClusterTrustBundles 功能增强 Istio 的网格证书管理体验，提出“安全模式”功能方法，改进 Istio 的遥测体验，并与 Istio 新宣布的无 Sidecar 环境网格模式进行合作。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-the-tls-encryption-in-istio/">如何理解 Istio 中的 mTLS 流量加密？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 mTLS 流量加密？', '本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。', '\nIstio 服务网格可以帮助云原生应用实现自动 mTLS，完成网格内的流量加密，有助于缩小云原生部署的攻击面，是构建零信任应用网络的关键框架。为了理解 Istio 中的 mTLS 流量加密，本文将包括以下内容：\n\n- 介绍什么是 TLS、mTLS 和 TLS 终止\n- 介绍 Istio 中如何实现 TLS 加密\n- 如何使用 Istio 为 Kubernetes 中的服务实现 mTLS？\n- 何时需要 mTLS？何时不需要 mTLS？\n\n## 什么是 TLS 和 mTLS？{#what-is-tls-and-mtls}\n\nTLS（Transport Layer Security，传输层安全性）是一种广泛采用的安全协议，用于在联网计算机之间建立经过身份验证和加密的链接，旨在促进互联网通信的私密性和数据安全性。TLS 作为 [SSL](https:\/\/www.ssl.com\/faqs\/faq-what-is-ssl\/)（Secure Socket Layer，安全套接字层）的继任者，实际上是由 SSL 改名而来，因此人们经常将 TLS\/SSL 混用，在本文中我们将统称为 TLS。TLS 1.0 发布于 1999 年，最新版本为 1.3（发布于 2018 年 8 月），1.0 和 1.1 版本已弃用。\n\n我们在浏览网页时看到的 HTTPS 实际上就使用了 TLS，如下图所示。TLS 是建立在 TCP 之上的，作为 OSI 模型中的会话层。为了保证兼容性，TLS 通常使用 443 端口，但是你也可以使用任意端口。\n\n![HTTP vs HTTPS](http-vs-https.svg)\n\n当客户端需要验证服务端身份，以防中间人攻击同时保证通信安全的情况下，在和服务端通信时会要求 TLS 加密。下图展示了的是 TLS 加密通信的流程。\n\n![TLS 加密通信流程](tls-flow.svg)\n\n1. 服务器向受信任的 CA（证书管理机构）申请并获得证书（X.509 证书）；\n2. 客户端向服务端发起请求，其中包含客户端支持的 TLS 版本和密码组合等信息；\n3. 服务器回应客户端请求并附上数字证书；\n4. 客户端验证证书的状态、有效期和数字签名等信息，确认服务器的身份；\n5. 客户端和服务器使用共享秘钥实现加密通信；\n\n以上仅是对 TLS 通信流程的一个概要描述，实际的 TLS 握手过程比较复杂，请参考[这篇文档](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)。\n\n从以上过程中你会发现，证书是代表服务器身份的关键要素，对于互联网公开服务，服务器需要使用权威认证的 CA 颁发的证书，而对于私有环境内部的服务，可以使用 PKI（Private Key Infrastructure，私钥基础设施）来管理证书。\n\n双向 TLS 或相互 TLS（Mutual TLS 或 mTLS）是指在服务端和客户端之间使用双向加密通道，需要双方相互提供证书并验证对方身份。关于如何在 Kubernetes 中使用 mTLS 请参考[这篇文章](https:\/\/cloudnative.to\/blog\/mtls-guide\/)。关于 mTLS 的详细介绍请见[这篇文章](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)。\n\n## 什么是 TLS 终止？{#what-is-tls-termination}\n\nTLS 终止（TLS Termination）指的是在将 TLS 加密流量传递给 Web 服务器之前对其进行解密的过程。将 TLS 流量卸载到入口网关或专用设备上，可以提高 Web 应用的性能，同时确保加密流量的安全性。一般运行在集群入口处，当流量到达入口处时实施 TLS 终止，入口与集群内服务器之间的通信将直接使用 HTTP 明文，这样可以提高服务性能。\n\n![TLS 终止](tls-termination.svg)\n\nIstio 默认在入口网关处终止 TLS，然后再为网格内的服务开启 mTLS。你也可以让流量直通（passthrough）到后端服务处理，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\n详见[网关 TLS  配置](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways)。\n\n## Istio 中如何实现自动 mTLS？{#istio-mtls}\n\n下图中展示的是 Istio 安全架构图，从图中可以看到在入口处使用 JWS \u002b TLS 认证和加密，在 Istio 网格内部的所有服务间都开启了 mTLS。\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio 中内置了 CA，使用 xDS 中的 SDS（Secret Discovery Service，秘密发现服务）实现 SVID 证书的签发和轮换。Istio 网格内的 mTLS 流程如下：\n\n1. Sidecar 代替工作负载向 Istiod 申请证书，Istiod 签发 [SVID](\/book\/kubernetes-handbook\/auth\/spiffe\/#svid) 证书（该过程比较复杂，我将在今后的博客中说明）；\n2. 客户端请求被 Pod 内的 sidecar 拦截；\n3. 客户端 sidecar 与服务端 sidecar 开始 mTLS 握手。在握手的同时，客户端 sidecar 中的 JWT 和认证过滤器将对请求的身份进行认证，认证通过后将身份存储在过滤器元数据中，然后请求经过授权过滤器，判断请求权限。\n4. 若请求通过了认证与授权，则客户端和服务端开始建立连接进行通信。\n\nIstio 中有三个资源对象可用于配置服务间的认证与授权：\n\n- \u0060RequestAuthentication\u0060：用于定义服务支持的请求级认证方式，目前只支持  JWT（[查看 JWT 组件详解](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)）；\n- \u0060PeerAuthentication\u0060：配置服务间的传输认证模式，如 \u0060STRICT\u0060、\u0060PERMISSIVE\u0060 或 \u0060DISABLE\u0060 等，以开启 mTLS 或明文请求；\n- \u0060AuthorizationPolicy\u0060：用于授权服务间的流量，定义谁可以做什么？例如主体 A 允许（\u0060ALLOW\u0060）或拒绝（\u0060DENY\u0060）来自主体 B 的流量；\n\n## 如何使用 Istio 为服务开启自动 mTLS？ {#how-to-setup-mtls}\n\n你可以在 \u0060PeerAuthentication\u0060 中指定对目标工作负载实施的 mTLS 模式。对等认证支持以下模式：\n\n- \u0060PERMISSIVE\u0060：默认值，工作负载可接受双向 TLS 或纯文本流量；\n- \u0060STRICT\u0060：工作负载仅接受 mTLS 流量；\n- \u0060DISABLE\u0060：禁用 mTLS。从安全角度来看，除非你有自己的安全解决方案，否则不应禁用 mTLS；\n- \u0060UNSET\u0060：从父级继承，优先级为服务特定 \u003e 命名空间范围 \u003e 网格范围的设置；\n\nIstio 的对等认证默认使用 \u0060PERMISSIVE\u0060 模式，自动将 mTLS 流量发送到这些工作负载，将纯文本流量发送到没有 sidecar 的工作负载。在将 Kubernetes 服务纳入 Istio 网格后，为了防止服务无法通过 mTLS，我们可以先使用 \u0060PERMISSIVE\u0060 模式。当我想为某些服务开启严格的 mTLS 模式时，可以使用以下两种方式之一：\n\n- 使用 \u0060PeerAuthentication\u0060 定义流量如何在 sidecar 之间传输；\n- 使用 \u0060DestinationRule\u0060 定义流量路由策略中的 TLS 设置；\n\n下面以为 \u0060default\u0060 命名空间下的 \u0060reviews\u0060 服务设置 mTLS 为例说明。\n\n### 使用 PeerAuthentication 为工作负载设置 mTLS {#peerauthentication-tls-setting}\n\n你可以使用 \u0060namespace\u0060 和 \u0060selector\u0060 指定某个命名空间下的某个工作负载开启严格的 mTLS。例如下面的配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\n你也可以给安装 Istio  的命名空间 \u0060istio-system\u0060 设置严格的 mTLS，那样会为网格中的所有服务开启严格的 mTLS，详细步骤请参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/authentication\/mtls-migration\/)。\n\n### 使用 DestinationRule 为工作负载设置 mTLS {#destinationrule-tls-setting}\n\nDestinationRule 用于设置流量路由策略，例如负载均衡、异常点检测、TLS 设置等。其中 TLS 设置中包含[多种模式](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ClientTLSSettings-TLSmode)，使用 \u0060ISTIO_MUTUAL\u0060 模式可以为工作负载开启 Istio 的自动 TLS，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## 什么时候用 mTLS？{#when-use-mtls}\n\n互联网客户端对 Web 服务的访问，一般使用单向 TLS，即只需要服务端提供身份证明，而不关心客户端的身份。当你需要验证客户端身份时，使用单向 TLS 可以使用密码、token、双因子认证等方式。不过这样的认证方式需要应用程序内部支持，而双向 TLS 是运行在应用程序之外的，不需要多应用逻辑进行修改。\n\n当你需要正如你在上文中看到的，实施 mTLS 的服务间需要交换证书，当服务数量变大时，就需要管理大量的证书，这需要消耗大量的精力，使用服务网格可以帮助你实现自动 mTLS，彻底解决证书管理的难题。\n\n## 什么时候不用 mTLS？{#when-not-use-mtls}\n\n虽然 mTLS 是确保云原生应用程序服务间通信安全的首选协议，但是应用 mTLS 需要完成复杂的对称加密、解密过程，这将非常耗时且消耗大量的 CPU 资源。对于某些安全级别不高的流量，如果我们在流量入口处终止 TLS，并网格内部仅对针对性的服务开启 mTLS，就可以加快请求响应和减少计算资源消耗。\n\n另外当有的服务无法获取证书，例如 Kubelet 上使用 HTTP 的健康检查，无法通过 TLS 访问服务内的健康检查端点，这时候就需要[为 Pod 禁用探针重写](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod)。\n\n最后当网格中的服务访问一些外部服务时，也不需要 mTLS。\n\n## 总结 {#summary}\n\nmTLS 实现了网格内流量的加密，是构建零信任应用网络的关键一步。借助 Istio 我们可以很方便的为 Kubernetes 中的服务开启自动 mTLS，省去管理证书的麻烦。同时，我们也可以针对性的为网格内的部分服务开启 mTLS，便于我们将 Kubernetes 中的服务迁移到网格内。关于 Istio 中的证书管理，我们将在今后的博客中再做说明。\n\n## 参考 {#reference}\n\n- [什么是 TLS（传输层安全性）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/ssl\/transport-layer-security-tls\/)\n- [什么是相互 TLS（mTLS）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)\n- [What happens in a TLS handshake? | SSL handshake - cloudflare.com](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n- [写给 Kubernetes 工程师的 mTLS 指南 - jimmysong.io](https:\/\/cloudnative.to\/blog\/mtls-guide\/)\n- [云原生安全白皮书中文版 - github.com](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/security-whitepaper\/v1\/cloud-native-security-whitepaper-simplified-chinese.md)\n- [Istio 安全 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/)\n- [JWT 组件详解 - jimmysong.io](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)\n', '\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Gateway API：Kubernetes 和服务网格入口中网关的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Gateway API：Kubernetes 和服务网格入口中网关的未来', '本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。', '\n本文将以 Kubernetes Ingress、Istio 和 Envoy Gateway 为例，向你介绍 Kubernetes 中的入口网关和 Gateway API，同时介绍 Gateway API 使得 Kubernetes 和服务网格入口网关融合的新趋势。\n\n## 本文观点\n\n- Ingress 作为 Kubernetes 的初代入口网关，它的资源模型过于简单以致于无法适应当今的可编程网络；\n- Gateway API 作为 Kubernetes 入口网关的最新成果，它通过角色划分将关注点分离，并提供跨 namespace 支持使其更适应多云环境，已获得大多数 API 网关的支持；\n- 入口网关（南北向）与服务网格（东西向，集群内路由）存在部分功能重叠，Gateway API 为两者的融合提供了新的参考模型；\n\n## Kubernetes 入口网关的历史\n\n2014 年 6 月 Kubernetes 开源，起初只能使用 NodePort 和 LoadBalancer 类型的 Service 对象来暴露集群内服务，后来才诞生了 [Ingress](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/ingress\/)，两年后（Kubernetes 1.2）Ingress API 进入 Beta 版本，随后为了保持其轻量和可移植的特性，Ingress API 相较于 Kubernetes 其他 API 发展得比较缓慢，直到 Kubernetes 1.19 它才升级到 GA。\n\nIngress 的主要目标是用简单的、声明性的语法来暴露 HTTP 应用。你可以在 Kubernetes 中部署多种 Ingress Controller，并在创建 Ingress 的时候通过 IngressClass 指定该网关使用的控制器，或者在 Kubernetes 中设置默认的默认的 IngressClass。Kubernetes 默认只支持 AWS、GCE 和 Nginx Ingress Controller，同时还支持大量的[第三方 Ingress Controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/#additional-controllers)。\n\n下图展示了 Kubernetes Ingress 的工作流程。\n\n![Kubernetes Ingress 工作流程](ingress-flow.svg)\n\n详细流程如下：\n\n1. Kubernetes 集群管理员在 Kubernetes 中部署 Ingress Controller；\n2. Ingress Controller 会持续监视 Kubernetes  API Server 中的 IngressClass 和 Ingress 对象的变动；\n3. 管理员应用 IngressClass 和 Ingress 来部署网关；\n4. Ingress Controller 会根据管理员的配置来创建对应的入口网关并配置路由规则；\n5. 如果在云中，客户端会访问该入口网关的负载均衡器；\n6. 网关将根据 HTTP 请求中的 host 和 path 将流量路由到对应的后端服务；\n\nIstio 同时支持 Ingress 和 Gateway API，下面是一个使用 Istio 入口网关的配置示例，在后文中会使用 Gateway API 创建该配置。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: IngressClass\nmetadata:\n  name: istio\nspec:\n  controller: istio.io\/ingress-controller\n---\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: ingress\nspec:\n  ingressClassName: istio\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port: 8000\n\u0060\u0060\u0060\n\n注意：Ingress 的 spec 中必须在 \u0060ingressClassName\u0060 字段中指定使用的 \u0060IngressClass\u0060，否则将无法创建对应的入口网关。\n\n## Kubernetes Ingress 的局限性\n\n虽然 \u0060IngressClass\u0060 实现了入口网关与后台实现的解耦，但是它仍然有着巨大的局限性：\n\n- Ingress 的配置过于简单，仅支持 HTTP 协议路由；\n- HTTP 路由仅支持 host 和 path 匹配，对于高级路由功能没有通用配置，只能通过 annotation 来实现，比如[使用 Nginx Ingress Controller 实现 URL 重定向](https:\/\/help.aliyun.com\/document_detail\/86533.html#section-xsg-g5g-1uy)，需要配置 \u0060nginx.ingress.kubernetes.io\/rewrite-target\u0060 annotation，已经无法适应可编程路由的需求；\n- 不同命名空间中的服务要绑定到同一个网关中的情况在实际情况下经常出现，而入口网关无法在多个命名空间中共享；\n- 入口网关的创建和管理的职责没有划分界限，导致开发者不仅要配置网关路由，还需要自己创建和管理网关；\n\n## Kubernetes Gateway API\n\nGateway API 是一个 API 资源的集合 —— \u0060GatewayClass\u0060、\u0060Gateway\u0060、\u0060HTTPRoute\u0060、\u0060TCPRoute\u0060、\u0060ReferenceGrant\u0060 等。Gateway API 暴露了一个更通用的代理 API，可以用于更多的协议，而不仅仅是 HTTP，并为更多的基础设施组件建模，为集群运营提供更好的部署和管理选项。\n\n另外 Gateway API 通过将资源对象分离，实现配置上的解耦，可以由不同的角色的人员来管理，其中的 API 对象如下图所示。\n\n![Gateway API 及角色](gateway-api-roles.svg)\n\n下面是在 Istio 中使用 Gateway API 的示例。\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: default\n    hostname: \u0022*.example.com\u0022\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: http\n  namespace: default\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\u0022httpbin.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/\n    backendRefs:\n    - name: httpbin\n      port: 8000\n\u0060\u0060\u0060\n\n与 Ingress 类似，Gateway 使用 \u0060gatewayClassName\u0060 声明其使用的控制器，该控制器需要平台管理员创建，并允许客户端对 \u0060*.example.com\u0060 域名的请求。应用开发者可以在其服务所在的命名空间中，在此示例中是 \u0060default\u0060 创建路由规则，并通过 \u0060parentRefs\u0060 绑定到 Gateway 上，当然这必须是在 Gateway 明确允许其绑定的情况下（通过 \u0060allowRoutes\u0060 字段中的规则设置）。\n\n当你应用上面的配置后，Istio 会自动为你创建一个负载均衡网关，下图展示了 Gateway API 的工作流程。\n\n![Gateway API 工作流程](gateway-api-flow.svg)\n\n详细流程如下：\n\n1. 基础设施供应商提供了 \u0060GatewayClass\u0060 和 Gateway 控制器；\n2. 平台运维部署 Gateway（可以部署多个，或使用不同的 \u0060GatewayClass\u0060）；\n3. Gateway Controller 会持续监视 Kubernetes  API Server 中的 \u0060GatewayClass\u0060 和 \u0060Gateway\u0060 对象的变动；\n4. Gateway Controller 会根据集群运维的配置来创建对应的网关；\n5. 应用开发者应用 xRoute 并绑定服务上；\n6. 如果在云中，客户端会访问该入口网关的负载均衡器；\n7. 网关将根据流量请求中的匹配条件将路由到对应的后端服务；\n\n从以上步骤中我们可以看出 Gateway API 相比 Ingress 有了明确的角色划分，而且路由规则可以与网关配置解耦，这大大增加了管理的灵活性。\n\n下图展示了流量接入网关后经过处理的流程。\n\n![网关处理流程图](traffic-flow.svg)\n\n从图中我们可以看出路由是与网关绑定的，路由一般与其后端服务部署在同一个命名空间中，如果在不同的命名空间中时，需要在 [\u0060ReferenceGrant\u0060](https:\/\/gateway-api.sigs.k8s.io\/api-types\/referencegrant\/) 中明确赋予该路由跨命名空间的引用权限，例如下面的 \u0060foo\u0060 命名空间中的 HTTPRoute \u0060foo\u0060 可以引用 \u0060bar\u0060 命名空间中的 \u0060bar\u0060 服务。\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\nmetadata:\n  name: foo\n  namespace: foo\nspec:\n  rules:\n  - matches:\n    - path: \/bar\n    forwardTo:\n      backend:\n      - name: bar\n        namespace: bar\n---\nkind: ReferenceGrant\nmetadata:\n  name: bar\n  namespace: bar\nspec:\n  from:\n  - group: networking.gateway.k8s.io\n    kind: HTTPRoute\n    namespace: foo\n  to:\n  - group: \u0022\u0022\n    kind: Service\n\u0060\u0060\u0060\n\n目前，Gateway API 仅支持 \u0060HTTPRoute\u0060，\u0060TCPRoute\u0060、\u0060UDPRoute\u0060、\u0060TLSRoute\u0060 和 \u0060GRCPRoute\u0060 还在实验阶段。Gateway API 已经得到了大量的网关和服务网格项目的支持，请[在 Gateway 官方文档中查看支持状况](https:\/\/gateway-api.sigs.k8s.io\/implementations\/)。\n\n## 入口网关与服务网格\n\n服务网格主要关注的是东西向流量，即 Kubernetes 集群内部的流量，但是大部分服务网格同样提供了入口网关功能，例如 Istio。但是 Istio 的功能和 API 过于复杂，在本文中我们就以 SMI 为例来说明入口网关和服务网格的关系。\n\n[SMI](https:\/\/smi-spec.io\/)（Service Mesh Interface）是 CNCF 的孵化项目，开源与 2019 年，它定义了独立于供应商的在 Kubernetes 中运行的服务网格通用标准。\n\n下图说明 Gateway API 与服务网格 API 的重叠点。\n\n![Gateway API 与 SMI 有部分重合](gateway-smi-overlay.svg)\n\n从图中我们可以看到 Gateway API 与 SMI 在流量规范部分有明显的重叠。这些重叠导致同样的功能，需要在 Gateway API 和服务网格中重复实现。\n\n### Istio 服务网格\n\n当然，并不是所有的服务网格是完全符合 SMI 标准，Istio 是目前最流行的服务网格实现，它提供了丰富的流量管理功能，但是没有对这些功能制定单独的策略 API，而是耦合在 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 中，如下所示。\n\n**VirtualService**\n\n- 路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；\n- 错误注入：HTTP 错误代码注入、HTTP 延时注入；\n- 流量切分：基于百分比的流量切分路由；\n- 流量镜像：将一定百分比的流量镜像发送到其他集群；\n- 超时：设置超时时间，超过设置的时间请求将失败；\n- 重试：设置重试策略，如触发条件、重试次数、间隔时间等；\n\n**DestinationRule**\n\n- 负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；\n- 熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；\n\n\u0060VirtualService\u0060 主要处理路由相关功能，而 \u0060DestinationRule\u0060 负责集群节点的开合和负载均衡。\n\n### Gateway API 融合 Kubernetes 和服务网格的入口网关\n\n正如上文所述，Gateway API 与服务网格之间有部分功能交集，为了减少重复开发，促成对 Gateway API 与服务网格之间共同关注点的建模，Gateway API 工作组提出了 [GAMMA](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/)（Gateway API Mesh Management and Administration）倡议。\n\n在该倡议的倡导下，那些在不同网关实现中的细节各不相同的高级流量管理功能，例如超时、重试、健康检查等，全部通过[策略附件](https:\/\/gateway-api.sigs.k8s.io\/references\/policy-attachment\/)（Policy Attachment）的方式将由各个提供商来实现。你可以通过通过 \u0060targetRef\u0060 字段指定策略附件所附加到的资源对象，例如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.acme.io\/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: foo\nspec:\n  override:\n    maxRetries: 10\n  default:\n    maxRetries: 5\n  targetRef:\n    group: gateway.networking.k8s.io\/v1alpha2\n    kind: HTTPRoute\n    name: foo\n\u0060\u0060\u0060\n\n在这里例子中重试策略被附加到了名为 \u0060foo\u0060 和 \u0060HTTPRoute\u0060 上。策略附件附加到不同的资源对象上，其生效的优先级也不同，例如 GatewayClass 是集群级的资源，如果策略附件覆盖在它上面的话，将优先生效。\n\n你可以给附加策略指定 \u0060override\u0060 和 \u0060default\u0060 值，其在入口和网格内不同资源上的层次结构的优先级是如下图所示。\n\n![Kubernetes 入口与网格中的覆盖和默认值的优先级](policy-attachment-priority.svg)\n\n目前，Gateway API 正在探索用来处理网格流量，并提出了一些[设计方案](https:\/\/docs.google.com\/document\/d\/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU\/edit#heading=h.6ks49gf06yii)。\n\n## Envoy Gateway\n\n2022 年 10 月 Envoy Gateway 首个开源版本 [v0.2 发布](\/blog\/envoy-gateway-release\/)，这是一个基于 Envoy 代理的遵循 Gateway API 而创建的网关，[Tetrate](https:\/\/tetrate.io) 是该项目的核心发起者之一。Envoy Gateway 的目标是降低用户采用 Envoy 作为 API 网关的障碍，以吸引更多用户采用 Envoy。它通过入口和 L4\/L7 流量路由，表达式、可扩展、面向角色的 API 设计，使其成为供应商建立 API 网关增值产品的基础。\n\n早在 Envoy Gateway 发布之前，Envoy 作为最流行了云原生代理之一，已被大规模采用，有多款 Gateway 软件基于 Envoy 构建，Istio 服务网格使用它作为默认的 sidecar 代理，并通过 xDS 协议来配置这些分布式代理。在 Envoy Gateway 中，它同样使用 xDS 来配置 Envoy 集群，下图展示了 Envoy Gateway 的架构。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n基础设施供应商会为你提供 \u0060GatewayGlass\u0060，你可以通过创建一个 Gateway 声明来创建一个 Envoy Gateway，你在 Gateway 中的路由和策略附件会通过 xDS 协议发送给 Envoy 集群。\n\n关于 Envoy Gateway 的进一步介绍，请阅读：\n\n- [使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API](https:\/\/cloudnative.to\/blog\/hands-on-with-envoy-gateway\/)\n- [面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍](https:\/\/cloudnative.to\/blog\/envoy-gateway-to-the-future\/)\n\n## 总结\n\nGateway API 作为下一代 Kubernetes Ingress API，为 Kubernetes 网关供应商提供一定程度上的 API 规范，在保证其可移植性的前提下丰富了入口网关的功能，同时通过关注点分离方便不同角色的人员对网关进行管理。最后 GAMMA 倡议正在促进服务网格的入口网关与 Gateway API 的融合，策略附件可能将 Gateway API 的功能进一步扩展到东西向网关，我们拭目以待。\n\n## 参考\n\n- [Gateway API - jimmysong.io](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)\n- [一文搞懂 Kubernetes Gateway API 的 Policy Attachment - atbug.com](https:\/\/atbug.com\/explore-k8s-gateway-api-policy-attachment\/)\n- [SMI 与 Gateway API 的 GAMMA 倡议意味着什么？- atbug.com](https:\/\/atbug.com\/why-smi-collaborating-in-gateway-api-gamma\/)\n- [Evolving the Kubernetes Ingress APIs to GA and Beyond - Christopher M Luciano, IBM \u0026 Bowei Du, Google](https:\/\/kccncna19.sched.com\/#)\n', '\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/service-mesh/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/service-mesh/page/4/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(70)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(39)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-game-life/">从黑神话悟空聊起：我心目中的 3A 大作</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
