<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/service-mesh/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-servicemesh-api-gateway/">如何理解 Istio Ingress，它与 API Gateway 有什么区别？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio Ingress，它与 API Gateway 有什么区别？', '服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。', '\nAPI 网关作为客户端访问后端的入口，已经存在很长时间了，它主要是用来管理”南北向“的流量；近几年服务网格开始流行，它主要是管理系统内部，即“东西向”流量，而像 Istio 这样的服务网格还内置了网关，从而将系统内外部的流量纳入了统一管控。这经常给初次接触 Istio 的人带来困惑——服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。\n\n## 主要观点\n\n- 服务网格诞生的初衷是为了解决分布式应用的内部流量的管理问题，而在此之前 API 网关已存在很久了。\n- 虽然 Istio 中内置了 Gateway，但是你仍可以使用自定义的 Ingress Controller 来代理外部流量。\n- API 网关和服务网格正朝着融合的方向发展。\n\n## 如何暴露 Istio mesh 中的服务？\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![暴露 Kubernetes 中服务的几种方式](access-cluster.svg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n| 方式                  | 控制器             | 功能                                                         |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n由于 NodePort\/LoadBalancer 是 Kubernetes 内置的基本的暴露服务的方式，本文就不讨论这种方式了。下文将对其他三种方式分别作出说明。\n\n## 使用 Kubernetes Ingress 暴露服务\n\n我们都知道 Kubernetes 集群的客户端是无法直接访问 Pod 的 IP 地址的，因为 Pod 是处于 Kubernetes 内置的一个网络平面中。我们可以将 Kubernetes 内的服务使用 NodePort 或者 LoadBlancer 的方式暴露到集群以外。同时为了支持虚拟主机、隐藏和节省 IP 地址，可以使用 [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来暴露 Kubernetes 中的服务。Kubernetes Ingress 原理如下图所示。\n\n![使用 Kubernetes Ingress 暴露服务](ingress.svg)\n\n简单的说，Ingress 就是从 Kubernetes 集群外访问集群的入口，将用户的 URL 请求转发到不同的服务上。Ingress 相当于 Nginx、Apache 等负载均衡方向代理服务器，其中还包括规则定义，即 URL 的路由信息，路由信息得的刷新由 [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers)来提供。\n\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\n上面的例子中的 \u0060kubernetes.io\/ingress.class: istio\u0060 注解表明该 Ingress 使用的 Istio Ingress Controller。 \n\n## 使用 Istio Gateway 暴露服务\n\n我们都知道 Istio 是继承 Kubernetes 之后发展出来的一个流行的服务网格实现，它实现了 Kubernetes 没有的一些功能，请参考[什么是 Istio？为什么 Kubernetes 需要 Istio？](https:\/\/jimmysong.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)简要来说，正是因为 Istio 补足了 Kubernetes 对于云原生应用的流量管理、可观测性和安全方面的短板，使得流量管理变得对应用程序透明，使这部分功能从应用程序中转移到了平台层，成为了云原生基础设施。\n\nIstio 0.8 以前版本中使用 Kubernetes [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来作为流量入口，其中使用 Envoy 作为 Ingress Controller。在 Istio 0.8 及以后的版本中，Istio 创建了 Gateway 对象。Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 sidecar 相同的 Envoy 代理。通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、遥测收集以及其他服务管控功能。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。\n\nIstio Gateway 资源本身只能配置 L4 到 L6 的功能，例如暴露的端口、TLS 设置等；但 Gateway 可与 VirtualService 绑定，在 VirtualService 中可以配置七层路由规则，例如按比例和版本的流量路由，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。\n\n下面是一个 Gateway 与 VirtualService 绑定的示例。拥有 \u0060istio: ingressgateway\u0060 标签的 pod 将作为 Ingress Gateway 并路由对 \u0060httpbin.example.com\u0060 虚拟主机的 80 端口的 HTTP 访问，这相当于给 Kubernetes 敞开了一个外部访问的入口。这与使用 Kubernetes Ingress 最大的区别就是，需要我们手动将 VirtualService 与 Gateway 绑定，并指定 Gateway 所在的 pod。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\n下面这个 VirtualService 通过 \u0060gateways\u0060 与上面的网关绑定在了一起，以接受来自该网关的流量。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## 使用 API 网关暴露服务\n\nAPI 网关是位于客户端和后端服务之间的 API 管理工具，一种将客户端接口与后端实现分离的方式，在微服务中得到了广泛的应用。当客户端发出请求时，API 网关会将其分解为多个请求，然后将它们路由到正确的位置，生成响应，并跟踪所有内容。\n\nAPI Gateway 是微服务架构体系中的一类型特殊服务，它是所有微服务的入口，它的职责是执行路由请求、协议转换、聚合数据、认证、限流、熔断等。大多数企业 API 都是通过 API 网关部署的。API 网关通常会处理跨 API 服务系统的常见任务，例如用户身份验证、速率限制和统计信息。\n\n在网格中可以有一个或多个 API Gateway。API 网关的职责有：\n\n- 请求路由和版本控制\n- 方便单体应用到微服务的过渡\n- 权限认证\n- 数据聚合：监控和计费\n- 协议转换\n- 消息和缓存\n- 安全和报警\n\n以上很多基本功能比如路由和权限认证通过 Istio Gateway 也可以实现，只是在功能的丰富度和扩展性方面有些成熟的 API Gateway 可能更占优势，不过在 Istio mesh 中再引入 API Gateway 也可能带来一些弊端。\n\n- 引入了 API Gateway，需要考虑 API Gateway 本身的部署、运维、负载均衡等场景，增加了后端服务的复杂度\n- API Gateway 中承载了大量的接口适配，导致难以维护\n- 对于部分场景，增加了一跳可能导致性能的降低\n\n## 总结\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 生命周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 [Nginx Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)，Traefik 构建了 [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 [Kuma](https:\/\/kuma.io)。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n## 参考\n\n- [利用 Gateway API 发展 Kubernetes 网络](https:\/\/cloudnative.to\/blog\/evolving-kubernetes-networking-with-the-gateway-api\/)\n- [如何为服务网格选择入口网关？](https:\/\/cloudnative.to\/blog\/how-to-pick-gateway-for-service-mesh\/)\n- [Service Mesh 和 API Gateway 关系深度探讨](https:\/\/cloudnative.to\/blog\/service-mesh-and-api-gateway\/)\n- [在 Istio 服务网格中使用 Traefik Ingress Controller](https:\/\/cloudnative.to\/blog\/using-traefik-ingress-controller-with-istio-service-mesh\/)\n', '\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/top-service-mesh-pk/">[译] 服务网格联网：使用案例、最佳实践和顶级服务网格选择比较</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://cncf.io/blog/2021/07/15/networking-with-a-service-mesh-use-cases-best-practices-and-comparison-of-top-mesh-options" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格联网：使用案例、最佳实践和顶级服务网格选择比较', '服务网格大 PK。', '\n服务网格技术是随着微服务结构的普及而出现的。由于服务网格促进了网络与业务逻辑的分离，它使你能够专注于你的应用程序的核心竞争力。\n\n微服务应用程序分布在多个服务器、数据中心或大陆上，使它们高度依赖网络。服务网格通过用路由规则和服务间包的动态方向控制流量来管理服务间的网络流量。\n\n在这篇文章中，我们将研究使用案例，比较顶级网格选项，并讨论最佳做法。\n\n让我们从使用服务网格的最常见场景开始。\n\n## 使用案例\n\n服务网格是一种连接微服务和管理它们之间流量的架构方法。它们在一个组织的许多层面上被大量用于生产。因此，有一些标准化的、被广泛接受的用例。\n\n### 可观测性\n\n假设你有一个后端服务的实例响应缓慢，在你的整个堆栈中造成了一个瓶颈。然后，来自前端服务的请求将超时，并重新尝试连接到缓慢的服务实例。在服务网格的帮助下，你可以使用一个断路器，确保前端实例只与健康的后端实例连接。因此，使用服务网格可以提高堆栈的可见性，并帮助你排除问题。\n\n### 部署策略\n\n部署策略（蓝\/绿部署、金丝雀等）正在成为发布云原生应用升级的规范。服务网格允许部署策略，因为大多数部署策略都是基于将流量转移到特定实例。例如，你可以在服务网格中创建流量规则，以便只有一小部分用户（比如 10%）会接触到新版本。\n\n如果一切按预期进行，你可以将所有流量转移到最新版本，完成你的金丝雀部署。也建议检查[Kubernetes 的内部部署策略](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/controllers\/deployment\/#strategy)，并与你的应用程序的要求相匹配。\n\n### 测试 \n\n为了保持你的生产堆栈的安全性，最好通过测试延迟、超时和灾难恢复来加固它们。\n\n服务网格允许你通过延迟和不正确的响应在系统中制造混乱来测试其稳健性。例如，通过在服务网格流量规则中注入延迟，你可以测试当你的数据库对其查询响应缓慢时，前端和后端将如何表现。\n\n### API 网关\n\nAPI 网关是 server-client 的设计模式，它使得从一个单一的入口点管理 API 成为可能。在服务网格的帮助下，你可以使用同样的方法进行服务间的通信，并在你的集群中创建复杂的 API 管理方案。建议你查看[Gateway API](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/)，以便在即将到来的 Kubernetes 版本中把这些想法纳入本地 Kubernetes 资源。\n\n服务网格作为 \u0022智能 \u0022胶水，通过流量策略、限制和测试功能动态地连接微服务。随着服务网格的日益普及，许多新的、被广泛接受的用例将加入上述的用例。\n\n现在让我们来看看现有的顶级服务网格软件的优点和缺点。\n\n## 顶级网格选项的比较\n\n虽然每次会议上总有一些初创公司推出花哨的服务网格产品，但在云原生世界中，只有三个顶级网格选项被广泛使用。Istio、Linkerd 和 Consul Connect。它们都是拥有活跃社区的开源产品。基于他们的愿景和实施，他们也都有各自的优点和缺点。\n\n### Istio\n\n[Istio](https:\/\/istio.io)是一个 Kubernetes 原生的服务网格，最初由 Lyft 开发，并在业界被广泛采用。领先的云 Kubernetes 供应商，如谷歌、IBM 和微软，都将 Istio 作为其服务的默认服务网格。Istio 提供了一套强大的功能来创建服务之间的连接，包括请求路由、超时、断路和故障注入。此外，Istio 通过延迟、流量和错误等指标对应用程序进行深入了解。\n\n**优点**\n\n最活跃的社区，业界采用率高，与 Kubernetes 和虚拟机一起使用。\n\n**缺点**\n\n学习曲线陡峭，对集群有很大的开销，没有本地管理仪表板。\n\n### Linkerd\n\nLinkerd 是第二大流行的服务网格，是云原生计算基金会（CNCF）的一部分。\n\n从架构的角度来看，Linkerd 类似于 Istio，但有更多的灵活性。这种灵活性来自于可插拔架构的多个维度。例如，在连接方面，Linkerd 与最流行的入口控制器一起工作，如 Nginx、Traefik 或 Kong。同样，除了它自己的 GUI，它还与 Grafana、Prometheus 和 Jaeger 合作，以实现可观测性。 \n\n**优点**\n\n文档和简单的安装，在行业中得到采用，和企业支持。\n\n**缺点**\n\n只适用于 Kubernetes，不支持虚拟机缺少一些网络路由功能，如断路或速率限制。\n\n## Consul Connect\n\nConsul 是分布式应用中最流行的服务发现和键\/值存储，直到其母公司 HashiCorp 以 Consul Connect 的名义转换为服务网格。\n\n因此，Consul Connect 有一个混合架构，在应用程序旁边有 Envoy sidecar，其控制平面和键\/值存储是用 Go 开发的。从连接性和安全性的角度来看，Consul Connect 与它的替代品相比并没有提供突出的功能。然而，它的配置和复杂性较低，使得它更容易上手--就像云原生世界中的其他 HashiCorp 工具一样。\n\n**优点**\n有 HashiCorp 的支持和企业级支持的可用性，可以与虚拟机和 Kubernetes 一起工作。\n\n**缺点**\n\n开源社区有限，缺乏完整和易于理解的文档。\n\n下面的图表提供了这三大解决方案之间关键差异的概述。\n\n| 对比项                     | Istio                    | Linkerd    | Consul Connect           |\n| -------------------------- | ------------------------ | ---------- | ------------------------ |\n| 支持的平台                 | Kubernetes 和虚拟机      | Kubernetes | Kubernetes 和虚拟机      |\n| 支持的 Ingress 控制器      | Istio ingress            | 任意       | Envoy                    |\n| 流量管理功能               | 蓝绿部署、断路和速率控制 | 蓝绿部署   | 蓝绿部署、断路和速率控制 |\n| Prometheus 和 Grafana 支持 | 是                       | 是         | 否                       |\n| 混沌测试                   | 是                       | 是         | 否                       |\n| 管理复杂度                 | 高                       | 低         | 中                       |\n| 原生 GUI                   | 否                       | 是         | 是                       |\n\n## 最佳实践和挑战\n\n服务网格使你的集群和应用中的服务间通信标准化和自动化。然而，由于产品的复杂性和基础设施的不同，服务网格产品并不简单。在使用服务网格时，以下关于挑战和最佳实践的说明将为你提供一些有用的指导。\n\n### 自动化\n\n服务网格的配置包括流量规则、速率限制和网络设置。该配置可以帮助你从头开始安装，升级版本，以及在集群之间迁移。因此，建议把配置当作代码来处理，并遵循 GitOps 的方法和持续部署管道。\n\n服务网格产品在拥有大量服务器的少数集群中工作得更好，而不是拥有较少实例的许多集群。因此，建议尽可能地减少冗余集群，使你能够利用简单的操作和集中配置的服务网格方法。\n\n### 监控和请求跟踪\n\n服务网格产品是复杂的应用，管理着更复杂的分布式应用的流量。因此，指标收集、可视化和仪表板对系统的可观测性至关重要。利用 Prometheus 或 Grafana 或您的服务网格提供的任何其他集成点，根据您的要求创建警报。\n\n### 安全性\n\n大多数服务网格产品，包括前三名，都实现了一套基本的安全功能：mTLS、证书管理、认证和授权。你还可以定义和执行网络策略，以限制集群中运行的应用程序之间的通信。\n\n不过，应该注意的是，定义网络策略不是一项简单的任务。你需要覆盖当前运行的应用程序的所有场景，并考虑未来的可扩展性。因此，利用服务网格的网络策略对用户来说并不友好，容易出现错误和安全漏洞。\n\n然而，利用服务网格来创建安全的网络策略有几个缺点。\n\n首先，用户必须准确定义集群所需要的策略——在微服务激增和不断变化的环境中，这是一项不容易的任务。因此，服务网格的策略需要经常改变，如果一个微服务改变其行为，可能会破坏生产。  \n\n其次，根据设计，服务网格使用 sidecar 代理来控制策略，所以任何从容器中出来的连接都会被自动视为合法流量，如果攻击者闯入一个容器，他们会自动继承该容器的网络身份，从而可以做任何原始容器可以做的事情。\n\n最后，由于每个连接都要经过代理，用户在集群中使用它来加密流量时，会看到明显的性能下降。\n\n总结一下：服务网格解决方案并不关心谁在发送或接收数据。只要网络策略允许，任何恶意的或配置错误的应用程序都可以检索你的敏感数据。因此，考虑开销更少、可操作性更强的整体方法至关重要，而不是盲目地只相信服务网格产品的安全措施。\n\n## 总结\n\n服务网格以动态、安全和可扩展的方式连接分布式微服务。目前有广泛接受的用例和实现这些用例的顶级产品。然而，由于云基础设施和应用需求高度复杂，服务网格不是银弹。\n\n当涉及到安全问题时，保护应用程序和运行时环境不在服务网格产品的范围内，而且仅仅为了安全而安装一个服务网格是矫枉过正的，因为它在集群中产生了很高的开销。\n', '\/trans\/top-service-mesh-pk\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格大 PK。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/multicluster-management-with-kubernetes-and-istio/">服务网格之旅——使用 Kubernetes 和 Istio Service Mesh 构建混合云</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格之旅——使用 Kubernetes 和 Istio Service Mesh 构建混合云', '这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。', '\n这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。\n\n## Kubernetes\n\n使用 Kubernetes 可以快速部署一个分布式环境，实现了云的互操作性，统一了云上的控制平面。并提供了 Service、Ingress 和 [Gateway](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/) 等资源对象来处理应用程序的流量。如下图所示，Kubernetes 中默认使用 Service 做服务注册和发现，服务之间可以使用服务名称来访问。Kubernetes API Server 与集群内的每个节点上的 \u0060kube-proxy\u0060 组件通信，为节点创建 iptables 规则，并将请求转发到其他 pod 上。\n\n假定现在客户端要访问 Kubernetes 中的服务，首先请求会发送到 Ingress\/Gateway 上，然后根据 Ingress\/Gateway 里的路由配置转发到后端服务上（图中是服务 A），接着服务 A 对服务 B 请求的流量转发轮询到服务 B 的实例上。\n\n![Kubernetes](008i3skNly1gsgg6a11l1j31lu0u042s.jpg)\n\n## Kubernetes 多集群管理\n\n多集群管理最常见的使用场景包括服务流量负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复、灵活分配计算资源、跨区域服务的低延迟访问以及避免厂商锁定等。一个企业内部往往有多个 Kubernetes 集群，由 MultiCluster SIG 开发的 KubeFed 实现 Kubernetes 集群联邦可以实现多集群管理的功能，这使得所有 Kubernetes 集群都通过同一个接口来管理。\n\n在使用集群联邦时需要解决以下几个通用问题：\n\n- 配置需要联邦哪些集群\n- 需要在集群中传播的 API 资源\n- 配置 API 资源如何分配到不同的集群\n- 对集群中 DNS 记录注册以实现跨集群的服务发现\n\n下面是 KubeSphere 的多集群架构，也是最常用的一种 Kubernetes 多集群管理架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。\n\n![Multicluster](008i3skNly1gsgg7a2ojvj31aa0u0491.jpg)\n\nHost 集群需要能够访问 Member 集群的 API Server，Member 集群之间的网络连通性没有要求。管理集群 Host Cluster 独立于其所管理的成员集群，Member Cluster 并不知道 Host Cluster 存在，这样做的好处是当控制平面发生故障时不会影响到成员集群，已经部署的负载仍然可以正常运行，不会受到影响。\n\nHost 集群同时承担着 API 入口的作用，由 Host Cluster 将对 Member 集群的资源请求转发到 Member 集群，这样做的目的是方便聚合，而且也利于做统一的权限认证。我们看到在 Host Cluster 中有联邦控制平面，其中的 Push Reconciler 会将联邦集群中身份、角色及角色绑定传播到所有成员集群中。\n\n## Istio\n\n当我们在 Kubernetes 中运行着多语言、多版本的微服务，并需要更细粒度的金丝雀发布和统一的安全策略管理，实现服务间的可观测性时，可以考虑使用 Istio 服务网格。Istio 通过向应用程序 Pod 中注入 sidecar proxy，缺省使用 IPTables 透明得拦截进出应用程序的所有流量，从而实现了应用层到集群中其他启用服务网格的服务的智能应用感知负载均衡，并绕过了初级的 kube-proxy 负载均衡。Istio 控制平面与 Kubernetes API Server 通信可以获取集群中所有注册的服务信息。\n\n下图展示了 Istio 的基本原理，其中所有节点属于同一个 Kubernetes 集群。\n\n![Istio Service Mesh](008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg)\n\n你可能最终会有至少几个 Kubernetes 集群，每个集群都承载着微服务。Istio 的多集群部署根据网络隔离、主备情况存在多种[部署模式](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/)，可以使用 Istio Operator 部署时通过声明来指定。集群中的这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供通用的通信模式，以提高弹性、安全性和可观测性。\n\n以上都是关于 Kubernetes 上的应用负载管理，但是对于虚拟机上遗留应用，如何在同一个平面中管理？如何管理多集群中的流量划分、网关和安全性呢？\n\n## 管理平面\n\n在 Istio 之上再增加一层抽象，将网关、流量和安全分组管理，并将它们应用到不同的集群和命名空间上。下图展示的是 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 的多租户模型，利用 NGAC 来管理用户的访问权限，同时也有利于构建零信任网络。\n\n![Management Plane](008i3skNly1gsgg8ndcajj31il0u00z9.jpg)\n\nIstio 提供了工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好。在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。\n\n下图展示的是 Tetrate Service Bridge 的架构图。\n\n![Tetrate Service Bridge](008i3skNly1gsgg951mknj314g0u0dnf.jpg)\n\n## 总结\n\n使用 Kubernetes 实现了异构集群的互操作性，Istio 将容器化负载和虚拟机负载纳入到一个同一个控制平面内，统一管理集群内的流量、安全和可观测性。但是，随着集群数量、网络环境和用户权限的越发复杂，人们还需要在 Istio 的控制平面至上再构建一层管理平面来进行混合云管理。\n', '\/blog\/multicluster-management-with-kubernetes-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/">如何调试 Kubernetes 中的微服务 ——proxy、sidecar 还是 service mesh？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何调试 Kubernetes 中的微服务 ——proxy、sidecar 还是 service mesh？', '本文讲解了调试 Kubernetes 中微服务的三种模式\/工具，以及 Istio 的引入为微服务的调试带来的变革。', '\nKubernetes 可以说是目前为止用来运行微服务的最佳载体，但是在调试 Kubernetes 环境中的微服务时的体验可能就没那么友好了。本文将带你了解如何调试 Kubernetes 中的微服务，介绍常用的工具，以及 Istio 的引入为微服务的调试带来的变革。\n\n## 调试微服务与传统单体应用有巨大的不同\n\n微服务的调试是一直长期困扰软件开发人员的问题，这在传统的单体应用中不存在，因为开发者可以利用 IDE 中的调试器，为应用程序增加断点、修改环境变量，单步执行等，这些都为软件调试提供了巨大帮助。随着 Kubernetes 的流行，微服务的调试就成了一个棘手的问题，其中相比传统单体应用的调试多了以下问题：\n\n### 多依赖\n\n一个微服务往往依赖多个其他微服务，在调试某个微服务时，如何部署其他依赖服务以快速搭建一套最新的 stagging 环境？\n\n### 从本地机器访问\n\n微服务在开发者的本地电脑上运行时，通常无法直接访问到 Kubernetes 集群中的服务，如何像调试本地服务一样调试部署在 Kubernetes 集群中的微服务？\n\n### 开发效率低下\n\n通常情况下，代码从更新到构建成镜像再推送到集群中需要一个漫长的过程，如何加快开发速度？\n\n我们一起来看下哪些工具能够解决以上问题。\n\n## 工具\n\n调试 Kubernetes 中的微服务的主要解决方案有：\n\n- Proxy：在 Kubernetes 集群和本地调试终端中部署一个代理，通过构建一个 VPN，使得本地应用可以直接访问到 Kubernetes 中的服务；\n- Sidecar：替换原来应用容器的镜像为开发镜像，可以在这个容器中中对该服务进行调试，同时在要调试的微服务 pod 中注入一个 sidecar 作为辅助工具来同步代码；\n- 服务网格：要想了解应用的整体情况，就需要在所有微服务中注入 sidecar，这样你就可以获得一个监控全局状态的仪表板；\n\n下面是实现以上解决方案的三个典型的开源项目，它们分别从不同的角度可以帮助你调试微服务。\n\n### Proxy 模式：Telepresence\n\n[Telesprence](https:\/\/www.telepresence.io\/) 本质上是一个本地代理，该代理将 Kubernetes 集群中的数据卷、环境变量、网络都代理到了本地。下图展示的是 Teleprence 的主要使用场景。\n\n![Proxy 模式：Telepresence](telepresence.jpg)\n\n用户需要在本地自主地执行 \u0060telepresence\u0060 命令，它会自动将代理部署到 Kubernetes 中，有了该代理之后：\n\n- 本地的服务就可以完整的访问到 Kubernetes 集群中的其他服务、环境变量、Secret、ConfigMap 等；\n- 集群中的服务还能直接访问到本地暴露出来的端点；\n\n但是这种方式仍然不够连贯，还需要用户在本地调试时运行多次命令，而且在某些网络环境下可能无法与 Kubernetes 集群建立 VPN 连接。\n\n### Sidecar 模式：Nocalhost\n\n[Nocalhost](https:\/\/nocalhost.dev\/) 是一个基于 Kubernetes 的云端开发环境。要想使用它，你只需要在你的 IDE——VS Code 中安装一个插件即可扩展 Kubernetes，并缩短开发反馈周期。通过为不同的用户创建不同的 namespace，并使用 ServiceAccount 绑定到不同用户角身上时，就可以实现开发环境隔离。同时，Nocalhost 还提供了 Web 控制台和 API，方便管理员来管理不同的开发环境。\n\n![Sidecar 模式：Nocalhost](sidecar-nocalhost.jpg)\n\n#### 测试\n\n参考 Nocalhost 文档，我们在 macOS 上安装 Nocalhost，并使用 Minikube 来演示如何调试。\n\n执行下面的命令安装 Nocalhost 客户端并查看 \u0060nhctl\u0060 命令行工具的版本。\n\n\u0060\u0060\u0060bash\nbrew install nocalhost\/repo\/nocalhost\n\nnhctl version\n\u0060\u0060\u0060\n\n我们假设你机的 \u0060kubeconfig\u0060 文件位于 \u0060~\/.kube\/config\u0060（若不在此位置需要在下面的命令中使用 \u0060--kubeconfig\u0060 手动指定）并拥有 Kubernetes 集群的 admin 角色，执行下面的命令使用 Helm3 在 Kubernetes 上安装 Nocalhost 服务端。\n\n\u0060\u0060\u0060bash\nnhctl init demo -n nocalhost \n\u0060\u0060\u0060\n\n执行下面的命令启动 Minikube 隧道并查看 Nocalhost web 端地址。\n\n\u0060\u0060\u0060bash\nminikube tunnel\nkubectl get service nocalhost-web\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/\u003cEXTERNAL-IP\u003e\u0060 即可，用户名\/密码为：\u0060admin@admin.com\/123456\u0060。\n\n要想在 VS Code 中使用，你还想需要创建一个 ServiceAccount 并绑定 admin 角色，然后将该 ServiceAccount 作为 Kubeconfig 文件导出。\n\n\u0060\u0060\u0060bash\nkubectl create serviceaccount my-service-account\nkubectl create rolebinding admin --clusterrole=admin --serviceaccount=default:my-service-account\n\u0060\u0060\u0060\n\n只要你有一个 Kubernetes 集群，并有集群的 admin 权限，就可以参考 Nocalhost 的文档快速开始试用。在 VS Code 中使用 Nocalhost 插件时需要先为插件中配置 Kubernetes 集群。选择你刚导出的 Kubeconfig 文件或者直接复制文件中的内容粘贴到配置里。然后选择你需要测试的服务，并选择对应的 Dev Container，VS Code 会自动打开一个新的代码窗口。\n\n下面是以 Istio 官方提供的 [bookinfo 示例](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)为例，你可以在本地 IDE 中打开克隆下来的代码，然后点击代码文件旁边的锤子即可进入开发模式。选择对应的 DevContainer，nocalhost 会自动向 pod 中注入一个开发容器 sidecar，并在终端中自动进入该容器，如下图所示。\n\n![Nocalhost VS code 界面](nocalhost-vs-code.jpg)\n\n在开发模式中，本地修改代码，无需重新构建镜像，远端开发环境实时生效，这样可以极大的加快开发速度。同时，Nocalhost 还提供了服务端，可用于开发环境和用户权限进行管理，如下图所示。\n\n![Nocalhost web 端](nocalhost-web-admin.jpg)\n\n### Service Mesh 模式：Istio\n\n以上使用 proxy 和 sidecar 的方式，一次只能对一个服务进行调试，如果想要掌握服务的全局状况，比如获取的服务的指标，以及通过分布式追踪了解服务的依赖和调用流程，对服务的性能进行调试。这些[可观测性](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/observability\/)的功能，需要为所有服务统一注入 sidecar 来实现。\n\n而且，当你的服务正处于从虚拟机迁移到 Kubernetes 的过程中时，使用 Istio 可以将虚拟机与 Kubernetes 纳入一个网络平面中（如下图所示），方便开发者调试和做渐进式的迁移。\n\n![Service Mesh 模式：Istio](istio-service-mesh.jpg)\n\n当然要获得这些好处也不是一点“代价”也不没有的，引入 Istio 后，你的 Kubernetes  service 需要遵守 Istio 的[命名规范](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/requirements\/)，学习使用 [Istioctl](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/istioctl-analyze\/) 命令行和日志的方式来调试微服务。\n\n- 使用 \u0060istioctl analyze\u0060 命令来调试集群中的微服务部署情况，可以使用 YAML 文件来检查某个命名空间或整个集群中的资源部署情况。\n- 使用 \u0060istioctl proxy-config secret\u0060  来调试 service mesh 中的 pod 的 secret 被正确的加载并有效。\n\nIstio 的配置信息在大型的集群部署中传播将会耗时更长并且可能有几秒钟的延迟时间，sidecar 的引入会给服务间调用带来一定延迟。\n\n## 总结\n\n在应用微服务化和从虚拟机迁移到 Kubernetes 的过程中，开发者需要很多观念和习惯上的转变。通过 proxy 在本地跟 Kubernetes 间构建 VPN，可以方便开发者像调试本地服务一样调试 Kubernetes 中的服务。通过向 pod 中注入 sidecar，可以实现实时调试，加快开发进度。最后，Istio service mesh 真正实现了全局的可观测性，你还可以使用像 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 这样的工具来管理异构平台，帮助你渐渐地从单体应用过度到微服务。\n', '\/blog\/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲解了调试 Kubernetes 中微服务的三种模式/工具，以及 Istio 的引入为微服务的调试带来的变革。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-4-year-birthday/">Istio 开源四周年回顾与展望</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/05/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 开源四周年回顾与展望', '今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。', '\nIstio 是由 [Tetrate](https:\/\/tetrate.io\/) 创始人 Varun Talwar 和谷歌首席工程师 Louis Ryan 命名并在 2017 年 5 月 24 日开源。今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。\n\n## Istio 的开源历史\n\n2017 年是 Kubernetes 结束容器编排之战的一年，Google 为了巩固在云原生领域的优势，并弥补 Kubernetes 在服务间流量管理方面的劣势，趁势开源了 Istio。下面是截止目前 Istio 历史上最重要的几次版本发布。\n\n| **日期**   | 版本 | 说明                                                         |\n| ---------- | ---- | ------------------------------------------------------------ |\n| 2017-05-24 | 0.1  | 正式开源，该版本发布时仅一个命令行工具。确立了功能范围和 sidecar 部署模式，确立的 Envoy 作为默认 sidecar proxy 的地位。 |\n| 2017-10-10 | 0.2  | 支持多运行时环境，如虚拟机。                                 |\n| 2018-06-01 | 0.8  | API 重构。                                                   |\n| 2018-07-31 | 1.0  | 生产就绪，此后 Istio 团队被大规模重组。                      |\n| 2019-03-19 | 1.1  | 企业就绪，支持多 Kubernetes 集群，性能优化。                 |\n| 2020-03-03 | 1.5  | 回归单体架构，支持 WebAssembly 扩展，使得 Istio 的生态更加强大。 |\n| 2020-11-18 | 1.8  | 正式放弃 Mixer，进一步完善对虚拟机的支持。                   |\n\nIstio 开源后经过了一年时间的发展，在 1.0 发布的前两个月发布了 0.8 版本，这是对 API 的一次大规模重构。而在 2018 年 7 月底发布 1.0 时，Istio 达到了生产可用的临界点，此后 Google 对 Istio 团队进行了大规模重组，多家以 Istio 为基础的 Service Mesh [创业公司](https:\/\/istio.io\/latest\/about\/ecosystem\/#providers)诞生，可以说 2018 年是服务网格行业诞生的元年。\n\n2019 年 3 月 Istio 1.1 发布，而这距离 1.0 发布已经过去了近 9 个月，这已经远远超出一个开源项目的平均发布周期。我们知道迭代和进化速度是基础软件的核心竞争力，此后 Istio 开始以每个季度一个版本的固定[发布节奏](https:\/\/istio.io\/v1.7\/about\/release-cadence\/)，并在 2019 年成为了 [GitHub 增长最快的十大项目中排名第 4 名](https:\/\/octoverse.github.com\/#fastest-growing-oss-projects-by-contributors)！\n\n## Istio 社区\n\nIstio 开源四年来，已经在 GitHub 上收获了 2.7 万颗星，获得了大量的[社区用户](https:\/\/istio.io\/latest\/about\/case-studies\/)。下图是 [Istio](https:\/\/github.com\/istio\/istio) 的 GitHub star 数增长情况。\n\n![](008i3skNly1gqtm7n2hm1j31me0n2tag.jpg)\n\n2020 年 Istio 的项目管理开始走向成熟，治理方式也到了进化的阶段。2020 年，Istio 社区进行了第一次[管委会选举](https:\/\/istio.io\/latest\/blog\/2020\/steering-election-results\/)，还把商标转让给了 [Open Usage Commons](https:\/\/istio.io\/latest\/blog\/2020\/open-usage\/)。首届 [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) 在 2021 年 2 月份成功举办，几千人参加了线上会议。在中国也有大量的 Istio 社区用户，2021 年也会有线下面对面的 Istio 社区 meetup 在中国举办。\n\n![](008i3skNly1gquicfqg14j31lw0smwl2.jpg)\n\n根据 CNCF 2020 年调查，46% 的组织在生产中使用服务网格或计划在未来 12 个月内使用。Istio 是在生产中使用的最多的网格。\n\n## 未来\n\n经过 4 年的发展，围绕 Istio 不仅形成了庞大的用户群，还诞生了多家 Istio 供应商，你可以在最近改版的 [Istio 的官网首页](https:\/\/istio.io)中看到。在最近几个版本中，Istio 已经将发展中心转移到了提升 Day 2 Operation 体验上来了。我们还希望看到更多的 Istio 的采纳路径建议、案例研究、学习资料、培训及认证（例如来自 Tetrate 的业界的第一个 [Istio 管理员认证](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)），这些都将有利于 Istio 的推广和采用。\n', '\/blog\/istio-4-year-birthday\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-do-you-need-istio-when-you-already-have-kubernetes/">为什么在使用了 Kubernetes 后你可能还需要 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么在使用了 Kubernetes 后你可能还需要 Istio？', '本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后可能还需要 Istio。', '\n如果你听说过服务网格，并尝试过 [Istio](https:\/\/istio.io\/)，你可能有以下问题。\n\n1. 为什么 Istio 要在 Kubernetes 上运行？\n2. Kubernetes 和服务网格在云原生应用架构中分别扮演什么角色？\n3. Istio 扩展了 Kubernetes 的哪些方面？它解决了哪些问题？\n4. Kubernetes、Envoy 和 Istio 之间是什么关系？\n\n本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后还需要 Istio。\n\nKubernetes 本质上是通过声明式配置来实现应用生命周期管理，而服务网格本质上是提供应用间的流量、安全管理和可观测性。如果你已经使用 Kubernetes 搭建了一个稳定的应用平台，那么如何设置服务间调用的负载均衡和流量控制？是否有这样一个通用的工具或者说平台（非 SDK），可以实现？这就需要用到服务网格了。\n\nEnvoy 引入了 xDS 协议，这个协议得到了各种开源软件的支持，比如 Istio、[MOSN](https:\/\/mosn.io\/) 等。Envoy 将 xDS 贡献给服务网格或云原生基础设施。Envoy 本质上是一个现代版的代理，可以通过 API 进行配置，在此基础上衍生出许多不同的使用场景–比如 API Gateway、服务网格中的 sidecar 代理和边缘代理。\n\n本文包含以下内容。\n\n- kube-proxy 的作用描述。\n- Kubernetes 在微服务管理方面的局限性。\n- Istio 服务网格的功能介绍。\n- Kubernetes、Envoy 和 Istio 服务网格中一些概念的比较。\n\n## Kubernetes vs Service Mesh\n\n下图显示了 Kubernetes 中的服务访问关系和服务网格（每个 pod 模型一个 sidecar）。\n\n![Kubernetes vs Service Mesh](008eGmZEly1gpb7knfo4dj31hk0redrz.jpg)\n\n### 流量转发\n\nKubernetes 集群中的每个节点都部署了一个 kube-proxy 组件，该组件与 Kubernetes API Server 进行通信，获取集群中的服务信息，然后设置 iptables 规则，将服务请求直接发送到对应的 Endpoint（属于同一组服务的 pod）。\n\n### 服务发现\n\n![Service Discovery](008eGmZEly1gpb7knwb79j30kq0fcjs9.jpg)\n\nIstio 可以跟踪 Kubernetes 中的服务注册，也可以在控制平面中通过平台适配器与其他服务发现系统对接；然后生成数据平面的配置（使用 CRD，这些配置存储在 etcd 中），数据平面的透明代理。数据平面的透明代理以 sidecar 容器的形式部署在每个应用服务的 pod 中，这些代理都需要请求控制平面同步代理配置。代理之所以“透明”，是因为应用容器完全不知道代理的存在。过程中的 kube-proxy 组件也需要拦截流量，只不过 kube-proxy 拦截的是进出 Kubernetes 节点的流量–而 sidecar 代理拦截的是进出 pod 的流量。\n\n### 服务网格的劣势\n\n由于 Kubernetes 的每个节点上都运行着很多 pod，所以在每个 pod 中放入原有的 kube-proxy 路由转发功能，会增加响应延迟–由于 sidecar 拦截流量时跳数更多，消耗更多的资源。为了对流量进行精细化管理，将增加一系列新的抽象功能。这将进一步增加用户的学习成本，但随着技术的普及，这种情况会慢慢得到缓解。\n\n### 服务网格的优势\n\nkube-proxy 的设置是全局的，无法对每个服务进行细粒度的控制，而 service mesh 通过 sidecar proxy 的方式将 Kubernetes 中的流量控制从服务层中抽离出来–可以实现更大的弹性。\n\n### Kube-proxy 的不足之处\n\n首先，如果转发的 pod 不能正常服务，它不会自动尝试其他 pod。每个 pod 都有一个健康检查机制，当一个 pod 出现健康问题时，kubelet 会重启 pod，kube-proxy 会删除相应的转发规则。另外，节点 Port 类型的服务不能添加 TLS 或更复杂的消息路由机制。\n\nKube-proxy 实现了一个 Kubernetes 服务的多个 pod 实例之间的流量负载均衡，但如何对这些服务之间的流量进行精细化控制–比如将流量按百分比划分给不同的应用版本（这些应用版本都是同一个服务的一部分，但在不同的部署上），或者做金丝雀发布（灰度发布）和蓝绿发布？\n\nKubernetes 社区给出了一个使用 Deployment 做[金丝雀发布](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments)的方法，本质上是通过修改 pod 的标签来给部署的服务分配不同的 pod。\n\n### Kubernetes Ingress vs Istio Gateway\n\n如上所述，kube-proxy 只能在 Kubernetes 集群内路由流量。Kubernetes 集群的 pod 位于 CNI 创建的网络中。Ingress 是在 Kubernetes 中创建的资源对象，用于集群外部的通信。它由位于 Kubernetes 边缘节点上的入口控制器驱动，负责管理南北向流量。Ingress 必须与各种 Ingress 控制器对接，比如 [nginx ingress 控制器](https:\/\/github.com\/kubernetes\/ingress-nginx)和 [traefik](https:\/\/traefik.io\/)。Ingress 只适用于 HTTP 流量，使用简单。它只能通过匹配有限的字段来路由流量——如服务、端口、HTTP 路径等。这使得它无法对 TCP 流量进行路由，如 MySQL、Redis 和各种 RPC。这就是为什么你会看到人们在 ingress 资源注释中写 Nginx 配置语言的原因（注：使用 Nginx Ingress Controller 可以通过 [配置 ConfigMap 和 Service 的方式](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/exposing-tcp-udp-services\/)来变通支持 TCP 和 UDP  流量转发）。直接路由南北流量的唯一通行方法是使用服务的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要额外的端口管理。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。Gateway 是一个 CRD 扩展，它也重用了 sidecar 代理的功能；详细配置请参见 [Istio 网站](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/)。\n\n## Envoy\n\nEnvoy 是 Istio 中默认的 sidecar 代理。Istio 基于 Envoy 的 xDS 协议扩展了其控制平面。在讨论 Envoy 的 xDS 协议之前，我们需要先熟悉 Envoy 的基本术语。下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch.jpg)\n\n### 基础概念\n\n以下是 Envoy 中你应该知道的基本术语。\n\n- 下游。下游主机连接到 Envoy，发送请求，并接收响应，即发送请求的主机。\n- 上游：上游主机。上游主机接收来自 Envoy 的连接和请求，并返回响应；即接收请求的主机。\n- Listener：监听器。监听器是一个命名的网络地址（如端口、UNIX 域套接字等）；下游客户端可以连接到这些监听器。Envoy 将一个或多个监听器暴露给下游主机进行连接。\n- 集群。集群是一组逻辑上相同的上游主机，Envoy 连接到它们。Envoy 通过服务发现来发现集群的成员。可以选择通过主动的健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略来决定集群中哪个成员的请求路由。\n\n在 Envoy 中可以设置多个监听器，每个监听器可以设置一个过滤链（过滤链表），而且过滤链是可扩展的，这样我们可以更方便地操纵流量的行为–比如设置加密、私有 RPC 等。\n\nxDS 协议是由 Envoy 提出的，是 Istio 中默认的 sidecar 代理，但只要实现了 xDS 协议，理论上也可以作为 Istio 中的 sidecar 代理 —— 比如蚂蚁集团开源的 [MOSN](https:\/\/mosn.io)。\n\n![Istio 的架构](arch.png)\n\nIstio 是一个功能非常丰富的服务网格，包括以下功能。\n\n- 流量管理。这是 Istio 最基本的功能。\n- 策略控制。实现访问控制系统、遥测采集、配额管理、计费等功能。\n- 可观测性。在 sidecar 代理中实现。\n- 安全认证。由 Citadel 组件进行密钥和证书管理。\n\n## Istio 中的流量管理\n\nIstio 中定义了以下 CRD 来帮助用户进行流量管理。\n\n- 网关。网关描述了一个运行在网络边缘的负载均衡器，用于接收传入或传出的 HTTP\/TCP 连接。\n- 虚拟服务（VirtualService）。VirtualService 实际上是将 Kubernetes 服务连接到 Istio 网关。它还可以执行额外的操作，例如定义一组流量路由规则，以便在主机寻址时应用。\n- DestinationRule。DestinationRule 定义的策略决定了流量被路由后的访问策略。简单来说，它定义了流量的路由方式。其中，这些策略可以定义为负载均衡配置、连接池大小和外部检测（用于识别和驱逐负载均衡池中不健康的主机）配置。\n- EnvoyFilter。EnvoyFilter 对象描述了代理服务的过滤器，可以自定义 Istio Pilot 生成的代理配置。这种配置一般很少被主用户使用。\n- ServiceEntry。默认情况下，Istio 服务 Mesh 中的服务无法发现 Mesh 之外的服务。ServiceEntry 可以在 Istio 内部的服务注册表中添加额外的条目，从而允许 Mesh 中自动发现的服务访问并路由到这些手动添加的服务。\n\n## Kubernetes vs xDS vs Istio\n\n在回顾了 Kubernetes 的 kube-proxy 组件、xDS 和 Istio 对流量管理的抽象后，现在我们仅从流量管理的角度来看看这三个组件 \/ 协议的比较（注意，三者并不完全等同）。\n\n| **Kubernetes** | **xDS**  | **Istio service mesh** |\n| -------------- | -------- | ---------------------- |\n| Endpoint       | Endpoint | WorkloadEntry          |\n| Service        | Route    | VirtualService         |\n| kube-proxy     | Route    | DestinationRule        |\n| kube-proxy     | Listener | EnvoyFilter            |\n| Ingress        | Listener | Gateway                |\n| Service        | Cluster  | ServiceEntry           |\n\n## 核心观点\n\n- Kubernetes 的本质是应用生命周期管理，具体来说就是部署和管理（伸缩、自动恢复、发布）。\n- Kubernetes 为微服务提供了一个可扩展、高弹性的部署和管理平台。\n- 服务网格是基于透明代理，通过 sidecar 代理拦截服务之间的流量，然后通过控制平面配置管理它们的行为。\n- 服务网格将流量管理与 Kubernetes 解耦，不需要 kube-proxy 组件来支持服务网格内的流量；通过提供更接近微服务应用层的抽象来管理服务间的流量、安全性和可观测性。\n- xDS 是服务网格的协议标准之一。\n- 服务网格是 Kubernetes 中服务的一个更高层次的抽象。\n\n## 总结\n\n如果说 Kubernetes 管理的对象是一个 pod，那么服务网格管理的对象就是一个服务，所以用 Kubernetes 管理微服务，然后应用服务网格就可以了。如果你连服务都不想管理，那就用 [Knative](https:\/\/knative.dev\/) 这样的无服务器平台，不过这是后话。\n', '\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将带大家了解 Kubernetes 和 Istio 的内部工作原理。此外，我会介绍 Kubernetes 中的负载均衡方法，并解释为什么有了 Kubernetes 后可能还需要 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/multi-cluster-service-mesh/">[译] 是否选择多集群——使用服务网格的集群间通信</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/03/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/kubernetes-multicluster-comms/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('是否选择多集群——使用服务网格的集群间通信', '是否该使用服务网格构建多集群？本文会给你答案。', '\n本文翻译自 [To Multicluster, or Not to Multicluster: Inter-Cluster Communication Using a Service Mesh](https:\/\/www.infoq.com\/articles\/kubernetes-multicluster-comms\/)。Istio 服务网格是解决 Kubernetes 集群间通信的一个关键，虽然翻译这篇文章距离原文发表也有快 2 年时间了，但是其中的很多观点仍不过时。\n\n## 主要观点\n\n- Kubernetes 已经成为容器编排的事实标准，许多组织都运行着多个集群。集群内的通信是一个解决了的问题，但是跨集群的通信需要更多的设计和操作开销。\n- 在决定是否实施多集群支持之前，你应该了解你的通信用例。\n- 你还应该确定你想要从解决方案中获得什么（单一界面的观察性、统一信任域等），然后制定一个关于如何实现这些的计划。\n- 有几种多集群服务网格方法，如共同管理、集群感知服务通过网关路由、扁平网络和 split-horizon 端点发现服务（EDS）。\n- Istio 有现有的多集群支持，在 1.1 中还有额外的新功能，甚至未来还会有更多的功能出现。\n\nKubernetes 已经成为企业中容器编排的事实标准。这是有充分理由的 —— 它提供了一系列功能，使管理容器化应用变得更加容易。Kubernetes 也带来了一些新的挑战，一个主要的挑战就是需要部署和管理多个 Kubernetes 集群，以便有效地管理大规模分布式系统。\n\n想象一下，你已经设计和编码了一个应用，并且你已经构建了容器 —— 你只需要运行它们。从代码到运行应用是令人振奋的，但正如任何构建了容器化应用的人所知道的那样，它并不像乍看起来那样简单。在部署到生产之前，有各种开发 \/ 测试 \/ 阶段周期。此外，还有一个扩展方面的问题 —— 你的生产应用可能需要在许多不同的地方运行，原因包括水平扩展性、弹性或接近最终用户。\n\n## 环境越多，（集群）问题越多\n\n即使是一个简单的绿地应用概念，最终也需要多个部署环境。如果你正在迁移一个现有的应用，你一定会遇到更多的挑战，比如不同的安全域，不同的组织 \/ 计费，以及对一个云供应商的机器学习工具包的亲和力。\n\n解决这个问题最常见的方法是创建多个 Kubernetes 集群，每个集群都致力于在其特定环境中运行你的应用组件。在高安全领域，你将广泛使用基于角色的访问控制（RBAC），并具有审计功能。测试环境应该重现很多生产行为，但要为便于调试和检查而定制。对于你的开发环境…… 好吧，也许你像我一样，你就打开 Docker 偏好设置，然后勾选 Kubernetes 框。易用性和短暂性是常态。\n\n你很可能最终会有多个 Kubernetes 集群，每个集群都会托管微服务。集群中这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供了通用的通信模式来提高弹性、安全性和可观测性。那么集群之间和跨集群呢？\n\n运行多个 Kubernetes 集群并不一定可怕，但运行多个集群确实需要你考虑它们如何通信和交互，以便轻松交付运行在上面的优秀应用。像 Istio 这样的服务网格可以让多集群通信变得毫无痛苦。Istio 拥有多集群支持，在 1.1 中增加了新功能，并计划在未来增加更多的功能。团队也应该考虑采用服务网格来简化跨多个集群的通信。\n\n## 常见的使用案例\n\n运行多集群服务网格最常见的是这些用户需求。\n\n- 由于我的组织规模，我有多个集群，我想在一个地方查看和管理它们。我的集群一般不做集群间的流量，或者当它们做的时候，是通过定义好的 API。\n- 我有多个集群以实现高可用性，它们是彼此的克隆，如果一个集群发生故障，另一个集群可以接管，这一点非常重要。\n- 我有多个集群，它们组合成一个更高级别的应用。其中一个集群中的微服务需要与另一个集群中的微服务进行通信，以提供适当的端到端应用体验。\n\n第三类多集群需要集群间的流量。如果你想要集群间流量支持，你的实现将取决于集群之间的网络，以及你对容错的要求。\n\n### 你能从多集群中得到什么？\n\n当你考虑多集群和服务网格时，你应该从确定你想要什么开始，然后转移到如何获得它。\n\n### 单一界面\n\n你的多个服务网格从一个地方操作。你可以在一个单一的接口中查看所有集群的配置、指标和跟踪。\n\n### 统一信任域\n\n你使用服务网格来提供工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好：你依靠的是它们是什么的加密证明，而不是脆弱的外围堆栈来控制它们的来源。\n\n统一的信任域意味着所有的工作负载都可以通过绑定到一个共同的信任根来相互认证（它们是什么）。服务网格控制平面都是为这个共同的信任根配置的，无论这些平面有一个还是几个。\n\n### 独立的故障域\n\n一个不依赖其他集群和相关基础设施，本身就可以正常运行的集群是一个独立的故障域。我是把服务网格列为相关基础设施 —— 如果你要安装服务网格，你是为了把通信弹性转移到应用下面的基础设施层。如果一个集群中的服务网格的故障可以破坏另一个集群中的服务网格，那么它就不能算是一个独立的故障域。\n\n### 集群间的流量\n\n如果你想让一个集群中的服务与另一个集群中的服务直接通信，并且你想让这种通信具有服务网格的好处，如高级路由、可观测性或透明加密，那么你需要集群之间的流量保持为服务网格的一部分。换句话说，你希望你的东\/西流量离开一个集群，中转一些中间网络，比如互联网，然后进入另一个集群。\n\n这可能是大多数人在考虑多集群服务网格时的第一想法，但我在这里单独把它列出来，因为它对容错有影响。\n\n### 异构\/非扁平化的网络\n\n非平面网络支持跨多个集群的服务，没有平面网络的要求。这意味着你可以做一些事情，比如在一个网格中分配 IP，而不考虑另一个网格，你不需要 VPN 或网络隧道来进行跨网格的通信。\n\n如果你的组织已经创建了一堆不同的集群，而没有冲突的 pod IP 地址范围，或者你只是永远不想再进入这种泥潭，这将是一个对你有吸引力的属性。\n\n## 多集群服务网格方法\n\n在阐述了你可能需要从多集群中寻找的不同属性之后，我可以介绍一下各种方法所带来的好处。\n\n### 独立集群\n\n这就是解多集群。仅仅因为你有多个集群，而且每个集群都使用一个服务网格，并不意味着你必须采用统一的多集群服务网格。扪心自问，你当初为什么会有多个集群。如果你希望每个集群都是自己独立的故障域，那么隔离和消除跨集群的依赖关系是有意义的。如果这能满足你的需求，那么把服务网格当作另一个单集群的服务，比如 pod 调度或持久性磁盘管理，也没有什么坏处。\n\n### 共同管理\n\n在独立集群方法之上的下一步是多个集群的共同管理系统。在这种模式下，每个集群都是独立运行的，但你通过一个共同的管理界面来管理这套网格。让你用来监控和调试系统（或者，在这种情况下，系统）的东西驻留在系统本身之外是一个很好的设计，这样当系统坏了的时候，你仍然可以检查和修复它。\n\n如果你选择在这些集群中使用一个共同的信任根（证书授权或签名证书），那么你也可以拥有一个统一的信任域。\n\n如果独立的故障域是首要任务，那么这是一个不错的选择。这种选择很适合将软件作为服务来消费，因为你可以得到一个外部的接口来统一一切，并得到服务级别协议的支持。\n\n### 通过网关进行集群感知的服务路由选择\n\nIstio 中的这种方法涉及多个独立的服务网格，每个集群中一个，以及一些配置技巧，以允许一个集群中的服务与另一个集群中的服务通信。首先，你要为所有网格创建一个统一的信任域。接下来，你配置一个入口网关，以接受来自另一个对等集群中的服务的可信流量。最后，配置服务条目，以允许某些服务的流量从一个集群路由出来并发送到另一个集群。\n\n这是第一种允许不同集群中的服务直接相互通信的方法。同时，每个集群仍然是一个独立的网格控制平面和故障域。这意味着，如果集群 B 中的服务网格发生故障，集群 A 仍然可以工作，只是看起来集群 B 中的服务不可用。配置这种跨集群流量的负担就落在了用户身上。\n\n### 扁平网络\n\n这种模式决定了你所有集群的服务网格。你安排它，使每个集群中的 pod 具有非重叠的 IP 地址，因此任何 pod 可以将流量路由到任何集群中的其他 pod。你可能在一个共同的防火墙后面有一堆集群，或者你可能在集群间建立 VPN 隧道。你配置服务网格，以将发现的 pod、服务和来自每个集群的配置结合到一个整体视图中。\n\n扁平化的网络使它看起来就像你有一个超级服务网格，横跨你的所有集群。也有一些缺点。这个超级服务网格由一个控制平面管理，所以如果它出现问题，所有集群的服务网格都会出现问题。如果你原来为了容错而划分成多个 Kubernetes 集群，这种方式就否定了这一点。另外一个考虑是控制平面必须要扩展来管理所有集群。而且你必须让这个扁平网络的性能足够好，以处理控制平面和跨集群的流量。\n\n### 分割区域端点发现服务（EDS）\n\n这种方法也可以在集群间创建一个服务网格，但不需要扁平网络。你仍然有一个控制平面，可以从每个集群中发现 pod、服务和配置，但 Istio 的 EDS，其功能类似于分裂水平 DNS，取代了对扁平网络的要求。\n\n一个集群中的 pod 的 sidecar 被配置了它想要通信的每个服务的端点列表。如果 pod 在同一个集群中，它就会直接显示在 EDS 列表中。如果 pod 在另一个集群中，则会出现另一个集群的入口网关。pod 选择一个端点进行对话并发送流量 —— 如果端点是本地的，则通信是直接的 pod 到 pod。如果 pod 选择了一个远程端点，它就会将流量发送到相关入口网关的地址，并标记为 pod 想要访问的服务。入口网关接收流量，并将其发送到其集群中实现服务的 pod 之一。入口网关使用服务器名称指示（SNI）来了解流量的目的地。\n\n与扁平网络方式一样，这种方式创建了一个统一的服务网格控制平面，并增加了一个单一故障域和单一信任域。它不需要扁平网络，只需要一个集群可以将流量发送到其他集群的入口网关的公共地址。\n\n## 要不要多集群？\n\n如果你出于开发和组织的原因要运行多个集群，那么了解你的需求并决定是否要在多集群环境中连接这些需求是很重要的，如果是这样，了解各种方法和每个选项的相关权衡。\n\n如果你已经读到这里，你可能已经决定了多集群。真正的问题是什么是最好的实现方法。希望下面的表格能帮助你决定适合你的方法。\n\n| 方法                               | 统一管理 | 统一信任 | 异构网络 | 独立故障域 | 跨集群通信 |\n| ---------------------------------- | -------- | -------- | -------- | ---------- | ---------- |\n| 独立集群                           |          |          | √        |            |            |\n| 共同管理                           | √        |          | √        | √          |            |\n| 扁平网络                           | √        | √        |          |            | √          |\n| 分割区域端点发现服务（EDS）        | √        | √        | √        |            | √          |\n| 通过网关进行集群感知的服务路由选择 |          | √        | √        | √          | √          |\n\n像 Istio 这样的服务网格可以提供帮助，如果使用得当，可以让多集群通信变得不痛苦。如果你想了解更多关于我对为什么以及团队应该如何考虑采用服务网格来简化跨多个集群的通信的看法。\n\n## 关于作者\n\nAndrew Jenkins 是 Aspen Mesh 的首席技术官，他正在构建一个企业服务网格，以帮助企业减轻管理微服务的负担。作为容器环境（如 Kubernetes）的软件和网络架构师，Jenkins 曾担任技术领导，推动快速发展的团队取得切实成果。他的专长包括 C\u002b\u002b、JavaScript（Node.js）、Python、C、Go 和 Java 的软件开发。Jenkins 还在软件和硬件测试、FPGA 和空间科学仪器的电路板设计方面拥有丰富的经验。\n', '\/trans\/multi-cluster-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">是否该使用服务网格构建多集群？本文会给你答案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/must-read-for-cloud-native-beginner/">云原生初学者入门必读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/10/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生初学者入门必读', '这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。', '\n## 为什么写这篇文章\n\n看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。\n\n因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。\n\n## 引言\n\n[Kubernetes](https:\/\/kubernetes.io\/) 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。\n\nKubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。\n\n这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。\n\n简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 [Docker](https:\/\/docker.com\/) 容器。让我们深入了解一下这些概念。\n\n## 容器和容器化\n\n那么什么是容器呢？\n\n要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。\n\n接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。\n\n现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。\n\n虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。\n\n解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。\n\n但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！\n\n更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。\n\n与容器相关的一个重要概念是**微服务**。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。\n\n## 从 Docker 开始\n\n现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。\n\nDocker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。\n\n还有其他的容器化工具，如 [CoreOS rkt](https:\/\/coreos.com\/rkt\/)、[Mesos Containerizer](http:\/\/mesos.apache.org\/documentation\/latest\/mesos-containerizer\/) 和 [LXC](https:\/\/linuxcontainers.org\/)。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。\n\n## 再到 Kubernetes\n\n首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。\n\n那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。\n\n现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。\n\n这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。\n\n我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。\n\n接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。\n\n## Kubernetes 架构和组件\n\n首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。\n\n例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。\n\n现在我们来定义一些 Kubernetes 的重要组件。\n\n当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。\n\nKubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。\n\n主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。\n\nMaster 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。\n\nWoker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。\n\nKubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。\n\nKubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。\n\nReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。\n\n## 什么是 Kubectl？\n\nkubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。\n\n## Kubernetes 中的自动扩展\n\n请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。\n\n自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。\n\n无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。\n\n我们再继续说一些概念，这次是和网络有关的。\n\n## 什么是 kubernetes Ingress 和 Egress？\n\n外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。\n\n进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 \/ 流量的地方。\n\n## 什么是 Ingress Controller？\n\n但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。\n\n## 什么是 Replica 和 ReplicaSet？\n\n为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。\n\n所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。\n\n因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。\n\n## 什么是服务网格？\n\n[服务网格 (Service Mesh)](\/blog\/what-is-a-service-mesh\/) 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 [Kubernetes 次世代的云原生应用](\/blog\/post-kubernetes-era\/) 的重要组成部分。\n\n服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。\n\n所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。\n\n如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。\n\n在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。\n\n在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。\n\n## 如何学习 Kubernetes？\n\n自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。\n\n### 一、从零开始学习和安装 Kubernetes\n\n要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -\u003e 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 [Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。\n\n### 二、Kubernetes 自托管解决方案\n\n这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 [Minikube](https:\/\/github.com\/kubernetes\/minikube)、[MicroK8s](https:\/\/github.com\/ubuntu\/microk8s)、[Docker Desktop](https:\/\/docs.docker.com\/docker-for-windows\/kubernetes\/) 和 [Kind](https:\/\/github.com\/kubernetes-sigs\/kind)。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。\n\n### 三、云托管的解决方案\n\n如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 [Katacoda](https:\/\/katacoda.com\/) 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。\n\n## 本地测试和调试 Kubernetes\n\n作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。\n\n用于在本地开发和调试 Kubernetes 服务的工具有：[Microsoft Bridge to Kubernetes](https:\/\/github.com\/microsoft\/mindaro) 和 [telepresence](https:\/\/github.com\/telepresenceio\/telepresence)。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。\n\nKubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。\n\n## Kubernetes 监控工具\n\nKubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。\n\n毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。\n\nKubernetes 包含两个内置度量收集工具用于监控：[资源管道和全度量管道](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/resource-usage-monitoring\/)。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。\n\n还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。\n\n### Prometheus 监控\n\nPrometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。\n\n### Grafana 仪表盘\n\nGrafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。\n\n### 高级警报\n\n对于高级警报，你可以添加 [Nagios](https:\/\/www.nagios.org\/) 或 [Prometheus Alertmanager](https:\/\/github.com\/prometheus\/alertmanager) 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。\n\n现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。\n\n调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？\n\n请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。\n\n## 更多\n\n云原生领域的开源项目众多（见 [Awesome Cloud Native\/云原生开源项目大全](\/awesome-cloud-native)），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读[官方文档](https:\/\/kubernetes.io)和实践来学习，也可以参考我编写的[Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](\/book\/kubernetes-handbook)。\n\n推荐大家加入我发起创办的[云原生社区](https:\/\/cloudnative.to)，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的[云原生学院](https:\/\/github.com\/cloudnativeto\/academy)定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。\n', '\/blog\/must-read-for-cloud-native-beginner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/service-mesh/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/service-mesh/page/3/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/service-mesh/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(74)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/shanxi-trip/">地上文物看山西：宝藏文物大省不该被埋没</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/multi-cluster-pki-istio-recipe/">多集群 PKI 与 Istio 实践：为服务网格构建可信且可扩展的 PKI</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
