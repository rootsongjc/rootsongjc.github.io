<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.6fb3e96087b14e4e93b1864f8131c7847fc003876bec82f602ff6e89143fedc8.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.6fb3e96087b14e4e93b1864f8131c7847fc003876bec82f602ff6e89143fedc8.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/service-mesh/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/slime-intro/">网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器', '本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。', '\n最近我在研究 Istio 生态中的开源项目，[Slime](https:\/\/github.com\/slime-io\/slime\/) 这个项目开源与 2021 年初，是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n## Slime 试图解决的问题\n\nSlime 项目的诞生主要为了解决以下问题：\n\n1. 网格内所有服务配置全量下到所有 Sidecar Proxy，导致其消耗大量资源使得应用性能变差的问题\n2. 如何在 Istio 中实现高阶扩展的问题：比如扩展 HTTP 插件；根据服务的资源使用率做到自适应限流\n\nSlime 解决以上问题的答案是构建 Istio 的控制平面，具体做法是：\n\n- 构建可拔插控制器\n- 数据平面监控\n- CRD 转换\n\n通过以上方式 Slime 可以实现**配置懒加载**和**插件管理器**。\n\n## Slime 架构\n\nSlime 内部分为三大模块，其架构图如下所示。\n\n![Slime 内部架构图](slime-internal-arch.jpg)\n\nSlime 内部三大组件为：\n\n1. \u0060slime-boot\u0060：在 Kubernetes 上部署 Slime 模块的 operator。\n2. \u0060slime-controller\u0060：Slime 的核心组件，监听 Slime CRD 并将其转换为 Istio CRD。\n3. \u0060slime-metric\u0060：用于获取服务 metrics 信息的组件，\u0060slime-controller\u0060 会根据其获取的信息动态调整服务治理规则。\n\n目前 Slime 内置了三个控制器子模块：\n\n1. **配置懒加载（按需加载）**：用户无须手动配置 \u0060SidecarScope\u0060，Istio 可以按需加载服务配置和服务发现信息；\n2. **HTTP 插件管理**：使用新的 CRD——\u0060pluginmanager\/envoyplugin\u0060 包装了可读性，摒弃了可维护性较差的 \u0060envoyfilter\u0060，使得插件扩展更为便捷；\n3. **自适应限流**：结合监控信息自动调整限流策略；\n\n\u003e **什么是 SidecarScope？**\n\u003e\n\u003e SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n\n## 使用 Slime 作为 Istio 的控制平面\n\n为了解决这些问题，Slime 在 Istio 之上构建了更高层次的抽象，相当于为 Istio 构建了一层管理平面，其工作流程图如下所示。\n\n![Slime 工作流程图](slime-flow-chart.jpg)\n\n具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；\n2. 开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n以上只是一个对 Slime 工作流程的一个笼统的介绍，更多详细信息请参考 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/)。\n\n## 配置懒加载\n\n为了解决数据平面中 Sidecar Proxy 资源消耗过大及网络延迟问题，Slime 使用了配置懒加载（按需加载 Sidecar 配置）的方案。该方案的核心思想是向每个 Sidecar Proxy 中只下发其所 Pod 中服务所需的配置，而不是将网格中的所有服务信息全量下发。所以 Slime 需要获取每个服务的调用关系这样才能得到其所需的 Sidecar Proxy 配置。\n\nSlime 实现 Sidecar Proxy 配置懒加载的方法是：\n\n- 让数据平面中的所有服务的首次调用都通过一个 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；\n- 当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060  的 CRD 来维护服务调用关系以解决服务信息缺失问题。\n\n### 使用 Global Proxy 初始化服务调用拓扑\n\nSlime 在数据平面中部署 Global Proxy（也叫做 Global Sidecar，但其与应用的 Pod 不是一对一的关系，笔者更倾向于称其为 Global Proxy），该代理同样使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n### 使用 ServiceFence 维护服务调用拓扑\n\n在使用 Global Proxy 初始化服务调用拓扑后，一旦服务调用链有变动的话怎么办？对此 Slime 创建了 ServiceFence 的 CRD。使用 ServiceFence 可以维护服务名和后端服务的映射关系。Slime 根据其对应服务的 VirtualService，找到 Kubernetes 服务名和真实后端（host）的映射关系，将两者的都加入 Sidecar 的配置中。ServiceFence 管理生成的 SidecarScope 的生命周期，自动清理长时间不用的调用关系，从而避免上述问题。\n\n### 如何开启配置懒加载\n\n配置懒加载功能对于终端用户是透明的，只需要 Kubernetes  Service 上打上 \u0060istio.dependency.servicefence\/status:\u0022true\u0022\u0060 的标签，表明该服务需要开启配置懒加载，剩下的事情交给 Slime Operator 来完成即可。\n\n## HTTP 插件管理\n\nIstio 中的插件扩展只能通过 EnvoyFilter 来实现，因为它是 xDS 层面的配置，管理和维护这样的配置需要耗费大量的精力，也极容易出错。因此，Slime 在 EnvoyFilter 的基础上做了一层面向插件的抽象。\n\nSlime 共有两个 CRD 用于 HTTP 插件管理，分别是：\n\n- **PluginManager**：配置为哪些负载开启哪些插件，插件的配置顺序即为执行顺序；\n- **EnvoyPlugin**：EnvoyPlugin 不关心每个插件的具体配置，具体配置会被放在 EnvoyFilter 资源的 \u0060patch.typed_config\u0060 结构中透传），EnvoyPlugin 的核心思想是将插件配置在需要的维度中做聚合，从而限定插件的生鲜范围。这样做一方面更加贴合插件使用者的习惯，另一方面也降低了上层配置的冗余，\n\n关于 Slime 中插件管理的详细使用方式请见 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/blob\/master\/doc\/zh\/plugin_manager.md)。\n\n## 自适应限流\n\nEnvoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。\n\nSlime 自适应限流的流程图如下所示。\n\n![Slime 的自适应限流流程图](slime-smart-limiter.jpg)\n\nSlime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 EnvoyFilter 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的 CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。\n\nSlime 创建的 CRD \u0060SmartLimiter\u0060 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  - action:\n      fill_interval:\n        seconds: 1\n      quota: \u002230\/{pod}\u0022    # 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10\n    condition: \u0022{cpu}\u003e0.8\u0022 # 根据监控项{cpu}的值自动填充该模板\n\u0060\u0060\u0060\n\n## 更多\n\nSlime 开源于 2021 年初，本文发稿时该项目仍处于初级阶段，本文大量参考了杨笛航在云原生社区中的分享 [Slime：让 Istio 服务网格变得更加高效与智能](https:\/\/cloudnative.to\/blog\/netease-slime\/) 及 Slime 的 [GitHub](https:\/\/github.com\/slime-io\/slime)。感兴趣的读者可以关注下这个项目的 GitHub，进一步了解它。\n\n另外欢迎关注服务网格和 Istio 的朋友加入云原生社区 Istio SIG，一起参与讨论和交流。\n\n## 参考\n\n- [Slime：让 Istio 服务网格变得更加高效与智能 - cloudnative.to](https:\/\/cloudnative.to\/blog\/netease-slime\/)\n- [Slime GitHub 文档 - github.com](https:\/\/github.com\/slime-io\/slime\/blob\/master\/README_ZH.md)\n- [Sidecar - istio.io](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)\n', '\/blog\/slime-intro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/grpc-proxyless-service-mesh/">[译] 基于 gRPC 和 Istio 的无 sidecar 代理的服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2021/proxyless-grpc/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('基于 gRPC 和 Istio 的无 sidecar 代理的服务网格', '本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。', '\n译者注：本文译自 Istio 官方博客，博客原标题 [gRPC Proxyless Service Mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/)，其实是 Istio 1.11 版本中支持的实验特性，可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。本文中还给出了一个 Demo 性能测试数据，这种做法可以极大的提升应用性能，降低网络延迟。\n\n------\n\nIstio 使用一组发现 API（统称为 [xDS API](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/operations\/dynamic_configuration) 来动态配置其 Envoy sidecar 代理。这些 API 的目标是成为一个 [通用的数据平面 API](https:\/\/blog.envoyproxy.io\/the-universal-data-plane-api-d15cec7a?gi=64aa2eea0283)。gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。你可以在 [Megan Yahya 的 KubeCon EU 2021 演讲](https:\/\/www.youtube.com\/watch?v=cGJXkZ7jiDk)中了解更多关于该集成的信息。关于 gRPC 支持的最新情况，可以在他们的[提案](https:\/\/github.com\/grpc\/proposal\/search?q=xds)中找到，还有实现状态。\n\nIstio 1.11 增加了实验性支持，可以直接将 gRPC 服务添加到网格中。我们支持基本的服务发现，一些基于 VirtualService 的流量策略，以及双向 TLS。\n\n## 支持的功能\n\n与 Envoy 相比，目前 gRPC 内的 xDS API 的实现在某些方面是有限的。以下功能应该可以使用，尽管这不是一个详尽的列表，其他功能可能部分可用。\n\n- 基本的服务发现。你的 gRPC 服务可以接触到在网格中注册的其他 pod 和虚拟机。\n- \u0060DestinationRule\u0060\n  - \u0060Subset\u0060：你的 gRPC 服务可以根据标签选择器将流量分割到不同的实例组。\n  - 目前唯一支持的 Istio \u0060loadBalancer\u0060 是 \u0060ROUND_ROBIN\u0060，\u0060consistentHash\u0060 将在未来的 Istio 版本中加入（支持 gRPC）。\n  - \u0060tls\u0060 设置被限制为 \u0060DISABLE\u0060 或 \u0060ISTIO_MUTUAL\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n- \u0060VirtualService\u0060\n  - Header 匹配和 URI 匹配的格式为 \u0060\/ServiceName\/RPCName\u0060。\n  - 覆盖目标主机和子集。\n  - 加权的流量转移。\n- \u0060PeerAuthentication\u0060\n  - 只支持 \u0060DISABLE\u0060 和 \u0060STRICT\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n  - 在未来的版本中可能会有对 auto-mTLS 的支持。\n\n其他功能包括故障、重试、超时、镜像和重写规则，可能会在未来的版本中支持。其中一些功能正等待在 gRPC 中实现，而其他功能则需要在 Istio 中支持。gRPC 中 xDS 功能的状态可以[在这里](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)找到。Istio 的支持状况将存在于未来的官方文档中。\n\n这个功能是[实验性的](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/)。标准的 Istio 功能将随着时间的推移和整体设计的改进而得到支持。\n\n## 架构概述\n\n![gRPC 服务如何与 istiod 通信的示意图](008i3skNly1gwp3lh9za5j311q0hm75n.jpg)\n\ngRPC 服务如何与 istiod 通信的示意图\n\n虽然不使用 proxy 进行数据面通信，但它仍然需要一个 agent 来进行初始化和与控制面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 istiod，在哪里可以找到数据面通信的证书，以及向控制面发送什么元数据。接下来，agent 作为一个 xDS proxy，代表应用程序与 istiod 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书。\n\n## 对应用程序代码的修改\n\n本节介绍了 gRPC 在 Go 中的 xDS 支持。其他语言也有类似的 API。\n\n为了启用 gRPC 中的 xDS 功能，你的应用程序必须做一些必要的修改。你的 gRPC 版本应该至少是 1.39.0。\n\n### 客户端\n\n下面的导入将在 gRPC 中注册 xDS 解析器和均衡器。它应该被添加到你的主包或调用 \u0060grpc.Dial\u0060 的同一个包中。\n\n\u0060\u0060\u0060go\nimport _ \u0022google.golang.org\/grpc\/xds\u0022\n\u0060\u0060\u0060\n\n当创建一个 gRPC 连接时，URL 必须使用 \u0060xds:\/\/\/\u0060 scheme。\n\n\u0060\u0060\u0060go\nconn, err := grpc.DialContext(ctx, \u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022)\n\u0060\u0060\u0060\n\n此外，为了支持（m）TLS，必须向 \u0060DialContext\u0060 传递一个特殊的 \u0060TransportCredentials\u0060 选项。\u0060FallbackCreds\u0060 允许我们在 istiod 不发送安全配置时成功。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/credentials\/xds\u0022\n\n...\n\ncreds, err := xds.NewClientCredentials(xds.ClientOptions{\nFallbackCreds: insecure.NewCredentials()\n})\n\/\/ handle err\nconn, err := grpc.DialContext(\nctx,\n\u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022,\ngrpc.WithTransportCredentials(creds),\n)\n\u0060\u0060\u0060\n\n### 服务端\n\n为了支持服务器端的配置，如 mTLS，必须做一些修改。\n\n首先，我们使用一个特殊的构造函数来创建 \u0060GRPCServer\u0060。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/xds\u0022\n\n...\n\nserver = xds.NewGRPCServer()\nRegisterFooServer(server, \u0026fooServerImpl)\n\u0060\u0060\u0060\n\n如果你的 \u0060protoc\u0060 生成的 Go 代码已经过期，你可能需要重新生成，以便与 xDS 服务器兼容。你生成的 \u0060RegisterFooServer\u0060 函数应该像下面这样。\n\n\u0060\u0060\u0060go\nfunc RegisterFooServer(s grpc.ServiceRegistrar, srv FooServer) {\ns.RegisterService(\u0026FooServer_ServiceDesc, srv)\n}\n\u0060\u0060\u0060\n\n最后，与客户端的变化一样，我们必须启用安全支持。\n\n\u0060\u0060\u0060go\ncreds, err := xds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})\n\/\/ handle err\nserver = xds.NewGRPCServer(grpc.Creds(creds))\n\u0060\u0060\u0060\n\n### 在你的 Kubernetes 部署中\n\n假设你的应用代码是兼容的，Pod 只需要注释 \u0060inject.istio.io\/templates：grpc-agent\u0060。这增加了一个运行上述代理的 sidecar 容器，以及一些环境变量，gRPC 使用这些变量来寻找引导文件并启用某些功能。\n\n对于 gRPC 服务端，你的 Pod 也应该用 \u0060proxy.istio.io\/config: \u0027{\u0022holdApplicationUntilProxyStarts\u0022: true}\u0027\u0060 来注释，以确保在你的 gRPC 服务端初始化之前，代理中的 xDS 代理和引导文件已经准备就绪。\n\n## 例子\n\n在本指南中，你将部署 echo，一个已经支持服务器端和客户端无代理的 gRPC 的应用。通过这个应用程序，你可以尝试一些支持的流量策略，启用 mTLS。\n\n### 先决条件\n\n本指南要求在进行之前[安装](https:\/\/istio.io\/latest\/docs\/setup\/install\/) Istio（1.11\u002b）控制平面。\n\n### 部署应用程序\n\n创建一个支持注入的命名空间 \u0060echo-grpc\u0060。接下来部署两个 \u0060echo\u0060 应用程序的实例以及服务。\n\n\u0060\u0060\u0060sh\n$ kubectl create namespace echo-grpc\n$ kubectl label namespace echo-grpc istio-injection=enabled\n$ kubectl -n echo-grpc apply -f samples\/grpc-echo\/grpc-echo.yaml\n\u0060\u0060\u0060\n\n确保两个 Pod 正在运行。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc get pods\n\nNAME                       READY   STATUS    RESTARTS   AGE\necho-v1-69d6d96cb7-gpcpd   2\/2     Running   0          58s\necho-v2-5c6cbf6dc7-dfhcb   2\/2     Running   0          58s\n\u0060\u0060\u0060\n\n### 测试 gRPC 解析器\n\n首先，将 17171 端口转发到其中一个 Pod 上。这个端口是一个非 xDS 支持的 gRPC 服务端，允许从端口转发的 Pod 发出请求。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc port-forward $(kubectl -n echo-grpc get pods -l version=v1 -ojsonpath=\u0027{.items[0].metadata.name}\u0027) 17171 \u0026\n\u0060\u0060\u0060\n\n接下来，我们可以发送一批 5 个请求。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 5}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n\nHandling connection for 17171\n[0 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[1 body] Hostname=echo-v2-cf97bd94d-qf628\n[2 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[3 body] Hostname=echo-v2-cf97bd94d-qf628\n[4 body] Hostname=echo-v1-7cf5b76586-bgn6t\n\u0060\u0060\u0060\n\n你也可以使用类似 Kubernetes 名称解析的短名称。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join\n(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v2-cf97bd94d-jt5mf\n\u0060\u0060\u0060\n\n### 用目的地规则创建子集\n\n首先，为每个版本的工作负载创建一个子集。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-versions\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\nEOF\n\u0060\u0060\u0060\n\n### 流量转移\n\n使用上面定义的子集，你可以把 80% 的流量发送到一个特定的版本。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: echo-weights\n  namespace: echo-grpc\nspec:\n  hosts:\n  - echo.echo-grpc.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v1\n      weight: 20\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v2\n      weight: 80\nEOF\n\u0060\u0060\u0060\n\n现在，发送一组 10 个请求。\n\n\u0060\u0060\u0060sh\ngrpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 10}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep ServiceVersion\n\u0060\u0060\u0060\n\n响应应主要包含 v2 响应。\n\n\u0060\u0060\u0060plain\n[0 body] ServiceVersion=v2\n[1 body] ServiceVersion=v2\n[2 body] ServiceVersion=v1\n[3 body] ServiceVersion=v2\n[4 body] ServiceVersion=v1\n[5 body] ServiceVersion=v2\n[6 body] ServiceVersion=v2\n[7 body] ServiceVersion=v2\n[8 body] ServiceVersion=v2\n[9 body] ServiceVersion=v2\n\u0060\u0060\u0060\n\n### 启用 mTLS\n\n由于在 gRPC 中启用安全所需的应用程序本身的变化，Istio 的自动检测 mTLS 支持的传统方法是不可靠的。出于这个原因，初始版本需要在客户端和服务端上明确启用 mTLS。\n\n要启用客户端的 mTLS，请应用带有 \u0060tls\u0060 设置的 \u0060DestinationRule\u0060。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\nEOF\n\u0060\u0060\u0060\n\n现在，试图调用尚未配置 mTLS 的服务器将会失败。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\nERROR:\nCode: Unknown\nMessage: 1\/1 requests had errors; first error: rpc error: code = Unavailable desc = all SubConns are in TransientFailure\n\u0060\u0060\u0060\n\n为了启用服务器端的 mTLS，应用一个 \u0060PeerAuthentication\u0060。\n\n以下策略对整个命名空间强制采用 STRICT mTLS。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n应用该政策后，请求将开始成功。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\n[0] grpcecho.Echo(\u0026{xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070 map[] 0  5s false })\n[0 body] x-request-id=0\n[0 body] Host=echo.echo-grpc.svc.cluster.local:7070\n[0 body] content-type=application\/grpc\n[0 body] user-agent=grpc-go\/1.39.1\n[0 body] StatusCode=200\n[0 body] ServiceVersion=v1\n[0 body] ServicePort=17070\n[0 body] Cluster=\n[0 body] IP=10.68.1.18\n[0 body] IstioVersion=\n[0 body] Echo=\n[0 body] Hostname=echo-v1-7cf5b76586-z5p8l\n\u0060\u0060\u0060\n\n## 限制条件\n\n最初的版本有几个限制，可能会在未来的版本中修复。\n\n- 不支持自动 mTLS，也不支持许可模式。相反，我们需要在服务器上使用 \u0060STRICT\u0060，在客户端使用 \u0060ISTIO_MUTUAL\u0060 的明确 mTLS 配置。在迁移到 \u0060STRICT\u0060 的过程中，可以使用 Envoy。\n- \u0060grpc.Serve(listener)\u0060 或 \u0060grpc.Dial(\u0022xds:\/\/...\u0022)\u0060 在 bootstrap 被写入或 xDS 代理准备好之前被调用会导致失败。 \u0060holdApplicationUntilProxyStarts\u0060 可以用来解决这个问题，或者应用程序可以对这些失败更加稳健。\n- 如果支持 xDS 的 gRPC 服务器使用 mTLS，那么你将需要确保你的健康检查可以绕过这个问题。要么使用一个单独的端口，要么你的健康检查客户端需要一种方法来获得适当的客户端证书。\n- gRPC 中 xDS 的实现与 Envoy 不一致。某些行为可能不同，某些功能可能缺失。[gRPC 的功能状态](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)提供了更多细节。请确保测试任何 Istio 配置是否真正适用于你的无代理的 gRPC 应用程序。\n\n## 性能\n\n### 实验设置\n\n- 使用 Fortio，一个基于 Go 的负载测试应用程序\n  - 稍作修改，以支持 gRPC 的 XDS 功能 (PR)\n- 资源：\n  - GKE 1.20 集群有 3 个 \u0060e2-standard-16\u0060 节点（每个节点有 16 个 CPU\u002b64GB 内存）\n  - Fortio 客户端和服务器应用程序：1.5 vCPU，1000 MiB 内存\n  - Sidecar（istio-agent 和可能的 Envoy 代理）：1 vCPU，512 MiB 内存\n- 测试的工作负载类型：\n  - 基线：常规的 gRPC，没有使用 Envoy 代理或 Proxyless xDS\n  - Envoy：标准的 istio-agent \u002b Envoy proxy sidecar\n  - 无代理：使用 xDS gRPC 服务器实现的 gRPC 和客户端的 \u0060xds:\/\/\/\u0060 解析器。\n  - 通过 \u0060PeerAuthentication\u0060 和 \u0060DestinationRule\u0060 启用 \/ 停用 mTLS\n\n### 延迟\n\n![P50 延迟对比图](008i3skNly1gwp512szlvj31260rgq57.jpg)\n\nP50 延迟对比图\n\n![P99 延迟对比图](008i3skNly1gwp51zjxqaj312q0r2jtl.jpg)\n\nP99 延迟对比图\n\n在使用无代理的 gRPC 解析器时，延迟会有微小的增加。与 Envoy 相比，这是一个巨大的改进，仍然可以实现先进的流量管理功能和 mTLS。\n\n### istio-proxy 容器的资源使用情况\n\n| 类别        | 客户端 \u0060mCPU\u0060 | 客户端内存 (\u0060MiB\u0060) | 服务端 \u0060mCPU\u0060 | 服务端内存 (\u0060MiB\u0060) |\n| ----------- | ------------- | ------------------ | ------------- | ------------------ |\n| Envoy 明文  | 320.44        | 66.93              | 243.78        | 64.91              |\n| Envoy mTLS  | 340.87        | 66.76              | 309.82        | 64.82              |\n| 无代理明文  | 0.72          | 23.54              | 0.84          | 24.31              |\n| 无代理 mTLS | 0.73          | 25.05              | 0.78          | 25.43              |\n\n尽管我们仍然需要一个代理，但代理使用的内存不到完整 vCPU 的 0.1%，而且只有 25 MiB，这还不到运行 Envoy 所需内存的一半。\n\n这些指标不包括应用容器中 gRPC 的额外资源使用量，但有助于展示 istio-agent 在此模式下运行时的资源使用影响。\n', '\/trans\/grpc-proxyless-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-ebpf-streamlines-the-service-mesh/">[译] eBPF 如何简化服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 如何简化服务网格', '本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。', '\n今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对额外的[复杂性](https:\/\/engineering.hellofresh.com\/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb)和[开销的](https:\/\/pklinker.medium.com\/performance-impacts-of-an-istio-service-mesh-63957a0000b)实际[担忧所抑制](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)。让我们来探讨一下 [eBPF](https:\/\/ebpf.io\/) 是如何让我们精简[服务网格](https:\/\/thenewstack.io\/category\/service-mesh\/)，使服务网格的数据平面更有效率，更容易部署。\n\n## Sidecar 问题\n\n今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 [Envoy](https:\/\/www.envoyproxy.io\/) 或 [Linkerd-proxy](https:\/\/linkerd.io\/)。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。\n\n每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的[经验](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。\n\n![来自 [redhat.com\/architect\/why-when-service-mesh](https:\/\/redhat.com\/architect\/why-when-service-mesh)——每个微服务都有自己的代理 sidecar](008i3skNly1gvtp69o74jj31w50u0jy8.jpg) \n\n为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。\n\n## 引入 eBPF\n\n[eBPF](http:\/\/ebpf.io\/) 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。\n\n重要的是，**每个节点只有一个内核**；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。\n\n![每台主机一个内核](008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg) \n\n这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。\n\n基于 eBPF 的 [Cilium](http:\/\/cilium.io\/) 项目（最近 [以孵化级别加入云计算基金会](https:\/\/www.cncf.io\/blog\/2021\/10\/13\/cilium-joins-cncf-as-an-incubating-project\/)）将这种“无 sidecar\u0022 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。\n\n![用无 sidecar 代理模式减少代理实例](008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg) \n\n## 减少 YAML\n\n在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。\n\n以 Istio 为例，这需要[标记](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#controlling-the-injection-policy) Kubernetes 命名空间和 \/ 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。\n\n但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。\n\n相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。\n\n如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。\n\n## eBPF 支持的网络效率\n\n支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的[性能得到显著改善](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark)。让我们看看这在服务网格数据平面中是如何应用的。\n\n![在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多](008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg) \n\n在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP\/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的[显著增加](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/#latency-at-20-rps)。\n\n基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。\n\n## 网络中的加密\n\n如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。\n\n通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。\n\n但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 [IPSec 或 WireGuard](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec)。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。\n\n## eBPF 是服务网格的数据平面\n\n现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。\n\n去年，我代表 [CNCF](https:\/\/cncf.io\/?utm_content=inline-mention) 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 [预测](https:\/\/youtu.be\/bESogtuHwX0)。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。\n', '\/trans\/how-ebpf-streamlines-the-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-ultimate-guide-e2/">[译] 服务网格终极指南第二版——下一代微服务开发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-ultimate-guide-2e/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格终极指南第二版——下一代微服务开发', '本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。', '\n### 主要收获\n\n- 了解采用服务网格技术的新兴架构趋势，特别是多云、多集群和多租户模式，如何在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案，以及从边缘计算层到网格的应用 \/ 服务连接。\n- 了解服务网格生态系统中的一些新模式，如多集群服务网格、媒体服务网格（Media Service Mesh）和混沌网格，以及经典的微服务反模式，如“死星（Death Star） “架构。\n- 获取最新的关于在部署领域使用服务网格的创新总结，在 Pod（K8s 集群）和 VM（非 K8s 集群）之间进行快速实验、混乱工程和金丝雀部署。\n- 探索服务网格扩展领域的创新，包括：增强身份管理，以确保微服务连接的安全性，包括自定义证书授权插件，自适应路由功能，以提高服务的可用性和可扩展性，以及增强 sidecar 代理。\n- 了解操作方面即将出现的情况，如配置多集群功能和将 Kubernetes 工作负载连接到托管在虚拟机基础设施上的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户。\n\n在过去的几年里，服务网格技术有了长足的发展。服务网格在各组织采用云原生技术方面发挥着重要作用。通过提供四种主要能力 —— 连接性、可靠性、可观测性和安全性，服务网格已经成为 IT 组织的技术和基础设施现代化工作的核心组成部分。服务网格使开发和运维团队能够在基础设施层面实现这些能力，因此，当涉及到跨领域的非功能需求时，应用团队不需要重新发明轮子。\n\n自本文[第一版](https:\/\/www.infoq.com\/articles\/service-mesh-ultimate-guide\/)于 2020 年 2 月发表以来，服务网格技术经历了重大创新，在不断发展的服务网格领域出现了一些新的架构趋势、技术能力和服务网格项目。\n\n在过去的一年里，服务网格产品的发展远远超过了原有的 Kubernetes 解决方案，没有托管在 Kubernetes 平台上的应用无法利用服务网格。并非所有的组织都将其所有的业务和 IT 应用程序过渡到 Kubernetes 云平台。因此，自服务网格诞生以来，一直需要这项技术在不同的 IT 基础设施环境中工作。\n\n随着微服务架构的不断采用，应用系统在云供应商、基础设施（Kubernetes、虚拟机、裸机服务器）、地域，甚至在服务网格集成环境中要管理的工作负载类型方面，都已实现解耦和分布式。\n\n让我们从服务网格的历史开始说起，了解服务网格是如何产生的。\n\n2016 年前后，“服务网格 \u0022 这个词出现在微服务、云计算和 DevOps 的领域。Buoyant 团队在 2016 年用[这个](https:\/\/twitter.com\/wm\/status\/1383061764938469377?s=20)词来解释他们的产品 Linkerd。和云计算领域的许多概念一样，相关的模式和技术其实有很长的历史。\n\n服务网格的到来主要是由于 IT 领域内的一场风暴。开发人员开始使用多语言（polyglot）方法构建分布式系统，并需要动态服务发现。运维部门开始使用短暂的基础设施，并希望优雅地处理不可避免的通信故障和执行网络策略。平台团队开始接受像 Kubernetes 这样的容器编排系统，并希望使用现代 API 驱动的网络代理（如 Envoy）在系统中和周围动态地路由流量。\n\n本文旨在回答软件架构师和技术负责人的相关问题，如：什么是服务网格？我是否需要服务网格？如何评估不同的服务网格产品？\n\n## 服务网格模式\n\n服务网格模式专注于管理分布式软件系统中所有服务之间的通信。\n\n### 背景介绍\n\n该模式的背景有两个方面。首先，工程师们已经采用了微服务架构模式，并通过将多个（理想情况下是单一用途且可独立部署的）服务组合在一起构建他们的应用。第二，组织已经接受了云原生平台技术，如容器（如 Docker）、编排器（如 Kubernetes）和网关。\n\n### 意图\n\n服务网格模式试图解决的问题包括：\n\n- 消除了将特定语言的通信库编译到单个服务中的需求，以处理服务发现、路由和应用层（第 7 层）非功能通信要求。\n- 外部化服务通信配置，包括外部服务的网络位置、安全凭证和服务质量目标。\n- 提供对其他服务的被动和主动监测。\n- 在整个分布式系统中分布式地执行策略。\n- 提供可观测性的默认值，并使相关数据的收集标准化。\n  - 启用请求记录\n  - 配置分布式追踪\n  - 收集指标\n\n### 结构\n\n服务网格模式主要侧重于处理传统上被称为“东西向“的基于远程过程调用（RPC）的流量：请求 \/ 响应类型的通信，源自数据中心内部，在服务之间传播。这与 API 网关或边缘代理相反，后者被设计为处理“南北“流量。来自外部的通信，进入数据中心内的一个终端或服务。\n\n## 服务网格的特点\n\n服务网格的实施通常会提供以下一个或多个功能：\n\n- 规范化命名并增加逻辑路由，（例如，将代码级名称“用户服务 \u0022 映射到平台特定位置“AWS-us-east-1a\/prod\/users\/v4”。\n- 提供流量整形和流量转移\n- 保持负载均衡，通常采用可配置的算法\n- 提供服务发布控制（例如，金丝雀释放和流量分割）\n- 提供按请求的路由（例如，影子流量、故障注入和调试重新路由）。\n- 增加基线可靠性，如健康检查、超时 \/ 截止日期、断路和重试（预算）。\n- 通过透明的双向传输级安全（TLS）和访问控制列表（ACL）等策略，提高安全性\n- 提供额外的可观测性和监测，如顶线指标（请求量、成功率和延迟），支持分布式追踪，以及 \u0022挖掘\u0022 和检查实时服务间通信的能力。\n- 使得平台团队能够配置 \u0022 理智的默认值”，以保护系统免受不良通信的影响。\n\n服务网格的能力可分为以下四个方面：\n\n- 连接性\n- 可靠性\n- 安全性\n- 可观测性\n\n让我们看看服务网格技术在这些领域都能提供哪些功能。\n\n**连接性**\n\n- 流量控制（路由，分流）\n- 网关（入口、出口）\n- 服务发现\n- A\/B 测试、金丝雀\n- 服务超时、重试\n\n**可靠性**\n\n- 断路器\n- 故障注入 \/ 混沌测试\n\n**安全性**\n\n- 服务间认证（mTLS）\n- 证书管理\n- 用户认证（JWT）\n- 用户授权（RBAC）\n- 加密\n\n**可观测性**\n\n- 监测\n- 遥测、仪表、计量\n- 分布式追踪\n- 服务图表\n\n## 服务网格架构：内部原理\n\n服务网格由两部分组成：数据平面和控制平面。Matt Klein，[Envoy Proxy](https:\/\/www.envoyproxy.io\/) 的作者，写了一篇关于“ [服务网格数据平面与控制平面 ](https:\/\/blog.envoyproxy.io\/service-mesh-data-plane-vs-control-plane-2774e720f7fc)“的深入探讨。\n\n广义上讲，数据平面“执行工作”，负责“有条件地翻译、转发和观察流向和来自 [网络终端] 的每个网络数据包”。在现代系统中，数据平面通常以代理的形式实现，（如 Envoy、[HAProxy](http:\/\/www.haproxy.org\/) 或 [MOSN](https:\/\/github.com\/mosn\/mosn)），它作为 \u0022sidecar\u0022 与每个服务一起在进程外运行。Linkerd 使用了一种 [微型代理](https:\/\/linkerd.io\/2020\/12\/03\/why-linkerd-doesnt-use-envoy\/)方法，该方法针对服务网格的使用情况进行了优化。\n\n控制平面“监督工作”，并将数据平面的所有单个实例 —— 一组孤立的无状态 sidecar 代理变成一个分布式系统。控制平面不接触系统中的任何数据包 \/ 请求，相反，它允许人类运维人员为网格中所有正在运行的数据平面提供策略和配置。控制平面还能够收集和集中数据平面的遥测数据，供运维人员使用。\n\n控制平面和数据平面的结合提供了两方面的优势，即策略可以集中定义和管理，同时，同样的政策可以以分散的方式，在 Kubernetes 集群的每个 pod 中本地执行。这些策略可以与安全、路由、断路器或监控有关。\n\n下图取自 Istio 架构文档，虽然标注的技术是 Istio 特有的，但这些组件对所有服务网格的实现都是通用的。\n\n![Istio 架构](arch.jpg) \n\nIstio 架构，展示了控制平面和代理数据平面的交互方式（由 [Istio 文档提供](https:\/\/istio.io\/docs\/)）。\n\n## 使用案例\n\n服务网格可以实现或支持多种用例。\n\n### 动态服务发现和路由\n\n服务网格提供动态服务发现和流量管理，包括用于测试的流量影子（复制），以及用于金丝雀发布和 A\/B 实验的流量分割。\n\n服务网格中使用的代理通常是“应用层 \u0022 感知的（在 OSI 网络堆栈的第 7 层运行）。这意味着流量路由决策和指标的标记可以利用 HTTP 头或其他应用层协议元数据。\n\n### 服务间通信可靠性\n\n服务网格支持跨领域的可靠性要求的实施和执行，如请求重试、超时、速率限制和断路。服务网格经常被用来补偿（或封装）处理[分布式计算的八个谬误](https:\/\/en.wikipedia.org\/wiki\/Fallacies_of_distributed_computing)。应该注意的是，服务网格只能提供 wire-level 的可靠性支持（如重试 HTTP 请求），最终服务应该对相关的业务影响负责，如避免多个（非幂等的）HTTP POST 请求。\n\n### 流量的可观测性\n\n由于服务网格处于系统内处理的每个请求的关键路径上，它还可以提供额外的“可观测性”，例如请求的分布式追踪、HTTP 错误代码的频率以及全局和服务间的延迟。虽然在企业领域是一个被过度使用的短语，但服务网格经常被提议作为一种方法来捕获所有必要的数据，以实现整个系统内流量的统一界面视图。\n\n### 通信安全\n\n服务网格还支持跨领域安全要求的实施和执行，如提供服务身份（通过 x509 证书），实现应用级服务 \/ 网络分割（例如，“服务 A\u0022 可以与“服务 B“通信，但不能与“服务 C“通信），确保所有通信都经过加密（通过 TLS），并确保存在有效的用户级身份令牌或“[护照](https:\/\/qconsf.com\/sf2019\/presentation\/user-device-identity-microservices-netflix-scale) \u0022。\n\n## 反模式\n\n当反模式的使用出现时，这往往是一个技术成熟的标志。服务网格也不例外。\n\n### 太多的流量管理层次\n\n当开发人员不与平台或运维团队协商，并在现在通过服务网格实现的代码中重复现有的通信处理逻辑时，就会出现这种反模式。例如，除了服务网格提供的 wire-level 重试策略外，应用程序还在代码中还实现了重试策略。这种反模式会导致重复的事务等问题。\n\n### 服务网格银弹\n\n在 IT 领域没有“银弹“这样的东西，但供应商有时会被诱惑给新技术贴上这个标签。服务网格不会解决微服务、Kubernetes 等容器编排器或云网络的所有通信问题。服务网格的目的只是促进服务件（东西向）的通信，而且部署和运行服务网格有明显的运营成本。\n\n### 企业服务总线（ESB）2.0\n\n在前微服务面向服务架构（SOA）时代，企业服务总线（ESB）实现了软件组件之间的通信系统。有些人担心 ESB 时代的许多错误会随着服务网格的使用而重演。\n\n通过 ESB 提供的集中的通信控制显然有价值。然而，这些技术的发展是由供应商推动的，这导致了多种问题，例如：ESB 之间缺乏互操作性，行业标准的定制扩展（例如，将供应商的特定配置添加到 WS-* 兼容模式中），以及高成本。ESB 供应商也没有做任何事情来阻止业务逻辑与通信总线的集成和紧耦合。\n\n### 大爆炸部署\n\n在整个 IT 界有一种诱惑，认为大爆炸式的部署方法是最容易管理的方法，但正如 [Accelerate](https:\/\/itrevolution.com\/book\/accelerate\/) 和 [DevOps 报告](https:\/\/puppet.com\/resources\/report\/state-of-devops-report\/)的研究，事实并非如此。由于服务网格的全面推广意味着这项技术处于处理所有终端用户请求的关键路径上，大爆炸式的部署是非常危险的。\n\n### 死星建筑\n\n当企业采用微服务架构，开发团队开始创建新的微服务或在应用中利用现有的服务时，服务间的通信成为架构的一个关键部分。如果没有一个良好的治理模式，这可能会导致不同服务之间的紧密耦合。当整个系统在生产中出现问题时，也将很难确定哪个服务出现了问题。\n\n如果缺乏服务沟通战略和治理模式，该架构就会变成所谓的“死星架构”。\n\n关于这种架构反模式的更多信息，请查看关于云原生架构采用的[第一部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part1\/)、[第二部分](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part2\/)和[第三部分的](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)文章。\n\n### 特定领域的服务网格\n\n服务网格的本地实现和过度优化有时会导致服务网格部署范围过窄。开发人员可能更喜欢针对自己的业务领域的服务网格，但这种方法弊大于利。我们不希望实现过于细化的服务网格范围，比如为组织中的每个业务或功能域（如财务、人力资源、会计等）提供专用的服务网格。这就违背了拥有像服务网格这样的通用服务协调解决方案的目的，即企业级服务发现或跨域服务路由等功能。\n\n## 服务网格的实现和产品\n\n以下是一份非详尽的当前服务网格实施清单。\n\n- [Linkerd ](https:\/\/linkerd.io\/)(CNCF 毕业项目)\n- [Istio](https:\/\/istio.io\/)\n- [Consul](https:\/\/www.consul.io\/)\n- [Kuma](https:\/\/kuma.io\/)（CNCF 沙盒项目）\n- [AWS App Mesh](https:\/\/aws.amazon.com\/app-mesh\/)\n- [NGINX Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)\n- [AspenMesh](https:\/\/aspenmesh.io\/)\n- [Kong](https:\/\/konghq.com\/kong-mesh\/)\n- [Solo Gloo Mesh](https:\/\/www.solo.io\/products\/gloo-mesh\/)\n- [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Traefik Mesh](http:\/\/traefik.io\/traefik-mesh)（原名 Maesh）。\n- [Meshery](http:\/\/layer5.io\/meshery)\n- [Open Service MEsh](http:\/\/openservicemesh.io\/)（CNCF 沙盒项目）。\n\n另外，像 [DataDog](https:\/\/www.datadoghq.com\/blog\/tag\/service-mesh\/) 这样的其他产品也开始提供与 [Linkerd](https:\/\/docs.datadoghq.com\/integrations\/linkerd\/?tab=host)、Istio、Consul Connect 和 AWS App Mesh 等服务网格技术的集成。\n\n## 服务网格对比\n\n服务网格领域的发展极为迅速，因此任何试图创建比较的努力都可能很快变得过时。然而，确实存在一些比较。应该注意了解来源的偏见（如果有的话）和进行比较的日期。\n\n- https:\/\/layer5.io\/landscape\n- https:\/\/kubedex.com\/istio-vs-linkerd-vs-linkerd2-vs-consul\/（截至 2021 年 8 月的正确数据）\n- https:\/\/platform9.com\/blog\/kubernetes-service-mesh-a-comparison-of-istio-linkerd-and-consul\/（截至 2019 年 10 月的最新情况）\n- [https:\/\/servicemesh.es\/ ](https:\/\/servicemesh.es\/)(最后发表于 2021 年 8 月)\n\nInfoQ 一直建议服务网格的采用者对每个产品进行自己的尽职调查和试验。\n\n## 服务网格教程\n\n对于希望试验多服务网格的工程师或建筑师来说，可以使用以下教程、游戏场和工具。\n\n- [Layer 5 Meshery](https:\/\/layer5.io\/meshery)—— 多网格管理平面\n- [Solo 的 Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)—— 服务网格编排平台\n- KataCoda Istio 教程\n- [Consul 服务网格教程](https:\/\/learn.hashicorp.com\/consul)\n- [Linkerd 教程](https:\/\/linkerd.io\/2\/getting-started\/)\n- [NGINX 服务网格教程](https:\/\/docs.nginx.com\/nginx-service-mesh\/tutorials\/)\n- [Istio 基础教程](https:\/\/tetrate-academy.thinkific.com\/courses\/istio-fundamentals-zh)\n\n## 服务网格的历史\n\n自 2013 年底 Airbnb 发布 [SmartStack](https:\/\/medium.com\/airbnb-engineering\/smartstack-service-discovery-in-the-cloud-4b8a080de619)，为新兴的“ [微服务 ](https:\/\/www.infoq.com\/microservices\/)“风格架构提供进程外服务发现机制（使用 [HAProxy](http:\/\/www.haproxy.org\/)）以来，InfoQ 一直在跟踪这个我们现在称之为 [服务网格](https:\/\/www.infoq.com\/servicemesh\/)的话题。许多之前被贴上“独角兽“标签的组织在此之前就在研究类似的技术。从 21 世纪初开始，谷歌就在开发其 [Stubby ](https:\/\/grpc.io\/blog\/principles\/)RPC 框架，该框架演变成了 [gRPC](https:\/\/cloud.google.com\/blog\/products\/gcp\/grpc-a-true-internet-scale-rpc-framework-is-now-1-and-ready-for-production-deployments)，以及 [谷歌前端（GFE）](https:\/\/landing.google.com\/sre\/sre-book\/chapters\/production-environment\/)和全局软件负载均衡器（GSLB），在 [Istio](https:\/\/istio.io\/) 中可以看到它们的特质。在 2010 年代早期，Twitter 开始了 Scala 驱动的 [Finagle](https:\/\/twitter.github.io\/finagle\/) 的工作，[Linkerd](https:\/\/linkerd.io\/) 服务网格由此产生。\n\n2014 年底，Netflix 发布了[一整套基于 JVM 的实用程序](https:\/\/netflix.github.io\/)，包括 [Prana](https:\/\/www.infoq.com\/news\/2014\/12\/netflix-prana\/)，一个“sidecar“程序，允许用任何语言编写的应用服务通过 HTTP 与库的独立实例进行通信。2016 年，NGINX 团队开始谈论“[Fabric 模型](https:\/\/www.nginx.com\/blog\/microservices-reference-architecture-nginx-fabric-model\/) \u0022，这与服务网格非常相似，但需要使用他们的商业 NGINX Plus 产品来实现。另外，Linkerd v0.2 在 2016 年 2 月[发布](https:\/\/linkerd.io\/2016\/02\/18\/linkerd-twitter-style-operability-for-microservices\/)，尽管该团队直到后来才开始称它为服务网格。\n\n服务网格历史上的其他亮点包括 2017 年 5 月的 [Istio](https:\/\/istio.io\/)、2018 年 7 月的 [Linkerd 2.0](https:\/\/linkerd.io\/2018\/09\/18\/announcing-linkerd-2-0\/)、2018 年 11 月的 [Consul Connect](https:\/\/www.hashicorp.com\/products\/consul\/service-mesh) 和 [Gloo Mesh](https:\/\/github.com\/solo-io\/supergloo)、2019 年 5 月的 [服务网格接口（SMI）](https:\/\/smi-spec.io\/)，以及 2019 年 9 月的 Maesh（现在叫 Traefik Mesh）和 Kuma。\n\n即使是在独角兽企业之外出现的服务网格，如 HashiCorp 的 [Consul](https:\/\/www.consul.io\/)，也从上述技术中获得了灵感，通常旨在实现 CoreOS 提出的“[GIFEE ](https:\/\/github.com\/linearregression\/GIFEE)“概念；所有人可用的 Google 基础设施（Google infrastructure for everyone else）。\n\n为了深入了解现代服务网格概念的演变历史，[Phil Calçado](https:\/\/philcalcado.com\/) 写了一篇全面的文章“ [模式：服务网格](https:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) \u0022。\n\n## 服务网格标准\n\n尽管在过去的几年里，服务网格技术年复一年地发生着重大转变，但服务网格的标准还没有跟上创新的步伐。\n\n使用服务网格解决方案的主要标准是[服务网格接口](https:\/\/smi-spec.io\/)（SMI）。服务网格接口是在 [Kubernetes](https:\/\/kubernetes.io\/) 上运行的服务网格的一个规范。它本身并没有实现服务网格，而是定义了一个通用的标准，可以由各种服务网格供应商来实现。\n\nSMI API 的目标是提供一套通用的、可移植的服务网格 API，Kubernetes 用户可以以一种与提供者无关的方式使用。通过这种方式，人们可以定义使用服务网格技术的应用程序，而不需要与任何特定的实现紧密结合。\n\nSMI 基本上是一个 Kubernetes 自定义资源定义（[CRD](https:\/\/kubernetes.io\/docs\/tasks\/extend-kubernetes\/custom-resources\/custom-resource-definitions\/)）和扩展 API 服务器的集合。这些 API 可以安装到任何 Kubernetes 集群，并使用标准工具进行操作。为了激活这些 API，需要在 Kubernetes 集群中运行一个 SMI 提供者。\n\nSMI 规范既允许终端用户的标准化，也允许服务网格技术提供商的创新。SMI 实现了灵活性和互操作性，并涵盖了最常见的服务网格功能。目前的[规范组件](https:\/\/github.com\/servicemeshinterface\/smi-spec\/tree\/main\/apis)集中在服务网格能力的连接方面。API 规范包括以下内容。\n\n- 流量访问控制\n- 流量指标\n- 流量规格\n- 流量分割\n\n目前的 SMI [生态系统](https:\/\/github.com\/servicemeshinterface\/smi-spec)包括广泛的服务网格，包括 Istio、Linkerd、Consul Connect、Gloo Mesh 等。\n\nSMI 规范是在 [Apache License 2.0 版本下](http:\/\/www.apache.org\/licenses\/)[许可的](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/LICENSE)。\n\n如果你想了解更多关于 SMI 规范及其 API 细节，请查看以下链接。\n\n- [核心规范](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/SPEC_LATEST_STABLE.md)（当前版本：0.6.0）\n- [规范 Github 项目](https:\/\/github.com\/servicemeshinterface\/smi-spec)\n- [如何贡献](https:\/\/github.com\/servicemeshinterface\/smi-spec\/blob\/main\/CONTRIBUTING.md)\n\n## 服务网格基准测试\n\n[服务网格性能](https:\/\/smp-spec.io\/)是一个捕捉基础设施容量、服务网配置和工作负载元数据细节的标准。SMP 规范用于捕捉以下细节。\n\n- 环境和基础设施细节\n- 节点的数量和规模，编排器\n- 服务网格和它的配置\n- 工作量 \/ 应用细节\n- 进行统计分析以确定性能特征\n\n来自 Linkerd 团队的 William Morgan [写了](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/)关于 Linkerd 和 Istio 的性能基准测试。还有一篇来自 2019 年的[文章](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/)，介绍了 Istio 关于服务网格性能基准测试的最佳实践。\n\n重要的是要记住，就像其他性能基准测试一样，你不应该对任何这些外部出版物投入过多的注意力，特别是产品供应商发表的文章。该在你的服务器环境中设计和执行你自己的性能测试，以验证哪个具体产品适合你的应用程序的业务和非功能要求。\n\n## 探索服务网格的未来\n\n[Kasun Indrasiri](https:\/\/www.infoq.com\/profile\/Kasun-Indrasiri\/) 探讨了“ [为事件驱动的消息传递使用服务网格的潜力](https:\/\/www.infoq.com\/articles\/service-mesh-event-driven-messaging\/) \u0022，他在其中讨论了在服务网格中实现消息传递支持的两种主要的新兴架构模式：协议代理 sidecar 和 HTTP 桥接 sidecar。这是服务网格社区中一个活跃的发展领域，在 [Envoy 中](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)支持 [Apache Kafka 的](https:\/\/github.com\/envoyproxy\/envoy\/issues\/2852)工作引起了相当多的关注。\n\nChristian Posta 之前在“[Towards a Unified, Standard API for Consolidating Service Meshes ](https:\/\/www.infoq.com\/articles\/service-mesh-api-federating\/)中写过关于服务网格使用标准化的尝试。这篇文章还讨论了 2019 年微软和合作伙伴在 KubeCon EU 上宣布的[服务网格接口（SMI）](https:\/\/cloudblogs.microsoft.com\/opensource\/2019\/05\/21\/service-mesh-interface-smi-release\/)。SMI 定义了一套通用和可移植的 API，旨在为开发人员提供不同服务网格技术的互操作性，包括 Istio、Linkerd 和 Consul Connect。\n\n将服务网格与平台结构整合的主题可以进一步分为两个子主题。\n\n首先，正在进行的工作是减少由服务网格数据平面引入的网络开销。这包括[数据平面开发工具包（DPDK）](https:\/\/www.dpdk.org\/)，它是一个[用户空间应用程序](https:\/\/www.linuxjournal.com\/content\/userspace-networking-dpdk)，“绕过了 Linux 内核网络堆栈，直接与网络硬件对话”。还有 [Cilium 团队的](https:\/\/www.infoq.com\/news\/2018\/03\/cilium-linux-bpf\/)基于 Linux 的 BPF 解决方案，它利用 Linux 内核中的扩展[伯克利包过滤器（eBPF）功能](https:\/\/cilium.io\/blog\/istio\/)来实现“非常有效的网络、策略执行和负载均衡功能”。另一个团队正在用[网络服务网格（Network Service Mesh）](https:\/\/github.com\/networkservicemesh\/networkservicemesh\/)将服务网格的概念映射到 L2\/L3 有效载荷，试图“以云原生的方式重新想象网络功能虚拟化（NFV）\u0022。\n\n其次，有多项举措将服务网格与公共云平台更紧密地结合在一起，从 [AWS App Mesh](https:\/\/www.infoq.com\/news\/2019\/01\/aws-app-mesh\/)、[GCP Traffic Director](https:\/\/www.infoq.com\/news\/2019\/04\/google-traffic-director\/) 和 [Azure Service Fabric Mesh 的](https:\/\/www.infoq.com\/articles\/azure-service-fabric-mesh\/)发布可见端倪。\n\nBuoyant 团队致力于为服务网格技术开发有效的以人为本的控制平面。他们最近发布了 [Buoyant Cloud](https:\/\/buoyant.io\/cloud\/)，一个基于 SaaS 的“团队控制平面”，用于平台团队操作 Kubernetes。这个产品将在下面的章节中详细讨论。\n\n自去年以来，在服务网格领域也有一些创新。\n\n### 多云、多集群、多租户服务网格\n\n近年来，不同组织对云的采用已经从单一的云解决方案（私有云或公共云）转变为由多个不同供应商（AWS、谷歌、微软 Azure 等）支持的基于多云（私有、公共和混合）的新基础设施。同时，需要支持不同的工作负载（交易、批处理和流媒体），这对实现统一的云架构至关重要。\n\n这些业务和非功能需求反过来又导致需要在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案。服务网格需要相应转变，以支持这些不同的工作负载和基础设施。\n\n像 [Kuma](https:\/\/konghq.com\/blog\/multi-cluster-multi-cloud-service-meshes-with-cncfs-kuma-and-envoy\/) 和 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 这样的技术支持多网格控制平面，以使业务应用在多集群和多云服务网格环境中工作。这些解决方案抽象出跨多个区域的服务网格策略的同步以及跨这些区域的服务连接（和服务发现）。\n\n多集群服务网格技术的另一个新趋势是需要从边缘计算层（物联网设备）到网格层的应用 \/ 服务连接。\n\n### 媒体服务网格\n\n思科系统公司开发的[媒体流网格（Media Streaming Mesh）](https:\/\/www.ciscotechblog.com\/blog\/introducing-media-streaming-mesh\/)或媒体服务网格，用于协调实时应用程序，如多人游戏、多方视频会议或在 Kubernetes 云平台上使用服务网格技术的 CCTV 流。这些应用正越来越多地从单体应用转向微服务架构。服务网格可以通过提供负载均衡、加密和可观测性等功能来帮助应用程序。\n\n### 混沌网格\n\n[Chaos Mesh](https:\/\/chaos-mesh.org\/) 是 [CNCF 托管的项目](https:\/\/community.cncf.io\/chaos-mesh-community\/)，是一个开源的、云原生的混沌工程平台，用于托管在 Kubernetes 上的应用程序。虽然不是直接的服务网格实现，但 Chaos Mesh 通过协调应用程序中的故障注入行为来实现混沌工程实验。故障注入是服务网格技术的一个关键能力。\n\nChaos Mesh 隐藏了底层的实现细节，因此应用开发者可以专注于实际的混沌实验。Chaos Mesh [可以和服务网格一起使用](https:\/\/chaos-mesh.org\/blog\/chaos-mesh-q\u0026a\/)。请看这个[用例](https:\/\/github.com\/sergioarmgpl\/operating-systems-usac-course\/blob\/master\/lang\/en\/projects\/project1v3\/project1.md)，该团队如何使用 Linkerd 和 Chaos Mesh 来为他们的项目进行混沌实验。\n\n### 服务网格作为一种服务\n\n一些服务网格供应商，如 Buoyant，正在提供管理服务网格或“服务网格作为一种服务“的解决方案。今年早些时候，Buoyant [宣布](https:\/\/buoyant.io\/newsroom\/buoyant-cloud-offers-managed-service-mesh\/)公开测试发布一个名为 [Buoyant Cloud 的](http:\/\/buoyant.io\/cloud) SaaS 应用程序，允许客户组织利用 Linkerd 服务网格的按需支持功能来管理服务网格。\n\nBuoyant Cloud 解决方案提供的一些功能包括如下：\n\n- 自动跟踪 Linkerd 数据平面和控制平面的健康状况\n- 在 Kubernetes 平台上管理跨 pod、代理和集群的服务网格生命周期和版本\n- 以 SRE 为重点的工具，包括服务水平目标（SLO）、工作负荷黄金指标跟踪和变更跟踪\n\n### 网络服务网格（NSM）\n\n网络服务网格（[NSM](https:\/\/networkservicemesh.io\/)）是云原生计算基金会的另一个沙盒项目，提供了一个混合的、多云的 IP 服务网格。NSM 实现了网络服务连接、安全和可观测性等功能，这些都是服务网格的核心特征。NSM 与现有的容器网络接口（[CNI](https:\/\/github.com\/containernetworking\/cni)）实现协同工作。\n\n### 服务网格扩展\n\n服务网格扩展是另一个已经看到很多创新的领域。服务网格扩展的一些发展包括：\n\n- 增强的身份管理，以确保微服务连接的安全，包括自定义证书授权插件\n- 自适应路由功能，以提高服务的可用性和可扩展性\n- 加强 sidecar 代理权\n\n### 服务网格业务\n\n采用服务网格的另一个重要领域是服务网格生命周期的运维方面。操作方面 —— 如配置多集群功能和将 Kubernetes 工作负载连接到虚拟机基础设施上托管的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户 —— 将在生产中服务网格解决方案的整体部署和支持方面发挥重要作用。\n\n## 常见问题\n\n### 什么是服务网格？\n\n服务网格是一种在分布式（可能是基于微服务的）软件系统内管理所有服务对服务（东西向）流量的技术。它既提供以业务为重点的功能操作，如路由，也提供非功能支持，如执行安全策略、服务质量和速率限制。它通常（尽管不是唯一的）使用 sidecar 代理来实现，所有服务都通过 sidecar 代理进行通信。\n\n### 服务网格与 API 网关有什么不同？\n\n关于服务网格的定义，见上文。\n\n另一方面，API 网关管理进入集群的所有入口（南北）流量，并为跨功能的通信要求提供额外支持。它作为进入系统的单一入口点，使多个 API 或服务凝聚在一起，为用户提供统一的体验。\n\n### 如果我正在部署微服务，我是否需要服务网格？\n\n不一定。服务网格增加了技术栈的操作复杂性，因此通常只有在组织在扩展服务与服务之间的通信方面遇到困难，或者有特定的用例需要解决时才会部署。\n\n### 我是否需要服务网格来实现微服务的服务发现？\n\n不，服务网格提供了实现服务发现的一种方式。其他解决方案包括特定语言的库（如 Ribbon 和 [Eureka](https:\/\/www.infoq.com\/news\/2012\/09\/Eureka\/) 或 [Finagle](https:\/\/www.infoq.com\/finagle\/)）。\n\n### 服务网格是否会给我的服务之间的通信增加开销 \/ 延迟？\n\n是的，当一个服务与另一个服务进行通信时，服务网格至少会增加两个额外的网络跳数（第一个是来自处理源的出站连接的代理，第二个是来自处理目的地的入站连接的代理）。然而，这个额外的网络跳转通常发生在 [localhost 或 loopback 网络接口](https:\/\/en.wikipedia.org\/wiki\/Localhost)上，并且只增加了少量的延迟（在毫秒级）。实验和了解这对目标用例是否是一个问题，应该是服务网格分析和评估的一部分。\n\n### 服务网格不应该是 Kubernetes 或应用程序被部署到的 \u0022云原生平台\u0022 的一部分吗？\n\n潜在的。有一种说法是在云原生平台组件内保持关注点的分离（例如，Kubernetes 负责提供容器编排，而服务网格负责服务间的通信）。然而，正在进行的工作是将类似服务网格的功能推向现代平台即服务（PaaS）产品。\n\n### 我如何实施、部署或推广服务网格？\n\n最好的方法是分析各种服务网格产品（见上文），并遵循所选网格特有的实施准则。一般来说，最好是与所有利益相关者合作，逐步将任何新技术部署到生产中。\n\n### 我可以建立自己的服务网格吗？\n\n是的，但更相关的问题是，你应该吗？建立一个服务网格是你组织的核心竞争力吗？你能否以更有效的方式为你的客户提供价值？你是否也致力于维护你自己的网络，为安全问题打补丁，并不断更新它以利用新技术？由于现在有一系列的开源和商业服务网格产品，使用现有的解决方案很可能更有效。\n\n### 在一个软件交付组织内，哪个团队拥有服务网格？\n\n通常，平台或运维团队拥有服务网格，以及 Kubernetes 和持续交付管道基础设施。然而，开发人员将配置服务网格的属性，因此这两个团队应该紧密合作。许多企业正在追随云计算先锋的脚步，如 Netflix、Spotify 和谷歌，并正在创建内部平台团队，为[以产品为重点的全周期开发团队](https:\/\/www.infoq.com\/news\/2018\/06\/netflix-full-cycle-developers\/)提供工具和服务。\n\n### Envoy 是一个服务网格吗？\n\nEnvoy 是一个云原生代理，最初是由 Lyft 团队设计和构建的。Envoy 经常被用作服务网格的数据平面。然而，为了被认为是一个服务网格，Envoy 必须与控制平面一起使用，这样才能使这些技术集合成为一个服务网格。控制平面可以是简单的集中式配置文件库和指标收集器，也可以是全面 \/ 复杂的 Istio。\n\n### Istio 和“服务网格 \u0022 这两个词可以互换使用吗？\n\n不，Istio 是服务网格的一种。由于 Istio 在服务网格类别出现时很受欢迎，一些人将 Istio 和服务网格混为一谈。这个混淆的问题并不是服务网格所独有的，同样的挑战发生在 Docker 和容器技术上。\n\n### 我应该使用哪个服务网格？\n\n这个问题没有唯一的答案。工程师必须了解他们当前的需求，以及他们的实施团队的技能、资源和时间。上面的服务网格比较链接将提供一个良好的探索起点，但我们强烈建议企业至少尝试两个网格，以了解哪些产品、技术和工作流程最适合他们。\n\n### 我可以在 Kubernetes 之外使用服务网吗？\n\n是的。许多服务网格允许在各种基础设施上安装和管理数据平面代理和相关控制平面。[HashiCorp 的 Consul](https:\/\/www.hashicorp.com\/resources\/consul-service-mesh-kubernetes-and-beyond) 是最知名的例子，Istio 也被实验性地用于 Cloud Foundry。\n\n## 其他资源\n\n- [InfoQ 服务网格主页](https:\/\/www.infoq.com\/servicemesh\/)\n- [InfoQ eMag：服务网格的过去、现在和未来](https:\/\/www.infoq.com\/minibooks\/service-mesh\/)\n- [服务网格：每位软件工程师都需要了解的世界上最容易被滥用的技术](https:\/\/servicemesh.io\/)\n- [服务网格的比较](https:\/\/servicemesh.es\/)\n- [服务网格](https:\/\/softwareengineeringdaily.com\/2020\/01\/07\/service-meshes\/)\n- [采用云原生架构，第三部分：服务协调和服务网格](https:\/\/www.infoq.com\/articles\/cloud-native-architecture-adoption-part3\/)\n', '\/trans\/service-mesh-ultimate-guide-e2\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 InfoQ 自 2020 年 2 月发表的服务网格终极指南后的第二版，发布于 2021 年 9 月。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-unnecessary-complexity/">[译] 远离复杂性——服务网格需要更加务实</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/service-mesh-unnecessary-complexity/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('远离复杂性——服务网格需要更加务实', '服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。', '\n## 主要收获\n\n- 采用服务网格有巨大的价值，但必须以轻便的方式进行，以避免不必要的复杂性。\n- 在实施服务网格时，要采取务实的方法，与技术的核心功能保持一致，并注意分散注意力的问题。\n- 服务网格的一些核心特征包括标准化监控、自动加密和身份识别、智能路由、可靠的重试和网络可扩展性。\n- 服务网格可以提供强大的功能，但这些功能可能会分散对核心利益的注意力，并不被视为实施服务网格的主要原因。\n- 一些值得注意的分心，可能对你的初始实施没有必要，包括复杂的控制平面、多集群支持、Envoy、WASM 和 A\/B 测试。\n\n服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。服务网格的采用受到了巨大的复杂性和似乎无穷无尽的供应商解决方案的限制。在我自己浏览了这个领域后，我发现采用服务网格有巨大的价值，但必须以轻量级的方式进行，以避免不必要的复杂性。尽管普遍存在幻灭感，但服务网格的前景依然光明。\n\n## 在工作中学习\n\n我进入服务网格的世界，始于我在一家历史悠久的财富 500 强科技公司担任云计算架构师。在我们的服务网格旅程开始时，我身边有许多强大的工程师，但大多数人几乎没有云开发的经验。我们的组织诞生于云计算之前，要完全实现云计算的价值需要时间。我们的传统业务线主要集中在技术堆栈的硬件元素上，而云计算的决策最初是由为运送硬件或为这些硬件提供固件和驱动程序而开发的流程所驱动。 \n\n随着这个组织经历了 \u0022数字化转型\u0022，它越来越依赖于提供高质量的软件服务，并逐渐形成了更好的方法论。但是，作为云计算架构师，我仍然在为优先考虑硬件的业务流程和具有不同技能组合、流程和信念的工程团队而奔波。随着时间的推移，我和我的团队在将.NET 应用程序迁移到 Linux、采用 Docker、迁移到 AWS 以及与之相关的最佳实践（如持续集成、自动部署、不可变基础设施、基础设施即代码、监控等）方面变得熟练和成功，但挑战仍然存在。\n\n在这段时间里，我们开始将我们的应用程序分割成一系列的微服务。起初，这是一个缓慢的转变，但最终这种方法流行起来，开发人员开始喜欢建立新的服务而不是增加现有的服务。我们这些基础设施团队的人把这看作是一种成功。唯一的问题是，与网络有关的问题数量激增，开发人员正在向我们寻求答案，而我们还没有准备应用这种冲击。\n\n## 服务网格拯救了我们\n\n我第一次听说服务网格是在 2015 年，当时我正在研究服务发现工具，并寻找与 Consul 集成的简单方法。我很喜欢把应用责任下沉到 \u0022sidecar\u0022容器的想法，并找到了一些可以做到这一点的工具。大约在这个时候，Docker 有一个叫做 \u0022linking\u0022的功能，让你把两个应用程序放在一个共享的网络空间中，这样它们就可以通过本地主机进行通信。这个功能提供了一个类似于我们现在在 Kubernetes pod 内的体验。两个独立构建的服务可以在部署时进行组合，以实现一些额外的功能。\n\n我总是抓住机会用简单的解决方案来解决大问题，所以这些新功能的力量立即打动了我。虽然这个工具是为了与 Consul 集成，但在实践中，它可以做任何你想要的事情。它是我们拥有的基础设施的一个新的层级，可以用来为每个人解决问题。\n\n这方面的一个具体例子是在我们采用过程的早期。当时，我们正在努力使许多不同服务的日志输出标准化。通过采用服务网格和这种新的设计模式，我们能够把我们的人的问题——让开发人员标准化他们的日志，转变成技术问题——把所有的服务流量通过一个可以为他们做日志记录的代理。这对我们的团队来说是一个重大的进步。\n\n我们对服务网格的实施是非常务实的，并与该技术的核心功能保持一致。然而，许多营销炒作可能集中在不太需要的边缘案例上，在评估服务网格是否适合你时，能够识别这些干扰是很重要的。\n\n## 核心功能\n\n服务网格可以提供的核心功能分为四个关键责任领域：可观测性、安全性、连接性和可靠性。\n\n## 标准化的监控\n\n这是我们最成功的地方之一，也是最简单的采用，就是标准化的监测。它的运营成本很低，而且可以被制作成适合你使用的任何监控系统。它使企业能够捕获他们所有的 HTTP 或 gRPC 指标，并在整个系统中以标准方式存储它们。这就控制了复杂性，减轻了应用团队的负担，他们不再需要实施 Prometheus 指标端点或标准化日志格式。它还使用户能够对其应用程序的[黄金信号](https:\/\/sre.google\/sre-book\/monitoring-distributed-systems\/#xref_monitoring_golden-signals)有一个公正的看法。 \n\n**自动加密和身份识别**\n\n证书管理是很难做好的。如果一个组织还没有在这方面投资，他们应该找一个网格来为他们做这件事。证书管理需要维护复杂的基础设施代码，具有巨大的安全影响。相比之下，网格将能够与编排系统集成，了解工作负载的身份，在需要时可以用来执行策略。这允许一个真正强大的安全态势，相当于或优于那些由 Calico 或 Cilium 等功能丰富的 CNI 提供的安全态势。\n\n## 智能路由\n\n智能路由是另一项功能，使网格在发送请求时能 \u0022做正确的事\u0022。应用如下：\n\n1. 使用延迟加权算法优化流量\n2. 拓扑感知路由，提高性能并降低成本\n3. 根据请求成功的可能性来确定时间\n4. 与编排系统集成以实现 IP 解析，而不是依赖 DNS\n5. 传输升级，如 HTTP 到 HTTP\/2\n\n这些功能可能不会让普通人感到兴奋，但随着时间的推移，它们带来了更多的价值。\n\n## 可靠的重试\n\n在分布式系统中重试请求可能很麻烦，然而，这总是需要实施的。分布式系统通常会将一个客户端请求转换为下游的许多请求，这意味着 \u0022尾巴\u0022情况的可能性大大增加，例如发生异常的失败请求。对此，最简单的缓解措施是重试失败的请求。\n\n困难来自于避免 \u0022重试风暴\u0022或 \u0022重试 DDoS\u0022，即当一个处于退化状态的系统触发重试时，随着重试的增加，负载增加，性能进一步下降。一个天真的实现不会考虑到这种情况，因为它可能需要与缓存或其他通信系统集成，以知道重试是否值得执行。服务网格可以通过提供整个系统允许的重试总数的约束来做到这一点。服务网格还可以在这些重试发生时进行报告，有可能在你的用户注意到之前提醒你系统的退化。\n\n## 网络可扩展性\n\n也许服务网格的最佳属性是其可扩展性。它提供了一个额外的适配层，可以承担 IT 部门接下来的任何工作。Sidecar 代理的设计模式是另一个令人兴奋和强大的功能，即使它有时被过度宣传和过度设计来做用户和技术还没有准备好的事情。当社区在等待哪个服务网格\u0022胜出\u0022时，这反映了之前被过度炒作的编排战争，我们将不可避免地在未来看到更多专门的网格，而且很可能有更多的最终用户建立自己的控制平面和代理来满足他们的使用情况。\n\n## 服务网格分心\n\n平台或基础设施控制层的价值怎么强调都不过分。然而，在服务网格的世界中，我了解到一个主要的挑战是，服务网格所解决的核心问题往往甚至不是大多数服务网格项目的沟通重点。\n\n相反，许多来自服务网格项目的沟通都是围绕着那些听起来很强大或令人兴奋的功能，但最终却让人分心。包括以下内容。\n\n## 强大（复杂）的控制平面\n\n要很好地运行复杂的软件是非常困难的。这就是为什么如此多的组织使用云计算，使用完全托管的服务。那么，为什么服务网格项目会让我们负责运行如此复杂的系统？系统的复杂性不是一种资产，而是一种责任，然而大多数项目都在吹嘘他们的功能集和可配置性。\n\n## 多集群支持\n\n多集群是现在的一个热门话题。大多数团队最终都会运行多个 Kubernetes 集群。但多集群的主要痛点是你的 Kubernetes 管理网络被分割成两半。服务网格帮助解决这个 Kubernetes 的扩展问题，但它最终并没有实现任何新的东西。是的，多集群支持是必要的，但它对服务网格的承诺被过度宣传了。\n\n## Envoy\n\nEnvoy 是一个伟大的工具，但它被当作某种标准来介绍，这是有问题的。Envoy 是许多开箱即用的代理之一，你可以在此基础上建立一个服务网格平台。但是，Envoy 并没有什么内在的特别之处，使它成为正确的选择。采用 Envoy 会给你的组织带来一系列重要的问题，包括：\n\n- 运行时间成本和性能（所有这些过滤器加起来）\n- 计算资源要求以及如何随负载变化而变化\n- 如何调试错误或意外行为\n- 你的网格如何与 Envoy 进行交互，以及配置的生命周期是什么\n- 运作成熟的时间（这可能比你预期的要长）\n\n服务网格中代理的选择应该是一个实施细节，而不是一个产品要求。\n\n## WASM\n\n我是 Web Assembly（WASM）的忠实粉丝，曾成功地用它在[Blazor](https:\/\/dotnet.microsoft.com\/apps\/aspnet\/web-apps\/blazor)中构建前端应用程序。然而，WASM 作为定制服务网格代理行为的工具，使你完全陷入了获得全新的软件生命周期开销的境地，这与你现有的软件生命周期是完全分离的。如果你的组织还没有准备好构建、测试、部署、维护、监控、回滚和版本代码（影响通过其系统运行的每个请求），那么你还没有准备好使用 WASM。\n\n## A\/B 测试\n\n当我意识到 A\/B 测试实际上是一个应用程序级别的问题已经太晚了。在基础设施层提供基元来实现它是可以的，但没有简单的方法来完全自动化大多数组织需要的 A\/B 测试水平。通常情况下，应用程序需要定义独特的指标，以确定测试的积极信号。如果一个组织想在服务网格层实施 A\/B 测试，以下是解决方案需要支持的内容：\n\n1. 对部署和回滚的精细控制，因为很可能有多个不同的 \u0022测试\u0022在同一时间进行\n2. 能够捕获系统知道的自定义指标，并能根据这些指标做出决定\n3. 根据请求的特点暴露出对流量方向的控制，这可能包括解析整个请求主体\n\n这是很难实现的，而且没有一个服务网格能做到开箱即用。最终，我们的组织选择了一个网格之外的功能标记解决方案，它以最小的努力取得了巨大的成功。\n\n## 我们终将走向何方\n\n最终，我们所面临的挑战并不是服务网格所独有的。我们工作的组织有一系列的限制条件，要求我们对解决的问题和解决的方式采取务实的态度。我们面临的问题包括： \n\n- 拥有大量不同技能的开发人员的大型组织\n- 一般来说，云计算和 SaaS 能力不成熟\n- 为非云计算软件优化的流程\n- 分散的软件工程方法和信念\n- 资源有限\n- 咄咄逼人的最后期限 \n\n简而言之，我们人少，问题多，而且需要快速展示价值。我们必须支持那些主要不是网络或云计算的开发者，我们需要扩大规模以支持大型工程组织，这些组织有不同的方法和流程来做云计算的事情。我们需要把大部分精力放在解决成熟度曲线上低的基本问题上。\n\n最后，当我们面临自己的服务网格决定时，我们决定建立在[Linkerd 服务网格](https:\/\/linkerd.io\/)之上，因为它最符合我们的优先事项：低运营成本（包括计算和人力）、低认知开销、支持性社区和透明的管理，同时满足我们的功能要求和预算。在 Linkerd 指导委员会呆了很短的时间（他们喜欢诚实的反馈和社区参与），我了解到它与我自己的工程原则是多么的吻合。Linkerd 最近[在 CNCF](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)达到了[毕业状态](https:\/\/www.cncf.io\/announcements\/2021\/07\/28\/cloud-native-computing-foundation-announces-linkerd-graduation\/)，这是一个漫长的过程，强调了项目的成熟度以及它的广泛采用。\n\n## 关于作者\n\n**Chris Campbell** 从事软件工程师和架构师工作超过十年，与多个团队和组织合作，采用云原生技术和最佳实践。他的工作时间分为两部分，一部分是与企业领导合作，采用软件交付策略来加速业务发展，另一部分是与工程团队合作，提供可扩展的云基础设施。他最感兴趣的是能提高开发人员生产力和体验的技术。\n', '\/trans\/service-mesh-unnecessary-complexity\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格是 Kubernetes 世界中的一个热门话题，但许多潜在的采用者已经失去了耐心。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-servicemesh-api-gateway/">如何理解 Istio Ingress，它与 API Gateway 有什么区别？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio Ingress，它与 API Gateway 有什么区别？', '服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。', '\nAPI 网关作为客户端访问后端的入口，已经存在很长时间了，它主要是用来管理”南北向“的流量；近几年服务网格开始流行，它主要是管理系统内部，即“东西向”流量，而像 Istio 这样的服务网格还内置了网关，从而将系统内外部的流量纳入了统一管控。这经常给初次接触 Istio 的人带来困惑——服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。\n\n## 主要观点\n\n- 服务网格诞生的初衷是为了解决分布式应用的内部流量的管理问题，而在此之前 API 网关已存在很久了。\n- 虽然 Istio 中内置了 Gateway，但是你仍可以使用自定义的 Ingress Controller 来代理外部流量。\n- API 网关和服务网格正朝着融合的方向发展。\n\n## 如何暴露 Istio mesh 中的服务？\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![暴露 Kubernetes 中服务的几种方式](access-cluster.svg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n| 方式                  | 控制器             | 功能                                                         |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n由于 NodePort\/LoadBalancer 是 Kubernetes 内置的基本的暴露服务的方式，本文就不讨论这种方式了。下文将对其他三种方式分别作出说明。\n\n## 使用 Kubernetes Ingress 暴露服务\n\n我们都知道 Kubernetes 集群的客户端是无法直接访问 Pod 的 IP 地址的，因为 Pod 是处于 Kubernetes 内置的一个网络平面中。我们可以将 Kubernetes 内的服务使用 NodePort 或者 LoadBlancer 的方式暴露到集群以外。同时为了支持虚拟主机、隐藏和节省 IP 地址，可以使用 [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来暴露 Kubernetes 中的服务。Kubernetes Ingress 原理如下图所示。\n\n![使用 Kubernetes Ingress 暴露服务](ingress.svg)\n\n简单的说，Ingress 就是从 Kubernetes 集群外访问集群的入口，将用户的 URL 请求转发到不同的服务上。Ingress 相当于 Nginx、Apache 等负载均衡方向代理服务器，其中还包括规则定义，即 URL 的路由信息，路由信息得的刷新由 [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers)来提供。\n\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\n上面的例子中的 \u0060kubernetes.io\/ingress.class: istio\u0060 注解表明该 Ingress 使用的 Istio Ingress Controller。 \n\n## 使用 Istio Gateway 暴露服务\n\n我们都知道 Istio 是继承 Kubernetes 之后发展出来的一个流行的服务网格实现，它实现了 Kubernetes 没有的一些功能，请参考[什么是 Istio？为什么 Kubernetes 需要 Istio？](https:\/\/jimmysong.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)简要来说，正是因为 Istio 补足了 Kubernetes 对于云原生应用的流量管理、可观测性和安全方面的短板，使得流量管理变得对应用程序透明，使这部分功能从应用程序中转移到了平台层，成为了云原生基础设施。\n\nIstio 0.8 以前版本中使用 Kubernetes [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来作为流量入口，其中使用 Envoy 作为 Ingress Controller。在 Istio 0.8 及以后的版本中，Istio 创建了 Gateway 对象。Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 sidecar 相同的 Envoy 代理。通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、遥测收集以及其他服务管控功能。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。\n\nIstio Gateway 资源本身只能配置 L4 到 L6 的功能，例如暴露的端口、TLS 设置等；但 Gateway 可与 VirtualService 绑定，在 VirtualService 中可以配置七层路由规则，例如按比例和版本的流量路由，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。\n\n下面是一个 Gateway 与 VirtualService 绑定的示例。拥有 \u0060istio: ingressgateway\u0060 标签的 pod 将作为 Ingress Gateway 并路由对 \u0060httpbin.example.com\u0060 虚拟主机的 80 端口的 HTTP 访问，这相当于给 Kubernetes 敞开了一个外部访问的入口。这与使用 Kubernetes Ingress 最大的区别就是，需要我们手动将 VirtualService 与 Gateway 绑定，并指定 Gateway 所在的 pod。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\n下面这个 VirtualService 通过 \u0060gateways\u0060 与上面的网关绑定在了一起，以接受来自该网关的流量。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## 使用 API 网关暴露服务\n\nAPI 网关是位于客户端和后端服务之间的 API 管理工具，一种将客户端接口与后端实现分离的方式，在微服务中得到了广泛的应用。当客户端发出请求时，API 网关会将其分解为多个请求，然后将它们路由到正确的位置，生成响应，并跟踪所有内容。\n\nAPI Gateway 是微服务架构体系中的一类型特殊服务，它是所有微服务的入口，它的职责是执行路由请求、协议转换、聚合数据、认证、限流、熔断等。大多数企业 API 都是通过 API 网关部署的。API 网关通常会处理跨 API 服务系统的常见任务，例如用户身份验证、速率限制和统计信息。\n\n在网格中可以有一个或多个 API Gateway。API 网关的职责有：\n\n- 请求路由和版本控制\n- 方便单体应用到微服务的过渡\n- 权限认证\n- 数据聚合：监控和计费\n- 协议转换\n- 消息和缓存\n- 安全和报警\n\n以上很多基本功能比如路由和权限认证通过 Istio Gateway 也可以实现，只是在功能的丰富度和扩展性方面有些成熟的 API Gateway 可能更占优势，不过在 Istio mesh 中再引入 API Gateway 也可能带来一些弊端。\n\n- 引入了 API Gateway，需要考虑 API Gateway 本身的部署、运维、负载均衡等场景，增加了后端服务的复杂度\n- API Gateway 中承载了大量的接口适配，导致难以维护\n- 对于部分场景，增加了一跳可能导致性能的降低\n\n## 总结\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 生命周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 [Nginx Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)，Traefik 构建了 [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 [Kuma](https:\/\/kuma.io)。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n## 参考\n\n- [利用 Gateway API 发展 Kubernetes 网络](https:\/\/cloudnative.to\/blog\/evolving-kubernetes-networking-with-the-gateway-api\/)\n- [如何为服务网格选择入口网关？](https:\/\/cloudnative.to\/blog\/how-to-pick-gateway-for-service-mesh\/)\n- [Service Mesh 和 API Gateway 关系深度探讨](https:\/\/cloudnative.to\/blog\/service-mesh-and-api-gateway\/)\n- [在 Istio 服务网格中使用 Traefik Ingress Controller](https:\/\/cloudnative.to\/blog\/using-traefik-ingress-controller-with-istio-service-mesh\/)\n', '\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/top-service-mesh-pk/">[译] 服务网格联网：使用案例、最佳实践和顶级服务网格选择比较</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://cncf.io/blog/2021/07/15/networking-with-a-service-mesh-use-cases-best-practices-and-comparison-of-top-mesh-options" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格联网：使用案例、最佳实践和顶级服务网格选择比较', '服务网格大 PK。', '\n服务网格技术是随着微服务结构的普及而出现的。由于服务网格促进了网络与业务逻辑的分离，它使你能够专注于你的应用程序的核心竞争力。\n\n微服务应用程序分布在多个服务器、数据中心或大陆上，使它们高度依赖网络。服务网格通过用路由规则和服务间包的动态方向控制流量来管理服务间的网络流量。\n\n在这篇文章中，我们将研究使用案例，比较顶级网格选项，并讨论最佳做法。\n\n让我们从使用服务网格的最常见场景开始。\n\n## 使用案例\n\n服务网格是一种连接微服务和管理它们之间流量的架构方法。它们在一个组织的许多层面上被大量用于生产。因此，有一些标准化的、被广泛接受的用例。\n\n### 可观测性\n\n假设你有一个后端服务的实例响应缓慢，在你的整个堆栈中造成了一个瓶颈。然后，来自前端服务的请求将超时，并重新尝试连接到缓慢的服务实例。在服务网格的帮助下，你可以使用一个断路器，确保前端实例只与健康的后端实例连接。因此，使用服务网格可以提高堆栈的可见性，并帮助你排除问题。\n\n### 部署策略\n\n部署策略（蓝\/绿部署、金丝雀等）正在成为发布云原生应用升级的规范。服务网格允许部署策略，因为大多数部署策略都是基于将流量转移到特定实例。例如，你可以在服务网格中创建流量规则，以便只有一小部分用户（比如 10%）会接触到新版本。\n\n如果一切按预期进行，你可以将所有流量转移到最新版本，完成你的金丝雀部署。也建议检查[Kubernetes 的内部部署策略](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/controllers\/deployment\/#strategy)，并与你的应用程序的要求相匹配。\n\n### 测试 \n\n为了保持你的生产堆栈的安全性，最好通过测试延迟、超时和灾难恢复来加固它们。\n\n服务网格允许你通过延迟和不正确的响应在系统中制造混乱来测试其稳健性。例如，通过在服务网格流量规则中注入延迟，你可以测试当你的数据库对其查询响应缓慢时，前端和后端将如何表现。\n\n### API 网关\n\nAPI 网关是 server-client 的设计模式，它使得从一个单一的入口点管理 API 成为可能。在服务网格的帮助下，你可以使用同样的方法进行服务间的通信，并在你的集群中创建复杂的 API 管理方案。建议你查看[Gateway API](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/)，以便在即将到来的 Kubernetes 版本中把这些想法纳入本地 Kubernetes 资源。\n\n服务网格作为 \u0022智能 \u0022胶水，通过流量策略、限制和测试功能动态地连接微服务。随着服务网格的日益普及，许多新的、被广泛接受的用例将加入上述的用例。\n\n现在让我们来看看现有的顶级服务网格软件的优点和缺点。\n\n## 顶级网格选项的比较\n\n虽然每次会议上总有一些初创公司推出花哨的服务网格产品，但在云原生世界中，只有三个顶级网格选项被广泛使用。Istio、Linkerd 和 Consul Connect。它们都是拥有活跃社区的开源产品。基于他们的愿景和实施，他们也都有各自的优点和缺点。\n\n### Istio\n\n[Istio](https:\/\/istio.io)是一个 Kubernetes 原生的服务网格，最初由 Lyft 开发，并在业界被广泛采用。领先的云 Kubernetes 供应商，如谷歌、IBM 和微软，都将 Istio 作为其服务的默认服务网格。Istio 提供了一套强大的功能来创建服务之间的连接，包括请求路由、超时、断路和故障注入。此外，Istio 通过延迟、流量和错误等指标对应用程序进行深入了解。\n\n**优点**\n\n最活跃的社区，业界采用率高，与 Kubernetes 和虚拟机一起使用。\n\n**缺点**\n\n学习曲线陡峭，对集群有很大的开销，没有本地管理仪表板。\n\n### Linkerd\n\nLinkerd 是第二大流行的服务网格，是云原生计算基金会（CNCF）的一部分。\n\n从架构的角度来看，Linkerd 类似于 Istio，但有更多的灵活性。这种灵活性来自于可插拔架构的多个维度。例如，在连接方面，Linkerd 与最流行的入口控制器一起工作，如 Nginx、Traefik 或 Kong。同样，除了它自己的 GUI，它还与 Grafana、Prometheus 和 Jaeger 合作，以实现可观测性。 \n\n**优点**\n\n文档和简单的安装，在行业中得到采用，和企业支持。\n\n**缺点**\n\n只适用于 Kubernetes，不支持虚拟机缺少一些网络路由功能，如断路或速率限制。\n\n## Consul Connect\n\nConsul 是分布式应用中最流行的服务发现和键\/值存储，直到其母公司 HashiCorp 以 Consul Connect 的名义转换为服务网格。\n\n因此，Consul Connect 有一个混合架构，在应用程序旁边有 Envoy sidecar，其控制平面和键\/值存储是用 Go 开发的。从连接性和安全性的角度来看，Consul Connect 与它的替代品相比并没有提供突出的功能。然而，它的配置和复杂性较低，使得它更容易上手--就像云原生世界中的其他 HashiCorp 工具一样。\n\n**优点**\n有 HashiCorp 的支持和企业级支持的可用性，可以与虚拟机和 Kubernetes 一起工作。\n\n**缺点**\n\n开源社区有限，缺乏完整和易于理解的文档。\n\n下面的图表提供了这三大解决方案之间关键差异的概述。\n\n| 对比项                     | Istio                    | Linkerd    | Consul Connect           |\n| -------------------------- | ------------------------ | ---------- | ------------------------ |\n| 支持的平台                 | Kubernetes 和虚拟机      | Kubernetes | Kubernetes 和虚拟机      |\n| 支持的 Ingress 控制器      | Istio ingress            | 任意       | Envoy                    |\n| 流量管理功能               | 蓝绿部署、断路和速率控制 | 蓝绿部署   | 蓝绿部署、断路和速率控制 |\n| Prometheus 和 Grafana 支持 | 是                       | 是         | 否                       |\n| 混沌测试                   | 是                       | 是         | 否                       |\n| 管理复杂度                 | 高                       | 低         | 中                       |\n| 原生 GUI                   | 否                       | 是         | 是                       |\n\n## 最佳实践和挑战\n\n服务网格使你的集群和应用中的服务间通信标准化和自动化。然而，由于产品的复杂性和基础设施的不同，服务网格产品并不简单。在使用服务网格时，以下关于挑战和最佳实践的说明将为你提供一些有用的指导。\n\n### 自动化\n\n服务网格的配置包括流量规则、速率限制和网络设置。该配置可以帮助你从头开始安装，升级版本，以及在集群之间迁移。因此，建议把配置当作代码来处理，并遵循 GitOps 的方法和持续部署管道。\n\n服务网格产品在拥有大量服务器的少数集群中工作得更好，而不是拥有较少实例的许多集群。因此，建议尽可能地减少冗余集群，使你能够利用简单的操作和集中配置的服务网格方法。\n\n### 监控和请求跟踪\n\n服务网格产品是复杂的应用，管理着更复杂的分布式应用的流量。因此，指标收集、可视化和仪表板对系统的可观测性至关重要。利用 Prometheus 或 Grafana 或您的服务网格提供的任何其他集成点，根据您的要求创建警报。\n\n### 安全性\n\n大多数服务网格产品，包括前三名，都实现了一套基本的安全功能：mTLS、证书管理、认证和授权。你还可以定义和执行网络策略，以限制集群中运行的应用程序之间的通信。\n\n不过，应该注意的是，定义网络策略不是一项简单的任务。你需要覆盖当前运行的应用程序的所有场景，并考虑未来的可扩展性。因此，利用服务网格的网络策略对用户来说并不友好，容易出现错误和安全漏洞。\n\n然而，利用服务网格来创建安全的网络策略有几个缺点。\n\n首先，用户必须准确定义集群所需要的策略——在微服务激增和不断变化的环境中，这是一项不容易的任务。因此，服务网格的策略需要经常改变，如果一个微服务改变其行为，可能会破坏生产。  \n\n其次，根据设计，服务网格使用 sidecar 代理来控制策略，所以任何从容器中出来的连接都会被自动视为合法流量，如果攻击者闯入一个容器，他们会自动继承该容器的网络身份，从而可以做任何原始容器可以做的事情。\n\n最后，由于每个连接都要经过代理，用户在集群中使用它来加密流量时，会看到明显的性能下降。\n\n总结一下：服务网格解决方案并不关心谁在发送或接收数据。只要网络策略允许，任何恶意的或配置错误的应用程序都可以检索你的敏感数据。因此，考虑开销更少、可操作性更强的整体方法至关重要，而不是盲目地只相信服务网格产品的安全措施。\n\n## 总结\n\n服务网格以动态、安全和可扩展的方式连接分布式微服务。目前有广泛接受的用例和实现这些用例的顶级产品。然而，由于云基础设施和应用需求高度复杂，服务网格不是银弹。\n\n当涉及到安全问题时，保护应用程序和运行时环境不在服务网格产品的范围内，而且仅仅为了安全而安装一个服务网格是矫枉过正的，因为它在集群中产生了很高的开销。\n', '\/trans\/top-service-mesh-pk\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格大 PK。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/multicluster-management-with-kubernetes-and-istio/">服务网格之旅——使用 Kubernetes 和 Istio Service Mesh 构建混合云</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格之旅——使用 Kubernetes 和 Istio Service Mesh 构建混合云', '这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。', '\n这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。\n\n## Kubernetes\n\n使用 Kubernetes 可以快速部署一个分布式环境，实现了云的互操作性，统一了云上的控制平面。并提供了 Service、Ingress 和 [Gateway](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/) 等资源对象来处理应用程序的流量。如下图所示，Kubernetes 中默认使用 Service 做服务注册和发现，服务之间可以使用服务名称来访问。Kubernetes API Server 与集群内的每个节点上的 \u0060kube-proxy\u0060 组件通信，为节点创建 iptables 规则，并将请求转发到其他 pod 上。\n\n假定现在客户端要访问 Kubernetes 中的服务，首先请求会发送到 Ingress\/Gateway 上，然后根据 Ingress\/Gateway 里的路由配置转发到后端服务上（图中是服务 A），接着服务 A 对服务 B 请求的流量转发轮询到服务 B 的实例上。\n\n![Kubernetes](008i3skNly1gsgg6a11l1j31lu0u042s.jpg)\n\n## Kubernetes 多集群管理\n\n多集群管理最常见的使用场景包括服务流量负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复、灵活分配计算资源、跨区域服务的低延迟访问以及避免厂商锁定等。一个企业内部往往有多个 Kubernetes 集群，由 MultiCluster SIG 开发的 KubeFed 实现 Kubernetes 集群联邦可以实现多集群管理的功能，这使得所有 Kubernetes 集群都通过同一个接口来管理。\n\n在使用集群联邦时需要解决以下几个通用问题：\n\n- 配置需要联邦哪些集群\n- 需要在集群中传播的 API 资源\n- 配置 API 资源如何分配到不同的集群\n- 对集群中 DNS 记录注册以实现跨集群的服务发现\n\n下面是 KubeSphere 的多集群架构，也是最常用的一种 Kubernetes 多集群管理架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。\n\n![Multicluster](008i3skNly1gsgg7a2ojvj31aa0u0491.jpg)\n\nHost 集群需要能够访问 Member 集群的 API Server，Member 集群之间的网络连通性没有要求。管理集群 Host Cluster 独立于其所管理的成员集群，Member Cluster 并不知道 Host Cluster 存在，这样做的好处是当控制平面发生故障时不会影响到成员集群，已经部署的负载仍然可以正常运行，不会受到影响。\n\nHost 集群同时承担着 API 入口的作用，由 Host Cluster 将对 Member 集群的资源请求转发到 Member 集群，这样做的目的是方便聚合，而且也利于做统一的权限认证。我们看到在 Host Cluster 中有联邦控制平面，其中的 Push Reconciler 会将联邦集群中身份、角色及角色绑定传播到所有成员集群中。\n\n## Istio\n\n当我们在 Kubernetes 中运行着多语言、多版本的微服务，并需要更细粒度的金丝雀发布和统一的安全策略管理，实现服务间的可观测性时，可以考虑使用 Istio 服务网格。Istio 通过向应用程序 Pod 中注入 sidecar proxy，缺省使用 IPTables 透明得拦截进出应用程序的所有流量，从而实现了应用层到集群中其他启用服务网格的服务的智能应用感知负载均衡，并绕过了初级的 kube-proxy 负载均衡。Istio 控制平面与 Kubernetes API Server 通信可以获取集群中所有注册的服务信息。\n\n下图展示了 Istio 的基本原理，其中所有节点属于同一个 Kubernetes 集群。\n\n![Istio Service Mesh](008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg)\n\n你可能最终会有至少几个 Kubernetes 集群，每个集群都承载着微服务。Istio 的多集群部署根据网络隔离、主备情况存在多种[部署模式](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/)，可以使用 Istio Operator 部署时通过声明来指定。集群中的这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供通用的通信模式，以提高弹性、安全性和可观测性。\n\n以上都是关于 Kubernetes 上的应用负载管理，但是对于虚拟机上遗留应用，如何在同一个平面中管理？如何管理多集群中的流量划分、网关和安全性呢？\n\n## 管理平面\n\n在 Istio 之上再增加一层抽象，将网关、流量和安全分组管理，并将它们应用到不同的集群和命名空间上。下图展示的是 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 的多租户模型，利用 NGAC 来管理用户的访问权限，同时也有利于构建零信任网络。\n\n![Management Plane](008i3skNly1gsgg8ndcajj31il0u00z9.jpg)\n\nIstio 提供了工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好。在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。\n\n下图展示的是 Tetrate Service Bridge 的架构图。\n\n![Tetrate Service Bridge](008i3skNly1gsgg951mknj314g0u0dnf.jpg)\n\n## 总结\n\n使用 Kubernetes 实现了异构集群的互操作性，Istio 将容器化负载和虚拟机负载纳入到一个同一个控制平面内，统一管理集群内的流量、安全和可观测性。但是，随着集群数量、网络环境和用户权限的越发复杂，人们还需要在 Istio 的控制平面至上再构建一层管理平面来进行混合云管理。\n', '\/blog\/multicluster-management-with-kubernetes-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将带你了解使用 Kubernetes 和 Istio Service Mesh 构建多集群及混合云的过程和需要考虑的问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/">如何调试 Kubernetes 中的微服务 ——proxy、sidecar 还是 service mesh？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/07/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何调试 Kubernetes 中的微服务 ——proxy、sidecar 还是 service mesh？', '本文讲解了调试 Kubernetes 中微服务的三种模式\/工具，以及 Istio 的引入为微服务的调试带来的变革。', '\nKubernetes 可以说是目前为止用来运行微服务的最佳载体，但是在调试 Kubernetes 环境中的微服务时的体验可能就没那么友好了。本文将带你了解如何调试 Kubernetes 中的微服务，介绍常用的工具，以及 Istio 的引入为微服务的调试带来的变革。\n\n## 调试微服务与传统单体应用有巨大的不同\n\n微服务的调试是一直长期困扰软件开发人员的问题，这在传统的单体应用中不存在，因为开发者可以利用 IDE 中的调试器，为应用程序增加断点、修改环境变量，单步执行等，这些都为软件调试提供了巨大帮助。随着 Kubernetes 的流行，微服务的调试就成了一个棘手的问题，其中相比传统单体应用的调试多了以下问题：\n\n### 多依赖\n\n一个微服务往往依赖多个其他微服务，在调试某个微服务时，如何部署其他依赖服务以快速搭建一套最新的 stagging 环境？\n\n### 从本地机器访问\n\n微服务在开发者的本地电脑上运行时，通常无法直接访问到 Kubernetes 集群中的服务，如何像调试本地服务一样调试部署在 Kubernetes 集群中的微服务？\n\n### 开发效率低下\n\n通常情况下，代码从更新到构建成镜像再推送到集群中需要一个漫长的过程，如何加快开发速度？\n\n我们一起来看下哪些工具能够解决以上问题。\n\n## 工具\n\n调试 Kubernetes 中的微服务的主要解决方案有：\n\n- Proxy：在 Kubernetes 集群和本地调试终端中部署一个代理，通过构建一个 VPN，使得本地应用可以直接访问到 Kubernetes 中的服务；\n- Sidecar：替换原来应用容器的镜像为开发镜像，可以在这个容器中中对该服务进行调试，同时在要调试的微服务 pod 中注入一个 sidecar 作为辅助工具来同步代码；\n- 服务网格：要想了解应用的整体情况，就需要在所有微服务中注入 sidecar，这样你就可以获得一个监控全局状态的仪表板；\n\n下面是实现以上解决方案的三个典型的开源项目，它们分别从不同的角度可以帮助你调试微服务。\n\n### Proxy 模式：Telepresence\n\n[Telesprence](https:\/\/www.telepresence.io\/) 本质上是一个本地代理，该代理将 Kubernetes 集群中的数据卷、环境变量、网络都代理到了本地。下图展示的是 Teleprence 的主要使用场景。\n\n![Proxy 模式：Telepresence](telepresence.jpg)\n\n用户需要在本地自主地执行 \u0060telepresence\u0060 命令，它会自动将代理部署到 Kubernetes 中，有了该代理之后：\n\n- 本地的服务就可以完整的访问到 Kubernetes 集群中的其他服务、环境变量、Secret、ConfigMap 等；\n- 集群中的服务还能直接访问到本地暴露出来的端点；\n\n但是这种方式仍然不够连贯，还需要用户在本地调试时运行多次命令，而且在某些网络环境下可能无法与 Kubernetes 集群建立 VPN 连接。\n\n### Sidecar 模式：Nocalhost\n\n[Nocalhost](https:\/\/nocalhost.dev\/) 是一个基于 Kubernetes 的云端开发环境。要想使用它，你只需要在你的 IDE——VS Code 中安装一个插件即可扩展 Kubernetes，并缩短开发反馈周期。通过为不同的用户创建不同的 namespace，并使用 ServiceAccount 绑定到不同用户角身上时，就可以实现开发环境隔离。同时，Nocalhost 还提供了 Web 控制台和 API，方便管理员来管理不同的开发环境。\n\n![Sidecar 模式：Nocalhost](sidecar-nocalhost.jpg)\n\n#### 测试\n\n参考 Nocalhost 文档，我们在 macOS 上安装 Nocalhost，并使用 Minikube 来演示如何调试。\n\n执行下面的命令安装 Nocalhost 客户端并查看 \u0060nhctl\u0060 命令行工具的版本。\n\n\u0060\u0060\u0060bash\nbrew install nocalhost\/repo\/nocalhost\n\nnhctl version\n\u0060\u0060\u0060\n\n我们假设你机的 \u0060kubeconfig\u0060 文件位于 \u0060~\/.kube\/config\u0060（若不在此位置需要在下面的命令中使用 \u0060--kubeconfig\u0060 手动指定）并拥有 Kubernetes 集群的 admin 角色，执行下面的命令使用 Helm3 在 Kubernetes 上安装 Nocalhost 服务端。\n\n\u0060\u0060\u0060bash\nnhctl init demo -n nocalhost \n\u0060\u0060\u0060\n\n执行下面的命令启动 Minikube 隧道并查看 Nocalhost web 端地址。\n\n\u0060\u0060\u0060bash\nminikube tunnel\nkubectl get service nocalhost-web\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/\u003cEXTERNAL-IP\u003e\u0060 即可，用户名\/密码为：\u0060admin@admin.com\/123456\u0060。\n\n要想在 VS Code 中使用，你还想需要创建一个 ServiceAccount 并绑定 admin 角色，然后将该 ServiceAccount 作为 Kubeconfig 文件导出。\n\n\u0060\u0060\u0060bash\nkubectl create serviceaccount my-service-account\nkubectl create rolebinding admin --clusterrole=admin --serviceaccount=default:my-service-account\n\u0060\u0060\u0060\n\n只要你有一个 Kubernetes 集群，并有集群的 admin 权限，就可以参考 Nocalhost 的文档快速开始试用。在 VS Code 中使用 Nocalhost 插件时需要先为插件中配置 Kubernetes 集群。选择你刚导出的 Kubeconfig 文件或者直接复制文件中的内容粘贴到配置里。然后选择你需要测试的服务，并选择对应的 Dev Container，VS Code 会自动打开一个新的代码窗口。\n\n下面是以 Istio 官方提供的 [bookinfo 示例](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)为例，你可以在本地 IDE 中打开克隆下来的代码，然后点击代码文件旁边的锤子即可进入开发模式。选择对应的 DevContainer，nocalhost 会自动向 pod 中注入一个开发容器 sidecar，并在终端中自动进入该容器，如下图所示。\n\n![Nocalhost VS code 界面](nocalhost-vs-code.jpg)\n\n在开发模式中，本地修改代码，无需重新构建镜像，远端开发环境实时生效，这样可以极大的加快开发速度。同时，Nocalhost 还提供了服务端，可用于开发环境和用户权限进行管理，如下图所示。\n\n![Nocalhost web 端](nocalhost-web-admin.jpg)\n\n### Service Mesh 模式：Istio\n\n以上使用 proxy 和 sidecar 的方式，一次只能对一个服务进行调试，如果想要掌握服务的全局状况，比如获取的服务的指标，以及通过分布式追踪了解服务的依赖和调用流程，对服务的性能进行调试。这些[可观测性](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/observability\/)的功能，需要为所有服务统一注入 sidecar 来实现。\n\n而且，当你的服务正处于从虚拟机迁移到 Kubernetes 的过程中时，使用 Istio 可以将虚拟机与 Kubernetes 纳入一个网络平面中（如下图所示），方便开发者调试和做渐进式的迁移。\n\n![Service Mesh 模式：Istio](istio-service-mesh.jpg)\n\n当然要获得这些好处也不是一点“代价”也不没有的，引入 Istio 后，你的 Kubernetes  service 需要遵守 Istio 的[命名规范](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/requirements\/)，学习使用 [Istioctl](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/istioctl-analyze\/) 命令行和日志的方式来调试微服务。\n\n- 使用 \u0060istioctl analyze\u0060 命令来调试集群中的微服务部署情况，可以使用 YAML 文件来检查某个命名空间或整个集群中的资源部署情况。\n- 使用 \u0060istioctl proxy-config secret\u0060  来调试 service mesh 中的 pod 的 secret 被正确的加载并有效。\n\nIstio 的配置信息在大型的集群部署中传播将会耗时更长并且可能有几秒钟的延迟时间，sidecar 的引入会给服务间调用带来一定延迟。\n\n## 总结\n\n在应用微服务化和从虚拟机迁移到 Kubernetes 的过程中，开发者需要很多观念和习惯上的转变。通过 proxy 在本地跟 Kubernetes 间构建 VPN，可以方便开发者像调试本地服务一样调试 Kubernetes 中的服务。通过向 pod 中注入 sidecar，可以实现实时调试，加快开发进度。最后，Istio service mesh 真正实现了全局的可观测性，你还可以使用像 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 这样的工具来管理异构平台，帮助你渐渐地从单体应用过度到微服务。\n', '\/blog\/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲解了调试 Kubernetes 中微服务的三种模式/工具，以及 Istio 的引入为微服务的调试带来的变革。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-4-year-birthday/">Istio 开源四周年回顾与展望</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/05/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 开源四周年回顾与展望', '今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。', '\nIstio 是由 [Tetrate](https:\/\/tetrate.io\/) 创始人 Varun Talwar 和谷歌首席工程师 Louis Ryan 命名并在 2017 年 5 月 24 日开源。今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。\n\n## Istio 的开源历史\n\n2017 年是 Kubernetes 结束容器编排之战的一年，Google 为了巩固在云原生领域的优势，并弥补 Kubernetes 在服务间流量管理方面的劣势，趁势开源了 Istio。下面是截止目前 Istio 历史上最重要的几次版本发布。\n\n| **日期**   | 版本 | 说明                                                         |\n| ---------- | ---- | ------------------------------------------------------------ |\n| 2017-05-24 | 0.1  | 正式开源，该版本发布时仅一个命令行工具。确立了功能范围和 sidecar 部署模式，确立的 Envoy 作为默认 sidecar proxy 的地位。 |\n| 2017-10-10 | 0.2  | 支持多运行时环境，如虚拟机。                                 |\n| 2018-06-01 | 0.8  | API 重构。                                                   |\n| 2018-07-31 | 1.0  | 生产就绪，此后 Istio 团队被大规模重组。                      |\n| 2019-03-19 | 1.1  | 企业就绪，支持多 Kubernetes 集群，性能优化。                 |\n| 2020-03-03 | 1.5  | 回归单体架构，支持 WebAssembly 扩展，使得 Istio 的生态更加强大。 |\n| 2020-11-18 | 1.8  | 正式放弃 Mixer，进一步完善对虚拟机的支持。                   |\n\nIstio 开源后经过了一年时间的发展，在 1.0 发布的前两个月发布了 0.8 版本，这是对 API 的一次大规模重构。而在 2018 年 7 月底发布 1.0 时，Istio 达到了生产可用的临界点，此后 Google 对 Istio 团队进行了大规模重组，多家以 Istio 为基础的 Service Mesh [创业公司](https:\/\/istio.io\/latest\/about\/ecosystem\/#providers)诞生，可以说 2018 年是服务网格行业诞生的元年。\n\n2019 年 3 月 Istio 1.1 发布，而这距离 1.0 发布已经过去了近 9 个月，这已经远远超出一个开源项目的平均发布周期。我们知道迭代和进化速度是基础软件的核心竞争力，此后 Istio 开始以每个季度一个版本的固定[发布节奏](https:\/\/istio.io\/v1.7\/about\/release-cadence\/)，并在 2019 年成为了 [GitHub 增长最快的十大项目中排名第 4 名](https:\/\/octoverse.github.com\/#fastest-growing-oss-projects-by-contributors)！\n\n## Istio 社区\n\nIstio 开源四年来，已经在 GitHub 上收获了 2.7 万颗星，获得了大量的[社区用户](https:\/\/istio.io\/latest\/about\/case-studies\/)。下图是 [Istio](https:\/\/github.com\/istio\/istio) 的 GitHub star 数增长情况。\n\n![](008i3skNly1gqtm7n2hm1j31me0n2tag.jpg)\n\n2020 年 Istio 的项目管理开始走向成熟，治理方式也到了进化的阶段。2020 年，Istio 社区进行了第一次[管委会选举](https:\/\/istio.io\/latest\/blog\/2020\/steering-election-results\/)，还把商标转让给了 [Open Usage Commons](https:\/\/istio.io\/latest\/blog\/2020\/open-usage\/)。首届 [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) 在 2021 年 2 月份成功举办，几千人参加了线上会议。在中国也有大量的 Istio 社区用户，2021 年也会有线下面对面的 Istio 社区 meetup 在中国举办。\n\n![](008i3skNly1gquicfqg14j31lw0smwl2.jpg)\n\n根据 CNCF 2020 年调查，46% 的组织在生产中使用服务网格或计划在未来 12 个月内使用。Istio 是在生产中使用的最多的网格。\n\n## 未来\n\n经过 4 年的发展，围绕 Istio 不仅形成了庞大的用户群，还诞生了多家 Istio 供应商，你可以在最近改版的 [Istio 的官网首页](https:\/\/istio.io)中看到。在最近几个版本中，Istio 已经将发展中心转移到了提升 Day 2 Operation 体验上来了。我们还希望看到更多的 Istio 的采纳路径建议、案例研究、学习资料、培训及认证（例如来自 Tetrate 的业界的第一个 [Istio 管理员认证](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)），这些都将有利于 Istio 的推广和采用。\n', '\/blog\/istio-4-year-birthday\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">今天是 Istio 开源四周年，让我们一起来回顾一下 Istio 四年来的发展并展望一下它的未来。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/service-mesh/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/service-mesh/page/2/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/service-mesh/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/service-mesh/page/4/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/service-mesh/page/4/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(68)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(23)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
