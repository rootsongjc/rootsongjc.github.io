<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 微服务</title>
    <link>https://jimmysong.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
    <description>Recent content in 微服务 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 25 Jul 2024 14:09:37 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>保障 Istio 安全：解决关键安全漏洞及最佳实践</title>
      <link>https://jimmysong.io/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/</link>
      <pubDate>Thu, 25 Jul 2024 14:09:37 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/</guid>
      <description>
        
        
        &lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;近期，Wiz 研究团队发布了&lt;a href=&#34;https://jimmysong.io/trans/sapwned-sap-ai-vulnerabilities-ai-security/&#34; title=&#34;博客&#34;&gt;博客&lt;/a&gt;，揭示了 AI 服务中的租户隔离漏洞，引起了广泛关注。该研究详细阐述了多个 AI 服务供应商存在的安全缺陷，特别是 SAP AI Core 平台。通过合法的 AI 训练过程，研究人员能够绕过 Istio 服务网格中的流量劫持，进而横向移动并接管服务，获取客户的私人文件和云环境凭证。这些发现凸显了当今云服务和管理平台在确保隔离和沙盒环境方面面临的挑战。&lt;/p&gt;



&lt;div class=&#34;alert alert-tip-container&#34;&gt;
  
  &lt;div class=&#34;alert-tip-title px-2 py-2&#34;&gt;
    关于 UID 1337
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-tip px-2&#34;&gt;
    Istio 选择 UID 1337（leet 的变体）作为 &lt;code&gt;istio-proxy&lt;/code&gt; 容器中的用户 ID 是为了便于配置并避免权限冲突。这个数字在技术和游戏文化中象征“精英”（elite），有助于防止与其他常规用户 ID 冲突，确保流量管理操作不受权限问题干扰。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在这个背景下，Istio 作为一个重要的服务网格解决方案，同样面临着类似的安全问题，尤其是在 sidecar 注入和流量管理等关键功能上。这篇博客旨在探讨如何保护 Istio 服务网格的安全，并提供一套全面的缓解措施。我们还将讨论多层安全策略如何有效增强 Istio 的安全性，以应对类似 Wiz 报告中提到的挑战。&lt;/p&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Istio 主要用于管理 Kubernetes 中的东西向流量，提供详细的流量管理功能，如请求路由、负载均衡和故障恢复策略。虽然 Istio 提供了流量加密、认证和授权等安全功能，但它本身不应被视为防火墙。为了确保 Istio 网格中的服务安全，除了使用 Istio 自身的安全功能，还需要结合底层网络和基础设施的安全措施，比如 CNI 和安全容器。此外，微分段技术可以用来实现更细粒度的隔离，提高安全性。&lt;/p&gt;
&lt;p&gt;不论是 Sidecar 模式还是 Ambient 模式，都是通过劫持应用程序 Pod 的流量到数据平面代理中进行处理和转发的。如果没有成功拦截到应用程序流量或者被仿冒程序冒充了 Istio 而执行操作，就会有安全漏洞出现。&lt;/p&gt;
&lt;p&gt;下图展示了通过绕过或仿冒 Istio 系统用户而造成的安全漏洞存在的位置。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/bypass-sidecar-traffic-hijack.svg&#34; data-img=&#34;/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/bypass-sidecar-traffic-hijack.svg&#34; alt=&#34;image&#34; data-caption=&#34;能够绕过 Istio 中流量劫持的“安全漏洞&amp;#34;&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;能够绕过 Istio 中流量劫持的“安全漏洞&#34;&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;接下来，我们将探讨“安全漏洞”产生的具体情况及应对策略。&lt;/p&gt;
&lt;h2 id=&#34;绕过-istio-sidecar-注入&#34;&gt;绕过 Istio Sidecar 注入&lt;/h2&gt;
&lt;h3 id=&#34;在命名空间级别禁用注入&#34;&gt;在命名空间级别禁用注入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队滥用命名空间标签，在命名空间级别禁用 Istio Sidecar 注入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队抽象化应用部署，限制对原始 Kubernetes 命名空间资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：使用策略引擎（如 OPA Gatekeeper）来确保命名空间标签的合规性，定期审查命名空间的配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;在-pod-级别禁用注入&#34;&gt;在 Pod 级别禁用注入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队滥用 Pod 标签，在 Pod 级别禁用 Istio Sidecar 注入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队抽象化应用部署，限制对原始 Kubernetes Pod 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：使用 Admission Webhook 强制启用 Sidecar 注入，禁止使用排除标签，定期扫描和审计所有 Pod，确保所有需要的 Pod 都注入了 Sidecar。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绕过流量重定向到-istio-sidecar&#34;&gt;绕过流量重定向到 Istio Sidecar&lt;/h2&gt;
&lt;h3 id=&#34;滥用流量重定向注解&#34;&gt;滥用流量重定向注解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队滥用 Pod 注解，排除特定的入站或出站端口或 IP 地址，从而绕过流量重定向。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队抽象化应用部署，限制对原始 Kubernetes Pod 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：使用策略引擎来检测和警告不合规的注解使用，定期审查 Pod 注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滥用-pod-的-uid&#34;&gt;滥用 Pod 的 UID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队滥用 UID 1337（sidecar 代理的 ID），绕过 Istio Iptables 重定向规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;强制所有 Pod 指定非 1337 的 UID。&lt;/li&gt;
&lt;li&gt;检查所有容器镜像以检查 UID 1337 并拒绝这些镜像。此检查可以使用准入 Webhook 或由管理镜像注册表的中央团队来执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：禁用或限制 UID 1337 的使用，定期审计 Pod 的 UID 配置，确保没有绕过行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滥用-pod-能力net_adminnet_raw&#34;&gt;滥用 Pod 能力（NET_ADMIN、NET_RAW）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队滥用 NET_ADMIN 和 NET_RAW 能力，移除 Istio Iptables 规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队启用 Istio CNI（以避免授予应用团队提升的权限），并限制对原始 Kubernetes Pod 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查和监控 Pod 的权限配置，确保没有越权行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绕过入站流量约束&#34;&gt;绕过入站流量约束&lt;/h2&gt;
&lt;h3 id=&#34;滥用-peerauthentication&#34;&gt;滥用 PeerAuthentication&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队创建一个针对每个命名空间/每个工作负载的 PeerAuthentication 资源，启用 PERMISSIVE 认证模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队限制对原始 Istio PeerAuthentication 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查 PeerAuthentication 配置，确保所有入站流量都按照要求加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;绕过出站流量约束&#34;&gt;绕过出站流量约束&lt;/h2&gt;
&lt;h3 id=&#34;滥用-serviceentry&#34;&gt;滥用 ServiceEntry&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队创建一个 ServiceEntry，直接访问外部服务，而无需经过 Egress 网关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队限制对原始 Istio ServiceEntry 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查 ServiceEntry 配置，确保没有绕过行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滥用-externalname-服务&#34;&gt;滥用 ExternalName 服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队创建一个类型为 ExternalName 的 Kubernetes Service，直接访问外部服务，而无需经过 Egress 网关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队限制对原始 Kubernetes Service 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查 Kubernetes Service 的类型配置，确保没有绕过行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;无法控制地更改-istio-sidecar-配置&#34;&gt;无法控制地更改 Istio Sidecar 配置&lt;/h2&gt;
&lt;h3 id=&#34;滥用-sidecar-资源&#34;&gt;滥用 Sidecar 资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队创建一个针对每个工作负载的 Istio Sidecar 资源，并将 &lt;code&gt;outboundTrafficPolicy&lt;/code&gt; 字段设置为 &lt;code&gt;ALLOW_ANY&lt;/code&gt;（覆盖可能的全局值 &lt;code&gt;REGISTRY_ONLY&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队限制对原始 Istio Sidecar 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查 Sidecar 资源配置，确保没有覆盖全局设置的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滥用-envoyfilter&#34;&gt;滥用 EnvoyFilter&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景&lt;/strong&gt;：应用团队创建 EnvoyFilter，导致与现有 Istio 对象冲突，从而引发 DoS 攻击或违反安全策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓解策略&lt;/strong&gt;：平台团队限制对原始 Istio EnvoyFilter 资源的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：定期审查 EnvoyFilter 配置，确保没有不当使用行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务网格应作为分层防御的一部分&#34;&gt;服务网格应作为分层防御的一部分&lt;/h2&gt;
&lt;p&gt;服务网格被描述为现有安全模型的一个补充层，通过在传统安全控制之上添加更细粒度的安全策略来增强微服务的安全性。然而，文章强调了服务网格无法独立保障微服务的全面安全，而是应当作为整体安全策略的一部分。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/security-layers.svg&#34; data-img=&#34;/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/security-layers.svg&#34; alt=&#34;image&#34; data-caption=&#34;微服务安全分层架构&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;微服务安全分层架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;服务网格主要通过在每个服务实例旁部署一个轻量级的代理（sidecar），来管理和控制网络流量。这使得它能够在网络层面上实现精细的流量控制和策略执行，如流量加密、身份认证和授权。尽管服务网格能够提供诸如流量控制、服务发现和断路器等功能，这些功能本质上是对网络流量的管理，无法解决所有安全问题。例如，它不能替代应用层防火墙、入侵检测系统和数据安全等更传统的安全措施。&lt;/p&gt;
&lt;p&gt;此外，服务网格依赖于正确的配置和管理，配置不当可能导致安全漏洞。因此，尽管服务网格是现代微服务架构中不可或缺的一部分，它应该与传统的安全措施相结合，共同构成一个全面的、多层次的安全策略框架。参考&lt;a href=&#34;https://jimmysong.io/trans/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/&#34; title=&#34;如何通过服务网格增强微服务的安全性&#34;&gt;如何通过服务网格增强微服务的安全性&lt;/a&gt;以进一步了解如何加强服务网格的安全。&lt;/p&gt;
&lt;h2 id=&#34;长期解决方案和社区合作&#34;&gt;长期解决方案和社区合作&lt;/h2&gt;
&lt;p&gt;Istio 社区每年都会进行一次安全审计，见 &lt;a href=&#34;https://istio.io/latest/blog/2021/ncc-security-assessment/&#34; title=&#34;2021 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2021 年&lt;/a&gt;、&lt;a href=&#34;https://istio.io/latest/blog/2023/ada-logics-security-assessment/&#34; title=&#34;2022 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2022 年&lt;/a&gt; 的安全审计结果。从结果中我们可以看到，Istio 的安全态势有了很大的提升。确保你的 Istio 服务网格符合&lt;a href=&#34;https://istio.io/latest/docs/ops/best-practices/security/&#34; title=&#34;安全最佳实践&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安全最佳实践&lt;/a&gt;。另外，你还需要关注 &lt;a href=&#34;https://istio.io/latest/news/security/&#34; title=&#34;Istio CVE 公告栏&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio CVE 公告栏&lt;/a&gt;，或者使用如 &lt;a href=&#34;https://tetrate.io/tetrate-istio-subscription/&#34; title=&#34;Tetrate Istio Subscription&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Subscription&lt;/a&gt; 这类工具来扫描 Istio 服务网格的各种 CVE，部署符合 FIPS 并经过 FIPS 验证的 Istio 发行版。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;服务网格通过在应用程序外部管理控制流，为微服务架构提供了额外的安全层。这允许在不影响应用程序性能的前提下，加强服务之间的通信安全。在部署服务网格时，推荐使用 Istio 的 Egress Gateway 来管理出口流量，结合 Kubernetes 的 NetworkPolicy，确保所有出口流量都必须经过网关，从而防止潜在的数据泄露和其他安全威胁。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies/&#34; title=&#34;How to enforce egress traffic using Istio’s authorization policies - tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How to enforce egress traffic using Istio’s authorization policies - tetrate.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/ops/best-practices/security/&#34; title=&#34;Istio Security Best Practice - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Security Best Practice - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/optimize-traffic-management-and-security-with-these-service-mesh-best-practices/&#34; title=&#34;Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/blog/2023/ada-logics-security-assessment/&#34; title=&#34;Istio publishes results of 2022 security audit - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio publishes results of 2022 security audit - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/blog/2021/ncc-security-assessment/&#34; title=&#34;Announcing the results of Istio’s first security assessment - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Announcing the results of Istio’s first security assessment - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>你可能不需要微服务</title>
      <link>https://jimmysong.io/trans/you-probably-dont-need-microservices/</link>
      <pubDate>Mon, 15 Jul 2024 11:17:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/you-probably-dont-need-microservices/</guid>
      <description>
        
        
        &lt;p&gt;撰写这篇博客非常有趣，虽然它可能不受某些人欢迎，但这是一个必须讨论的话题。&lt;/p&gt;
&lt;p&gt;亲爱的开发者朋友们，我们需要开诚布公地讨论一下微服务以及某些不适宜的使用场景。这个过程可能不会轻松，但我们必须进行这样的探讨，否则我们无法取得成功。&lt;/p&gt;
&lt;p&gt;如今，微服务极为流行，它是一种优秀的架构风格，有助于扩展系统和组织架构。许多成功的公司都在使用微服务（例如 Netflix、Spotify 等），因此，大多数公司正在使用或计划使用微服务并不令人意外。然而，一些公司忽视了它带来的额外成本。&lt;/p&gt;
&lt;p&gt;在深入讨论之前，让我分享一下我与微服务的经历。&lt;/p&gt;
&lt;h2 id=&#34;起始---是微服务吗&#34;&gt;起始 - 是微服务吗？&lt;/h2&gt;
&lt;p&gt;2012 年，在我当时的公司，我们面临一个挑战：如何使公司扩展到数千名工程师和增加 1000 倍的交易量。这篇文章不关注招聘、入职等方面，而是关注架构。&lt;/p&gt;
&lt;p&gt;当时我在阅读《Scalability Rules: 50 Principles for Scaling Web Sites》，这本书介绍了 AKF Scale Cube。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/you-probably-dont-need-microservices/f1_huf402617a1744efd6a2665cb9be75ebf4_66467_445x305_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/you-probably-dont-need-microservices/f1.jpg&#34; data-img=&#34;/trans/you-probably-dont-need-microservices/f1.jpg&#34; data-width=&#34;445&#34; data-height=&#34;305&#34; alt=&#34;image&#34; data-caption=&#34;来自《Scalability Rules: 50 Principles for Scaling Web Sites》的 AKF Scale Cube&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;来自《Scalability Rules: 50 Principles for Scaling Web Sites》的 AKF Scale Cube&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;我发现这个模型非常容易理解。因此，我用它来向其他人解释为什么我们需要在生产环境中运行不同的二进制文件。搜索模块的流量模式与购物车模块的流量模式完全不同。将这些组件分开是有道理的。此外，这也允许我们拥有多个独立、自主的团队。这将有助于我们面对公司扩大到数千名工程师的挑战。&lt;/p&gt;
&lt;p&gt;当时我们并没有称之为微服务，只是服务。&amp;ldquo;微服务&amp;quot;这个术语还没有出现在我们的雷达上。在这一过程中，我们犯了很多错误。但从问题出发做出的决定，回顾起来，是正确的。&lt;/p&gt;
&lt;p&gt;因此，你现在知道我对这个话题相当熟悉，而且在这 10 多年中，我在实施众多服务和进行大量重新架构方面有过很多经验。&lt;/p&gt;
&lt;h2 id=&#34;那么问题出在哪里&#34;&gt;那么，问题出在哪里？&lt;/h2&gt;
&lt;p&gt;从本质上说，微服务没有错。单体架构也没有错。但我们的行业似乎忘记了没有银弹。有时候，某些选择实际上可能会带来伤害。不相信？让我给你举几个例子。&lt;/p&gt;
&lt;h4 id=&#34;示例-1---你得到一个服务他也得到一个服务大家都得到一个服务&#34;&gt;示例 1 - 你得到一个服务，他也得到一个服务，大家都得到一个服务&lt;/h4&gt;
&lt;p&gt;我喜欢与行业中的其他人交流，了解他们正在做什么并分享我的经验。这些对话是拓展人脉和从聪明人那里获得洞察的好方法。&lt;/p&gt;
&lt;p&gt;我记得特别是和一家拥有约 200 人技术部门的创业公司的两位工程总监的一次对话。他们是令人难以置信的人物，非常聪明，也很好交流。&lt;/p&gt;
&lt;p&gt;我通常喜欢深入了解技术领域，了解公司正在做什么以及主要的挑战是什么。因此，不出所料，我询问他们是否可以告诉我更多关于架构和团队组织方式的信息。&lt;/p&gt;
&lt;p&gt;其中一位说他们在生产中使用了一个复杂的微服务系统。然后说他们在生产中运行了大约 350 个微服务。他们说的最大挑战是确保所有这些微服务得到维护——过时的依赖项，过时的运行时版本，对一些服务的内部了解不足等。&lt;/p&gt;
&lt;p&gt;公司的微服务数量超过了开发人员数量。在那些为客户提供许多功能的以产品为中心的公司中，跟上所有这些微服务的步伐是很困难的。&lt;/p&gt;
&lt;h4 id=&#34;示例-2---你变我也变大家都变&#34;&gt;示例 2 - 你变我也变，大家都变&lt;/h4&gt;
&lt;p&gt;低耦合和高内聚很难做到正确。在微服务架构中做到这一点更是难上加难。你可能最终会得到一些非常小的微服务（也称为纳米服务），它们耦合紧密，内聚性低。&lt;/p&gt;
&lt;p&gt;我记得在之前的公司中，一个“有界上下文”有许多小服务，任何变更都需要许多团队共同努力才能实现。更糟糕的是，性能非常差。&lt;/p&gt;
&lt;p&gt;这个例子非常好，因为在此基础上，团队希望建立另一个服务来整合所有信息以提高性能。将小服务合并以增加内聚力的想法被认为是不好的，因为它看起来，我引用一下，&amp;ldquo;像一个单体&amp;rdquo;。&lt;/p&gt;
&lt;h4 id=&#34;示例-3---一切都好直到不好&#34;&gt;示例 3 - 一切都好，直到不好&lt;/h4&gt;
&lt;p&gt;随着技术行业裁员的增多，我越来越多地听到公司在大幅裁员后还拥有太多服务的情况。&lt;/p&gt;
&lt;p&gt;这可能不是一个公平的例子，因为谁能猜到公司会开始裁减其技术部门的 40% 或 60% 呢？问题是，简单是我们行业中最难的事情之一。但我们应该力求将事物保持在尽可能简单的状态，但又不能过于简单。&lt;/p&gt;
&lt;p&gt;拥有简单系统的公司在生产中拥有更多的灵活性。他们可以削减成本和减少人员而不必过多担心运营负担。&lt;/p&gt;
&lt;h4 id=&#34;示例-4---让我们使用微服务开始我们的创业项目&#34;&gt;示例 4 - 让我们使用微服务开始我们的创业项目&lt;/h4&gt;
&lt;p&gt;这将是最后一个例子，我保证。这实际上来自一个我正在努力寻找的讲座——如果你知道我所指的是哪个讲座，请在评论中告诉我，以便我可以给予适当的致谢。&lt;/p&gt;
&lt;p&gt;绿地项目很棒，对吧？它就像一块等待创意艺术家开始绘画的空白画布。在这种情况下，艺术家选择绘制一幅多彩的画作。艺术家挑选了所有主要颜色，Ruby、Golang 和 Java。他们将这些颜色与一些 Postgresql、Elasticsearch 和 Cassandra 混合在一起。&lt;/p&gt;
&lt;p&gt;这幅画？如果他们能找到时间完成的话，它本可以成为一幅毕加索作品。&lt;/p&gt;
&lt;p&gt;是否总是不好的？&lt;/p&gt;
&lt;p&gt;我并不是说它不好。我相信 Jet.com 实际上是从使用微服务开始的，并且成功地被沃尔玛收购。我只是说我们作为工程师，需要进行批判性思考并选择最佳方案。&lt;/p&gt;
&lt;h2 id=&#34;好的但为什么&#34;&gt;好的，但为什么？&lt;/h2&gt;
&lt;p&gt;有些人读到这里可能会想，“这是技能问题”。其实不是。在前两个例子中，我认识涉及的人。他们都是非常聪明的优秀工程师。我相信其他例子中的人也同样聪明。&lt;/p&gt;
&lt;p&gt;我们可能已经内化了微服务的思维方式。这也许就是为什么我们看到如此多的小团队采用微服务的原因。这种思维方式深深地植入了我们的大脑。&lt;/p&gt;
&lt;p&gt;零利率政策 (ZIRP) 也可能是罪魁祸首。ZIRP 可能确实促进了这一现象。公司希望增长，并且聘请大量开发人员成为大多数公司的标准选择。&lt;/p&gt;
&lt;p&gt;在后 ZIRP 时代，我预期人们会更加意识到微服务的隐藏成本。即使微服务是解决手头问题的好方法，管理层可能也会更加不愿采用它。&lt;/p&gt;
&lt;h2 id=&#34;你还有时间&#34;&gt;你还有时间&lt;/h2&gt;
&lt;p&gt;如果上述任何例子反映了你的现实，请不要担心。软件的好处是你几乎总是可以改变它。如果你将其视为一个“问题”，试着将“问题”一词替换为“机会”——就像笑话中说的，我有一个喝酒的“机会”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你是否处于服务数量影响你创新能力的位置？&lt;/strong&gt; 制定一个策略，让你的公司可以减少运营开销。也许你可以放松对可靠性的要求，或者你可以投资简化系统架构，以便在未来拥有更多的创新能力。&lt;/p&gt;
&lt;p&gt;第二个例子中的团队就是这样做的。他们提出了一个以节约成本和改善客户体验为重点的合并服务的策略。利益相关者非常满意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你是否正在创办一家公司？&lt;/strong&gt; 如果你正在创办一家公司并考虑使用微服务，请撰写一份设计文档，解释什么挑战，为什么选择微服务，以及你考虑过的替代方案。如果你有信任的人，分享这份设计文档并征求他们的反馈——如果你可以合法地这样做的话。这可能有助于澄清你的思路并清晰地了解微服务是否适合你的创业项目的正确架构风格。&lt;/p&gt;
&lt;p&gt;微服务很棒，但它增加了你的系统和组织的复杂性。工作方式发生变化，架构变得更加复杂，如果你正从单体架构迁移到微服务，要理解这将需要多年时间。你需要在急于采用微服务之前停下来思考，它们将如何帮助你，又将如何伤害你&amp;hellip;&lt;/p&gt;
&lt;p&gt;而且相信我，它会同时带来伤害和喜悦，即使它是最佳的架构风格。就像生活中的每一件好事一样。&lt;/p&gt;
&lt;p&gt;所以，亲爱的开发者们，我之所以开始这场对话，是因为我关心。我关心我们行业的未来。我希望我们的行业能长久、持续、可持续地建立能抵御时间考验的软件。我希望我们的行业能做出务实的决策，将技术作为手段，而不是目的。&lt;/p&gt;
&lt;p&gt;有时候微服务很棒……但你可能并不需要微服务。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>微服务中常见的认证方式详解</title>
      <link>https://jimmysong.io/blog/microservice-auth-methods/</link>
      <pubDate>Wed, 22 May 2024 13:54:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/microservice-auth-methods/</guid>
      <description>
        
        
        &lt;p&gt;在现代微服务架构中，安全性是一个至关重要的方面。随着微服务数量的增加，如何确保服务间的安全通信成为了一个挑战。本文将介绍几种常见的微服务认证方式，帮助你在设计和实现微服务系统时选择合适的认证方案。&lt;/p&gt;
&lt;h2 id=&#34;comparation&#34;&gt;微服务中常用的认证方式&lt;/h2&gt;
&lt;p&gt;下表列出了几种微服务中常用的认证方式，并从优点、缺点、适用场景和现实示例等维度进行比较。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;认证方式&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;运行位置&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;th&gt;典型用途&lt;/th&gt;
&lt;th&gt;现实使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JWT&lt;/td&gt;
&lt;td&gt;自包含令牌，减少服务器负担&lt;/td&gt;
&lt;td&gt;令牌较大，可能会增加带宽开销&lt;/td&gt;
&lt;td&gt;API 网关、服务间&lt;/td&gt;
&lt;td&gt;微服务之间无状态通信&lt;/td&gt;
&lt;td&gt;用户认证和授权&lt;/td&gt;
&lt;td&gt;在微服务架构中，用户认证（如 Auth0、Firebase）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OAuth 2.0&lt;/td&gt;
&lt;td&gt;广泛支持，灵活性高&lt;/td&gt;
&lt;td&gt;实现复杂，需要额外的交互&lt;/td&gt;
&lt;td&gt;API 网关&lt;/td&gt;
&lt;td&gt;第三方应用授权&lt;/td&gt;
&lt;td&gt;第三方应用访问用户数据&lt;/td&gt;
&lt;td&gt;Github OAuth，用于第三方应用访问 Github 数据和 API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mTLS&lt;/td&gt;
&lt;td&gt;高安全性，防止中间人攻击&lt;/td&gt;
&lt;td&gt;证书管理复杂，性能开销较大&lt;/td&gt;
&lt;td&gt;服务间&lt;/td&gt;
&lt;td&gt;高安全性要求的通信&lt;/td&gt;
&lt;td&gt;安全敏感的服务通信&lt;/td&gt;
&lt;td&gt;银行系统中的服务通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Basic 认证&lt;/td&gt;
&lt;td&gt;简单易实现&lt;/td&gt;
&lt;td&gt;不安全，容易被拦截&lt;/td&gt;
&lt;td&gt;API 网关、服务间&lt;/td&gt;
&lt;td&gt;简单的 API 保护&lt;/td&gt;
&lt;td&gt;简单的内部服务&lt;/td&gt;
&lt;td&gt;Kubernetes API Server 的基本认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;API Key 认证&lt;/td&gt;
&lt;td&gt;简单易用&lt;/td&gt;
&lt;td&gt;安全性低，容易被滥用&lt;/td&gt;
&lt;td&gt;API 网关、服务间&lt;/td&gt;
&lt;td&gt;低安全性要求的场景&lt;/td&gt;
&lt;td&gt;简单的服务访问控制&lt;/td&gt;
&lt;td&gt;各种公共 API，如 OpenAI API&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面我们将详细介绍这几种常见的认证方式。&lt;/p&gt;
&lt;h2 id=&#34;jwt&#34;&gt;JWT 认证&lt;/h2&gt;
&lt;p&gt;JWT（JSON Web Token）最早由 IETF JSON Web Token (JWT) 工作组提出，并在 2015 年作为 RFC 7519 标准正式发布。JWT 的设计目标是提供一种紧凑且自包含的方式，用于在各方之间安全地传递信息。由于其易于使用和无状态的特性，JWT 迅速被广泛采用，成为身份验证和信息交换的标准之一，特别是在微服务和现代 Web 应用中。&lt;/p&gt;
&lt;p&gt;下图展示的是 JWT 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/5dbe313ba5e9704fe2669e7a1ea556a4.svg&#34; data-img=&#34;/blog/microservice-auth-methods/5dbe313ba5e9704fe2669e7a1ea556a4.svg&#34; alt=&#34;image&#34; data-caption=&#34;JWT 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;JWT 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;JWT 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户提供凭证&lt;/li&gt;
&lt;li&gt;客户端请求访问令牌&lt;/li&gt;
&lt;li&gt;认证服务器返回 JWT 令牌&lt;/li&gt;
&lt;li&gt;客户端带 JWT 令牌请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证 JWT&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;jwt-的格式说明及示例&#34;&gt;JWT 的格式说明及示例&lt;/h3&gt;
&lt;p&gt;JWT（JSON Web Token）由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature），分别通过 Base64 编码后用点（.）连接在一起组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;头部（Header）&lt;/strong&gt;：头部包含令牌类型和签名算法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;alg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HS256&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;typ&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;JWT&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;载荷（Payload）&lt;/strong&gt;：载荷包含声明（claims），即关于用户或其他数据的断言。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;sub&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1234567890&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;iat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1516239022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;签名（Signature）&lt;/strong&gt;：签名由编码后的头部、编码后的载荷以及一个密钥通过头部中指定的算法生成。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HMACSHA256(
  base64UrlEncode(header) + &amp;#34;.&amp;#34; +
  base64UrlEncode(payload),
  secret
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个 JWT 令牌示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-jwt&#34; data-lang=&#34;jwt&#34;&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;oauth-20&#34;&gt;OAuth 2.0&lt;/h2&gt;
&lt;p&gt;OAuth（Open Authorization）协议最早由 Blaine Cook 和 Chris Messina 在 2006 年提出。最初的目标是为 Twitter 提供一个开放的授权标准。OAuth 1.0 于 2007 年发布，提供了一个允许用户授权第三方应用访问其资源的标准化方式，但由于其复杂的签名机制和其他安全问题，受到了一些限制。&lt;/p&gt;
&lt;p&gt;为了克服这些缺点，IETF（Internet Engineering Task Force）成立了 OAuth 工作组，旨在开发一个更简化、更灵活的授权协议。2012 年，&lt;a href=&#34;https://oauth.net/2/&#34; title=&#34;OAuth 2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAuth 2.0&lt;/a&gt; 正式发布（RFC 6749 和 RFC 6750）。OAuth 2.0 简化了授权流程，增加了多种授权模式，如授权码模式、简化模式、资源所有者密码凭证模式和客户端凭证模式。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 迅速成为行业标准，广泛应用于各种网络服务和应用程序，如 Google、Facebook、GitHub 等。在此基础上，出现了多个扩展和补充协议（如 OpenID Connect），进一步增强了 OAuth 2.0 的功能和安全性。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 的发展和扩展使其成为现代互联网身份验证和授权的重要基石，提供了灵活和安全的解决方案，满足了不断变化的网络应用需求。&lt;/p&gt;
&lt;p&gt;下图展示的是 OAuth 2.0 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/d79d70a5b27686dbaf8eee2e825f3d6c.svg&#34; data-img=&#34;/blog/microservice-auth-methods/d79d70a5b27686dbaf8eee2e825f3d6c.svg&#34; alt=&#34;image&#34; data-caption=&#34;OAuth 2.0 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;OAuth 2.0 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;OAuth 2.0 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户请求访问资源&lt;/li&gt;
&lt;li&gt;客户端请求认证&lt;/li&gt;
&lt;li&gt;用户登录并授权&lt;/li&gt;
&lt;li&gt;认证服务器返回授权码&lt;/li&gt;
&lt;li&gt;客户端交换授权码获取访问令牌&lt;/li&gt;
&lt;li&gt;客户端带访问令牌请求资源服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;oauth-20-授权码&#34;&gt;OAuth 2.0 授权码&lt;/h3&gt;
&lt;p&gt;在 OAuth 2.0 授权码模式中，授权码是客户端在用户授权后从授权服务器获取的短期凭证，用于交换访问令牌。授权码是一个临时的字符串，可以在授权服务器和客户端之间传递以获得更安全的访问令牌。&lt;/p&gt;
&lt;h3 id=&#34;oauth-20-扩展&#34;&gt;OAuth 2.0 扩展&lt;/h3&gt;
&lt;p&gt;OAuth 2.0 在发展过程中，为了适应不同的场景，发展出了众多的扩展，下表罗列出一些常用的扩展名称、主要功能及适用场景。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;扩展名称&lt;/th&gt;
&lt;th&gt;主要功能&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;授权码 PKCE 扩展&lt;/td&gt;
&lt;td&gt;提高授权码模式的安全性，防止授权码拦截攻击&lt;/td&gt;
&lt;td&gt;公共客户端（如移动应用、单页应用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动态客户端注册协议&lt;/td&gt;
&lt;td&gt;允许客户端动态注册和更新客户端信息&lt;/td&gt;
&lt;td&gt;自动化和灵活性要求高的系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Token Introspection&lt;/td&gt;
&lt;td&gt;允许资源服务器验证和获取访问令牌的详细信息&lt;/td&gt;
&lt;td&gt;需要验证令牌有效性和获取令牌详细信息的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Token Revocation&lt;/td&gt;
&lt;td&gt;提供令牌撤销的标准接口&lt;/td&gt;
&lt;td&gt;提高系统安全性和控制能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Device Authorization Grant&lt;/td&gt;
&lt;td&gt;允许输入受限的设备通过其他设备完成身份验证&lt;/td&gt;
&lt;td&gt;智能电视、游戏机等输入能力有限的设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mutual TLS Client Authentication&lt;/td&gt;
&lt;td&gt;基于双向 TLS 的客户端认证&lt;/td&gt;
&lt;td&gt;高安全性要求的应用场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resource Indicators&lt;/td&gt;
&lt;td&gt;允许客户端在授权请求中指定访问的资源服务器&lt;/td&gt;
&lt;td&gt;多资源服务器的支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Step-up Authentication Challenge Protocol&lt;/td&gt;
&lt;td&gt;允许资源服务器按需请求更强的身份验证（如多因素认证）&lt;/td&gt;
&lt;td&gt;高风险操作的高级认证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;oauth-20-授权流程以-github-为例&#34;&gt;OAuth 2.0 授权流程（以 Github 为例）&lt;/h3&gt;
&lt;p&gt;GitHub 使用 OAuth 2.0 来授权第三方应用访问用户的 GitHub 数据。OAuth 2.0 令牌在 GitHub 上被称为 &amp;ldquo;access tokens&amp;rdquo;，用于验证和授权访问 GitHub API。它提供了一种安全、标准化的方法，允许第三方应用在用户授权的情况下访问 GitHub 资源。通过使用访问令牌，应用程序可以代表用户执行各种操作，如读取用户信息、访问仓库、创建 gists 等。这个过程确保了用户的安全和隐私，同时简化了应用程序的认证和授权流程。&lt;/p&gt;
&lt;p&gt;以下是使用 GitHub OAuth 2.0 令牌的详细流程和示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户授权&lt;/strong&gt;：用户在第三方应用程序的界面上点击“Login with GitHub”按钮。应用程序将用户重定向到 GitHub 的授权页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取授权码&lt;/strong&gt;：用户在 GitHub 授权页面上登录并同意授权，GitHub 会将用户重定向回应用程序，并在 URL 参数中附带一个授权码（authorization code）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://yourapp.com/callback?code=AUTHORIZATION_CODE
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交换访问令牌&lt;/strong&gt;：应用程序服务器使用授权码向 GitHub 的授权服务器请求访问令牌。&lt;/p&gt;
&lt;p&gt;请求示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;POST https://github.com/login/oauth/access_token
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;client_id&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_CLIENT_ID&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;client_secret&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_CLIENT_SECRET&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;code&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;AUTHORIZATION_CODE&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;redirect_uri&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://yourapp.com/callback&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GitHub 返回访问令牌&lt;/strong&gt;：GitHub 验证请求并返回访问令牌。&lt;/p&gt;
&lt;p&gt;响应示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;access_token&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_ACCESS_TOKEN&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;token_type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;bearer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scope&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;repo,gist&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用访问令牌访问资源&lt;/strong&gt;：应用程序使用获取的访问令牌访问 GitHub API。&lt;/p&gt;
&lt;p&gt;请求示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Authorization: token YOUR_ACCESS_TOKEN&amp;#34;&lt;/span&gt; https://api.github.com/user
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;响应示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;login&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;github-user&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;node_id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;MDQ6VXNlcjE=&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;avatar_url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://github.com/images/avatar.jpg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Github User&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;company&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GitHub&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;blog&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Earth&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;github-user@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;访问令牌的特点和使用&#34;&gt;访问令牌的特点和使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;权限范围（Scopes）&lt;/strong&gt;：访问令牌的权限范围由用户在授权时指定，可以包括读取用户资料、访问用户仓库、管理 gists 等。例如，在上述示例中，&lt;code&gt;scope&lt;/code&gt; 包含 &lt;code&gt;repo&lt;/code&gt; 和 &lt;code&gt;gist&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有效期和刷新&lt;/strong&gt;：访问令牌的有效期可以是长期的也可以设置时间范围，直到用户主动撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全传输&lt;/strong&gt;：访问令牌应通过 HTTPS 传输，以确保其不被截获。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mtls&#34;&gt;mTLS&lt;/h2&gt;
&lt;p&gt;mTLS（Mutual TLS）是一种在客户端和服务器之间进行双向身份验证的技术，最早起源于 TLS（传输层安全协议），TLS 的前身 SSL（安全套接层）协议于 1995 年由 Netscape 开发。随着互联网安全需求的增加，TLS 逐步发展为一个高度安全的通信标准，而 mTLS 则在此基础上进一步提升了安全性，通过要求双方互相验证身份，广泛应用于金融、医疗等对安全性要求极高的领域。&lt;/p&gt;
&lt;p&gt;下图展示的是 mTLS 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/6a1cea6c141bda005fd183e0200b0f15.svg&#34; data-img=&#34;/blog/microservice-auth-methods/6a1cea6c141bda005fd183e0200b0f15.svg&#34; alt=&#34;image&#34; data-caption=&#34;mTLS 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;mTLS 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;mTLS 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端与服务器互相发送证书&lt;/li&gt;
&lt;li&gt;双方验证对方证书&lt;/li&gt;
&lt;li&gt;建立安全连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多关于 TLS 和 mTLS 的内容请参考博客 &lt;a href=&#34;https://jimmysong.io/blog/understanding-the-tls-encryption-in-istio/#what-is-tls-and-mtls&#34; title=&#34;如何理解 Istio 中的 mTLS 流量加密&#34;&gt;如何理解 Istio 中的 mTLS 流量加密&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic 认证&lt;/h2&gt;
&lt;p&gt;Basic 认证是一种最早由 HTTP/1.0 规范（RFC 1945）定义的简单认证机制，它通过将用户名和密码进行 Base64 编码后附加到 HTTP 请求头中进行身份验证。由于实现简单且易于使用，Basic 认证在早期的 Web 应用中被广泛采用。然而，由于其固有的安全性问题（如明文传输容易被截获），它在现代应用中通常与 HTTPS 一起使用，或被更安全的认证方式所替代。&lt;/p&gt;
&lt;p&gt;下图展示的是 Basic 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/e6f9bd871c5b59988c0f251e4cc3af64.svg&#34; data-img=&#34;/blog/microservice-auth-methods/e6f9bd871c5b59988c0f251e4cc3af64.svg&#34; alt=&#34;image&#34; data-caption=&#34;Basic 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Basic 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Basic 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户提供用户名和密码&lt;/li&gt;
&lt;li&gt;客户端带用户名和密码请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;basic-示例&#34;&gt;Basic 示例&lt;/h3&gt;
&lt;p&gt;Basic 认证使用 Base64 编码的用户名和密码进行认证。下面是使用 &lt;code&gt;curl&lt;/code&gt; 命令进行 Basic 认证请求的示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -u &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果用户名为 &lt;code&gt;admin&lt;/code&gt;，密码为 &lt;code&gt;password123&lt;/code&gt;，请求示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -u admin:password123 https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;api-key&#34;&gt;API Key 认证&lt;/h2&gt;
&lt;p&gt;API Key 认证是一种通过在请求中包含预先分配的唯一密钥来进行身份验证的方法，最早在 2000 年代初随着 Web API 的兴起而流行。API Key 认证由于其简单易用和便于管理的特性，被广泛应用于各种公共和私有 API 中。尽管它的安全性较低，容易被滥用，但在许多场景中仍然是控制访问的一种有效手段，特别是对于不需要高度安全保护的应用。&lt;/p&gt;
&lt;p&gt;下图展示的是 API Key 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/8865798e8d7aea6c02e9913b925b0b2b.svg&#34; data-img=&#34;/blog/microservice-auth-methods/8865798e8d7aea6c02e9913b925b0b2b.svg&#34; alt=&#34;image&#34; data-caption=&#34;API Key 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;API Key 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;API Key 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端带 API Key 请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证 API Key&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;api-key-示例&#34;&gt;API Key 示例&lt;/h3&gt;
&lt;p&gt;API Key 是在请求中传递的一个唯一标识符，用于验证客户端身份。API Key 通常通过 HTTP 请求头或 URL 参数传递。&lt;/p&gt;
&lt;p&gt;HTTP 请求头中的 API Key 示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Authorization: ApiKey YOUR_API_KEY&amp;#34;&lt;/span&gt; https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;URL 参数中的 API Key 示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl https://api.example.com/data?api_key&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;YOUR_API_KEY
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;API Key 格式通常是一个字符串，包含字母和数字，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1234567890abcdef1234567890abcdef
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在微服务架构中选择合适的认证方式至关重要。不同的认证方式在安全性、复杂性和适用场景上各有优劣。本文介绍了 JWT、OAuth 2.0、mTLS、Basic 认证和 API Key 认证五种常见的认证方式，并提供了它们的优缺点和适用场景。此外，其他常见的认证方式如 SAML、LDAP、Kerberos 和 OpenID Connect 也广泛应用于不同的互联网应用场景，特别是在单点登录和跨域认证方面。希望这些信息能帮助你在设计和实现微服务系统时选择最合适的认证方案。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>微服务的未来——更多层抽象</title>
      <link>https://jimmysong.io/trans/the-future-of-microservices/</link>
      <pubDate>Fri, 13 Aug 2021 17:05:42 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/the-future-of-microservices/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://thenewstack.io/category/microservices/&#34; title=&#34;微服务&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;是在 10 年前出现的，是软件融合进化的例子之一。虽然这个词可以归功于软件咨询公司 &lt;a href=&#34;https://www.thoughtworks.com/&#34; title=&#34;ThoughtWorks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ThoughtWorks&lt;/a&gt; 的 &lt;a href=&#34;https://twitter.com/boicy&#34; title=&#34;James Lewis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;James Lewis&lt;/a&gt; 和 Martin Fowler，&lt;a href=&#34;https://www.linkedin.com/in/adriancockcroft/&#34; title=&#34;Adrian Cockcroft&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adrian Cockcroft&lt;/a&gt; 也曾提出类似的想法。但当时在 Netflix 和许多硅谷的其他公司，如亚马逊、Google 和 eBay 等公司大致在相同的时间内独立搭建了或多或少相同的架构模式。&lt;/p&gt;
&lt;p&gt;在这个词诞生后的十年里，我们看到了 Kubernetes、服务网格和无服务器的兴起，我们也开始看到微服务被应用到了前端。除了可以横向扩展，微服务还可以让开发人员更快地部署代码，有利于组件的可替换性而不是可维护性。&lt;/p&gt;
&lt;p&gt;无论好坏，对许多人来说，微服务已经成为默认的架构选择。对于拥有自主团队和松散耦合系统的组织来说，微服务可以很好地工作，但它们带来了所有分布式系统都无法逃避的复杂性。&lt;/p&gt;
&lt;p&gt;“我坚决认为公共云比私有云和数据中心更好，这些好处是一目了然的。在许多情况下，是恐惧让人们畏缩不前。“独立技术顾问 &lt;a href=&#34;https://www.linkedin.com/in/samnewman/&#34; title=&#34;Sam Newman&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sam Newman&lt;/a&gt; 告诉 The New Stack，他的 &lt;a href=&#34;https://samnewman.io/books/building_microservices_2nd_edition/&#34; title=&#34;Building Microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Building Microservices&lt;/a&gt; 一书的第二版将在今年 8 月出版。“但是对于微服务，事情将比这复杂得多的多。”&lt;/p&gt;
&lt;p&gt;考虑到这一点，在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。&lt;/p&gt;
&lt;h2 id=&#34;盘点部署和运行时间&#34;&gt;盘点：部署和运行时间&lt;/h2&gt;
&lt;p&gt;现在有各种各样成熟的、设计良好的微服务框架，涵盖了大多数语言的基础知识，在 JVM 上有大量的选择，包括 &lt;a href=&#34;https://spring.io/projects/spring-boot&#34; title=&#34;Spring Boot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Boot&lt;/a&gt;、&lt;a href=&#34;https://www.dropwizard.io/en/latest/&#34; title=&#34;Dropwizard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dropwizard&lt;/a&gt;、&lt;a href=&#34;https://helidon.io/#/&#34; title=&#34;Helidon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Helidon&lt;/a&gt;、&lt;a href=&#34;https://www.lagomframework.com/&#34; title=&#34;Lagom&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lagom&lt;/a&gt;、&lt;a href=&#34;https://micronaut.io/&#34; title=&#34;Micronaut&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Micronaut&lt;/a&gt; 和 &lt;a href=&#34;https://quarkus.io/&#34; title=&#34;Quarkus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quarkus&lt;/a&gt;，同时还有 &lt;a href=&#34;https://github.com/go-kit/kit&#34; title=&#34;Go kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go kit&lt;/a&gt;（Go）、&lt;a href=&#34;https://flask.palletsprojects.com/en/2.0.x/&#34; title=&#34;Flask&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flask&lt;/a&gt; 和 &lt;a href=&#34;https://falconframework.org/&#34; title=&#34;Falcon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falcon&lt;/a&gt;（Python）、&lt;a href=&#34;https://nodejs.org/en/&#34; title=&#34;Node.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Node.js&lt;/a&gt;（JavaScript）等选择。&lt;/p&gt;
&lt;p&gt;同样地，好的监控工具也比比皆是。&lt;a href=&#34;https://thenewstack.io/getting-started-with-opentelemetry-for-java/&#34; title=&#34;OpenTelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; 的出现尤其重要。它由 OpenTracing 和 OpenCensus 合并而成，拥有广泛的供应商和语言支持，为分布式遥测数据提供标准化。这意味着开发人员只需要对他们的代码进行一次检测，然后就可以交换和改变监控工具，比较相互竞争的解决方案，甚至在生产中为不同的需求运行多个不同的监控解决方案。&lt;/p&gt;
&lt;p&gt;然而，当我们看向部署和运行时，情况就变得有点模糊了。Kubernetes 已经或多或少地成为微服务的代名词，它的复杂性不断增加，促使云原生咨询公司 &lt;a href=&#34;https://www.container-solutions.com/&#34; title=&#34;Container Solutions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Solutions&lt;/a&gt; 的首席科学家 &lt;a href=&#34;https://twitter.com/adrianmouat&#34; title=&#34;Adrian Mouat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adrian Mouat&lt;/a&gt; &lt;a href=&#34;https://blog.container-solutions.com/10-predictions-for-the-future-of-computing&#34; title=&#34;猜测&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;猜测&lt;/a&gt;我们将看到它的竞争对手出现。&lt;/p&gt;
&lt;p&gt;“值得注意的是，这种复杂性不仅仅是隐藏在引擎盖下。“Mouat 说：“它正在溢出到界面上，影响到用户。“黑进 kubectl 运行并得到一个演示并运行仍然相当容易。但是，运行生产应用程序并弄清楚如何安全地暴露它们需要了解大量不同的功能，这不可避免地导致 YAML 文件比大多数微服务源代码还要长。”&lt;/p&gt;
&lt;p&gt;Newman 总结了一个基本挑战：“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 &lt;a href=&#34;https://www.heroku.com/&#34; title=&#34;Heroku&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heroku&lt;/a&gt; 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.spotify.com/&#34; title=&#34;Spotify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spotify&lt;/a&gt; 的工程总监 &lt;a href=&#34;https://www.linkedin.com/in/pia-nilsson-02b47b1/&#34; title=&#34;Pia Nilsson&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pia Nilsson&lt;/a&gt; 曾 &lt;a href=&#34;https://engineering.atspotify.com/2021/05/18/a-product-story-the-lessons-of-backstage-and-spotifys-autonomous-culture/&#34; title=&#34;谈到&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谈到&lt;/a&gt;，这家快速扩张的公司的新工程师平均需要 60 天才能合并他们的第 10 个 pull request。作为回应，该公司建立了一个&lt;a href=&#34;https://thenewstack.io/design-a-better-kubernetes-experience-for-developers/&#34; title=&#34;开发者门户网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者门户网站&lt;/a&gt; &lt;a href=&#34;https://engineering.atspotify.com/2020/09/24/cloud-native-computing-foundation-accepts-backstage-as-a-sandbox-project/&#34; title=&#34;Backstage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backstage&lt;/a&gt;，现在是 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; title=&#34;云原生计算基金会&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会&lt;/a&gt;的一个&lt;a href=&#34;https://backstage.io/&#34; title=&#34;沙盒项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;沙盒项目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://about.netflix.com/&#34; title=&#34;Netflix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix&lt;/a&gt; 非常重视 DevEx—— 该公司为开发者铺设的“道路”—— 利用它来帮助 &lt;a href=&#34;https://www.infoq.com/presentations/devex-netflix-graphql/&#34; title=&#34;加速&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加速&lt;/a&gt; &lt;a href=&#34;https://graphql.org/&#34; title=&#34;GraphQL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt; 等新技术的 &lt;a href=&#34;https://www.infoq.com/presentations/devex-netflix-graphql/&#34; title=&#34;采用&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用&lt;/a&gt;。同样，我们已经看到了内部建设和通过 &lt;a href=&#34;https://humanitec.com/&#34; title=&#34;Humanitec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Humanitec&lt;/a&gt; 等供应商建设的 &lt;a href=&#34;https://info.container-solutions.com/the-rise-of-the-internal-developer-platform&#34; title=&#34;开发者平台&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者平台&lt;/a&gt;的崛起。 &lt;a href=&#34;https://www.getambassador.io/&#34; title=&#34;Ambassador Labs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador Labs&lt;/a&gt; 有一个相关的 &lt;a href=&#34;https://www.getambassador.io/developer-control-plane/&#34; title=&#34;开发者控制平面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者控制平面&lt;/a&gt;的概念 —— 它的网站声称，“使开发者能够控制和配置整个云开发循环，以便更快地发布软件”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 &lt;a href=&#34;https://www.heroku.com/&#34; title=&#34;Heroku&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heroku&lt;/a&gt; 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。” ——Sam Newman，Building Microservices 作者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ambassador Labs 的开发者关系总监 &lt;a href=&#34;https://www.linkedin.com/in/danielbryantuk&#34; title=&#34;Daniel Bryant&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Bryant&lt;/a&gt; 告诉 The New Stack：“如果你看看 &lt;a href=&#34;https://www.airbnb.com/&#34; title=&#34;Airbnb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Airbnb&lt;/a&gt;、&lt;a href=&#34;https://www.shopify.com/&#34; title=&#34;Shopify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shopify&lt;/a&gt; 和 &lt;a href=&#34;https://tech.lunar.app/&#34; title=&#34;Lunar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lunar&lt;/a&gt; 等公司正在做什么，它们之间有一个明显的共同点。他们正在为他们的开发者创建一个类似于 Heroku 的 CLI，这样，像’创建新的微服务’这样的命令就会产生一些支架，插入 CI，插入管道，插入可观测性。问题是，你向开发者展示的抽象是什么，以便他们获得所需的可见性，同时也使他们所需的要求变得清晰？”&lt;/p&gt;
&lt;p&gt;Bryant 特继续说：“开发者需要指定某些操作特性：这是一个内存大的服务；这个服务需要低延迟；这个服务需要非常接近那个服务。目前，你通过启动 Kubernetes 和编写大量的 YAML 来做到这一点。那里的抽象并不完全正确，特别是当你引入其他部署机制时，如&lt;a href=&#34;https://thenewstack.io/category/serverless/&#34; title=&#34;无服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器&lt;/a&gt;和&lt;a href=&#34;https://thenewstack.io/how-low-code-can-help-enterprise-software-development/&#34; title=&#34;低代码 / 无代码&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;低代码 / 无代码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;“我想知道谁能通过平台暴露出正确的抽象概念，然后让工程师决定如何打包他们的代码 —— 但他们打包的方式是一样的，而平台暴露出一些传统上属于运维的属性。”&lt;/p&gt;
&lt;h2 id=&#34;开放应用模型oam&#34;&gt;开放应用模型（OAM）&lt;/h2&gt;
&lt;p&gt;其他几个关于 Kubernetes 的倡议也值得跟踪。由&lt;a href=&#34;https://thenewstack.io/open-application-model-build-the-next-generation-of-cloud-native-applications/&#34; title=&#34;微软和阿里云&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微软和阿里云&lt;/a&gt;联合创建的&lt;a href=&#34;https://oam.dev/&#34; title=&#34;开放应用模型&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放应用模型&lt;/a&gt;（OAM）是一个描述应用的规范，将应用定义与集群的操作细节分开。因此，它使应用程序开发人员能够专注于其应用程序的关键要素，而不是其部署地点的操作细节。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://crossplane.io/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt; 是 &lt;a href=&#34;https://thenewstack.io/oam-the-kubernetes-application-model-bridging-development-and-deployment/&#34; title=&#34;OAM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM&lt;/a&gt; 的 Kubernetes 特定实现。它可以被企业用来在各种基础设施和云供应商之间建立和运维一个内部平台即服务（PaaS），这使得它在多云环境中特别有用，比如在那些兼并和收购越来越常见的大型企业中。&lt;/p&gt;
&lt;p&gt;虽然 OAM 试图将部署细节的责任从编写服务代码中分离出来，但服务网格旨在通过一个专门的基础设施层将服务间通信的责任从个人开发者那里转移出来，该层侧重于使用代理管理服务间的通信。不幸的是，它们也有复杂性的问题，而且还可能引入相当大的性能开销。&lt;/p&gt;
&lt;p&gt;因此，到目前为止，许多在生产中成功实施服务网格的案例都是在那些非常精通技术的初创公司。在 &lt;a href=&#34;https://www.infoq.com/podcasts/monolith-microservices/?&#34; title=&#34;2020 年与 InfoQ 的 Wes Reisz 的播客中&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2020 年与 InfoQ 的 Wes Reisz 的播客中&lt;/a&gt;，Newman 建议在选择之前等待 6 个月，他告诉 The New Stack，他仍然给出同样的建议。&lt;/p&gt;
&lt;p&gt;“就该技术栈的权重、管理、影响以及性能带来的影响而言，它们的现实情况是非常可怕的，“Newman 说。“对有一些组织说，如果没有它们，有些事情是不可能完成的，&lt;a href=&#34;https://monzo.com/blog/2019/04/03/deploying-envoy-proxy&#34; title=&#34;Monzo 就是一个很好的例子&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Monzo 就是一个很好的例子&lt;/a&gt; —— 在一个组织中，你有一个异构的技术栈，你需要做大规模的双向 TLS，我可以看到它的价值。但在我看来，它仍然是“概念很好，执行不力”。我想，我们可能会在很长时间内仍这样说。”&lt;/p&gt;
&lt;h2 id=&#34;隐藏服务网格&#34;&gt;隐藏服务网格&lt;/h2&gt;
&lt;p&gt;有一件事可能会发生，至少对企业客户来说，性能问题往往不是那么尖锐，那就是服务网格被推到平台的更深处，并在很大程度上对开发者隐藏。例如，&lt;a href=&#34;https://www.openshift.com/try?utm_content=inline-mention&#34; title=&#34;红帽 OpenShift&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;红帽 OpenShift&lt;/a&gt; &lt;a href=&#34;https://www.openshift.com/blog/istio-on-openshift-in-2020&#34; title=&#34;将 Istio 整合到平台层&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将 Istio 整合到平台层&lt;/a&gt;，还有多个类似的计划，将服务网格与公有云平台更紧密地整合在一起，如 &lt;a href=&#34;https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&amp;amp;aws-app-mesh-blogs.sort-order=desc&amp;amp;whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;amp;whats-new-cards.sort-order=desc&#34; title=&#34;AWS App Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt; 和 &lt;a href=&#34;https://cloud.google.com/traffic-director&#34; title=&#34;Google Cloud Platform Traffic Director&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform Traffic Director&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于服务网格的工作还在继续，以减少其所带来的网络开销。&lt;a href=&#34;https://cilium.io/&#34; title=&#34;Cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 团队的工作很有希望，它利用 Linux 内核中的 &lt;a href=&#34;https://ebpf.io/&#34; title=&#34;eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 功能来实现它所说的“非常有效的网络、策略执行和负载均衡功能”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为现在我们需要为其他人提供领域驱动设计（DDD）。因为即使是普通的开发者而不是架构师，也需要对如何确定实体的范围和边界有一定的了解，这其中有很多是回到了良好的 API 设计上。——Daniel Bryant，开发者关系总监，Ambassador Labs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但另一种可能性是，我们可能完全转向不同的运行时。&lt;a href=&#34;https://leadingedgeforum.com/&#34; title=&#34;Leading Edge Forum&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leading Edge Forum&lt;/a&gt; 的顾问 &lt;a href=&#34;https://www.linkedin.com/in/simonwardley/&#34; title=&#34;Simon Wardley&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Simon Wardley&lt;/a&gt; &lt;a href=&#34;https://acloudguru.com/blog/engineering/simon-wardley-is-a-big-fan-of-containers-despite-what-you-might-think&#34; title=&#34;认为&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;认为&lt;/a&gt;，函数即服务（Faas）/ 无服务器将最终取代 Kubernetes，成为分布式应用事实上的标准运行时，我们也看到了一些真实的生产实例，比如 &lt;a href=&#34;https://www.bbc.com/&#34; title=&#34;BBC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BBC&lt;/a&gt;，它的大部分在线架构已经从之前的 LAMP 堆栈 &lt;a href=&#34;https://www.infoq.com/podcasts/bbc-aws-lambda-react-cicd/&#34; title=&#34;直接转向了 AWS 上的 Lambda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;直接转向了 AWS 上的 Lambda&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;“我认为 FaaS 是一个管理部署的伟大抽象，“Newman 说。“作为一个对开发者友好的部署软件的抽象，它是自 Heroku 以来我们拥有的最好的东西。我确实认为目前的实现方式很差，但他们会改进。但他们只处理了在一次在一个地方执行一件任务。这并没有解决更大的网络系统的抽象问题”。&lt;/p&gt;
&lt;p&gt;作为一个例子，Newman 引用了&lt;a href=&#34;https://azure.microsoft.com/&#34; title=&#34;微软 Azure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微软 Azure&lt;/a&gt; 的 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp&#34; title=&#34;Durable Functions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Durable Functions&lt;/a&gt;，它通过响应式扩展提供了类似于连续性的东西，允许开发者在无服务器环境中建立有状态的工作流和函数。但是，虽然部署抽象可能会有所改善，但如果想象你可以完全抽象出编写分布式系统的复杂性，那就太天真了。&lt;/p&gt;
&lt;p&gt;“你不能假设你说的东西就在那里，“Newman 说。“你不能假设数据会神奇地从一个时间点瞬时传送到另一个时间点。因为它不是这样的。而且，再多的抽象也无法解决这个基本问题。”&lt;/p&gt;
&lt;h2 id=&#34;自主团队的架构&#34;&gt;自主团队的架构&lt;/h2&gt;
&lt;p&gt;另一个仍然具有挑战性的领域与整个系统架构有关，以及围绕团队组织和结构的相关问题。正如 &lt;a href=&#34;https://www.ibm.com/cloud?utm_content=logo-sponsorpage&amp;amp;utm_source=thenewstack&amp;amp;utm_medium=website&amp;amp;utm_campaign=platform&#34; title=&#34;IBM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM&lt;/a&gt; 的全球开发者 leader &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; title=&#34;Holly Cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Holly Cummins&lt;/a&gt; 在 云原生是关于文化而不是容器 一文中指出的，“即使有适当的自主团队，系统级的考虑也不会消失”。&lt;/p&gt;
&lt;p&gt;Eric Evans 的《&lt;a href=&#34;https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321125215&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20&#34; title=&#34;领域驱动设计》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;领域驱动设计》&lt;/a&gt;是微服务运动的基石，任何软件架构师都应该阅读，Bryant 说。但他更进一步说：&lt;/p&gt;
&lt;p&gt;“我认为现在我们需要为我们其他人提供 DDD，“他告诉 The New Stack。“因为即使是普通的开发者而不是架构师，也需要对如何确定实体和边界的范围有一定的了解，其中很多都要回到良好的 API 设计。一旦你理解了耦合和内聚的重要性，关注点和边界的分离，无论你处理的是什么抽象（模块、类、服务、应用），你都会自然而然地跳到这个齿轮上。”&lt;/p&gt;
&lt;p&gt;Newman 的 Building Microservices 一书的第二版即将推出，该书介绍了很多这些概念，并考虑到了下一代服务。&lt;/p&gt;
&lt;p&gt;在更新这本书时，Newman 告诉 The New Stack，“我想多谈一点耦合性。我想多谈一点内聚力。我想更多地谈论信息隐藏，这对我来说是现在最重要的事情。&lt;/p&gt;
&lt;p&gt;“我认为，即使人们掌握了分布式系统方面的知识，他们也没有掌握一个事实，即从根本上说，微服务只是模块化架构的一种形式。然而，很多创建微服务的人对什么是模块化架构或如何进行模块化毫无概念。”&lt;/p&gt;
&lt;p&gt;Newman 在新书中还引入了自 2014 年第一版出版以来出现的一些组织思维的变化。他特别引用了马修・斯凯尔顿（Matthew Skelton）和曼努埃尔・派斯（Manuel Pais）关于如何组织业务和技术团队以实现快速流动的极具影响力的作品&lt;a href=&#34;https://teamtopologies.com/book&#34; title=&#34;《团队拓扑（Team Topologies）》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《团队拓扑（Team Topologies）》&lt;/a&gt;，以及尼科尔・福斯格伦（Nicole Forsgren）、杰兹・汉伯（Jez Humble）和吉恩・金（Gene Kim）的&lt;a href=&#34;https://itrevolution.com/accelerate-book/&#34; title=&#34;《加速（Accelerate）》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《加速（Accelerate）》&lt;/a&gt;一书，该书探讨了精益管理和 DevOps 原则背后的科学。&lt;/p&gt;
&lt;p&gt;修订过程不仅揭示了有多少关于微服务的新知识可以分享，而且这些知识是如何不断积累的。&lt;/p&gt;
&lt;p&gt;“这本书可以让你广泛了解什么是微服务以及它对软件开发的影响，“Newman 说。“我发现我在向人们推荐，哦，你应该读那本书的第四章。现在我会说这个，而不是那个。我不想在推荐自己的书上一直含糊其辞。这就是为什么我写了第二版：因为我希望它是好的、准确的。”&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>微服务设计读书笔记</title>
      <link>https://jimmysong.io/blog/microservice-reading-notes/</link>
      <pubDate>Sat, 11 Mar 2017 15:45:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/microservice-reading-notes/</guid>
      <description>
        
        
        &lt;p&gt;最近在看 &lt;strong&gt;《微服务设计（Sam Newman 著）》&lt;/strong&gt; 这本书。作者是 &lt;strong&gt;ThoughtWorks&lt;/strong&gt; 的 Sam Newman。这本书中包括很多业界是用案例，比如 &lt;strong&gt;Netflix&lt;/strong&gt; 和 &lt;strong&gt;亚马逊&lt;/strong&gt;。有兴趣的话大家一起看看讨论一下。😄&lt;/p&gt;
&lt;p&gt;P.S 这本书比较偏理论，另外还有一本中国人写的书，&lt;strong&gt;《微服务架构与实践，王磊著，电子工业出版社》&lt;/strong&gt; 。这个人同样也是 &lt;strong&gt;ThoughtWorks&lt;/strong&gt; 的，两个人的观点不谋而合，依然是便理论的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cloud Native Go - 基于 Go 和 React 的 web 云服务构建指南&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书是我最近在翻译的，将由 &lt;strong&gt;电子工业出版社&lt;/strong&gt; 出版，本书根据实际案例教你如何构建一个 web 微服务，是实践为服务架构的很好的参考。&lt;a href=&#34;https://jimmysong.io/book/cloud-native-go/&#34; title=&#34;查看本书介绍&#34;&gt;查看本书介绍&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1微服务初探&#34;&gt;1.微服务初探&lt;/h2&gt;
&lt;h3 id=&#34;什么是微服务&#34;&gt;什么是微服务？&lt;/h3&gt;
&lt;p&gt;微服务（Microservices）这个词比较新颖，但是其实这种架构设计理念早就有了。微服务是一种分布式架构设计理念，为了推动细粒度服务的使用，这些服务要能协同工作，每个服务都有自己的生命周期。一个微服务就是一个独立的实体，可以独立的部署在 PAAS 平台上，也可以作为一个独立的进程在主机中运行。服务之间通过 API 访问，修改一个服务不会影响其它服务。&lt;/p&gt;
&lt;h3 id=&#34;微服务的好处&#34;&gt;微服务的好处&lt;/h3&gt;
&lt;p&gt;微服务的好处有很多，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助你更快的采用新技术&lt;/li&gt;
&lt;li&gt;解决技术异构的问题，因为是用 API 网络通信，可以使用不同的语言和技术开发不同的服务&lt;/li&gt;
&lt;li&gt;增强系统弹性，服务的边界比较清晰，便于故障处理&lt;/li&gt;
&lt;li&gt;方便扩展，比如使用容器技术，可以很方便的一次性启动很多个微服务&lt;/li&gt;
&lt;li&gt;方便部署，因为微服务之间彼此独立，所以能够独立的部署单个服务而不影响其它服务，如果部署失败的话还可以回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;别忘了康威定律，微服务可以很好契合解决组织架构问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可重用，可随意组合&lt;/li&gt;
&lt;li&gt;便于维护，可以随时重写服务，不必担心历史遗留问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与面向服务架构-soa-的关系&#34;&gt;与面向服务架构 SOA 的关系&lt;/h3&gt;
&lt;p&gt;可以说微服务架构师 SOA 的一种，但是目前的大多数 SOA 做的都不好，在&lt;code&gt;通信协议的选择&lt;/code&gt;、&lt;code&gt;第三方中间件的选择&lt;/code&gt;、&lt;code&gt;服务力度如何划分&lt;/code&gt;方面做的都不够好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务与 SOA 的共同点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都使用共享库，比如可重用的代码库&lt;/li&gt;
&lt;li&gt;模块化，比如 Java 中的 OSGI(Open Source Gateway Initiative)、Erlang 中的模块化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2架构师的职责&#34;&gt;2.架构师的职责&lt;/h2&gt;
&lt;h3 id=&#34;架构师应该关心是什么&#34;&gt;架构师应该关心是什么&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;架构师（Architect）&lt;strong&gt;在英文中和&lt;/strong&gt;建筑师&lt;/strong&gt;是同一个词，他们之间也有很多相同之处，架构师构建的是软件，而建筑师构建的是建筑。&lt;/p&gt;
&lt;p&gt;终于看到了我翻译的&lt;em&gt;Cloud Native Go&lt;/em&gt;第 14 章中引用的这本书的原话了。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/microservice-reading-notes/building-microservices-reference_hub9c0e50fdb57d51b987a72e16255d0e2_281076_1916x674_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/microservice-reading-notes/building-microservices-reference.jpg&#34; data-img=&#34;/blog/microservice-reading-notes/building-microservices-reference.jpg&#34; data-width=&#34;1916&#34; data-height=&#34;674&#34; alt=&#34;image&#34; data-caption=&#34;原话&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;原话&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;软件的需求变更是&lt;strong&gt;来的那么快来的那么直接&lt;/strong&gt;，不像建筑那样可以在设计好后按照设计图纸一步步的去建设。&lt;/p&gt;
&lt;p&gt;架构师应该关心的是什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证系统适合开发人员在上面工作&lt;/li&gt;
&lt;li&gt;关注服务之间的交互，不需要过于关注各个服务内部发生的事情，比如服务之间互相调用的接口，是使用&lt;code&gt;protocol buffer&lt;/code&gt;呢，还是使用&lt;code&gt;RESTful API&lt;/code&gt;，还是使用&lt;code&gt;Java RMI&lt;/code&gt;，这个才是架构师需要关注的问题，至于服务内部究竟使用什么，那就看开发人员自己了，&lt;strong&gt;架构师更需要关注系统的边界和分区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;架构师应该与团队在一起，&lt;strong&gt;结对编程&lt;/strong&gt; 🤓🤓 了解普通工作，知道普通的工作是什么样子，做一个&lt;em&gt;代码架构师&lt;/em&gt; 😂&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;架构师应该做什么&#34;&gt;架构师应该做什么&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供原则指导实践，比如 Heroku 的&lt;a href=&#34;https://jimmysong.io/posts/12-factor-app/&#34; title=&#34;12 因素法则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;12 因素法则&lt;/a&gt;用来指导 SAAS 应用架构一样，微服务架构设计也要有一套原则。&lt;/li&gt;
&lt;li&gt;提供要求标准，通过日志功能和监控对服务进行集中式管理，明确接口标准，提供安全性建议。&lt;/li&gt;
&lt;li&gt;代码治理。为开发人员提供范例和服务代码模板。&lt;/li&gt;
&lt;li&gt;解决技术债务。&lt;/li&gt;
&lt;li&gt;集中治理和领导。维持良好的团队关系，当团队跑偏的时候及时纠正。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3服务建模&#34;&gt;3.服务建模&lt;/h2&gt;
&lt;p&gt;以&lt;strong&gt;MusicCorp&lt;/strong&gt;这家公司的服务为例子讲解。&lt;/p&gt;
&lt;p&gt;服务建模的两个指导原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高内聚：关键是找出问题的边界，把相关的问题放在同一个服务中。&lt;/li&gt;
&lt;li&gt;松耦合：修改一个服务不需要修改另一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;strong&gt;限定上下文&lt;/strong&gt;（一个由显示边界限定的特定指责）的方法将服务拆分，比如 MusicCorp 的服务可以拆分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;财务部门&lt;/li&gt;
&lt;li&gt;仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们都不需要知道各自的具体实现，只要给它们提供特定的输入就会有你想要的产出。&lt;/p&gt;
&lt;p&gt;过早的将一个系统划分成微服务的代价非常高，尤其是在面对新领域时，将一个已有的代码库划分成微服务会比葱头开始建设微服务要简单的多。&lt;/p&gt;
&lt;h2 id=&#34;4集成&#34;&gt;4.集成&lt;/h2&gt;
&lt;p&gt;使用共享数据库，为用户创建好接口，可以使用 RPC（protocol buffer、thrift）或者 REST。服务端和客户端消息格式可以用 Json 或 XML。当然每种技术都有各自的适用场景，结合自己的业务选择。&lt;/p&gt;
&lt;p&gt;微服务的协作方式是什么样的呢？基于事件的异步通信，使用消息中间件来实现事件发布和消费者接收机制。比如用 Kafka 或 RabbitMQ。&lt;/p&gt;
&lt;h2 id=&#34;5分解单块系统&#34;&gt;5.分解单块系统&lt;/h2&gt;
&lt;p&gt;分解巨大无比没人感动的单块系统，首先要做的是理清代码库，找到&lt;strong&gt;接缝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分解系统带来的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加快以后系统开发速度&lt;/li&gt;
&lt;li&gt;划清了团队结构（又是康威定律）&lt;/li&gt;
&lt;li&gt;增加安全审计功能后，保障安全性&lt;/li&gt;
&lt;li&gt;利于开展新技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-部署&#34;&gt;6. 部署&lt;/h2&gt;
&lt;p&gt;这一块跟传统服务的部署并没有太大的不同，无非是微服务的短平快，加快了 CI（持续集成）的速度。如果将微服务打包为 docker 镜像，使用 Jenkins、ansible、puppet 等技术来部署微服务可以实现部署自动和效率的显著提高。&lt;/p&gt;
&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;
&lt;p&gt;该书的后面还讲了&lt;strong&gt;测试&lt;/strong&gt;、&lt;strong&gt;监控&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;康威定律&lt;/strong&gt;、最后还上升到&lt;strong&gt;人本&lt;/strong&gt;，给予广大的软件开发人员强烈的人文关怀，可见提倡架构师要融入团队，最一个&lt;strong&gt;代码架构师&lt;/strong&gt;和&lt;strong&gt;结对编程&lt;/strong&gt;的作者是多么博爱❤️。&lt;/p&gt;
&lt;p&gt;该书的核心部分是&lt;strong&gt;第 11 章规模化微服务&lt;/strong&gt;，为将在下篇中来探讨一下。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
