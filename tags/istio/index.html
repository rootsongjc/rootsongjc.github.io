<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-data-plane-deployment-modes/">深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/09/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析', '在本文中，我将详细解析四种主要的服务网格数据平面部署模式，包括 Sidecar 模式、Ambient 模式、Cilium mesh 模式和 gRPC 模式。通过对这些模式的架构、性能、安全性、管理复杂性和资源成本的分析，提供选择建议，帮助你在不同的应用场景中做出最优决策。无论你是追求高性能、低资源消耗，还是需要更高的安全保障，本指南都能帮助你找到合适的部署模式。', '\n本文将向你介绍 Istio 服务网格的四种平面部署模式，通过分析它们的优缺点，根据他们的性能、可靠性和安全性给出选择建议。\n\n## 什么是服务网格？\n\n服务网格是一种基础设施层，通常使用应用代理来实现各种功能。以 Istio 为例，它通过应用代理让用户能够将应用感知的流量管理、强大的可观测性和稳健的安全能力编程到网络中。Istio 确保云原生和分布式系统具有弹性，使现代企业能够在不同平台上维护其工作负载，同时保持连接和受保护。它的功能包括零信任安全、策略管理和访问控制等安全和治理控制，以及金丝雀部署、A\/B 测试、负载均衡和故障恢复等网络功能，还能提供对整个网络流量的可观测性。Istio 不受单一集群、网络或运行时的限制，可以将在 Kubernetes 或虚拟机上运行的服务、多云、混合或本地的服务包含在单个网格中。其设计可扩展，并得到广泛生态系统的支持。\n\n服务网格的架构分为控制平面和数据平面，以 Istio 为例，\u0060istiod\u0060 是它的控制平面，而数据平面有两种部署模式，用户可以选择 sidecar 或 ambient 模式。\n\n![Istio 服务网格的架构图（来源 [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/)）](service-mesh.svg)\n\n实际上服务网格的数据平面的部署模式不止这两种，加上 Istio 支持的 [gRPC 无 sidecar 的服务网格](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/)，以及 [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/)，一共有四种部署模式。\n\n## 数据平面部署模式\n\n这四种部署模式是根据什么划分的？是根据代理与服务实例的关联形式来划分的。数据平面可能位于应用程序不同的位置，根据服务网格中代理\/数据平面的部署方式不同而将其划分为以上四种模式，我们通过其典型用例来命名这四种模式：\n\n- **Sidecar 模式**：在每个服务实例中运行 L4 和 L7 代理。\n- **Ambient 模式**：在主机级别共享 L4 代理，每个服务账户或命名空间使用专用 L7 代理。\n- **Cilium mesh 模式**：在主机级别共享 L4 和 L7 代理。\n- **gRPC 模式**：无代理，L4 和 L7 功能作为应用程序的一部分，比如 gRPC、Java Spring 等 RPC 框架，对应用的侵入性较强。虽然该模式没有代理，但是仍实现了服务网格的所有功能，且在服务网格出现之前已经存在。\n\n下表格从多个维度对服务网格数据平面的部署模式进行了比较。\n\n{{\u003ctable \u0022服务网格的四种部署模式对比\u0022\u003e}}\n\n| **数据平面模式**                                          | **平台安全性** - 威胁评估、风险                              | **成本** - 基础设施\/资源成本等                         | **可管理性** - 升级、漏洞等                                | **性能** - 延迟等                            |\n| --------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------------------------------------------- | -------------------------------------------- |\n| **Sidecar 模式 -** 每个服务实例拥有一个 L4 和 L7 代理     | 高安全性，每个服务实例拥有独立代理，降低了攻击面。风险管理取决于控制平面配置。 | 高资源消耗，每个实例需要独立代理，增加了基础设施成本。 | 需要集中管理和配置，升级相对复杂，但可以通过控制平面简化。 | 可能增加延迟，因为请求需要通过代理转发。     |\n| **Ambient 模式 -** 节点共享 L4 代理，服务账户共享 L7 代理 | 安全性较低，多个服务共享一个代理，增加了攻击面。             | 成本较低，多个服务共享同一个代理。                     | 相对简单的管理，但由于共享代理可能面临漏洞。               | 性能更好，延迟更低，因为请求不需要多次转发。 |\n| **Cilium mesh 模式 -** 共享的 L4 和 L7 代理               | 安全性中等，支持精细的访问控制。                             | 成本较低，资源共享减少了基础设施开销。                 | 管理较复杂，需要处理多个服务的配置。                       | 性能良好，延迟相对较低，适合高并发场景。     |\n| **gRPC 模式 -** L4 和 L7 代理集成到应用程序内             | 安全性中等，可利用代码是应用本身的一部分，因此妥协可能更严重。 | 总体成本较低，因为代理与应用同进程内实现。             | 管理复杂，需要定期更新和维护应用层代理。                   | 性能卓越，延迟低，适合实时应用。             |\n\n{{\u003c\/table\u003e}}\n\n你可以从下图中更直观地看到这四种模式在成本和安全性方面的比较：\n\n![服务网格部署模式对比](istio-data-plane-deployment-modes.svg)\n\n从图中可以看出 Sidecar 模式安全性最高但成本最高，而 Ambient 模式和 Cilium 模式的成本和安全性适中，gRCP 模式的成本最低但安全性也一般。\n\n下图说明了服务网格数据平面的不同部署模式中代理的潜在位置。\n\n![服务网格数据平面的不同部署模式中的代理位置](overview.svg)\n\n- **Sidecar 模式**：代理与应用程序容器位于同一个 Pod 中\n- **Ambient 模式**：L4 代理与应用程序容器位于同一个节点上，L7 代理不一定跟应用程序容器在同一个节点上\n- **Cilium 模式**：L4 和 L7 代理作为一个整体与应用程序容器在同一个节点上\n- **gRPC 模式**：gRPC 框架集成到应用程序中，共同部署在一个容器中\n\n## Sidecar 模式：每个服务实例一个 L4 和 L7 的代理\n\n下面展示的是 sidecar 模式中 Application 1 访问同节点上的 Application 2 及跨节点上的 Application 3 的通信路径。\n\n![Sidecar 模式：每个服务实例一个 L4 和 L7 代理](sidecar-mode.svg)\n\n这是最常见的服务网格部署模式，也是 [Istio](https:\/\/istio.io) 服务网格起初支持的模式。每个服务实例旁边部署一个代理（如 [Envoy](https:\/\/envoyproxy.io)），该代理处理进出该服务的所有网络通信，包括 L4 和 L7 网络通信。\n\n- **优点**：安全性高，因为每个服务实例都是隔离的，减少了潜在的攻击面。\n- **缺点**：资源消耗较高，因为每个服务实例都需要单独的代理，增加了基础设施成本。\n- **成熟度**：Istio Sidecar 模式的成熟度已经达到生产级别，它们经过广泛测试并准备好在实际环境中使用。\n\n## Ambient 模式：节点共享 L4 代理，服务账户共享 L7 代理\n\n下面展示的是 ambient 模式中 Application 1 访问同节点上的 Application 2 及跨节点上的 Application 3 的通信路径。\n\n![Ambient 模式：节点共享 L4 代理，服务账户共享 L7 代理](ambient-mode.svg)\n\n在这个模式中，每个节点上有一个共享的 L4 代理，该 L4 代理为同一物理主机上的所有服务实例之间共享，而每个服务帐户都有专用的 L7 代理。\n\n- **优点**：成本较低，因为代理被多个服务共享。\n- **缺点**：安全性较低，如果代理被攻破，可能影响到所有依赖它的服务。需要注意的是，该模式仍在 beta 阶段，缺乏生产级的最佳实践。\n- **成熟度**：Istio ambient 模式现在为 beta 阶段，尚无大规模生产级最佳实践，且不支持多集群。\n\n## Cilium mesh 模式：共享的 L4 和 L7 代理\n\n下面展示的是 Cilium mesh 模式中 Application 1 访问同节点上的 Application 2 及跨节点上的 Application 3 的通信路径。\n\n![Cilium mesh 模式：共享的 L4 和 L7 代理](cilium-mesh-mode.svg)\n\n这是一个介于完全独立和完全共享之间的模式，每个节点上都有一个共享的 L7 代理。然而，像流量路由这样的 L4 功能可以不通过代理而是通过内核程序（例如，eBPF 程序）或网格代理来执行。这种数据平面模式的一个例子是 Cilium 服务网格，它根据其 \u0060CiliumEnvoyConfig\u0060 规范部署 Envoy 代理作为 L7 代理。使用如 Cilium 这样 CNI 插件可以实现服务间的安全隔离同时减少资源使用。\n\n- **优点**：成本和性能之间的良好平衡。\n- **缺点**：管理上比较复杂，因为需要维护多个服务的网络策略。\n- **成熟度**：Cilium mesh 直接通过 eBPF 管理 L4 流量，通过 CRD（如 \u0060CiliumEnvoyConfig\u0060 和 \u0060CiliumClusterwideEnvoyConfig\u0060）配置每个节点上的 Envoy 代理以控制 L7 流量。该[代理](https:\/\/github.com\/cilium\/proxy)是经过定制过的，它具有最少的 Envoy 扩展和 Cilium 策略执行过滤器。因此，该 Cilium mesh 可能无法支持 Envoy 代理的全部功能。\n\n**注意**：该模式并非 Istio 的数据平面。\n\n## gRPC 模式：L4 和 L7 代理集成到应用程序内\n\n在 gRPC 模式中，不需要部署任何代理，代理功能使用 RPC 框架直接集成到应用程序中，因此对应用的侵入性较大。服务网格控制平面使用一组被统称为 xDS API 的发现 API 动态配置应用程序。应用程序的 gRPC 客户端库为 xDS API 提供广泛的支持。利用这个功能，服务网格控制平面可以将 L4 和 L7 代理功能编程到服务容器中的这个库中。\n\n下图展示了在 Istio 的 gRPC 模式中，控制平面如何与应用程序通信。\n\n![gRPC 模式：L4 和 L7 代理集成到应用程序内](grpc-mode.svg)\n\n在这种架构中，gRPC 服务与控制平面进行通信时，不需要传统的 Sidecar 代理，而是通过特定的 agent 来完成初始化和与控制面的通信。这样的设计使得服务网格在实现服务发现、流量管理等功能的同时，减少了资源的消耗和部署的复杂性。例如，在 Kubernetes 部署中，Pod 只需添加特定注释，客户端和服务端进行一些必要的代码修改，就可以实现基本的功能，如服务发现、部分 DestinationRule 和 VirtualService 的功能，以及有限的 Istio loadBalancer 支持等。虽然存在一些限制条件，但其在性能和资源使用方面具有一定的优势。\n\n- **优点**：极高的性能和安全性，因为代理与应用程序紧密集成。\n- **缺点**：成本较高，需要在应用程序中实现复杂的网络处理功能。\n- **成熟度**：Istio 的 gRPC 模式仍处于实验阶段。\n\n## 如何选择？\n\n上文已经向你介绍了服务网格数据平面的几种部署模式及其优缺点，那么该如何选择呢？选择适合的服务网格数据平面模式取决于几个关键因素：\n\n- 成熟度\n- 企业的安全需求\n- 资源限制\n- 性能要求\n- 网络开销\n- 管理复杂性的容忍度\n\n### 成熟度\n\n在考虑服务网格数据平面部署模式时，成熟度是一个关键因素。每种模式的成熟度不同，会影响其在生产环境中的可靠性和支持程度：\n\n- **Sidecar 模式**：这是最成熟的服务网格部署模式，已被广泛采用在生产环境中，得到了充分的验证和支持。\n- **Ambient 模式**：虽然此模式提供了一定的成本效益和性能优势，但仍处于早期阶段，可能缺乏成熟的最佳实践和广泛的生态系统支持。\n- **Cilium mesh 模式**：作为一个相对新的选项，提供了独特的技术优势，尤其是在使用 eBPF 的场景中。然而，其成熟度和广泛的采用程度可能还不如 Sidecar 模式。\n- **gRPC 模式**：尽管在性能方面表现出色，此模式的复杂性和对应用程序的侵入性意味着它可能需要更多的定制开发，目前仍然处于实验阶段。\n\n### 安全需求\n\n如果你的业务对安全性要求极高，例如在金融或医疗行业，那么选择**Sidecar 模式**可能是最佳选择。这种模式提供了最强的安全保障，因为每个服务实例都有自己的独立代理，从而最大化地隔离了服务。然而，如果你的应用不处理敏感数据，或者安全需求不是首要考虑因素，**Ambient 模式**或**Cilium mesh 模式**可能是更经济的选择，它们提供了较低的代理管理开销。\n\n### 资源限制\n\n在资源受限的环境中，每个服务实例部署单独的代理可能不现实。在这种情况下，可以考虑**gRPC 模式**或**Ambient 模式**。**gRPC 模式**特别适合那些已经广泛使用 gRPC 且愿意直接在应用程序内部处理复杂网络功能的组织。而**Ambient 模式**则利用共享代理来减少资源消耗。\n\n### 性能要求\n\n对于需要极高性能和低延迟的应用，**gRPC 模式**提供了最优性能，因为它去除了传统代理带来的额外网络跳数。同时，**Cilium mesh 模式**通过在内核中处理部分网络功能来提供优秀的性能，适合需要处理高并发请求的场景。但需要注意的是，gRPC 模式仍是实验性的，暂无法支持 Istio 的全部功能，请根据你对服务网格的功能需求进行考量。\n\n确实，网络开销和成本是选择服务网格数据平面模式时的重要考量因素之一，特别是在跨多个可用区甚至跨地域部署时。\n\n### 网络开销\n\n在云环境或大规模部署中，网络成本通常源于跨区域或跨地区的数据传输。每种数据平面模式都具有影响网络开销的独特特性。**Sidecar 模式**通过区域感知路由减少跨区流量，但增加了网络跳数，导致延迟和计算使用增加。**Ambient 模式**使用 ztunnel 实现本地路由，但可能因 waypoint 代理而产生跨可用区成本。**Cilium 模式**将代理放置在与应用相同的节点上，减少节点间流量和延迟。**gRPC 模式**将 RPC 框架集成到应用中，最大限度地减少网络跳数和开销，非常适合需要高性能、低延迟的场景，但是该模式要求应用能够处理更复杂的网络逻辑，可能增加应用层的复杂性和开发成本。\n\n### 管理复杂性\n\n管理复杂性也是选择服务网格数据平面模式的一个重要考量点。**Sidecar 模式**和**gRPC 模式**可能需要更复杂的配置和维护工作，而**Ambient 模式**和**Cilium mesh 模式**则可能在某些部署环境中提供更简化的管理体验。\n\n## 结论\n\n选择合适的服务网格数据平面部署模式取决于多个因素，包括成熟度、安全性、资源限制、性能和管理复杂性。这里是一个快速指南：\n\n- **Sidecar 模式**：最适合高安全需求，提供最高程度的隔离。\n- **gRPC 模式** 或 **Cilium Mesh 模式**：适合资源有限且对性能要求高的环境。\n- **Ambient 模式**：在成本效益和较低隔离需求方面表现良好。\n- **Cilium Mesh 模式**：理想选择用于利用 eBPF 技术的现代基础设施。\n\n最佳选择应当符合你的应用需求、安全政策和技术熟悉程度。理解每种模式的优势和局限，以做出能够平衡利益、风险和成本的明智决策，是至关重要的。\n', '\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在本文中，我将详细解析四种主要的服务网格数据平面部署模式，包括 Sidecar 模式、Ambient 模式、Cilium mesh 模式和 gRPC 模式。通过对这些模式的架构、性能、安全性、管理复杂性和资源成本的分析，提供选择建议，帮助你在不同的应用场景中做出最优决策。无论你是追求高性能、低资源消耗，还是需要更高的安全保障，本指南都能帮助你找到合适的部署模式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/09/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格架构：Sidecar vs. Sidecarless，谁才是未来？', '探讨服务网格架构中 sidecar 与 sidecarless 的争论，比较 Cilium、Istio 和 Linkerd 在安全性、性能和架构复杂性方面的不同观点，帮助读者理解这些技术专家的看法和背后的争议。', '\n服务网格已经成为现代云原生应用架构中至关重要的一部分，帮助团队在大规模分布式系统中管理微服务通信、提高安全性并优化性能。然而，随着技术的不断演进，关于服务网格架构的最佳实践出现了激烈的争论，尤其是关于 sidecar 与 sidecarless 模式的选择问题。这场争论的核心在于如何在性能、资源利用、安全性和操作复杂性之间取得最佳平衡。近年来，Cilium 引入了无 sidecar 架构的 eBPF 技术，而 Istio 也推出了 Ambient 模式，结合了传统 sidecar 与无 sidecar 的优点。与此同时，Linkerd 则坚守 sidecar 架构，并对新兴的无 sidecar 方法持保守态度。这篇文章将深入探讨这些服务网格架构的主要观点和争议，并分析每种方法的优势与挑战。\n\n## 关于服务网格有无 sidecar 的争论\n\n关于服务网格的 sidecar 与无 sidecar 的争论是随着 Cilium 的推出和各大服务网格技术的演变而逐渐加剧的，尤其是在 2021 年之后：\n\n1. **Cilium Service Mesh 的推出（2021 年 12 月）**  ：Cilium 通过 eBPF 技术引入了无 sidecar 的服务网格架构，开始引发对传统 sidecar 模式的讨论。这一概念的提出标志着无 sidecar 架构的兴起。\n   \n2. **Linkerd 与 Istio 的反应（2021 年 12 月至 2022 年初）** ：Linkerd 的创始人 William Morgan 及其团队对 Cilium 的无 sidecar 方法表示担忧，认为这种方法可能会带来安全和性能上的问题。这一讨论逐渐演变为对 sidecar 与无 sidecar 架构的更广泛争辩。\n   \n3. **Istio 的 Ambient 概念（2022 年 5 月）** ：Istio 提出了 Ambient Mesh，尝试结合 sidecar 和主机级代理的优势，这进一步加剧了各方对服务网格架构的讨论。此时，业界对不同服务网格架构的看法开始分化。\n   \n4. **专家观点的发表（2021 年 12 月至 2023 年）**  ：多位行业专家如 Thomas Graf 和 William Morgan 等在不同场合发表了对 sidecar 与无 sidecar 架构的看法，形成了更为系统的争论。这些观点在多个会议和文章中被广泛讨论，推动了对服务网格架构的深入理解。\n\n## 各方观点\n\n下表摘录了各服务网格提供商及用户的公开观点。\n\n{{\u003ctable \u0022关于服务网格技术选型的公开观点\u0022\u003e}}\n\n| **人物**            | **职位\/公司**                             | **观点**                                                     |\n| ------------------- | ----------------------------------------- | ------------------------------------------------------------ |\n| **Andrey Rybka**    | Bloomberg                                 | 倾向于选择成熟度更高的 Istio，特别是在有 Google 等大公司支持的情况下。 |\n| **Ara Pulido**      | Datadog 开发者关系专家                     | 认为 eBPF 工具（如 Cilium）是 Kubernetes 网络扩展问题的解决方案，使用 Cilium 可以完全替代 kube-proxy，实现更细粒度的容器安全特性；移除 kube-proxy 后，操作简化，性能提升。 |\n| **Dale Ragan**      | SAP Concur Technologies 首席软件设计工程师 | 认为 eBPF 在安全方面提供了更好的优势，可同时应用于整个集群和各个服务；正在使用 Cilium 替代 Flannel 作为其生产环境中的容器网络接口（CNI）插件，并测试 Isovalent 的专有 SecOps 插件。 |\n| **Dan Wendlandt**   | Isovalent CEO                             | 认为 eBPF 和服务网格是互补的技术，eBPF 可作为服务网格的基础，为服务网格代理（如 Envoy）提供高效的数据进出服务。 |\n| **David Ortiz**     | Constant Contact 首席软件工程师            | 对 Istio 的 Ambient Mesh 非常感兴趣，认为其显著简化了 Istio 的操作流程，尤其是在升级方面，计划尽快采用这一技术。 |\n| **Filip Nikolic**   | PostFinance                               | 认为 eBPF 基础的无 sidecar 服务网格具有更高的网络性能和效率，并且安全实践也在不断进化。 |\n| **Greg Otto**       | Comcast 云服务执行董事                     | 对 Istio Ambient Mesh 感兴趣，计划在其成熟后进行评估；希望能够分别扩展和服务第 7 层（L7）和第 4 层（L4）功能，认为减少不必要的 L7 过滤可以减少安全暴露面和漏洞风险。 |\n| **John Mitchell**   | 独立数字化转型顾问                        | 认为 eBPF 正经历一个炒作周期，但它确实有潜力为 Kubernetes 提供高级网络安全特性，而无需改变应用程序代码。 |\n| **Kasper Nissen**   | Lunar 的首席平台架构师                     | 支持 sidecar 架构，认为它简单易用，并与其他容器技术相同；在全面部署服务网格后，资源消耗增加不多但功能增多；指出 sidecar 同步问题源于 Kubernetes 网络层的问题，建议在 Kubernetes 层面进行修复。 |\n| **Louis Ryan**      | Solo.io CTO                               | 强调 Istio 1.23 版引入的 Ambient Mesh 的优势，包括减少 sidecar 的使用，简化架构，提高性能，降低复杂性，并增强了灵活性与可扩展性。他认为，Ambient Mesh 能够帮助团队更轻松地管理微服务架构。 |\n| **Thomas Graf**     | Isovalent CTO                             | 主张通过 eBPF 和 Cilium 提供无边车的服务网格，优化 mTLS 认证，消除 sidecar 的使用，从而提高性能和安全性。认为分离认证握手和数据传输的模式能够实现更高效、更灵活的服务间认证，同时减少管理复杂性，并提供对多种网络协议的支持。 |\n| **William Morgan**  | Linkerd 创始人兼 Buoyant CEO                | 强烈批评无 sidecar 的 eBPF 方法，认为 sidecar 提供了更好的安全隔离和性能预测性，指出 sidecarless 架构可能重蹈 Linkerd 1 的覆辙。他认为，eBPF 和 sidecar 不是对立的，eBPF 可以用于网络优化，但不应替代 sidecar。主张继续使用更轻量的 sidecar 代理。 |\n| **Zachary Butcher** | Tetrate 创始工程师                         | 对 Ambient Mesh 持审慎乐观态度，认为它有助于降低服务网格的采用难度，但当前性能表现较差、功能有限，距离生产就绪还有很长的路要走。他建议用户暂时不要在生产环境中使用 Ambient Mesh，直到其成熟度提高。 |\n\n{{\u003c\/table\u003e}}\n\n## 个人观点\n\n近年来，我有幸见证并参与了许多关于服务网格架构选择的讨论和实践。我认为服务网格选择不应仅仅基于技术特性的比较，更应考虑到团队的具体需求、现有技术栈的兼容性以及未来的扩展性。\n\n在 sidecar 与 sidecarless 的选择问题上，我的看法是两者各有千秋。Sidecar 模型虽然在某些情况下可能会带来资源占用和管理复杂性的增加，但它提供了更细粒度的流量控制和安全策略实施，这对于需要高度精细化管理的企业环境是非常宝贵的。与此同时，sidecarless 模型，尤其是通过 eBPF 技术实现的，为服务网格带来了前所未有的性能优化和资源利用率提升，它对于构建高效率的大规模服务网格同样具有重要价值。\n\n因此，我的建议是，企业在选择服务网格架构时，应该从自身的业务需求出发，综合考虑安全性、性能、成本以及团队的运维能力，选择最适合自己的服务网格解决方案。\n\n## 总结\n\n总结下目前关于这三个流行的服务网格项目的主流看法：\n\n1. **Linkerd**：强调 sidecar 的安全隔离和性能稳定性，对 eBPF 无 sidecar 模式持批评态度，认为其复杂性和安全风险增加。\n2. **Istio**：引入 Ambient Mesh，部分采用无 sidecar 方法，以降低复杂性和提高性能，但仍保留 sidecar 的部分功能，体现出对现有 sidecar 架构的保留与创新。\n3. **Cilium**：主张通过 eBPF 无 sidecar 模式来优化网络性能和安全性，简化操作，同时保持对多种协议的支持，推动服务网格功能集成到 Linux 内核中。\n\n不同的观点反映了各自对服务网格架构设计的偏好与关注点，不同企业应根据自身需求和技术背景选择合适的服务网格方案。\n\n## 参考\n\n- [Sidecarless eBPF service mesh sparks debate](https:\/\/www.techtarget.com\/searchitoperations\/news\/365535362\/Sidecarless-eBPF-service-mesh-sparks-debate)\n\n- [eBPF or not: Sidecars are the future of the service mesh](https:\/\/thenewstack.io\/ebpf-or-not-sidecars-are-the-future-of-the-service-mesh\/)\n\n- [eBPF Service Mesh](https:\/\/isovalent.com\/blog\/post\/2021-12-08-ebpf-servicemesh\/)\n\n- [Linux kernel utility could solve Kubernetes networking woes](https:\/\/www.techtarget.com\/searchitoperations\/news\/252483517\/Linux-kernel-utility-could-solve-Kubernetes-networking-woes)\n\n- [Service Mesh Security](https:\/\/isovalent.com\/blog\/post\/2022-05-03-servicemesh-security\/)\n\n- [Istio 1.23 drops the sidecars for a simpler ambient mesh](https:\/\/thenewstack.io\/istio-1-23-drops-the-sidecars-for-a-simpler-ambient-mesh)\n\n- [Ambient Mesh: What you need to know about this experimental new deployment model for Istio](https:\/\/tetrate.io\/blog\/ambient-mesh-what-you-need-to-know-about-this-experimental-new-deployment-model-for-istio\/)\n\n- [Sidecarless service mesh: fad or the future?](https:\/\/www.techtarget.com\/searchitoperations\/news\/252526651\/Sidecarless-service-mesh-fad-or-the-future)\n', '\/blog\/service-mesh-sidecar-vs-sidecarless-debate\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探讨服务网格架构中 sidecar 与 sidecarless 的争论，比较 Cilium、Istio 和 Linkerd 在安全性、性能和架构复杂性方面的不同观点，帮助读者理解这些技术专家的看法和背后的争议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ambient-mesh-can-sidecar-less-istio-make-applications-faster/">[译] Istio Ambient 模式：无 Sidecar Istio 如何让应用更快？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/09/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/ambient-mesh-can-sidecar-less-istio-make-applications-faster/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式：无 Sidecar Istio 如何让应用更快？', '探索如何使用 Fortio 与 Istio 集成，在使用 Bookinfo 应用和流行的 DevOps 工具如 Kubernetes、Prometheus 和 Grafana 的微服务架构中进行高效的性能测试和监控。', '\nAmbient 模式是 2022 年在 [Istio](https:\/\/thenewstack.io\/simplifying-cluster-connectivity-with-istio-service-mesh\/) 中引入的新型无 sidecar 数据平面。当今年 5 月 [Ambient 模式](https:\/\/thenewstack.io\/ambient-mesh-sidestepping-the-sidecar\/) 达到 [Beta](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/) 阶段时，我观察到用户开始试用并运行负载测试，以理解将应用添加到网格后的性能影响。\n\n受到 [Quentin Joly 的博客](https:\/\/a-cup-of.coffee\/blog\/istio\/#with-istio-ambient) 关于 Istio 在 Ambient 模式下的惊人性能的启发，以及来自社区其他用户有时应用在 [Ambient 模式](https:\/\/thenewstack.io\/istio-1-23-drops-the-sidecars-for-a-simpler-ambient-mesh\/) 下稍快的反馈，我决定自己验证这些结果。\n\n## 测试环境\n\n我使用了一个拥有 256GB RAM 和每个节点 32 核 CPU 的三节点 Kubernetes 集群。\n\n![](f1.webp)\n\nIstio 使用了一些工具来简化一致性的基准测试。首先，我们使用一个叫做 [Fortio](https:\/\/github.com\/fortio\/fortio) 的负载测试工具，它以指定的每秒请求数 (RPS) 运行，记录执行时间的直方图并计算百分位数，例如 P99，即 99% 的请求在此时间内完成。\n\n我们还提供了一个叫做 [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) 的示例应用，其中包括用 Python、Java、Node.js 和 Ruby 编写的微服务。\n\n每个 Bookinfo 部署都有两个副本，这些副本均匀分布在三个工作节点上。使用 [pod anti-affinity rule](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/assign-pod-node\/#affinity-and-anti-affinity)，我确保 Fortio 被放置在与 [details](https:\/\/github.com\/istio\/istio\/tree\/master\/samples\/bookinfo\/src\/details) 服务不同的节点上。\n\n## 初始测试结果\n\n我从 Istio v1.22.3 版本安装了 Bookinfo 应用。使用 Fortio 工具对单个 Bookinfo 服务（例如 details）或完整的 Bookinfo 应用进行负载驱动，我注意到在将所有服务添加到 ambient 网格后，延迟影响 **接近零**。大多数时间它们的增加范围在 0-5% 之间，用于平均值或 P90。我一致注意到 Istio 的 details 服务在 ambient 模式下稍微快一点，就像 Quentin 在他的博客中报告的那样。\n\n### 对 Details 服务进行负载测试\n\n我进行了与 Quentin 相同的测试，通过 10 个连接发送 100 RPS 到 details 服务，并收集了无网格和 ambient 的结果。\n\n![无网格：details 服务 100 RPS。](f2.webp)\n\n![Ambient：details 服务 100 RPS。](f3.webp)\n\n就像 Quentin 一样，我不得不进行多次测试以验证 ambient 模式比无网格模式略有性能提升——这很难让人相信！对于 Bookinfo 的 details 服务来说，加入 ambient 模式平均降低了 6-11% 的延迟——以及添加了 mTLS 和 L4 观测！\n\n| **Fortio 对 details** | **平均** | **P50** | **P75** | **P90** | **P99** | **差异**                  |\n| --------------------- | -------- | ------- | ------- | ------- | ------- | ------------------------- |\n| **无网格运行 1**      | 0.89ms   | 0.64ms  | 0.74ms  | 0.85ms  | 2.67ms  | **平均慢 11%，P90 慢 5%** |\n| **Ambient 运行 1**    | 0.80ms   | 0.6ms   | 0.71ms  | 0.81ms  | 1.4ms   |                           |\n| **无网格运行 2**      | 0.86ms   | 0.65ms  | 0.75ms  | 0.86ms  | 1.71ms  | **平均慢 6%，P90 慢 4%**  |\n| **Ambient 运行 2**    | 0.81ms   | 0.61ms  | 0.72ms  | 0.83ms  | 1.56ms  |                           |\n| **无网格运行 3**      | 0.90ms   | 0.65ms  | 0.76ms  | 0.88ms  | 1.92ms  | **平均慢 10%，P90 慢 5%** |\n| **Ambient 运行 3**    | 0.82ms   | 0.63ms  | 0.72ms  | 0.84ms  | 1.5ms   |                           |\n\n*表 1: Fortio 对 details 服务 100 RPS 10 连接。*\n\n## 为什么应用有时在 Ambient Mesh 中更快？\n\n我们被教导说服务网格会增加延迟。Quentin 的结果，这里复制的结果，展示了一个工作负载在通过服务网格运行时*更快*的案例。这是怎么回事？\n\n### 第一种理论\n\n当您的应用位于 ambient 模式 中时，负载请求首先通过一个轻量级的本地节点代理叫做 [ztunnel](https:\/\/istio.io\/latest\/docs\/ambient\/overview\/#ztunnel)，然后传送到目的地 ztunnel，再向服务传送。details 服务使用带有 Webrick 库的 HTTP\/1.1，我们已经看到旧的或配置不良的 HTTP 库中存在连接管理和保持活动状态的行为不佳。我的第一个假设是，当客户端和服务器位于不同节点时，通过客户端和服务器 ztunnels 代理实际上可能更快，如果应用没有使用高效的 HTTP\/2 连接的话。Ztunnel 使用连接池和 [HTTP Connect](https:\/\/en.wikipedia.org\/wiki\/HTTP_tunnel) 建立节点之间的安全通道，以在负载下利用并行性和 HTTP\/2 流多路复用。\n\n![](f4.webp)\n\n然而，这个理论有一些挑战。为什么我只在 details 服务上一致观察到这个，而不是任何其他 Bookinfo 服务？\n\n进一步研究，我发现我们的 Fortio 负载工具默认启用了[连接保持活动](https:\/\/github.com\/fortio\/fortio\/blob\/8a7d9112667e637139c788b68cb063f456d20cb4\/bincommon\/commonflags.go#L55)。使用 10 个来自 Fortio 的连接到 details 服务和 details 服务（使用 WEBrick Ruby 库）尊重连接保持活动设置，连接可以有效地被重用，无需 ambient。\n\n### 用 Connection Close 进行负载测试\n\n接下来，我探索了使用设置 \u0060Connection: close\u0060 标头的同样负载测试。这强制禁用任何 HTTP 连接池，这是测试这个假设的好方法。\n\n\u0060\u0060\u0060bash\ncurl -v -d \u0027{\u0022metadata\u0022: {\u0022url\u0022:\u0022http:\/\/details:9080\/details\/0\u0022, \u0022c\u0022:\u002210\u0022, \u0022qps\u0022: \u0022100\u0022, \u0022n\u0022: \u00222000\u0022, \u0022async\u0022:\u0022on\u0022, \u0022save\u0022:\u0022on\u0022}}\u0027 \u0022localhost:8081\/fortio\/rest\/run?jsonPath=.metadata\u0022 -H \u0022Connection: close\u0022\n\u0060\u0060\u0060\n\n![无网格：details 服务 100 RPS 10 连接带有 connection close。](f5.webp)\n\n![Ambient：details 服务 100 RPS 10 连接带有 connection close。](f6.webp)\n\n| **Fortio 对** **details** | **平均** | **P50** | **P75** | **P90** | **P99** | **差异**                 |\n| ------------------------- | -------- | ------- | ------- | ------- | ------- | ------------------------ |\n| **无网格**                | 1.90ms   | 1.72ms  | 2.28ms  | 2.77ms  | 3.98ms  |                          |\n| **Ambient**               | 2.06ms   | 2.15ms  | 2.65ms  | 2.94ms  | 4ms     | **平均慢 8%，P90 慢 6%** |\n\n*表 2: Fortio 对 details 服务 100 RPS 10 连接带有 connection close。*\n\n与表 1 的结果相比，表 2 的响应时间明显更高，这是预期的，因为每个连接在 details 服务响应后立即关闭。考虑到 P50、P75、P90 和 P99 都从带有 connection close 的 ambient 运行中变慢，似乎可以安全排除第一理论中的 ztunnel 连接池可能使请求更快。\n\n### 第二种理论\n\n我注意到在我们新的 Istio v1.23 版本中的 details 和 productpage 服务中有一个与性能相关的 [PR](https:\/\/github.com\/istio\/istio\/pull\/51428\/files)。对于 details 服务，PR 为 details WEBrick 服务器启用了 [TCP_NODELAY](https:\/\/brooker.co.za\/blog\/2024\/05\/09\/nagle.html) 标志，这将减少来自 details 服务响应时间的不必要延迟（高达 [40ms](https:\/\/vorner.github.io\/2020\/11\/06\/40-ms-bug.html)）。对于 productpage 服务，PR 在传入请求上启用了保持活动状态，这将重用现有的传入连接，从而提高性能。\n\n包含修复的新更新的 details 部署中，我重复了通过 10 个连接发送 100 RPS 到 details 服务的相同测试。无网格和 ambient 的结果非常接近，所以我进行了三次测试以确保结果的一致性。下面是每个场景的第一次运行的截图：\n\n![无网格：新 details 服务 100 RPS 10 连接。](f7.webp)\n\n![Ambient：新 details 服务 100 RPS 10 连接。](f8.webp)\n\n我为每个场景的三次运行建立了一个表格：\n\n![](t1.webp)\n\n*表 3: Fortio 对新 details 服务 100 RPS 10 连接。*\n\n与表 1 的先前结果相比，表 3 的无网格数字有了相当大的改进（在更高百分比下更显著地超过 ambient 数字），现在接近于 ambient 数字。Ztunnel 默认启用了 [TCP_NODELAY](https:\/\/github.com\/istio\/ztunnel\/pulls?q=is%3Apr\u002bis%3Aclosed\u002bTCP_NODELAY)，这有助于 ambient 性能在表 1 中超过无网格，当旧的 details 服务没有启用 TCP_NODELAY 时。当新的 details 服务启用了 TCP_NODELAY 时，它也稍微提高了 ambient 的响应时间。\n\n表 3 还显示，在此类型的负载测试中，无网格和 ambient 运行之间的平均、P50、P75 和 P90 几乎没有差异。这些运行之间的差异可能只是噪音，除了 P99，无网格始终比 ambient 慢 8% 或更多。\n\n### 第三种理论\n\n继续审查表 3 的测试结果，为什么在有额外跳转到 ztunnel pod 和 ambient 提供的如 mTLS 和 L4 观测等显著优势时，无网格和 ambient 之间的延迟相似？对于 P99 情况，为什么 details 服务在 ambient 模式下始终更快？\n\nZtunnel 提供了出色的读写缓冲管理，并通过 HTTP\/2 多路复用，可以有效地最小化或有时甚至消除通过客户端和服务器 ztunnel pod 的额外跳转所增加的开销。我决定通过在两个 Fortio 和 details 服务的 Kubernetes 工作节点上进入并附加 strace 来测量这一点，同时过滤掉无关的跟踪：\n\n\u0060\u0060\u0060bash\nstrace -fp {pid} -e trace=write,writev,read,recvfrom,sendto,readv\n\u0060\u0060\u0060\n\n无网格和 ambient 情况下的 details 服务的 strace 输出是相似的：\n\n\u0060\u0060\u0060\n…read(9, \u0022GET \/details\/0 HTTP\/1.1\\r\\nHost: d\u0022..., 8192) = 118write(9, \u0022HTTP\/1.1 200 OK\\r\\nContent-Type: a\u0022..., 180) = 180write(9, \u0022{\u0022id\u0022:0,\u0022author\u0022:\u0022William Shakes\u0022..., 178) = 178write(2, \u0022192.168.239.19 - - [13\/Aug\/2024:\u0022..., 80) = 80…\n\u0060\u0060\u0060\n\n*输出 1: 无网格或 ambient —— 附加 strace 到 details 服务的 PID。*\n\n无网格和 ambient 情况下的 Fortio 服务的 strace 输出不同。在无网格情况下，我们看到 Fortio 执行了两次读取，一次用于 HTTP 头部，另一次用于正文。\n\n\u0060\u0060\u0060\n…read(13, \u0022HTTP\/1.1 200 OK\\r\\nContent-Type: a\u0022..., 4096) = 180read(13, \u0022{\u0022id\u0022:0,\u0022author\u0022:\u0022William Shakes\u0022..., 4096) = 178…write(19, \u0022GET \/details\/0 HTTP\/1.1\\r\\nHost: d\u0022..., 118) = 118 …\n\u0060\u0060\u0060\n\n*输出 2: 无网格 —— 附加 strace 到 Fortio 的 PID。*\n\n在 ambient 情况下，我们始终只看到一个读取，用于同时获取头部和正文。\n\n\u0060\u0060\u0060\n…read(19, \u0022HTTP\/1.1 200 OK\\r\\nContent-Type: a\u0022..., 4096) = 358…write(19, \u0022GET \/details\/0 HTTP\/1.1\\r\\nHost: d\u0022..., 118) = 118…\n\u0060\u0060\u0060\n\n*输出 3: Ambient 模式 —— 附加 strace 到 Fortio 的 PID。*\n\n为什么会这样？这是有道理的，因为 write 调用完全基于应用行为，而这在这种情况下没有变化。Ambient 将这些多个应用写入合并为单个网络写入，并隐含地在对等端进行单个读取。\n\n在上述测试场景中，我观察到 Fortio 服务在启用 ambient 时系统调用总数减少了 60%。这非常**重要**，并解释了在 peak 时 Fortio pod 的延迟和 CPU 使用量减少约 25% 的大部分原因。系统调用的减少超过了 mTLS 和 ztunnel 的其他功能的成本。我预计这种模式在企业中会相当常见，因为一些 HTTP 库和应用在缓冲和刷新方面做得更好，而一些则不太好。这通常与应用的年龄和它们构建时使用的 SDK 相关。\n\n![无网格和 ambient 运行：details 服务 100 QPS 10 连接。](f9.webp)\n\n## 整个 Bookinfo 应用怎么样？\n\n在更新了 details 和 productpage 部署之后，我开始通过 100 个连接发送 1000 RPS 到 Bookinfo 应用，并观察到无网格和 ambient 的优异结果。\n\n![无网格：新 Bookinfo 应用 1000 RPS 100 连接。](f10.webp)\n\n![无网格：新 Bookinfo 应用 1000 RPS 100 连接。](f11.webp)\n\n| **Fortio 对 Bookinfo** | **平均** | **P50** | **P75** | **P90** | **P99** | **平均差异**               |\n| ---------------------- | -------- | ------- | ------- | ------- | ------- | -------------------------- |\n| **无网格**             | 1.39ms   | 1.32ms  | 1.42ms  | 1.67ms  | 2.19ms  |                            |\n| **Ambient**            | 1.40ms   | 1.34ms  | 1.48ms  | 1.68ms  | 2.94ms  | **平均和 P90 均慢不到 1%** |\n\n*表 4: Fortio 对新 Bookinfo 应用 1000 RPS 100 连接。*\n\n作为对比，我还针对 v1.22.3 版本中附带的旧 Bookinfo 示例进行了同样的测试，你可以看到新 Bookinfo 在响应时间上取得了 **5-10 倍** 的提升，无论是无网格还是 ambient！\n\n| **Fortio 对 Bookinfo** | **平均** | **P50** | **P75** | **P90** | **P99** | **平均差异** |\n| ---------------------- | -------- | ------- | ------- | ------- | ------- | ------------ |\n| **无网格**             | 6.35ms   | 4.68ms  | 7.44ms  | 11.4ms  | 36.63ms |              |\n| **Ambient**            | 6.74ms   | 4.9ms   | 7.79ms  | 12.12ms | 41.14ms | **慢 6%**    |\n\n*表 5: Fortio 对旧 Bookinfo 应用 1000 RPS 100 连接。*\n\n将负载增加到 4000 RPS 和 400 连接，并使用新 Bookinfo 部署：\n\n![Ambient：新 Bookinfo 应用 4000 RPS 400 连接。](f12.webp)\n\n![Ambient：新 Bookinfo 应用 4000 RPS 400 连接。](f13.webp)\n\n响应时间依然很好，远远优于只有 1000 RPS 和 100 连接的旧 Bookinfo 应用（表 5）：\n\n| **Fortio 对 Bookinfo** | **平均** | **P50** | **P75** | **P90** | **P99** | **平均差异**             |\n| ---------------------- | -------- | ------- | ------- | ------- | ------- | ------------------------ |\n| **无网格**             | 1.54ms   | 1.33ms  | 1.54ms  | 2.25ms  | 3.98ms  |                          |\n| **Ambient**            | 1.58ms   | 1.37ms  | 1.57ms  | 2.33ms  | 4.9ms   | **平均慢 3%，P90 慢 4%** |\n\n*表 6: Fortio 对新 Bookinfo 应用 4000 RPS 400 连接。*\n\n很高兴看到 Bookinfo 能够在 4000 RPS 下无错误地运行，而且 ambient 模式比无网格慢 3-4%，但带来了传输中加密的 mTLS 和 L4 观测的所有好处。我记得我之前只能在旧 Bookinfo 应用中达到最高 1200 RPS，这已经导致了少量的错误。现在我可以增加到 4000 或更高 RPS 而不出现错误。\n\n## 总结\n\n在 L4 上，Ambient 模式只引入了非常微小的影响——偶尔甚至可以自动**改善**！— 用户应用的延迟。结合简单的用户体验，通过标记命名空间以将您的应用注册到 ambient 而无需重启任何工作负载，它为用户提供了我们初衷中预期的愉快体验。\n\n我想感谢所有 Istio 维护者，他们构建了这样一个令人愉快的项目，以及为 Istio 项目提供测试基础设施的 [CNCF](https:\/\/www.cncf.io\/community-infrastructure-lab\/)。我还要感谢 Quentin Joly 和许多提供了“ambient 有时比无网格稍快”的反馈的用户，这促使我进行了上述基准测试，亲身体验了在负载下的改善或微小的延迟影响。\n', '\/trans\/ambient-mesh-can-sidecar-less-istio-make-applications-faster\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何使用 Fortio 与 Istio 集成，在使用 Bookinfo 应用和流行的 DevOps 工具如 Kubernetes、Prometheus 和 Grafana 的微服务架构中进行高效的性能测试和监控。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/08/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('集成 Envoy Gateway 作为 Istio 服务网格中的入口网关', '本文介绍了如何将 Envoy Gateway 作为 Istio 服务网格中的入口网关集成，增强应用的安全性和可访问性。', '\n[Istio](https:\/\/istio.io) 提供了对入口网关的强大而灵活的支持，利用 Envoy 代理在其 sidecar 模式下运行。尽管 Istio 专注于管理集群内服务之间的通信，[Envoy Gateway](https:\/\/gateway.envoyproxy.io) 旨在将应用程序暴露给外部世界，处理用户请求，并支持高级功能，如 OIDC 单点登录。通过结合 Istio 服务网格的功能和 Envoy Gateway 的高级网关功能，可以增强整体应用程序的可访问性和安全性。\n\n下图显示了 Istio 网格中入口网关的流量路径。\n\n![Istio 入口网关流量路径](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-ingress-sidecar.svg)\n\n下一个图表显示了在引入 Envoy Gateway 后，流量如何从 Istio 网格的边缘流入内部网络。\n\n![引入 Envoy Gateway 后的流量路径](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-teg-integration.svg)\n\n### 准备 Envoy Gateway 与 Istio 之间的互操作性\n\n要将 Envoy Gateway 用作 Istio 的入口网关，请考虑以下关键点：\n\n- 在 Istio 安装期间避免启用入口网关。我们将手动安装并配置 Envoy Gateway 作为入口网关。\n- 由于 Istio 和 Envoy Gateway 都使用 Envoy 作为代理，确保 Istio 将 Envoy sidecar 注入到 Envoy Gateway 的网关 Pod 中，以允许与 Istio 的数据平面安全通信。\n- 配置由 Envoy Gateway 创建的 Envoy 代理的路由类型为 \u0060Service\u0060 而不是 \u0060Endpoint\u0060，以确保正确路由。\n\n按照 [快速启动文档](https:\/\/gateway.envoyproxy.io\/docs\/tasks\/quickstart\/) 安装 Envoy Gateway。标记 Envoy Gateway 的命名空间以确保数据平面获得 Istio sidecar 注入：\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 的 sidecar 以不拦截进入网关的流量。注入的 sidecar 确保 Envoy Gateway 的组件及其创建的代理被包含在 Istio 网格中，并安装正确的证书以进行安全通信。\n\n{{\u003cinclude_code file=\u0022control-plane-tls.yaml\u0022\u003e}}\n\n应用补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 不拦截入站流量：\n\n{{\u003cinclude_code file=\u0022teg-sidecars-no-inbound.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\n修改 GatewayClass 配置以将 sidecar 配置应用于 Envoy Gateway 数据平面中的所有 \u0060EnvoyProxy\u0060：\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\n应用补丁：\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### 安装 Istio\n\n使用 minimal 配置文件部署 Istio 以避免部署入口网关：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### 重启 Envoy Gateway 控制平面\n\n在 Istio 的 sidecar 注入准备好后，重启所有 Envoy Gateway 控制平面的 pod：\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis;\n\tdo kubectl rollout restart deployment -n envoy-gateway-system $d;\ndone\n\u0060\u0060\u0060\n\n### 部署测试应用程序\n\n在安装 Istio 后部署测试应用程序，以确保它们也接收到 sidecar 注入：\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### 配置 Envoy Gateway\n\n现在配置 Envoy Gateway 以处理边缘流量：\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\n部署应用网关，包括以下容器：\n\n- \u0060istio-init\u0060：由 Istio 注入以修改 pod iptables。\n- \u0060envoy\u0060：由 Envoy Gateway 控制，充当入口网关。\n- \u0060istio-proxy\u0060：由 Istio 注入，负责与内部集群 pod 的通信。\n- \u0060shutdown-manager\u0060：由 Envoy Gateway 控制，负责 pod 生命周期管理。\n\n创建一个 HTTP 路由：\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\n应用路由配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### 发送测试请求\n\n获取网关的负载平衡器 IP 地址并发送测试请求：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\n你应该能看到来自 \u0060httpbin\u0060 服务的正确响应：\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### 启用严格 mTLS\n\n通过应用以下配置启用严格 mTLS：\n\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n\n### 为网关启用 TLS\n\n创建服务签名的根证书和私钥：\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\n为 \u0060www.example.com\u0060 创建证书和私钥：\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n为入口网关创建一个密钥：\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential --key=example_certs\/www.example.com.key --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n配置入口网关：\n\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\n应用配置：\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\n发送测试请求：\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\n你应该可以通过 HTTPS 在网格内访问 \u0060httpbin\u0060 服务。\n\n### 结论\n\n通过将 Envoy Gateway 集成为 Istio 服务网格中的入口网关，你可以利用两者的优势：Istio 的强大服务网格能力和 Envoy Gateway 的高级网关功能。这种设置增强了你的应用程序的安全性、可扩展性和灵活性，提供了无缝且安全的用户体验。通过仔细的配置和正确的工具，管理服务网格内外的流量变得更加高效和有效，确保你的应用程序始终可访问并且安全。\n', '\/blog\/envoy-gateway-integration-istio-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何将 Envoy Gateway 作为 Istio 服务网格中的入口网关集成，增强应用的安全性和可访问性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/08/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 配置安全：如何避免错误配置', '探索常见的 Istio 配置错误及其解决方法，提高服务网格的安全性和稳定性。', '\nIstio 是一个功能强大的服务网格解决方案，提供零信任安全性、可观测性和高级流量管理等功能，且无需修改代码即可实现。然而，由于配置错误，我们经常会遇到意料之外的行为。本文将介绍几种常见的 Istio 配置错误，解析其背后的原理，并通过示意图展示如何识别和解决这些问题。我们还将介绍 Tetrate 提供的工具——[TIS Config Analyzer](https:\/\/docs.tetrate.io\/istio-subscription\/dashboard\/analyzers\/config)，这是一种优化 Istio 操作效率和安全性的工具。\n\n## 配置错误导致的事故案例\n\n以下是两个由于配置错误导致的典型事故案例：\n\n1. **[Amazon Web Services 2017 年停机事件](https:\/\/www.theverge.com\/2017\/3\/2\/14792442\/amazon-s3-outage-cause-typo-internet-server)**：一次简单的输入错误导致了广泛的服务中断，影响了数千个在线服务和应用，突显了即使在成熟的云基础设施中，一个小小的配置错误也会引发严重后果。\n\n2. **[GitLab 2017 年数据丢失事故](https:\/\/about.gitlab.com\/blog\/2017\/02\/01\/gitlab-dot-com-database-incident\/)**：由于配置错误，GitLab 在进行数据库维护时误删除了大量生产数据。尽管备份机制被配置好，但错误的配置阻止了数据的及时恢复。\n\n这些案例表明，正确的配置管理对于防止服务中断和数据丢失至关重要。\n\n## 常见的 Istio 配置错误类型\n\nIstio 配置错误主要分为以下几大类：\n\n1. **AuthorizationPolicy（授权策略）**：命名空间不存在、仅允许 HTTP 方法和完全限定的 gRPC 名称、主机没有匹配的服务注册表条目、字段需要启用 mTLS、未找到服务帐户等。\n2. **DestinationRule（目标规则）**：同一主机子集组合的多个目标规则、主机在服务注册表中没有匹配条目、子集标签在任何匹配主机中未找到等。\n3. **Gateway（网关）**：同一主机端口组合的多个网关、网关选择器在命名空间中未找到匹配的工作负载等。\n4. **Port（端口）**：端口名称必须遵循特定格式、端口的应用协议必须遵循特定格式等。\n5. **Service（服务）**：未找到暴露与服务相同端口的部署等。\n6. **VirtualService（虚拟服务）**：目标权重的路由没有有效的服务、指向不存在网关的虚拟服务等。\n\n## 常见的 Istio 配置错误示例\n\n在 Istio 的日常使用中，以下是一些最常见的配置错误：\n\n1. **虚拟服务指向不存在的网关：**\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n      gateways:\n        - non-existent-gateway\n    \u0060\u0060\u0060\n    在这种情况下，\u0060details\u0060 虚拟服务试图通过一个不存在的 \u0060non-existent-gateway\u0060 进行路由，导致流量管理失败。\n\n2. **虚拟服务引用不存在的服务子集：**\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n    \u0060\u0060\u0060\n    如果 \u0060details\u0060 服务没有定义相应的子集，请求将因无法找到正确的服务实例而被拒绝。\n\n3. **网关找不到指定的服务器凭证：**\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: Gateway\n    metadata:\n      name: cert-not-found-gateway\n      namespace: bookinfo\n    spec:\n      selector:\n        istio: ingressgateway\n      servers:\n        - port:\n            number: 443\n            name: https\n            protocol: HTTPS\n          tls:\n            mode: SIMPLE\n            credentialName: \u0022not-exist\u0022\n    \u0060\u0060\u0060\n    这会导致 TLS 握手失败，因为指定的凭证 \u0060not-exist\u0060 不存在。\n\n## 配置验证\n\n为了减少由于配置错误而导致的服务中断风险，配置验证成为了一个不可或缺的步骤。配置验证可以分为以下两种：\n\n- **静态配置验证**：在配置应用到系统之前进行验证。这包括检查语法错误、完整性以及配置项的有效性。\n- **按需配置验证**：在配置已经应用但可能需要根据实时数据进行调整时进行验证。这种类型的验证有助于适应动态环境中的变化，确保配置的持续正确性。\n\n### 推荐的配置验证工具\n\n#### \u0060istioctl validate\u0060\n\n\u0060istioctl validate\u0060 用于验证 Istio 配置文件（如 YAML 文件）的语法和基本结构，确保配置文件符合 Istio API 的规范。它可以在配置应用到集群之前检测出语法错误和格式问题，是一个静态分析工具，通常结合 CI 流程使用，防止无效配置文件应用到集群中。\n\n#### \u0060istioctl analyze\u0060\n\n[\u0060istioctl analyze\u0060](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/istioctl-analyze\/) 是一个强大的诊断工具，用于分析 Istio 集群的运行状态和配置一致性。它不仅检查配置文件的语法，还可以检查集群中实际应用的配置，找出潜在的问题和冲突。\u0060istioctl analyze\u0060 提供动态分析功能，能够识别集群运行时的配置错误和潜在问题。\n\n\u0060istioctl analyze\u0060 的配置流程如下：\n\n1. **收集配置数据**：首先，\u0060istioctl analyze\u0060 收集来自指定源的 Istio 配置数据。这些源可以是活动的 Kubernetes 集群，也可以是本地的配置文件。\n2. **解析和构建模型**：工具解析收集的配置数据，构建一个内部表示 Istio 配置的模型。\n3. **应用分析规则**：随后，它应用一系列预定义的规则来分析这个模型，检测潜在的配置问题。这些规则涵盖从安全漏洞到性能问题的各种潜在问题。\n4. **生成报告**：分析完成后，\u0060istioctl analyze\u0060 输出一个包含所有发现问题的详细报告。如果没有发现问题，它会通知用户配置看起来没有问题。\n\n下面是 \u0060istioctl analyze\u0060 的工作流程图：\n\n\u0060\u0060\u0060mermaid istio analyze 的工作流程\nflowchart TD\n    A[开始] --\u003e B[选择配置源]\n    B --本地文件--\u003e C[加载本地配置文件]\n    B --实时集群--\u003e D[连接 Kubernetes 集群]\n    B --两者--\u003e E[组合本地文件和集群配置]\n    C --\u003e F[解析配置数据]\n    D --\u003e F\n    E --\u003e F\n    F --\u003e G[构建内部配置模型]\n    G --\u003e H[应用分析规则]\n    H --\u003e I{发现问题?}\n    I --是--\u003e J[生成问题报告]\n    I --否--\u003e K[输出配置无问题]\n    J --\u003e L[结束]\n    K --\u003e L\n\u0060\u0060\u0060\n\n![istioctl analyze 的工作流程](4eb4d5bbb7c8856d609944835aa03993.svg)\n\n#### Kiali\n\n[Kiali](https:\/\/kiali.io) 是管理和可视化 Istio 服务网格的重要工具，提供对网格健康状况、性能和配置状态的实时洞察。通过将 Kiali 集成到 Istio 环境中，可以通过以下方式增强配置安全性：\n\n- **可视化**：Kiali 提供服务网格的图形表示，更容易发现配置错误，如路由错误或缺失的策略。\n- **验证**：有助于验证 Istio 配置，突出显示如配置错误的网关或目标规则等问题，以防这些问题引起麻烦。\n- **安全洞察**：Kiali 提供对安全策略的可见性，确保 mTLS 和授权设置正确实施。\n\n将 Kiali 与 \u0060istioctl validate\u0060 和 \u0060istioctl analyze\u0060 等工具结合使用，能确保更为稳健的方法来预防和解决 Istio 配置错误，进而提升服务网格的安全性和效率。\n\n## Tetrate 的 TIS 中的 Config Analyzer 工具介绍\n\n为了帮助开发者和运维人员避免常见的配置失误，Tetrate 开发了 TIS Dashboard 中的 [Config Analyzer](https:\/\/docs.tetrate.io\/istio-subscription\/dashboard\/analyzers\/config) 工具。该工具能够自动验证 Istio 的配置，根据最佳实践分析服务网格的配置问题，并提供优化建议。Config Analyzer 可以自动检测 Istio 服务网格中的配置问题，提供解释及解决方案，支持按需检测配置中的错误。\n\n![TIS Config Analyzer 可以按需检测配置中的问题](config-validate.png)\n\n## 总结\n\n正确配置 Istio 是确保服务网格健康运行的关键。通过了解和避免常见配置错误，以及利用如 Tetrate 的 TIS Config Analyzer 这样的高级工具，您可以确保 Istio 环境的稳定性和安全性。记住，一个小小的配置错误可能导致整个服务网格的故障，因此持续监控和审核配置是非常必要的。\n\n## 参考\n\n- [Validation - kiali.io](https:\/\/kiali.io\/docs\/features\/validations\/)', '\/blog\/istio-configuration-safety-common-misconfigurations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索常见的 Istio 配置错误及其解决方法，提高服务网格的安全性和稳定性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/podless-kubernetes-istio/">[译] 如何实现无 Pod 的 Kubernetes 和 Istio 部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/podless-kubernetes/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何实现无 Pod 的 Kubernetes 和 Istio 部署', '探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。', '\nKubernetes 经常被批评（有些不公平）操作起来过于复杂，促使大多数人依赖托管服务。然而，[\u0060k3s\u0060](https:\/\/k3s.io\/) 某种程度上颠覆了这一点，将完整的 Kubernetes 发行版打包成一个二进制文件。这非常方便，特别是在物联网等小型环境中运行时；虽然隔离组件对非常大规模、先进的部署有好处，但对较小的环境来说，操作微服务可能只是一种负担——这正是 [Istio 多年前选择重构为更单体架构的原因](https:\/\/blog.christianposta.com\/microservices\/istio-as-an-example-of-when-not-to-do-microservices\/)。\n\n然而，它还是没有那么“精简”。在一个空集群中运行 \u0060k3d cluster create test\u0060 后，我们会在集群中看到各种 pod：\n\n\u0060\u0060\u0060bash\n$ kubectl get pods --all-namespaces\nNAMESPACE     NAME                                      READY   STATUS     RESTARTS  AGE\nkube-system   local-path-provisioner-6c86858495-gc9jq   1\/1     Running    0         2m18s\nkube-system   coredns-6799fbcd5-pdf4b                   1\/1     Running    0         2m18s\nkube-system   helm-install-traefik-crd-cp9s2            0\/1     Completed  0         2m18s\nkube-system   helm-install-traefik-pch7c                0\/1     Completed  1         2m18s\nkube-system   traefik-f4564c4f4-q4lkj                   1\/1     Running    0         2m8s\nkube-system   metrics-server-54fd9b65b-d69w6            1\/1     Running    0         2m18s\nkube-system   svclb-traefik-58c5bb65-sq54b              2\/2     Running    0         2m8s\n\u0060\u0060\u0060\n\n\u003e [\u0060k3d\u0060](https:\/\/github.com\/k3d-io\/k3d\/) 是一个方便的工具，可以在 Docker 内部部署 \u0060k3s\u0060，便于测试。\n\n这是怎么回事？我们的“单二进制 Kubernetes”怎么变成了 6 个不同的容器？\n\n虽然 k3s 将许多组件（\u0060kube-proxy\u0060、\u0060flannel\u0060、\u0060containerd\u0060、\u0060kubelet\u0060 等）嵌入到一个二进制文件中，但其他组件则作为标准 pod 在集群中运行。\n\n此外，一旦我们部署了我们最喜欢的 [服务网格](https:\/\/istio.io\/)，我们将会有更多的 pod，使我们离没有 pod 的目标更远。\n\n## 没有 pod 的 Kubernetes？\n\n那么问题是——我们能否通过进一步推进 \u0060k3s\u0060 的理念，将完整的集群功能嵌入到一个二进制文件中，来获得一个功能齐全的 Kubernetes 和 Istio 部署？\n\n\u003e **警告**：这些是实验性概念；绝不要在生产环境中尝试！\n\n首先，我们可以直接去除一些不必要的组件，如 \u0060servicelb\u0060（负载均衡服务需要）、\u0060traefik\u0060（Ingress 需要）、\u0060local-storage\u0060（PVC 需要）和 \u0060metrics-server\u0060（\u0060kubectl top\u0060 需要）。\n\n这就剩下 \u0060coredns\u0060 和 Istio。\n\n如果我们追求极简，我们肯定会希望使用 Istio 的 [ambient mode](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/getting-started\/)，它完全不需要 sidecar。幸运的是，它开箱即用并且有完整的 [DNS 支持](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)。这让我们可以去掉 \u0060coredns\u0060。\n\n这样一来，如果我们能运行 Istio ambient，就可以去掉 \u0060kube-system\u0060 中的所有内容。这相对简单；难点在于不为 Istio 添加更多的 pod。\n\n## 嵌入 Istio\n\n通过 \u0060k3s\u0060 的一个分支，我修改了它，使 Istio 本身嵌入到 \u0060k3s\u0060 中。\u0060k3s\u0060 可以作为服务器和\/或代理运行。通常你会有 1 个服务器，每个其他节点作为代理运行。\n\n在 \u0060server\u0060 上，我们希望运行 \u0060Istiod\u0060（Istio 的控制平面）。在代理上，我们希望运行 \u0060istio-cni\u0060（每个节点的控制平面）和 \u0060ztunnel\u0060（每个节点的数据平面）。\n\n这三个组件都可以直接嵌入到 \u0060k3s\u0060 中，只需一些工作！\n\n使用这个自定义构建，我们可以通过一些自定义配置启动一个新的 \u0060k3d\u0060 集群，禁用我们不再需要的组件：\n\n\u0060\u0060\u0060yaml\napiVersion: k3d.io\/v1alpha5\nkind: Simple\nmetadata:\n  name: podless\nservers: 1\nagents: 1\noptions:\n  k3d:\n    wait: true\n    timeout: \u002260s\u0022\n    disableLoadbalancer: true\n    disableRollback: true\n  k3s:\n    extraArgs:\n      - arg: --disable-cloud-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable-kube-proxy\n        nodeFilters:\n          - server:*\n      - arg: --disable-network-policy\n        nodeFilters:\n          - server:*\n      - arg: --disable-helm-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable=coredns,servicelb,traefik,local-storage,metrics-server\n        nodeFilters:\n          - server:*\n\u0060\u0060\u0060\n\n这里我们禁用了上面看到的所有 pod，包括一些额外的。\n\n一个显著的例子是 \u0060kube-proxy\u0060。像其他一些项目一样（如 [Cilium](https:\/\/docs.cilium.io\/en\/stable\/network\/kubernetes\/kubeproxy-free\/)），Istio 的 \u0060ztunnel\u0060 可以有效地替代大多数用例中的 \u0060kube-proxy\u0060。\n\n## 无 pod 的服务网格\n\n所有配置就绪后，我们的集群是什么样子？\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNo resources found\n\u0060\u0060\u0060\n\n到目前为止一切顺利....当然，什么都不运行很容易；真正的挑战是保持集群的功能。\n\n让我们部署一些应用程序 pod。再次强调，这些是集群中的唯一 pod：\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNAMESPACE   NAME                     READY   STATUS    RESTARTS   AGE\ndefault     shell-5fff89ccf5-98kgg   1\/1     Running   0          19s\ndefault     echo-66d88ff694-9qprp    1\/1     Running   0          14s\n\u0060\u0060\u0060\n\n然后我们可以发送流量：\n\n\u0060\u0060\u0060\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n\u0060\u0060\u0060\n\n流量完全正常，包括服务流量（以前由 \u0060kube-proxy\u0060 处理）和 DNS（以前由 \u0060coredns\u0060 处理）。现在这些全部由 \u0060ztunnel\u0060 处理，并且所有内容都通过安全的 mTLS 传输。\n\n除了 mTLS 加密，我们还可以基于 mTLS 身份应用策略。同样，这些都由 \u0060ztunnel\u0060 执行。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: allow-default\nspec:\n  action: ALLOW\n  selector:\n    matchLabels:\n      app: echo\n  rules:\n  - from:\n    - source:\n        namespace: [\u0022cluster.local\/ns\/default\/sa\/shell\u0022]\n\u0060\u0060\u0060\n\n现在 \u0060default\u0060 命名空间的流量被允许，但其他流量不被允许。我们可以通过从 \u0060shell\u0060 发送流量以及我在 \u0060other\u0060 命名空间中部署的新测试工作负载来验证这一点：\n\n\u0060\u0060\u0060bash\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n$ kubectl exec deploy\/shell -n other -- curl -s echo\ncommand terminated with exit code 56\n\u0060\u0060\u0060\n\n正如预期的那样，我们的其他应用程序被拒绝了！\n\n此外，如果我们愿意，我们可以将流量升级通过完整的 HTTP 代理（[\u0022waypoint\u0022](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/architecture\/)）：\n\n\u0060\u0060\u0060\n$ istioctl x waypoint apply --enroll-namespace\nwaypoint default\/waypoint applied\n\n$ kubectl get pods\nNAME                        READY   STATUS    RESTARTS   AGE\necho-66d88ff694-czd65       1\/1     Running  \n\n 0          93m\nshell-56bd5dbdbf-f4gh9      1\/1     Running   0          93m\nwaypoint-7cd4dc789f-2s7z2   1\/1     Running   0          41s\n\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nRequestHeader=X-Request-Id:18d72190-9caa-4162-8bc5-4c11518d7568\nHostname=echo-66d88ff694-czd65\n\u0060\u0060\u0060\n\n现在我们的 waypoint 已经部署，所有到命名空间的流量会自动转发到它，在那里可以执行完整的 HTTP 策略。这里，我们可以看到 \u0060X-Request-Id\u0060 被添加到我们的请求中，但我们还可以获得 [自动配置的其他功能](https:\/\/istio.io\/latest\/blog\/2021\/zero-config-istio\/)，以及更多 [我们可以配置的内容](https:\/\/istio.io\/latest\/docs\/tasks\/)。\n\n## 总结\n\n最终，我们能够部署一个完整的 Kubernetes 集群和服务网格，所有基础设施组件嵌入到一个隐藏的节点二进制文件中——集群功能不需要 pod。\n\n这实际操作起来是否实用？不太实用。然而，这确实表明 Kubernetes\/Istio 被认为过于臃肿和复杂的看法并不完全准确。\n\n它真的比典型的集群更简单吗？某种程度上是的……我们确实替换了两个组件（\u0060kube-proxy\u0060 和 \u0060coredns\u0060），但其余的我们基本上只是隐藏和打包。这显然不如完全替换有意义，但也不错。话虽如此，隐藏东西对 [社交媒体参与度](https:\/\/twitter.com\/wm\/status\/1577081662848241664) 有好处，而 \u0060k3s\u0060 通过有效地隐藏和打包取得了巨大成功，因此显然提供了一些实实在在的好处。\n', '\/trans\/podless-kubernetes-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('保障 Istio 安全：解决关键安全漏洞及最佳实践', '探索 Istio 中的关键安全漏洞及其缓解措施，并结合多层安全策略的最佳实践。', '\n## 引言\n\n近期，Wiz 研究团队发布了[博客](\/trans\/sapwned-sap-ai-vulnerabilities-ai-security\/)，揭示了 AI 服务中的租户隔离漏洞，引起了广泛关注。该研究详细阐述了多个 AI 服务供应商存在的安全缺陷，特别是 SAP AI Core 平台。通过合法的 AI 训练过程，研究人员能够绕过 Istio 服务网格中的流量劫持，进而横向移动并接管服务，获取客户的私人文件和云环境凭证。这些发现凸显了当今云服务和管理平台在确保隔离和沙盒环境方面面临的挑战。\n\n{{\u003ccallout tip \u0022关于 UID 1337\u0022\u003e}}\nIstio 选择 UID 1337（leet 的变体）作为 \u0060istio-proxy\u0060 容器中的用户 ID 是为了便于配置并避免权限冲突。这个数字在技术和游戏文化中象征“精英”（elite），有助于防止与其他常规用户 ID 冲突，确保流量管理操作不受权限问题干扰。\n{{\u003c\/callout\u003e}}\n\n在这个背景下，Istio 作为一个重要的服务网格解决方案，同样面临着类似的安全问题，尤其是在 sidecar 注入和流量管理等关键功能上。这篇博客旨在探讨如何保护 Istio 服务网格的安全，并提供一套全面的缓解措施。我们还将讨论多层安全策略如何有效增强 Istio 的安全性，以应对类似 Wiz 报告中提到的挑战。\n\n## 概述\n\nIstio 主要用于管理 Kubernetes 中的东西向流量，提供详细的流量管理功能，如请求路由、负载均衡和故障恢复策略。虽然 Istio 提供了流量加密、认证和授权等安全功能，但它本身不应被视为防火墙。为了确保 Istio 网格中的服务安全，除了使用 Istio 自身的安全功能，还需要结合底层网络和基础设施的安全措施，比如 CNI 和安全容器。此外，微分段技术可以用来实现更细粒度的隔离，提高安全性。\n\n不论是 Sidecar 模式还是 Ambient 模式，都是通过劫持应用程序 Pod 的流量到数据平面代理中进行处理和转发的。如果没有成功拦截到应用程序流量或者被仿冒程序冒充了 Istio 而执行操作，就会有安全漏洞出现。\n\n下图展示了通过绕过或仿冒 Istio 系统用户而造成的安全漏洞存在的位置。\n\n![能够绕过 Istio 中流量劫持的“安全漏洞\u0022](bypass-sidecar-traffic-hijack.svg)\n\n接下来，我们将探讨“安全漏洞”产生的具体情况及应对策略。\n\n## 绕过 Istio Sidecar 注入\n\n### 在命名空间级别禁用注入\n\n- **场景**：应用团队滥用命名空间标签，在命名空间级别禁用 Istio Sidecar 注入。\n- **缓解策略**：平台团队抽象化应用部署，限制对原始 Kubernetes 命名空间资源的访问。\n- **监控**：使用策略引擎（如 OPA Gatekeeper）来确保命名空间标签的合规性，定期审查命名空间的配置。\n\n### 在 Pod 级别禁用注入\n\n- **场景**：应用团队滥用 Pod 标签，在 Pod 级别禁用 Istio Sidecar 注入。\n- **缓解策略**：平台团队抽象化应用部署，限制对原始 Kubernetes Pod 资源的访问。\n- **监控**：使用 Admission Webhook 强制启用 Sidecar 注入，禁止使用排除标签，定期扫描和审计所有 Pod，确保所有需要的 Pod 都注入了 Sidecar。\n\n## 绕过流量重定向到 Istio Sidecar\n\n### 滥用流量重定向注解\n\n- **场景**：应用团队滥用 Pod 注解，排除特定的入站或出站端口或 IP 地址，从而绕过流量重定向。\n- **缓解策略**：平台团队抽象化应用部署，限制对原始 Kubernetes Pod 资源的访问。\n- **监控**：使用策略引擎来检测和警告不合规的注解使用，定期审查 Pod 注解。\n\n### 滥用 Pod 的 UID\n\n- **场景**：应用团队滥用 UID 1337（sidecar 代理的 ID），绕过 Istio Iptables 重定向规则。\n- **缓解策略**：\n  - 强制所有 Pod 指定非 1337 的 UID。\n  - 检查所有容器镜像以检查 UID 1337 并拒绝这些镜像。此检查可以使用准入 Webhook 或由管理镜像注册表的中央团队来执行。\n- **监控**：禁用或限制 UID 1337 的使用，定期审计 Pod 的 UID 配置，确保没有绕过行为。\n\n### 滥用 Pod 能力（NET_ADMIN、NET_RAW）\n\n- **场景**：应用团队滥用 NET_ADMIN 和 NET_RAW 能力，移除 Istio Iptables 规则。\n- **缓解策略**：平台团队启用 Istio CNI（以避免授予应用团队提升的权限），并限制对原始 Kubernetes Pod 资源的访问。\n- **监控**：定期审查和监控 Pod 的权限配置，确保没有越权行为。\n\n## 绕过入站流量约束\n\n### 滥用 PeerAuthentication\n\n- **场景**：应用团队创建一个针对每个命名空间\/每个工作负载的 PeerAuthentication 资源，启用 PERMISSIVE 认证模式。\n- **缓解策略**：平台团队限制对原始 Istio PeerAuthentication 资源的访问。\n- **监控**：定期审查 PeerAuthentication 配置，确保所有入站流量都按照要求加密。\n\n## 绕过出站流量约束\n\n### 滥用 ServiceEntry\n\n- **场景**：应用团队创建一个 ServiceEntry，直接访问外部服务，而无需经过 Egress 网关。\n- **缓解策略**：平台团队限制对原始 Istio ServiceEntry 资源的访问。\n- **监控**：定期审查 ServiceEntry 配置，确保没有绕过行为。\n\n### 滥用 ExternalName 服务\n\n- **场景**：应用团队创建一个类型为 ExternalName 的 Kubernetes Service，直接访问外部服务，而无需经过 Egress 网关。\n- **缓解策略**：平台团队限制对原始 Kubernetes Service 资源的访问。\n- **监控**：定期审查 Kubernetes Service 的类型配置，确保没有绕过行为。\n\n## 无法控制地更改 Istio Sidecar 配置\n\n### 滥用 Sidecar 资源\n\n- **场景**：应用团队创建一个针对每个工作负载的 Istio Sidecar 资源，并将 \u0060outboundTrafficPolicy\u0060 字段设置为 \u0060ALLOW_ANY\u0060（覆盖可能的全局值 \u0060REGISTRY_ONLY\u0060）。\n- **缓解策略**：平台团队限制对原始 Istio Sidecar 资源的访问。\n- **监控**：定期审查 Sidecar 资源配置，确保没有覆盖全局设置的行为。\n\n### 滥用 EnvoyFilter\n\n- **场景**：应用团队创建 EnvoyFilter，导致与现有 Istio 对象冲突，从而引发 DoS 攻击或违反安全策略。\n- **缓解策略**：平台团队限制对原始 Istio EnvoyFilter 资源的访问。\n- **监控**：定期审查 EnvoyFilter 配置，确保没有不当使用行为。\n\n## 服务网格应作为分层防御的一部分\n\n服务网格被描述为现有安全模型的一个补充层，通过在传统安全控制之上添加更细粒度的安全策略来增强微服务的安全性。然而，文章强调了服务网格无法独立保障微服务的全面安全，而是应当作为整体安全策略的一部分。\n\n![微服务安全分层架构](security-layers.svg)\n\n服务网格主要通过在每个服务实例旁部署一个轻量级的代理（sidecar），来管理和控制网络流量。这使得它能够在网络层面上实现精细的流量控制和策略执行，如流量加密、身份认证和授权。尽管服务网格能够提供诸如流量控制、服务发现和断路器等功能，这些功能本质上是对网络流量的管理，无法解决所有安全问题。例如，它不能替代应用层防火墙、入侵检测系统和数据安全等更传统的安全措施。\n\n此外，服务网格依赖于正确的配置和管理，配置不当可能导致安全漏洞。因此，尽管服务网格是现代微服务架构中不可或缺的一部分，它应该与传统的安全措施相结合，共同构成一个全面的、多层次的安全策略框架。参考[如何通过服务网格增强微服务的安全性](\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/)以进一步了解如何加强服务网格的安全。\n\n## 长期解决方案和社区合作\n\nIstio 社区每年都会进行一次安全审计，见 [2021 年](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)、[2022 年](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/) 的安全审计结果。从结果中我们可以看到，Istio 的安全态势有了很大的提升。确保你的 Istio 服务网格符合[安全最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)。另外，你还需要关注 [Istio CVE 公告栏](https:\/\/istio.io\/latest\/news\/security\/)，或者使用如 [Tetrate Istio Subscription](https:\/\/tetrate.io\/tetrate-istio-subscription\/) 这类工具来扫描 Istio 服务网格的各种 CVE，部署符合 FIPS 并经过 FIPS 验证的 Istio 发行版。\n\n## 结论\n\n服务网格通过在应用程序外部管理控制流，为微服务架构提供了额外的安全层。这允许在不影响应用程序性能的前提下，加强服务之间的通信安全。在部署服务网格时，推荐使用 Istio 的 Egress Gateway 来管理出口流量，结合 Kubernetes 的 NetworkPolicy，确保所有出口流量都必须经过网关，从而防止潜在的数据泄露和其他安全威胁。\n\n## 参考\n\n- [How to enforce egress traffic using Istio’s authorization policies - tetrate.io](https:\/\/tetrate.io\/blog\/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies\/)\n- [Istio Security Best Practice - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n- [Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io](https:\/\/tetrate.io\/blog\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/)\n- [Istio publishes results of 2022 security audit - istio.io](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/)\n- [Announcing the results of Istio’s first security assessment - istio.io](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)\n', '\/blog\/securing-istio-addressing-critical-security-gaps-and-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Istio 中的关键安全漏洞及其缓解措施，并结合多层安全策略的最佳实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ztunnel-testing/">[译] 无需 Kubernetes 测试 Kubernetes 网络实现</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/ztunnel-testing/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('无需 Kubernetes 测试 Kubernetes 网络实现', '探讨如何在没有 Kubernetes 环境的情况下测试 Ztunnel 网络代理，该代理为 Istio 的新 Ambient 模式编写。', '\n由于在开发过程中我[真的不喜欢等待](https:\/\/blog.howardjohn.info\/posts\/ideal-ci\/)，所以在构建 Ztunnel（一个为 Istio 的新 [Ambient 模式](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)设计的底层网络代理）时，我的首要任务之一便是确保测试的快速进行（包括运行和编写测试），并且易于调试。\n\n这一任务颇为棘手，因为在大多数真实场景中，Ztunnel 高度依赖 Kubernetes。虽然它能够完全独立于 Kubernetes 运行，但许多关键代码路径的行为完全不同，使得仅通过这种方式进行测试变得不可行。\n\n下图为典型的 Ztunnel 部署架构：\n\n![Ztunnel 架构概览](ztunnel-architecture.svg)\n\n在此架构中，用户将运行一个包含多个节点的 Kubernetes 集群。每个节点上都运行着一个 Ztunnel，配置了宿主机和每个 pod 的网络栈。\n\n此外，Ztunnel 实际上进入了每个 pod 的网络命名空间，并代表其发送\/接收流量。这一点非常奇特且酷炫，但也大大增加了测试的难度！（[详细信息](https:\/\/www.youtube.com\/watch?v=cuMeEhpyH5s)）\n\n## 加速测试\n\n启动完整的 Kubernetes 环境、重建镜像、部署到每个节点的过程非常缓慢且难以调试。\n\n黄金标准应该是将所有操作运行在一个简单的单一二进制文件中——仅需执行 \u0060cargo test\u0060。这种方式避开了复杂的设置和缓慢的重建，并使调试变得轻而易举（当然，你可以将调试器连接到正在运行的 pod，但这很麻烦）。\n\n## 设置网络\n\n如果我们去除无尽的抽象层，Kubernetes pod 实际上只是几个 Linux 命名空间和挂载的组合。Docker 在这方面管理得很好，[bash](https:\/\/github.com\/p8952\/bocker) 也可以。\n\n我们特别关注的是[网络命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/network_namespaces.7.html)，它可以实现网络栈的隔离。每个 pod 都有自己的网络命名空间，通过各种机制连接，允许与同一节点上的其他 pod、其他节点以及外部目的地通信。\n\n好消息是创建网络命名空间非常简单。\n\n\u0060\u0060\u0060shell\n$ sudo ip netns add testing\n\u0060\u0060\u0060\n\n我们的最终目标是设置一系列的网络命名空间，外观与我们在 Kubernetes 上的真实架构类似：\n\n![所需的网络命名空间设置](ztunnel-network-namespaces.svg)\n\n在网络命名空间之间建立连接稍微复杂一些。像  [\u0060cnitool\u0060](https:\/\/www.cni.dev\/docs\/cnitool\/) 这样的工具可以帮助我们完成（它实际上执行了一些 Kubernetes 环境中用于设置网络的相同逻辑，但作为 CLI 工具），但你也可以完全手动操作。我们选择了后者。\n\n最终，我们的设置如下：\n\n- 每个测试都拥有自己的网络命名空间，通过一个桥接设备（\u0060br0\u0060）来促进节点之间的流量。\n- 每个节点配置了一个 \u0060veth\u0060 设备。一端成为节点上的 \u0060eth0\u0060，另一端连接到根命名空间中的 \u0060br0\u0060。\n- 每个 pod 都配置了一个 \u0060veth\u0060 设备。一端成为 pod 上的 \u0060eth0\u0060，另一端位于节点网络命名空间中。\n- 为每个 pod 设置路由以将流量发送到节点。\n- 为每对节点设置路由，以实现跨节点流量。\n\n![所需的网络连接设置](ztunnel-network-devices.svg)\n\n除了根命名空间\/桥接设备外，这与许多现实世界中的 Kubernetes 集群的运行方式相同（在现实世界中，根命名空间是两台机器之间的物理网络）。\n\n你可以在[这里](https:\/\/github.com\/istio\/ztunnel\/blob\/34fce85a6a2b2a85eb170a04096731e2ea4e0e9f\/src\/test_helpers\/netns.rs#L194)找到所有细节。\n\n## 运行测试\n\n一旦我们有了这些命名空间，我们仍然需要一种实际使用它们的方法。幸运的是，Linux 允许在运行时更改当前命名空间线程（这是接下来重要的内容）。这让我们建立了一个基本的帮助函数（真实的代码稍微更复杂）：\n\n\u0060\u0060\u0060rust\nfn run_in_namespace(namespace: Namespace, f: Fn()) { let original_namespace = get_current_namespace(); namespace.enter(); f(); original_namespace.enter(); }\n\u0060\u0060\u0060\n\n有了这个，我们可以轻松地从任意的“pods”或“nodes”执行代码。\n\n然而，我们仍然面临一个问题。我们的所有代码都运行在 [tokio](https:\/\/tokio.rs\/) 异步运行时中，它会根据需要将我们的各种任务安排到物理操作系统线程上（类似于 Go 运行时的工作方式）。由于网络命名空间是线程相关的，所以当我们的任务在线程之间跳转时，这一切都会崩溃。\n\n幸运的是，Rust 给了我们比 Go 更多的关于异步运行时的灵活性——我们可以同时拥有多个！借此，我们能够构建一个能够异步执行 \u0060run_in_namespace\u0060。对于我们想要执行的每个函数，我们启动一个新线程并构建一个专用的单线程异步运行时来处理它：\n\n\u0060\u0060\u0060rust\nasync fn async_run_in_namespace(namespace: Namespace, f: async Fn()) { thread::spawn(move || { run_in_namespace(namespace, || { let rt = tokio::runtime::Builder::new_current_thread().enable_all().build(); rt.block_on(f()) }) }); }\n\u0060\u0060\u0060\n\n我们为每个命名空间运行一次这个函数，因此这里的开销是最小的。如果我们想要运行许多小函数，可以在顶层构建一个抽象来发送工作到线程以执行。\n\n我们需要的最后一件事是一种合理的方法来识别如何调用每个目的地。虽然它们都会被分配一个 IP（基于我们代码中的简单 IPAM 策略），但我们不希望每个测试都必须猜测 IP。为了处理这个问题，我们构建了一个简单的名称解析器。这就像 DNS，但简单得多：对于我们创建的每个“pod”，我们记录一个\u0060name -\u003e IP\u0060的映射，并允许查找 IP。\n\n将所有这些放在一起，一个简单的测试启动了 3 个 pods（客户端、服务器和 ztunnel）在一个单一节点上看起来像这样：\n\n\u0060\u0060\u0060rust\n#[tokio::test] async fn simple_test(){ let ztunnel = manager.deploy_ztunnel(DEFAULT_NODE).await?; let server = manager .workload_builder(\u0022server\u0022, DEFAULT_NODE) .register() .await?; run_tcp_server(server)?; let client = manager .workload_builder(\u0022client\u0022, DEFAULT_NODE) .register() .await?; run_tcp_client(client, manager.resolve(\u0022server\u0022))?; \/\/ ... some assertions here }\n\u0060\u0060\u0060\n\n## 放弃权限\n\n上述设置效果很好，但也带来了一些问题。\n\n基本上设置的每一步都需要提升的 root 权限；这让简单的 \u0060cargo test\u0060 案例的开箱即用变得乏味，通常也不可取。\n\n此外，这会在主机环境中污染大量的命名空间。虽然我们有一些清理过程，但这些并不是 100% 可靠，可能会导致悬挂的命名空间阻碍未来的执行。\n\n解决拥有太多命名空间的问题的方法？更多的命名空间！为此，我们需要的不仅仅是网络命名空间。\n\n[用户命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/user_namespaces.7.html) 允许我们实质上假装是 UID 0 (root)，同时实际上将其映射回我们原始的 UID。这里的力量在于，在该命名空间中，我们可以做一些本来需要 root 权限的事情——特别是创建新的网络命名空间。\n\n然而，我们不能做的一件事是修改主机-root 拥有的文件（这将是明显的权限违规）。尽管我们可能可以绕过它们，但我们在测试中使用的很多工具喜欢触摸 root 文件。这再次可以通过 [mount 命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/mount_namespaces.7.html) 解决，它允许我们将我们拥有的文件绑定挂载到主机-root 拥有的文件上，而不会影响命名空间外的事物。\n\n将所有这些放在一起，我们有这样的东西：\n\n\u0060\u0060\u0060rust\nlet original_uid = get_uid(); \/\/ 首先，进入一个新的用户命名空间。unshare(CloneFlags::CLONE_NEWUSER).unwrap(); \/\/ 将用户命名空间中的 root 映射到我们原始的 UID File::create(\u0022\/proc\/self\/uid_map\u0022).write(format!(\u00220 {original_uid} 1\u0022)); \/\/ 设置一个新的网络命名空间 unshare(CloneFlags::CLONE_NEWNET).unwrap(); \/\/ 设置一个新的挂载命名空间 unshare(CloneFlags::CLONE_NEWNS).unwrap(); \/\/ 将一个文件夹在我们的每个测试目录中挂载到 \/var\/run\/netns mount(tmp_dir.join(\u0022netns\u0022), \u0022\/var\/run\/netns\u0022, MS_BIND); \/\/ 一个方便手动调试的好帮手信息，如果需要的话。let pid = get_pid(); eprintln!(\u0022Starting test in {tmp_dir}. Debug with \u0060sudo nsenter --mount --net -t {pid}\u0060\u0022);\n\u0060\u0060\u0060\n\n如上所述，一个技巧是，进入命名空间是按线程进行的。我们需要在生成任何额外线程之前设置这一点。\n\nRust 实际上为我们提供了这样做的能力，但这意味着我们失去了 \u0060#[tokio::test]\u0060 宏帮助。我们可以写自己的宏，但这有点痛苦。幸运的是，通过 [链接器的花招](https:\/\/crates.io\/crates\/ctor) 我们可以迫使我们的代码在进程执行的非常早期运行。\n\nGo 中的类似方法也有效（请参见 [我写的帮助库](https:\/\/github.com\/howardjohn\/unshare-go)），实际上在那里是必需的，因为设置必须在 Go 运行时启动之前完成（这通常在任何用户代码运行之前很久）。\n\n## 总结\n\n有了所有这些设备，一个完整的测试只需要大约 200 毫秒。一切都在一个单一进程中运行，使调试变得轻而易举。所有的测试也都是完全隔离的，因此可以完全并行运行测试（包括相同的测试，用于压力测试以消除测试缺陷）。\n', '\/trans\/ztunnel-testing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探讨如何在没有 Kubernetes 环境的情况下测试 Ztunnel 网络代理，该代理为 Istio 的新 Ambient 模式编写。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案', '深入了解 Tetrate Enterprise Gateway (TEG) 及其如何与 Istio 服务网格集成 —— 一种基于 Envoy 的企业级网关解决方案，包括它的架构、基本功能以及如何在 Kubernetes 中使用 TEG 来暴露和管理应用。', '\n## TEG 简介\n\nTetrate Enterprise Gateway（TEG）是基于 [Envoy Gateway](https:\/\/gateway.envoyproxy.io\/) (EG) 的企业级解决方案，专门针对 Envoy Proxy 设计，通过 [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 提供更易于消费的 Envoy 代理配置和管理包。TEG 结合了 Kubernetes Gateway API 的特性，支持在 Kubernetes 中轻松暴露服务和应用程序。\n\nTEG 相对于 Envoy Gateway 的主要新增特性包括：\n\n1. **全局速率限制（Rate Limiting）**：TEG 支持基于 IP 5-tuple、请求头等进行流量控制，需要通过 Redis 实例管理。\n2. **WAF 功能（Web Application Firewall）**：TEG 提供了与 \u0060mod_security\u0060 兼容的 WAF 功能，增强了安全防护能力。\n3. **OIDC\/OAuth2认证**：支持在网关级别进行 OIDC\/OAuth2 认证，应用程序可以按路由配置认证方式。\n4. **使用 Kubernetes Gateway API**：相较于其他 API，Kubernetes Gateway API 的设计更加现代，结合了众多 Ingress 实现的经验，将网关的配置与流量的路由分离，使平台所有者可以管理网关，而应用团队可以掌控流量路由。\n\nTEG 将 Envoy 的高级网络流量处理能力带入 Kubernetes 环境，提供了一种简化的方法来部署和管理负载平衡、API 网关功能、安全控制等，同时支持现代的、开放的应用程序暴露 API，如 Kubernetes Gateway API。这些特性使 TEG 成为一个功能丰富、易于管理的企业级网关解决方案。\n\n## TEG 的能力\n\nTetrate Enterprise Gateway for Envoy (TEG) 构建于 Envoy Gateway 项目之上，提供了一种易于使用和操作的入口，具有先进的按请求流量控制功能、与现有环境的轻松集成，以及一流的可观测性，以理解应用流量和入口健康状况。\n\n### 易于安装、操作和升级\n\nTEG 从头到尾注重易用性：从首次安装到启用应用团队，从故障排查到执行升级。TEG 的初始安装只需几分钟，你就可以开始使用高级功能，如速率限制、单点登录和金丝雀流量路由。TEG 还简化了运维流程，与你现有的指标、跟踪和日志记录管道相适应，我们还提供了一个完整的、预配置的可观测性堆栈，以评估 EG 产生的数据，并帮助你计划如何将 TEG 集成到你的现有指标堆栈中。\n\n### 操作性：一流的功能\n\nTEG 由在生产环境中运行大型、关键系统的经验丰富团队构建。TEG 简化了漏洞检查和持续升级过程，与你现有的指标和跟踪提供商轻松集成，并为你现有的 Grafana 部署提供了一套强大的入口可观测性仪表板。\n\n### 与现有的环境集成\n\nTEG 不仅适用于绿地部署的启动，还可以直接与传统环境以及现代云原生环境集成。它可以帮助你在现有的应用生态系统和你正在构建的云原生目标之间架起桥梁。\n\n### 引入现有的可观测性堆栈\n\n你的组织可能已经有一个可观测性系统，你的应用和运营团队已经训练有素地使用它。TEG 可以轻松地嵌入到现有的基础设施中，并在你的组织中运行。TEG 将使 Envoy 的丰富指标集导出，让你的应用团队对其应用流量的行为有最佳的洞察，并看到他们所做配置更改的效果。TEG 还为运行它的平台团队提供了仪表板和警报功能，使你能够自信地操作并快速解决发现的问题。\n\n### 简单的负载平衡\n\nEnvoy 非常强大，但要使其启动并运行简单用例可能很难——像 Istio 这样的系统提供 Envoy 入口管理作为更广泛功能套件的一部分，也附带了许多与简单、流畅的操作体验相冲突的额外功能。这就是 Envoy Gateway 存在的原因：使 Envoy 的强大功能易于用于入口用例。\n\n### 简单的 API 网关\n\n组织中绝大多数 API 网关的使用归结为三件事：认证发起请求的用户；限制用户对服务的访问；在此 API 端点的服务实例之间进行负载平衡。TEG 简化了在传统和云原生环境中完成这三项任务的过程。\n\n## TEG 的架构\n\n下图展示的是 TEG 的架构图。\n\n![TEG 架构图](teg-architecture.svg)\n\n从架构图中可以看出，Tetrate Enterprise Gateway for Envoy (TEG) 的架构设计包括以下主要组件和流程：\n\n### 主要组件\n\n1. **Kubernetes Cluster**\n   - **Envoy Gateway**：作为控制平面，配置和管理 Envoy 代理，消费 Kubernetes Gateway API 的配置。\n   - **Metrics Collection**：使用 Prometheus 或 OpenTelemetry (OTEL) 作为指标收集点，用于监控 Envoy Proxy 的性能和健康状态。\n\n2. **Envoy Proxy**\n   - 作为数据平面，直接处理所有进入的流量，支持基于 Kubernetes Gateway API 的配置。\n\n3. **Coraza WAF**\n   - 作为 TEG 的一部分部署，执行 WAF 规则以保护应用免受恶意请求攻击。\n\n4. **Redis Rate Limit Store**\n   - 作为全局速率限制的存储解决方案，用于跨所有 Envoy 实例维护统一的速率限制计数。\n\n5. **Your OIDC Server**\n   - 处理 OAuth2.0 和 OIDC 认证流程，确保只有经过认证的用户可以访问特定的路由和服务。\n\n### 工作流程\n\n1. **流量入口**\n   - 所有外部流量首先通过上游的负载均衡器，然后被路由到 Envoy Proxy。\n\n2. **Envoy Proxy 处理**\n   - Envoy Proxy 根据 Kubernetes Cluster 中的 Envoy Gateway 的配置处理流量。\n   - 配置信息包括路由规则、安全策略（如 WAF 和速率限制）等。\n\n3. **安全和认证**\n   - **Coraza WAF**：在流量到达应用前，根据配置的 WAF 规则进行检查和过滤，提高安全性。\n   - **OIDC 认证**：OIDC Server 处理认证，Envoy Proxy 根据 OIDC Server 的验证结果决定是否允许访问。\n\n4. **速率限制**\n   - 使用 Redis 存储进行速率限制，Envoy Proxy 将根据从 Redis 获取的数据执行速率限制策略。\n\n5. **性能监控**\n   - Envoy Proxy 的性能和健康状态通过集成的指标收集系统（Prometheus 或 OTEL）进行监控。\n\n### 配置和管理\n\n- 用户可以通过 Kubernetes Gateway API 定义和应用 Envoy Proxy 的配置。\n- 这包括定义专用网关的具体配置，如安全规则、路由策略等。\n\n这种架构设计利用了 Kubernetes 的灵活性和扩展性，并通过 Envoy 提供了强大的流量管理和安全功能。\n\n## 部署 TEG\n\n执行下面的命令部署 TEG V0.0.0：\n\n\u0060\u0060\u0060bash\nexport REGISTRY=\u0022oci:\/\/docker.io\/tetrate\u0022\nexport CHART_VERSION=\u0022v0.0.0-latest\u0022\nhelm install teg ${REGISTRY}\/teg-envoy-gateway-helm \\\n --version ${CHART_VERSION} \\\n -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n检查部署：\n\n\u0060\u0060\u0060bash\nkubectl get pod -n envoy-gateway-system\n\u0060\u0060\u0060\n\n你将看到下面的结果：\n\n\u0060\u0060\u0060\nNAMESPACE              NAME                                                       READY   STATUS    RESTARTS        AGE\nenvoy-gateway-system   envoy-gateway-596dfbcb88-tx7xb                             1\/1     Running   0               3m55s\nenvoy-gateway-system   envoy-ratelimit-674b8c955c-jhlfn                           2\/2     Running   2 (3m48s ago)   3m54s\nenvoy-gateway-system   teg-envoy-gateway-64fd8c8fbb-59b4l                         1\/1     Running   0               3m55s\nenvoy-gateway-system   teg-redis-86bb7d9b9d-27n44                                 1\/1     Running   0               3m55s\n\u0060\u0060\u0060\n\n部署示例应用：\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n部署 Envoy Proxy：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: dedicated-gateway\n  namespace: httpbin\nspec:\n  gatewayClassName: teg\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\nEOF\n\u0060\u0060\u0060\n\n然后你会在 \u0060envoy-gateway-system\u0060 命名空间下看到一个新的 Envoy 代理。\n\n部署 HTTPRoute，给网关配置路由：\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\n  namespace: httpbin\nspec:\n  parentRefs:\n    - group: gateway.networking.k8s.io\n      kind: Gateway\n      name: dedicated-gateway\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \/httpbin\/\n      filters:\n        - type: URLRewrite\n          urlRewrite:\n            path:\n              type: ReplacePrefixMatch\n              replacePrefixMatch: \/\n      backendRefs:\n        - group: \u0022\u0022\n          kind: Service\n          name: httpbin\n          port: 8000\nEOF\n\u0060\u0060\u0060\n\n这个路由配置中有一个 URLRewrite filter，重写 URL 前缀，去掉了 \u0060\/httpbin\/\u0060 部分。\n\n发送流量测试：\n\n\u0060\u0060\u0060bash\nexport DEDICATED_GATEWAY_IP=$(kubectl get gateway\/dedicated-gateway -n httpbin -o jsonpath=\u0027{.status.addresses[0].value}\u0027)\ncurl -i http:\/\/${DEDICATED_GATEWAY_IP}\/httpbin\/get\n\u0060\u0060\u0060\n\n{{\u003ccallout note \u0022为什么使用 \u0060\/httpbin\/get\u0060?\u0022\u003e}}\n\n在通过 Tetrate Enterprise Gateway for Envoy (TEG) 暴露 \u0060httpbin\u0060 应用时，选择 \u0060\/httpbin\/get\u0060 作为访问路径的原因主要是为了在同一个 Envoy 网关下能够同时支持多个应用或服务，并能根据不同的路径将流量正确地路由到指定的服务。\n\n这种路径前缀的设置方法允许系统管理员或开发人员为每个服务配置独立的路径前缀，从而通过单一的入口点（即 Envoy 网关）来管理对多个后端服务的访问。这样的配置增加了路由的灵活性，使得在不更改现有服务配置的情况下，轻松地扩展或修改服务的暴露方式。\n\n{{\u003c\/callout\u003e}}\n\n## 作为 Istio 的入口网关\n\nIstio 提供了成熟且灵活的入口网关支持，基于与 Tetrate Enterprise Gateway（TEG）相同的 Envoy 代理。Istio 主要专注于处理集群内服务之间的通信。相较之下，TEG 设计用于向外界暴露应用，处理人类用户的请求，并支持如 OIDC 单点登录等高级功能。通过结合 Istio 网格和 TEG 的高级网关功能，两者可以共同使用，以提升整体应用的可访问性和安全性。\n\n以下图示展示了 Istio 网格中入口网关的流量路径。\n\n![Istio 中入口网关的流量路径](istio-ingress-sidecar.svg)\n\n下图展示了在引入 TEG 之后，流量如何从 Istio 网格边缘进入到内部。\n\n![引入 TEG 后流量从 Istio 网格边缘进入内部的流量路径](istio-teg-integration.svg)\n\n将 TEG 集成到 Istio 网格中，通过在 TEG 上配置 sidecar 来颁发证书，同时避免 sidecar 拦截 TEG 中的流量。然后通过 Envoy Gateway 控制入口网关的流量路径。\n\n### 为 TEG 与 Istio 的互操作做准备\n\n为了使 TEG 作为 Istio 的入口网关，应注意以下关键点：\n\n- 在安装 Istio 时，避免启用 Ingress Gateway。我们将手动安装并配置 TEG 作为 Istio 的入口网关。\n- 由于 Istio 和 TEG 都使用 Envoy 作为代理，我们需要让 Istio 为 TEG 的网关 Pod 注入 Envoy sidecar，以便 TEG 可以安全地与 Istio 数据平面通信。\n- 配置 Envoy Gateway 创建的 Envoy 代理的[路由类型](https:\/\/gateway.envoyproxy.io\/latest\/api\/extension_types\/#routingtype)为 \u0060Service\u0060 而非 \u0060Endpoint\u0060，确保 Envoy 代理能正确找到路由。\n\n为 TEG 的命名空间添加标签，以确保数据平面获得 Istio sidecar 的注入。\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\n我们还需要配置 TEG 的 sidecar，使其不处理进入网关的 Envoy 流量。注入 sidecar 的目的是使 Envoy Gateway 的组件及其创建的代理能够被纳入 Istio 网格，并挂载正确的证书进行安全通信。\n\n{{\u003c include_code file=\u0022control-plane-tls.yaml\u0022 \u003e}}\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway \\\n     --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\n配置 Envoy Gateway 中的 sidecar 不拦截流量：\n\n{{\u003c include_code file=\u0022teg-sidecars-no-inbound.yaml\u0022 \u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\n修改 GatewayClass 的配置，将上述 sidecar 配置应用到 Envoy Gateway 数据平面的所有 \u0060EnvoyProxy\u0060 上：\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### 安装 Istio\n\n使用 minimal profile 部署 Istio，从而不部署 Ingress Gateway：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### 重启 TEG 控制平面\n\n现在 Istio 的 sidecar 注入已准备就绪，我们将重启所有 TEG 控制平面 Pod，它们将带有 sidecar 重新启动。\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis; \\\n    do kubectl rollout restart deployment -n envoy-gateway-system $d; \\\n    done\n\u0060\u0060\u0060\n\n### 部署测试应用\n\n此步应在安装 Istio 之后进行，以确保它们也获得 sidecar 的注入。\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### 配置 TEG\n\n现在我们配置 TEG 处理边缘流量。\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\n部署应用网关，包含以下容器：\n\n- \u0060istio-init\u0060：由 Istio 注入，负责修改 pod 中的 iptables\n- \u0060envoy\u0060：由 TEG 控制，作为入口网关\n- \u0060istio-proxy\u0060：由 Istio 注入，负责与集群内部 pod 联系\n- \u0060shutdown-manager\u0060：由 TEG 控制，负责 Pod 启停\n\n创建 HTTP 路由：\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### 发送测试请求\n\n获取网关的负载均衡器 IP 地址，并发送测试请求：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\n你将看到来自 \u0060httpbin\u0060 服务的正确响应，如下所示：\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### 启用严格的 mTLS\n\n运行下面的命令启用严格的 mTLS：\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n### 为网关启用 TLS\n\n创建用于服务签名的根证书和私钥：\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\n为 \u0060www.example.com\u0060 创建证书和私钥：\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n为入口网关创建 secret：\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential \\\n  --key=example_certs\/www.example.com.key \\\n  --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\n配置入口网关：\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\n发送测试请求：\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 \\\n  --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\n你将可以通过 HTTPS 访问网格内的 \u0060httpbin\u0060 服务。\n\n## 总结\n\nTetrate Enterprise Gateway 为企业提供了一种强大的网关解决方案，能够在云原生环境中高效地暴露和管理应用服务。通过其基于 Envoy 的架构和对 Kubernetes Gateway API 的支持，TEG 不仅确保了高性能的流量管理，还大幅简化了网关的部署和维护。无论是面对复杂的安全需求还是高流量的业务场景，TEG 都能提供可靠的支持，帮助企业实现其业务连续性和技术创新。\n\n## 参考\n\n- [Using TEG in Conjunction with an Istio Service Mesh - docs.tetrate.io](https:\/\/docs.tetrate.io\/envoy-gateway\/v0.0.0-latest\/howto\/eg-and-istio)\n', '\/blog\/explore-tetrate-enterprise-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入了解 Tetrate Enterprise Gateway (TEG) 及其如何与 Istio 服务网格集成 —— 一种基于 Envoy 的企业级网关解决方案，包括它的架构、基本功能以及如何在 Kubernetes 中使用 TEG 来暴露和管理应用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/sapwned-sap-ai-vulnerabilities-ai-security/">[译] SAPwned：SAP AI 漏洞暴露客户云环境和私有 AI 工件</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.wiz.io/blog/sapwned-sap-ai-vulnerabilities-ai-security" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('SAPwned：SAP AI 漏洞暴露客户云环境和私有 AI 工件', '本文通过研究 SAP AI Core，揭示了多个安全漏洞，这些漏洞可能允许攻击者访问客户数据和内部工件。', '\n## AI 是否存在隔离问题？\n\n在过去的几个月里，我们 Wiz 研究团队对多个 AI 服务提供商进行了广泛的租户隔离研究。我们认为这些服务更容易受到租户隔离漏洞的影响，因为它们允许用户运行 AI 模型和应用程序，这等同于执行任意代码。随着 AI 基础设施越来越成为许多商业环境的标配，这些攻击的影响正变得越来越重要。\n\n我们将在即将举行的 Black Hat 会议上展示这个研究项目的发现，在我们的会议“隔离还是幻觉？为乐趣和权重黑客攻击 AI 基础设施提供商”。\n\n在这个项目的最新一期中，我们研究了 SAP 的 AI 产品，恰当地命名为“SAP AI Core”。这是我们系列中的第三份报告，继我们对 Hugging Face 和 Replicate 平台的研究之后。本博客将探索漏洞链并详细介绍我们的发现，称为“SAPwned”，同时也将观察到确保管理 AI 平台安全的潜在影响和更广泛的启示。\n\n## 执行摘要\n\nAI 训练过程需要访问大量敏感客户数据，这使 AI 训练服务成为攻击者的诱人目标。SAP AI Core 提供与 HANA 及其他云服务的集成，通过云访问密钥访问客户的内部数据。这些凭据非常敏感，我们的研究目标是确定潜在的恶意行为者是否能够访问这些客户秘密。\n\n我们对 SAP AI Core 的研究始于使用 SAP 的基础设施执行合法的 AI 训练程序。通过执行任意代码，我们能够横向移动并接管服务——获取客户的私有文件以及客户云环境的凭据：AWS、Azure、SAP HANA Cloud 等。我们发现的漏洞可能允许攻击者访问客户数据并污染内部工件——蔓延到相关服务和其他客户环境。\n\n具体来说，我们获得的访问权限允许我们：\n\n- 在 SAP 的内部容器注册表上读取和修改 Docker 镜像\n\n- 在 Google 容器注册表上读取和修改 SAP 的 Docker 镜像\n\n- 在 SAP 的内部 Artifactory 服务器上读取和修改工件\n\n- 获得 SAP AI Core 的 Kubernetes 集群的集群管理员权限\n\n- 访问客户的云凭证和私有 AI 工件\n\n![我们研究发现的逐步插图](f1.png)\n\n我们发现这些问题的根本原因是攻击者可以运行恶意 AI 模型和训练程序，这本质上是代码。在审查了几个主要 AI 服务之后，我们认为行业必须改进其在运行 AI 模型时的隔离和沙箱标准。\n\n所有漏洞已报告给 SAP 的安全团队，并由 SAP 修复，如其网站所确认。我们感谢他们的合作。没有客户数据受到泄露。\n\n## 介绍：研究开始\n\nSAP AI Core 是一项服务，允许用户以可扩展和管理的方式在 SAP 的庞大云资源上开发、训练和运行 AI 服务。类似于其他云提供商（和 AI 基础设施提供商），客户的代码在 SAP 的共享环境中运行——构成跨租户访问的风险。\n\n我们的研究始于作为 SAP 客户，基本权限允许我们创建 AI 项目。因此，我们首先在 SAP AI Core 上创建了一个常规 AI 应用程序。SAP 的平台允许我们提供一个 Argo Workflow 文件，该文件反过来生成了一个根据我们的配置的新 Kubernetes Pod。\n\n![SAP AI Core 上的 Argo 工作流配置示例](f2.png)\n\n这允许我们在 Pod 中按设计运行我们自己的任意代码——不需要任何漏洞。然而，我们的环境受到了相当大的限制。我们很快意识到，我们的 Pod 的网络访问非常有限，这是由 Istio 代理 sidecar 强制执行的——因此，扫描内部网络对我们来说不是一个选项。至少现在不是。\n\n## Bug #1: 通过 1337 的力量绕过网络限制\n\n我们首先尝试的是为我们的 Pod 配置“有趣”的权限。然而，SAP 的准入控制器阻止了我们尝试的所有危险安全选项——例如，以\u0060root\u0060身份运行我们的容器。\n\n尽管如此，我们发现准入控制器未能阻止两种有趣的配置。\n\n第一个是\u0060shareProcessNamespace\u0060，它允许我们与我们的 sidecar 容器共享进程命名空间。由于我们的 sidecar 是 Istio 代理，我们获得了对 Istio 的配置的访问权限，包括对集群的集中式 Istiod 服务器的访问令牌。\n\n![通过我们的 sidecar 容器访问 Istio 令牌](f3.png)\n\n另一个是\u0060runAsUser\u0060（和\u0060runAsGroup\u0060）。虽然我们不能成为 root，但所有其他 UID 都是允许的——包括 Istio 的 UID，讽刺的是，这个 UID 是\u00601337\u0060（是的，真的）。我们将我们的 UID 设置为 1337，并成功地以 Istio 用户的身份运行。由于 Istio 本身是[从 Istio 的 iptables 规则中排除的](https:\/\/istio.io\/latest\/docs\/reference\/config\/analysis\/ist0144\/)——我们现在运行时没有任何流量限制！\n\n![发送请求到内部网络——在 UID 1337 之前和之后](f4.png)\n\n我们摆脱了流量束缚，开始扫描我们 Pod 的内部网络。使用我们的 Istio 令牌，我们能够从 Istiod 服务器读取配置并了解内部环境——这引导我们进行了以下发现。\n\n## Bug #2: Loki 泄露 AWS 令牌\n\n我们在集群中找到了一个 Grafana Loki 的实例，因此我们请求了\u0060\/config\u0060端点以查看 Loki 的配置。API 响应了完整的配置，包括 Loki 用来访问 S3 的 AWS 密钥：\n\n![来自 SAP 的 Loki 服务器的配置摘录](f5.png)\n\n这些密钥授予访问 Loki 的 S3 存储桶的权限，其中包含 AI Core 服务（SAP 称其不敏感）和客户 Pods 的大量日志。\n\n![Loki 的 S3 存储桶中的部分文件列表](f6.png)\n\n## Bug #3: 未经身份验证的 EFS 共享暴露用户文件\n\n在内部网络中，我们发现了 6 个 AWS Elastic File System（EFS）实例，监听端口 2049。EFS 实例的一个[常见问题](https:\/\/youtu.be\/HcNmkCRXFdE)是它们默认配置为公共的——这意味着只要您可以访问其 NFS 端口，就不需要凭据即可查看或编辑文件。这些实例也不例外，我们使用简单的开源 NFS 工具，可以自由访问共享的内容。\n\n列出这些 EFS 实例上存储的文件，揭示了大量 AI 数据，包括代码和训练数据集，按客户 ID 分类：\n\n![](f7.png)\n\n![两个 EFS 共享的部分文件列表；每个文件夹代表一个不同的客户 ID](f8.png)\n\n## Bug #4: 未经身份验证的 Helm 服务器危及内部 Docker 注册表和 Artifactory\n\n我们在网络上最有趣的发现是一个名为 Tiller 的服务，这是 Helm 包管理器的服务器组件（版本 2）。\n\n与 Tiller 的通信是通过其 gRPC 接口在端口 44134 进行的，该端口默认是未经身份验证的。\n\n在我们的内部网络上查询这个服务器，揭示了对 SAP 的 Docker 注册表以及其 Artifactory 服务器的高权限密钥：\n\n![通过 Helm 服务器查询暴露的容器注册表和 Artifactory 凭据](f9.png)\n\n使用这些密钥的读取权限，潜在的攻击者可以读取内部图像和构建，提取商业秘密，可能还包括客户数据。\n\n使用这些密钥的写权限，攻击者可以篡改图像和构建，对 SAP AI Core 服务进行供应链攻击。\n\n## Bug #5: 未经身份验证的 Helm 服务器危及 K8s 集群，暴露 Google 访问令牌和客户秘密\n\nHelm 服务器暴露了读写操作。尽管读取权限暴露了敏感的秘密（如上所示），但服务器的写权限允许完全接管集群。\n\nTiller 的\u0060install\u0060命令接受一个 Helm 包并将其部署到 K8s 集群。我们创建了一个恶意 Helm 包，生成了一个具有\u0060cluster-admin\u0060权限的新 Pod，并运行了安装命令。\n\n现在我们在集群上运行具有完全权限！\n\n![通过 Helm 获得的 K8s 权限的部分列表](f10.png)\n\n使用这种访问级别，攻击者可以直接访问其他客户的 Pods 并窃取敏感数据，如模型、数据集和代码。这种访问还允许攻击者干扰客户的 Pods，污染 AI 数据并操纵模型的推理。\n\n此外，这种访问级别还将允许我们查看客户自己的秘密——甚至超出 SAP AI Core 范围的秘密。例如，我们的 AI Core 账户包含了我们的 AWS 账户（用于 S3 数据访问）、我们的 SAP HANA 账户（用于 Data Lake 访问）和我们的 Docker Hub 账户（用于拉取我们的镜像）的秘密。使用我们新获得的访问级别，我们查询了这些秘密，并设法以纯文本形式访问它们所有：\n\n![使用我们的 K8s 权限访问客户秘密](f11.png)\n\n同样的查询还揭示了一个名为\u0060sap-docker-registry-secret\u0060的 SAP 访问 Google 容器注册表的密钥。我们已经确认这个密钥授予了读写权限——进一步扩大了潜在供应链攻击的范围。\n\n## 启示\n\n我们对 SAP AI Core 的研究表明，深度防御的重要性。我们面临的主要安全障碍是 Istio 阻止我们的流量到达内部网络。一旦我们能够绕过这个障碍，我们就获得了对几个内部资产的访问权限，这些资产不需要任何其他身份验证——这意味着内部网络被视为可信的。加固这些内部服务本可以将这次攻击的影响降至最低，将其从完全服务接管降级为轻微的安全事件。\n\n符合我们之前与 K8s 相关的漏洞，这项研究还展示了在管理服务中使用 K8s 的租户隔离陷阱。控制平面（服务逻辑）和数据平面（客户计算）之间的关键分离受到了 K8s 架构的影响，该架构通过 API、身份、共享计算和软件分段网络允许它们之间的逻辑连接。\n\n此外，这项研究表明，AI R\u0026D 过程引入的独特挑战。AI 培训本质上需要运行任意代码；因此，应该有适当的保护措施，确保不受信任的代码与内部资产和其他租户正确分离。\n\n## 披露时间线\n\n-   **2024 年 1 月 25 日** – Wiz 研究报告安全发现给 SAP\n\n-   **2024 年 1 月 27 日** – SAP 回复并分配了一个案件编号\n\n-   **2024 年 2 月 16 日** – SAP 修复了第一个漏洞并旋转了相关的秘密\n\n-   **2024 年 2 月 28 日** – Wiz 研究绕过补丁使用 2 个新漏洞，报告给 SAP\n\n-   **2024 年 5 月 15 日** – SAP 部署修复了所有报告的漏洞\n\n-   **2024 年 7 月 17 日** – 公开披露\n\n## 保持联系！\n\n嗨，我们是 Wiz 研究团队的 Hillai Ben-Sasson（[@hillai](https:\/\/twitter.com\/hillai)），Shir Tamari（[@shirtamari](https:\/\/twitter.com\/shirtamari)），Nir Ohfeld（[@nirohfeld](https:\/\/twitter.com\/nirohfeld)），Sagi Tzadik（[@sagitz_](https:\/\/twitter.com\/sagitz_)) 和 Ronen Shustin（[@ronenshh](https:\/\/twitter.com\/ronenshh)）。我们是一群资深白帽黑客，我们的目标是让云成为每个人更安全的地方。我们主要关注在云中找到新的攻击向量并揭露云供应商的隔离问题。\n\n我们很想听听您的意见！欢迎通过 Twitter 或电子邮件与我们联系：[research@wiz.io](mailto:research@wiz.io)。\n', '\/trans\/sapwned-sap-ai-vulnerabilities-ai-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文通过研究 SAP AI Core，揭示了多个安全漏洞，这些漏洞可能允许攻击者访问客户数据和内部工件。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/page/11/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(71)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(41)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-data-plane-deployment-modes/">深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
