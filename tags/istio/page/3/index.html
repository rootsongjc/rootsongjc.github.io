<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-keycloak-authentication-authorization/">[译] 使用 Istio 和 Keycloak 实现身份验证和授权</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://platform.ex-offenders.co.uk/docs/auth.html" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Istio 和 Keycloak 实现身份验证和授权', '本指南介绍了如何利用 Istio 和 Keycloak 来实现身份验证和授权，简化开发流程，让开发人员能够专注于核心任务。', '\n在本指南中，我们将探讨如何利用 Istio 和 Keycloak 实现身份验证和授权。目标是简化开发流程，使开发者可以专注于核心任务，而不需要担心身份验证和授权问题。我们将通过实际示例和有效的示例代码，逐步讲解此过程。\n\n![网格](auth.png)\n\n## Keycloak 介绍\n\nKeycloak 是一个开源的身份及访问管理解决方案，提供单点登录（SSO）功能，允许用户一次认证后，使用单一凭证访问多个应用程序和服务。我特别印象深刻的一个功能是 Keycloak 的开发流程简化能力，它支持集成自定义主题，例如登录页面。在这个场景中，我们已将 Keycloak 部署在同一个 Kubernetes 集群内。\n\n以下是我们用于构建自定义 Keycloak 镜像的 Dockerfile。\n\n\u0060\u0060\u0060\nFROM quay.io\/keycloak\/keycloak:24.0.3\nCOPY .\/ex-offenders-theme \/opt\/keycloak\/themes\/ex-offenders-theme\nCOPY .\/providers\/create-account-custom-spi.jar \/opt\/keycloak\/providers\/create-account-custom-spi.jar\n\u0060\u0060\u0060\n\n我们使用以下部署清单来部署 Keycloak。\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: keycloak\n  namespace: keycloak\n  labels:\n    app: keycloak\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: keycloak\n  template:\n    metadata:\n      labels:\n        app: keycloak\n    spec:\n      serviceAccountName: keycloak\n      automountServiceAccountToken: true\n      containers:\n        - name: keycloak\n          image: eocontainerregistry.azurecr.io\/keycloak:v1.8.6 # {\u0022$imagepolicy\u0022: \u0022flux-system:keycloak\u0022}\n          args: [\u0022start\u0022]\n          env:\n            - name: KEYCLOAK_ADMIN\n              value: \u0022admin\u0022\n            - name: KEYCLOAK_ADMIN_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: keycloak\n                  key: admin-password\n            - name: KC_HOSTNAME\n              value: auth.ex-offenders.co.uk\n            - name: KC_PROXY\n              value: \u0022edge\u0022\n            - name: KC_DB\n              value: mysql\n            - name: KC_DB_URL\n              value: \u0022jdbc:mysql:\/\/keycloakdb-keycloakdb-mysql.keycloakdb.svc.cluster.local:3306\/keycloakdb\u0022\n            - name: KC_DB_USERNAME\n              value: \u0022keycloak-user\u0022\n            - name: jgroups.dns.query\n              value: keycloak\n            - name: KC_DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: keycloak\n                  key: db-password\n          ports:\n            - name: http\n              containerPort: 8080\n            - name: jgroups\n              containerPort: 7600\n      imagePullSecrets:\n        - name: acr-secret\n\u0060\u0060\u0060\n\n请注意，在清单文件中提到的 FluxCD \u0060imagepolicy\u0060 引用。借助此功能，我们可以在镜像库中有新镜像可用时自动化部署。\n\n## Istio 介绍\n\nIstio 是一个开源的服务网格平台，旨在管理微服务的通信和数据共享。它提供了多种功能，以提升微服务应用的可观测性、安全性和管理能力。我们将很快讨论如何配置 Istio。\n\n## FastAPI 介绍\n\nFastAPI 是一个现代的 Python 框架，迅速获得了广泛的流行。它设计用于快速开发并最大化开发者体验。在这个示例中，我们将使用两个版本的 job API（[V1](https:\/\/github.com\/ex-offenders\/job-service-v1), [V2](https:\/\/github.com\/ex-offenders\/job-service-v2)）编写于 FastAPI。这个 API 使用 SQLModel 库与后端数据库进行交互，结合了 SQLAlchemy 和 Pydantic 的功能。\n\nSQLModel 是由与 FastAPI 相同的作者开发的。\n\n## 部署无认证与授权的 job-service 微服务\n\n让我们从更简单的事情开始：一个没有任何认证和授权的 job 微服务。\n\n这是 job-service v1 和 job-service v2 的部署清单，均在“job-service”命名空间运行。注意每个部署清单中的版本标签。\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: job-service\n    version: v1\n  name: job-service\n  namespace: job-service\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: job-service\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: job-service\n        version: v1\n    spec:\n      serviceAccountName: job-service\n      automountServiceAccountToken: true\n      containers:\n      - image: eocontainerregistry.azurecr.io\/job-service:v1.0.3 # {\u0022$imagepolicy\u0022: \u0022flux-system:job-service-v1\u0022}\n        name: job-service\n        env:\n        - name: DB_HOST\n          value: \u0022keycloakdb-keycloakdb-mysql.keycloakdb.svc.cluster.local\u0022\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: job-service\n              key: db-password\n        - name: DB_PORT\n          value: \u00223306\u0022\n        - name: DB_USER\n          value: \u0022job-service\u0022\n        - name: DB_NAME\n          value: \u0022job-service\u0022\n        resources:\n          requests:\n            memory: \u002264Mi\u0022\n            cpu: \u002250m\u0022\n      imagePullSecrets:\n      - name: acr-secret\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: job-service\n    version: v2\n  name: job-service-v2\n  namespace: job-service\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: job-service\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: job-service\n        version: v2\n    spec:\n      serviceAccountName: job-service\n      automountServiceAccountToken: true\n      containers:\n      - image: eocontainerregistry.azurecr.io\/job-service-v2:v1.1.3 # {\u0022$imagepolicy\u0022: \u0022flux-system:job-service-v2\u0022}\n        name: job-service\n        env:\n        - name: DB_HOST\n          value: \u0022keycloakdb-keycloakdb-mysql.keycloakdb.svc.cluster.local\u0022\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: job-service\n              key: db-password\n        - name: DB_PORT\n          value: \u00223306\u0022\n        - name: DB_USER\n          value: \u0022job-service\u0022\n        - name: DB_NAME\n          value: \u0022job-service\u0022\n        resources:\n          requests:\n            memory: \u002264Mi\u0022\n            cpu: \u002250m\u0022\n      imagePullSecrets:\n      - name: acr-secret\n\u0060\u0060\u0060\n\n我们还有一个 ClusterIP 服务，选择器为“app=job-service”。这个配置确保了 job-service v1 和 job-service v2 都被添加为这个服务的端点。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: job-service\n    kustomize.toolkit.fluxcd.io\/name: flux-system\n    kustomize.toolkit.fluxcd.io\/namespace: flux-system\n  name: job-service\n  namespace: job-service\nspec:\n  ports:\n  - port: 80\n    name: http\n    protocol: TCP\n    targetPort: 8080\n  selector:\n    app: job-service\n  type: ClusterIP\n\u0060\u0060\u0060\n\n注意，我们使用同一个数据库实例为 Keycloak 和不同版本的 job-service。然而，各自的用户被限制不得访问对方的数据库。尽管共享同一个实例，这种设置有效地模拟了微服务架构。\n\n首先，我们希望将所有流量独占路由到 v1 部署。（如果你查看 job-service v1，你会看到它编写时没有包括任何认证或授权代码。我们计划在接下来的步骤中使用 Istio 实现这些功能。）\n\n为此，我们创建了如下的虚拟服务和目标规则。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: job-service\n  namespace: job-service\nspec:\n  hosts:\n    - \u0022www.ex-offenders.co.uk\u0022\n    - \u0022ex-offenders.co.uk\u0022\n    - job-service.job-service.svc.cluster.local\n  gateways:\n    - istio-system\/gateway\n    - mesh\n  http:\n    - match:\n        - uri:\n            prefix: \u0022\/api\/jobs\u0022\n        - uri:\n            prefix: \u0022\/api\/jobcategories\u0022\n      route:\n        - destination:\n            host: job-service.job-service.svc.cluster.local\n            subset: v1\n          weight: 100\n        - destination:\n            host: job-service.job-service.svc.cluster.local\n            subset: v2\n          weight: 0\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: job-service\n  namespace: job-service\nspec:\n  host: job-service.job-service.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n\u0060\u0060\u0060\n\n注意，在网关部分下，我们指定了我们的入口网关和“mesh”。这是因为我们期望来自外部网关和集群内其他微服务的流量。观察我们如何将 100% 的流量定向到 v1 部署。\n\n下面是 Istio 网关资源。它处理目标为 ex-offenders.co.uk 域的流量。此外，我们使用 cert-manager 将 Let\u0027s Encrypt TLS 证书附加到网关。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-system\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n    - port:\n        number: 443\n        name: https\n        protocol: HTTPS\n      tls:\n        mode: SIMPLE\n        credentialName: ex-offenders-tls\n      hosts:\n      - \u0022www.ex-offenders.co.uk\u0022\n      - \u0022ex-offenders.co.uk\u0022\n      - \u0022auth.ex-offenders.co.uk\u0022\n\u0060\u0060\u0060\n\n我们可以使用 Kiali 仪表板来验证我们的路由配置。注意，\u0060job-service\u0060 连接到同一个 \u0060keycloakdb\u0060 MySQL 实例。但实际上，\u0060job-service\u0060 只能访问实例内的特定 \u0060job-service\u0060 数据库。\n\n![路由](kiali.png)\n\n现在我们准备进行一些测试。\n\n### 创建新的 job 类别\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--data \u0027{\n    \u0022name\u0022: \u0022Information Technology\u0022\n}\u0027\n{\u0022name\u0022:\u0022Information Technology\u0022,\u0022id\u0022:17}\n\u0060\u0060\u0060\n\n### 创建新 job\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobs\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--data \u0027{\n  \u0022title\u0022: \u0022Software Engineer\u0022,\n  \u0022description\u0022: \u0022Software Engineer with 2 years of experience\u0022,\n  \u0022owner_id\u0022: \u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\n  \u0022category_id\u0022: 17\n}\u0027\n{\u0022title\u0022:\u0022Software Engineer\u0022,\u0022description\u0022:\u0022Software Engineer with 2 years of experience\u0022,\u0022owner_id\u0022:\u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\u0022category_id\u0022:17,\u0022id\u0022:\u0022f19e68da-e40a-4954-9dbf-6dfaf1f7f4d4\u0022}\n\u0060\u0060\u0060\n\n### 通过 ID 获取 job 类别\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/17\u0027\n{\u0022name\u0022:\u0022Information Technology\u0022,\u0022id\u0022:17}\n\u0060\u0060\u0060\n\n### 通过 ID 获取 job\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobs\/bff285f6-34f6-4c5f-9619-2e860bec2d87\u0027\n{\u0022title\u0022:\u0022Software Engineer\u0022,\u0022description\u0022:\u0022Software Engineer with 2 years of experience\u0022,\u0022owner_id\u0022:\u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\u0022category_id\u0022:17,\u0022id\u0022:\u0022bff285f6-34f6-4c5f-9619-2e860bec2d87\u0022}\n\u0060\u0060\u0060\n\n如您所见，这些端点没有身份验证或授权。任何人都可以创建、更新、删除或检索 job 和 job 类别。\n\n请注意，我使用与 FastAPI 集成的 Swagger 生成了样本 curl 请求。\n\n另请注意，当创建新 job 时，我们手动传递了 \u0060owner_id\u0060。理想\n\n情况下，这应该是已登录用户的用户 ID。我们将在讨论 job-service v2 时进一步深入探讨这个问题。\n\n## 使用 Istio 实现认证\n\n让我们开始保护我们的端点。\n\n首先，我们添加 RequestAuthentication 资源，定义对 job 负载支持的请求认证。这个配置确保 Istio 拒绝任何具有无效认证信息的请求。下面，我们定义了我们的 Keycloak 发行者 URL 和公开证书 URL，以便 Istio 验证令牌签名。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: RequestAuthentication\nmetadata:\n  name: job-service\n  namespace: job-service\nspec:\n  selector:\n     matchLabels:\n      app: job-service\n  jwtRules:\n   - issuer: \u0022https:\/\/auth.ex-offenders.co.uk\/realms\/ex-offenders\u0022\n     jwksUri: \u0022https:\/\/auth.ex-offenders.co.uk\/realms\/ex-offenders\/protocol\/openid-connect\/certs\u0022\n     forwardOriginalToken: true\n\u0060\u0060\u0060\n\n此外，我们设定了“forwardOriginalToken”: true，因为我们需要以“Authorization: Bearer”格式将令牌传递给后端服务。您还可以使用以下代码片段将令牌作为“jwt_parsed”键的值传递给后端服务。\n\n\u0060\u0060\u0060yaml\n   jwtRules:\n    - issuer: \u0022https:\/\/auth.ex-offenders.co.uk\/realms\/ex-offenders\u0022\n      jwksUri: \u0022https:\/\/auth.ex-offenders.co.uk\/realms\/ex-offenders\/protocol\/openid-connect\/certs\u0022\n      outputPayloadToHeader: jwt-parsed\n\u0060\u0060\u0060\n\n现在，RequestAuthentication 将拒绝任何带有无效令牌的请求。然而，没有任何认证信息的请求仍然会被接受，但它们不会有一个经过认证的身份。为了处理这些情况，除了 RequestAuthentication 外，我们需要添加授权政策来拒绝缺少认证身份的请求。因此，我们按如下方式添加一个授权策略：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: job-service\n  namespace: job-service\nspec:\n  selector:\n    matchLabels:\n       app: job-service\n  rules:\n  - to:\n    - operation:\n        methods: [\u0022GET\u0022]\n  - from:\n    - source:\n        requestPrincipals: [\u0022*\u0022]\n    to:\n    - operation:\n        methods: [\u0022POST\u0022, \u0022DELETE\u0022, \u0022PATCH\u0022]\n        paths: [\u0022\/api\/jobs*\u0022]\n    - operation:\n        methods: [\u0022POST\u0022, \u0022DELETE\u0022, \u0022PATCH\u0022]\n        paths: [\u0022\/api\/jobcategories*\u0022]\n\u0060\u0060\u0060\n\n因此，上述 AuthorizationPolicy 允许任何人无限制地访问 GET 方法。然而，对 job 和 jobcategory 端点的任何其他方法都需要认证。\n\n让我们测试一些端点：\n\n### 创建新 job\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobs\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--data \u0027{\n  \u0022title\u0022: \u0022Software Engineer II\u0022,\n  \u0022description\u0022: \u0022Software Engineer with 2 years of experience\u0022,\n  \u0022owner_id\u0022: \u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\n  \u0022category_id\u0022: 17\n}\u0027\nRBAC: access denied\n\u0060\u0060\u0060\n\n### 通过 ID 获取 job\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobs\/bff285f6-34f6-4c5f-9619-2e860bec2d87\u0027\n{\u0022title\u0022:\u0022Software Engineer\u0022,\u0022description\u0022:\u0022Software Engineer with 2 years of experience\u0022,\u0022owner_id\u0022:\u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\u0022category_id\u0022:17,\u0022id\u0022:\u0022bff285f6-34f6-4c5f-9619-2e860bec2d87\u0022}\n\u0060\u0060\u0060\n\n### 创建新的 job 类别\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--data \u0027{\n    \u0022name\u0022: \u0022Computer Science\u0022\n}\u0027\nRBAC: access denied\n\u0060\u0060\u0060\n\n### 通过 ID 获取 job 类别\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/17\u0027\n{\u0022name\u0022:\u0022Information Technology\u0022,\u0022id\u0022:17}\n\u0060\u0060\u0060\n\n正如观察到的，我们可以在没有认证的情况下检索信息。然而，添加、修改或删除条目需要认证。\n\n接下来，让我们通过调用 Keycloak 令牌 URL 生成令牌，并使用它来执行添加、修改或删除操作：\n\n### 生成令牌\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/auth.ex-offenders.co.uk\/realms\/ex-offenders\/protocol\/openid-connect\/token\u0027 \\\n--header \u0027Content-Type: application\/x-www-form-urlencoded\u0027 \\\n--data-urlencode \u0027grant_type=password\u0027 \\\n--data-urlencode \u0027client_id=ex-offenders-platform\u0027 \\\n--data-urlencode \u0027username=\u003cusername\u003e\u0027 \\\n--data-urlencode \u0027password=\u003cpassword\u003e\u0027\n\u0060\u0060\u0060\n\n这将返回一个访问令牌，我们可以用它进行后续请求。\n\n### 创建新 job\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobs\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--header \u0027Authorization: Bearer \u003ctoken\u003e\u0027 \\\n--data \u0027{\n  \u0022title\u0022: \u0022Software Engineer II\u0022,\n  \u0022description\u0022: \u0022Software Engineer with 2 years of experience\u0022,\n  \u0022owner_id\u0022: \u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\n  \u0022category_id\u0022: 17\n}\u0027\n\n{\n    \u0022title\u0022: \u0022Software Engineer II\u0022,\n    \u0022description\u0022: \u0022Software Engineer with 2 years of experience\u0022,\n    \u0022owner_id\u0022: \u00225690cc29-5008-4a81-8f08-db92e01d6d44\u0022,\n    \u0022category_id\u0022: 17,\n    \u0022id\u0022: \u0022571c9ce6-566f-4e57-a780-9af5275ce5ef\u0022\n}\n\u0060\u0060\u0060\n\n如所示，经过认证的用户能够成功地添加、修改或删除 job 和 job 类别。\n\n## 使用 Istio 实现授权\n\n在这一点上，我们已经配置了认证。就 job 类别而言，我们不预期数据库中存在大量类别。有理由维持有限数量的 job 类别，并将创建、修改和删除权限限制给管理员用户。\n\n当前，任何具有有效认证的用户都可以修改 job 类别。让我们看看如何实现授权。\n\n我们修改授权政策，以确保只有拥有管理员角色的用户可以修改 job 类别。或者，如果您有更复杂的用户层次结构，您也可以使用“组”。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: job-service\n  namespace: job-service\nspec:\n  selector:\n    matchLabels:\n      app: job-service\n  rules:\n  - to:\n    - operation:\n        methods: [\u0022GET\u0022]\n  - from:\n    - source:\n        requestPrincipals: [\u0022*\u0022]\n    to:\n    - operation:\n        methods: [\u0022POST\u0022, \u0022DELETE\u0022, \u0022PATCH\u0022]\n        paths: [\u0022\/api\/jobs*\u0022]\n  - from:\n    - source:\n        requestPrincipals: [\u0022*\u0022]\n    when:\n    - key: request.auth.claims[realm_access][roles]\n      values: [\u0022admin\u0022]\n    to:\n    - operation:\n        methods: [\u0022POST\u0022, \u0022DELETE\u0022, \u0022PATCH\u0022]\n        paths: [\u0022\/api\/jobcategories*\u0022]\n\u0060\u0060\u0060\n\n我们可以通过导航到我们使用的 Keycloak 领域下的“Realm Roles”来创建管理员角色。之后，我们前往要分配管理员角色的相应用户，点击“Role Mapping”标签，并将用户添加到新创建的“admin”角色。\n\n![领域角色](realm-roles.png)\n\n![角色映射](role-mapping.png)\n\n### 创建 job 类别 - 普通用户\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--header \u0027Authorization: Bearer \u003ctoken\u003e\u0027 \\\n--data \u0027{\n    \u0022name\u0022: \u0022Research\u0022\n}\u0027\nRBAC: access denied\n\u0060\u0060\u0060\n\n### 创建 job 类别 - 管理员用户\n\n\u0060\u0060\u0060bash\ncurl --location \u0027https:\/\/ex-offenders.co.uk\/api\/jobcategories\/\u0027 \\\n--header \u0027Content-Type: application\/json\u0027 \\\n--header \u0027Authorization: Bearer \u003ctoken\u003e\u0027 \\\n--data \u0027{\n    \u0022name\u0022: \u0022Research\u0022\n}\u0027\n{\u0022name\u0022:\u0022Research\u0022,\u0022id\u0022:20}\n\u0060\u0060\u0060\n\n如我们所见，现在只有管理员用户可以创建\/更新\/删除 job 类别。\n\n## 微服务间的授权实施\n\n现在我们增加另一个名为“job-notification-service”的微服务。\n\n![job 通知服务](job-notification-service.png)\n\n这个服务不通过网关暴露，并且应仅被“job-service”访问。为实现这一点，我们可以添加以下授权政策。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: job-notification-service\n  namespace: job-notification-service\nspec:\n  selector:\n    matchLabels:\n      app: job-notification-service\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022job-service\u0022]\n        principals: [\u0022cluster.local\/ns\/job-service\/sa\/job-service\u0022]\n\u0060\u0060\u0060\n\n## 结论\n\n总结来说，我们使用 Istio 和 Keycloak 实现了对我们的微服务的认证和授权，确保了资源的安全访问。我们配置了基于角色和用户身份的访问控制政策，增强了我们应用的整体安全姿态。\n\n欢迎您提供任何改进建议、可能忽略的方面或增强本文档的建议。\n\n注：本页面是 Cloud Agnostic Platform 指南的一部分。点击[这里](https:\/\/github.com\/ex-offenders\/Cloud-Agnostic-Startup-Platform\/tree\/main)访问主页。\n', '\/trans\/istio-keycloak-authentication-authorization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本指南介绍了如何利用 Istio 和 Keycloak 来实现身份验证和授权，简化开发流程，让开发人员能够专注于核心任务。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/seamless-cross-cluster-access-istio/">多集群 Istio 服务网格的跨集群无缝访问指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('多集群 Istio 服务网格的跨集群无缝访问指南', '探索如何在 Istio 多集群网格中利用 SPIRE 联邦、DNS 代理和东西向网关技术，有效实现服务的跨集群无缝访问。本指南将提供详细的配置示例和步骤，帮助你克服部署中的挑战，确保服务间的高效、安全通信。', '\n## 前言\n\n随着企业信息系统越来越多地采用微服务架构，如何在多集群环境中实现服务的高效、安全地跨集群访问成为了一个重要的挑战。Istio 作为一种流行的服务网格解决方案，提供了丰富的功能来支持跨集群服务的无缝连接。\n\n在部署和使用多集群服务网格时有以下难点：\n\n- 跨集群的服务注册发现与路由\n- 集群间服务的身份识别与认证\n\n本文将深入探讨如何在多集群多网格的 Istio 部署中，通过实施 SPIRE 联邦和东西向网关暴露服务的方式，实现跨集群的无缝访问。通过一系列配置和部署示例，本文旨在为读者提供一个清晰的指南，帮助理解和解决多集群服务网格部署中遇到的常见问题和挑战。\n\n## Istio 的部署模型\n\n[Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/)中根据集群、网络、控制平面、网格、信任域及租户等维度划分了多种部署模型，我将其总结并附上适用场景说明如下表所示。\n\n{{\u003ctable \u0022Istio 的多维度部署模型及适用场景\u0022\u003e}}\n\n| 维度         | 单一配置                                   | 多元配置                                             | 适用场景说明                                                 |\n| ------------ | ------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |\n| **集群**     | 一个集群托管所有服务与控制平面。           | 跨多个集群分布服务，可以共享或分离控制平面。         | 单集群适用于资源需求较小、管理相对简单的环境；多集群适合于需要高可用性、地理冗余或遵守数据驻留政策的大型组织。 |\n| **网络**     | 所有服务在单一网络内通信，无需跨网络通信。 | 服务跨越多个网络，需通过 Istio 网关进行通信。        | 单网络适用于网络简单、无复杂跨网络通信需求的场景；多网络适合在多云、混合云环境中部署，或需要跨行政边界部署的场景。 |\n| **控制平面** | 一个控制平面管理所有服务。                 | 每个控制平面管理一个或多个集群，增强隔离与可用性。   | 单控制平面适用于小型至中型部署，易于管理；多控制平面适用于大规模部署，需要高度的容错能力和安全隔离。 |\n| **网格**     | 所有服务在一个连续的服务网格中。           | 服务网格之间通过联盟进行通信，适用于不同组织或区域。 | 单网格适用于组织内部密切协作的服务；多网格适合于需要隔离不同业务线或合作伙伴间的服务，或实施强隔离的大型组织。 |\n| **信任域**    | 所有服务使用同一套密钥和证书体系。         | 不同信任域使用不同的密钥和证书，需进行信任链交换。   | 单信任域适用于信任级别统一的环境；多信任域适用于需要严格隔离、满足不同安全级别需求的复杂组织或多方合作场景。 |\n| **租户**    | 整个网格为单一租户或用户服务。             | 通过命名空间隔离，支持多个租户在同一网格中运行服务。 | 单租户适用于所有资源和服务由单一组织管理的场景；多租户适用于云服务提供商或需要在同一物理基础设施上运营多个客户的场景。 |\n\n{{\u003c\/table\u003e}}\n\n选择合适的部署模型需要考虑到实际的业务需求、安全要求、管理复杂度以及成本等因素。在生产环境中，往往是对多种部署模型的组合使用。\n\n{{\u003ctable \u0022Istio 的部署模型组合\u0022\u003e}}\n\n下表展示了在实际应用中如何结合不同的部署模型来满足更复杂的业务和技术需求：\n\n| **混合部署模型**                             | **描述**                                                     | **适用场景**                                                 |\n| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **多集群 \u002b 多网格 \u002b 多控制平面**             | 不同的集群可以配置成不同的网格，每个网格都有自己的控制平面。通过网格联邦共享服务和策略。 | 适合大型组织，其中不同的业务单位需要独立运行并管理自己的服务，同时需要一定级别的服务共享和协作。 |\n| **多信任域联邦 \u002b 命名空间隔离的多租户**      | 不同的网格可以拥有不同的信任域，通过信任域联邦共享密钥和证书。同时在一个网格内部通过命名空间实现租户隔离。 | 适用于需要强隔离但又要求跨组织或跨业务线协作的环境，如跨国公司或合作伙伴网络。 |\n| **多集群 \u002b 单网格 \u002b 多控制平面**             | 多个集群共享一个服务网格，但每个集群拥有自己的控制平面来管理本地服务的配置。 | 适用于需要高可用性和灾难恢复能力的应用，各地区的集群可以独立运行，减少单点故障风险。 |\n| **多集群 \u002b 多网格 \u002b 单控制平面**             | 多个集群分布在不同的网格中，但所有网格共享一个中心控制平面。 | 适用于中心化管理的大规模部署，可以减少管理的复杂性，但对控制平面的可用性要求极高。 |\n| **多信任域 \u002b 多网格 \u002b 命名空间隔离的多租户** | 各网格拥有独立的信任域，增强安全性和隔离性。在单个网格内使用命名空间来隔离不同的租户。 | 适用于提供云服务的组织，需要隔离不同客户的数据和服务，同时在不同的法律和合规环境下操作。 |\n\n{{\u003c\/table\u003e}}\n\n这些混合模型提供了高度的灵活性和可扩展性，能够满足各种复杂的部署要求。在选择混合模型时，组织需要考虑到管理复杂性、成本、安全要求以及业务需求，以确定最合适的部署策略。通过适当的规划和设计，Istio 的灵活部署模型可以帮助组织构建出既安全又高效的服务网格架构。在大多数场景下，单信任域的多集群 \u002b 单网格 \u002b 多控制平面已足够满足需要。\n\n本文将聚焦多集群 \u002b 多网格 \u002b 多控制平面 \u002b 多信任域的混合部署模型，这是一种相当复杂的场景，如果你可以完成这种场景的部署，那么其他场景也就不在话下了。\n\n## 多集群 Istio 服务网格中的 FQDN\n\n网格间的服务要想互相访问，必须了解各自的 FQDN。FQDN 通常由服务名、命名空间和顶级域（如 \u0060svc.cluster.local\u0060）组成。在 Istio 的多集群或多网格设置中，可以通过不同的机制（如\u0060ServiceEntry\u0060、\u0060VirtualService\u0060、\u0060Gateway\u0060 配置）来控制和管理服务的路由和访问，而不是通过修改 FQDN 来实现。\n\n多集群服务网格中的 FQDN 与单集群并没有什么不同，通常遵循以下格式：\n\n\u0060\u0060\u0060\n\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local\n\u0060\u0060\u0060\n\n也许你会想到通过 \u0060meshID\u0060 来区分网格？\u0060meshID\u0060 主要用于区分和管理在同一环境中或跨环境的多个 Istio 网格，\u0060meshID\u0060 并不用于直接构造服务的 FQDN。\n\n{{\u003ccallout note  \u0022\u0060meshID\u0060 的主要作用\u0022\u003e}}\n- **网格级的遥测数据聚合**：区分不同网格的数据，以便在统一平台上进行监控和分析。\n- **网格联邦**：在网格之间建立联邦关系，允许网格间共享一些配置和服务。\n- **跨网格的策略实施**：识别和应用特定于网格的策略，如安全策略和访问控制。\n{{\u003c\/callout\u003e}}\n\n## 跨集群的服务注册发现与路由\n\n在 Istio 多网格环境中，东西向网关（East-West Gateway）起着关键作用，它不仅处理网格间的入口和出口流量，还支持服务的发现和连接。当一个集群需要访问另一个集群中的服务时，它通过这个网关路由到目标服务。\n\n下图展示了跨集群的服务注册发现与路由的过程。\n\n在跨集群的 Istio 网格配置中，服务注册、发现和路由的流程是至关重要的，它们确保了不同集群中的服务可以相互发现并通信。以下是跨集群 Istio 网格中服务注册、发现与路由的基本流程：\n\n### 1. 服务注册\n\n在每个 Kubernetes 集群中，当一个服务被部署时，它的信息会被注册到 Kubernetes 的 API Server。这包括服务的名称、标签、选择器、端口等信息。\n\n### 2. 同步到 Istiod\n\nIstiod，作为控制平面，负责监控 Kubernetes API Server 的状态变化。每当有新的服务被注册或现有服务被更新时，Istiod 会自动检测到这些变化。Istiod 接着提取必要的服务信息并构建内部的服务和端点的配置。\n\n### 3. 跨集群服务发现\n\n为了使一个集群中的服务能够发现并通信到另一个集群的服务，Istiod 需要将服务端点信息同步到所有相关集群。这通常通过以下两种方式之一实现：\n   - **DNS 解析**：Istio 可配置为利用 CoreDNS 或类似服务，在 DNS 查询中返回跨集群的服务端点。当一个服务尝试解析另一个集群中的服务时，DNS 查询会返回可以访问的远程服务的 IP 地址。在本文中我们将启用 Istio 的 [DNS 代理](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)实现跨集群的服务发现。在一个服务同时存在于本地和远程集群中时，在本地执行 DNS 查询只会返回本地服务的 ClusterIP，若该服务只存在于远程集群中时，DNS 查询将返回远程服务所在集群的东西向网关的负载均衡器地址，该特性也可以用于跨集群的故障恢复。\n   - **服务入口同步**：通过设置特定的 ServiceEntry 配置，使得一个集群的 Envoy 代理知道如何通过东西向网关找到并路由到另一个集群的服务。\n\n### 4. 路由和负载均衡\n\n当服务 A 需要与服务 B 通信时，它的 Envoy 代理首先解析服务 B 的名称获取 IP 地址，即服务 B 所在集群的东西向网关的负载均衡器地址。接着该东西向网关将请求路由到目标服务。Envoy 代理可以根据配置的负载均衡策略（如轮询、最少连接数等），选择最佳的服务实例来发送请求。\n\n### 5. 流量管理\n\nIstio 提供了丰富的流量管理功能，例如请求路由、故障注入、流量复制等。这些规则在 Istio 的控制平面中定义，并推送到各个 Envoy 代理执行。这样可以在跨集群环境中灵活地控制和优化服务间的通信。\n\n## 集群间服务的身份识别与认证\n\n当不同集群中运行的服务需要相互通信时，正确的身份认证和授权是确保服务安全的关键。使用 SPIFFE 可以帮助标识和验证服务的身份，但在多集群环境中需要确保这些身份是唯一且可验证的。\n\n为此，我们将设置 SPIRE 联邦来为多集群的服务分配身份并实现跨集群的身份认证：\n\n- **使用 SPIFFE 来标识服务身份**：在 SPIFFE 框架下，每个服务都会被分配一个格式为\u0060spiffe:\/\/\u003ctrust-domain\u003e\/\u003cnamespace\u003e\/\u003cservice\u003e\u0060的唯一标识符。在多集群环境中，可以通过包括集群名称在内的“trust domain”来确保身份的唯一性。例如，可以设置\u0060spiffe:\/\/foo.com\/ns\/default\/svc\/service1\u0060和\u0060spiffe:\/\/bar.com\/ns\/default\/svc\/service1\u0060，以区分不同集群中相同名称的服务。\n- **使用 SPIRE 联邦来管理集群间的证书**：它可以增强多集群服务网格中的安全性。SPIRE（SPIFFE Runtime Environment）提供了一个高度可配置的平台，用于服务身份验证和证书颁发。当使用 SPIRE 联邦时，可以实现跨集群的服务认证，通过为每个 SPIRE 集群创建 Trust Bundle 实现跨集群的身份认证。\n\n以下是实现 SPIRE 联邦的步骤说明。\n\n### 1.  配置 Trust Domain\n\n每个集群都配置为一个单独的 trust domain。这样，每个集群内的服务都将具有基于其所在 trust domain 的唯一 SPIFFE ID。例如，集群 1 的服务可能拥有 ID \u0060spiffe:\/\/cluster1\/ns\/default\/svc\/service1\u0060，而集群 2 的相同服务则为 \u0060spiffe:\/\/cluster2\/ns\/default\/svc\/service1\u0060。\n\n### 2. 建立 Trust Bundle\n\n在 SPIRE 中配置 trust relationships 以允许不同 trust domain 的节点和工作负载相互验证。这涉及到 trust domain 之间交换和接受彼此的 CA 证书或 JWT keys，确保跨集群通信的安全性。\n\n### 3. 配置 SPIRE Server 和 Agent\n\n在每个集群中部署 SPIRE Server 和 SPIRE Agent。SPIRE Server 负责管理证书颁发和续签，而 SPIRE Agent 负责将证书和密钥安全地分发给集群内的服务。\n\n{{\u003ccallout warning \u0022Istio 使用 SPIRE 联邦时的工作负载注册兼容性问题\u0022\u003e}}\n在本文中，我们将在 SPRIE Server 中使用传统的 Kubernetes Workload Registrar 来负责集群中的工作负载注册。从 SPIRE v1.5.4 起弃用了 Kubernetes Workload Registrar，转而是使用 SPIRE Controller Manager 代替，经我测试并不能与 Istio 很好的运行。\n{{\u003c\/callout\u003e}}\n\n### 4. 使用 Workload API\n\n服务可以通过 SPIRE 的 Workload API 请求和更新其身份证书。这样，服务即使在不同集群中运行，也能持续验证其身份，并安全地与其他服务通信。我们将配置 Istio 网格中的代理共享 SPIRE Agent 中的 Unix Domain Socket，从而访问 Workload API 来管理证书。\n\n### 5. 自动化证书轮换\n\n我们将使用 cert-manager 作为 SPIRE 的 [UpstreamAuthority](https:\/\/github.com\/spiffe\/spire\/blob\/v1.9.5\/doc\/plugin_server_upstreamauthority_cert_manager.md)，配置 SPIRE 自动轮换服务证书和密钥，增强系统的安全性。通过自动化轮换，即使证书被泄露，攻击者也只能在很短的时间内利用这些证书。\n\n通过这些步骤，你可以建立一个跨集群的、安全的服务身份验证框架，使得各个集群的服务能够安全地识别和通信，从而有效地降低安全风险并简化证书管理。这样的配置不仅增强了安全性，还通过分散的信任域提高了系统的可扩展性和灵活性。\n\n## 部署多集群\n\n下图展示了 Istio 多集群及 SPIRE 联邦的部署模型。\n\n![多集群网格部署模型](multi-cluster-deployment.svg)\n\n下面我将演示如何在多集群 Istio 网格中实现无缝地跨集群无缝访问。\n\n1. 在 GKE 中创建两个 Kubernetes 集群，分别命名为 \u0060cluster-1\u0060 和 \u0060cluster-2\u0060\n2. 分别在这两个集群中部署 SPIRE 并设置联邦\n3. 分别在两个集群中安装 Istio，注意配置信任域、东西向网关、入口网关、 \u0060sidecarInjectorWebhook\u0060 挂载 SPIFFE UDS 的 \u0060workload-socket\u0060，并启用 DNS 代理\n4. 部署测试应用并验证跨集群的无缝访问\n\n我们部署的各组件版本如下：\n\n- Kubernetes: v1.29.4\n- Istio: v1.22.1\n- SPIRE: v1.5.1\n- cert-manager: v1.15.1\n\n我将所有命令及步骤说明保存在 Github 上：[rootsongjc\/istio-multi-cluster](https:\/\/github.com\/rootsongjc\/istio-multi-cluster)，你可以按照该项目中的说明操作。下面是对各主要步骤的说明。\n\n### 1. 准备 Kubernetes 集群\n\n打开 Google Cloud Shell 或本地终端，并确保你已经安装了 \u0060gcloud\u0060 CLI。使用以下命令创建两个集群：\n\n\u0060\u0060\u0060bash\ngcloud container clusters create cluster-1 --zone us-central1-a --num-nodes 3\ngcloud container clusters create cluster-2 --zone us-central1-b --num-nodes 3\n\u0060\u0060\u0060\n\n### 2. 部署 cert-manager\n\n使用 cert-manager 作为根 CA 为 istiod 和 SPIRE 颁发证书。\n\n\u0060\u0060\u0060bash\n.\/cert-manager\/install-cert-manager.sh\n\u0060\u0060\u0060\n\n### 3. 部署 SPIRE 联邦\n\nSPIRE 联邦的基本信息如下：\n\n| Cluster Alias | Trust Domain |\n| ------------- | ------------ |\n| cluster-1     | foo.com      |\n| cluster-2     | bar.com      |\n\n注意：信任域不需要与 DNS 名称一致，但需要与 Istio Operator 配置中的信任域相同。\n\n执行下面的命令部署 SPIRE 联邦：\n\n\u0060\u0060\u0060bash\n.\/spire\/install-spire.sh\n\u0060\u0060\u0060\n\n想了解 Istio 中使用 SPIRE 进行身份管理的详情，请参考[使用 cert-manager 和 SPIRE 管理 Istio 中的证书](\/blog\/cert-manager-spire-istio\/)。\n\n### 4. 安装 Istio\n\n我们将使用 IstioOperator 来安装 Istio，其中为每个集群配置了：\n\n- 自动 Sidecar 注入\n- 入口网关\n- 东西向网关\n- DNS 代理\n- SPIRE 集成\n- 访问远程 Kubernetes 集群的 Secret\n\n执行下面的命令安装 Istio：\n\n\u0060\u0060\u0060bash\nistio\/install-istio.sh\n\u0060\u0060\u0060\n\n## 验证流量联邦\n\n为了验证多集群安装的正确性，我们将在两个集群中分别部署不同版本的 \u0060helloworld\u0060 应用，然后在 \u0060cluster-1\u0060 中访问 \u0060helloworld\u0060 服务，以测试以下跨集群访问场景：\n\n1. 东西向流量联邦：跨集群的服务冗余\n2. 东西向流量联邦：处理非本地目标服务\n3. 南北向流量联邦：通过远程入口网关访问服务\n\n执行下面的命令在两个集群中部署 \u0060helloworld\u0060 应用：\n\n\u0060\u0060\u0060bash\n.\/example\/deploy-helloword.sh\n\u0060\u0060\u0060\n\n### 东西向流量联邦：跨集群的服务冗余\n\n部署完成 \u0060helloworld\u0060 应用后，从 \u0060cluster-1\u0060 的 \u0060sleep\u0060 pod 访问 \u0060hellowrold\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n下图展示的是该场景下的部署架构及流量路由路径。\n\n![东西向流量联邦：跨集群的服务冗余](east-west-traffic-federation-between-clusters-without-dns-proxying.svg)\n\n从请求结果既有 \u0060helloworld-v1\u0060 又有 \u0060helloworld-v2\u0060 的响应来看，说明跨集群的服务冗余生效了。\n\n**验证 DNS**\n\n此时，因为 \u0060helloworld\u0060 服务既存在于本地又在远程集群中，若你在 \u0060cluster-1\u0060 中查询 \u0060helloworld\u0060 服务的 DNS 名称：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n你将得到  \u0060cluster-1\u0060 集群中的 \u0060helloworld\u0060 服务的 ClusterIP。\n\n**验证流量路由**\n\n接下来我们将通过查看 Envoy 代理配置来验证跨集群的流量路由路径。\n\n在 \u0060cluster-1\u0060 中查看 \u0060helloworld\u0060 服务的端点：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deployment\/sleep.sleep --context=cluster-1 --cluster \u0022outbound|5000||helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\n你将得到类似下面的输出：\n\n\u0060\u0060\u0060\nENDPOINT               STATUS      OUTLIER CHECK     CLUSTER\n10.76.3.22:5000        HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n34.136.67.85:15443     HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n这两个端点，一个是 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务的端点，另一个是 \u0060cluster-2\u0060 的 \u0060istio-eastwestgateway\u0060 服务的负载均衡器地址。Istio 将为跨集群的 TLS 连接设置 SNI，在 \u0060cluster-2\u0060 中将通过 SNI 区分目标服务。\n\n执行下面的命令，在 \u0060cluster-2\u0060 中查询前面 SNI 的端点：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deploy\/istio-eastwestgateway.istio-system --context=cluster-2 --cluster \u0022outbound_.5000_._.helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\n你将得到类似下面的结果：\n\n\u0060\u0060\u0060\nENDPOINT           STATUS      OUTLIER CHECK     CLUSTER\n10.88.2.4:5000     HEALTHY     OK                outbound_.5000_._.helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n这个端点就是 \u0060helloworld\u0060 服务在 \u0060cluster-2\u0060 集群中的端点。\n\n通过以上步骤，你应该了解了跨集群冗余服务的流量路径。接下来我们将删除 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务，不需要对 Istio 做任何配置，就可以自动实现故障转移。\n\n### 东西向流量联邦：故障转移\n\n执行下面的命令将 \u0060cluster-1\u0060  中的 \u0060helloworld\u0060 副本数量缩容为 0：\n\n\u0060\u0060\u0060bash\nkubectl -n helloworld scale deploy helloworld-v1 --context=cluster-1 --replicas 0\n\u0060\u0060\u0060\n\n再次从 \u0060cluster-1\u0060 中访问 \u0060helloworld\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n依然可以获得来自 \u0060helloworld-v2\u0060 的响应。\n\n现在，直接删除 \u0060cluster-1\u0060 中的 \u0060helloworld\u0060 服务：\n\n\u0060\u0060\u0060bash\nkubectl delete service helloworld -n helloworld --context=cluster-1\n\u0060\u0060\u0060\n\n依然可以获得来自 \u0060helloworld-v2\u0060 的响应，这说明跨集群的故障转移生效了。\n\n下图展示了该场景下的流量路径。\n\n![东西向流量联邦：故障转移](east-west-traffic-federation-between-clusters-failover.svg)\n\n**验证 DNS**\n\n此时，因为 \u0060helloworld\u0060 服务既存在于本地又在远程集群中，若你在 \u0060cluster-1\u0060 中查询 \u0060helloworld\u0060 服务的 DNS 名称：\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\n你将得到  \u0060cluster-2\u0060 集群中东西向网关的地址和 15443 端口。\n\n### 南北向流量联邦：通过远程入口网关访问服务\n\n通过入口网关访问远程集群中的服务，是最传统的跨集群访问方式，下图展示了该场景下的流量路径。\n\n![南北向流量联邦：通过远程入口网关访问服务](north-south-traffic-federation-between-clusters.svg)\n\n执行下面的命令在 \u0060cluster-2\u0060 中创建 Gateway 和 VirtualService：\n\n\u0060\u0060\u0060bash\nkubectl apply --context=cluster-2 \\\n\t-f .\/examples\/helloworld-gateway.yaml -n helloworld\n\u0060\u0060\u0060\n\n获取 \u0060cluster-2\u0060 中的入口网关地址：\n\n\u0060\u0060\u0060bash\nGATEWAY_URL=$(kubectl -n istio-ingress --context=cluster-2 get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n执行下面的验证可以通过远程入口网关访问服务：\n\n\u0060\u0060\u0060bash\nkubectl exec --context=\u0022${CTX_CLUSTER1}\u0022 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -s http:\/\/$GATEWAY_URL\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\n你将得到来自 \u0060helloworld-v2\u0060 的响应。\n\n## 验证身份\n\n执行下面的命令获取 \u0060cluster-1\u0060 集群中 \u0060sleep\u0060 pod 中的证书：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config secret deployment\/sleep -o json --context=cluster-1| jq -r \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in cert-aa\n\u0060\u0060\u0060\n\n如果在输出的消息中看到下面的字段，说明身份分配正确：\n\n\u0060\u0060\u0060\nSubject: C=US, O=SPIFFE\n\nURI:spiffe:\/\/foo.com\/ns\/sample\/sa\/sleep\n\u0060\u0060\u0060\n\n查看 SPIRE 中的身份信息：\n\n\u0060\u0060\u0060bash\nkubectl --context=cluster-1 exec -i -t -n spire spire-server-0 -c spire-server \\\n\t-- .\/bin\/spire-server entry show -socketPath \/run\/spire\/sockets\/server.sock --spiffeID spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\n\u0060\u0060\u0060\n\n你将看到类似下面的输出：\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 9b09080d-3b67-44c2-a5b8-63c42ee03a3a\nSPIFFE ID        : spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\nParent ID        : spiffe:\/\/foo.com\/k8s-workload-registrar\/cluster-1\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:sleep\nSelector         : k8s:pod-uid:6800aca8-7627-4a30-ba30-5f9bdb5acdb2\nFederatesWith    : bar.com\nDNS name         : sleep-86bfc4d596-rgdkf\nDNS name         : sleep.sleep.svc\n\u0060\u0060\u0060\n\n## 生产环境建议\n\n对于生产环境，建议使用[统一网关](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway)，通过 Tier-2 架构，在 Tier-1 边缘网关配置全局的流量路由，该边缘网关将把转写的 Istio 配置下发给 Tier-2 集群中的各个入口网关。\n\n下图展示了使用 TSB 部署的 Tier2 架构的 Istio 服务网格，其中使用 SPIRE 联邦。\n\n![使用 SPIRE、Tier2 架构的 TSB 部署的多集群 Istio 服务网格架构图](tsb-multi-cluster-architeture.svg)\n\n我们将这四个 Kubernetes 集群分为 Tier1 集群（\u0060tier1\u0060）和 Tier2 集群（\u0060cp-cluster-1\u0060、\u0060cp-cluster-2\u0060 和 \u0060cp-cluster-3\u0060）。在 T1 中安装 Edge Gateway，而在 T2 中安装 bookinfo 和 httpbin 应用程序。每个集群将拥有独立的信任域，所有这些集群将构成 SPIRE 联邦。\n\n下图展示了用户通过入口网关访问 bookinfo 和 httpbin 服务的流量路由。\n\n![统一网关架构图](tsb-unified-gateway.svg)\n\n你需要在 Istio 之上创建一个适用于多集群的逻辑抽象层，关于 TSB 中的统一网关的详细信息，请参考 [TSB 文档](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway#scenario-1-cluster-based-routing-with-http-path-and-header-match).\n\n## 总结\n\n本文详细介绍了在 Istio 多集群网格环境中实现服务身份验证、DNS 解析和跨集群流量管理的关键技术和方法。通过精确配置 Istio 和 SPIRE 联邦，我们不仅增强了系统的安全性，还提高了服务间通信的效率和可靠性。遵循这些步骤，你将能够构建一个强大的、可扩展的多集群服务网格，满足现代应用的复杂需求。\n\n## 参考\n\n- [Deploying a Federated SPIRE Architecture - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/architecture\/federation\/readme\/)\n- [Install Multi-Primary on different networks -istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Istio SPIRE Integration - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)\n- [DNS Proxying - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)\n- [Attesting Istio workload identities with SPIFFE and SPIRE - developer.ibm.com](https:\/\/developer.ibm.com\/articles\/istio-identity-spiffe-spire\/)\n- [Expanding into New Frontiers - Smart DNS Proxying in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [使用 cert-manager 和 SPIRE 管理 Istio 中的证书 - jimmysong.io](https:\/\/jimmysong.io\/blog\/cert-manager-spire-istio\/)', '\/blog\/seamless-cross-cluster-access-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何在 Istio 多集群网格中利用 SPIRE 联邦、DNS 代理和东西向网关技术，有效实现服务的跨集群无缝访问。本指南将提供详细的配置示例和步骤，帮助你克服部署中的挑战，确保服务间的高效、安全通信。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/gateway-api-istio-ingress-evolution/">探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型', '本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。', '\n随着 Istio 1.22 版本的发布，Istio API 已正式升级至 v1 版本，同期，Kubernetes Gateway API 也更新至 v1.1 版本。本篇文章旨在深入探索 Ingress API、Istio API 与 Kubernetes Gateway API 之间的联系与区别，并详述它们在现实应用中的选择及迁移策略。\n\n## 前言\n\n之前，我曾撰写一篇文章，讨论了 [为何 Gateway API 是 Kubernetes 与服务网格入口中的未来方向](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/)。文章中指出，作为 Kubernetes 的初始入口网关，Ingress 的资源模型由于过于简单，难以满足当下的可编程网络需求。作为其接班人，Gateway API 近年来发展迅速，获得了广泛支持，包括众多新兴的开源网关项目如 [Envoy Gateway](https:\/\/gateway.envoyproxy.io) 也选择基于 Gateway API 开发。此外，一些传统网关项目也开始适配 Gateway API，或通过 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) 这样的工具进行迁移。\n\nGateway API，作为 Kubernetes 入口网关的最新成果，通过角色划分来分离关注点，并支持跨 namespace，更适合多云环境。它整合了入口网关（南北向）与服务网格（东西向，集群内路由）的重叠功能，为云原生时代的统一流量管理提供了新的参考模型。\n\nIngress API、Gateway API 与 Istio API 都能实现网关功能，它们之间具体有何联系与区别？本文将为你揭晓这一迷题，并提供 Kubernetes 环境中网关的选择和迁移策略。\n\n## Kubernetes 中的流量管理\n\n随着微服务架构的广泛应用和日益增长的复杂性，Kubernetes 的流量管理工具也在不断演进以适应各种技术需求。Ingress API、Istio API 与 Kubernetes Gateway API 分别标志着这一演变的不同阶段。\n\n**Ingress API** 提供了 Kubernetes 的基本流量管理功能，允许用户通过定义简单的路由规则（例如 HTTP 和 HTTPS）来管理外部访问集群内服务的流量。其设计虽简洁，但功能有限，主要适用于规模较小、结构较简单的应用场景。\n\n相比之下，**Istio API** 作为服务网格的一部分，提供了一系列高级流量管理功能，如流量镜像、金丝雀发布和断路器，适合于需要复杂流量管理的大规模微服务架构。\n\n为了克服 Ingress API 的局限性并集成类似 Istio 的高级功能，**Kubernetes Gateway API** 因应而生。它不仅在设计上提供了更高的灵活性和扩展性，还通过社区的广泛支持，成为连接传统 Ingress 实现和现代服务网格技术如 Istio 的桥梁，目前主流的开源网关都是基于 Gateway API 或已进行适配。\n\n以下表格概述了这三者的核心特点和推荐使用场景：\n\n| API 名称    | 对象类型                    | 状态                    | 推荐使用场景                                                 |\n| ----------- | --------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API | \u0060Ingress\u0060                   | 稳定 (Kubernetes v1.19) | 适用于小规模和简单的应用场景，主要用于基本的路由配置         |\n| Istio API   | \u0060VirtualService\u0060、\u0060Gateway\u0060 | 稳定 (Istio 1.22)       | 适用于高度复杂的微服务架构，需细粒度控制和高级流量管理特性的场景 |\n| Gateway API | \u0060HTTPRoute\u0060、\u0060Gateway\u0060      | 稳定 (Gateway API v1.1) | 适用于新部署或现有部署，需提高灵活性和可扩展性的场景，特别是结合 Istio 使用 |\n\n[Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/) 的推出，特别是其在提升与现有 Ingress 配置兼容性方面的改进，为用户提供了一个平稳的迁移途径，使从传统的 Ingress 解决方案向更现代的、功能更全面的 Gateway API 的过渡变得更为顺畅。\n\n## 从 Ingress 迁移到 Kubernetes Gateway API\n\n若想从 Ingress 迁移到 Gateway API，请按以下步骤操作：\n\n1. **理解关键差异**：与 Ingress 相比，Gateway API 引入了多种新的概念和资源类型，如 \u0060Gateway\u0060、\u0060HTTPRoute\u0060 和 \u0060TLSRoute\u0060。这些资源提供了更多的配置选项和灵活性，请参阅 [Gateway API 文档](https:\/\/gateway-api.sigs.k8s.io\/guides\/)以了解其配置。\n2. **配置入口点**：创建 \u0060Gateway\u0060 资源配置，明确定义如何接收外部流量，包括配置协议、端口和 TLS 终端。\n3. **映射旧资源**：将现有的 Ingress 资源映射到对应的 Gateway API 资源。例如，Ingress 中的 host 和 path 规则需要转换为 HTTPRoute 中的路由规则。\n4. **测试与部署**：在正式迁移之前，在测试环境中验证新的 Gateway API 配置，确保所有流量路由正常，无安全漏洞。\n\n为了简化迁移过程，你可以使用工具如 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway)，该工具能自动将 Ingress 配置转换为 Gateway API 格式。\n\n## 实际迁移示例\n\n以下是一个简单的 HTTP 网关配置示例，展示了如何将 Ingress 迁移到 Gateway API。\n\n假设现有一个 Ingress 配置如下：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\n要将其迁移到 Gateway API，首先需要创建一个 Gateway 对象：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\n请确保 \u0060gatewayClassName\u0060 指向你集群中配置的有效 GatewayClass。GatewayClass 通常由集群管理员设置，是一个为 Gateway 提供配置的资源。\n\n接下来，创建 HTTPRoute 资源来定义路由规则，将流量路由到后端服务：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\n在此示例中，我们看到：\n\n- \u0060Ingress\u0060 对象中的规则被直接映射到 \u0060HTTPRoute\u0060 对象中。\n- 路由规则中的主机名匹配、路径匹配以及后端服务配置保持不变，只是对象和字段名称有所不同。\n\n## 考虑的挑战\n\n虽然可以将 Ingress 迁移到 Gateway API，并可能同时运行它们，但需要考虑以下挑战和迁移的必要性：\n\n- **功能差异**：某些 Ingress 控制器的特定功能可能在 Gateway API 中没有直接对应，可能需要通过额外的配置或自定义资源来实现。\n- **多资源管理**：Gateway API 的使用可能涉及比 Ingress 更多的资源类型和更复杂的配置，这可能增加管理的复杂性。\n\n对于现有的 Ingress 和 Istio API 用户，是否需要迁移到 Gateway API 取决于具体情况。以下是一些迁移建议：\n\n- **新部署**：建议直接采用 Gateway API，以便利用其先进特性和预见未来的发展。\n- **现有部署**：如果现有系统运行稳定且无需高级特性，可以继续使用现有 API；如果希望利用 Gateway API 的新特性或计划未来长期发展，逐步迁移则是一个理智的选择。\n\n对于不同网关对 Gateway API 的支持情况，可以参考 [Gateway API 实现项目的一致性报告](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/)了解详细信息。\n\n## 总结\n\nIngress API、Istio API 和 Kubernetes Gateway API 各具特色，适应不同的应用场景和需求。选择合适的 API，进行合理的规划和管理，可以显著提高系统的灵活性和稳定性。随着 Gateway API 的持续发展和成熟，它将越来越成为未来流量管理的主流选择。\n\n选择合适的网关技术，结合你的具体需求和现有架构，可以更好地管理和优化流量，确保应用的高效和稳定运行。随着技术的进步和社区的发展，Gateway API 提供了一个强大且灵活的框架，使得从传统的 Ingress 迁移到更现代的解决方案变得更为简单和高效。\n\n## 参考\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)', '\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-integrate-third-party-registry-with-istio/">如何在 Istio 中集成第三方服务注册表？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中集成第三方服务注册表？', '本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。', '\nIstio 依赖 Kubernetes 来进行服务发现，这通常意味着必须在 Kubernetes 集群中部署微服务并使用 Kubernetes 服务发现。然而，很多现有的微服务项目还在使用如 Consul、Eureka 这样的第三方服务注册表，本文将探讨如何将这些现有的微服务的注册表与 Istio 集成。\n\n## Istio 对非 Kubernetes 服务的支持\n\nIstio 最初只支持 Kubernetes 服务，但随着时间的推移，为了适应更广泛的应用场景，它开始支持像 Consul 这样的第三方服务注册表。通过引入 Mesh Configuration Protocol（MCP），Istio 能够与各种服务发现后端通信，如 Consul，从而管理非 Kubernetes 环境中的服务。在 Istio 1.1 版本中，引入了 ServiceEntry 资源对象，这使得用户可以手动将外部服务添加到 Istio 的服务注册表中，并在 Istio 1.8 中取消了对 Consul 的直接支持，转而通过 [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) 提供了一种更灵活的方式来集成和管理所有服务，无论它们是否托管在 Kubernetes 上。\n\n## Istio 代理配置的高层架构\n\n下图展示了 Istio 代理配置的高层架构，揭示了配置如何从各种源被摄取、转换，并最终服务于 Envoy 代理。\n\n\u0060\u0060\u0060mermaid \u0022Istio 代理配置高层架构\u0022\ngraph TD\n    subgraph 配置摄取\n        subgraph 配置存储\n            xcs(XDS 客户端) --\u003e acs(聚合)\n            ccs(CRD 客户端) --\u003e acs(聚合)\n            fcs(文件系统客户端) --\u003e acs(聚合)\n        end\n        subgraph 服务发现\n            kc(Kube Controller) --\u003e sd(聚合)\n            sec(ServiceEntry Controller) --\u003e sd(聚合)\n        end\n    end\n    subgraph 配置转换\n        acs \u0026 sd --\u003e ct(配置转换器)\n    end\n    subgraph \u0022配置服务 (XDS)\u0022\n        ct --\u003e xds(XDS 服务器)\n    end\n    xds --\u003e ep(Envoy 代理)\n\u0060\u0060\u0060\n\n![Istio 代理配置高层架构](ba3ac1f8ffc2b172dd0681013c328a09.svg)\n\n要想详细了解 Istiod 的架构，可以参考 [Istio 架构详解](https:\/\/cloudnative.to\/blog\/istiod-architecture\/)。\n\n### 配置摄取过程详解\n\n- **ConfigStore**: 负责读取多种类型的资源并进行聚合。包括：\n    - **XDS Client**: 通过 xDS 协议读取资源。\n    - **CRD Client**: 从 Kubernetes 自定义资源定义（CRD）读取资源。\n    - **Filesystem Client**: 从文件系统读取资源。\n- **ServiceDiscovery**: 聚合面向服务的内部资源。使用的组件包括：\n    - **Kube Controller**: 依据 Kubernetes 核心类型运行。\n    - **ServiceEntry Controller**: 依据 Istio 类型运行。\n\n### 配置翻译与服务\n\n配置从 ConfigStore 和 ServiceDiscovery 聚合后，由 **Config Translator** 翻译成适合代理的格式，然后通过 **XDS Server** 服务于 Envoy 代理。这是将动态配置应用于代理的最终步骤。\n\n## 第三方注册表同步\n\n为了集成第三方服务注册表，我们可以实现一个 Operator，该 Operator 监视第三方服务注册表并将服务以 ServiceEntry 和 WorkloadEntry 资源形式推送至 Kubernetes API 服务器。以下流程图展示了该同步过程。\n\n\u0060\u0060\u0060mermaid \u0022第三方注册表同步流程图\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as 第三方服务注册表\n    participant K8s as Kubernetes API 服务器\n    participant I as Istiod\n    participant EP as Envoy 代理\n\n    O-\u003e\u003e\u002bCM: 查询服务注册表\n    CM--\u003e\u003e-O: 返回服务数据\n    O-\u003e\u003eO: 将服务转换为 ServiceEntry\n    O-\u003e\u003e\u002bK8s: 推送 ServiceEntry\n    K8s--\u003e\u003e-I: 更新 Istio 配置\n    I-\u003e\u003eEP: 更新代理配置\n    Note over EP: Envoy 代理接收新配置\n\n    loop 监控变更\n        O-\u003e\u003e\u002bCM: 检查更新\n        CM--\u003e\u003e-O: 通知变更\n        O-\u003e\u003eO: 转换更新的服务\n        O-\u003e\u003e\u002bK8s: 更新 ServiceEntry\n        K8s--\u003e\u003e-I: 刷新 Istio 配置\n        I-\u003e\u003eEP: 刷新代理配置\n    end\n\u0060\u0060\u0060\n\n![第三方注册表同步流程图](34ee760a4cb26025ecf954077f77eee2.svg)\n\n### 第三方服务注册表同步的步骤说明\n\n1. Operator 向第三方服务注册表发起查询请求。\n2. 第三方服务注册表返回当前注册的服务数据。\n3. Operator 将服务数据转换为 Istio 的 ServiceEntry 对象。\n4. Operator 将 ServiceEntry 推送至 Kubernetes API 服务器。\n5. Kubernetes API 服务器将变更通知 Istiod。\n6. Istiod 更新 Envoy Proxies 的配置。\n7. Operator 定期检查第三方服务注册表以监控服务变化，发现变更后更新 ServiceEntry 并重新推送至 Kubernetes API 服务器，完成服务同步。\n\n## Istio Registry Sync\n\nTetrate 开发的 [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) 是一个扩展 Operator，可以作为 [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/) 的 add-on 运行。它支持非 Kubernetes 服务注册表（如 AWS Cloud Map 和 Consul）与 Istio 的集成。此工具提供了以下几个使用场景：\n\n- **混合应用集成**: 在混合环境中，如使用 Consul 的传统应用与 AWS Cloud Map 中的微服务可以通过 Istio Registry Sync 实现无缝的服务发现。\n- **动态端点管理**: 在服务频繁扩缩的环境中，Istio Registry Sync 能快速反映来自配置注册表的变更，确保 Istio 服务网格中的流量管理策略准确有效。\n- **统一的监控与安全态势**: 通过将所有环境的服务集成至 Istio，可以利用 Istio 提供的服务健康指标和统一的安全协议，如 mTLS，确保跨所有服务的加密和认证通信。\n\n## 总结\n\n通过上述方法，你可以有效地将 Istio 与第三方服务注册表集成，无论是通过开发自定义的 Operator 还是使用现成的 Istio Registry Sync 工具。这样不仅能够保持服务的现代化，还能确保在不同环境之间的高效协同工作。\n\n## 参考资料\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n', '\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了如何将第三方服务发现机制如 Consul 和 Eureka 与 Istio 集成，实现服务发现的无缝对接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istiod-architecture/">[译] Istiod 架构详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://github.com/istio/istio/blob/master/architecture/networking/pilot.md" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istiod 架构详解', '本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。', '\n本文档描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。\n\n## 代理配置 {#proxy-configuration}\n\nIstiod 的主要角色——以及大部分代码——是动态配置代理（Envoy sidecar、入口、gRPC、ztunnel 等）。这大致包括 3 个部分：\n1. 配置摄取（系统的输入）\n1. 配置翻译\n1. 配置服务（XDS）\n\n### 配置摄取\n\nIstio 从超过 20 种不同的资源类型读取，并将它们聚合在一起构建代理配置。这些资源可以来自 Kubernetes（通过观察）、文件或通过 xDS；尽管如此，Kubernetes 是最常用的。\n\n主要出于历史原因，摄取分为几个组件。\n\n#### ConfigStore\n\n\u0060ConfigStore\u0060 读取多种资源，并通过标准接口（Get、List 等）暴露它们。这些类型被包装在通用的 \u0060config.Config\u0060 结构中，与通常使用每种资源类型的 Kubernetes 客户端形成对比。最常见的是通过 \u0060crdclient\u0060 包从 Kubernetes 读取。\n\n![](.\/output-1.svg)\n\n#### 服务发现 {#ServiceDiscovery}\n\n另一个主要接口是 ServiceDiscovery。类似于 ConfigStore，它也是对多种资源进行聚合。然而，它不提供通用资源访问，而是预计算了多种服务导向的内部资源，如 \u0060model.Service\u0060 和 \u0060model.ServiceInstance\u0060。\n\n这由两个控制器组成——一个由核心 Kubernetes 类型驱动（“Kube Controller”），一个由 Istio 类型驱动（“ServiceEntry 控制器”）。\n\n![](.\/output-2.svg)\n\n大部分情况下这是相当直接的。然而，我们支持 \u0060ServiceEntry\u0060 选择 \u0060Pod\u0060，以及 \u0060Service\u0060 选择 \u0060WorkloadEntry\u0060，这导致跨控制器通信。\n\n注意：\u0060Pods\u0060 不贡献给 Kube 控制器的 \u0060ServiceInstances\u0060 是因为使用了 \u0060Endpoints\u0060，它本身是从 Kubernetes 核心的 \u0060Pod\u0060 派生的。\n\n#### PushContext\n\n\u0060PushContext\u0060 是当前全局状态（SotW）的一个不可变快照。它在每次配置推送时（下面会详细讨论）通常是部分地重新生成的。由于是快照，大多数查找都是无锁的。\n\n\u0060PushContext\u0060 是通过查询上述层构建的。对于一些简单的用例，这和存储类似于 \u0060configstore.List(SomeType)\u0060 的东西一样简单；在这种情况下，与直接暴露 configstore 的唯一区别是要快照当前状态。在其他情况下，一些预计算和索引被计算出来，以便后续访问效率。\n\n#### 端点\n\n端点有一个优化的代码路径，因为它们是迄今为止更新最频繁的资源——在一个稳定的集群中，这通常是*唯一*的变化，由扩缩容引起。\n\n因此，它们不经过 \u0060PushContext\u0060，变化也不会触发 \u0060PushContext\u0060 的重新计算。相反，当前状态是基于来自 \u0060ServiceDiscovery\u0060 的事件增量计算的。\n\n#### 结论\n\n总体而言，配置摄取流程如下：\n\n![](.\/output-3.svg)\n\n### 配置翻译\n\n配置翻译将上述输入转换为连接的 XDS 客户端（通常是 Envoy）消费的实际类型。这通过 \u0060Generators\u0060 完成，这些生成器注册一个函数来构建给定类型。例如，有一个 \u0060RouteGenerator\u0060 负责构建 \u0060Routes\u0060。除了核心 Envoy XDS 类型外，还有一些自定义的 Istio 类型，例如我们用于 DNS 的 \u0060NameTable\u0060 类型，以及调试接口。\n\n\u0060Generators\u0060 的输入是 \u0060Proxy\u0060（当前客户端的表示）、当前的 \u0060PushContext\u0060 快照以及导致更改的配置更新列表。\n\n将 \u0060Proxy\u0060 作为输入参数是重要的，并且与其他一些 XDS 实现的主要区别。我们无法在没有每个客户端信息的情况下静态翻译输入到 XDS。例如，我们依赖于客户端的标签来确定应用的政策集。虽然这是实现 Istio API 的必要条件，但它确实大大限制了性能。\n\n#### 缓存\n\n配置翻译通常占用了 Istiod 的绝大部分资源使用，尤其是 protobuf 编码。因此，引入了缓存，存储给定资源的已编码 \u0060protobuf.Any\u0060。\n\n这种缓存依赖于声明所有输入到给定生成器作为缓存键的一部分。这极其容易出错，因为没有任何东西阻止生成器使用*不*是键部分的输入。当这种情况发生时，不同的客户端将不确定地获得错误的配置。这种类型的错误在历史上导致了 CVE。\n\n有几种方法可以防止这些问题：\n* 只将缓存键本身传入到生成逻辑中，这样就不能使用其他未计入的输入。不幸的是，今天还没有任何生成器这样做。\n* 非常非常小心。\n* 缓存有一个内置测试，通过设置 \u0060UNSAFE_PILOT_ENABLE_RUNTIME_ASSERTIONS=true\u0060 启用，该测试在 CI 中运行。如果任何键以不同的值写入，这将引发 panic。\n\n#### 部分计算\n\n与缓存一样，部分计算是确保我们不需要在每次更改时为每个代理构建（或发送）每个资源的关键性能优化。这将在配置服务部分中更详细讨论。\n\n### 配置服务\n\n配置服务是实际接受代理客户端的层，这些客户端通过双向 gRPC 流连接，并为它们提供所需的配置。\n\n我们将有两种触发发送配置的方式——请求和推送。\n\n#### 请求\n\n来自客户端的请求特别要求一组资源。这可能是在新连接上请求初始资源集，或者来自新的依赖。例如，\u0060Cluster X\u0060 的推送引用 \u0060Endpoint Y\u0060 可能导致请求 \u0060Endpoint Y\u0060（如果客户端尚未知道的话）。\n\n注意客户端实际上可以发送三种类型的消息——请求、对先前推送的 ACKs 和对先前推送的 NACKs。不幸的是，这些在 API 中没有清晰地区分，因此有一些逻辑来分解这些（\u0060shouldRespond\u0060）。\n\n#### 推送\n\n当 Istiod 检测到需要某些配置更新时，会发生推送。这大致与请求的结果相同（新配置推送到客户端），只是由不同的来源触发。\n\n在配置摄取中描述的各种组件可以触发配置更新。这些被批量处理（\u0022debounced\u0022），以避免在连续多次更改时活动过度，并最终排队在推送队列中。\n\n推送队列大部分是一个正常的队列，但它有一些特殊逻辑来合并每个给定代理的推送请求。这导致每个代理有 0 或 1 个未完成的推送请求；如果有更多更新进来，现有的推送请求就会扩展。\n\n另一个任务轮询这个队列并触发每个客户端开始推送。\n\n![](.\/output-4.svg)\n\n在高层次上，每个客户端任务将找到正确的生成器来处理请求，生成所需的配置，并发送。\n\n#### 优化\n\n一个简单的实现将简单地重新生成每个客户端的所有订阅类型的所有资源，无论配置是否更改。然而，这种方式扩展性很差。因此，我们有许多级别的优化以避免做这些工作。\n\n首先，我们有一个 \u0060Full\u0060 推送的概念。只有在更改时 \u0060Full\u0060 推送会重新计算 \u0060PushContext\u0060；否则，这将被跳过，重用最后一个 \u0060PushContext\u0060。注意：即使是 \u0060Full\u0060，我们也尽可能从上一个 \u0060PushContext\u0060 复制。例如，如果只有一个 \u0060WasmPlugin\u0060 发生了变化，我们不会重新计算服务索引。\n\n注意：\u0060Full\u0060 只是指是否需要重新计算 \u0060PushContext\u0060。即使在 \u0060Full\u0060 推送中，我们也会跟踪触发此的配置更新，因此我们可以有 \u0022Config X 的完整更新\u0022 或 \u0022所有配置的完整更新\u0022。\n\n接下来，对于单个代理，我们将检查它是否可能受到更改的影响。例如，我们知道一个 sidecar 从不受 \u0060Gateway\u0060 更新的影响，我们还可以查看限制更新范围的分流（来自 \u0060Sidecar.egress.hosts\u0060）。\n\n一旦我们确定代理可能受到影响，我们将确定哪些*类型*可能受到影响。例如，我们知道 \u0060WasmPlugin\u0060 不影响 \u0060Cluster\u0060 类型，所以在这种情况下我们可以跳过生成 \u0060Cluster\u0060。警告：Envoy 当前有一个错误，*要求* 每当推送对应的 \u0060Cluster\u0060 时必须推送 \u0060Endpoints\u0060，因此这个优化在这个特定情况下故意关闭了。\n\n最后，我们确定我们需要生成类型的哪个子集。XDS 有两种模式 - \u0022State of the World (SotW)\u0022 和 \u0022Delta\u0022。在 SotW 中，我们通常需要生成类型的所有资源，即使只有一个发生了变化。注意我们实际上需要*生成*所有这些，通常是因为我们不存储先前生成的资源（主要因为它们是每个客户端生成的）。这也意味着每当我们确定是否需要更改时，我们都是基于仔细的代码分析，而不是在运行时。\n\n尽管在 SotW 中有这样的期望，由于协议的一个特点，我们实际上可以启用我们最重要的优化之一。XDS 类型形成一棵树，CDS 和 LDS 是 Envoy 的树根。对于根类型，我们*必须*总是生成完整的资源集——缺失的资源被视为删除。\n然而，所有其他类型*不能*显式删除，而是在所有引用被移除时清理。这意味着我们可以为非根类型发送部分更新，而不删除未发送的资源。这有效地允许在 SotW 上进行 delta 更新。这个优化对我们的端点生成器至关重要，确保当一个 pod 扩展时，我们只需要更新该 pod 内的端点。\n\n## 控制器\n\nIstiod 由一系列控制器组成。按 Kubernetes 的说法，\u0022控制器是观察你的集群状态的控制循环，然后在需要时进行或请求更改。\u0022\n\n在 Istio 中，我们更自由地使用这个术语。Istio 的控制器不仅仅观察一个集群的状态——许多控制器从多个集群读取，甚至从外部来源（文件和 XDS）读取。通常，Kubernetes 控制器然后将状态写回到集群；Istio 确实有几个这样的控制器，但大多数控制器都集中在推动[代理配置](#proxy-configuration)。\n\n### 编写控制器\n\nIstio 提供了一些帮助库来开始编写控制器。虽然这些库有帮助，但正确编写（和测试！）一个控制器仍然有很多细微之处。\n\n要开始编写控制器，请查看[示例控制器](https:\/\/github.com\/istio\/istio\/blob\/master\/pkg\/kube\/controllers\/example_test.go)。\n\n### 控制器概览\n\n下面提供了 Istiod 中控制器的高级概览。有关每个控制器的更多信息，建议咨询控制器的 Go 文档。\n\n![](.\/output-5.svg)\n\n正如您所看到的，目前控制器的景观相当广泛。\n\n[服务发现](#ServiceDiscovery) 和 [Config Store](#ConfigStore) 已在上文讨论，因此这里不再赘述。\n\n#### 网格配置\n\n网格配置控制器是一个相当简单的控制器，从 \u0060ConfigMap\u0060（如果使用 \u0060SHARED_MESH_CONFIG\u0060 则为多个）读取，处理并合并这些到类型化的 \u0060MeshConfig\u0060 中。然后它通过一个简单的 \u0060mesh.Watcher\u0060 暴露这个，这只是暴露一种访问当前 \u0060MeshConfig\u0060 的方式并在它改变时获得通知。\n\n#### Ingress\n\n除了 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，Istio 也支持 \u0060Ingress\u0060 核心资源类型。像 CRD 一样，\u0060Ingress\u0060 控制器实现 \u0060ConfigStore\u0060，但有些不同。\u0060Ingress\u0060 资源在即时转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，所以虽然控制器读取 \u0060Ingress\u0060 资源（和一些相关类型如 \u0060IngressClass\u0060），它发出其他类型。这允许其他代码不用关心 Ingress，只关注核心类型。\n\n除了这种转换外，\u0060Ingress\u0060 还需要在状态中写入它可以访问的地址。这由 Ingress 状态控制器完成。\n\n#### Gateway\n\nGateway（指的是 [Kubernetes API](http:\/\/gateway-api.org\/)，不是同名的 Istio 类型）的工作方式与 [Ingress](#ingress) 非常相似。网关控制器也将网关 API 类型转换为 \u0060VirtualService\u0060 和 \u0060Gateway\u0060，实现 \u0060ConfigStore\u0060 接口。\n\n然而，还有一些额外的逻辑。网关类型有广泛的状态报告。与 Ingress 不同，这是状态报告是在主控制器中直接完成的，允许在处理资源的逻辑中直接生成状态。\n\n此外，Gateway 涉及两个组件写入到集群：\n* 网关类控制器是一个简单的控制器，只是写一个描述我们实现的默认 \u0060GatewayClass\u0060 对象。\n* 网关部署控制器使用户能够创建一个实际配置底层资源（部署和服务）的网关。这更像是一个传统的“Operator”。这部分逻辑是确定基于 \u0060istio.io\/rev\u0060 标签哪个 Istiod 修订应该处理资源（反映 sidecar 注入）；因此，这需要依赖“标签观察者”控制器。\n\n#### CRD 观察者\n\n对于针对自定义类型（CRD）的观察，我们希望优雅地处理缺失的 CRD。如果对缺失类型启动 informers，则会导致错误并阻塞启动。相反，我们引入了一个“CRD 观察者”组件，观察集群中的 CRD 以确定它们是否可用。\n\n有两种使用方式：\n* 一些组件只是在做需要的工作之前阻塞 \u0060watcher.WaitForCRD(...)\u0060。\n* \u0060kclient.NewDelayedInformer\u0060 也可以完全抽象这一点，通过提供一个在幕后处理这一点的客户端。\n\n#### Credentials Controller\n\n凭证控制器暴露访问 TLS 证书信息的途径，这些信息存储在集群的 \u0060Secrets\u0060 中。除了简单地访问证书外，它还有一个授权组件，可以验证请求者是否有权读取其命名空间中的 \u0060Secrets\u0060。\n\n#### Discovery Filter\n\n发现过滤器控制器用于实现 \u0060MeshConfig\u0060 的 \u0060discoverySelectors\u0060 字段。这个控制器读取集群中的 \u0060Namespace\u0060 以确定它们是否应该被“选中”。许多控制器使用这个过滤器来只处理配置的一个子集。\n\n#### 多集群\n\n各种控制器从多个集群读取。\n\n这始于多集群密钥控制器，该控制器读取 \u0060kubeconfig\u0060 文件（存储为 \u0060Secrets\u0060），并为每个创建 Kubernetes 客户端。控制器允许注册处理程序，这些处理程序可以处理集群的添加\/更新\/删除。\n\n这有两个实现：\n* 凭证控制器负责读取存储为 Secrets 的 TLS 证书。\n* Kubernetes 服务发现控制器有点像一个大块头，除了核心服务发现控制器之外，还启动了一堆其他子控制器。\n\n由于整体复杂性，看看这个放大一点会有帮助：\n\n![](.\/output-6.svg)\n\n#### 虚拟机\n\n虚拟机支持由两个控制器组成。\n\n自动注册控制器是一个相当独特的控制器——控制器的输入是 XDS 连接。对每个 XDS 连接，创建一个 \u0060WorkloadEntry\u0060 来注册 XDS 客户端（通常是在 VM 上运行的 \u0060istio-proxy\u0060）到网格中。这个 \u0060WorkloadEntry\u0060 与连接的生命周期绑定，有一些逻辑确保临时的停机（重新连接等）不会移除 \u0060WorkloadEntry\u0060。\n\n健康检查控制器还控制 \u0060WorkloadEntry\u0060 的健康状态。健康状态通过 XDS 客户端报告并与 \u0060WorkloadEntry\u0060 同步。\n\n#### Webhook\n\nIstio 包含验证和变更 webhook 配置。这些需要在 \u0060caBundle\u0060 中指定以配置 TLS 信任。因为 Istiod 的 CA 证书有些动态性，这在运行时进行修补（而不是作为安装的一部分）。webhook 控制器处理这种修补。\n\n这些控制器非常相似，但由于各种原因是不同的组件。\n', '\/trans\/istiod-architecture\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文译自 Istio 官方代码仓库中对 Istiod 架构的解析。描述了 Istio 控制平面——Istiod 的高层架构。Istiod 是一个模块化的单体应用，涵盖了从证书签名、代理配置（XDS）、传统的 Kubernetes 控制器等多种功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-22/">深入解析 Istio 1.22：新特性和实际应用建议</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio 1.22：新特性和实际应用建议', '探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。', '\n最近 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)包含大量的重大更新，本文将为你分享这个发布带来的新特性及应用建议。\n\n## Ambient 模式进入 Beta 阶段\n\n虽然 Ambient 模式现已进入 Beta 阶段，但这并不意味着我们可以完全告别 Sidecar。尽管 Istio 官方宣称 Ambient 模式可以简化操作并显著减少内存和 CPU 使用，但它仍然存在局限性和潜在的复杂性问题。例如，虽然取消了 Sidecar，但需引入新的 ztunnel 和 waypoint 组件，这可能带来新的挑战。关于 Ambient 模式进入 Beta 模式的详细信息请参阅 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/)。\n\n**Ambient 模式带来的新的挑战**\n\n- Ambient mode 对 L7 流量的管理仍未成熟\n- mTLS 被强制在 namespace 级别开启，也就是说使用 Ambient 模式你无法关闭 mTLS\n- Ambient 模式的无宕机升级仍未解决\n- 缺少 与 Sidecar 模式共存和迁移的最佳实践\n\n关于 Sidecar 模式和 Ambient 模式的对比，详见 [Istio Ambient 模式的局限性解析](\/blog\/istio-ambient-mode-limitations\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n如果是刚开始使用 Istio，尤其是你只需要为服务自动开启 mTLS 的情况下，当前阶段可以尝试使用 Ambient 模式。但是对于 L7 功能，建议等到 Ambient 模式完全成熟后再考虑生产上使用。\n{{\u003c\/callout\u003e}}\n\n## Istio API 升级\n\nIstio Istio 1.22 版本中，关键 API 如流量管理、安全、Telemetry 相关的 API 都已正式升级到 \u0060v1\u0060 版本。你只需要将原有配置的 API 版本修改为 \u0060v1\u0060 即可，除此之外不需要任何更改。这些 API 早已成熟，你可以放心的使用 \u0060v1\u0060 版本，对于对稳定性要求较高的环境，Istio 添加了[验证准入策略](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/)确保只有 \u0060v1\u0060 API 和字段可以在 Istio API 中使用。\n\n例如下面的 AuthorizationPolicy 示例。\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\n其他扩展类的 API 如 \u0060EnvoyFilter\u0060、\u0060WasmPlugin\u0060、\u0060ProxyConfig\u0060 还未成熟，因此还停留在 alpha 或 beta 阶段。关于 API 升级的更多信息，请参考 [v1 API 博客](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于常用功能可以放心使用 \u0060v1\u0060 API，扩展类 API 尚未稳定为了保证系统稳定性，可以开启验证准入策略。\n{{\u003c\/callout\u003e}}\n\n## Gateway API 升级\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 已更新至版本 1.1.0，现已普遍可用。这一更新扩展了 Istio 的流量管理能力，但需要注意 Istio 原生 API 与 Gateway API 的兼容性问题。在迁移到新 API 时应谨慎，以避免依赖尚未完全成熟的特性。更多详情，请查看 [Gateway API v1.1 博客](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/)。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n对于已经稳定使用 Istio API 的现有部署，可以继续使用，尤其是在需要使用到高级功能的场景下。对于新部署优先考虑使用稳定版的 Gateway API，以利用其现代化的流量管理功能。因为二者现存的兼容性问题，不要冒然迁移到 Gateway API，否则得不偿失。\n{{\u003c\/callout\u003e}}\n\n## 增量 xDS 默认启动\n\nIstio 1.22 版本默认启用了增量 xDS，这是一个优化配置分发的机制。与传统的 State of the World（SotW）模式相比，增量 xDS 仅将变更的配置发送给 Envoy 代理，从而显著减少了网络传输的数据量和控制平面的资源消耗。这一变更尤其适用于配置频繁更新的大规模部署环境，能够提高配置更新的效率和性能。此外，增量 xDS 还有助于在网络环境复杂或配置动态变化的情况下，更高效地管理服务网格的配置更新。\n\n{{\u003ccallout note \u0022建议\u0022\u003e}}\n增量 xDS 早在 Istio 的几个版本前就已经开发完成，只是没有默认开启，现在该功能已经稳定，可以放心使用。\n{{\u003c\/callout\u003e}}\n\n更多关于 xDS 的介绍请参考[Envoy xDS 及 Istio 中的配置分发流程介绍](\/blog\/istio-delta-xds-for-envoy\/)。\n\n### AuthorizationPolicy 的路径模板支持通配符\n\n在 Istio 1.22 中，\u0060AuthorizationPolicy\u0060 新增了对[路径模板](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation)的支持，极大增强了路径匹配的灵活性和精确性。而在此之前，\u0060AuthorizationPolicy\u0060 的路径配置并不支持通配符。此功能允许使用基于 Envoy 的 URI 模板匹配来定义 HTTP 请求中的路径。路径可以包括简单的通配符（\u0060*\u0060 和 \u0060**\u0060）或具名变量，从而精确匹配单个或多个路径组件。例如，路径模板 \u0060\/foo\/{*}\u0060 能匹配 \u0060\/foo\/bar\u0060 但不匹配 \u0060\/foo\/bar\/baz\u0060，而 \u0060\/foo\/{**}\/\u0060 则可以匹配任何以 \u0060\/foo\/\u0060 开头的路径。这种灵活的路径模板设计，特别适用于动态和复杂的路由规则，进一步加强了 Istio 的安全策略工具箱。\n\n下图展示了 AuthorizationPolicy 的路径匹配的通配符规则。\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy 的路径匹配通配符规则\u0022\ngraph LR\n    A[AuthorizationPolicy 路径匹配] --\u003e B(定义路径模板)\n    B --\u003e C{路径模板操作符}\n    C --\u003e D[\u0022*（匹配单个段）\u0022]\n    C --\u003e E[\u0022**（匹配多个段）\u0022]\n    C --\u003e F[\u0022{name}（命名变量匹配单个段）\u0022]\n    C --\u003e G[\u0022{name=**}（命名变量匹配多个段）\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} 匹配 \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ 匹配 \/foo\/bar\/、\/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} 匹配 \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd 匹配 \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy 的路径匹配通配符规则](f96fd4f3843d3d7b7c13b0a5083f00f4.svg)\n\n了解更多关于路径模板的具体应用和规则，你可以参考 [Envoy 的官方文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto)。\n\n{{\u003ccallout note \u0022提示\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 中的路径匹配终于支持模板了，你不需要再在配置中一个一个地手动加入路径了。\n{{\u003c\/callout\u003e}}\n\n## 总结\n\nIstio 1.22 版本引入了多项重要更新和改进，尽管某些特性被广泛宣传，但在实际使用中需要进行详细评估和适当的测试。希望本篇博客能帮助你更深入地理解和应用这些新特性，以在实际操作中获得最佳效果。\n\n## 参考\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)', '\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 Istio 1.22 的新特性与实用建议，包括增量 xDS、路径模板支持及 API 升级等，助力优化服务网格管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-delta-xds-for-envoy/">Envoy xDS 及 Istio 中的配置分发流程介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/06/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy xDS 及 Istio 中的配置分发流程介绍', '本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。', '\n在 Istio 项目的早期采用全局状态（State of the World，简称 SotW）的方式推送配置给 Envoy 代理。一旦有一个服务变更，就要将全局配置推送给所有 Sidecar，造成巨大的网络负担及控制平面的性能损耗。Istio 社区从几年前就开始开发增量 xDS 以解决此问题，并在最近几个 Istio 版本中支持了增量 xDS。在最近的 [Istio 1.22 发布](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/)中，增量 xDS 成为默认开启的功能。本文将为你介绍 xDS、增量 xDS 及 Istio 的配置分发方式。\n\n## 什么是 xDS？{#what-is-xds}\n\nxDS（Extensible Discovery Service）是一种通信协议，用于在微服务架构中管理服务发现和动态配置。这种机制被广泛用于 Envoy 代理和 Istio 服务网格中，以管理各种类型的资源配置，如路由、服务发现、负载均衡设置等。\n\n### xDS 包含哪些发现服务？{#xds-services}\n\nxDS 包括以下主要的发现服务，每种服务都负责不同类型的网络资源配置：\n\n1. **LDS（Listener Discovery Service）**：管理 Envoy 监听器的配置，这些监听器定义了如何接收和处理入站连接。\n2. **RDS（Route Discovery Service）**：提供路由信息，定义了如何根据指定规则将请求路由到不同的服务。\n3. **CDS（Cluster Discovery Service）**：管理集群信息，集群代表一组逻辑上类似的后端服务实例。\n4. **EDS（Endpoint Discovery Service）**：提供具体服务实例的网络地址，这些服务实例组成了 CDS 中定义的集群。\n5. **SDS（Secret Discovery Service）**：管理安全相关的配置，如 TLS 证书和私钥。\n6. **VHDS（Virtual Host Discovery Service）**：为 RDS 提供虚拟主机配置，允许动态更新虚拟主机而不重启连接。\n7. **SRDS（Scoped Route Discovery Service）**：管理路由作用域，提供基于不同条件（如请求头部）的动态路由选择。\n8. **RTDS（Runtime Discovery Service）**：提供运行时配置，这些配置可用于实验性功能或精细调整系统行为。\n9. **ECDS（Extension Config Discovery Service）**：为特定过滤器提供动态配置更新的服务。目前，网络过滤器、HTTP 过滤器和监听器过滤器都支持 ECDS。\n\n这些服务共同支持动态配置的分发和更新，使得基于 Envoy 的应用架构能够实时适应变化，提高可扩展性和灵活性。每种服务的实现可以独立进行，也可以通过聚合方式（如 ADS）进行统一管理。CNCF 也成立了 [xDS API 工作组](https:\/\/github.com\/cncf\/xds)来推动 xDS API 为 L4\/L7 数据平面配置提供事实上的标准，类似于 SDN 中 OpenFlow 在 L2\/L3\/L4 中所扮演的角色。\n\n{{\u003ccallout note 提示\u003e}}\n关于 xDS  协议的详细介绍，如 xDS 协议的 RPC 服务和变体方法，以及 xDS 请求流程，请参考 [Envoy 代理文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n{{\u003c\/callout\u003e}}\n\n### xDS 协议的变体 {#xds-variants}\n\nxDS 协议主要包括以下变体：\n1. **State of the World (SotW)**：单独的 gRPC 流为每种资源类型提供完整数据，通常在 Envoy 代理初次启动时使用，也是 Istio 最早使用的 xDS 协议类型。\n2. **增量 xDS（Delta xDS）**：为每种资源类型提供变化的部分数据，从 2021 年开始开发，在 Istio 1.22 版本中开始默认开启。\n3. **聚合发现服务（ADS）**：一个 gRPC 流聚合所有资源类型的数据。\n4. **增量 ADS（Delta ADS）**：一个 gRPC 流聚合所有资源类型的增量数据。\n\n下表概述了 xDS 协议的四种变体，包括对每个变体的解释、使用场景以及优缺点的对比。这些变体为不同的网络环境和服务需求提供了多种选择，可以根据具体情况选择最合适的协议变体以优化服务的性能和资源使用。\n\n{{\u003ctable \u0022xDS 协议的四种变体介绍\u0022\u003e}}\n| 变体类型  | 解释                                                         | 使用场景                                                     | 优点                                                     | 缺点                                                         |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW      | 每次都发送所有配置数据，不论是否有变化。                     | 适用于配置较少变化的稳定环境。                               | 简单易实现，易于理解和维护。                             | 数据传输量大，不适合频繁更新配置的环境。                     |\n| Delta xDS | 只传输变更的配置数据，而不是全部数据。                       | 适用于配置频繁变化，需要快速响应变更的环境。                 | 减少了不必要的数据传输，提高了效率。                     | 实现复杂，需要客户端和服务端管理配置状态。                   |\n| ADS       | 通过单一的 gRPC 流来管理所有配置数据，无需为每种资源类型建立独立的连接。 | 适用于需要同时管理多种类型资源的复杂服务架构。               | 减少了网络连接数，简化了资源管理。                       | 对于网络或服务质量差的情况，单点故障可能导致所有配置更新失败。 |\n| Delta ADS | 结合了 ADS 和增量 xDS 的优点，通过一个 gRPC 流聚合并且只传输变化部分的资源。 | 适用于既需要管理多种资源类型，又需要频繁更新配置的极其动态的环境。 | 提供了最大的灵活性和效率，适合大规模和高动态的服务架构。 | 实现最为复杂，对于配置管理的逻辑要求高，需要精确控制资源的变更和传输。 |\n\n{{\u003c\/table\u003e}}\n\n使用 xDS 协议的服务网格可以更灵活地管理微服务之间的通信和配置，减少了配置变更的延迟，提高了系统的响应速度和可靠性。\n\n在 Istio 中，DiscoveryServer 作为 Envoy 的 xDS API 的实现，负责监听 gRPC 接口并根据 Envoy 的需求动态推送配置。它能够处理各种资源类型的请求，并根据服务的变更实时更新 Envoy 配置。此外，它还支持安全特性，如验证客户端证书，确保只有合法的服务实例可以接收配置数据。\n\n### xDS 变体的配置示例 {#xds-config}\n\n使用 xDS 协议的变体通常涉及在 Envoy 代理或与之类似的服务网格配置中指定 xDS 服务器的详细信息。虽然不同的服务网格和代理服务器的配置细节可能有所不同，下面是一些通用的 YAML 配置示例，说明如何指定 xDS 服务器以及如何使用这些协议变体。\n\n#### State of the World (SotW)\n\n在 Envoy 的配置中，你可以通过静态资源或通过 API 动态获取资源的方式来使用 SotW。这里是一个简单的 Envoy 配置示例，显示了如何静态定义集群和监听器：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n####  增量 xDS {#axds}\n\n增量 xDS 的配置需要在 xDS 服务端支持增量协议，并在客户端配置中指定使用增量 xDS。Envoy 启动配置中需要添加 API 版本来启用增量 xDS：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### 聚合发现服务 (ADS) {#ads}\n\n使用 ADS 时，所有资源类型的配置通过一个单一的 API 端点聚合。这在 Envoy 配置中指定：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n  lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n####  增量 ADS {#adds}\n\n增量 ADS 通过在 ADS 配置中指定增量 API 类型，可以实现更为细粒度的更新：\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n这些配置示例需要根据你的具体环境和需求进行调整。更多细节和高级配置，你可以参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype)。\n\n## Istio 如何发送配置给 Envoy sidecar？\n\n得益于 xDS 协议，如 Istio、Envoy Gateway 等可以通过 API 远程动态分发配置到 Envoy 代理。下图展示了 Istio 的配置分发流程（Sidecar 模式）。\n\n\u0060\u0060\u0060mermaid \u0022Istio 的配置分发流程图\u0022\nflowchart TB\n    Declarative_Configuration[声明式配置] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio 的配置分发流程图](0fa133ccdbeb372a413ad1ecc99ff9f0.svg)\n\nIstio 中配置分发的主要流程说明：\n\n1. **声明式配置**：用户通过 YAML 文件或其他配置管理工具定义服务网格的配置。这些配置可以包括路由规则、安全策略、遥测设置等。\n2. **Kubernetes**：Istio 配置文件被提交到 Kubernetes 集群中，通常是通过 \u0060kubectl apply\u0060 命令或其他 CI\/CD 工具。Kubernetes 接收到配置文件并将其存储在 etcd 数据库中。\n3. **Istiod**：Istiod 是 Istio 的控制平面组件，负责管理和分发配置。它监听从 Kubernetes API 服务器中传入的事件，获取相关配置变更，并对其进行处理。Istiod 解析配置文件，生成相应的路由规则和策略，并通过 xDS API 将这些配置分发到数据平面（Envoy 代理）。\n4. **xDS API**：Istiod 使用 xDS API 将配置下发到各个 Envoy 代理中。\n5. **Envoy Proxy**：Envoy 是 Istio 的数据平面组件，运行在每个服务的旁路（sidecar）容器中，拦截并管理所有入站和出站流量。Envoy 代理通过 xDS API 接收来自 Istiod 的配置，并根据这些配置进行流量管理、策略执行和遥测数据收集。\n6. **Pod**：每个服务实例运行在一个 Pod 中，Pod 内部包含一个应用容器和一个 Envoy 代理容器。Envoy 代理拦截应用容器的所有网络流量，并根据配置进行处理。\n\n这个配置分发流程确保了 Istio 能够动态管理和配置服务网格中的所有服务实例，提供一致的流量管理和策略执行。\n\n## xDS 的发展与 Istio 中的 Delta xDS 实现\n\n起初，xDS 采用了“全局状态”（State of the World，简称 SotW）的设计，这意味着任何一个配置的更改都需要向 Envoy 发送所有配置的完整状态。这种方法在网络和控制平面上造成了巨大的负担，尤其是在大规模服务部署时。\n\n在 2021 年的 EnvoyCon 上，Aditya Prerepa 和 John Howard 分享了 Istio 如何实现 Delta xDS，这是一种增量式的 xDS 实现。与传统的 SotW xDS 相比，Delta xDS 只发送变更的配置，显著减少了需要通过网络发送的配置数据量，从而提高了效率和性能。这种方法特别适用于那些配置频繁变更的环境，因为它只更新变化的部分而不是整个配置。\n\n在实现 Delta xDS 的过程中，Istio 团队面临了多个挑战，包括如何确保配置更新的正确性以及避免潜在的资源泄漏。他们通过采用干运行（Dry-run）模式来并行运行 SotW 和 Delta 生成器，逐步发现并修复了实现中的缺陷。此外，他们还引入了新的 Envoy 类型，如虚拟主机发现服务（Virtual Host Discovery Service），以支持更细粒度的配置分发。\n\n### Delta xDS 增量配置\n\n下图展示了 Delta xDS 增量配置的流程。\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS 增量配置流程图\u0022\nsequenceDiagram\n    participant CP as 控制平面\n    participant P as 代理\n    CP-\u003e\u003eP: 初始完整配置\n    P-\u003e\u003eCP: 订阅配置变更\n    Note over CP,P: 发生任何配置变更\n    CP-\u003e\u003eP: 检查配置变更\n    CP-\u003e\u003eP: 计算差异\n    CP-\u003e\u003eP: 仅发送差异\n    Note over P: 代理使用差异进行更新\n\u0060\u0060\u0060\n\n![Delta xDS 增量配置流程图](835038abb9bb83ba223974c525293468.svg)\n\nDelta xDS 配置流程如下：\n\n1. **初始完整配置**：控制平面向代理发送初始完整配置，此时使用的是 StoW 模式。\n2. **订阅配置变更**：代理从控制平面订阅配置变更。\n4. **检查配置变更**：控制平面检查相对于代理已知状态的配置变更。\n5. **计算差异**：控制平面计算当前配置与代理持有的前一配置之间的差异（增量）。\n6. **仅发送差异**：控制平面仅发送变更的配置（差异）给代理，代理应用这些差异增量更新其配置。\n\n该流程确保只有必要的变更被传输和应用，提高了效率并减少了网络和代理资源的负载。\n\n### SotW vs Delta xDS\n\n虽然 Delta xDS 解决了在大规模网络下的配置分发的性能问题，但是 SotW 模式依然有它存在的意义，比如在初次下发配置的情况下。下表对比了 Istio 中的两种配置分发方式：SotW (State of the World) 和 Delta xDS。\n\n{{\u003ctable \u0022Istio 中的全局状态和增量 xDS 配置分发方式对比\u0022\u003e}}\n| 对比项         | SotW                                                     | Delta XDS                                    |\n| -------------- | -------------------------------------------------------- | -------------------------------------------- |\n| **数据传输量** | 每次传输完整的配置数据，不管配置是否有变更。             | 仅传输发生变化的配置数据，减少了数据传输量。 |\n| **效率**       | 在小型或变更少的环境中效率可接受。                       | 在大型环境或频繁变更的环境中更高效。         |\n| **复杂性**     | 实现简单，易于理解和维护。                               | 实现较为复杂，需要精细的变更跟踪和管理。     |\n| **资源消耗**   | 可能因为重复发送大量未变更的数据而增加服务器和网络负载。 | 更低的资源消耗，因为只处理变更的部分。       |\n| **实时性**     | 配置更新后立即发送全量配置，实时性高。                   | 只发送变更部分，响应更快，减少处理时间。     |\n| **适用场景**   | 适合配置变动不频繁的小型至中型部署。                     | 适合配置频繁变更或大规模部署的场景。         |\n{{\u003c\/table\u003e}}\n\n这个表格从数据传输量、效率、复杂性、资源消耗、实时性以及适用场景等多个角度对 SotW 和 Delta XDS 进行了对比，有助于在不同的使用环境中做出合适的选择。\n\n## 总结\n\n在这篇文章中我分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。随着 Delta xDS 在 Istio 1.22 版本中成为默认配置，这将有助于用户在大规模网络环境下轻松使用 Istio。\n\n## 参考\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文分享了 xDS 的组成及 Istio 中配置分发的流程，还有 xDS 的两种模式 SotW 和 Delta xDS。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-mode-limitations/">Istio Ambient 模式的局限性解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式的局限性解析', '深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。', '\n[Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) 版本的发布标志着 Ambient 模式正式进入 beta 阶段，随之发布了一篇标题为 [告别 Sidecar：Istio 的 Ambient 模式在 v1.22 中达到 Beta](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/) 的博客，声称 Layer 4 和 Layer 7 的功能现已可用于生产环境。其实社区早在一个月前的 KubeCon EU 上就宣布了这一里程碑。这种激动人心的宣传似乎在暗示我们可以彻底抛弃 Sidecar 模式，但事实真是如此吗？\n\n### 为什么不急于告别 Sidecar 模式？\n\n虽然我对新技术持开放态度，但完全告别 Sidecar 模式可能为时尚早。每种模式都有其特定的应用场景和优缺点。下面，我将详细分享 Ambient 模式相较于 Sidecar 模式的一些限制，帮助大家更好地理解两者之间的差异。\n\n### Ambient 模式与 Sidecar 模式的关键区别\n\n#### 流量管理\n\nAmbient 模式的 L7 流量管理支持尚未成熟，尚未达到生产环境的可用水平。相较之下，Sidecar 模式在这方面更为稳定和可靠。\n\n#### 安全性\n\n在 Ambient 模式下，mTLS 被强制在 namespace 级别开启，而 Sidecar 模式则赋予用户更大的灵活性，可以选择是否启用 mTLS。这种灵活性对于某些应用场景尤为重要。\n\n#### 可观测性\n\n对于 L7 层的遥测数据，Ambient 模式能否像 Sidecar 模式一样对每个 pod 进行精确的监控和追踪仍是一个疑问。Sidecar 模式在可观测性方面已被广泛验证，其能力更为成熟。\n\n#### 运维\n\n部署方面，Ambient 模式推荐使用 Helm，仅支持 Kubernetes 平台，而 Sidecar 模式还支持虚拟机和混合云环境。此外，Ambient 模式尚未得到主要云厂商的官方支持。在升级过程中，Ambient 模式的爆炸半径更大，暂不支持金丝雀发布，推荐使用蓝绿部署。对于从 Sidecar 模式向 Ambient 模式的迁移或二者共存，仍缺乏最佳实践。\n\n#### 扩展性\n\n目前对于 Wasm 插件的支持，Ambient 模式仍不明确，而 Sidecar 模式在这方面已经有了较为完善的支持。\n\n#### 其他功能特性\n\nDual Stack 模式在 Sidecar 模式下虽然仍处于实验阶段，但至少已有一定的实现，而 Ambient 模式是否支持这一特性仍不明朗。\n\n### 总结\n\n虽然 Istio 1.22 带来了令人兴奋的 Ambient 模式，但在完全告别 Sidecar 模式之前，我们需要慎重考虑这些限制和差异。每种模式都有其独特的优势和适用场景，用户应根据自身需求做出明智的选择。我将继续对 Ambient 模式进行测试和追踪，更多深入解读敬请关注本博客。', '\/blog\/istio-ambient-mode-limitations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-introduction/">Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口', '本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。', '\n在 Kubernetes 环境下选择正确的网络通信工具至关重要。根据[Tetrate 的讨论](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/)，选择取决于网络通信的类型：南北向流量还是东西向流量。对于主要处理外部请求的服务，Envoy Gateway 是理想选择，它不仅高效管理流量，还能在你向微服务架构过渡时提供无缝集成。\n\n本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。\n\n## Envoy Gateway 及其在服务网格中的角色概述 {#overview}\n\nEnvoy Gateway 是一个围绕 Envoy Proxy 构建的 Kubernetes 原生 API 网关，它旨在降低用户采用 Envoy 作为 API 网关的难度，并为供应商建立 API 网关（例如 [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/)）增值产品奠定基础。\n\nEnvoy Gateway 不仅是管理南北流量的理想选择，也可作为连接和保护服务网格中服务的关键组件。它还通过提供安全的数据传输、流量路由、负均衡及故障恢复等功能，增强了微服务之间的通信效率和安全性。Envoy Gateway 利用其内置的 Envoy Proxy 技术，可以处理大量的并发连接和复杂的流量管理策略，同时保持较低的延迟和高吞吐量。\n\n此外，Envoy Gateway 与 Kubernetes Gateway API 的紧密集成使得它能够以声明式的方式进行配置和管理，极大简化了服务网格中网关的部署和更新过程。这种集成不仅提升了操作效率，还使得 Envoy Gateway 能够在不增加额外复杂性的前提下，与服务网格如 Istio 这样的解决方案无缝协作。\n\n下图展示了 Envoy Gateway 与服务网格的关系。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 与服务网格的关系\u0022\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes 集群\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022服务\u0022]\n        pods[\u0022Pod\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022管理南北向流量\u0022 --\u003e svcs\n        eg -- \u0022由...配置\u0022 --\u003e gwapi\n        gwapi -. \u0022定义路由规格\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022服务网格\u0022]\n        smc[\u0022服务网格控制平面（如 Istio、Linkerd）\u0022]\n        smp[\u0022服务网格数据平面（Envoy Sidecars）\u0022]\n        smc -- \u0022配置\u0022 --\u003e smp\n        smp -- \u0022处理东西向流量\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022是...的一部分\u0022 .-\u003e SM\n    svcs -- \u0022连接到\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Envoy Gateway 与服务网格的关系](8691fed7a410e3a8f45252cc5c8e11db.svg)\n\n在 Kubernetes 集群中，Envoy Gateway 负责管理南北向流量，即进出集群的流量，并通过 Kubernetes Gateway API 进行配置，后者定义了服务的路由规格。集群内服务直接连接到 Pods。服务网格部分，由控制平面（如 Istio 或 Linkerd）配置数据平面中的 Envoy Sidecars，这些 Sidecars 负责处理集群内部的东西向流量。在这个系统中，Envoy Gateway 可以与服务网格相互协作，但它们各自独立地管理不同方向的流量。\n\n设想一下，Envoy Gateway 像是一个城市的主要入口（比如海关），所有的数据流，就像各种车辆，都得通过这个大门进出。它就像一个严格的守门员，负责审查、指导，确保每个数据包，就像每个乘客，都能被准确地送到目的地。在 Kubernetes 这座城市中，Envoy Gateway 管理着所有进城的流量，它确保数据流可以安全、高效地进入城市，并被准确地送达给城市内部的服务。\n\n进入城市之后，服务网格就接管了，这就像城市内部的一系列交通网络。服务网格中的 Envoy sidecars 就好比是这座城市内部的出租车或者公交车，负责把数据包从海带到它们在城市内部的具体目的地。Envoy Gateway 负责将外部请求顺利引入，之后服务网格负责在集群内部继续高效地处理这些请求。\n\nEnvoy Gateway 对 Kubernetes Gateway API 的支持，可以看作是对我们城市交通信号系统的一个重大升级。这不仅为进入城市的数据流提供了更加清晰和个性化的指引，而且让整个城市的交通运行更加智能化。\n\n## Envoy Gateway 的核心功能和优势 {#pros}\n\nEnvoy Gateway 提供了几个核心功能，使其成为 API 网关的突出选择：\n\n- **简化配置**：通过与 Kubernetes Gateway API 直接集成，Envoy Gateway 允许开发者使用 Kubernetes 自定义资源以声明方式配置路由规则、安全策略和流量管理。\n- **性能和可扩展性**：基于经过实战测试的 Envoy Proxy，它提供卓越的性能和可扩展性，轻松处理数千个服务和每秒数百万个请求。\n- **安全功能**：内置支持各种安全措施，如 SSL\/TLS 终止、OAuth2、OIDC 认证以及细粒度访问控制。\n- **可观测性**：提供全面的监控能力，包括详细的度量、日志和追踪，这对于诊断和理解流量行为至关重要。\n\n## 与 Gateway API 的关系 {#gateway-api}\n\n在 Kubernetes 环境中引入的 Gateway API 为集成和配置 Ingress 网关提供了一种新的强大方法，它与传统的 Ingress 相比具有更高的灵活性和功能性。正如我在 [Gateway API：Kubernetes 和服务网格入口中网关的未来](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 中所讨论的，Gateway API 通过区分角色和提供跨命名空间支持，更适应多云环境，且已被多数 API 网关采用。这种 API 设计支持了 ingress 网关（南北向流量）与服务网格（东西向流量，跨集群路由）的融合，使得 Envoy Gateway 成为 Kubernetes 和服务网格中统一未来的网关解决方案。通过引入 Gateway API，Envoy Gateway 强化了其作为云原生环境中前沿代理的角色，使得用户能够更灵活地管理其流量和策略。\n\nKubernetes Gateway API 是 Envoy Gateway 的基石，它提供了一种更具表达性、灵活性和以角色为导向的方式来配置 Kubernetes 生态系统中的网关和路由。该 API 提供了如 GatewayClass、Gateway、HTTPRoute 等自定义资源定义（CRD），Envoy Gateway 利用这些资源创建用户友好且一致的配置模型，与 Kubernetes 的原生原则保持一致。\n\n{{\u003ccallout note \u0022什么是 API Gateway？\u0022\u003e}}\n\nAPI Gateway 是对 API 的全面管理和托管服务。它作为应用程序与后端服务之间的中间层，不仅处理创建、维护、发布、运行和下线等生命周期事件，还承担着更多关键职能。一个完善的 API Gateway 应该提供以下功能来丰富和扩展其基本定义：\n\n1. **流量控制**：API Gateway 应能够处理并控制到后端服务的流量，包括请求路由、负载均衡、熔断机制以及速率限制，以保证后端服务的稳定性和高可用性。\n2. **安全性保障**：应具备鉴权、授权和加密功能，能够有效地管理和保护 API 的安全。这涉及到身份验证机制、API 密钥管理、OAuth、JWT、mTLS 等，以确保只有授权的用户和服务能够访问 API。\n3. **监控和分析**：提供实时监控和日志记录功能，能够跟踪 API 的使用情况、性能指标、异常检测和分析流量模式，从而优化 API 的性能和响应能力。\n4. **变更管理**：支持对 API 变更进行管理，包括版本控制和渐进式部署（如蓝绿部署或金丝雀发布），以无缝过渡新版本且最小化对最终用户的影响。\n5. **请求和响应的转换**：允许对传入和传出的 API 调用进行转换，比如从 REST 到 GraphQL 的转换，或是添加、删除和修改请求头和响应头。\n6. **跨域资源共享（CORS）支持**：管理和控制跨域请求，允许不同域的前端应用安全地调用后端 API。\n7. **配额和计费**：为 API 使用设定配额限制，同时支持计费功能，以适用于商业化的 API 提供。\n8. **用户友好的开发者门户**：提供一个面向开发者的门户，使得第三方开发者可以轻松地发现、测试和集成 API。\n9. **协议支持**：支持各种网络协议，包括 HTTP\/HTTPS、WebSocket、gRPC 等，确保与多种客户端和服务的兼容性。\n10. **插件化和扩展性**：允许通过插件或中间件来扩展 API Gateway 的功能，使其可以根据业务需求灵活适配各种中间件服务。\n11. **服务治理**：集成服务注册和发现机制，以适应微服务架构下服务的动态性。\n\n综上所述，API Gateway 的角色远远超越了简单的 API 生命周期管理。它是实现微服务架构、确保服务安全性、提高运维效率和优化用户体验的关键组件。通过这些广泛的功能，API Gateway 成为现代云原生应用不可或缺的一部分。\n\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 架构概览 {#arch}\n\nEnvoy Gateway 的架构设计旨在轻量级和简洁。它包括一个动态配置运行作为数据平面的 Envoy 代理的控制平面。这种关注点的分离确保了网关可以随着流量的增长而扩展，而不影响控制平面的效率。\n\nEnvoy Gateway 的架构图如下所示。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n在这个架构图的核心是 Envoy Gateway，它是 Envoy 代理的执行实例，负责处理从 Kubernetes 集群进出的所有流量。初始启动时，Envoy Gateway 通过配置文件提供静态配置，建立其操作的基本参数。\n\nEnvoy Gateway 配置的动态方面由提供者处理，该提供者定义了网关与 Kubernetes 或其他动态配置输入源的交互。资源监视器负责监视 Kubernetes 资源的更改，特别关注与自定义资源定义（CRD）相关的 CRUD 操作。\n\n随着更改的发生，资源转换器介入将这些外部资源转换为 Envoy Gateway 可以理解的形式。这一转换过程进一步由特定于提供者的基础设施管理器促进，后者负责管理与特定云或基础设施提供商相关的资源，塑造中间表示形式的基础设施，这对于网关的功能至关重要。\n\n然后，该中间表示形式转变为 xDS 中间表示形式，作为 Envoy 理解和执行的最终 xDS 配置的先导。xDS 翻译器承担将这种中间表示形式转换为具体的 xDS 配置的角色。\n\n这些配置由 xDS 服务器交付并执行，该服务器作为服务，根据其收到的 xDS 配置，认真管理 Envoy 实例。Envoy 作为实际运行的代理，最终从 xDS 服务器接收这些配置，解释并实现它们以有效管理流量请求。\n\n最终，所有请求经过 Envoy 的处理后被重定向到了 Envoy Gateway 路由的流量的最终目的地，也就是后端服务。\n\n## 与其他网关的比较 {#comparations}\n\n与 Istio 的入口网关或 NGINX Ingress 等其他流行解决方案相比，Envoy Gateway 凭借其与 Kubernetes 的原生集成以及利用 Envoy 全部潜力的专注，而脱颖而出。下图从多方面对比了目前流行的一些开源的 API 网关。\n\n{{\u003ctable \u0022开源 API 网关对比\u0022\u003e}}\n| API 网关      | 支持的认证和授权策略                                         | 支持的服务发现组件                     | 支持的协议                       | 控制平面配置分发方法 | 支持的插件扩展机制   | 组织隶属               |\n| ------------- | ------------------------------------------------------------ | -------------------------------------- | -------------------------------- | -------------------- | -------------------- | -------------------------- |\n| Envoy Gateway | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                        | HTTP, HTTPS, gRPC                | xDS                  | 基于 Envoy Filter | CNCF                       |\n| Kuma          | mTLS, JWT                                                    | Kubernetes, Consul                     | HTTP, HTTPS, gRPC, TCP           | REST, gRPC           | 基于 Lua, Go       | CNCF                       |\n| NGINX Ingress | RBAC                                                         | Kubernetes                             | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD       | 基于 Nginx 模块    | N\/A                        |\n| APISIX        | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID 等 | Kubernetes, DNS, Consul, Nacos, Eureka | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI    | 基于 Lua, Wasm    | Apache Software Foundation |\n| Kong          | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI   | 基于 Lua          | N\/A                        |\n| Emissary      | Basic Auth                                                   | Kubernetes                             | HTTP, HTTPS, gRPC                | Kubernetes CRD       | 基于 Lua, Go      | CNCF                       |\n{{\u003c\/table\u003e}}\n\n## 快速开始使用 Envoy Gateway {#envoy-gateway-quick-start}\n\n要快速上手 Envoy Gateway，你可以通过以下简化步骤快速搭建一个本地实验环境。首先，启动一个本地 Kubernetes 集群：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\n接下来，部署 Gateway API CRD 和 Envoy Gateway 本身：\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n然后，安装网关配置并部署一个示例应用：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n为了暴露 LoadBalancer 服务，这里我们使用端口转发作为示例。你也可以选择使用 \u0060minikube tunnel\u0060 或安装 [MetalLB](https:\/\/metallb.universe.tf\/installation\/) 作为负载均衡器：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\n通过以下命令测试你的 Envoy Gateway 是否正常工作：\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\n想了解更多详细的安装和配置步骤，请访问 Envoy Gateway 网站。通过这些步骤，你可以快速开始探索 Envoy Gateway 的功能。\n\n## 总结 {#summary}\n\nEnvoy Gateway 不仅优化了云原生时代的七层网关配置，而且为从边缘网关向服务网格过渡提供了一个平滑的道路。由于服务网格的推广面临一些挑战，如对应用的侵入性和运维团队推动问题，边缘网关则更易于被开发团队接受。Envoy Gateway 采用简化的 Kubernetes Gateway API，提高了流量管理和可观测性的能力。此外，Envoy Gateway 到 Istio 的过渡对于已熟悉 Envoy 功能的团队来说，将是一个自信的技术进步，同时还支持从标准的 Kubernetes Gateway API 到 Istio Ingress Gateway 的无缝切换，或者作为一个定制解决方案继续与 Istio 协作。这些特点使得 Envoy Gateway 成为一个在云原生时代值得投资的网关选择。\n\n请继续关注本系列博客的后续部分，我们将深入探讨如何配置和优化 Envoy Gateway，提供实用指南并展示更广泛的实际应用案例。\n', '\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-cni-deep-dive/">深入解析 Istio CNI：赋能无侵入式流量管理与强化服务网格安全</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/04/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio CNI：赋能无侵入式流量管理与强化服务网格安全', '本文详细解释了 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 提升安全性和权限管理。', '\n本文将深入探讨 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 来解决传统模式中存在的安全和权限问题。本文内容包括：\n\n- Init 容器的安全风险及其解决方案。\n- Istio CNI 的工作原理及其优势。\n- Ambient Mode 的实现机制及其与 CNI 的集成。\n\n## Istio 网络要求与解决方案概览 {#overview}\n\nIstio 服务网格通过 Sidecar 模式实现应用流量的拦截和管理。该模式通过在应用程序 Pod 中注入 Sidecar Proxy 和 init 容器，并使用 iptables 规则来管理网络流量。详细的部署和操作过程请参见 [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](\/blog\/sidecar-injection-iptables-and-traffic-routing\/)。虽然此方法在多数 Kubernetes 平台上有效，但对高权限的依赖在多租户环境中引发了安全方面的担忧。\n\n### Istio-init 的局限性 {#istio-init}\n\nIstio 在其网络配置初期采用了 \u0060istio-init\u0060 容器来初始化流量拦截规则，这需要容器具有高级权限来修改网络配置，如 IPTables 规则。虽然这种方法实现了对流量的有效管理，但它也显著提高了权限需求并增加了安全风险。根据 [Istio 官方文档](https:\/\/istio.io\/latest\/zh\/docs\/setup\/additional-setup\/cni\/)，\u0060istio-init\u0060 容器默认被注入到 Istio 网格中的 Pod 里，以便将网络流量劫持到 Istio 的 Sidecar 代理。这一过程需要对部署 Pod 的 Service Account 赋予 [\u0060NET_ADMIN\u0060 容器权限](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/configure-pod-container\/security-context\/#set-capabilities-for-a-container)，可能与某些组织的安全政策相悖。\n\n### Istio CNI 插件 {#istio-cni-plugin}\n\n为响应这一挑战，Istio 社区推出了 [Istio CNI](https:\/\/github.com\/istio\/istio\/tree\/master\/cni) 插件，该插件避免了对 init 容器的需求，允许直接在 Kubernetes 的网络层面操作，从而降低权限需求并简化部署流程，但是存在 CNI 兼容性问题。\n\n### Ambient 模式的引入 {#ambient-mode}\n\nIstio 的 Ambient Mode 是一种创新的无 sidecar 方案，它通过 [使用 Geneve 隧道](\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/) 或 Istio CNI 提高网络的灵活性和安全性。\n\n直到最近 Istio 社区才推出[适配任意 CNI](https:\/\/istio.io\/latest\/zh\/blog\/2024\/inpod-traffic-redirection-ambient\/) 的通用的解决方案。此模式解决了与任意 CNI 的兼容性问题，使 Istio 能够在不影响现有网络策略的前提下，更有效地管理服务间的流量。\n\n## NET_ADMIN 权限的安全考虑 {#net-admin}\n\n在 Kubernetes 和 Docker 等容器化环境中，\u0060NET_ADMIN\u0060 权限允许容器内的进程执行广泛的网络相关操作。这包括修改 iptables 规则、更改网络接口配置、管理 IP 路由表，以及控制网络相关的内核参数。然而，这种权限的使用引发了安全上的考虑，特别是在权限过度和潜在的攻击面方面。\n\n**最佳实践包括**：\n\n- **限制使用范围**：只在必要时授予 \u0060NET_ADMIN\u0060 权限，并通过 Kubernetes 网络策略加以限制。\n- **持续监控与审计**：对使用 \u0060NET_ADMIN\u0060 权限的容器进行严格的日志记录和监控。\n\n## Istio CNI 插件的工作原理 {#istio-cni-principal}\n\nIstio CNI 插件是一个二进制文件，作为代理安装在每个节点的文件系统中。以下流程图说明了 Istio CNI 节点代理的工作原理：\n\n\u0060\u0060\u0060mermaid \u0022Istio CNI 插件的工作原理\u0022\nflowchart TB\n    subgraph istio_cni_node_agent[Istio CNI 节点代理]\n        direction LR\n        install_plugin[安装 Istio CNI 插件]\n        update_config[更新节点 CNI 配置位于 \/etc\/cni\/net.d]\n        monitor_paths[监控插件和配置路径]\n        \n        subgraph sidecar_mode[\u0022Sidecar 模式\u0022]\n            sidecar_setup[为 Pod 配置 iptables]\n        end\n        \n        subgraph ambient_mode[\u0022Ambient 模式\u0022]\n            ambient_server[Ambient 监控服务器]\n            sync_events[同步 Pod 事件]\n            configure_iptables[在 Pod 内配置 iptables]\n        end\n\n        install_plugin --\u003e update_config\n        update_config --\u003e monitor_paths\n        monitor_paths --\u003e sidecar_mode\n        monitor_paths --\u003e ambient_mode\n        ambient_mode --\u003e ambient_server\n        ambient_server --\u003e sync_events\n        sync_events --\u003e configure_iptables\n    end\n\u0060\u0060\u0060\n\n![Istio CNI 插件的工作原理](fb607dc081ac2cb19c109626ccfe368b.svg)\n\n\n\n- Istio CNI Node Agent 充当安装在每个节点上的代理。\n- 安装 Istio CNI 插件并更新节点的 CNI 配置。\n- 代理监控 CNI 插件和配置路径的更改。\n- 在 Sidecar 模式下，它使用 pod 的 iptables 处理 sidecar 网络设置。\n- 在 Ambient 模式下，它将 pod 事件同步到环境监控服务器，然后该服务器在 pod 内配置 iptables。\n- 节点需要提升权限，例如 \u0060CAP_SYS_ADMIN\u0060 、 \u0060CAP_NET_ADMIN\u0060 和 \u0060CAP_NET_RAW\u0060 才能在任一模式下运行。\n\n## 解析 Istio Ambient Mode 与 Kubernetes CNI 的冲突 {#confilct}\n\nIstio 的 Ambient Mode 是为了适配所有 CNI 而设计的一种模式，它通过 ztunnel 来透明地处理 Pod 内的流量转发，而不影响现有的 CNI 配置。这种模式下，Ambient Mode 通过 ztunnel 管理流量，使其流经 Istio 服务网格，而标准的 CNI 则侧重于为 Pod 提供标准化的网络接入。\n\nCNI 的主要职责是解决 Kubernetes Pod 之间的网络连通性，例如分配 IP 地址和转发数据包。相比之下，Ambient Mode 需要将流量导入 ztunnel，这与 CNI 的网络配置可能存在不兼容，主要问题包括：\n\n- 主流 CNI 的网络配置可能会与 Istio 的 CNI 扩展冲突，导致流量处理中断。\n- 如果部署的网络策略依赖于 CNI，那么使用 Istio CNI 时可能会影响这些策略的执行。\n\n为解决这些问题，可以通过将 ztunnel 运行在与 Pod 相同的用户空间中，避免与 CNI 修改过的内核空间的冲突。这样，Pod 可以直接连接到 ztunnel，绕过 CNI 的影响。\n\n下面的时序图描述了 Ambient mode 下的流程：\n\n\u0060\u0060\u0060mermaid \u0022Amibent mode 的运行流程\u0022\nsequenceDiagram\n    participant K8s_API as Kubernetes API\n    participant Plugin as CNI Plugin\n    participant Agent as Ambient CNI Agent\n    participant Server as Ambient Watch Server\n    participant Ztunnel as ztunnel\n\n    Plugin-\u003e\u003eAgent: CmdAdd (Pod 调度)\n    Agent-\u003e\u003eServer: 通知新的 Pod\n    Server-\u003e\u003eK8s_API: 检索 Pod 信息\n    K8s_API--\u003e\u003eServer: Pod 详情\n    Server-\u003e\u003eZtunnel: 设置 iptables\n    Ztunnel-\u003e\u003eServer: 确认设置\n    Server-\u003e\u003eAgent: 配置完成\n    Agent-\u003e\u003ePlugin: CmdDel (Pod 移除)\n    Server-\u003e\u003eZtunnel: 移除 iptables\n    Ztunnel--\u003e\u003eServer: 确认\n\u0060\u0060\u0060\n\n![Amibent mode 的运行流程](a513f6cb6fbbf1fd242a46a962706dd8.svg)\n\n\n\n- **Ambient CNI 代理** 通过监听信号着 Pod 创建的 UDS 事件来启动交互。\n- **Ambient 监控服务器** 根据需要修改 Pod 内的 iptables，将流量重定向到 ztunnel。\n- **ztunnel** 在 Kubernetes 集群内建立连接，并处理网络流量的重定向。\n\n## 解决 Istio Ambient Mode 和 Kubernetes CNI 的冲突 {#resolution}\n\n为缓解这些冲突，Istio 的 Ambient Mode 避免了对 CNI 修改过的内核空间的依赖：\n\n- **在用户空间运行 ztunnel**：这一策略让 ztunnel 与 Pod 运行在同一用户空间，避免了与 CNI 的直接冲突。\n- **确保 CNI 兼容性**：Istio CNI 配置必须在不影响现有 CNI 插件配置的前提下进行，确保 Pod 间的正常通信和流量管理。\n\n这些措施帮助 Istio 的 Ambient Mode 在不干扰现有 CNI 插件的情况下，有效管理服务间流量。\n\n## Istio Ambient Mode 的流量管理优化 {#optimization}\n\nAmbient Mode 在 Istio 中通过 **node-local Ztunnel** 实现了改进的流量转发机制，允许在 Pod 的网络命名空间中设置侦听套接字，实现从服务网格内部的加密（mTLS）和明文流量的有效重定向。这种方法不仅提高了流量管理的灵活性，还避免了与现有的 CNI 插件之间的潜在冲突。下面是该模式的具体实现流程：\n\n\u0060\u0060\u0060mermaid \u0022Ambient mode 的实现流程\u0022\ngraph TD\n    subgraph Kubernetes 集群\n    A[带有 istio.io\/dataplane-mode=ambient 的 Pod] --\u003e|被检测到| B(istio-cni 节点代理)\n    B --\u003e C{Pod 状态}\n    C --\u003e|新启动| D[CNI 插件触发]\n    C --\u003e|已运行| E[新 Pod 事件]\n    D \u0026 E --\u003e F[配置重定向]\n    F --\u003e|进入 Pod 的网络命名空间| G[建立网络重定向]\n    G --\u003e H[通知节点 Ztunnel]\n    H --\u003e|在 Pod 的命名空间中创建监听套接字| I[节点本地 Ztunnel 代理实例]\n    I --\u003e J[流量重定向已建立]\n    end\n\n    J --\u003e K{流量类型}\n    K --\u003e|mTLS| L[网格内的加密流量]\n    K --\u003e|明文| M[明文流量处理]\n\u0060\u0060\u0060\n\n![Ambient mode 的实现流程](37dcdcfa80a406219ebe4b580345b04d.svg)\n\n\n\n具体步骤如下：\n\n1. **侦测标记**：Istio CNI 节点代理侦测标记为 \u0060istio.io\/dataplane-mode=ambient\u0060 的 Pod。\n2. **触发 CNI 插件**：根据 Pod 事件（新启动或现有 Pod 加入网格）触发 CNI 插件，这一步会触发 Istio CNI 节点代理进行流量重定向配置。\n3. **配置重定向规则**：在 Pod 的网络命名空间内配置网络重定向规则，以便拦截并重定向至 node-local ztunnel 代理。\n4. **建立侦听套接字**：node-local ztunnel 在 Pod 的网络命名空间中创建侦听套接字，实现流量的重定向。\n5. **流量处理**：node-local ztunnel 处理网格内的加密（mTLS）和明文流量，确保数据传输的安全性和高效性。\n\n通过这种方法，Istio Ambient Mode 为 Kubernetes 环境中的服务间流量管理提供了一种更为高效和安全的解决方案。\n\n## 总结 {#summary}\n\n本文全面解析了 Istio CNI 插件的设计理念、实现方式和优势，特别是 Istio CNI 如何解决了传统 \u0060istio-init\u0060 方法中存在的权限和安全问题。通过这些创新，Istio 在网络安全和操作简便性上取得了重大进步，为 Kubernetes 环境中实施 Istio 提供了更灵活和高效的方法。\n', '\/blog\/istio-cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细解释了 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 提升安全性和权限管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/2/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/4/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/page/12/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(81)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-ext-proc-guide/">深入解析 Envoy 外部处理过滤器（ext_proc）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/building-private-ai-knowledge-base-anythingllm/">探索 AnythingLLM：借助开源 AI 打造私有化智能知识库</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
