<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-certificates-management/">Istio 中的证书管理方式介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的证书管理方式介绍', '本文介绍了数字证书和 Istio 中的证书管理方式。', '\n我在[如何理解 Istio 中的 mTLS 流量加密](\/blog\/understanding-the-tls-encryption-in-istio\/)这篇文章中提出流量加密的关键是证书管理。我们可以使用 Istio 中内置了 CA（证书授权机构）也可以使用自定义 CA 来管理网格内的证书。这篇博客将为你讲解 Istio 是如何进行证书管理的。\n\n## 什么是证书？ {#certificates-introduction}\n\n在介绍 Istio 的证书管理方式之前，我们先来了解一下什么是证书。若你已了解证书的作用及原理，请直接跳到 Istio 中的证书管理部分。\n\n证书（Certificate），又称电子证书，是用于身份认证和加密通信的一种数字证明文件。在了解 Istio 的证书管理之前，我们先来了解一下什么是证书。如果你已经了解了证书，可以跳过这一节。\n\n证书有很多类别，本文中的证书特指的是 [X.509 V3 证书](https:\/\/datatracker.ietf.org\/doc\/html\/rfc5280)。X509 证书是一种常见的数字证书格式，用于在计算机网络中识别实体的身份。X509 是公钥基础设施（PKI）的国际标准，主要用于身份认证和信息加密，例如 TLS。X.509 证书中包含了个人、组织或计算机的身份信息和公钥。V3 是它的最新版本。它主要用于在客户端和服务器之间进行安全通信，例如在通过 HTTPS 访问网站时。x509 证书通常由 CA 颁发，该 CA 会验证实体的身份，并将这些信息编码到证书中。当客户端连接到服务器时，服务器会向客户端提供其 x509 证书，客户端会验证证书的有效性，并通过该证书来识别服务器的身份。通过这种方式，双方可以安全地进行通信，并确保数据传输的完整性和保密性。\n\n### 哈希函数 {#hash}\n\n谈到证书就不得不提哈希（Hash）函数，因为证书的内容会使用哈希函数进行哈希处理，然后用证书颁发者的私钥进行签名。这样，当收到一份证书时，接收者就可以使用证书颁发者的公钥来验证证书的合法性。\n\n哈希函数是一种将任意长度的输入（也称为消息）映射为固定长度的输出的函数。这个输出也称为哈希值或消息摘要。\n\n哈希函数有许多用途，其中一个重要的用途是密码存储。当用户在系统中设置密码时，通常不会将真实的密码直接存储在系统中。相反，会将密码进行哈希处理，并将哈希值存储在系统中。当用户登录时，系统会将用户输入的密码进行哈希处理，然后与存储的哈希值进行比较。如果两者相同，则证明用户输入的密码正确，反之则错误。\n\n哈希函数有很多种类型，例如 MD5、SHA-1 等。这些函数都有一些共同的特点，比如输出固定长度、不可逆、散列冲突少等。\n\n哈希函数的安全性与其输出的长度有关。一般来说，输出长度越长，哈希函数就越安全。但是，输出长度越长，哈希处理的时间就越长，因此要在安全性和效率之间进行平衡。\n\n### 证书的作用 {#cert-works}\n\n证书的用途广泛，凡是需要加密、认证、授权的场景都会用到它，比如：\n\n- 在 Kubernetes 中你需要给各个组件配置证书，你可以选择[手动生成证书](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)；\n- Istio 中为实现自动 mTLS 给各个工作负载颁发的证书；\n- 访问 HTTPS 网站所用到的证书等；\n\n证书就像是由权威机构印发的名片，供使用者表明其身份，同时还可以为信息加密，保证通信的安全性和完整性。下图展示的是 TLS 通信的大概步骤，其中证书承担了证明服务器身份和加密通信的职责。\n\n下面以一个网站的 HTTP 链接为例，颁发数字证书、验证和加密通信的过程如下图所示。\n\n![TLS 证书颁发和校验过程](tls.svg)\n\n详细步骤如下：\n\n1. 服务器（网站所有者）向 CA 提交证书签名请求；\n2. CA  验证服务器的身份和网站的真实性后为服务器颁发数字证书，服务器安装该证书，以便访问者能够验证网站的安全性；\n3. 用户通过浏览器（客户端）向网站发送请求；\n4. 服务器向客户端返回 TLS 证书；\n5. 客户端向 CA 验证证书的有效性，若有效则建立连接，若无效则提示用户拒绝连接；\n6. 客户端生成一对随机的公钥和私钥；\n7. 客户端将并将自己的公钥发送给服务端；\n8. 服务端使用客户端的公钥加密消息；\n9. 服务端将加密后的数据发送给客户端；\n10. 客户端使用自己的私钥解密服务端发送的数据；\n\n至此，双方建立了一个安全的通道，并可以通过该通道进行双向加密的数据传输。\n\n### 如何生成证书？{#how-to-generate-certificates}\n\n你可以通过以下开源工具生成 X.509 证书：\n\n- [Easy-RSA](https:\/\/github.com\/OpenVPN\/easy-rsa)：一个简单地命令行工具，由 OpenVPN 项目组维护，使用 EasyRSA 可以轻松地为 OpenVPN 网络生成安全的证书和密钥；\n- [OpenSSL](https:\/\/github.com\/openssl\/openssl)：由个人发起于 1995 年，现由独立组织维护，只提供命令行工具；\n- [CFSSL](https:\/\/github.com\/cloudflare\/cfssl)：由 CloudFlare 开发和维护，不仅仅是一个用于生成证书的命令行工具，还可以作为 PKI 服务器；\n- [BoringSSL](https:\/\/github.com\/google\/boringssl)：Google 开发和维护的 OpenSSL 分支，已用于 Chrome 浏览器和安卓操作系统；\n\n因为可能大多数人都对 OpenSSL 比较熟悉，所以下文中我们将使用 OpenSSL 来创建证书。\n\n### 证书的组成 {#cert-component}\n\n下面以 X.509 V3 证书为例，讲解数字证书的组成。下面是该证书的一个示例：\n\n\u0060\u0060\u0060\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            fc:c6:18:2e:20:bd:27:b5:6b:60:bc:47:23:6b:8b:d9\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: O=cluster.local\n        Validity\n            Not Before: Dec 15 07:25:32 2022 GMT\n            Not After : Dec 16 07:27:32 2022 GMT\n        Subject:\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (2048 bit)\n                Modulus:\n                    00:eb:40:16:87:6c:17:5a:9c:b2:91:00:94:d1:31:\n                    37:bb:d7:1e:e6:06:1c:a1:c1:35:64:54:82:54:af:\n                    b8:4b:40:6f:e0:73:86:4e:c1:c6:75:b8:c8:30:ac:\n                    69:16:e8:68:25:cb:dd:e8:53:55:ec:7a:bd:a9:d3:\n                    42:44:7f:e5:f5:52:dd:99:ae:c2:1a:a2:06:1f:be:\n                    1b:e6:3e:69:87:a3:fc:91:21:39:b0:a7:67:11:f2:\n                    3c:55:c6:4b:04:15:1b:ff:49:14:88:c4:58:87:79:\n                    96:5b:6e:00:1c:c1:e7:2c:53:0c:d1:77:dc:a8:82:\n                    cc:fa:26:c1:bb:6c:df:a8:43:0c:b7:cc:f0:a2:11:\n                    9b:e8:3f:8a:1d:ed:2a:ff:1f:d1:03:eb:8a:b9:98:\n                    40:18:83:24:4f:14:95:a3:59:ef:67:0f:35:6d:ae:\n                    91:81:b2:04:02:16:80:d1:39:bd:70:cf:0f:cb:9a:\n                    81:39:d9:fe:52:a5:cf:79:4f:a3:69:d8:0d:39:6a:\n                    48:24:8d:2b:88:04:fa:81:de:65:50:7d:1a:3d:cd:\n                    f3:1c:42:63:29:75:a0:9b:8e:16:44:3a:89:d6:2b:\n                    41:76:65:a5:2e:c8:b6:d2:89:42:5d:21:24:33:30:\n                    f0:9d:0b:4d:cf:78:d5:45:2d:49:5a:55:50:98:93:\n                    03:f5\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Key Usage: critical\n                Digital Signature, Key Encipherment\n            X509v3 Extended Key Usage:\n                TLS Web Server Authentication, TLS Web Client Authentication\n            X509v3 Basic Constraints: critical\n                CA:FALSE\n            X509v3 Authority Key Identifier:\n                keyid:BA:31:8A:9C:ED:EB:49:D2:54:09:98:D9:4C:3A:9C:42:D0:64:8D:B2\n\n            X509v3 Subject Alternative Name: critical\n                URI:spiffe:\/\/cluster.local\/ns\/default\/sa\/httpbin\n    Signature Algorithm: sha256WithRSAEncryption\n         90:7f:cb:6f:0b:16:cb:59:7d:f4:87:a7:5a:38:fa:0a:16:d8:\n         83:0d:b1:36:77:a2:4a:fe:38:52:ab:49:e9:89:50:1a:4c:e9:\n         94:07:37:7f:27:bc:2c:ce:c1:d2:33:75:5d:b6:ab:ae:cb:2e:\n         71:f4:22:c0:40:15:27:02:75:c1:32:2e:83:49:73:6c:9a:ea:\n         04:ef:55:2d:8d:71:30:9b:e4:30:dd:95:20:0d:7c:d2:f4:30:\n         2f:07:2e:9f:53:37:e6:3d:14:c7:41:f4:09:8b:a3:76:56:c7:\n         c7:92:0f:fc:17:5a:5a:32:6c:9e:87:18:2e:51:75:54:68:d8:\n         01:c1:07:cc:b0:35:bf:0b:6c:62:a6:5b:23:61:35:c8:4f:7f:\n         e7:1f:a0:e9:11:44:a6:17:52:4d:00:40:21:de:63:ee:02:c8:\n         2b:5d:a1:7a:5d:7f:d5:d3:c1:7d:5f:00:40:e8:80:8d:cc:e9:\n         8a:c6:b4:98:fe:7a:7d:37:0c:6f:4c:31:91:7a:79:30:84:cd:\n         01:a7:14:f6:1b:33:8f:0f:50:1c:36:38:6b:24:da:cf:49:8a:\n         5b:28:cf:27:76:e1:a5:c7:e6:d5:6e:d8:36:85:aa:1f:a5:ac:\n         fa:f1:2e:a2:36:2e:25:b0:71:24:d1:3e:d5:e5:19:2b:0b:6f:\n         b7:17:e4:75\n\u0060\u0060\u0060\n\n证书中各个字段的含义如下：\n\n- 证书版本（Version）：表示证书的版本号。\n- 序列号（Serial Number）：表示证书的唯一序列号。\n- 签名算法（Signature Algorithm）：表示证书的签名算法，例如 RSA、DSA 或 ECDSA 等。\n- 证书颁发机构（Issuer）：表示颁发该证书的可信的第三方机构的名称。\n- 有效期（Validity）：表示证书的有效期，包括证书生效日期（Not Before）和证书失效日期（Not After）。\n- 使用者（Subject）：表示证书所有者的名称。\n- 公钥信息（Subject Public Key Info）：表示证书所有者的公钥以及公钥的算法。\n- 扩展（Extensions）：表示证书的扩展信息，包括：\n  - 密钥用法扩展（Key Usage Extension）：表示证书所有者的密钥可用于哪些操作，例如数字签名、密钥加密等。\n  - 扩展密钥用法扩展（Extended Key Usage Extension）：表示证书所有者的密钥可用于哪些扩展的操作，例如 TLS Web Server Authentication、TLS Web Client Authentication 等。\n  - 基本约束扩展（Basic Constraints Extension）：表示证书所有者是否是证书颁发机构的下级机构，以及是否允许其作为证书颁发机构颁发其他证书。\n  - 主体密钥表示扩展（Authority Key Identifier）：包含一个或多个唯一的标识符，用于表示证书颁发机构的密钥。这些标识符可以是证书颁发机构的公钥哈希值，也可以是证书颁发机构的证书序列号。该扩展用于验证证书的合法性，例如在验证证书链时，用于验证证书颁发机构是否为可信的机构。这个扩展字段是可选的，但在许多情况下都会被使用。\n  - 主体替代名称扩展（Subject Alternative Name Extension）：表示证书所有者的其他名称，例如域名、IP 地址、电子邮件地址等。\n\n### 证书信任链 {#certificate-trust-chain}\n\n证书的验证需要通过证书信任链（Certificate Trust Chain）。证书信任链是指用于身份验证的一系列证书，它们形成一条从一个可信任的根证书颁发机构开始，逐级向下连接，直到用于验证某个特定证书的中间证书或终端证书的一种方式。证书信任链允许数字证书的可信度随着证书级别的升高而提高。\n\n在下面的证书信任链示意图中，你可以看到四条信任链。\n\n![证书信任链](certificate-trust-chain.svg)\n\n证书的信任链是一个树形结构，每个 CA 都可以有一或多个子 CA，一共有三种角色：\n\n- 根 CA：最顶层的 CA，可以颁发证书给中间 CA；\n- 中间 CA：除根 CA 以外的 CA，可颁发终端证书；\n- 终端实体：拥有终端证书的设备或服务；\n\n根 CA 是数字证书的最顶级颁发机构，因此它所颁发的证书是最可信的。根证书颁发机构通常由政府机构或其他权威机构（如国际基础设施安全组织）经营和监管。常见的根 CA 包括：\n\n- Symantec\/VeriSign\n- Comodo\n- DigiCert\n- GlobalSign\n- GoDaddy\n- Entrust\n- GeoTrust\n- RapidSSL\n- Baltimore CyberTrust Root\n\n请注意，上述列表只是一个样例，实际上有许多其他根 CA。\n\n在 Chrome 浏览器中打开一个 HTTPS 网页，你可以通过点击地址栏左侧的锁图标查看证书信息，其中包括证书信任链，例如 [https:\/\/tetrate.io](https:\/\/tetrate.io) 的证书信任链如下图：\n\n![Tetrate.io 的证书信任链](tetrate-cert.jpg)\n\n证书信任链允许客户端（例如，Web 浏览器）在验证终端证书时，逐级向上验证每个证书，以确定它是否可信。数字证书签发的原理是 CA 将证书拥有者的公钥与身份信息绑定在一起，然后 CA 使用其专有的私钥生成正式的数字签名，用以表示这个证书是经 CA 签发的。在证书校验时使用 CA 的公钥对这个证书上的数字签字进行验证即可。\n\n## 将 Istio 纳入 PKI 证书信任链 {#istio-pki}\n\n在使用 Istio 之前，企业通常有自己的内部 PKI（公钥基础设施），那么如何将 Istio 纳入到 PKI 的证书信任链中呢？\n\n我们知道 Istio 内置了证书管理功能，可以开箱即用，Istio 启动时会为 *istiod* 创建自签名证书，作为网格内所有工作负载的根证书。这样做有个问题，如果你有多网格，内置的根证书无法做到网格间互信。正确的做法是不使用 Istio 自签名证书，而是将 Istio 纳入到你的证书信任链中，将 Istio 集成到你的 PKI，为 PKI 每个网格创建一个中间证书，这样两个网格拥有了共同的信任根，就可以做到网格间互信。\n\n通过为 Istio 网格创建中间 CA 使其纳入到企业内部 PKI 证书信任链中，如下图所示。\n\n![为多网格创建中间 CA 使得 Istio 纳入到企业内部 PKI 证书信任链](cluster-ca.svg)\n\n将 Istio 纳入企业内部 PKI 证书信任链后有诸多好处：\n\n- 可以实现跨网格\/集群之间的通信：有了共同的信任根，集群之间就可以互相验证身份，进而实现跨集群通信；\n- 更细粒度的证书撤销：你可以撤销某个实体或中间 CA 的证书来撤销某个服务或集群的证书；\n- 轻松实现证书轮换：你可以按集群\/网格实现证书轮换，而不是轮换根节点证书，这样会减少停机时间，推荐您使用 [cert-manager](https:\/\/github.com\/cert-manager\/cert-manager) 来实现自动化的大规模 CA 证书轮换，详情请参考[在生产中大规模自动化 Istio CA 轮换](https:\/\/cloudnative.to\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)；\n\n关于将 Istio 纳入企业内部 PKI 的证书信任链的详细说明请参考[这篇博客](https:\/\/cloudnative.to\/blog\/istio-trust\/)。\n\n## Istio 中使用自定义 CA 的步骤 {#istio-custom-ca}\n\n默认情况下，Istio CA 会生成一个自签名的根证书和密钥，并使用它们来签署工作负载证书。为了保护根 CA 密钥，你应该使用在安全机器上离线运行的根 CA，并使用根 CA 向运行在每个集群上的 Istio CA 签发中间证书。Istio CA 可以使用管理员指定的证书和密钥来签署工作负载证书，并将管理员指定的根证书作为信任根分配给工作负载。\n\n下图展示了 Istio 中的证书签发和挂载过程。\n\n![Istio 中的证书签发和挂载过程](cert-process.svg)\n\n1. Istio 向 Pod 中注入的 Envoy 代理中有两个进程——\u0060envoy\u0060 和 \u0060pilot-agent\u0060。\u0060pilot-agent\u0060 为 Envoy 生成私钥，通过 UNIX Domain Socekt（UDS）使用 Secret Discovery Service（SDS）向 CA 发起证书签名请求（CSR），如果你没有配置 CA 插件的话，Istio 默认向 *istiod* 发起 CSR；\n2. \u0060istiod\u0060 内置 CA 向 \u0060pilot-agent\u0060 返回证书；\n3. \u0060pilot-agent\u0060 将生成的私钥和 CA 返回的证书发送给 \u0060envoy\u0060 挂载；\n\nIstio 默认使用内置于 *istiod* 中的 CA，也支持插入其他 CA，见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)。若想使用自定义的 CA 证书和密钥为服务创建身份，你需要：\n\n- 创建 CA 配置文件并使用它来创建自签名的 CA 根证书和密钥；\n- 为服务创建私钥、签名请求配置文件；\n- 为服务创建证书签名请求（CSR）；\n- 使用根证书和密钥以及服务的签名请求文件为服务创建证书；\n\n接下来，我们将以为 Bookinfo 的 productpage 服务创建和挂载证书为例详述 Istio 内置 CA 签发证书的流程。\n\n## Istio 内置 CA 签发证书流程  {#istio-ca}\n\nIstio 启动时将创建一个自签名的 CA 证书，然后再用该 CA 证书为网格内的服务颁发证书。下面我们手动模拟 Istio 内置 CA 签发证书的步骤：\n\n1. 创建 CA 私钥 \u0060ca.key\u0060；\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out ca.key\n   \u0060\u0060\u0060\n\n2. 创建 CA 配置文件 \u0060ca.conf\u0060：\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = req_dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = Root CA\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n3. 使用 CA 私钥 \u0060ca.key\u0060 生成自签名证书 \u0060ca.pem\u0060，其中主题中包含 CA 的信息：\n\n   \u0060\u0060\u0060bash\n   openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.pem -config ca.conf\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022关于 PEM 文件\u0022\u003e}}\n\n   PEM 文件是一种用于存储证书、公钥或私钥的文件。它采用 Base64 编码的 ASCII 格式，并使用特定的文件扩展名，例如 \u0060.pem\u0060、\u0060.crt\u0060、\u0060.cer\u0060 或 \u0060.key\u0060。PEM 文件通常用于存储加密密钥、数字证书和公钥基础设施（PKI）证书。\n\n   PEM 文件的内容通常以一组特定的标头和脚本开始，例如 \u0060-----BEGIN RSA PRIVATE KEY-----\u0060 和 \u0060-----END RSA PRIVATE KEY-----\u0060。这些标头和脚本指定了文件的类型和数据的开始和结束位置。\n\n   PEM 文件可以通过文本编辑器直接打开，但并不可读，因为它是由二进制编码格式 DER（可分辨编码规则）转化而来，要想解析它需要使用特别的工具，例如 OpenSSL。\n\n   {{\u003c\/callout\u003e}}\n\n4. 为工作负载创建私钥 \u0060workload.key\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out workload.key\n   \u0060\u0060\u0060\n\n5. 创建证书签名请求配置文件 \u0060csr.conf\u0060，其中包含 CA 的地址及附加信息；\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = productpage\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n6. 基于工作负载的 CSR 配置文件 \u0060csr.conf\u0060 和工作负载的私钥文件 \u0060workload.key\u0060 创建证书签名请求 \u0060workload.csr\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl req -new -key workload.key -out workload.csr -config csr.conf\n   \u0060\u0060\u0060\n\n7. 基于 CA 的私钥 \u0060ca.key\u0060、CA 的证书 \u0060ca.pem\u0060 和工作负载的证书签名请求创建服务器证书 \u0060workload.pem\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -req -in workload.csr -CA ca.pem -CAkey ca.key \\\n       -CAcreateserial -out workload.pem -days 365 \\\n       -extensions req_ext -extfile csr.conf -sha256\n   \u0060\u0060\u0060\n\n   Istiod 在收到工作负载的 CSR 后将根证书 \u0060ca.pem\u0060 和服务证书下发给工作负载；\n\n8. 查看工作负载中 Envoy 代理挂载的证书链：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n   \u0060\u0060\u0060\n\n   \u0060chain.pem\u0060 文件中保存着 \u0060productpage\u0060 服务的证书链，因为我们使用的 Istio 内置 CA 作为根 CA，所以该文件中只保存有一个证书，可以运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in chain.pem\n   \u0060\u0060\u0060\n\n9. 查看 Envoy 代理挂载的根证书：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n   \u0060\u0060\u0060\n\n   \u0060root.pem\u0060 即为根证书，运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in root.pem\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022提示\u0022\u003e}}\n\n   \u0060root.pem\u0060 中的内容与 \u0060istiod-ca-cert\u0060 ConfigMap 中的 \u0060root-cert.pem\u0060 及 \u0060istio-ca-secret\u0060 中的 \u0060ca-cert.pem\u0060 是一样的，虽然现在 Envoy 已不在通过读取挂载卷来获得证书内容，但之所以保留了这些卷是为了向后兼容。\n\n   {{\u003c\/callout\u003e}}\n\n   证书挂载到 Envoy 代理之后，*istiod* 将负责定期替换密钥证书，以及根据需要撤销密钥证书。\n\n## 总结 {#summary}\n\n本文向你介绍了数字证书的作用、组成和证书信任链，以及 Istio 中内置的开箱即用的证书管理器运作的流程。但是 Istio 内置 CA 仍然有一定限制，在下一篇博客中我将向你介绍如何使用插件 SPIRE 和 cert-manager 来实现细粒度的证书管理和自动证书轮换。\n\n## 参考 {#reference}\n\n- [插入 CA 证书 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)\n- [如何设置 SSL 证书 - istio.tetratelabs.io](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)\n- [管理集群中的 TLS 认证 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/tls\/managing-tls-in-a-cluster\/)\n- [手动生成证书 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - jimmysong.io](https:\/\/cloudnative.to\/blog\/istio-trust\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - jimmysong.io](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n', '\/blog\/istio-certificates-management\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了数字证书和 Istio 中的证书管理方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/">[译] 如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书', '本文将指导你使用 Vault 存储 Istio 的证书。', '\n在本文中，我们将探讨如何使用 Hashicorp Vault 作为一种比使用 Kubernetes [Secret](https:\/\/kubernetes.io\/docs\/concepts\/configuration\/secret) 更安全的方式来存储 Istio 证书。默认情况下，Secret 使用 base64 编码存储在 *etcd* 中。在安全策略严格的环境中，这可能是不可接受的，因此需要额外的措施来保护它们。一种此类解决方案涉及将机密存储在外部机密存储提供程序中，例如 [HashiCorp Vault](https:\/\/www.vaultproject.io\/)。\n\nVault 可以托管在 Kubernetes 集群内部和外部。在本案例中，我们将探索使用托管在 Kubernetes 外部的 Vault，以便它可以同时为多个集群提供秘密。该设置也非常适合探索 Istio 的[多集群功能](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster)，它需要一个共享的信任域。\n\n利用 \u0060vault-agent-init\u0060 容器，我们可以将证书和私钥材料注入实际的 Istio 控制平面 Pod，以便它们使用外部 CA 证书进行引导。这避免了依赖 Secret 来引导 Istio 控制平面。该技术也完全适用于入口和出口证书。\n\n有关如何在 Istio 中使用和管理证书的更多信息，请参见官方文档：\n\n- [身份和证书管理](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/#pki)\n- [插入 CA 证书](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert)\n- [使用 Kubernetes CSR 的自定义 CA 集成](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/custom-ca-k8s)\n\n有关基于实际生产经验的最佳实践，另请查看以下 [Tetrate](https:\/\/tetrate.io\/) 的博客文章：\n\n- [在 Istio 中构建证书信任链：将现有 PKI 作为信任根](\/trans\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换](\/trans\/automate-istio-ca-rotation-in-production-at-scale)\n\n这篇博文附带的代码可以在以下存储库中找到：\n\nhttps:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\n\n## **Istiod 证书处理**\n\n尽管上述博文中解释了一些决策逻辑，但也值得参考[源代码](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/pkg\/bootstrap\/istio_ca.go)以查找一些未记录的行为。\n\n在 Istio 的源码 \u0060istio\/pilot\/pkg\/bootstrap\/istio_ca.go\u0060 文件中，你将看到：为了向后兼容，Istio 保留了对用于自签名证书 \u0060cacerts\u0060 Secret 的支持。它安装在相同的位置，如果发现了就会被使用——创建秘密就足够了，不需要额外的选项。在旧安装程序中，\u0060LocalCertDir\u0060 被硬编码到 \u0060\/etc\/cacerts\u0060 并使用 \u0060cacerts\u0060  Secret 安装。已删除对签署其他根 CA 的支持——太危险，没有明确的用例。\n\n默认配置，用于向后兼容 Citadel：\n\n- 如果 \u0060istio-system\u0060 中存在 \u0060cacerts\u0060 秘密，将被挂载。它可能包含一个可选的 \u0060root-cert.pem\u0060，\n带有额外的根和可选的 \u0060{ca-key, ca-cert, cert-chain}.pem\u0060 由用户提供的根 CA。\n- 如果未找到用户提供的根 CA，则使用 \u0060istio-ca-secret\u0060 Secret，以及 \u0060ca-cert.pem\u0060 和 \u0060ca-key.pem\u0060 文件。\n- 如果两者均未找到，将创建 \u0060istio-ca-secret\u0060。\n- 带有 \u0060caTLSRootCert\u0060 文件的 \u0060istio-security\u0060 ConfigMap 将用于根证书，并在需要时创建。该 ConfigMap 由节点代理使用，不再可能在 sds-agent 中使用，但我们仍保留它以向后兼容。将与 node-agent 一起删除。sds-agent 使用 K8S root 直接调用 \u0060NewCitadelClient\u0060 。\n\n为了指示 Istio 从其他地方获取证书，而不是标准 Kubernetes Secret，我们将利用 *istio-pilot*（又名 istiod 或 Istio 控制平面）的环境变量（[见此文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-discovery)），从 Kubernetes Pod 中的另一个位置获取证书。这是必需的，因为 \u0060vault-agent-init\u0060 注入容器将创建一个新的挂载卷 \u0060\/vault\/secrets\u0060 ，以放置从外部 Vault 服务器拉出的证书和私钥。\n\n| 变量名称      | 类型   | 默认值         | 描述                         |\n| ------------- | ------ | -------------- | ---------------------------- |\n| \u0060ROOT_CA_DIR\u0060 | 字符串 | \u0060\/etc\/cacerts\u0060 | 本地或安装的 CA 根目录的位置 |\n\n## Pod 内的 \u0060vault-agent-init\u0060 容器注解\n\n我们将利用 Vault 注入器注解来指示 Sidecar 提取哪些数据以及在这样做时使用什么 Vault 角色。我们还确保容器在我们实际的主容器之前运行，因此后者可以获取证书和密钥材料以正确引导自身。[此处](https:\/\/developer.hashicorp.com\/vault\/docs\/platform\/k8s\/injector\/annotations)列举并记录了 Vault 注解。我们将在本教程中使用的相关注释如下：\n\n| **注解**                                     | **默认值** | **描述**                                                     |\n| -------------------------------------------- | ---------- | ------------------------------------------------------------ |\n| \u0060vault.hashicorp.com\/agent-inject\u0060           | false      | 配置是否为 Pod 显式启用或禁用注入。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/agent-init-first\u0060       | false      | 如果为 true，则将 Pod 配置为首先运行 Vault Agent init 容器（如果为 false，则最后运行）。当其他 init 容器需要预填充的秘密时，这很有用。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/role\u0060                   | –          | 配置 Vault 代理自动验证方法使用的 Vault 角色。\u0060vault.hashicorp.com\/agent-configmap\u0060 未设置时需要。 |\n| \u0060vault.hashicorp.com\/auth-path\u0060              | –          | 配置 Kubernetes 身份验证方法的身份验证路径。默认为 \u0060auth\/kubernetes\u0060。 |\n| \u0060vault.hashicorp.com\/agent-inject-secret-\u0060   | –          | 配置 Vault 代理以从容器所需的 Vault 中检索秘密。Secret 的名称是 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 之后的任意唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-secret-foobar\u0060 该值是 secret 所在的 Vault 中的路径。 |\n| \u0060vault.hashicorp.com\/agent-inject-template-\u0060 | –          | 配置 Vault Agent 应该用于呈现秘密的模板。模板的名称是 v\u0060ault.hashicorp.com\/agent-inject-template-\u0060 之后的任何唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-template-foobar\u0060。这应该映射到 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 中提供的相同唯一值。如果未提供，则使用默认的通用模板。 |\n\n## Vault 服务器注意事项 {#vault-server-considerations}\n\nVault 支持多种客户端验证自己的方法。我们将利用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)，这意味着我们将利用 Kubernetes ServiceAccount JWT 令牌验证。请注意，自 Kubernetes 1.24 以来，不再自动生成 ServiceAccount 令牌。您仍然可以手动创建这些 API 令牌，如[此处所述](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-service-account\/#manually-create-an-api-token-for-a-serviceaccount)。\n\n至于证书和私钥材料的存储，我们有两种选择：\n\n- [PKI 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/pki)\n- [KV 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/kv)\n\n因为 PKI 秘密引擎不提供精简的 API 来检索我们需要的证书和私钥，并且因为 PKI 秘密引擎会为每次调用（例如，每次 *istiod* 重启）生成一个新的中间证书，我们将使用通用的 KV 秘密引擎，将我们需要的所有值存储在一个简单的键值数据结构中。我们假设中间证书的更新是通过一些服务门户或 CI\/CD 过程在外部处理的，这些过程也将更新的中间证书存储在 Vault 服务器中。\n\nIstio 的控制平面 Pod 需要以下文件才能在 CA 中正确引导其构建：\n\n| Key            | 值（PEM 编码） | 细节                                    |\n| -------------- | -------------- | --------------------------------------- |\n| ca-key.pem     | 私钥           | 中间证书的私钥，用作 *istiod* 的根 CA。 |\n| ca-cert.pem    | CA 公共证书    | 中间证书，用作 *istiod* 的根 CA。       |\n| root-cert.pem  | CA 根证书      | 我们新生成的中间证书的信任根。          |\n| cert-chain.pem | 完整的证书链   | 中间证书在顶部，根证书在底部。          |\n\n## 设置\n\n如果要遵循本地设置，则安装软件的先决条件包括：\n\n- *kubectl* 与 Kubernetes 集群交互（[下载](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)）\n- *helm* 安装 Vault injector 和 Istio chart（[下载](https:\/\/helm.sh\/docs\/intro\/install)）\n- 用于配置 Vault 服务器的 *vault cli* 工具（[下载](https:\/\/developer.hashicorp.com\/vault\/tutorials\/getting-started\/getting-started-install#install-vault)）\n\n如果您想要本地演示环境，请按照[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/local-setup.md)的说明进行操作，该说明使用 \u0060docker-compose\u0060 启动一个 Vault 服务器和两个独立的 k3s 集群。如果您使用自己的 Kubernetes 集群和外部托管的 Vault 实例，请跳至下一节。\n\n- *docker-compose* 启动本地环境（[下载](https:\/\/github.com\/docker\/compose\/releases)）\n\n为了取得进展，我们希望根据您的环境设置以下 shell 变量。\n\n\u0060\u0060\u0060bash\nexport VAULT_SERVER=\nexport K8S_API_SERVER_1=\nexport K8S_API_SERVER_2=\n\u0060\u0060\u0060\n\n## **Vault Kubernetes 身份验证后端**\n\n正如在有关 [Vault 服务器注意事项](#vault-server-considerations)的介绍部分中提到的，我们将使用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)。由于 *istiod* 将从 Vault 服务器获取证书和私钥材料，让我们从在两个集群中创建相应的服务账户开始。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml create ns istio-system\nkubectl --kubeconfig kubecfg2.yml create ns istio-system\nkubectl --kubeconfig kubecfg1.yml apply -f istio-sa.yml\nkubectl --kubeconfig kubecfg2.yml apply -f istio-sa.yml\n\u0060\u0060\u0060\n\nServiceAccount、Secret 和 ClusterRoleBinding 如下：\n\n\u0060\u0060\u0060yaml\n# istio-sa.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: istiod\n  namespace: istio-system\n  labels: # added for istio helm installation\n    app: istiod\n    app.kubernetes.io\/managed-by: Helm\n    release: istio-istiod\n  annotations: # added for istio helm installation\n    meta.helm.sh\/release-name: istio-istiod\n    meta.helm.sh\/release-namespace: istio-system\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: istiod\n  namespace: istio-system\n  annotations:\n    kubernetes.io\/service-account.name: istiod\ntype: kubernetes.io\/service-account-token\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: role-tokenreview-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:auth-delegator\nsubjects:\n  - kind: ServiceAccount\n    name: istiod\n    namespace: istio-system\n\u0060\u0060\u0060\n\n\u003e 注意：*我们在 istiod ServiceAccount 上添加了 Helm 标签和注解，以免与稍后的 Istio Helm 部署发生冲突。*\n\n在两个集群中创建 ServiceAccount 后，让我们将它们的 Secret 令牌和 ca.cert 值存储在 output 文件夹中：\n\n\u0060\u0060\u0060bash\nmkdir -p .\/output\nkubectl --kubeconfig kubecfg1.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod1.jwt\nkubectl --kubeconfig kubecfg1.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert1.pem\nkubectl --kubeconfig kubecfg2.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod2.jwt\nkubectl --kubeconfig kubecfg2.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert2.pem\n\u0060\u0060\u0060\n\n关于 Kubernetes API 证书和 istiod ServiceAccount JWT 令牌的详细内容的更多信息可以在[这里](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/output)找到，在这里我们也更深入地描述了 Vault 的交互过程，即通过 REST API 调用来验证和获取秘密。在调试权限拒绝的问题时，这些可以派上用场。\n\n让我们根据刚刚检索到的 Kubernetes CA 证书和 JWT 令牌创建必要的 Vault 身份验证配置：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault auth enable --path=kubernetes-cluster1 kubernetes\nvault auth enable --path=kubernetes-cluster2 kubernetes\nvault write auth\/kubernetes-cluster1\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_1\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert1.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod1.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\nvault write auth\/kubernetes-cluster2\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_2\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert2.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod2.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\n\u0060\u0060\u0060\n\n\u003e 注意：如果您使用的是 *docker-compose* 提供的环境，则 \u0060VAULT_ADDR\u0060 设置为 localhost。\n\n## *Vault kv* Secret 中的 Istio 证书和私钥\n\n接下来我们将创建一个新的自签名根证书并为我们的两个集群生成中间证书。我们将在[这里](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/certs)使用上游 Istio 提供的辅助 *Makefile* 脚本：\n\n\u0060\u0060\u0060bash\ncd certs\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk root-ca\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster1-cacerts\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster2-cacerts\ncd ..\n\u0060\u0060\u0060\n\n有关实际内容和正在设置的 X509v3 扩展的更多详细信息，请参见[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs)。您可以通过[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs-gen)的 *Makefile*文档和相应的 *Makefile* 覆盖值微调证书。\n\n让我们将生成的证书和私钥添加到 Vault *kv* secret 中：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault secrets enable -path=kubernetes-cluster1-secrets kv\nvault secrets enable -path=kubernetes-cluster2-secrets kv\nvault kv put kubernetes-cluster1-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster1\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster1\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster1\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster1\/root-cert.pem\nvault kv put kubernetes-cluster2-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster2\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster2\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster2\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster2\/root-cert.pem\n\u0060\u0060\u0060\n\n通过限制对每个集群的这些证书和私钥的访问，绑定到基于 Kubernetes *istiod* ServiceAccount 的身份验证后端：\n\n\u0060\u0060\u0060bash\necho \u0027path \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster1 -\necho \u0027path \u0022kubernetes-cluster2-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster2 -\nvault write auth\/kubernetes-cluster1\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster1 \\\n  ttl=24h\nvault write auth\/kubernetes-cluster2\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster2  \\\n  ttl=24h\n\u0060\u0060\u0060\n\n## 部署 *vault-inject* 和 Istio Helm Charts\n\n为了部署 Vault 注入器，我们将利用官方 Vault [Helm chart](https:\/\/github.com\/hashicorp\/vault-helm)。\n\n\u0060\u0060\u0060bash\nhelm repo add hashicorp https:\/\/helm.releases.hashicorp.com\nhelm repo update\nkubectl --kubeconfig kubecfg1.yml create ns vault\nkubectl --kubeconfig kubecfg2.yml create ns vault\nhelm --kubeconfig kubecfg1.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nhelm --kubeconfig kubecfg2.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nkubectl --kubeconfig kubecfg1.yml -n vault get pods\nkubectl --kubeconfig kubecfg2.yml -n vault get pods\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vt9w   1\/1     Running   0          92s\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vjnx   1\/1     Running   0          91s\n\u0060\u0060\u0060\n\n要安装 Istio，我们将使用 Tetrate Istio Distro [Helm chart](https:\/\/github.com\/tetratelabs\/helm-charts)。\n\n\u0060\u0060\u0060bash\nhelm repo add tetratelabs https:\/\/tetratelabs.github.io\/helm-charts\nhelm repo update\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster1-values.yaml\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster2-values.yaml\nkubectl --kubeconfig kubecfg1.yml -n istio-system get pods\nkubectl --kubeconfig kubecfg2.yml -n istio-system get pods\n\u0060\u0060\u0060\n\n请注意我们如何利用多个 Istio Helm chart 值覆盖来我们预期的目标：\n\n- 注入一个 pilot Pod 环境变量 \u0060ROOT_CA_DIR\u0060 来告诉 *istiod* 从哪里获取证书和私钥\n- 告诉 \u0060vault-agent-init\u0060 容器在 *istiod* 容器之前运行，因此秘密安装在 \u0060\/vault\/secrets\u0060 的卷中可用\n- 指示 Vault 注入器从正确的位置和数据密钥获取机密\n- 这样做时承担 Vault *istiod* 角色\n- 覆盖默认的 Kubernetes auth-path，因为我们有多个集群 \n\n\u0060\u0060\u0060yaml\npilot:\n  env:\n    ROOT_CA_DIR: \/vault\/secrets\n  podAnnotations:\n    vault.hashicorp.com\/agent-inject: \u0022true\u0022\n    vault.hashicorp.com\/agent-init-first: \u0022true\u0022\n    vault.hashicorp.com\/agent-inject-secret-ca-key.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-key.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_key }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-ca-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-root-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-root-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.root_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-cert-chain.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-cert-chain.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.cert_chain }}\n        {{ end -}}\n    vault.hashicorp.com\/role: \u0022istiod\u0022\n    vault.hashicorp.com\/auth-path: \u0022auth\/kubernetes-cluster1\u0022\n\u0060\u0060\u0060\n\n当我们查看 \u0060vault-agent-init\u0060 容器日志时，我们应该看到类似这样的内容。我们的控制平面已经正确地获取了 Vault 注入的秘密。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c vault-agent-init --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n==\u003e Vault agent started! Log data will stream in below:\n\n  ==\u003e Vault agent configuration:\n\n                      Cgo: disabled\n                Log Level: info\n                  Version: Vault v1.12.0, built 2022-10-10T18:14:33Z\n              Version Sha: 558abfa75702b5dab4c98e86b802fb9aef43b0eb\n\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: creating file sink\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: file sink configured: path=\/home\/vault\/.vault-token mode=-rw-r-----\n  2022-11-18T11:01:21.398Z [INFO]  template.server: starting template server\n  2022-11-18T11:01:21.398Z [INFO]  sink.server: starting sink server\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: starting auth handler\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: authenticating\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: authentication successful, sending token to sinks\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: starting renewal process\n  2022-11-18T11:01:21.402Z [INFO]  sink.file: token written: path=\/home\/vault\/.vault-token\n  2022-11-18T11:01:21.402Z [INFO]  sink.server: sink server stopped\n  2022-11-18T11:01:21.402Z [INFO]  sinks finished, exiting\n  2022-11-18T11:01:21.402Z [INFO]  template.server: template server received new token\n  2022-11-18T11:01:21.402Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO] (runner) starting\n  2022-11-18T11:01:21.403Z [INFO]  auth.handler: renewed auth token\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/root-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/cert-chain.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-key.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.516Z [INFO]  template.server: template server stopped\n  2022-11-18T11:01:21.516Z [INFO] (runner) received finish\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: shutdown triggered, stopping lifetime watcher\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: auth handler stopped\n\u0060\u0060\u0060\n\n当我们查看 \u0060discovery\u0060 容器日志时，我们应该看到如下内容：\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c discovery --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n info\tUsing istiod file format for signing ca files\n  info\tUse plugged-in cert at \/vault\/secrets\/ca-key.pem\n  info\tx509 cert - Issuer: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, Subject: \u0022\u0022, SN: 39f67569f10d36a1fc91e9d82156b07d, NotBefore: \u00222022-11-18T11:11:59Z\u0022, NotAfter: \u00222032-11-15T11:13:59Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, SN: dedf298a147681d6, NotBefore: \u00222022-11-17T22:01:54Z\u0022, NotAfter: \u00222024-11-16T22:01:54Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Root CA,O=Istio\u0022, SN: f5bcd7e89bdb6248, NotBefore: \u00222022-11-17T22:01:52Z\u0022, NotAfter: \u00222032-11-14T22:01:52Z\u0022\n  info\tIstiod certificates are reloaded\n  info\tspiffe\tAdded 1 certs to trust domain cluster.local in peer cert verifier\n\u0060\u0060\u0060\n\n我们可以看到我们的 Istio 控制平面已经正确地获取了我们的 Vault 注入证书和私钥。任务完成！\n\n## 结论\n\n在本文中，我们已经使用外部 Vault 存储的证书和私钥成功引导了 Istio 控制平面。实现这一目标的步骤包括：\n\n- 将证书和私钥存储在每个集群专用的 Vault 秘密安装路径中\n- 为每个集群设置 Kubernetes Vault 身份验证后端，链接到正确的 ServiceAccount\n- 定义适当的角色和策略以允许从 *istiod* ServiceAccount 访问 Vault 机密\n- 将 Istio Pilot 引导程序参数调整为：\n  - 注入 *vault-agent-init* sidecar\n  - 获取包含我们的证书和私钥的正确 Vault 机密\n  - 使用正确的角色和身份验证后端来这样做\n  - 从正确的 vault secret 安装路径中获取证书和私钥\n\n我们可以使用完全相同的技术来注入*入口网关*和*出口网关*证书。创建 Istio [Gateway](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings) 对象时，请确保将 *serverCertificate*、*privateKey* 和 *caCertificates* 指向 \u0060\/vault\/secrets\u0060 挂载卷中的正确文件。我们将把它作为练习留给读者。\n\n通过将证书注入绑定到 Kubernetes ServiceAccount，我们现在已将证书生命周期管理委托给外部秘密 Vault 实例。现在可以使用专用角色和写入\/更新策略创建服务门户或 CI\/CD 管道等外部流程，以提供必要的证书生命周期管理安全性。\n', '\/trans\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你使用 Vault 存储 Istio 的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/distributed-tracing-with-skywalking-in-istio/">如何在 Istio 中使用 SkyWalking 进行分布式追踪？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中使用 SkyWalking 进行分布式追踪？', '这篇文章将介绍一些关于分布式追踪的基础知识以及如何在 Istio 中使用分布式追踪。', '\n在云原生应用中，一次请求往往需要经过一系列的 API 或后台服务处理才能完成，这些服务有些是并行的，有些是串行的，而且位于不同的平台或节点。那么如何确定一次调用的经过的服务路径和节点以帮助我们进行问题排查？这时候就需要使用到分布式追踪。\n\n本文将向你介绍：\n\n- 分布式追踪的原理\n- 如何选择分布式追踪软件\n- 在 Istio 中如何使用分布式追踪\n- 以 Bookinfo 和 SkyWalking 为例说明如何查看分布式追踪数据\n\n## 分布式追踪基础 {#tracing-basic}\n\n分布式追踪是一种用来跟踪分布式系统中请求的方法，它可以帮助用户更好地理解、控制和优化分布式系统。分布式追踪中用到了两个概念：TraceID 和 SpanID。\n\n- TraceID 是一个全局唯一的 ID，用来标识一个请求的追踪信息。一个请求的所有追踪信息都属于同一个 TraceID，TraceID 在整个请求的追踪过程中都是不变的；\n\n- SpanID 是一个局部唯一的 ID，用来标识一个请求在某一时刻的追踪信息。一个请求在不同的时间段会产生不同的 SpanID，SpanID 用来区分一个请求在不同时间段的追踪信息；\n\nTraceID 和 SpanID 是分布式追踪的基础，它们为分布式系统中请求的追踪提供了一个统一的标识，方便用户查询、管理和分析请求的追踪信息。\n\n![分布式追踪原理图](basic.svg)\n\n下面是分布式追踪的过程：\n\n1. 当一个系统收到请求后，分布式追踪系统会为该请求分配一个 TraceID，用于串联起整个调用链；\n2. 分布式追踪系统会为该请求在系统内的每一次服务调用生成一个 SpanID 和 ParentID，用于记录调用的父子关系，没有 ParentID 的 Span 将作为调用链的入口；\n3. 每个服务调用过程中都要传递 TraceID 和 SpanID；\n4. 在查看分布式追踪时，通过 TraceID 查询某次请求的全过程；\n\n## Istio 如何实现分布式追踪 {#distributed-tracing-in-istio}\n\nIstio 中的分布式追踪是基于数据平面中的 Envoy 代理实现的。服务请求在被劫持到 Envoy 中后，Envoy 在转发请求时会附加大量 Header，其中与分布式追踪相关的有：\n\n- 作为 TraceID：\u0060x-request-id\u0060\n- 用于在 LightStep 追踪系统中建立 Span 的父子关系：\u0060x-ot-span-context\u0060\n- 用于 Zipkin，同时适用于 Jaeger、SkyWalking，详见 [b3-propagation](https:\/\/github.com\/openzipkin\/b3-propagation)：\n  - \u0060x-b3-traceid\u0060\n  - \u0060x-b3-spanid\u0060\n  - \u0060x-b3-parentspanid\u0060\n  - \u0060x-b3-sampled\u0060\n  - \u0060x-b3-flags\u0060\n  - \u0060b3\u0060\n- 用于 Datadog：\n  - \u0060x-datadog-trace-id\u0060\n  - \u0060x-datadog-parent-id\u0060\n  - \u0060x-datadog-sampling-priority\u0060\n- 用于 SkyWalking：\u0060sw8\u0060\n- 用于 AWS X-Ray：\u0060x-amzn-trace-id\u0060\n\n关于这些 Header 的详细用法请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers)。\n\nEnvoy 会在 Ingress Gateway 中为你产生用于追踪的 Header，不论你的应用程序使用何种语言开发，Envoy 都会将这些 Header 转发到上游集群。但是，你还要对应用程序代码做一些小的修改，才能为使用分布式追踪功能。这是因为应用程序无法自动传播这些 Header，可以在程序中集成分布式追踪的 Agent，或者在代码中手动传播这些 Header。Envoy 会将追踪数据发送到 tracer 后端处理，然后就可以在 UI 中查看追踪数据了。\n\n例如在 Bookinfo 应用中的 Productpage 服务，如果你查看它的代码可以发现，其中集成了 Jaeger 客户端库，并在 \u0060getForwardHeaders (request)\u0060 方法中将 Envoy 生成的 Header 同步给对 Details 和 Reviews 服务的 HTTP 请求：\n\n\u0060\u0060\u0060python\ndef getForwardHeaders(request):\n    headers = {}\n\n    # 使用 Jaeger agent 获取 x-b3-* header\n    span = get_current_span()\n    carrier = {}\n    tracer.inject(\n        span_context=span.context,\n        format=Format.HTTP_HEADERS,\n        carrier=carrier)\n\n    headers.update(carrier)\n\n    # 手动处理非 x-b3-* header\n    if \u0027user\u0027 in session:\n        headers[\u0027end-user\u0027] = session[\u0027user\u0027]\n    incoming_headers = [\n        \u0027x-request-id\u0027,\n        \u0027x-ot-span-context\u0027,\n        \u0027x-datadog-trace-id\u0027,\n        \u0027x-datadog-parent-id\u0027,\n        \u0027x-datadog-sampling-priority\u0027,\n        \u0027traceparent\u0027,\n        \u0027tracestate\u0027,\n        \u0027x-cloud-trace-context\u0027,\n        \u0027grpc-trace-bin\u0027,\n        \u0027sw8\u0027,\n        \u0027user-agent\u0027,\n        \u0027cookie\u0027,\n        \u0027authorization\u0027,\n        \u0027jwt\u0027,\n    ]\n\n    for ihdr in incoming_headers:\n        val = request.headers.get(ihdr)\n        if val is not None:\n            headers[ihdr] = val\n\n    return headers\n\u0060\u0060\u0060\n\n关于 Istio 中分布式追踪的常见问题请见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)。\n\n## 分布式追踪系统如何选择 {#how-to-choose-a-distributed-tracing-system}\n\n分布式追踪系统的原理类似，市面上也有很多这样的系统，例如 [Apache SkyWalking](https:\/\/github.com\/apache\/skywalking)、[Jaeger](https:\/\/github.com\/jaegertracing\/jaeger)、[Zipkin](https:\/\/github.com\/openzipkin\/zipkin\/)、LightStep、[Pinpoint](https:\/\/github.com\/pinpoint-apm\/pinpoint) 等。我们将选择其中三个，从多个维度进行对比。之所以选择它们是因为：\n\n- 它们是当前最流行的开源分布式追踪系统；\n- 都是基于 OpenTracing 规范；\n- 都支持与 Istio 及 Envoy 集成；\n\n{{\u003ctable \u0022分布式追踪系统对比表（数据截止时间 2022-12-07）\u0022\u003e}}\n| 类别      | Apache SkyWalking                                            | Jaeger                                       | Zipkin                                       |\n| --------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| 实现方式  | 基于语言的探针、服务网格探针、eBPF agent、第三方指标库（当前支持 Zipkin） | 基于语言的探针                               | 基于语言的探针                               |\n| 数据存储  | ES、H2、MySQL、TiDB、Sharding-sphere、BanyanDB               | ES、MySQL、Cassandra、内存                   | ES、MySQL、Cassandra、内存                   |\n| 支持语言  | Java、Rust、PHP、NodeJS、Go、Python、C\u002b\u002b、.NET、Lua          | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b |\n| 发起者    | 个人                                                         | Uber                                         | Twitter                                      |\n| 治理方式  | Apache Foundation                                            | CNCF                                         | CNCF                                         |\n| 版本      | 9.3.0                                                        | 1.39.0                                       | 2.23.19                                      |\n| Star 数量 | 20.9k                                                        | 16.8k                                        | 15.8k                                        |\n\n{{\u003c\/table\u003e}}\n\n虽然 Apache SkyWalking 的 Agent 支持的语言没有 Jaeger 和 Zipkin 多，但是 SkyWalking 的实现方式更丰富，并且与 Jaeger、Zipkin 的追踪数据兼容，开发更为活跃，且为国人开发，中文资料丰富，是构建遥测平台的最佳选择之一。\n\n## 实验 {#demo}\n\n参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/skywalking\/)来安装和配置 Apache SkyWalking。\n\n### 环境说明 {#environments}\n\n以下是我们实验的环境：\n\n- Kubernetes 1.24.5\n- Istio 1.16\n- SkyWalking 9.1.0\n\n### 安装 Istio {#install-istio}\n\n安装之前可以先检查下环境是否有问题：\n\n\u0060\u0060\u0060bash\n$ istioctl experimental precheck\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\n  To get started, check out https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/\n\u0060\u0060\u0060\n\n然后使用 \u0060istioctl\u0060 安装 Istio 同时配置发送追踪信息的目的地为 SkyWalking：\n\n\u0060\u0060\u0060bash\n# 将安装配置保存到文件中\ncat\u003c\u003cEOF\u003eistio-install.yaml\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\n  name: istio-with-skywalking\nspec:\n  meshConfig:\n    defaultProviders:\n      tracing:\n      - \u0022skywalking\u0022\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: tracing.istio-system.svc.cluster.local\n        port: 11800\nEOF\n\n# 使用 istioctl 安装 Istio\nistioctl install -f istio-install.yaml\n\u0060\u0060\u0060\n\n### 部署 Apache SkyWalking {#install-skywalking}\n\nIstio 1.16 支持使用 Apache SkyWalking 进行分布式追踪，执行下面的代码安装 SkyWalking：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\n它将在 \u0060istio-system\u0060 命名空间下安装：\n\n- SkyWalking OAP (Observability Analysis Platform) ：用于接收追踪数据，支持 SkyWalking 原生数据格式，Zipkin v1 和 v2 以及 Jaeger 格式。\n- UI：用于查询分布式追踪数据。\n\n关于 SkyWalking 的详细信息请参考 SkyWalking 文档。\n\n### 部署 Bookinfo 应用 {#install-bookinfo}\n\n执行下面的命令安装 bookinfo 示例：\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n\u0060\u0060\u0060\n\n然后给 productpage 服务发送请求，如果你是在 Kind 中安装的 Istio，则默认的 IngressGateway 将是 LoadBalancer 类型，你可以使用端口转发的方式来暴露网关。\n\n\u0060\u0060\u0060bash\nkubectl port-forward -n istio-system svc\/istio-ingressgateway 8081:80\n\u0060\u0060\u0060\n\n通过 \u0060http:\/\/localhost:8081\/productpage\u0060 就可以访问到 productpage 服务。多访问几次来制造一些流量，后面我们就能在 SkyWalking UI 上看到拓扑图了。\n\n打开 SkyWalking UI：\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nSkyWalking 的 General Service 页面展示了 bookinfo 应用中的所有服务。\n\n![SkyWalking 的 General Service 页面](general-service.jpg)\n\n你还可以看到实例、端点、拓扑、追踪等信息。例如下图展示了 bookinfo 应用的服务拓扑。\n\n![Bookinfo 应用的服务拓扑](topology.jpg)\n\nSkyWalking 的追踪视图有多种显示形式，如列表、树形、表格和统计。\n\n![SkyWalking 通用服务追踪支持多种显示样式](gs-styles.jpg)\n\n为了方便我们检查，将追踪的采样率设置为 100%：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  tracing:\n  - randomSamplingPercentage: 100.00\nEOF\n\u0060\u0060\u0060\n\n### 卸载 {#purge}\n\n在实验完后，执行下面的命令卸载 Istio 和 SkyWalking：\n\n\u0060\u0060\u0060bash\nsamples\/bookinfo\/platform\/kube\/cleanup.sh\nistioctl unintall --purge\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## Bookinfo demo 追踪信息说明 {#bookinfo-tracing}\n\n在 Apache SkyWalking UI 中导航到 General Service 分页，查看最近的 \u0060istio-ingressgateway\u0060 服务的追踪信息，表视图如下所示。图中展示了此次请求所有 Span 的基本信息，点击每个 Span 可以查看详细信息。\n\n![表格视图中显示了 Span 的基本信息](span-table.jpg)\n\n切换为列表视图，可以看到每个 Span 的执行顺序及持续时间，如下图所示。\n\n![列表视图](trace-list.jpg)\n\n你可能会感到困惑，为什么这么简单的一个应用会产生如此多的 Span 信息？因为我们为 Pod 注入了 Envoy 代理之后，每个服务间的请求都会被 Envoy 拦截和处理，如下图所示。\n\n![Envoy 拦截请求产生 Span](span.svg)\n\n整个追踪流程如下图所示。\n\n![Bookinfo 的分布式追踪痕迹](bookinfo-spans-with-time.svg)\n\n图中给每一个 Span 标记了序号，并在括号里注明了耗时。为了便于说明我们将所有 Span 汇总在下面的表格中。\n\n| 序号 | 方法     | 总耗时（ms） | 组件耗时（ms） | 当前服务         | 说明                    |\n| -------- | ------------ | ------------------------ | -------------------------- | -------------------- | ------------------------------- |\n| 1    | \/productpage | 190                      | 0                          | istio-ingressgateway | Envoy Outbound          |\n| 2    | \/productpage | 190                      | 1                          | istio-ingressgateway | Ingress -\u003e Productpage 网络传输 |\n| 3    | \/productpage | 189                      | 1                          | productpage          | Envoy Inbound       |\n| 4    | \/productpage | 188                      | 21                         | productpage          | 应用内部处理        |\n| 5    | \/details\/0   | 8                        | 1                          | productpage          | Envoy Outbound      |\n| 6    | \/details\/0   | 7                        | 3                          | productpage          | Productpage -\u003e Details 网络传输     |\n| 7    | \/details\/0   | 4                        | 0                          | details              | Envoy Inbound           |\n| 8    | \/details\/0   | 4                        | 4                          | details              | 应用内部                |\n| 9    | \/reviews\/0   | 159                      | 0                          | productpage          | Envoy Outbound      |\n| 10   | \/reviews\/0   | 159                      | 14                         | productpage          | Productpage -\u003e Reviews 网络传输 |\n| 11   | \/reviews\/0   | 145                      | 1                          | reviews              | Envoy Inbound           |\n| 12   | \/reviews\/0   | 144                      | 109                        | reviews              | 应用内部处理              |\n| 13   | \/ratings\/0   | 35                       | 2                          | reviews              | Envoy Outbound          |\n| 14   | \/ratings\/0   | 33                       | 16                         | reviews              | Reviews -\u003e Ratings 网络传输         |\n| 15   | \/ratings\/0   | 17                       | 1                          | ratings              | Envoy Inbound           |\n| 16   | \/ratings\/0   | 16                       | 16                         | ratings              | 应用内部处理            |\n\n从以上信息可以发现：\n\n- 本次请求总耗时 190ms；\n- 在 Istio sidecar 模式下，每次流量在进出应用容器时都需要经过一次 Envoy 代理，每次耗时在 0 到 2 ms；\n- 在 Pod 间的网络请求耗时在 1 到 16ms 之间；\n- 将耗时做多的调用链 Ingress Gateway -\u003e Productpage -\u003e Reviews -\u003e Ratings 上的所有耗时累计 182 ms，小于请求总耗时 190ms，这是因为数据本身有误差，以及 Span 的开始时间并不一定等于父 Span 的结束时间，如果你在 SkyWalking 的追踪页面，选择「列表」样式查看追踪数据（见图 2）可以更直观的发现这个问题；\n- 我们可以查看到最耗时的部分是 Reviews 应用，耗时 109ms，因此我们可以针对该应用进行优化；\n\n## 总结 {#summary}\n\n只要对应用代码稍作修改就可以在 Istio 很方便的使用分布式追踪功能。在 Istio 支持的众多分布式追踪系统中，[Apache SkyWalking](https:\/\/skywalking.apache.org\/) 是其中的佼佼者。它不仅支持分布式追踪，还支持指标和日志收集、报警、Kubernetes 和服务网格监控，[使用 eBPF 诊断服务网格性能](https:\/\/skywalking.apache.org\/zh\/diagnose-service-mesh-network-performance-with-ebpf\/)等功能，是一个功能完备的云原生应用分析平台。本文中为了方便演示，将追踪采样率设置为了 100%，在生产使用时请根据需要调整采样策略（采样百分比），防止产生过多的追踪日志。\n\n## 参考 {#reference}\n\n- [Istio 分布式追踪概览 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/observability\/distributed-tracing\/overview\/)\n- [Istio 分布式追踪 FAQ - istio.io](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)\n', '\/blog\/distributed-tracing-with-skywalking-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将介绍一些关于分布式追踪的基础知识以及如何在 Istio 中使用分布式追踪。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-the-tls-encryption-in-istio/">如何理解 Istio 中的 mTLS 流量加密？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 mTLS 流量加密？', '本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。', '\nIstio 服务网格可以帮助云原生应用实现自动 mTLS，完成网格内的流量加密，有助于缩小云原生部署的攻击面，是构建零信任应用网络的关键框架。为了理解 Istio 中的 mTLS 流量加密，本文将包括以下内容：\n\n- 介绍什么是 TLS、mTLS 和 TLS 终止\n- 介绍 Istio 中如何实现 TLS 加密\n- 如何使用 Istio 为 Kubernetes 中的服务实现 mTLS？\n- 何时需要 mTLS？何时不需要 mTLS？\n\n## 什么是 TLS 和 mTLS？{#what-is-tls-and-mtls}\n\nTLS（Transport Layer Security，传输层安全性）是一种广泛采用的安全协议，用于在联网计算机之间建立经过身份验证和加密的链接，旨在促进互联网通信的私密性和数据安全性。TLS 作为 [SSL](https:\/\/www.ssl.com\/faqs\/faq-what-is-ssl\/)（Secure Socket Layer，安全套接字层）的继任者，实际上是由 SSL 改名而来，因此人们经常将 TLS\/SSL 混用，在本文中我们将统称为 TLS。TLS 1.0 发布于 1999 年，最新版本为 1.3（发布于 2018 年 8 月），1.0 和 1.1 版本已弃用。\n\n我们在浏览网页时看到的 HTTPS 实际上就使用了 TLS，如下图所示。TLS 是建立在 TCP 之上的，作为 OSI 模型中的会话层。为了保证兼容性，TLS 通常使用 443 端口，但是你也可以使用任意端口。\n\n![HTTP vs HTTPS](http-vs-https.svg)\n\n当客户端需要验证服务端身份，以防中间人攻击同时保证通信安全的情况下，在和服务端通信时会要求 TLS 加密。下图展示了的是 TLS 加密通信的流程。\n\n![TLS 加密通信流程](tls-flow.svg)\n\n1. 服务器向受信任的 CA（证书管理机构）申请并获得证书（X.509 证书）；\n2. 客户端向服务端发起请求，其中包含客户端支持的 TLS 版本和密码组合等信息；\n3. 服务器回应客户端请求并附上数字证书；\n4. 客户端验证证书的状态、有效期和数字签名等信息，确认服务器的身份；\n5. 客户端和服务器使用共享秘钥实现加密通信；\n\n以上仅是对 TLS 通信流程的一个概要描述，实际的 TLS 握手过程比较复杂，请参考[这篇文档](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)。\n\n从以上过程中你会发现，证书是代表服务器身份的关键要素，对于互联网公开服务，服务器需要使用权威认证的 CA 颁发的证书，而对于私有环境内部的服务，可以使用 PKI（Private Key Infrastructure，私钥基础设施）来管理证书。\n\n双向 TLS 或相互 TLS（Mutual TLS 或 mTLS）是指在服务端和客户端之间使用双向加密通道，需要双方相互提供证书并验证对方身份。关于如何在 Kubernetes 中使用 mTLS 请参考[这篇文章](https:\/\/cloudnative.to\/blog\/mtls-guide\/)。关于 mTLS 的详细介绍请见[这篇文章](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)。\n\n## 什么是 TLS 终止？{#what-is-tls-termination}\n\nTLS 终止（TLS Termination）指的是在将 TLS 加密流量传递给 Web 服务器之前对其进行解密的过程。将 TLS 流量卸载到入口网关或专用设备上，可以提高 Web 应用的性能，同时确保加密流量的安全性。一般运行在集群入口处，当流量到达入口处时实施 TLS 终止，入口与集群内服务器之间的通信将直接使用 HTTP 明文，这样可以提高服务性能。\n\n![TLS 终止](tls-termination.svg)\n\nIstio 默认在入口网关处终止 TLS，然后再为网格内的服务开启 mTLS。你也可以让流量直通（passthrough）到后端服务处理，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\n详见[网关 TLS  配置](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways)。\n\n## Istio 中如何实现自动 mTLS？{#istio-mtls}\n\n下图中展示的是 Istio 安全架构图，从图中可以看到在入口处使用 JWS \u002b TLS 认证和加密，在 Istio 网格内部的所有服务间都开启了 mTLS。\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio 中内置了 CA，使用 xDS 中的 SDS（Secret Discovery Service，秘密发现服务）实现 SVID 证书的签发和轮换。Istio 网格内的 mTLS 流程如下：\n\n1. Sidecar 代替工作负载向 Istiod 申请证书，Istiod 签发 [SVID](\/book\/kubernetes-handbook\/auth\/spiffe\/#svid) 证书（该过程比较复杂，我将在今后的博客中说明）；\n2. 客户端请求被 Pod 内的 sidecar 拦截；\n3. 客户端 sidecar 与服务端 sidecar 开始 mTLS 握手。在握手的同时，客户端 sidecar 中的 JWT 和认证过滤器将对请求的身份进行认证，认证通过后将身份存储在过滤器元数据中，然后请求经过授权过滤器，判断请求权限。\n4. 若请求通过了认证与授权，则客户端和服务端开始建立连接进行通信。\n\nIstio 中有三个资源对象可用于配置服务间的认证与授权：\n\n- \u0060RequestAuthentication\u0060：用于定义服务支持的请求级认证方式，目前只支持  JWT（[查看 JWT 组件详解](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)）；\n- \u0060PeerAuthentication\u0060：配置服务间的传输认证模式，如 \u0060STRICT\u0060、\u0060PERMISSIVE\u0060 或 \u0060DISABLE\u0060 等，以开启 mTLS 或明文请求；\n- \u0060AuthorizationPolicy\u0060：用于授权服务间的流量，定义谁可以做什么？例如主体 A 允许（\u0060ALLOW\u0060）或拒绝（\u0060DENY\u0060）来自主体 B 的流量；\n\n## 如何使用 Istio 为服务开启自动 mTLS？ {#how-to-setup-mtls}\n\n你可以在 \u0060PeerAuthentication\u0060 中指定对目标工作负载实施的 mTLS 模式。对等认证支持以下模式：\n\n- \u0060PERMISSIVE\u0060：默认值，工作负载可接受双向 TLS 或纯文本流量；\n- \u0060STRICT\u0060：工作负载仅接受 mTLS 流量；\n- \u0060DISABLE\u0060：禁用 mTLS。从安全角度来看，除非你有自己的安全解决方案，否则不应禁用 mTLS；\n- \u0060UNSET\u0060：从父级继承，优先级为服务特定 \u003e 命名空间范围 \u003e 网格范围的设置；\n\nIstio 的对等认证默认使用 \u0060PERMISSIVE\u0060 模式，自动将 mTLS 流量发送到这些工作负载，将纯文本流量发送到没有 sidecar 的工作负载。在将 Kubernetes 服务纳入 Istio 网格后，为了防止服务无法通过 mTLS，我们可以先使用 \u0060PERMISSIVE\u0060 模式。当我想为某些服务开启严格的 mTLS 模式时，可以使用以下两种方式之一：\n\n- 使用 \u0060PeerAuthentication\u0060 定义流量如何在 sidecar 之间传输；\n- 使用 \u0060DestinationRule\u0060 定义流量路由策略中的 TLS 设置；\n\n下面以为 \u0060default\u0060 命名空间下的 \u0060reviews\u0060 服务设置 mTLS 为例说明。\n\n### 使用 PeerAuthentication 为工作负载设置 mTLS {#peerauthentication-tls-setting}\n\n你可以使用 \u0060namespace\u0060 和 \u0060selector\u0060 指定某个命名空间下的某个工作负载开启严格的 mTLS。例如下面的配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\n你也可以给安装 Istio  的命名空间 \u0060istio-system\u0060 设置严格的 mTLS，那样会为网格中的所有服务开启严格的 mTLS，详细步骤请参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/authentication\/mtls-migration\/)。\n\n### 使用 DestinationRule 为工作负载设置 mTLS {#destinationrule-tls-setting}\n\nDestinationRule 用于设置流量路由策略，例如负载均衡、异常点检测、TLS 设置等。其中 TLS 设置中包含[多种模式](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ClientTLSSettings-TLSmode)，使用 \u0060ISTIO_MUTUAL\u0060 模式可以为工作负载开启 Istio 的自动 TLS，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## 什么时候用 mTLS？{#when-use-mtls}\n\n互联网客户端对 Web 服务的访问，一般使用单向 TLS，即只需要服务端提供身份证明，而不关心客户端的身份。当你需要验证客户端身份时，使用单向 TLS 可以使用密码、token、双因子认证等方式。不过这样的认证方式需要应用程序内部支持，而双向 TLS 是运行在应用程序之外的，不需要多应用逻辑进行修改。\n\n当你需要正如你在上文中看到的，实施 mTLS 的服务间需要交换证书，当服务数量变大时，就需要管理大量的证书，这需要消耗大量的精力，使用服务网格可以帮助你实现自动 mTLS，彻底解决证书管理的难题。\n\n## 什么时候不用 mTLS？{#when-not-use-mtls}\n\n虽然 mTLS 是确保云原生应用程序服务间通信安全的首选协议，但是应用 mTLS 需要完成复杂的对称加密、解密过程，这将非常耗时且消耗大量的 CPU 资源。对于某些安全级别不高的流量，如果我们在流量入口处终止 TLS，并网格内部仅对针对性的服务开启 mTLS，就可以加快请求响应和减少计算资源消耗。\n\n另外当有的服务无法获取证书，例如 Kubelet 上使用 HTTP 的健康检查，无法通过 TLS 访问服务内的健康检查端点，这时候就需要[为 Pod 禁用探针重写](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod)。\n\n最后当网格中的服务访问一些外部服务时，也不需要 mTLS。\n\n## 总结 {#summary}\n\nmTLS 实现了网格内流量的加密，是构建零信任应用网络的关键一步。借助 Istio 我们可以很方便的为 Kubernetes 中的服务开启自动 mTLS，省去管理证书的麻烦。同时，我们也可以针对性的为网格内的部分服务开启 mTLS，便于我们将 Kubernetes 中的服务迁移到网格内。关于 Istio 中的证书管理，我们将在今后的博客中再做说明。\n\n## 参考 {#reference}\n\n- [什么是 TLS（传输层安全性）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/ssl\/transport-layer-security-tls\/)\n- [什么是相互 TLS（mTLS）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)\n- [What happens in a TLS handshake? | SSL handshake - cloudflare.com](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n- [写给 Kubernetes 工程师的 mTLS 指南 - jimmysong.io](https:\/\/cloudnative.to\/blog\/mtls-guide\/)\n- [云原生安全白皮书中文版 - github.com](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/security-whitepaper\/v1\/cloud-native-security-whitepaper-simplified-chinese.md)\n- [Istio 安全 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/)\n- [JWT 组件详解 - jimmysong.io](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)\n', '\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ambient-mesh-l7-traffic-path/">Istio Ambient 模式中的七层流量路由路径详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的七层流量路由路径详解', '本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的七层（L7）流量路径。', '\n在[上一篇博客中](\/blog\/ambient-mesh-l4-traffic-path\/)我介绍了 Ambient 模式中的透明流量劫持和四层流量路由，在这一篇博客中，我将向你介绍在 Istio 的 Ambient 模式中，七层流量是如何路由的。\n\n下图展示了 Ambient 模式中七层网络流量路径。\n\n![Ambient Mesh 中的七层网络流量路径](ambient-mesh-l7-traffic-path.svg)\n\n注意：Waypoint Proxy 可以位于应用程序所在节点，甚至图中的服务 A、服务 B 和 Waypoint Proxy 都可以位于同一个节点，之所以将它们画在三个节点上是为了方便展示，但是对于实际的流量路径没有大的影响，只不过是不再通过 eth0 发送到另外一个节点。\n\n下文我们将从手操作探究图中过程。\n\n## 环境说明 {#environment}\n\n我们继续使用上一篇博客中部署的 Ambient 模式的 Istio，[查看环境说明](\/blog\/ambient-mesh-l4-traffic-path\/#environment)。为了说明七层网路路由，我们需要在此基础上再创建一个 Gateway：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n name: productpage\n annotations:\n   istio.io\/service-account: bookinfo-productpage\nspec:\n gatewayClassName: istio-mesh\nEOF\n\u0060\u0060\u0060\n\n执行完该命令后，\u0060default\u0060 命名空间下会创建了一个 Waypoint proxy，在我的环境中这个 pod 的名字是 \u0060bookinfo-productpage-waypoint-proxy-6f88c55d59-4dzdx\u0060，专门用于处理发往 productpage 服务（服务 B）的 L7 流量，我将它称之为 Waypoint Proxy B。\n\nWaypoint 代理可以位于与工作负载相同或者不同的节点上，它也可以部署在独立的命名空间中，不论它位于哪个节点，对于 L7 流量路径没有影响。\n\nAmbient mesh 中透明流量的方式在 L4 和 L7 网络中没有什么不同，因此在这篇博客中我们将略过 Inbound 和 Outbound 流量劫持部分，你可以查看[上一篇博客](\/blog\/ambient-mesh-l4-traffic-path\/)了解详情。\n\n下面我们将直接从流量被劫持到 Ztunnel A 后，被转发到 Envoy 的 15006 端口开始。\n\n## Ztunnel A 上的出站流量路由 {#ztunel-a-outbound}\n\n使用下面的命令导出 Ztunnel A 上的 Envoy 代理配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system ztunnel-hptxk -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-a-all-include-eds.json\n\u0060\u0060\u0060\n\n查看 \u0060ztunnel-a-all-include-eds.json\u0060 文件中的 Listener 配置部分，根据目的端口和来源 IP 的匹配关系，你将看到 \u0060ztunnel_outbound\u0060 监听器中有如下配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=2 12 18\u0022\u003e}}\n{\n  \u002210.8.14.226\u0022: {\n    \u0022matcher\u0022: {\n    \u0022matcher_tree\u0022: {\n      \u0022input\u0022: {\n      \u0022name\u0022: \u0022port\u0022,\n      \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n      }\n      },\n      \u0022exact_match_map\u0022: {\n      \u0022map\u0022: {\n        \u00229080\u0022: {\n        \u0022action\u0022: {\n          \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022,\n          \u0022typed_config\u0022: {\n          \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n          \u0022value\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022\n          }\n        }\n        }\n      }\n      }\n    }\n    }\n  }\n}\n{{\u003c\/highlight\u003e}}\n\n\u006010.8.14.226\u0060 是目标服务的 Cluster  IP，服务端口是 9080。流量将被路由到 \u0060spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0060 集群，查看该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   }\n  },\n  \/* 省略 *\/\n}\n{{\u003c\/highlight\u003e}}\n\n该集群使用 EDS 服务发现。查看该集群的 EDS 信息：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=11 12\u0022\u003e}}\n{ \n \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n \u0022endpoints\u0022: [\n  {\n   \u0022locality\u0022: {},\n   \u0022lb_endpoints\u0022: [\n    {\n     \u0022endpoint\u0022: {\n      \u0022address\u0022: {\n       \u0022socket_address\u0022: {\n        \u0022address\u0022: \u002210.4.3.14\u0022,\n        \u0022port_value\u0022: 15006\n       }\n      },\n      \u0022health_check_config\u0022: {}\n     },\n     \u0022health_status\u0022: \u0022HEALTHY\u0022,\n     \u0022load_balancing_weight\u0022: 1\n    }\n   ]\n  }\n ],\n \u0022policy\u0022: {\n  \u0022overprovisioning_factor\u0022: 140\n }\n}\n{{\u003c\/highlight\u003e}}\n\n注意：这里还是缺少输出 \u0060cluster_name\u0060 字段。\n\n在这里直接将流量转发给 Waypoint Proxy 的端点 \u006010.4.3.14:15006\u0060。\n\n## Waypoint Proxy B 上的流量转发 {#waypoint-proxy-b}\n\n我们再导出 Waypoint Proxy B 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n default bookinfo-productpage-waypoint-proxy-6f88c55d59-4dzdx -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003ewaypoint-a-all-include-eds.json\n\u0060\u0060\u0060\n\n查看 \u0060inbound_CONNECT_terminate\u0060 监听器的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 39 44 58 62\u0022\u003e}}\n{\n  \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022,\n  \u0022active_state\u0022: {\n    \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n    \u0022listener\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n    \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022,\n    \u0022address\u0022: {\n      \u0022socket_address\u0022: {\n      \u0022address\u0022: \u00220.0.0.0\u0022,\n      \u0022port_value\u0022: 15006\n      }\n    },\n    \u0022filter_chains\u0022: [{\n      \u0022filters\u0022: [{\n        \u0022name\u0022: \u0022capture_tls\u0022,\n        \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n        \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.CaptureTLS\u0022\n        }\n      },\n      {\n        \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n        \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_hcm\u0022,\n        \u0022route_config\u0022: {\n          \u0022name\u0022: \u0022local_route\u0022,\n          \u0022virtual_hosts\u0022: [{\n          \u0022name\u0022: \u0022connect\u0022,\n          \u0022domains\u0022: [\n            \u0022*\u0022\n          ],\n          \u0022routes\u0022: [{...},\n            {\n            \u0022match\u0022: {\n              \u0022headers\u0022: [{\n              \u0022name\u0022: \u0022:authority\u0022,\n              \u0022exact_match\u0022: \u002210.8.14.226:9080\u0022\n              }],\n              \u0022connect_matcher\u0022: {}\n            },\n            \u0022route\u0022: {\n              \u0022cluster\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n              \u0022upgrade_configs\u0022: [{\n              \u0022upgrade_type\u0022: \u0022CONNECT\u0022,\n              \u0022connect_config\u0022: {}\n              }]\n            }\n            }\n          ]\n          }],\n          \u0022validate_clusters\u0022: false\n        },\n        \u0022http_filters\u0022: [...],\n        \u0022tracing\u0022: {...},\n        \u0022http2_protocol_options\u0022: {\n          \u0022allow_connect\u0022: true\n        },\n        \u0022use_remote_address\u0022: false,\n        \u0022upgrade_configs\u0022: [{\n          \u0022upgrade_type\u0022: \u0022CONNECT\u0022\n        }],\n        \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n        \u0022normalize_path\u0022: true,\n        \u0022request_id_extension\u0022: {...},\n        \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n        }\n      }\n      ],\n      \u0022transport_socket\u0022: {...},\n      \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022\n    }]\n    },\n    \u0022last_updated\u0022: \u00222022-11-17T06:24:51.467Z\u0022\n  }\n}\n{{\u003c\/highlight\u003e}}\n\n目的地为 \u006010.8.14.226:9080\u0060 的 TCP 流量将被转发到 \u0060inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0060，并将 HTTP 类型修改为 \u0060CONNECT\u0060，查看该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 37\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n  \u0022type\u0022: \u0022STATIC\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022passthrough_metadata\u0022: [\n     {\n      \u0022kind\u0022: {\n       \u0022cluster\u0022: {}\n      },\n      \u0022name\u0022: \u0022istio\u0022\n     }\n    ],\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {},\n  \u0022load_assignment\u0022: {\n   \u0022cluster_name\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n   \u0022endpoints\u0022: [\n    {\n     \u0022lb_endpoints\u0022: [\n      {\n       \u0022endpoint\u0022: {\n        \u0022address\u0022: {\n         \u0022envoy_internal_address\u0022: {\n          \u0022server_listener_name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022\n         }\n        }\n       }\n      }\n     ]\n    }\n   ]\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.137Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群的端点是一个内部监听器 \u0060inbound-vip|9080||productpage.default.svc.cluster.local\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=21-47 73-80\u0022\u003e}}\n{\n \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022,\n   \u0022filter_chains\u0022: [{\n    \u0022filters\u0022: [{\n      \u0022name\u0022: \u0022restore_tls\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n       \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.RestoreTLS\u0022\n      }\n     },\n     {\n      \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n       \u0022stat_prefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n       \u0022route_config\u0022: {\n        \u0022name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n        \u0022virtual_hosts\u0022: [{\n         \u0022name\u0022: \u0022inbound|http|9080\u0022,\n         \u0022domains\u0022: [\n          \u0022*\u0022\n         ],\n         \u0022routes\u0022: [{\n          \u0022match\u0022: {\n           \u0022prefix\u0022: \u0022\/\u0022\n          },\n          \u0022route\u0022: {\n           \u0022cluster\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n           \u0022timeout\u0022: \u00220s\u0022,\n           \u0022max_stream_duration\u0022: {\n            \u0022max_stream_duration\u0022: \u00220s\u0022,\n            \u0022grpc_timeout_header_max\u0022: \u00220s\u0022\n           }\n          },\n          \u0022decorator\u0022: {\n           \u0022operation\u0022: \u0022:9080\/*\u0022\n          },\n          \u0022name\u0022: \u0022default\u0022\n         }]\n        }],\n        \u0022validate_clusters\u0022: false\n       }\n      },\n      \u0022server_name\u0022: \u0022istio-envoy\u0022,\n      \u0022use_remote_address\u0022: false,\n      \u0022forward_client_cert_details\u0022: \u0022APPEND_FORWARD\u0022,\n      \u0022set_current_client_cert_details\u0022: {\n       \u0022subject\u0022: true,\n       \u0022dns\u0022: true,\n       \u0022uri\u0022: true\n      },\n      \u0022upgrade_configs\u0022: [{\n       \u0022upgrade_type\u0022: \u0022websocket\u0022\n      }],\n      \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n      \u0022normalize_path\u0022: true,\n      \u0022request_id_extension\u0022: {\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig\u0022,\n        \u0022use_request_id_for_trace_sampling\u0022: true\n       }\n      },\n      \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n     }\n    ],\n    \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local-http\u0022\n   }],\n   \u0022listener_filters\u0022: [{\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.metadata_to_peer_node\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.telemetry.metadatatopeernode.v1.Config\u0022\n     }\n    }\n   ],\n   \u0022traffic_direction\u0022: \u0022INBOUND\u0022,\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.300Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-vip|9080|http|productpage.default.svc.cluster.local\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   },\n   \u0022service_name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022\n  },\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022metadata\u0022: {\n   \u0022filter_metadata\u0022: {\n    \u0022istio\u0022: {\n     \u0022services\u0022: [{\n      \u0022namespace\u0022: \u0022default\u0022,\n      \u0022name\u0022: \u0022productpage\u0022,\n      \u0022host\u0022: \u0022productpage.default.svc.cluster.local\u0022\n     }]\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {}\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.138Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群是 EDS 类型，查看 Endpoint 配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=14\u0022\u003e}}\n{\n \u0022endpoint_config\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n  \u0022cluster_name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [{\n   \u0022locality\u0022: {\n    \u0022region\u0022: \u0022us-west2\u0022,\n    \u0022zone\u0022: \u0022us-west2-a\u0022\n   },\n   \u0022lb_endpoints\u0022: [{\n    \u0022endpoint\u0022: {\n     \u0022address\u0022: {\n      \u0022envoy_internal_address\u0022: {\n       \u0022server_listener_name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022\n      }\n     },\n     \u0022health_check_config\u0022: {}\n    },\n    \u0022health_status\u0022: \u0022HEALTHY\u0022,\n    \u0022metadata\u0022: {\n     \u0022filter_metadata\u0022: {\n      \u0022istio\u0022: {\n       \u0022workload\u0022: \u0022productpage-v1;default;productpage;v1;Kubernetes\u0022\n      }\n     }\n    },\n    \u0022load_balancing_weight\u0022: 1\n   }]\n  }],\n  \u0022policy\u0022: {\n   \u0022overprovisioning_factor\u0022: 140\n  }\n }\n}\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-pod|9080||10.4.0.5\u0060 监听器：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=33\u0022\u003e}}\n\n{\n \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n   \u0022filter_chains\u0022: [{\n    \u0022filters\u0022: [{\n      \u0022name\u0022: \u0022restore_tls\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n       \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.RestoreTLS\u0022\n      }\n     },\n     {\n      \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n       \u0022stat_prefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n       \u0022route_config\u0022: {\n        \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n        \u0022virtual_hosts\u0022: [{\n         \u0022name\u0022: \u0022inbound|http|9080\u0022,\n         \u0022domains\u0022: [\n          \u0022*\u0022\n         ],\n         \u0022routes\u0022: [{\n          \u0022match\u0022: {\n           \u0022prefix\u0022: \u0022\/\u0022\n          },\n          \u0022route\u0022: {\n           \u0022cluster\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n           \u0022timeout\u0022: \u00220s\u0022,\n           \u0022max_stream_duration\u0022: {\n            \u0022max_stream_duration\u0022: \u00220s\u0022,\n            \u0022grpc_timeout_header_max\u0022: \u00220s\u0022\n           }\n          },\n          \u0022decorator\u0022: {\n           \u0022operation\u0022: \u0022:9080\/*\u0022\n          },\n          \u0022name\u0022: \u0022default\u0022\n         }]\n        }],\n        \u0022validate_clusters\u0022: false\n       },\n       \u0022http_filters\u0022: [{\n        \u0022name\u0022: \u0022envoy.filters.http.rbac\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.http.rbac.v3.RBAC\u0022,\n         \u0022rules\u0022: {\n          \u0022policies\u0022: {\n           \u0022ns[default]-policy[productpage-viewer]-rule[0]\u0022: {\n            \u0022permissions\u0022: [{\n             \u0022and_rules\u0022: {\n              \u0022rules\u0022: [{\n               \u0022any\u0022: true\n              }]\n             }\n            }],\n            \u0022principals\u0022: [{\n             \u0022and_ids\u0022: {\n              \u0022ids\u0022: [{\n               \u0022or_ids\u0022: {\n                \u0022ids\u0022: [{\n                  \u0022authenticated\u0022: {\n                   \u0022principal_name\u0022: {\n                    \u0022exact\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022\n                   }\n                  }\n                 },\n                 {\n                  \u0022authenticated\u0022: {\n                   \u0022principal_name\u0022: {\n                    \u0022exact\u0022: \u0022spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022\n                   }\n                  }\n                 }\n                ]\n               }\n              }]\n             }\n            }]\n           }\n          }\n         },\n         \u0022shadow_rules_stat_prefix\u0022: \u0022istio_dry_run_allow_\u0022\n        }\n       }],\n       \u0022server_name\u0022: \u0022istio-envoy\u0022,\n       \u0022use_remote_address\u0022: false,\n       \u0022forward_client_cert_details\u0022: \u0022APPEND_FORWARD\u0022,\n       \u0022set_current_client_cert_details\u0022: {\n        \u0022subject\u0022: true,\n        \u0022dns\u0022: true,\n        \u0022uri\u0022: true\n       },\n       \u0022upgrade_configs\u0022: [{\n        \u0022upgrade_type\u0022: \u0022websocket\u0022\n       }],\n       \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n       \u0022normalize_path\u0022: true,\n       \u0022request_id_extension\u0022: {\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig\u0022,\n         \u0022use_request_id_for_trace_sampling\u0022: true\n        }\n       },\n       \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n      }\n     }\n    ],\n    \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5-http\u0022\n   }],\n   \u0022listener_filters\u0022: [{\n    \u0022name\u0022: \u0022set_dst_address\u0022,\n    \u0022typed_config\u0022: {\n     \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n     \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n     \u0022value\u0022: {}\n    }\n   }],\n   \u0022traffic_direction\u0022: \u0022INBOUND\u0022,\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.339Z\u0022\n }\n}\n\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-pod|9080||10.4.0.5\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 43 48-55\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n  \u0022type\u0022: \u0022STATIC\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022passthrough_metadata\u0022: [\n     {\n      \u0022kind\u0022: {\n       \u0022host\u0022: {}\n      },\n      \u0022name\u0022: \u0022tunnel\u0022\n     },\n     {\n      \u0022kind\u0022: {\n       \u0022host\u0022: {}\n      },\n      \u0022name\u0022: \u0022istio\u0022\n     }\n    ],\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {},\n  \u0022load_assignment\u0022: {\n   \u0022cluster_name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n   \u0022endpoints\u0022: [\n    {\n     \u0022lb_endpoints\u0022: [\n      {\n       \u0022endpoint\u0022: {\n        \u0022address\u0022: {\n         \u0022envoy_internal_address\u0022: {\n          \u0022server_listener_name\u0022: \u0022inbound_CONNECT_originate\u0022,\n          \u0022endpoint_id\u0022: \u002210.4.0.5:9080\u0022\n         }\n        }\n       },\n       \u0022metadata\u0022: {\n        \u0022filter_metadata\u0022: {\n         \u0022tunnel\u0022: {\n          \u0022destination\u0022: \u002210.4.0.5:9080\u0022,\n          \u0022address\u0022: \u002210.4.0.5:15008\u0022\n         }\n        }\n       }\n      }\n     ]\n    }\n   ]\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.139Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群是 \u0060STATIC\u0060 类型，其中包含了 HBONE 隧道配置（HTTP\/2 CONNECT 地址是 \u006010.4.0.15008\u0060），端点是 Envoy 内部监听器 \u0060inbound_CONNECT_originate\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=16-27 33 36\u0022\u003e}}\n{\n \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.tcp_proxy\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_CONNECT_originate\u0022,\n        \u0022cluster\u0022: \u0022inbound_CONNECT_originate\u0022,\n        \u0022tunneling_config\u0022: {\n         \u0022hostname\u0022: \u0022%DYNAMIC_METADATA(tunnel:destination)%\u0022,\n         \u0022headers_to_add\u0022: [\n          {\n           \u0022header\u0022: {\n            \u0022key\u0022: \u0022x-envoy-original-dst-host\u0022,\n            \u0022value\u0022: \u0022%DYNAMIC_METADATA([\\\u0022tunnel\\\u0022, \\\u0022destination\\\u0022])%\u0022\n           }\n          }\n         ]\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \u0022use_original_dst\u0022: false,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    }\n   ],\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.339Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- \u0060listener_filters\u0060 中的 \u0060set_dst_address\u0060 将目的地地址设置为 \u006010.4.0.5.15008\u0060；\n- 在隧道中新增了一个 Header：\u0060x-envoy-original-dst-host\u0060，它的值是 \u006010.4.0.5:9080\u0060；\n- 该集群的端点是 \u0060inbound_CONNECT_originate\u0060 集群；\n\n查看 \u0060inbound_CONNECT_originate\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022connect_timeout\u0022: \u00222s\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022cleanup_interval\u0022: \u002260s\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\u0022,\n    \u0022common_tls_context\u0022: {\n     \u0022tls_params\u0022: {\n      \u0022tls_minimum_protocol_version\u0022: \u0022TLSv1_3\u0022,\n      \u0022tls_maximum_protocol_version\u0022: \u0022TLSv1_3\u0022\n     },\n     \u0022alpn_protocols\u0022: [\n      \u0022h2\u0022\n     ],\n     \u0022tls_certificate_sds_secret_configs\u0022: [\n      {\n       \u0022name\u0022: \u0022default\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     ],\n     \u0022combined_validation_context\u0022: {\n      \u0022default_validation_context\u0022: {\n       \u0022match_subject_alt_names\u0022: [\n        {\n         \u0022prefix\u0022: \u0022spiffe:\/\/cluster.local\/\u0022\n        }\n       ]\n      },\n      \u0022validation_context_sds_secret_config\u0022: {\n       \u0022name\u0022: \u0022ROOTCA\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     }\n    }\n   }\n  },\n  \u0022typed_extension_protocol_options\u0022: {\n   \u0022envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022,\n    \u0022explicit_http_config\u0022: {\n     \u0022http2_protocol_options\u0022: {\n      \u0022allow_connect\u0022: true\n     }\n    }\n   }\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.140Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群的类型是 \u0060ORIGINAL_DST\u0060，直接与上游建立 HBONE 隧道，将数据包发送到 Pod B 的 15008 端口。在节点 B 的 Ztunnel 的流量劫持和路由方式就跟 L4 是一样的了，在这里不再赘述。\n\n## 总结 {#summary}\n\nL7 流量路由是在 L4 的基础上增加了 Waypoint 代理，该代理中 Envoy 处理比较复杂。Waypoint 代理使用 Gateway API 生成基于 Deployment 部署的，我们可以根据个别服务的负载情况，单独扩缩容其 Waypoint 代理，也可以创建 HPA 来动态扩容。\n\n## 参考 {#reference}\n\n- [Original destination - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#arch-overview-service-discovery-types-original-destination)\n- [一文读懂 Ambient Mesh 七层服务治理 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/TXMyxbzBSfuYNquOZJmZTg)\n', '\/blog\/ambient-mesh-l7-traffic-path\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的七层（L7）流量路径。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ambient-mesh-l4-traffic-path/">Istio Ambient 模式中的透明流量劫持四层网络路由路径详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的透明流量劫持四层网络路由路径详解', '本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。', '\n本文通过动手操作，带领读者一步步了解 Istio ambient 模式中的四层流量路径。如果你还不了解什么是 Ambient 模式，以下文章可以帮助你了解：\n\n- [关于 Istio 推出 Ambient 数据平面模式的看法](\/blog\/istio-ambient-mode\/)\n- [Istio 无 sidecar 代理数据平面 ambient 模式简介](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)\n- [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/)\n- [什么是 Ambient Mesh，它与 sidecar 模式有什么区别？](https:\/\/cloudnative.to\/blog\/what-is-ambient-mesh\/)\n\n如果你想略过实际动手步骤，只是想知道 Ambient 模式中的四层流量路径，请看下面服务 A 的一个 Pod 访问不同节点上服务 B 的 Pod 的四层流量路径图。\n\n![Ambient 模式中的四层流量路径](ambient-mesh-l4-traffic-path.svg)\n\n## 原理 {#principles}\n\nAmbient 模式使用 **tproxy** 和 **HBONE** 这两个关键技术实现透明流量劫持和路由的：\n\n- 使用 tproxy 将主机 Pod 中的流量劫持到 Ztunnel（Envoy Proxy）中，实现透明流量劫持；\n- 使用 HBONE 建立在 Ztunnel 之间传递 TCP 数据流隧道；\n\n### 什么是 tproxy？{#what-is-tproxy}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt) 。\n\n### 什么是 HBONE？{#what-is-hbone}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n## 环境说明 {#environment}\n\n在开始动手操作之前，需要先说明一下笔者的演示环境，本文中对应的对象名称：\n\n| 代号           | 名称                                         | IP            |\n| -------------- | -------------------------------------------- | ------------- |\n| 服务 A Pod     | sleep-5644bdc767-2dfg7                       | 10.4.4.19     |\n| 服务 B Pod     | productpage-v1-5586c4d4ff-qxz9f              | 10.4.3.20     |\n| Ztunnel A Pod  | ztunnel-rts54                                | 10.4.4.18     |\n| Ztunnel B Pod  | ztunnel-z4qmh                                | 10.4.3.14     |\n| 节点 A         | gke-jimmy-cluster-default-pool-d5041909-d10i | 10.168.15.222 |\n| 节点 B         | gke-jimmy-cluster-default-pool-d5041909-c1da | 10.168.15.224 |\n| 服务 B Cluster | productpage                                  | 10.8.14.226   |\n\n注意：因为这些名称将在后续的命令行中用到，文中将使用代称，以便你在自己的环境中实验。\n\n笔者在 GKE 中安装了 Ambient 模式的 Istio，请参考[该步骤](\/blog\/istio-ambient-mode\/#setup)安装，注意不要安装 Gateway，以免启用 L7 功能，否则流量路径将于 L4 流量不同。\n\n下面我们将动手实验，深入探究 \u0060sleep\u0060 服务的 Pod 访问不同节点上 \u0060productpage\u0060 服务的 Pod 的四层流量路径。我们将分别检视 Pod 的 outbound 和 inbound 流量。\n\n## Outbound 流量劫持 {#outbound}\n\nAmbient mesh 的 pod 出站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioout\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 [IP 集](https:\/\/ipset.netfilter.org\/)，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioout\u0060 虚拟网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioout\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15001 端口；\n3. Envoy 对数据包进行处理，并与上游端点建立 HBONE 隧道（HTTP CONNECT），将数据包转发到上游。\n\n### 检查节点 A 上的路由规则 {#node-a-rules}\n\n登录到服务 A 所在的节点 A，使用 \u0060iptables-save\u0060 查看规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=3 4 6 35\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A PREROUTING -m comment --comment \u0022kubernetes service portals\u0022 -j KUBE-SERVICES\n-A ztunnel-POSTROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n-A ztunnel-PREROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n\/* 省略 *\/\n*mangle\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A INPUT -j ztunnel-INPUT\n-A FORWARD -j ztunnel-FORWARD\n-A OUTPUT -j ztunnel-OUTPUT\n-A OUTPUT -s 169.254.169.254\/32 -j DROP\n-A POSTROUTING -j ztunnel-POSTROUTING\n-A ztunnel-FORWARD -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-FORWARD -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-INPUT -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-INPUT -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-OUTPUT -s 10.4.4.1\/32 -j MARK --set-xmark 0x220\/0xffffffff\n-A ztunnel-PREROUTING -i istioin -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioin -j RETURN\n-A ztunnel-PREROUTING -i istioout -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioout -j RETURN\n-A ztunnel-PREROUTING -p udp -m udp --dport 6081 -j RETURN\n-A ztunnel-PREROUTING -m connmark --mark 0x220\/0x220 -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING ! -i veth300a1d80 -m connmark --mark 0x210\/0x210 -j MARK --set-xmark 0x40\/0x40\n-A ztunnel-PREROUTING -m mark --mark 0x40\/0x40 -j RETURN\n-A ztunnel-PREROUTING ! -s 10.4.4.18\/32 -i veth300a1d80 -j MARK --set-xmark 0x210\/0x210\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -i veth300a1d80 -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -p udp -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n{{\u003c\/highlight\u003e}}\n\niptables 规则说明：\n\n- 第 3 行：PREROUTING 链是最先运行的，所有数据包将先进入 \u0060ztunnel-PREROUTING\u0060 链；\n- 第 4 行：将数据包发往 \u0060KUBE-SERVICES\u0060 链，在那里将 Kubernetes Service 的 Cluster IP 进行 DNAT 转换为 Pod IP；\n- 第 6 行：带有 \u00600x100\/0x100\u0060 标记的数据包通过 PREROUTING 链，不再经过 \u0060KUBE-SERVICES\u0060 链；\n- 第 35 行：这是添加到 \u0060ztunnel-PREROUTING\u0060 链上的最后一条规则，进入 \u0060ztunnel-PREROUTING\u0060 链中的在 \u0060ztunnel-pods-ips\u0060 IP 集中的所有 TCP 数据包都会被打上 \u00600x100\/0x100\u0060 的标记，它将覆盖前面的所有标记；\n\n{{\u003ccallout note \u0022关于 iptables 设置 mark 和 xmark 标记\u0022\u003e}}\n\n\u0060MARK\u0060 这个扩展目标可以用来给数据包打标记，标记分两种：一种是用于标记链接的 \u0060ctmark\u0060，一种是用于标记数据包的 \u0060nfmark\u0060 。\u0060nfmark\u0060占四个字节共 32 位，我们可以把它看成是一个长度为 32 位的无符号整数，一般用 16 进制来表示。\n\nMark 的设置一共有五个选项，分别是 \u0060--set-xmark\u0060、\u0060--set-mark\u0060、\u0060--and-mark\u0060、\u0060--and-mark\u0060、\u0060--or-mark\u0060 和 \u0060--xor-mark\u0060。在本文用到了前两种，下面将分别为大家介绍。\n\n**\u0060--set-xmark value[\/mask]\u0060**\n\n上面的 \u0060value\u0060 和掩码 \u0060mask\u0060 都是 32 位无符号整数，一般用 16 进制表示。内核设置数据包 nfmark 值的流程分为两步：\n\n1. 首先，内核会先用 mask 预处理数据包原来的 nfmark，处理方法是：如果 mask 的第 N 位（二进制）为 1，则将数据包的 nfmark 第的 N 位（二进制）清零（Zero out） ，如果 mask 的第 N 位为 0，那么数据包的 nfmark 位保持不变\n2. 再用上面预处理后的 nfmark 和 value 做异或运算，得到数据包最后的 nfmark 值。\n\n举个例子：假设我们设置了 \u0060--set-xmark 0x4000\/0xffffffff\u0060，掩码为 \u00600xffffffff\u0060，掩码表示为二进制的话 32 位每一位都是 \u00601\u0060，那么内核首先会将数据包原来的 \u0060nfmark\u0060 所有的位都清零（异或运算，相当于是先把 \u0060nfmark\u0060 置 0），然后再和 value 做异或操作，那么得到的最后的 \u0060nfmark\u0060 值就是 \u00600x4000\u0060。所以，数据包经过这条规则后，它的 nfmark 值就是 \u00600x4000\u0060。\n\n上面的掩码 \u0060mask\u0060 是个可选项，如果没有设置的话，默认为 \u00600xffffffff\u0060。\n\n根据上面的规则，省略 \u0060mask\u0060 的值或者将 \u0060mask\u0060 和 \u0060value\u0060 的值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF XOR value =value\u0060，\u0060value XOR value XOR value = value\u0060。\n\n**\u0060--set-mark value[\/mask]\u0060**\n\n设置步骤与上文类似。第一步预处理也是将原来的 \u0060nfmark\u0060 与 mask 进行异或运算，第二步不同，该方法是将预处理的 nfmark 和 value 做或（OR）运算。\n\n根据上面的规则，省略 \u0060mask\u0060 的值，或者将 \u0060mask\u0060 与 \u0060value\u0060 值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF OR value = value\u0060，\u00600 OR value = value\u0060）。\n\n查看 [netfilter 文档](https:\/\/ipset.netfilter.org\/iptables-extensions.man.html#lbDD) 了解详情。\n\n{{\u003c\/callout\u003e}}\n\n通过执行以上 iptables 规则，可以确保 Ambient Mesh 仅拦截 \u0060ztunnel-pods-ips\u0060 IP 集 Pod 中的数据包并给数据包打上 \u00600x100\/0x100\u0060 标记（\u0060nfmark\u0060，格式为 \u0060值\/掩码\u0060，值和掩码都是 32 位的二进制整数，），而不影响其他 Pod。\n\n{{\u003ccallout note \u0022关于 ztunnel-pods-ips IP 集\u0022\u003e}}\n\n\u0060ztunnel-pods-ips\u0060 是由 Istio CNI 创建的 [IP 集（IP Set）](https:\/\/ipset.netfilter.org\/)，这里面保存着该节点上 Ambient Mesh 中的所有 Pod 的 IP 地址。IP 集是 Linux 内核中的一个框架，可由 [ipset](https:\/\/ipset.netfilter.org\/ipset.man.html) 实用程序管理。IP 集可以存储不同类型的数据，例如 IP 地址、网络、（TCP\/UDP）端口号、MAC 地址、接口名称或它们的组合，从而确保在条目与集合匹配时具有闪电般的速度。\n\n{{\u003c\/callout\u003e}}\n\n{{\u003cdetail \u0022用 \u0060iptables -t nat -L\u0060 按顺序查看 iptables 规则，将可以更明显的看到路由路径。\u0022\u003e}}\n\n\u0060\u0060\u0060bash\n$ iptables -t nat -L\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n# 数据包首先进入 ztunnel-PREROUTING 链处理\nztunnel-PREROUTING  all  --  anywhere             anywhere\n# 然后进入 KUBE-SERVICES 链处理\nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nztunnel-POSTROUTING  all  --  anywhere             anywhere            \nKUBE-POSTROUTING  all  --  anywhere             anywhere             \/* kubernetes postrouting rules *\/\nIP-MASQ    all  --  anywhere             anywhere             \/* ip-masq: ensure nat POSTROUTING directs all non-LOCAL destination traffic to our custom IP-MASQ chain *\/ ADDRTYPE match dst-type !LOCAL\n\n\/* Omit KUBE-SVC chains *\/\n\nChain ztunnel-POSTROUTING (1 references)\ntarget     prot opt source               destination         \nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\nChain ztunnel-PREROUTING (1 references)\ntarget     prot opt source               destination   \n# 通过所有被打上 0x100\/0x100 标记的数据包\nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\u0060\u0060\u0060\n\n{{\u003c\/detail\u003e}}\n\n我们再查看一下该节点的路由规则：\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n路由表将按顺序执行，第一列表示的是路由表的优先级，第二列表示要查找或跳转的路由表。你会看到所有带有 \u00600x100\/0x100\u0060 标记的数据包将查找 101 路由表。我们再查看一下该路由表：\n\n\u0060\u0060\u0060bash\n$ ip route show table 101\ndefault via 192.168.127.2 dev istioout \n10.4.4.18 dev veth52b75946 scope link \n\u0060\u0060\u0060\n\n你会看到 \u0060101\u0060 路由表中带有关键字 \u0060via\u0060 ，这表示数据包将通过网关传输，查看 [ip route 命令的用法](http:\/\/linux-ip.net\/html\/tools-ip-route.html#tools-ip-route-show)。所有数据包被通过 \u0060istioout\u0060 网卡发送到网关（IP 是 \u0060192.168.127.2\u0060）。另一行表示是当前节点上 ztunnel pod 的路由链路。\n\n{{\u003ccallout note  \u0022关于 101 路由表\u0022\u003e}}\n所谓路由表（Routing Table），指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。为了完成这项工作，在路由器中保存着各种传输路径的相关数据，供路由选择时使用，表中包含的信息决定了数据转发的策略。路由表根据其建立的方法，可以分为**动态路由表**和**静态路由表**。\n\n101 路由表是由 Istio CNI 创建的，它的作用是将带有 \u00600x100\/0x00\u0060 fwmark 的数据包转发到 ztunnel 中。\n\n在 Linux 系统中，用户可以自定义编号 1 到 252 的路由表，Linux 系统维护了 4 个路由表：\n\n- 0：系统保留表\n- 253：defulte 表，没特别指定的默认路由都放在改表\n- 254：main 表，没指明路由表的所有路由放在该表，默认表，我们使用 \u0060ip route list\u0060 或 \u0060route -n\u0060 或 \u0060netstat -rn\u0060 查看的路由记录即为 main 表中的记录\n- 255：locale 表，保存本地接口地址，广播地址、NAT 地址 由系统维护，用户不得更改\n\n{{\u003c\/callout\u003e}}\n\n我们再查看一下 \u0060istioout\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioout\n24: istioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 62:59:1b:ad:79:01 brd ff:ff:ff:ff:ff:ff\n    geneve id 1001 remote 10.4.4.18 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535\n    inet 192.168.127.1\/30 brd 192.168.127.3 scope global istioout\n       valid_lft forever preferred_lft forever\n    inet6 fe80::6059:1bff:fead:7901\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\nPod A 中的 \u0060istioout\u0060 网卡通过 Geneve tunnel 与 ztunnel A 中的 \u0060pstioout\u0060 网卡连通。\n\n{{\u003ccallout note \u0022关于 istioout 网卡\u0022\u003e}}\n\n\u0060istioout\u0060 是一个 [Geneve（Generic Network Virtualization Encapsulation）](https:\/\/datatracker.ietf.org\/doc\/html\/draft-gross-geneve-00)类型的虚拟网卡，它的 IP 是 \u0060192.168.127.1\u0060，远端是 \u006010.4.2.19\u0060（节点 A 上的 ztunnel Pod 的 IP），网关是 \u0060192.168.127.2\u0060（节点 A 上 ztunnel Pod 中 \u0060pistioout\u0060 网卡的 IP，在下文会看到）。\n\n{{\u003c\/callout\u003e}}\n\n### 检查 Ztunnel A 上的路由规则 {#ztunnel-a-rules}\n\n进入 Ztunnel A Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11-20\u0022\u003e}}\n$ ip -d a\n1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 minmtu 0 maxmtu 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 127.0.0.1\/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0@if16: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1460 qdisc noqueue state UP group default \n    link\/ether 06:3e:d1:5d:95:16 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 minmtu 68 maxmtu 65535 \n    veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 10.4.2.1\/24 brd 10.4.4.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: pistioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether 06:18:ee:29:7e:e4 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.2\/30 scope global pistioin\n       valid_lft forever preferred_lft forever\n4: pistioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether aa:40:40:7c:07:b2 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1001 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.127.2\/30 scope global pistioout\n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n你将发现其中有两个网卡：\n\n- \u0060pistioin\u0060 ：IP 为 \u0060192.168.126.2\u0060\n- \u0060pistioout\u0060：IP 为 \u0060192.168.127.2\u0060\n\n{{\u003ccallout note \u0022关于 pistioin 和 pistioout 网卡\u0022\u003e}}\n\n这两个网卡都是由 ztunnel 中的 init 容器创建的 Geneve 类型的虚拟网卡，其 IP 地址也是固定的，如果你查看 ztunnel 的 YAML 配置将发现其中的网卡创建命令，在此我们按下不表，因为 Ambient 模式还在开发初期，这些启动命令未来可能有很大变化，感兴趣的读者可以自行查阅。\n\n{{\u003c\/callout\u003e}}\n\n自 Pod A 的流量进入 ztunnel 之后，如何对流量进行处理呢？答案是 iptables，查看 ztunnel A 中的 iptables 规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n*mangle\n:PREROUTING ACCEPT [185880:96984381]\n:INPUT ACCEPT [185886:96984813]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [167491:24099839]\n:POSTROUTING ACCEPT [167491:24099839]\n-A PREROUTING -j LOG --log-prefix \u0022mangle pre [ ztunnel-rts54] \u0022\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioout -p tcp -j TPROXY --on-port 15001 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\/* 省略 *\/\n{{\u003c\/highlight\u003e}}\n\n可以看到 ztunnel A 中的所有发往 \u0060pistioin\u0060 网卡的 TCP 流量透明转发到 \u006015001\u0060 端口（Envoy 的 outbound 端口），并打上了 \u00600x400\/0xfff\u0060 的标记。这个标记可以保证数据包发往正确的网卡。\n\n{{\u003ccallout note \u0022关于 tproxy\u0022\u003e}}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt)。\n\n{{\u003c\/callout\u003e}}\n\n查看 Ztunnel A 中的路由表。\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n20000:  from all fwmark 0x400\/0xfff lookup 100\n20001:  from all fwmark 0x401\/0xfff lookup 101\n20002:  from all fwmark 0x402\/0xfff lookup 102\n20003:  from all fwmark 0x4d3\/0xfff lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n你会看到所有标记 \u00600x400\/0xfff\u0060 的数据包应用 101 路由表，我们查看该路由表详情：\n\n\u0060\u0060\u0060bash\n$ ip route show table 100\nlocal default dev lo scope host \n\u0060\u0060\u0060\n\n你会看到这是一条本地路由，数据包发送到本地的回环网卡，即 \u0060127.0.0.1\u0060。\n\n以上就是 Pod 中出站流量的透明劫持过程。\n\n## Ztunnel A 上的出站流量路由 {#ztunnel-a-outbound}\n\n出站流量在被劫持到 Ztunnel 上，进入 Envoy 的 15001 端口处理。下面我们来查看 Ztunnel 如何路由出站流量。\n\n注意：Ztunnel 中的 Envoy 过滤器规则与 Sidecar 模式中的 Envoy 过滤器规则完全不同，我们不使用 \u0060istioctl proxy-config\u0060 命令来检视 Listener、Cluster、Endpoint 等配置，而是直接导出 ztunnel 中的 Envoy 完整配置。 \n\n我们直接在自己的本地机器上远程获取 ztunnel A 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system ztunnel-hptxk -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-a-all-include-eds.json\n\u0060\u0060\u0060\n\n注意：不要使用 \u0060istioctl proxy-config all ztunnel-rts54 -n istio-system\u0060 命令来获取 Envoy 配置，因为这样获取的配置中不包含 EDS 部分。导出的 Json 文件将有上万行，为了便于阅读，建议使用 [fx](https:\/\/github.com\/antonmedv\/fx) 或其他工具来解析该文件。\n\n### ztunnel_outbound 监听器 {#ztunnel_outbound-listener}\n\n在这个 Envoy 配置中包含了该节点上的所有 Pod 访问的流量规则配置，查看 \u0060ztunnel_outbound\u0060 Listener 部分配置（因配置太多，省略部分内容）：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 14 43 59 62 64 69 76 82 85 88-123\u0022\u003e}}\n{\n \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15001\n    }\n   },\n   \u0022filter_chains\u0022: [{...},...],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_dst\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_dst.v3.OriginalDst\u0022\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_src\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_src.v3.OriginalSrc\u0022,\n      \u0022mark\u0022: 1234\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.workload_metadata\u0022,\n     \u0022config_discovery\u0022: {\n      \u0022config_source\u0022: {\n       \u0022ads\u0022: {},\n       \u0022initial_fetch_timeout\u0022: \u002230s\u0022\n      },\n      \u0022type_urls\u0022: [\n       \u0022type.googleapis.com\/istio.telemetry.workloadmetadata.v1.WorkloadMetadataResources\u0022\n      ]\n     }\n    }\n   ],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [\n    {\n     \u0022description\u0022: \u0022Set socket mark to packets coming back from outbound listener\u0022,\n     \u0022level\u0022: \u00221\u0022,\n     \u0022name\u0022: \u002236\u0022,\n     \u0022int_value\u0022: \u00221025\u0022\n    }\n   ],\n   \u0022access_log\u0022: [{...}],\n   \u0022default_filter_chain\u0022: {\u0022filters\u0022: [...], ...},\n   \u0022filter_chain_matcher\u0022: {\n    \u0022matcher_tree\u0022: {\n     \u0022input\u0022: {\n      \u0022name\u0022: \u0022port\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n      }\n     },\n     \u0022exact_match_map\u0022: {\n      \u0022map\u0022: {\n       \u002215001\u0022: {\n        \u0022action\u0022: {\n         \u0022name\u0022: \u0022BlackHoleCluster\u0022,\n         \u0022typed_config\u0022: {\n          \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n          \u0022value\u0022: \u0022BlackHoleCluster\u0022\n         }\n        }\n       }\n      }\n     }\n    },\n    \u0022on_no_match\u0022: {\n     \u0022matcher\u0022: {\n      \u0022matcher_tree\u0022: {\n       \u0022input\u0022: {\n        \u0022name\u0022: \u0022source-ip\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.SourceIPInput\u0022\n        }\n       },\n       \u0022exact_match_map\u0022: {\n        \u0022map\u0022: {\n         \u002210.168.15.222\u0022: {...},\n         \u002210.4.4.19\u0022: {\n          \u0022matcher\u0022: {\n           \u0022matcher_tree\u0022: {\n            \u0022input\u0022: {\n             \u0022name\u0022: \u0022ip\u0022,\n             \u0022typed_config\u0022: {\n              \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput\u0022\n             }\n            },\n            \u0022exact_match_map\u0022: {\n             \u0022map\u0022: {\n              \u002210.8.4.226\u0022: {\n               \u0022matcher\u0022: {\n                \u0022matcher_tree\u0022: {\n                 \u0022input\u0022: {\n                  \u0022name\u0022: \u0022port\u0022,\n                  \u0022typed_config\u0022: {\n                   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n                  }\n                 },\n                 \u0022exact_match_map\u0022: {\n                  \u0022map\u0022: {\n                   \u00229080\u0022: {\n                    \u0022action\u0022: {\n                     \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n                     \u0022typed_config\u0022: {\n                      \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n                      \u0022value\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022\n                     }\n                    }\n                   }\n                  }\n                 }\n                }\n               }\n              },\n              {...}\n             }\n            }\n           }\n          }\n         },\n         \u002210.4.4.7\u0022: {...},\n         \u002210.4.4.11\u0022: {...},\n        }\n       }\n      },\n      \u0022on_no_match\u0022: {\n       \u0022action\u0022: {\n        \u0022name\u0022: \u0022PassthroughFilterChain\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n         \u0022value\u0022: \u0022PassthroughFilterChain\u0022\n        }\n       }\n      }\n     }\n    }\n   }\n  },\n  \u0022last_updated\u0022: \u00222022-11-11T07:33:10.485Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n- 第 10、11、59、62、64、69、76、82、85 行：Envoy 监听 15001 端口，处理内核中使用 tproxy 转发的流量；对于目的地是 15001 端口的数据包直接抛弃，对于目的地是其他端口的流量再根据源 IP 地址匹配决定数据包去向；\n- 第 43 行：使用 \u0060IP_TRANSPARENT\u0060 套接字选项，开启 tproxy 透明代理，转发目的地非 ztunnel IP 的流量包；\n-  第 88 到 123 行：根据源 IP（\u006010.4.4.19\u0060 是 Pod A 的 IP）、目的 IP（\u006010.8.14.226\u0060 是服务 B 的 Cluster IP）和端口（9080）规则匹配，数据包将被发往 \u0060spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0060 集群。\n\n### Sleep 集群\n\n我们再查看一下该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=5 6 18 23-37\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   }\n  },\n  \u0022transport_socket_matches\u0022: [\n   {\n    \u0022name\u0022: \u0022internal_upstream\u0022,\n    \u0022match\u0022: {\n     \u0022tunnel\u0022: \u0022h2\u0022\n    },\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n      \u0022passthrough_metadata\u0022: [\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022tunnel\u0022\n       },\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022istio\u0022\n       }\n      ],\n      \u0022transport_socket\u0022: {\n       \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n       }\n      }\n     }\n    }\n   },\n   {\n    \u0022name\u0022: \u0022tlsMode-disabled\u0022,\n    \u0022match\u0022: {},\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  ]\n },\n \u0022last_updated\u0022: \u00222022-11-08T06:40:06.619Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该 Cluster 配置使用 EDS 获取端点\n- 第 18 行：对所有具有 \u0060tunnel: h2\u0060 元数据的字节流应用 [\u0060InternalUpstreamTransport\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/internal_upstream\/v3\/internal_upstream.proto#envoy-v3-api-msg-extensions-transport-sockets-internal-upstream-v3-internalupstreamtransport)，用于内部地址，定义位于同一代理实例中的环回用户空间 socket。除了常规字节流之外，该扩展还允许跨用户空间 socket 传递额外的结构化状态（\u0060passthrough_metadata\u0060）。目的是促进下游过滤器和上游内部连接之间的通信。与上游连接共享的所有过滤器状态对象也通过此传输 socket 与下游内部连接共享。\n- 第 23 到 37 行：向上游传递的结构化数据；\n\n### Sleep 集群的端点 {#sleep-endpoints}\n\n我们再检查下 EDS，你会发现在众多的 \u0060endpoint_config\u0060 中有这样一条：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=4 13 20-30\u0022\u003e}}\n{\n \u0022endpoint_config\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n  \u0022cluster_name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022endpoints\u0022: [\n   {\n    \u0022locality\u0022: {},\n    \u0022lb_endpoints\u0022: [\n     {\n      \u0022endpoint\u0022: {\n       \u0022address\u0022: {\n        \u0022envoy_internal_address\u0022: {\n         \u0022server_listener_name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n         \u0022endpoint_id\u0022: \u002210.4.3.20:9080\u0022\n        }\n       },\n       \u0022health_check_config\u0022: {}\n      },\n      \u0022health_status\u0022: \u0022HEALTHY\u0022,\n      \u0022metadata\u0022: {\n       \u0022filter_metadata\u0022: {\n        \u0022envoy.transport_socket_match\u0022: {\n         \u0022tunnel\u0022: \u0022h2\u0022\n        },\n        \u0022tunnel\u0022: {\n         \u0022address\u0022: \u002210.4.3.20:15008\u0022,\n         \u0022destination\u0022: \u002210.4.3.20:9080\u0022\n        }\n       }\n      },\n      \u0022load_balancing_weight\u0022: 1\n     }\n    ]\n   }\n  ],\n  \u0022policy\u0022: {\n   \u0022overprovisioning_factor\u0022: 140\n  }\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 4 行：截止 2022 年 11 月 14 日，实际在导出 Envoy 配置的时候并没有该字段，但是理应有这个字段，否则无法判断 Endpoint 属于哪个 Cluster；\n- 第 13 行：该端点的地址是一个 \u0060envoy_internal_address\u0060，Envoy 内部监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060；\n- 第 20 - 30 行：定义过滤器元数据，使用 HBONE 隧道传递给 Envoy 内部监听器；\n\n{{\u003ccallout warning \u0022关于 endpoint_config 中未显示 cluster_name 字段的问题\u0022\u003e}}\n\n这里的 [\u0060endpoint_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/endpoint\/v3\/endpoint.proto) 中缺少了必选的 \u0060cluster_name\u0060 字段，这可能是 Ambient 模式的一个 bug 导致了在导出 Envoy 的配置时缺少了该字段。我在 GItHub 上创建了一个 Issue 来追踪这个问题，详见 [Istio Issue-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)。\n\n{{\u003c\/callout\u003e}}\n\n### 通过 Envoy 内部监听器建立 HBONE 隧道 {#sleep-internal-upstream}\n\n我们再看下这个监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=16 18-28 40\u0022\u003e}}\n{\n \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.tcp_proxy\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\u0022,\n        \u0022stat_prefix\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022cluster\u0022: \u0022outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022access_log\u0022: [{...}, ...],\n        \u0022tunneling_config\u0022: {\n         \u0022hostname\u0022: \u0022%DYNAMIC_METADATA(tunnel:destination)%\u0022,\n         \u0022headers_to_add\u0022: [\n          {\n           \u0022header\u0022: {\n            \u0022key\u0022: \u0022x-envoy-original-dst-host\u0022,\n            \u0022value\u0022: \u0022%DYNAMIC_METADATA([\\\u0022tunnel\\\u0022, \\\u0022destination\\\u0022])%\u0022\n           }\n          }\n         ]\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \u0022use_original_dst\u0022: false,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    }\n   ],\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-08T06:40:06.750Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 14 行：数据包将被转发到 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群；\n- 第 18 - 28 行： [\u0060tunneling_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/network\/tcp_proxy\/v3\/tcp_proxy.proto#envoy-v3-api-msg-extensions-filters-network-tcp-proxy-v3-tcpproxy-tunnelingconfig) ，用来配置上游 HTTP CONNECT 隧道。另外该监听器中的 \u0060TcpProxy\u0060 过滤器将流量传给上游 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群。TCP 过滤器上设置了 HTTP CONNECT 隧道（承载发送到 \u006010.4.3.20:9080\u0060 的流量），供 \u0060productpage\u0060 所在节点的 ztunnel 使用。有多少个端点，就会创建多少条隧道。HTTP 隧道是 Ambient 组件之间安全通信的承载协议。同时在隧道中的数据包添加了 \u0060x-envoy-original-dst-host\u0060 header，根据上一步 EDS 中选择的端点的 \u0060metadata\u0060 里的参数设置目的地址。前面 EDS  选择的端点是 \u006010.4.3.20:9080\u0060 ，那么这里的 tunnel 监听器就会 header 的值设置为 \u006010.4.3.20:9080\u0060，请留意这个 header，它会在隧道的另一端被用到；\n- 第 40 行：监听器中首先执行监听器过滤器，\u0060set_dst_address\u0060 过滤器将上游地址设置为下游的目的地址。\n\n{{\u003ccallout note \u0022关于 HBONE 隧道\u0022\u003e}}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n{{\u003c\/callout\u003e}}\n\n### Sleep 集群的 HBONE 隧道端点 {#sleep-tunnel-cluster}\n\n我们再查看一下 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 22-41 45-47\u0022\u003e}}\n {\n \u0022version_info\u0022: \u00222022-11-11T07:30:10Z\/37\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022outbound_pod_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022connect_timeout\u0022: \u00222s\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022cleanup_interval\u0022: \u002260s\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\u0022,\n    \u0022common_tls_context\u0022: {\n     \u0022tls_params\u0022: {\n      \u0022tls_minimum_protocol_version\u0022: \u0022TLSv1_3\u0022,\n      \u0022tls_maximum_protocol_version\u0022: \u0022TLSv1_3\u0022\n     },\n     \u0022alpn_protocols\u0022: [\n      \u0022h2\u0022\n     ],\n     \u0022tls_certificate_sds_secret_configs\u0022: [\n      {\n       \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep~sleep-5644bdc767-2dfg7~85c8c34e-7ae3-4d29-9582-0819e2b10c69\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     ]\n    }\n   }\n  },\n  \u0022original_dst_lb_config\u0022: {\n   \u0022upstream_port_override\u0022: 15008\n  },\n  \u0022typed_extension_protocol_options\u0022: {\n   \u0022envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022,\n    \u0022explicit_http_config\u0022: {\n     \u0022http2_protocol_options\u0022: {\n      \u0022allow_connect\u0022: true\n     }\n    }\n   }\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:30:10.754Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，即前文中 EDS 获取到的地址 \u006010.4.3.20:9080\u0060；\n- 第 22 - 41 行：配置了上游的 TLS 证书；\n- 第 45 - 48 行：将上游端口修改为 15008；\n\n以上就是使用 tproxy 和 HBONE 隧道实现的出站流量透明劫持的全过程。\n\n## Inbound 流量劫持 {#inbound}\n\n节点 B 接收节点 A 对 \u006010.4.3.20:15008\u0060 的请求。Ambient 模式的入站流量劫持与出站流量类似，同样使用 tproxy 和 HBONE 实现透明流量劫持。\n\nAmbient mesh 的 pod 入站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioin\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 IP 集，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioin\u0060 虚拟机网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioin\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15008 端口；\n3. Envoy 对数据包进行处理后转发给 Pod B。\n\n因为操作步骤与上文中的检查出站流量时相同，因此下文将省略部分输出。\n\n### 检查节点 B 上的路由规则 {#node-b-rules}\n\n登录到服务 B 所在的节点 B，查看节点上的 iptables：\n\n\u0060\u0060\u0060bash\n$ iptables-save\n\/* 省略 *\/\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n\/* 省略 *\/\n\u0060\u0060\u0060\n\n你将看到在前文中提到的给所有 \u0060ztunnel-pods-ips\u0060 IP 集中 Pod 发送的数据包打上 \u00600x100\/0x100\u0060 标记的上一条命令：给所有数据包打上 \u00600x200\/0x200\u0060 标记，然后继续执行 iptables。\n\n查看节点 B 上的路由表：\n\n\u0060\u0060\u0060bash\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n所有 Ambient Mesh 节点中的路由表数量和规则是一样的，路由表规则将按顺序执行，首先查找 \u0060local\u0060 表，然后所有带有 \u00600x200\/0x200\u0060 标记的数据包将首先跳转到 \u0060main\u0060 表（其中定义了 veth 路由），然后查找 \u0060100\u0060 表，在 \u0060100\u0060 表中有以下规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=8\u0022\u003e}}\n$ ip route show table 100\n10.4.3.14 dev veth28865c45 scope link \n10.4.3.15 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.16 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.17 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.18 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.19 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.20 via 192.168.126.2 dev istioin src 10.4.3.1\n{{\u003c\/highlight\u003e}}\n\n你会看到发往 \u006010.4.3.20\u0060 的数据包将被路由到 \u0060istioin\u0060 网卡上的 \u0060192.168.126.2\u0060 网关。\n\n查看 \u0060istioin\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioin \n17: istioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 36:2a:2f:f1:5c:97 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.3.14 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.1\/30 brd 192.168.126.3 scope global istioin\n       valid_lft forever preferred_lft forever\n    inet6 fe80::342a:2fff:fef1:5c97\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n从输出中可以看到，\u0060istioin\u0060 是一个 Geneve 类型虚拟网卡，它创建了一个 Geneve 隧道，远端的 IP 是 \u006010.4.3.14 \u0060，这是 Ztunnel B 的 Pod IP。\n\n### 检查 Ztunnel B Pod 上的路由规则 {#ztunnel-b-rules}\n\n进入 Ztunnel B Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息，你会看到有一个 \u0060pistioout\u0060 网卡，它的 IP 为 \u0060192.168.127.2\u0060，这正是与 \u0060istioout\u0060 虚拟网卡建立的 Geneve 隧道的远端。\n\n使用 \u0060iptables-save\u0060 查看 Pod 内的 iptables 规则，你会看到：\n\n\u0060\u0060\u0060bash\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\u0060\u0060\u0060\n\n所有发往 \u006010.4.3.20:15008\u0060 的流量将使用 tproxy 被路由到 15008 端口。\n\n{{\u003ccallout note \u0022关于 15006 和 15008 端口\u0022\u003e}}\n\n- 15006 端口用于处理非加密的（plain）TCP 数据包。\n- 15008 端口用于处理加密的（TLS）TCP 数据包。\n\n{{\u003c\/callout\u003e}}\n\n以上就是 Pod 中入站流量的透明劫持过程。\n\n## Ztunnel B 上的入站流量路由 {#ztunnel-b-inbound}\n\n出站的 TLS 加密流量在被劫持到 Ztunnel 上，进入 Envoy 的 15008 端口处理。下面我们来查看 Ztunnel 如何路由入站流量。\n\n我们直接在自己的本地机器上远程获取 ztunnel B 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system \tztunnel-z4qmh -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-b-all-include-eds.json\n\u0060\u0060\u0060\n\n### ztunnel_inbound 监听器 {#ztunnel_inbound-listener}\n\n查看 \u0060ztunnel_inbound\u0060 监听器的详细信息：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 17-22 39-65 78-82\u0022\u003e}}\n\n{\n \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:12:01Z\/16\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15008\n    }\n   },\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filter_chain_match\u0022: {\n      \u0022prefix_ranges\u0022: [\n       {\n        \u0022address_prefix\u0022: \u002210.4.3.20\u0022,\n        \u0022prefix_len\u0022: 32\n       }\n      ]\n     },\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.rbac\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.rbac.v3.RBAC\u0022,\n        \u0022rules\u0022: {...},\n        \u0022stat_prefix\u0022: \u0022tcp.\u0022,\n        \u0022shadow_rules_stat_prefix\u0022: \u0022istio_dry_run_allow_\u0022\n       }\n      },\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_hcm\u0022,\n        \u0022route_config\u0022: {\n         \u0022name\u0022: \u0022local_route\u0022,\n         \u0022virtual_hosts\u0022: [\n          {\n           \u0022name\u0022: \u0022local_service\u0022,\n           \u0022domains\u0022: [\n            \u0022*\u0022\n           ],\n           \u0022routes\u0022: [\n            {\n             \u0022match\u0022: {\n              \u0022connect_matcher\u0022: {}\n             },\n             \u0022route\u0022: {\n              \u0022cluster\u0022: \u0022virtual_inbound\u0022,\n              \u0022upgrade_configs\u0022: [\n               {\n                \u0022upgrade_type\u0022: \u0022CONNECT\u0022,\n                \u0022connect_config\u0022: {}\n               }\n              ]\n             }\n            }\n           ]\n          }\n         ]\n        },\n        \u0022http_filters\u0022: [\n         {\n          \u0022name\u0022: \u0022envoy.filters.http.router\u0022,\n          \u0022typed_config\u0022: {\n           \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.http.router.v3.Router\u0022\n          }\n         }\n        ],\n        \u0022http2_protocol_options\u0022: {\n         \u0022allow_connect\u0022: true\n        },\n        \u0022access_log\u0022: [{...}],\n        \u0022upgrade_configs\u0022: [\n         {\n          \u0022upgrade_type\u0022: \u0022CONNECT\u0022\n         }\n        ]\n       }\n      }\n     ],\n     \u0022transport_socket\u0022: {\n      \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n      \u0022typed_config\u0022: {...} \n     },\n     \u0022name\u0022: \u0022inbound_10.4.3.20\u0022\n    },\n    {...}\n   ],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [{},...],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [{...}}],\n   \u0022access_log\u0022: [{...} ]\n  },\n  \u0022last_updated\u0022: \u00222022-11-14T03:54:07.040Z\u0022\n }\n}\n\n{{\u003c\/highlight\u003e}}\n\n从上面的配置中可以看出：\n\n- 发往 \u006010.4.3.20\u0060 的流量将被路由到 \u0060virtual_inbound\u0060 集群；\n- 第 78 - 82 行：[\u0060upgrade_type: \u0022CONNECT\u0022\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/route\/v3\/route_components.proto#config-route-v3-routeaction-upgradeconfig) 为 Envoy 的 HCM 启用 HTTP Connect 隧道，将该隧道中的 TCP 数据发送到上游；\n\n### virtual_inbound 集群 {#virtual_inbound-cluster}\n\n查看 \u0060virtual_inbound\u0060 集群的信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=6 9\u0022\u003e}}\n\n{\n \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022virtual_inbound\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022original_dst_lb_config\u0022: {\n   \u0022use_http_header\u0022: true\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:10:42.111Z\u0022\n}\n\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 7 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，表示使用下游的原始目的地作为路由目的地，即 \u006010.4.3.20:15008\u0060，显然这个地址中的端口不正确；\n- 第 9 行：[\u0060use_http_header\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/cluster\/v3\/cluster.proto#config-cluster-v3-cluster-originaldstlbconfig) 为 \u0060true\u0060 时将使用 HTTP header [\u0060x-envoy-original-dst-host\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#config-http-conn-man-headers-x-envoy-original-dst-host) 作为目的地址，而这个 header [在出站的 Ztunnel 中已设置](\/#sleep-internal-upstream)为 \u006010.4.3.20:9080\u0060，它将覆盖之前设置的目的地址；\n\n至此，入站流量被 ztunnel 准确地路由到了目的地。以上就是 Ambient 模式中不同节点间 L4 流量劫持和路由流程。\n\n## 总结 {#summary}\n\n为了方便演示，本文中展示的是不同节点上的服务 L4 网络访问数据包的路径，即使两个服务在同一个节点上路径也是类似的。根据本文中提供的操作说明，读者可以在自己的环境中尝试。Istio 的 Ambient 模式还在初级阶段，在笔者测试过程中，也发现导出的 Envoy 配置中 EDS 缺少 \u0060cluster_name\u0060 字段的问题（[Issue Istio-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)）。另外 Ambient 模式使用 Istio CNI 在节点中注入 iptables 规则，通过设置 \u0060nfmark\u0060 的方式拦截 Pod 的流量到 Ztunnel 中，这种方式可能造成对其他 CNI 的兼容性问题，[Merbridge](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/) 项目正在寻求使用 eBPF 来绕过 IPtables，从而无需安装 Istio CNI，这样也就不会存在 CNI 兼容性问题。\n\n在了解了 L4 流量路径之后，今后笔者会再分享 Ambient 模式中的 L7 流量路径，欢迎关注。\n\n## 参考{#reference}\n\n- [安装 Ambient Mesh - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/get-started-ambient\/)\n- [深入 Ambient Mesh - 流量路径 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/PpP0pmxdJR8PknHeR-pVHQ)\n- [一文读懂 Ambient Mesh 七层服务治理 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/TXMyxbzBSfuYNquOZJmZTg)\n- [深度剖析！Istio 共享代理新模式 Ambient Mesh - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/B0q73ACAvmY4SjW42A2GVw)\n- [Istio Ambient 模式流量管理实现机制详解（一）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n- [Istio Ambient 模式流量管理实现机制详解（二） - zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-2\/)\n- [Istio Ambient 模式流量管理实现机制详解（三）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-10-17-ambient-deep-dive-3\/)\n- [Merbridge 支持 Ambient Mesh，无惧 CNI 兼容性！- merbridge.io](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/)\n', '\/blog\/ambient-mesh-l4-traffic-path\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understand-istio-vs-and-dr/">如何理解 Istio 中的 VirtualService 和 DestinationRule？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 VirtualService 和 DestinationRule？', '本文将 Istio 中的流量治理与现实世界中的交通管理类比，可以帮助你快速理解 VirtualService 和 DestinationRule 设置的功能。', '\nIstio 在刚开源的时候就定义了几十个 CRD，其中用于流量治理的有 \u0060RouteRule\u0060、\u0060DestinationPolicy\u0060、\u0060EgressRule\u0060 等，后来推出了 [v1alpha3 API](https:\/\/istio.io\/v1.13\/blog\/2018\/v1alpha3-routing\/) 使用 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 等取代了之前的 API。但是这些资源对象的定义，并不像 Kubernetes 中那么直观，反而会有些难以理解，比如 \u0060VirtualService\u0060，只看名字你可能认为只是第一个了一个“虚拟的服务”，但实际并非如此。\n\n本文将为你通过与实际的交通做类比，直观简要的介绍 Istio 中的两个核心的用于流量治理的对象——\u0060VirtualService\u0060 和 \u0060DestinationRule\u0060。\n\n## 流量 vs 交通\n\n很多刚接触 Istio 的人可能对 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 和两个资源对象不是很理解，如果我们将环境仅限定于 Kubernetes 集群，我们可以将路由比喻成现实世界中的交通，有很多车辆在道路上行驶，这就是流量。\u0060DestinationRule\u0060 相当于开辟了道路\/路径\/车道，确保了两点之间可达并控制车道的数量、宽度等。而 \u0060VirtualService\u0060 就像是红绿灯和道路标线，指挥车辆向哪行驶和如何行驶。也就是说如果你只定义了 DR 将不会对流量产生任何影响，因为你没有指挥流量怎么走，所以你必须定义 VirtualService 才可以控制流量的走向。\n\n一句话来概括：DestinationRule 打通了两地之间的通路，犹如修路架桥通隧道，同时控制车道设路障；VirtualService 做车辆指挥调度。\n\n请看下面这张将流量与交通的对比图，可以帮助你更直观的理解这种比喻。\n\n![流量与交通对比图](traffic.jpg)\n\n## 流量治理\n\n下面列举了你分别可以在这两个资源对象上做的流量治理行为。\n\n**VirtualService**\n\n- 路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；\n- 错误注入：HTTP 错误代码注入、HTTP 延时注入；\n- 流量切分：基于百分比的流量切分路由；\n- 流量镜像：将一定百分比的流量镜像发送到其他集群；\n- 超时：设置超时时间，超过设置的时间请求将失败；\n- 重试：设置重试策略，如触发条件、重试次数、间隔时间等；\n\n**DestinationRule**\n\n- 负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；\n- 熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；\n\n## 总结\n\n本文将抽象的流量治理与现实中的交通管理相类比，帮助你更直观的理解 Istio 中的流量管理对象 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060。同时介绍了基于它们可以进行的流量治理功能。\u0060VirtualService\u0060 主要用于设置路由规则，而服务弹性（超时、重试、熔断等）需要靠它和 DestinationRule 来共同维持。\n\n## 参考\n\n- [Introducing the Istio v1alpha3 routing API - istio.io](https:\/\/istio.io\/v1.13\/blog\/2018\/v1alpha3-routing\/)\n- [Traffic Management - istio.io](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/)\n', '\/blog\/understand-istio-vs-and-dr\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将 Istio 中的流量治理与现实世界中的交通管理类比，可以帮助你快速理解 VirtualService 和 DestinationRule 设置的功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-canary-upgrade/">如何不停机升级 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何不停机升级 Istio？', '本文详述了使用金丝雀升级 Istio 的步骤及升级后的注意事项。', '\n## 开始之前\n\n截止到撰写本文时 Istio 的最高版本为 1.15.2，1.13 版本的官方支持已经结束。请对照 [Istio 文档中的发布状态描述](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases)确定是否需要对 Istio 进行升级。\n\nIstio 官网上给出了升级 Istio 的[几种方式](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/)：\n\n- 金丝雀升级\n- 原地升级\n- 使用 Helm 升级\n\n但实际上，为了减少在升级时对网格内业务的影响，建议在升级 Istio 的时候，使用 [canary upgrade](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)，它比 [in-place upgrade](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/in-place\/) 更加安全，而且支持回滚。使用 canary upgrade 支持跨越两个小版本，而 in-place upgrade 必须一个一个小版本的升级。不论使用哪种方式，其中 Ingress Gateway 都是 in-place upgrade 的。\n\n[Istio 官方文档](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)对升级的步骤描述的不是很详细，本文是对官方文档的一个补充，在升级完成后有两个注意事项：\n\n- 为需要自动 sidecar 注入的 namespace 打上对应的 label；\n- 删除原有的 \u0060validatingwebhookconfiguration\u0060 并添加新的；\n\n下面是详细的升级步骤。\n\n## 升级步骤\n\n使用的是以下命令安装的 canary 版本：\n\n\u0060\u0060\u0060bash\n# 将新版本的 revision 命名为 canary\nistioctl install --set revision=canary\n\n# 取消原先自动注入 sidecar 的 namespace 中的 label 并设置新的 label，这样该 namespace 就可以注入 canary 版本对应的 sidecar\nkubectl label namespace test-ns istio-injection- istio.io\/rev=canary\n\n# 重启数据平面中的工作负载，将完成新版本的 sidecar 自动注入\nkubectl rollout restart deployment -n test-ns\n\u0060\u0060\u0060\n\n注意在升级完成后，为新的 namespace 开启 sidecar 自动注入时，需要给 namespace 打上安装 canary Istio 时候设置的 label，执行下面的命令：\n\n\u0060\u0060\u0060bash\nkubectl label namespace new-ns istio-injection- istio.io\/rev=canary\n\u0060\u0060\u0060\n\n## Istio 升级完成后的注意事项\n\n在升级完成后，还有一些注意事项。例如如果你已经为其他 namespace 打上了 sidecar 自动注入的 label，请一定要将它删掉，并将 label 设置为 \u0060istio.io\/rev=canary\u0060，因为可以保证在 pod 中注入新版被 sidecar，并且连接到新版的 Istiod。\n\n另外，你需要把最早安装 Istio 时设置的 \u0060ValidatingWebhookConfiguration\u0060 删掉，执行下面的命令：\n\n\u0060\u0060\u0060bash\nkubectl delete validatingwebhookconfiguration istiod-default-validator\n\u0060\u0060\u0060\n\n{{\u003ccallout note \u0022关于 ValidatingWebhookConfiguration\u0022\u003e}}\n\n在你安装新版本的 Istio 的时候，会自动创建一个名为 \u0060istio-validator-canary-istio-system\u0060 的 ValidatingWebhookConfiguration，该配置的目的是在创建和更新 Istio CR 的时候，先检测所有连接的 Istiod 是否有效。关于动态准入控制的详细描述请见 [Kubernetes 文档](https:\/\/kubernetes.io\/zh-cn\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/)。\n\n{{\u003c\/callout\u003e}}\n\n因为在安装新版本 Istio 的时候，安装了新的 \u0060istio-validator-canary-istio-system\u0060。如果你不将旧的删除话，你在创建 Istio CR 的时候将会看到如下错误。\n\n\u0060\u0060\u0060\nError from server (InternalError): error when creating \u0022samples\/bookinfo\/networking\/bookinfo-gateway.yaml\u0022: Internal error occurred: failed calling webhook \u0022validation.istio.io\u0022: failed to call webhook: Post \u0022https:\/\/istiod.istio-system.svc:443\/validate?timeout=10s\u0022: service \u0022istiod\u0022 not found\n\u0060\u0060\u0060\n\n以上内容在 Istio 的官方文档中里并没有说明，但是在 [Istio Issue-36526](https:\/\/github.com\/istio\/istio\/issues\/36526) 中有提及。\n\n## 参考\n\n- [动态准入控制 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/)\n- [Istio Supported Releases - istio.io](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/)\n- [Canary Upgrades - istio.io](https:\/\/istio.io\/latest\/docs\/setup\/upgrade\/canary\/)\n', '\/blog\/istio-canary-upgrade\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详述了使用金丝雀升级 Istio 的步骤及升级后的注意事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-mode/">关于 Istio 推出 ambient 数据平面模式的看法</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/09/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('关于 Istio 推出 ambient 数据平面模式的看法', '本文介绍了 Ambient 模式并阐述了笔者对于 Istio 新推出的 ambient mesh（环境网格）的看法。', '\n今天 [Istio 社区推出了 Ambient Mesh](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)，这是一种新的 Istio 数据平面模式，旨在简化操作、扩大应用兼容性并降低基础设施成本。用户可以选择将 Ambient Mesh 集成到其基础设施的网格数据平面，放弃 sidecar 代理，同时保持 Istio 的零信任安全、遥测和流量管理等核心功能。该模式目前还是预览版，Istio 社区准备在未来几个月内将其推向生产就绪。\n\nAmbient Mesh 推出的消息对于社区来说可能显得有些突然，但其实关于 sidecar 模式对于资源的消耗过大，以及简化服务网格的呼声在社区里已经存在很久了，Google 从多年前就在寻求 HBONE（HTTP-Based Overlay Network Environment，基于 HTTP 的重叠网络环境）解决方案，还有社区提出的[多种 sidecar 部署模式](\/blog\/beyond-istio-oss\/#sidecar-management)、[proxyless 模式](\/blog\/beyond-istio-oss\/#proxyless-pattern) 等都是为了解决这个问题。\n\n## 什么是 Ambient 模式？{#what-is-ambient-mode}\n\nAmbient 模式是 Istio 社区在 2022 年 9 月推出的一种无 sidecar 的 Istio 数据平面部署模式，下图展示了 Ambient 模式的架构。\n\n![Ambient 模式架构](ambient-mesh-arch.svg)\n\n从图中我们可以看到 Ambient 模式对应用程序本身没有任何侵入，而是在应用程序外围：\n\n1. 同 node 上部署 ztunnel：使用 Envoy 实现的共享代理，多租户模式，负责 L4 网络，主要是安全性方面；\n2. 以服务账户为单位部署 Waypoint proxy：同样使用 Envoy 实现，单租户模式，使用 Gateway API 部署的 Gateway 资源，负责 L7 网络，当服务需要 L7 网络功能的时候才部署；\n\n下面是 Ambient 模式的功能分层。\n\n![Ambient 模式的功能分层](ambient-mesh-layers.svg)\n\n关于 Ambient 模式的更多介绍请阅读：\n\n- [Istio 无 sidecar 代理数据平面 ambient 模式简介](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)\n- [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/)\n- [什么是 Ambient Mesh，它与 sidecar 模式有什么区别？](https:\/\/cloudnative.to\/blog\/what-is-ambient-mesh\/)\n\n## Ambient 模式的核心技术 {#ambient-core}\n\nAmbient 模式中的 ztunnel 和 Waypoint proxy 目前还是使用 Envoy 来实现的，未来不排除使用其他语言（非 C\u002b\u002b，如 Rust）来实现一个轻量级的 ztunnel。该模式的核心是所谓的 HBONE（HTTP Based Overlay Network Environment，基于 HTTP 的覆盖网络环境）。\n\nHBONE 基于 HTTP\/2 CONNECT，将工作负载之间的请求以流的形式进行隧道传输，尽可能地复用 HTTP\/2 连接。HBONE 对工作负载来说是透明的，支持更好的传输机制：\n\n- 支持多协议，包括 Server First 协议，如 MySQL。Istio 可以自动检测出 HTTP 和 HTTP\/2 流量。如果未自动检测出协议，流量将会视为普通 TCP 流量。对于 Server First 协议必须明确声明，否则将作为 TCP 流量处理；\n- 对于使用自己 TLS 证书的应用程序可以逐步采用 Istio；\n- 支持绕过 Istio mTLS 封装直接调用 Pod IP；\n\n## Sidecar 模式的限制 {#sidecar-limitations}\n\n其实 ambient 模式的出现，主要是因为 sidecar 模式有以下限制：\n\n- Sidecar 容器不是 pod 中的一等公民，它的生命周期不受控制，有可能在 sidecar 就没准备好的情况下，pod 就开始接收连接，让 sidecar 的生命周期与应用程序 pod 绑定，这本身就是对应用程序的一种侵入\n- Sidecar 无法解释不规范的七层系列，如 HTTP 和 gRPC；\n- 如果仅需服务网格的安全功能，那么引入 sidecar 是一次过大的投资，因为它增加了很多七层网络功能，这些是用不到的，客户无法做到渐进式采用服务网格；\n- Sidecar 升级时，应用程序需要重新部署或者启动，这需要对应用程序进行协调；\n\n## 关于 Ambient 模式的看法 {#ambient-insight}\n\n本文我将谈谈对 ambient 模式的几点看法：\n\n1. **关于 Ambient Mesh 的命名**：我觉得叫做 **Ambient Mode** 会更好，有些接触 Istio 的初学者可能会觉得它是一种全新的不同于 Istio 的 service mesh；另外关于这个模式的中文翻译，如果直接翻译成“环境网格”似乎让人很难理解，我还想到了其他词汇，如“外围”、“氛围”、“周围”、“环绕”、”情景”等，没有一个汉语词汇可以准确表达这个 ambient 的含义，因为相对于 sidecar 模式，ambient 模式对应用程序 pod 没有侵入性，暂且将其称之为**外围模式**。\n2. **Ambient Mode 的本质**：它的本质是分离 sidecar proxy（Envoy）中的 L4 和 L7 功能，让一部分仅需要安全功能的用户可以最小阻力（低资源消耗、运维成本）地使用 Istio service mesh。\n3. **Ambient Mode 的意义**：因为它 sidecar 模式兼容，用户在采纳 Ambient Mode 获得了 mTLS 和有限的可观测性及 TPC 路由等 L4 功能，之后可以更方便的过度到 sidecar mode 以获得完全的 L7 功能。这给用户采纳 Istio 提供了更多模式选择，优化了 Istio 采纳路径。\n4. **Ambient Mode 的坏处**：Proxyless、sidecar、ambient 模式，使得 Istio 越来越复杂，用户理解起来更加费力；控制平面为了支持多种数据平面部署模式，其实现将更加复杂。\n5. **与其他服务网格的关系**：有的 service mesh 从原先的 per-proxy per-node 模式转变为 sidecar mode，如 Linkerd；还有的从 CNI 做到 service mesh，如 Cilium 使用 per-proxy per-node 模式；如今 Istio 在 sidecar mode 的基础上增加了 ambient mode，这也是目前唯一同时支持这两种部署模式的服务网格，为用户提供了多样的选择。\n6. **安全问题**：虽然 [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/) 说明了 ambient 模式的设计主旨是为了将应用程序与数据平面分离，让安全覆盖层的组件（ztunnel）处于类似于 CNI 的网格底层，考虑到 ztunnel 有限的 L4 攻击面，该模式的安全风险是可以接受的；但是，ztunnel 作为 DaemonSet 部署在每个节点上，需要处理和分发调度到该节点上的所有 pod 的证书来建立 mTLS 连接，一旦 一个 ztunnel 被攻破，它的爆炸半径确实是大于一个 sidecar，安全详解的博客中说 Envoy 的 CVE 问题会影响所有 sidecar，升级 sidecar 也会带来很大的运营成本，所以权衡之下选择 ambient 模式，安全问题再次给用户造成了困惑，不过最终选择的权利还是在用户自己。\n\n## 安装试用 {#setup}\n\n参考 [Istio 官网中的步骤](https:\/\/istio.io\/latest\/blog\/2022\/get-started-ambient\/)安装：\n\n1. [下载 Ambient Mesh 预览版](https:\/\/gcsweb.istio.io\/gcs\/istio-build\/dev\/0.0.0-ambient.191fe680b52c1754ee72a06b3e0d3f9d116f2e82)；\n\n2. 检查 Kubernetes 版本，建议的大于等于 1.21；\n\n3. 安装 Ambient profile：\n\n   \u0060\u0060\u0060bash\n   istioctl install --set profile=ambient\n   \u0060\u0060\u0060\n\n4. 部署示例应用：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n   kubectl apply -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/sleep.yaml\n   kubectl apply -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/notsleep.yaml\n   kubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n   \u0060\u0060\u0060\n\n5. 将应用添加到 Ambient Mesh：\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio.io\/dataplane-mode=ambient\n   \u0060\u0060\u0060\n\n6. 发送测试流量：\n\n   \u0060\u0060\u0060bash\n   kubectl exec deploy\/sleep -- curl -s http:\/\/istio-ingressgateway.istio-system\/productpage | head -n1\n   kubectl exec deploy\/sleep -- curl -s http:\/\/productpage:9080\/ | head -n1\n   kubectl exec deploy\/notsleep -- curl -s http:\/\/productpage:9080\/ | head -n1\n   \u0060\u0060\u0060\n\n7. 在将 Pod 加入到 Ambient Mesh 中之后，就可以给这些 Pod 应用 L4 的授权策略：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: security.istio.io\/v1beta1\n   kind: AuthorizationPolicy\n   metadata:\n    name: productpage-viewer\n    namespace: default\n   spec:\n    selector:\n      matchLabels:\n        app: productpage\n    action: ALLOW\n    rules:\n    - from:\n      - source:\n          principals: [\u0022cluster.local\/ns\/default\/sa\/sleep\u0022, \u0022cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022]\n   EOF\n   \u0060\u0060\u0060\n\n   上面这个策略只允许 sleep 服务和 istio ingress gateway 访问 productpage。\n\n8. 应用 L7 策略：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1alpha2\n   kind: Gateway\n   metadata:\n    name: productpage\n    annotations:\n      istio.io\/service-account: bookinfo-productpage\n   spec:\n    gatewayClassName: istio-mesh\n   EOF\n   \u0060\u0060\u0060\n\n   使用 Gateway API 创建了一个 Gateway，这里实际是在 \u0060default\u0060 命名空间下创建了一个 waypoint proxy，专门用于处理 L7 流量。\n\n   在给它应用授权策略：\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: security.istio.io\/v1beta1\n   kind: AuthorizationPolicy\n   metadata:\n    name: productpage-viewer\n    namespace: default\n   spec:\n    selector:\n      matchLabels:\n        app: productpage\n    action: ALLOW\n    rules:\n    - from:\n      - source:\n          principals: [\u0022cluster.local\/ns\/default\/sa\/sleep\u0022, \u0022cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022]\n      to:\n      - operation:\n          methods: [\u0022GET\u0022]\n   EOF\n   \u0060\u0060\u0060\n\n   这个策略跟之前有所不同的是最后的 \u0060to\u0060 字段定义了 HTTP 方法，现在你在 sleep pod 中对 productpage 服务执行除 GET 以外的其他请求都将失败。从 notsleep pod 中对 productpage 服务的 GET 请求将成功。\n\n   现在你可以从前面创建的这个 productpage Gateway 中获取到 HTTP 请求的 Prometheus 指标信息。\n\n   \u0060\u0060\u0060bash\n   kubectl exec deploy\/bookinfo-productpage-waypoint-proxy -- curl -s http:\/\/localhost:15020\/stats\/prometheus | grep istio_requests_total\n   \u0060\u0060\u0060\n\n9. **给 Reviews 服务创建 Gateway（Waypoint proxy），所有访问 Reviews 服务的 L7 流量都会经过它。**\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1alpha2\n   kind: Gateway\n   metadata:\n    name: reviews\n    annotations:\n      istio.io\/service-account: bookinfo-reviews\n   spec:\n    gatewayClassName: istio-mesh\n   EOF\n   \u0060\u0060\u0060\n\n   再给它应用流量划分：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f samples\/bookinfo\/networking\/virtual-service-reviews-90-10.yaml\n   kubectl apply -f samples\/bookinfo\/networking\/destination-rule-reviews.yaml\n   \u0060\u0060\u0060\n\n   发送 100 次请求测试流量切分结果。\n\n   \u0060\u0060\u0060bash\n   kubectl exec -it deploy\/sleep -- sh -c \u0027for i in $(seq 1 100); do curl -s http:\/\/istio-ingressgateway.istio-system\/productpage | grep reviews-v.-; done\u0027\n   \u0060\u0060\u0060\n\n   你将获得请求结果，说明一切运行正常。\n\n10. 清理环境和删除 Istio。\n\n    \u0060\u0060\u0060bash\n    kubectl delete -f samples\/bookinfo\/networking\/virtual-service-reviews-90-10.yaml\n    kubectl delete -f samples\/bookinfo\/networking\/destination-rule-reviews.yaml\n    kubectl delete -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n    kubectl delete -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/sleep.yaml\n    kubectl delete -f https:\/\/raw.githubusercontent.com\/linsun\/sample-apps\/main\/sleep\/notsleep.yaml\n    kubectl delete namespace istio-system\n    kubectl label namespace default istio.io\/dataplane-mode-   \n    \u0060\u0060\u0060\n\n## 如何开启 Ambient Mesh？{#enable-ambient}\n\n在安装有 Istio 的 Kubernetes 中部署了你的应用之后，如果想要给命名空间 \u0060ns-a\u0060 启用 Ambient Mode，只需要运行：\n\n\u0060\u0060\u0060bash\nkubectl label namespace ns-a istio.io\/dataplane-mode=ambient\n\u0060\u0060\u0060\n\nAmbient Mesh 默认启用 L4 安全。\n\n## 如何启用 L7 网络功能？{#enable-l7}\n\nAmbient 模式的 L7 网络功能是按需启用的：假如你想给服务 A 访问服务 B 的路径开启 L7 网络功能，那么你需要给服务 B 创建 Gateway。\n\n另外，L7 网络功能是与服务账户绑定的，假如服务 \u0060svc-a\u0060 的服务账户是 \u0060sa-svc-a\u0060，那么给它部署一个 Gateway：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n name: svc-a\n annotations:\n   istio.io\/service-account: sa-svc-a\nspec:\n gatewayClassName: istio-mesh\n\u0060\u0060\u0060\n\n然后你就可以创建 \u0060VirtualService\u0060、\u0060DestinationRule\u0060 等资源管理服务 \u0060svc-a\u0060。\n\n该 Gateway 实际上是一个 Deployment，它可以部署在与应用程序不同的命名空间中，你可以对这个 Deployment 单独管理和扩缩容。\n\n## Ambient 模式的限制 {#limitation}\n\n目前 ambient 模式的代码位于 Istio 代码库的 [\u0060experimental-ambient\u0060 分支](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient)，[根据 Matt Klein 和 Louis Ryan 的说法](https:\/\/twitter.com\/mattklein123\/status\/1567870635568955392?ref_src=twsrc%5Etfw)，ztunnel 和 Waypoint proxy 是用 Envoy 实现的，其中 ztunnel 是精简后的 Envoy，只负责 L4 功能且继续使用 xDS 协议来控制。但是 ambient 模式依然有很多[限制](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#limitations)，例如：\n\n- 对 Kubernetes 版本的要求不低于 1.21\n- 不支持 \u0060EnvoyFilter\u0060；\n- 不支持 IPv6；\n- 直接对 Pod IP 而不是 service 的请求在某些情况下将无效；\n- Ambient 模式下的服务无法通过 \u0060LoadBalancer\u0060 和 \u0060NodePort\u0060 方式访问，不过你可以部署一个入口网关（未启用 ambient 模式）以从外部访问服务；\n- 不支持 Calico CNI 和 Dataplane V2 CNI，因为 Ambient 模式会使用 Istio CNI，与其他 CNI 冲突；\n\n[这里](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#supported-environments)有安装 ambient 模式的详细环境要求。\n\n## 更多 {#more}\n\n以上就是笔者对 ambient 模式（外围模式）的看法，该模式还处于试验阶段，但绝不是玩具，据信已在某些场景试验过。笔者也将继续追踪该模式的最新进展，请保持关注。也欢迎更多关注 Istio 的朋友[加入云原生社区 Istio 讨论群](https:\/\/cloudnative.to\/community\/join\/)，与社区大咖一起探讨，或者在本文下面评论聊聊你的看法。\n', '\/blog\/istio-ambient-mode\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Ambient 模式并阐述了笔者对于 Istio 新推出的 ambient mesh（环境网格）的看法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-arm64-support/">Istio 1.15 新增对 arm64 架构处理器的支持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/08/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.15 新增对 arm64 架构处理器的支持', '随着 Istio 1.15 的发布，你可以很方便得在 arm64 架构上部署 Istio。', '\nIstio 是基于容器的云原生技术栈的三大核心技术之一，另外两个是 Kubernetes 和 Knative。其中 Kubernetes 和 Knative 早已支持了 arm64 架构，甚至连 Istio 的数据平面 Envoy 早在 [1.16 版本](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.16.0\/install\/building#arm-binaries)就已支持 arm64 架构（2020 年 10 月）。随着 [Istio 1.15 的发布](https:\/\/istio.io\/latest\/news\/releases\/1.15.x\/announcing-1.15\/)，你可以开箱即用得在 arm64 架构上部署 Istio，不需要自己来编译 arm 架构的镜像。\n\n## 在 Istio 1.15 之前如何在 arm 架构上安装 Istio？\n\nIstio 默认使用 Docker Hub 作为生产镜像仓库，Google Container Registry 作为生产和测试仓库。对于 1.14 及以前的版本，Istio 官方的镜像仓库中只有 amd64 架构的镜像，如果你的 Kubernetes 集群是运行在 arm 架构下，在安装 Istio 时会出现出现如下错误：\n\n\u0060\u0060\u0060\nexec user process caused: exec format error\n\u0060\u0060\u0060\n\n这时你需要为 Istio 安装重新指定一个包含 arm64 架构镜像的仓库，在安装 Istio 时执行下面的命令指定该镜像仓库：\n\n\u0060\u0060\u0060bash\n$ istioctl install --set profile=demo --set hub=docker.io\/mydockerhub -y\n\u0060\u0060\u0060\n\n此时要想在 arm64 架构上使用 Istio，你可以使用 Istio 社区中有人为 Istio 单独构建了 arm64 架构的[镜像](https:\/\/github.com\/resf\/istio)，或者自己构建镜像。\n\n## Istio 为了支持 arm 做了哪些工作？\n\n为了让 Istio 支持 arm，需要将以下二进制文件或者镜像基于 arm 架构编译：\n\n- \u0060istioctl\u0060：这是最简单的部分，只需要使用 Go 语言的交叉编译即可，Istio 的早期版本就已经支持；\n- \u0060pilot\u0060：控制平面 Istiod 中运行的镜像；\n- \u0060proxyv2\u0060：在 Ingress Gateway、Egress Gateway 和 Sidecar 中使用的镜像，通过 Kubernetes [mutating webhook](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/#mutatingadmissionwebhook) 自动注入；\n\nIstio 数据平面中的 Envoy 是从 Envoy 官方仓库中 fork 出来的，但是 Envoy 早就支持了 arm64，为什么 Istio 官方还不支持呢？这是因为一方面 Istio 的官方 CI 环境 [prow.istio.io](https:\/\/prow.istio.io\/) 运行在 GKE 上的，而 GKE 上并没有 arm64 架构的环境，所以无法执行测试。直到 2022 年 7 月 GKE 才正式提供 arm64 架构的虚拟机，那时才可以方便的编译和测试 arm64 架构的 Istio，详见 [Run your Arm workloads on Google Kubernetes Engine with Tau T2A VMs](https:\/\/cloud.google.com\/blog\/products\/containers-kubernetes\/gke-supports-new-arm-based-tau-t2a-vms)。\n\n{{\u003ccallout note 注意\u003e}}\n\nIstio 官方仅提供了 amd64 和 arm64 架构的镜像，不支持 arm32。\n\n{{\u003c\/callout\u003e}}\n\n至于 arm 架构的镜像构建，可以使用 Docker BuildKit 来实现多平台构建，你可以使用下面的命令编译指定 arm 平台架构的镜像：\n\n\u0060\u0060\u0060bash\ndocker buildx build --platform linux\/arm64\n\u0060\u0060\u0060\n\n关于 \u0060docker buildx\u0060 的详细信息请参考 [Docker 文档](https:\/\/docs.docker.com\/build\/buildx\/multiplatform-images\/)。\n\n你可以像往常一样来安装 Istio，Kubernetes Node 会根据节点的架构自动拉起对应平台架构的镜像。\n', '\/blog\/istio-arm64-support\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">随着 Istio 1.15 的发布，你可以很方便得在 arm64 架构上部署 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/5/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/7/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/page/10/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
