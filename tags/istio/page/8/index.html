<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-sidecar-traffic-types/">Istio sidecar 中的流量类型及 iptables 规则详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio sidecar 中的流量类型及 iptables 规则详解', '本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。', '\n我在[之前的一篇博客中](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/)讲解过 Istio 中 sidecar 的注入、使用 iptables 进行透明流量拦截及流量路由的详细过程，并以 Bookinfo 示例中的 \u0060productpage\u0060 服务访问 \u0060reviews\u0060 服务，和 \u0060reviews\u0060 服务访问 \u0060ratings\u0060 服务为例绘制了透明流量劫持示意图。在那个示意图中仅展示了 \u0060reviews\u0060 pod 接收流量和对外访问的路由，实际上 sidecar 内的流量远不止于此。\n\n## ISTIO_OUTPUT 规则\n\n在所有的 iptables 调用链中最复杂的一个是 \u0060ISTIO_OUTPUT\u0060，其中共有 9 条规则如下：\n\n| **Rule** | **Target**        | **In** | **Out** | **Source** | **Destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n\n本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，以示意图的形式带你一览其全貌，其中详细指出了路由具体使用的是 \u0060ISTIO_OUTPUT\u0060 中的哪一条规则。\n\n## Sidecar 中的 iptables 流量路由\n\nSidecar 中的流量可以划分为以下几类：\n\n- 远程服务访问本地服务：Remote Pod -\u003e Local Pod\n- 本地服务访问远程服务：Local Pod -\u003e Remote Pod\n- Prometheus 抓取本地服务的 metrics：Prometheus -\u003e Local Pod\n- 本地 Pod 服务间的流量：Local Pod -\u003e Local Pod\n- Envoy 内部的进程间 TCP 流量\n- Sidecar 到 Istiod 的流量\n\n下面将依次解释每个场景下 Sidecar 内的 iptables 路由规则。\n\n## 类型一：Remote Pod -\u003e Local Pod\n\n以下是远程服务、应用或客户端访问数据平面本地 Pod IP 的 iptables 规则。\n\nRemote Pod -\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060 -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n我们看到流量只经过一次 Envoy 15006 Inbound 端口。这种场景下的 iptables 规则的示意图如下。\n\n![Remote Pod 到 Local Pod](remote-pod-local-pod.svg)\n\n## 类型二：Local Pod -\u003e Remote Pod\n\n以下是本地 Pod IP 访问远程服务经过的 iptables 规则。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e ISTIO_REDIRECT -\u003e Envoy 15001 (Outbound)-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060 -\u003e Remote Pod\n\n我们看到流量只经过 Envoy 15001 Outbound 端口。\n\n![Local Pod 到 Remote Pod](local-pod-remote-pod.svg)\n\n以上两种场景中的流量都只经过一次 Envoy，因为该 Pod 中只有发出或接受请求一种场景发生。\n\n## 类型三：Prometheus -\u003e Local Pod\n\nPrometheus 抓取数据平面 metrics 的流量不会也无须经过 Envoy 代理。\n\n这些流量通过的 iptables 规则如下。\n\nPrometheus-\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060（对目的地为 15020、15090 端口流量将转到 \u0060INPUT\u0060）-\u003e \u0060INPUT\u0060 -\u003e  Local Pod\n\n这种场景下的 iptables 规则的示意图如下。\n\n![Prometheus 到 Local Pod](prometheus-local-pod.svg)\n\n## 类型四：Local Pod -\u003e Local Pod\n\n一个 Pod 可能同时存在两个或多个服务，如果 Local Pod 访问的服务也在该当前 Pod 上，流量会依次经过 Envoy 15001 和 Envoy 15006 端口最后到达本地 Pod 的服务端口上。\n\n这些流量通过的 iptables 规则如下。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e \u0060ISTIO_REDIRECT\u0060 -\u003e Envoy 15001（Outbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 2** -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n![Local Pod 到 Local Pod](local-pod-local-pod.svg)\n\n## 类型五：Envoy 内部的进程间 TCP 流量\n\nEnvoy 内部进程的 UID 和 GID 为 1337，它们之间的流量将使用 lo 网卡，使用 localhost 域名来通信。\n\n这些流量通过的 iptables 规则如下。\n\nEnvoy 进程（Localhost） -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 8** -\u003e \u0060POSTROUTING\u0060 -\u003e Envoy 进程（Localhost）\n\n![Envoy 内部的进程间 TCP 流量](envoy-internal-tcp-traffic.svg)\n\n## 类型六：Sidecar 到 Istiod 的流量\n\nSidecar 需要访问 Istiod 以同步配置，\u0060pilot-agent\u0060 进程会向 Istiod 发送请求，以同步配置。\n\n这些流量通过的 iptables 规则如下。\n\n\u0060pilot-agent\u0060 进程 -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060Istio_OUTPUT\u0060 RULE 9** -\u003e Envoy 15001 (Outbound Handler) -\u003e OUTPUT -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060  -\u003e Istiod\n\n![Sidecar 到 Istiod 的流量](sidecar-istiod.svg)\n\n## 总结\n\nIstio 注入在 Pod 内或虚拟机中安装的所有 sidecar 代理组成了服务网格的数据平面，也是 Istio 的主要工作负载所在地，通过 [Istio 中的透明流量劫持](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/) 及这篇博客，相信你一定对 sidecar 代理中的流量有了一个深刻的了解，但这还只是管中窥豹，略见一斑，在我的[下一篇博客](https:\/\/jimmysong.io\/blog\/istio-components-and-ports\/)中，我将带你了解 Envoy 中各个组件的端口及其功能，这样可以让我们对 Istio 中的流量有一个更全面的了解。\n', '\/blog\/istio-sidecar-traffic-types\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-has-applied-to-join-the-cncf/">Istio 捐献给 CNCF 意味着什么？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/04/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 捐献给 CNCF 意味着什么？', '来自 Tetrate CEO、Istio 联合创始人 Varun Talwar 的解读。', '\n在 2022 年 4 月 25 日，IstioCon 2022 开幕的当天，Istio 社区宣布正在[申请将项目捐献给 CNCF](https:\/\/istio.io\/latest\/blog\/2022\/istio-has-applied-to-join-the-cncf\/)，这是 Istio 项目的一个里程碑，企业级服务网格公司 Tetrate 的 CEO\/Istio 项目联合创始人 Varun Talwar 对此进行了解读。\n\n以下是来自 Varun 对 Istio 捐献给 CNCF 的[解读](https:\/\/www.tetrate.io\/blog\/istio-has-applied-to-join-the-cncf\/)。\n\n------\n\n将 Istio 纳入 CNCF，使得 Istio 和 Envoy 的发展更容易同步推进。它还有助于将 Istio 与 Envoy 一起定位为 CNCF 验证的 \u0022云原生技术栈\u0022 的一部分。根据 CNCF 的年度[调查](https:\/\/www.cncf.io\/reports\/cncf-annual-survey-2021\/)，到目前为止，Istio 是生产中最受欢迎和使用最多的服务网格。有 20 多家不同的公司在推动 Istio 社区的发展，这一宣布为 CNCF 管理下的持续创新和增长创造了条件。\n\n## 2016：Istio 的起源\n\n我想借此机会解释一下 Istio 的起源。Istio 来自谷歌的 API 平台团队，名为 One Platform。(今天，具有讽刺意味的是，Istio 是美国政府项目 [Platform One](https:\/\/www.tetrate.io\/blog\/tetrate-first-to-provide-hardened-istio-to-dods-iron-bank\/) 的一部分，它使用 Tetrate 产品和服务）。一个平台利用了谷歌所有的基础设施优势（stubby、monarch、loas 等），并增加了最初的服务管理经验，并将其全部暴露给应用团队。\n\n每个团队都会编写他们的方案和方法，并定义他们的 \u0022One Platform API\u0022。一旦与 API 平台团队达成一致，各团队就不必再处理任何跨领域的问题，因为 Istio 处理了这些服务：流量管理、弹性、可观测性（使用具有一致名词的每个服务的预建仪表板）、认证、授权、速率限制等等。\n\nIstio 的想法来自于此；我们基本上采用了 One Platform 的想法，将 Envoy 加入其中（作为一个更好的数据平面），并将其与 LOAS 服务身份概念相结合，也就是今天世人所知的 Spiffe）。我们把这个想法告诉了 12 家公司，他们都很喜欢这个想法。这些公司包括大型互联网公司、金融服务公司和科技公司，特别是 SaaS 供应商。\n\n## 2017：形成核心\n\n2017 年 5 月的，Istio 在 Gluecon 上[首次公布](https:\/\/cloud.google.com\/blog\/products\/gcp\/istio-modern-approach-to-developing-and)。0.1 展示了 Istio 的潜力，引发了大量的关注和讨论。\n\n## 2018-2019：稳定核心，增加能力\n\n接下来的两年里，我们收集了客户的需求，将使用反馈内化，并稳定了核心功能。此外，我们还做出了一些关键的架构决定，如定义多集群模型，并将代码重新架构为一个单一的二进制文件，以方便使用。\n\n## 2020：团结社区\n\n随着 Istio 的采用和用户生态系统的发展，人们对管理和商标保护的担忧也越来越大。然而，正如我们在[这里](https:\/\/www.tetrate.io\/blog\/istio-ouc\/)所提到的，作为一个社区保持团结是项目成功的关键。我可以自豪地说，Istio 就是这样做的。因此，今天加入 CNCF 的行动是发展社区和建立最终用户信任的又一步骤。\n\n## 2021：向 Wasm 和其他领域发展\n\n人们对加入其他基础设施，如虚拟机、功能和裸机工作负载，以及使用 Wasm 等技术的定制和其他功能作为本地 API 的兴趣越来越大，这样用户就不必再使用 Envoy 过滤器了。2021 年见证了其中一些功能的建立和推广。\n\n\u0022Varun Talwar 是项目的创始人之一，他一直认为 Istio 是云原生生态系统的一个重要组成部分。今天的公告验证了他对项目的愿景，我要感谢 Tetrate 成为 Istio 和我们社区的有力支持者。\u0022——Louis Ryan（Istio 联合创始人，谷歌工程负责人）\n\n## 零信任的基础\n\n关于零信任的话题已经有很多讨论，但很少有明确的说法。正如 Eric Brewer 今天在 IstioCon 的[主题演讲](https:\/\/events.istio.io\/istiocon-2022\/sessions\/zero-trust-istio\/)中提到的，Istio 正在成为零信任的一个重要组成部分。其中最主要的是面向身份的控制，而不是面向网络的控制。这方面的核心原则在谷歌白皮书[《BeyondProd：云原生安全的新方法》](https:\/\/cloud.google.com\/blog\/products\/identity-security\/beyondprod-whitepaper-discusses-cloud-native-security-at-google)。\n\n然而，作为一个行业，这里有更多的事情要做。我们需要确保我们可以把应用用户和数据服务都带进来。如果我们能将身份概念扩展到用户，并为我们提供灵活而丰富的策略机制来指定、监控和跟踪访问控制，我们就能达到一个可操作的零信任结构 —— 一个将用户、服务和数据统一到一个管理层的结构。我在 2020 年为美国国家标准与技术研究院（NIST）举办的围绕信任云原生应用的主题演讲中也提到了这一点。这就是为什么我们在 Tetrate 创建了 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)—— 一个管理平面，使大型组织可操作。\n\nTetrate Service Bridge 的基础是：\n\n- 用户、服务和数据的身份。每个人都有一个加密身份，构成所有政策的骨干。\n- 策略和访问控制。定义 Istio 策略，也包括应用和组织策略，包括用户和设备，以及大规模管理它们的能力。\n- 自动化。在运行时自动化、测量和持续监测策略的能力。\n\n如果我们能让企业以这种方式为云原生工作负载部署和运营安全，我们就能作为一个行业取得巨大进步。\n\n## 人才\n\n归根结底，没有高素质、富有创造性的人才，任何项目或技术都不会成为主流。在 Tetrate，我们相信我们需要对社区进行有关这项技术的教育，并为负责任的采用路径做出贡献。因此，我们提供世界级的认证和免费的在线培训课程，使社区中的任何人都可以在 [academy.terate.io](https:\/\/academy.tetrate.io\/) 轻松参加 Istio 和 Envoy 的初级和高级课程。\n\n我们 Tetrate 的所有人，特别是我自己，都期待着下一步的发展，我们将始终支持 Istio 项目和社区。\n', '\/blog\/istio-has-applied-to-join-the-cncf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">来自 Tetrate CEO、Istio 联合创始人 Varun Talwar 的解读。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-13/">Istio 1.13 有哪些值得注意的更新？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/03/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.13 有哪些值得注意的更新？', '2022 年 2 月 Istio 发布 Istio 1.13.0 和 Istio 1.13.1，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。', '\n2022 年 2 月 Istio 发布 [1.13.0](https:\/\/istio.io\/latest\/news\/releases\/1.13.x\/announcing-1.13\/) 和 [1.13.1](https:\/\/istio.io\/latest\/news\/releases\/1.13.x\/announcing-1.13.1\/)，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。\n\nIstio 1.13 是 2022 年的第一个版本，不出意外的话，Istio 团队会依然按照每个季度的频率发布新版本。总体来看，这个版本中的新特性包括：\n\n- 对 Kubernetes 更新版本的支持\n- 引入了一个新的 API——ProxyConfig，用来配置 sidecar proxy\n- 完善了 Telemetry API\n- 支持多网络网关的基于主机名的负载均衡器\n\n## 对 Kubernetes 版本的支持\n\n我经常看到有人在社区里问 Istio 支持哪些 Kubernetes 版本，其实 Istio 官网中已经明确列出了支持的 Kubernetes 版本，你可以在[这里](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases)看到，Istio 1.13 支持 Kubernetes 1.20、1.21、1.22 和 1.23 版本，并在 Kubernetes 1.16、1.17、1.18、1.19 中测试过，但并得到官方支持。\n\n在配置 Istio 的时候，其实还有很多检查列表，我将他们都记录到了 [Istio cheatsheet](https:\/\/github.com\/tetratelabs\/istio-cheatsheet) 中，这个项目中整理了很多关于配置 Istio、资源对象的使用、常见问题处理等相关的 cheatsheet，将于近期上线，敬请期待。\n\n![Istio cheatsheet 页面截图](istio-cheatsheet.jpg)\n\n## 引入新的 ProxyConfig API\n\n在 Istio 1.13 版本之前，如果你想自定义 sidecar proxy 的配置，有两种方式。\n\n**\u0060方式一：MeshConfig\u0060**\n\n使用 \u0060MeshConfig\u0060，在 Mesh 级别使用 IstioOperator 来修改。例如，使用下面的配置来修改 \u0060istiod\u0060 的默认发现端口。\n\n\u0060\u0060\u0060yaml\napVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n\t  defaultConfig:\n      discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n**方式二：Pod 中的 annotation**\n\n你也可以在 Pod 级别使用 annotation 的方式自定义配置，例如在 Pod 中增加下面的配置同样可以修改工作负载所有连接的 \u0060istiod\u0060 的默认端口。 \n\n\u0060\u0060\u0060yaml\nanannotations:\n  proxy.istio.io\/config: |\n    discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n当你同时使用了以上两种方式配置了 sidecar，\u0060annotations\u0060 中设置的字段将完全覆盖 \u0060MeshConfig\u0060 默认的字段。关于 \u0060ProxyConfig\u0060 的所有配置项请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#ProxyConfig)。\n\n**新方式：\u0060ProxyConfig\u0060 API**\n\n但是在 1.13 版本中，新增了一个顶级自定义资源 \u0060ProxyConfig\u0060，你可以一站式的在一个地方来自定义 sidecar proxy 的配置，你可以通过指定 namespace、使用 \u0060selector\u0060 来选择工作负载的范围，就像其他 CRD 一样。目前 Istio 对该 API 的支持有限，关于 \u0060ProxyConfig\u0060 API 的详细信息请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/proxy-config\/)。\n\n但是不论你用哪种方式自定义 sidecar proxy 的配置，该配置都无法动态生效，需要重启工作负载才可以生效。例如，对于上面的配置，因为你修改了 \u0060istiod\u0060 的默认端口，mesh 中的所有工作负载都需要重启才可以与 control plane 建立连接。\n\n## Telemetry API\n\n在 Istio 服务网格中，很多扩展和自定义的配置都是通过 [\u0060MeshConfig\u0060](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-ExtensionProvider) 的方式来完成的。可观测性的三种类型 Metric、遥测和日志，分别可以对接不同的提供者，[Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/) 可以让你有一个一站式的灵活的配置它们。与 ProxyConfig API 类似，Telemetry API 也遵循着工作负载选择器\u003e本地命名空间\u003e根配置命名空间的配置层级关系。该 API 是在 Istio 1.11 中引入，在该版本中得到了进一步完善，增加了 \u0060OpenTelemetry\u0060 日志、过滤访问日志以及自定义跟踪服务名称的支持。详见 [Telemetry 配置](https:\/\/istio.io\/latest\/docs\/reference\/config\/telemetry\/)。\n\n## 自动解析多网络网关主机名\n\n2021 年 9 月，Istio 社区里[有人报告](https:\/\/szabo.jp\/2021\/09\/22\/multicluster-istio-on-eks\/)，在 AWS EKS 中运行多集群多主的 Istio 时，出现 EKS 的负载均衡器无法解析的问题。对于多集群多网络的网格，跨集群边界的服务负载，需要通过专用的东西向网关，以间接的方式通讯。你可以按照 [Istio 官网上的说明](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)配置多网络的 primary-remote 集群，Istio 会根据主机名自动解析负载均衡器的 IP 地址。\n\n## Istio 1.13.1 修复重大安全漏洞\n\n当月，Istio 1.13.1 发布，修复了一个已知的[重大漏洞](https:\/\/cve.mitre.org\/cgi-bin\/cvekey.cgi?keyword=CVE-2022-23635)，该漏洞可能导致未经认证的控制平面拒绝服务攻击。\n\n![跨网络的主从集群](primary-remote-cluster-mesh.jpg)\n\n在安装多网络的 [primary-remote](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/) 模式的 Istio 网格时，为了让 remote Kubernetes 集群能够访问控制平面，需要在 primary 集群中安装一个东西向的 Gateway，将控制平面 \u0060istiod\u0060 的 15012 端口暴露到互联网。攻击者可能向该端口发送特制的消息，导致控制平面崩溃。如果你设置了防火墙，只允许来自部分 IP 的流量访问该端口，将可以缩小该问题的影响范围。建议你立即升级到 Istio 1.13.1 来彻底解决该问题。\n\n## IstioCon 2022\n\n![IstioCon 2022](istiocon-2022.jpg)\n\n最后，作为上一届和本届 IstioCon 的筹备委员会成员之一，我号召大家报名参加 4 月 25 日在线上举行的 [IstioCon 2022](https:\/\/events.istio.io\/istiocon-2022\/)！IstioCon 2022 是一个以行业为重点的活动，一个连接贡献者和用户的平台，讨论 Istio 在不同架构设置中的用途，有哪些限制，以及项目的下一步发展方向。主要的焦点将是在最终用户公司，因为我们期待着分享多样化的案例研究，展示如何在生产中使用 Istio。\n', '\/blog\/what-is-new-in-istio-1-13\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2022 年 2 月 Istio 发布 Istio 1.13.0 和 Istio 1.13.1，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/resiliency-app-aware-network/">[译] 利用服务网格和智能应用感知网络增强应用弹性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/02/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('利用服务网格和智能应用感知网络增强应用弹性', '本文是作者在 QCon 上的分享，主要谈及服务网格及其引申出来的应用感知网络。', '\n我是 Varun Talwar，Tetrate 公司的联合创始人。我们是一家企业级服务网格公司。我要谈的是弹性，更准确地说，是运行时的弹性，是内置于你的网络中的东西。我喜欢从历史上的一个技术话题开始谈起。Cloud 1.0 是云的第一个时代。当时我们看到了虚拟化的浪潮，人们基本上从他们的硬件中获得更多。在我们进入当前的云时代之前，这已经持续了好几年，也就是 Cloud 2.0 时代，这基本上是从别人那里获得计算资源。你不需要在数据中心运行机器，别人为你更有效地运行它们。你刷一下信用卡，就可以得到他们管理的资源。这对配置灵活性和在我们想要的任何地方提供计算有很大的帮助。实际上，下一阶段就是 Cloud 3.0，这是一个更加动态和分布式的计算。从容器和自动伸缩的意义上讲，动态的，通过 Kubernetes 这样的协调器进行调度。分布式是指不同的区域：私有云、公有云、混合云等等。以及在应用组件分布的意义上的分布式。在一个计算如此动态的世界里，我们的网络和安全堆栈是滞后的。这些都是需要迎头赶上的。\n\n## Cloud 3.0 转型 —— 网络的创新\n\n在创办 Tetrate 之前，我曾有机会在谷歌工作了大约 11 年。很多人都在谈论，谷歌的基础设施怎么会如此可靠和安全？为什么它如此有弹性？尽管推出了更多的服务，尽管每年有数以千计的新开发者加入，但基础设施始终是正常的，可用的。这其中的核心之一是对核心网络的投资。谷歌的网络创新相当少，并不是所有的创新都被谈论过。我有幸参与了其中的两项重要创新，即 gRPC 和 Istio，我是这两个创新的共同创造者。这些都是网络栈被带到应用层面的地方。gRPC 是这个现代 RPC 结构，在 2016 年推出。Istio 是这种基于代理的方法，将代理注入到网络中，并使其成为 L7 代理，知道什么是通过它们进行的。这是在 2017 年推出的。这两个都是今天蓬勃发展的开源项目。\n\n## 背景介绍\n\n回到这次谈话的背景，弹性是超级重要的。随着越来越多的公司转向公有云，任何一个云供应商出现故障时，受到影响的品牌名单就会不断增加。这大大阻碍了他们的正常运行时间，不仅仅是正常运行时间，还有他们的业务和品牌形象。\n\n## 弹性不仅仅与软件有关\n\n我们如何才能做得更好？在我们讨论这个问题之前，让我们先来看看弹性问题的范围。这是一个多层次的问题，从基础设施层开始，然后延伸到网络层。它们的分布越多，网络层的可靠性就越关键。显然，也延伸到数据层，以及你的人、实践和操作。故障可能是不同类型的。你可以从一个主机到一个节点，到一个特定的服务，到一个特定的数据中心，到一个特定的区域。很明显，在物理层面上，在布线、交换机和路由器方面也是如此。所有这些都会给你的应用程序造成故障模式和可用性问题。问题是，你如何设计你的应用程序以适应它们？我们可以做得更好，而不仅仅是两种部署，主 - 主，或主 - 被？\n\n在一个计算无处不在的世界里，我的观点是，你应该在多个可用区部署应用程序。无论如何，它们现在更容易配置、运行和管理。部署流水线更加自动化。我们真正需要的是一个智能的、连接的网络，它可以将流量一直路由到正确的健康部署，我们将有弹性的应用程序。说起来容易做起来难，我们如何才能在实践中真正做到这一点？让我们看看一些场景。\n\n## 情景 1：服务实例失败\n\n想象一下一个简单的三层应用程序的场景。你有你的前端 Web 服务器数据库，你有流量进入一些边缘。它可能是一个数据中心或一个云区域，进入一些应用代理或入口代理，然后进入你的应用程序。第一件事是应用程序应该部署在多个可用区。这是使其更具弹性的第一个前提。第二是模拟故障，并加强你的服务代码库处理故障的能力。像服务网格和 Istio 有一定的能力，你可以注入和模拟故障，并使它准备好更多的容错。一旦你在可用性区域部署了应用程序，你需要它有故障转移的东西是区域之间的连接，所以你实际上可以将流量路由过去。这些是提高可用性的一些良好做法。\n\n## 服务代理 - 通往更健康的实例的路由\n\n比方说，你有一个特定的服务实例在一个给定的节点上停机。它可能是数据库。它可能是网络服务器。它可能是前端。这个弹性网络的方法是在每个服务旁边有一个服务代理，或者在整个应用面前有一个应用代理，它可以检测到一个特定的实例正在发生错误。也许这可以通过更高的延迟或更高的错误率，或其他信号来检测，而且是来自该实例。它通常来自运行在它们旁边的 Sidecar 代理。这可以发出信号说，好吧，我应该把负载均衡到另一个更健康的实例，它有更健康的计算池，它有更健康的 pod，如果你遵循 Kubernetes。这是一个保持可用性和弹性的简单方法。另一个是关于，故障会发生。你如何确保代理足够聪明，内置超时和快速重试，所以他们可以从这些模式中恢复？这些也是很好的提示和做法。\n\n## 情景 2：服务失败\n\n假设整个服务瘫痪了，而且在那个特定的区域或特定的数据中心，没有一个实例是实际可用的。那你该怎么办呢？那么，你需要做的是将其路由到一个不同的可用区。这说起来容易，做起来难。要做到这一点，你需要知道每个服务和所有区域的状态和健康状况，并实时输入控制器，然后可以决定，好吧，我应该把流量发送到哪里？你需要它们之间的连接，以便它能够真正地路由流量。数据的一致性是另一个层面的问题，需要解决的是你要有一个一致的结果。另一个问题是，让这些东西在自动扩展的基础设施上运行总是可取的，所以资源容量不会成为我们可用性的一个问题。\n\n## 可用性数学\n\n有一件事我们都知道，但有时会忘记，用数字来表示是很好的，那就是，什么是可用性？可用性的定义是我在任何一年的平均停机时间是多少。我们经常谈论两个九、四个九、五个九的可用性，但实际上，只要在一到两个可用性区域内有可用性，就可以大大减少我们的停机时间，并提高我们的弹性。即使是一到两个可用区，也是非常有意义的影响。\n\n## 情景 3：应用失败\n\n继续这一趋势，让我们说，不是一个服务或服务实例，而是整个应用系统瘫痪了。那么，你如何将流量路由到该应用程序的一个完全不同的实例？如何设置两层的负载均衡，这样上面的一层，在这种情况下，边缘代理实际上可以知道，将流量发送到哪个应用代理。在这里，重要的是，你的所有其他安全控制，你已经建立的合规控制，你需要操作的应用程序，实际上在所有这些可用性区域都可用。这是通过服务网格的配置来完成的，这些 L7 网格，可以确保相同的配置被发送到所有的区域，因此你可以保证相同的行为。这看起来很容易，但对每个人来说，要实现这样的设置并不容易，即健康信号传播到边缘代理，代理做出正确的决定，你以正确的方式进行负载均衡。\n\n## 情景 4：区域故障\n\n你可以把这个问题提升到不仅仅是一个应用程序，而是整个区域的故障，整个数据中心的故障或容量不足。在这些情况下，你要把路由到一个完全不同的数据中心。在云设置中，它甚至可能意味着到一个完全不同的云。只要你有应用程序部署在这些区域，问题的解决方案是类似的，也就是你有一个上面的层，它在任何时候都有健康和性能的信号，并可以做出路由决策，将流量路由到最佳区域。然后从那里到最佳应用实例，再从那里到实际服务。\n\n## 通过动态自动伸缩的 L7 网络实现复原能力\n\n总之，我的主要观点是，我们可以有这种动态的自动伸缩，应用程序感知的网络。之所以称之为自动伸缩，是因为所有这些负载均衡器也可以在计算中运行，它可以自动伸缩，而且它们也可以是弹性的，就像你的计算节点。这种设置如果部署得当，架构合理，可以做两件事，第一，大大改善你的应用程序的弹性。二，你的开发人员不需要在他们的每个服务和应用程序中建立所有这些，并使其成为服务网格本身的一部分。我们在 Tetrate 是以这个为生的。我们有一个平台来实现这一点。在很多地方做了这些工作后，我们有不少最佳实践和蓝图架构，在实际的、真实的环境中很适合。\n\n## 问答\n\n**当你讲述谷歌的网络进化故事时，我想到的是，是什么导致了 gRPC 和 Istio 的诞生？你以前有什么不理想的地方，然后导致了最初 gRPC 的创建？什么问题没有得到解决？你也许想谈一谈这个问题。**\n\nTalwar：gRPC 是谷歌内部一个叫 Stubby 的东西的下一代演绎。Stubby 在谷歌成立之初就存在了，也就是 1999 年。实际上，任何两个服务都可以通过这个 Stubby 机制相互通信。它存在了很长时间。在大约 12 年的时间里经历了一系列的迭代。那么需要它的原因有两个方面。在这种规模下，如果你在 HTTP 上做 JSON，这是客户端流量的经典方式，对于我们的规模来说，这还不够理想。只是给你一些例子，只是通过做 protobuf，也就是通过二进制，比通过文本，与通过 HTTP 的 JSON 相比，你在许多情况下得到 10 倍的改进。这意味着在我们的规模上可以节省数百万甚至数十亿美元的费用。\n\n然后，渐渐地，发生了很多事情，比如负载均衡，重试，以及发送一些跨度进行追踪。gRPC 只不过是它的下一个版本，它被开放了源代码。原因是在一个组织中，你可以非常有主见，就像，好吧，我只支持三种语言或四种语言，在某些情况下，只支持一种语言，然后这些是我的库。这是好的。当我们把它放在外面的时候，你不能有那种一个组织的意见。谷歌实际上是用三种语言运行的。C\u002b\u002b、Java 和 Python。然后一切都在这里面。当我们不得不进入多语言世界，并支持许多现有的服务时，这就是为什么需要一些不基于库和代理的东西，这导致了 Istio。\n\n**有一种争论是，对于断路器来说，最好是避免回退或重试，而典型的情况是，它们需要在应用中实现，而不是在网络层。你有什么想法？**\n\nTalwar：我们正在经历这样一个有趣的时代，什么是在应用程序中，什么是在网络中，在许多情况下，需要合作。与追踪不同的是，对于传递标头值，这是一个很好的例子，你必须在应用中做到这一点。断路器，核心代理，无论是 Envoy，还是其他代理，它们都有这些内置的概念，能够检查上游的健康状况，或者你要把它发送到哪里。定义我何时破坏它的规则，并通过配置做所有这些，所以这些范式存在于这些代理和控制平面中。显然，这一切只是基于代理，而不是基于通过代理的所有流量，就通过代理的请求的延迟和错误率而言。他们不知道你底层计算的其他方面。比方说，你的 CPU 超载了，就像那个应用程序正在消耗，这不会被知道。现在发生的更多的是这些事情被添加到了上面，也就是，从你的节点传递信号，比如 CPU 内存信号，这些被传递到了上面，以做出一些决定，或者能够从应用中获取外部信号，让代理做出决定。\n\n显然，应用程序本身知道，有最多的背景，但人们在理解方面实际发展了多少，从节点开始，一直到可能出错的不同事情。我认为这很难。我们至少看到的两件事是代理与底层节点和应用程序之间的互动，以及反向的互动。这基本上意味着代理向底层自动扩展基础设施发出信号以进行扩展，所以这实际上也在更多地发生。我知道健康状况正在下降，因为延迟上升，信号下降到像 Kubernetes 这样的自动伸缩基础设施，或者只是云供应商的实例组。这是一个没有被使用的信号，应该被使用。\n\n**有一种观点认为，Istio 没有被企业完全采用。你怎么看？企业需要认识到哪些事情，然后利用你所说的这种智能应用感知网络的优势？**\n\nTalwar：Istio 在技术势头之前就已经有了营销的势头。这是其反馈循环的原因之一。它现在变得更好了。现在已经好了很多。另一件事是，它有太多的旋钮和太多的配置，等等，它只是让人们摸索和采用时变得复杂。另一件事是你需要对谁能做什么进行非常干净的控制。我经常告诉人们，与 Kubernetes 和其他类似的东西不同，**Istio 和服务网格总体上是一个多角色的问题**。这不是一个单一角色的问题。在企业内部，一个平台团队如何管理网关，管理 Sidecar？Sidecar 通常与应用结合在一起，所以现在，如何进行应用升级？这是应用团队的事。网关通常由一个不同的团队管理。如果你要一直走到边缘，通常有边缘代理团队。然后，安全希望总是作为其他人在那里，至少有可见性。在许多情况下，甚至想强制执行必须发生的策略，以及可选择发生的策略。他们甚至希望在工作流程中向外部暴露服务。\n\n总之，你必须解决的问题是，每个团队在他们的观点和控制方面得到什么？你如何使旋钮更简单地使用？如果你问我，这里有太多的旋钮和太多的 YAML。有一件事是，只要让它简单，这是我的 API，这是我想要的行为。这应该就这样发生。像 Istio 这样的东西只是在平台上实现的，在基础设施中也是如此。这就是我们在 Tetrate 采取的方法。我认为这是一个长期的方法，如果这将被真正地大规模采用，而且时间更长。这就是它将成为的方式。像大多数技术一样，它将变得枯燥和不可见，将有一种方法可以直接使用它们，而不必对它们的细节进行搔扰。\n\n**当我们谈论服务网格和 Istio，当然还有其他技术时，人们总是担心这与传统的 API 网关有什么关系。路线图变得模糊了。比如，什么是边缘代理？什么是 API 网关？它们有区别吗？它们应该是不同的吗？你对此有什么想法？**\n\nTalwar：这里显然是有偏见的。我认为它们不应该是不同的。我们正在建立和构建的平台是这样的，全程使用 Envoy，因为你可以把它部署为一级负载均衡器，作为边缘代理。每个应用都可以有一个代理和一个应用代理在前面。然后，你可以拥有同样基于同一数据平面的 Sidecar。一个数据平面贯穿始终，然后每个应用程序，一个应用程序是我们的第一类概念，做它需要做的事情。在某些情况下，你会想，只要在入口层做认证，这就是我想要的一切。这就是我需要做的一切。我暂时不会去做 Sidecar 业务，这很正常。而其他人会想，不，我已经准备好了。这都是 HTTP，我很舒服。它不像超级性能敏感，延迟的东西对我来说并不重要。你也可以走这条路。\n\n我思考的方式是，人们建立服务。人们部署服务。你可以通过内部 API 将它们暴露给你的内部团队成员，和 \/ 或你的合作伙伴。你可以通过公共 API 将其暴露给公众。你需要的控制是类似的。传统上的南北和东西之间的界限正在模糊化。人们做更多的微服务和 API 协议，你需要基于内部 API 的互动。唯一的区别是内部 API，你会在那里做基于令牌的认证。在外部 API 中，你会要求像，我需要有 OAuth，你需要通过这个流程。在外部 API 中，你要做的是，不，我想要 WAF 风格的策略，即批量保护这些 IP 的类型。而在内部 API 中，你将只是说，来自这个团队的测试流量不应该对我进行 DoS，所以只是速率限制。场景有一点不同，但技术层面的控制是相似的。我认为把它放在一个平台上是很有意义的，这就是唯一的区别。\n\n事实上，Istio 所来自的团队，实际上被称为 One Platform，这是谷歌的说法，这是内部 API，外部 API。你只要告诉我们你在你的 API 中想要什么。这些是行为。我们以前在谷歌的团队所做的是，每个团队只是提交他们的 API 规格和他们想要的东西，事情就会发生。今天它是一个内部的，明天就变成了一个外部的 API。你可以在 API 规格上添加一些东西，仅此而已。在推广方面没有其他变化。\n\n**网格的网格，这到底是不是同一个东西？**\n\nTalwar：我不太喜欢这个词，但这个概念确实是真的。我们在 Tetrate 所做的，以及我认为更普遍的，在工业界，它正在成为事实，这就是，有三个层次，这还没有被很好地解释。有一个数据平面，它必须通信的地方。还有一个控制平面，需要在它的附近，也就是在同一个集群或同一个 VPC 中，但不能太远。然后还有第三层，也就是我们所说的管理平面，也就是你在上面看，说，好的，我需要为每个应用做什么，做路由决定，做弹性决定，等等。我们正在建立管理平面。Istio 仍然是按原样使用的，随着它的功能不断增加，以及所有这些，作为附近的控制平面。\n\n当然，它是以一种与计算和云无关的方式完成的。如果我在微软云有 N 个集群，在亚马逊云有 N 个集群，每个集群都可以用 Istio 作为控制平面。你真的能做出那些有弹性的决定，而不是路由到这个微软区，而是路由到这个亚马逊区？人们来问我，为了成本、性能、安全或其他原因选择他们喜欢的云服务，我们可以这样做吗？这绝对是可能的，但对人们来说并不那么容易实现。我们想让这个目标容易实现。我认为我们正在走向那个世界。网格的网格听起来是一个不好的名字，但从架构上看，我们正在走向那里。\n\n是的，它可以在任何地方。这就是管理机的魅力所在。它可以在任何一个地方，无论你决定它在哪里。问题是，所需的边缘或入口要放在更接近其应用的地方。\n\n**我喜欢你的智能应用感知网络的说法，你认为它是否总是可以自动等同于一般的服务网格？如果我不使用边缘技术，那么我的替代方案是什么，如果有的话？**\n\nTalwar：服务网格成为这个一切的术语。这个概念就是你的网络和你的平台层更加智能。例如，gRPC 是我的另一个宝贝，它支持 xDS，所以你可以在 gRPC 中建立东西，没有任何代理，并要求控制层有同样的行为，这一切都可以。我认为更多的语言栈和框架将开始支持这些类似 xDS 的功能。一旦他们这样做了，我想我们就可以进入事情本身的构建方式了。这还没有发生。我认为这才是应该发生的。今天是 Envoy 代理。明天可能是更好的东西。这个概念在语言框架和这些代理中都是一样的。让它们更智能，这样你就不会在应用中做了，而且你可以在不加重应用开发者负担的情况下，在你的应用中持续地做。我认为这个概念是非常有用的，而且会继续存在。\n', '\/trans\/resiliency-app-aware-network\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是作者在 QCon 上的分享，主要谈及服务网格及其引申出来的应用感知网络。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/importance-of-wasm-in-istio/">[译] 在 Istio 中引入 Wasm 意味着什么？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/02/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中引入 Wasm 意味着什么？', '本文回顾了 Istio 和 Envoy 中引入 Wasm 的历史并介绍了其重要性。', '\nWasmPlugin API 最近被添加到 Istio 项目中，作为一种新改进的可扩展性机制。在 Tetrate，我们最近成功举办了一个名为 Istio Wasm workshop 的研讨会。[点击这里](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ)观看研讨会的录音，并加入 [Slack 上的对话](https:\/\/tetr8.io\/tetrate-edu-slack)。\n\n我们谈论了 WebAssembly 及其在 Istio 和 Envoy 项目中的重要性，并通过使用 [Proxy-Wasm Go SDK](https:\/\/github.com\/tetratelabs\/proxy-wasm-go-sdk) 和 [func-e](https:\/\/func-e.io\/) 进行了多个演示。\n\n我们在 Tetrate 关注 Istio 的可扩展性已经有很长一段时间了。Tetrate 的工程师 Takeshi Yoneda 和周礼赞在为此做出了巨大的贡献，我们非常高兴地看到 Istio 的可扩展性因此而得到了极大的改善。\n\n在这篇博文中，我描述了在引入 WasmPlugin API 之前 Istio 和 Envoy 可扩展性的状况；目前大为改善的情况；以及将或多或少完成这条可扩展性改进弧线的变化，我们预计这些变化将在即将到来的版本中出现。\n\n## Istio 和 Wasm 的历史\n\n| Istio 1.4 之前                       | Istio 1.5                                                   | Istio 1.12 和未来         |\n| ------------------------------------ | ----------------------------------------------------------- | ------------------------- |\n| 用 C\u002b\u002b 扩展维护自己的 Envoy 代理构建 | 使用 EnvoyFilter 资源引入新的 Wasm 可扩展性模型（仍然复杂） | 引入专用的 WasmPlugin API |\n| 使用 Mixer（效率低）                 | 仅支持本地或 HTTP 位置                                      | 包括对 OCI 注册表的支持   |\n\n在 Istio 1.4（2019 年 11 月发布）之前，没有良好的机制来运行插件。当时，Istio 维护了他们自己的 Envoy 代理的分支，以运行自定义插件，如用 C\u002b\u002b 编写并与 Envoy 代理一起构建的 RBAC 和 JWT 过滤器。\n\n当时，Istio 使用 Mixer 组件，在应用程序代码和基础设施后端之间提供一个层。使用 Mixer，人们能够执行授权策略，收集遥测数据，并管理配额。在这种模式下，Envoy 代理在向后端发出请求之前会调用 Mixer 组件，以执行任何前提条件检查 —— 例如，“服务 A 能否调用服务 B”，并在每个请求完成后再次调用 Mixer 以报告遥测数据。使用这种模式导致了资源的低效使用，也导致了延迟。\n\nEnvoy 的扩展性依赖于开发者知道如何用 C\u002b\u002b 编写扩展。此外，任何 C\u002b\u002b 扩展都必须用 Envoy 代理来构建。这就是当时 Istio 维护他们自己的 Envoy 代理构建的原因。\n\n在这种模式下，人们必须用新的二进制文件替换整个现有的 Envoy 代理实例。\n\n## Envoy 和 Wasm 的历史\n\nEnvoy 希望将依赖一个单一的可扩展性堆栈，使 Envoy 的发布与扩展生态系统脱钩，并使扩展开发者能够使用 C\u002b\u002b 以外的东西。在 Envoy 中加入这个功能，可以让 Istio（以及其他 Envoy 代理用户）随时推出新的特性和功能，而不需要单独维护 Envoy 的构建。在 Envoy 和 Istio 双方的强烈推动下，在 Envoy 中[支持](https:\/\/github.com\/envoyproxy\/envoy\/issues\/4272) WebAssembly 的[工作](https:\/\/github.com\/envoyproxy\/envoy\/issues\/4272)于 2018 年开始。\n\n## 在 Envoy 中引入 WebAsssembly\n\n在 Envoy 和 Istio 中所做的关于可扩展性的艰苦工作被纳入了 Istio 1.5 版本（2020 年）。Istio 1.5 版本包括一个使用 WebAssembly 的可扩展性新模型。随着 WebAssembly 的引入，不再需要运行单独的 Mixer 组件，这也导致了 Istio 部署的简化 —— 少了一件部署的东西，也少了一件需要担心的东西。\n\n该版本包括通用的应用二进制接口（ABI）和 C\u002b\u002b、Rust 和 AssemblyScript SDK。现有的 Istio 功能，如统计、元数据交换和其他功能也被实现为 WebAssembly 扩展。一个名为 EnvoyFilter 的资源被引入，以处理这些扩展的部署。\n\nEnvoyFilter 资源是对 Envoy 配置的一个非常简单的抽象，它允许 Istio 操作者修改 Envoy 代理行为。然而，这种轻量级的抽象仍然意味着操作者必须熟悉 Envoy API 的细节以及如何有效地配置它们。\n\n为了让 Envoy 代理加载和使用扩展，你必须把 Wasm 二进制文件放在与 Envoy 代理容器相同的 pod 内。运维人员可以选择指向一个本地文件（即集群内的文件，Envoy 代理容器可以访问）或提供一个 HTTP 位置，代理可以从那里下载扩展。\n\n在 Istio 的后续版本中有多项改进，特别是 Istio 代理开始拦截 EnvoyFilter 资源并代表 Envoy 代理获取二进制文件的变化。\n\n## Istio 1.12 和 WasmPlugin API\n\n最近在 Istio 1.12 中引入了最重要的突破性功能。为 Wasm 插件引入了一个专门的 API，称为 WasmPlugin API，它使用一种新的方法从符合 OCI 的注册表中获取 Wasm 二进制文件。\n\n新 API 的引入消除了使用 EnvoyFilter 来部署扩展的需要。扩展开发者现在可以使用一个名为 WasmPlugin 的资源来指定要部署插件的工作负载。对符合 OCI 标准的注册表的新支持允许开发人员使用现有的工具（例如，Docker）来构建包含其扩展的镜像，并将其推送到符合 OCI 标准的注册表。这允许以对待容器镜像的相同方式对待 Wasm 插件。例如，使用镜像标签和不同的存储库。\n\n# 总结\n\nWasmPlugin API 的工作仍在进行中。一些功能，包括对镜像拉取 secret 的支持，更好的镜像缓存支持，以及对 singleton 扩展的支持还不能使用。\n\n要开始使用 Wasm，请[观看](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ) Wasm 研讨会的[录音](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ)并加入 [Slack 上的 Wasm 对话](https:\/\/tetr8.io\/tetrate-edu-slack)。\n', '\/trans\/importance-of-wasm-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文回顾了 Istio 和 Envoy 中引入 Wasm 的历史并介绍了其重要性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-solve-service-mesh-sidecar/">[译] 告别 Sidecar——使用 eBPF 解锁内核级服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/12/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('告别 Sidecar——使用 eBPF 解锁内核级服务网格', '本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。', '\n译者注：本文作者是 Isovalent 联合创始人\u0026CTO，原文标题 [How eBPF will solve Service Mesh - Goodbye Sidecars](https:\/\/isovalent.com\/blog\/post\/2021-12-08-ebpf-servicemesh)，作者回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。\n\n------\n\n## 什么是服务网格？\n\n随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。\n\n![服务网格示意图](008i3skNly1gx7wyna8jsj32e20sojtx.jpg)\n\n纵观今天服务网格的功能设置，可以总结为以下几点：\n\n- **弹性连接**：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。\n- **L7 流量管理**：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。\n- **基于身份的安全**：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。\n- **可观测性和跟踪**：追踪和指标形式的可观测性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。\n- **透明**：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。\n\n在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP\/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。\n\n![基于库的服务网格模型](008i3skNly1gx7wyowb55j31pi0k076p.jpg)\n\n今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为“挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。\n\n![基于 Sidecar 的服务网格模型](008i3skNly1gx7wyqsefhj31pe0moq5h.jpg)\n\n这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。\n\n这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。\n\n## 连接性转移到内核中的历史\n\n几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 [TCP 包装器](https:\/\/en.wikipedia.org\/wiki\/TCP_Wrappers)和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。\n\n然而，iptables 显然不适合解决现代应用的连接性、安全性和可观测性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。\n\n![服务网格的进化](008i3skNly1gx7y8ybphhj31h30u041s.jpg) \n\n在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。\n\n## 扩展内核命名空间概念\n\nLinux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 \u0022容器\u0022 概念中。\n\n符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。\n\n![Service Mesh Namespace](008i3skNly1gx7wypvr2zj31p20q0q75.jpg)\n\n不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。\n\n### 注入 Sidecar 的成本\n\n如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。\n\n![注入 Sidecar 的成本](008i3skNly1gx7y8nu479j31h30u041s.jpg) \n\n \n\n这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。\n\n## 用 eBPF 解锁内核服务网格\n\n为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见[我们已经构建了相当多的服务网格 - Tim Hockin, Google](https:\/\/www.youtube.com\/watch?v=lUF88T16YqY\u0026ab_channel=CloudNativeRejekts)）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。\n\neBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观测性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观测性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。\n\n![eBPF 服务网格架构](008i3skNly1gx7wyrufdyj31w90u0q6o.jpg) \n\n**有人可能想知道为什么 Linux 内核社区不直接解决这些需求**。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。**新的内核版本需要几年时间才能进入用户手中**。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。\n\n## 无 Sidecar 的基于 eBPF 的 L7 追踪和度量\n\n让我们看看 L7 追踪和指标可观测性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观测性应该没有明显的成本（延迟、复杂性、资源…）。\n\n![基于 eBPF 的可视性](008i3skNly1gx7wysxpr4j31ne0iugq1.jpg)\n\n在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。\n\n![基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性](008i3skNly1gx7wyt6izdj31ns0rawfw.jpg)\n\n我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。**几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。**\n\n这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。\n\n## 使用 eBPF 加速的 per-node 代理\n\n越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。\n\n我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。\n\n当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。\n\n![eBPF per-node Proxy](008i3skNly1gx7wyvrfmfj31vq0u0q87.jpg) \n\neBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。\n\n## Sidecar 与 per-Node 代理\n\n即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。\n\n### 每个连接的代理\n\n所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。\n\n![基于 eBPF 的模型](008i3skNly1gx7wyy16o4j32960kcwg9.jpg)\n\n用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。\n\n![基于 Sidecar 代理的模型](008i3skNly1gx7wz3o1f6j32860lego3.jpg)\n\n切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。\n\n![Per-node 代理模式](008i3skNly1gx7wyx2lulj32980o4dhz.jpg)\n\n### 所需的代理总数\n\n在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。\n\n![代理数量](008i3skNly1gx7y8synvej31z40oiq6n.jpg) \n\n \n\n让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。\n\n### 多租户\n\n当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。\n\n![Envoy Namespace](008i3skNly1gx7z3klyfhj31hx0u0djs.jpg)\n\n如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（[Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019](https:\/\/www.youtube.com\/watch?v=08opgZkdYIw)）。\n\n## 想参与其中吗？- 加入 Cilium 服务网格测试版\n\n![测试版](008i3skNly1gx7wz1obexj327t0u0dkm.jpg) \n\n伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。\n\n- L7 流量管理和负载均衡（HTTP，gRPC，…）\n- 跨集群、云和集群的拓扑感知路由\n- TLS 终止\n- 通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等\n- 用 OpenTelemetry 和 Jaeger 集成进行追踪\n- 内置 Kubernetes Ingress 支持\n\n上述所有功能都可以在 [github.com\/cilium\/cilium](https:\/\/github.com\/cilium\/cilium) 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 [这个表格](https:\/\/forms.gle\/j9fwhAC6HnHRJQKeA)，或者你可以在 Cilium 社区的[公告](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)中阅读更多关于该计划的信息。\n\n## 总结\n\neBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。\n\n如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 [Twitter](https:\/\/twitter.com\/tgraf__) 或 [eBPF \u0026 Cilium Slack 联系我们](http:\/\/ebpf.io\/slack)。\n\n## 进一步阅读\n\n- [eBPF 如何简化服务网格](\/trans\/how-ebpf-streamlines-the-service-mesh\/)，Liz Rice，The New Stack\n- [Cilium 服务网格测试计划](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)，Cilium 社区\n- [了解更多关于 Cilium 的信息](https:\/\/cilium.io\/learn)\n', '\/trans\/ebpf-solve-service-mesh-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/slime-intro/">网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器', '本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。', '\n最近我在研究 Istio 生态中的开源项目，[Slime](https:\/\/github.com\/slime-io\/slime\/) 这个项目开源与 2021 年初，是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n## Slime 试图解决的问题\n\nSlime 项目的诞生主要为了解决以下问题：\n\n1. 网格内所有服务配置全量下到所有 Sidecar Proxy，导致其消耗大量资源使得应用性能变差的问题\n2. 如何在 Istio 中实现高阶扩展的问题：比如扩展 HTTP 插件；根据服务的资源使用率做到自适应限流\n\nSlime 解决以上问题的答案是构建 Istio 的控制平面，具体做法是：\n\n- 构建可拔插控制器\n- 数据平面监控\n- CRD 转换\n\n通过以上方式 Slime 可以实现**配置懒加载**和**插件管理器**。\n\n## Slime 架构\n\nSlime 内部分为三大模块，其架构图如下所示。\n\n![Slime 内部架构图](slime-internal-arch.jpg)\n\nSlime 内部三大组件为：\n\n1. \u0060slime-boot\u0060：在 Kubernetes 上部署 Slime 模块的 operator。\n2. \u0060slime-controller\u0060：Slime 的核心组件，监听 Slime CRD 并将其转换为 Istio CRD。\n3. \u0060slime-metric\u0060：用于获取服务 metrics 信息的组件，\u0060slime-controller\u0060 会根据其获取的信息动态调整服务治理规则。\n\n目前 Slime 内置了三个控制器子模块：\n\n1. **配置懒加载（按需加载）**：用户无须手动配置 \u0060SidecarScope\u0060，Istio 可以按需加载服务配置和服务发现信息；\n2. **HTTP 插件管理**：使用新的 CRD——\u0060pluginmanager\/envoyplugin\u0060 包装了可读性，摒弃了可维护性较差的 \u0060envoyfilter\u0060，使得插件扩展更为便捷；\n3. **自适应限流**：结合监控信息自动调整限流策略；\n\n\u003e **什么是 SidecarScope？**\n\u003e\n\u003e SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n\n## 使用 Slime 作为 Istio 的控制平面\n\n为了解决这些问题，Slime 在 Istio 之上构建了更高层次的抽象，相当于为 Istio 构建了一层管理平面，其工作流程图如下所示。\n\n![Slime 工作流程图](slime-flow-chart.jpg)\n\n具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；\n2. 开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n以上只是一个对 Slime 工作流程的一个笼统的介绍，更多详细信息请参考 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/)。\n\n## 配置懒加载\n\n为了解决数据平面中 Sidecar Proxy 资源消耗过大及网络延迟问题，Slime 使用了配置懒加载（按需加载 Sidecar 配置）的方案。该方案的核心思想是向每个 Sidecar Proxy 中只下发其所 Pod 中服务所需的配置，而不是将网格中的所有服务信息全量下发。所以 Slime 需要获取每个服务的调用关系这样才能得到其所需的 Sidecar Proxy 配置。\n\nSlime 实现 Sidecar Proxy 配置懒加载的方法是：\n\n- 让数据平面中的所有服务的首次调用都通过一个 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；\n- 当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060  的 CRD 来维护服务调用关系以解决服务信息缺失问题。\n\n### 使用 Global Proxy 初始化服务调用拓扑\n\nSlime 在数据平面中部署 Global Proxy（也叫做 Global Sidecar，但其与应用的 Pod 不是一对一的关系，笔者更倾向于称其为 Global Proxy），该代理同样使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n### 使用 ServiceFence 维护服务调用拓扑\n\n在使用 Global Proxy 初始化服务调用拓扑后，一旦服务调用链有变动的话怎么办？对此 Slime 创建了 ServiceFence 的 CRD。使用 ServiceFence 可以维护服务名和后端服务的映射关系。Slime 根据其对应服务的 VirtualService，找到 Kubernetes 服务名和真实后端（host）的映射关系，将两者的都加入 Sidecar 的配置中。ServiceFence 管理生成的 SidecarScope 的生命周期，自动清理长时间不用的调用关系，从而避免上述问题。\n\n### 如何开启配置懒加载\n\n配置懒加载功能对于终端用户是透明的，只需要 Kubernetes  Service 上打上 \u0060istio.dependency.servicefence\/status:\u0022true\u0022\u0060 的标签，表明该服务需要开启配置懒加载，剩下的事情交给 Slime Operator 来完成即可。\n\n## HTTP 插件管理\n\nIstio 中的插件扩展只能通过 EnvoyFilter 来实现，因为它是 xDS 层面的配置，管理和维护这样的配置需要耗费大量的精力，也极容易出错。因此，Slime 在 EnvoyFilter 的基础上做了一层面向插件的抽象。\n\nSlime 共有两个 CRD 用于 HTTP 插件管理，分别是：\n\n- **PluginManager**：配置为哪些负载开启哪些插件，插件的配置顺序即为执行顺序；\n- **EnvoyPlugin**：EnvoyPlugin 不关心每个插件的具体配置，具体配置会被放在 EnvoyFilter 资源的 \u0060patch.typed_config\u0060 结构中透传），EnvoyPlugin 的核心思想是将插件配置在需要的维度中做聚合，从而限定插件的生鲜范围。这样做一方面更加贴合插件使用者的习惯，另一方面也降低了上层配置的冗余，\n\n关于 Slime 中插件管理的详细使用方式请见 [Slime GitHub](https:\/\/github.com\/slime-io\/slime\/blob\/master\/doc\/zh\/plugin_manager.md)。\n\n## 自适应限流\n\nEnvoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。\n\nSlime 自适应限流的流程图如下所示。\n\n![Slime 的自适应限流流程图](slime-smart-limiter.jpg)\n\nSlime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 EnvoyFilter 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的 CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。\n\nSlime 创建的 CRD \u0060SmartLimiter\u0060 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  - action:\n      fill_interval:\n        seconds: 1\n      quota: \u002230\/{pod}\u0022    # 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10\n    condition: \u0022{cpu}\u003e0.8\u0022 # 根据监控项{cpu}的值自动填充该模板\n\u0060\u0060\u0060\n\n## 更多\n\nSlime 开源于 2021 年初，本文发稿时该项目仍处于初级阶段，本文大量参考了杨笛航在云原生社区中的分享 [Slime：让 Istio 服务网格变得更加高效与智能](https:\/\/cloudnative.to\/blog\/netease-slime\/) 及 Slime 的 [GitHub](https:\/\/github.com\/slime-io\/slime)。感兴趣的读者可以关注下这个项目的 GitHub，进一步了解它。\n\n另外欢迎关注服务网格和 Istio 的朋友加入云原生社区 Istio SIG，一起参与讨论和交流。\n\n## 参考\n\n- [Slime：让 Istio 服务网格变得更加高效与智能 - cloudnative.to](https:\/\/cloudnative.to\/blog\/netease-slime\/)\n- [Slime GitHub 文档 - github.com](https:\/\/github.com\/slime-io\/slime\/blob\/master\/README_ZH.md)\n- [Sidecar - istio.io](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)\n', '\/blog\/slime-intro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器 Slime。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-insight/">服务网格现状之我见</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格现状之我见', '本文探讨了服务网格和云原生的关系，社区发展现状，开源生态，及未来发展。', '\n本文根据 2021 年 11 月 22 日晚我应极客邦邀请在「极客时间训练营」的直播分享《云原生漫谈：聊聊 Service Mesh 的现状》整理而成。\n\n本来极客时间是想邀请我分享云原生的，但我觉得那个范围太大，在一次分享中只能泛泛而谈，无法聚焦到一个具体的点，因此我想还是先聚焦在服务网格这一个专题上吧。云原生社区最近倒是在做一个[云原生系列的分享](https:\/\/mp.weixin.qq.com\/s\/FWUkc1HJobhZgb26pG73Cg)，大家可以关注下。\n\n这是我今天分享的大纲：\n\n1. 第一探讨下服务网格跟云原生的关系\n2. 第二是给大家陈述下我观察到的目前社区里关于服务网格有哪些争论\n3. 第三是给大家介绍几个服务网格的相关的开源项目\n4. 最后是畅想下服务网格未来的发展\n\n## 服务网格与云原生的关系\n\n首先我们将探讨下服务网格与云原生的关系。\n\n### 服务网格——容器编排大战后的产物\n\n![Docker Swarm vs Kubernetes vs Mesos](008i3skNly1gwp7oq2980j313w0eqq56.jpg)\n\n如果你关注云原生领域足够早的话，应该还会对 2015 到 2017 年间的容器编排大战记忆犹新。关于服务网格的起源已经无需多言。2017 年 Kubernetes 获得了容器大战的胜利，微服务的理念已经深入人心，容器化的趋势可谓势不可挡。Kubernetes 架构趋向成熟，慢慢变得无聊，以 Linkerd、Istio 为代表的服务网格技术进入了 CNCF 定义的云原生关键技术视野中。\n\n服务网格将微服务中的通用的功能给下沉到了基础设施层，让开发者可以更加专注于业务逻辑，从而加快服务交付，这与整个云原生的理念的一致的。你不需要再在应用中集成笨重的 SDK，为不同语言开发和维护 SDK，应用部署完后，使用服务网格进行 Day 2 操作即可。\n\nKubernetes 设计之初就是按照云原生的理念设计的，云原生中有个重要概念就是微服务的架构设计，当将单体应用拆分微服务后，随着服务数量的增多，如何微服务进行管理以保证服务的 SLA 呢？为了从架构层面上解决这个问题，解放程序员的创造性，避免繁琐的服务发现、监控、分布式追踪等事务，服务网格应运而生。\n\n![微服务关注点](008i3skNly1gwp7qas2vtj30v70u0whb.jpg)\n\n来源：[RedHat](https:\/\/developers.redhat.com\/blog\/2016\/12\/09\/spring-cloud-for-microservices-compared-to-kubernetes)\n\n服务网格被誉为下一代微服务，从右面这幅图里我们可以看到微服务的一些关注点，这些关注点很多与 Kubernetes 的功能是重合的，既然这些作为平台级的功能 Kubernetes 已经提供了，为什么还要使用服务网格呢？其实 Kubernetes 关注的还是应用的生命周期，它管理的对象是资源和部署，对于服务的管控力度很小。而服务网格正好弥补了这个缺陷。服务网格可以连接、控制、观察和保护微服务。\n\n### Kubernetes vs xDS vs Istio\n\n这幅图展示的是 Kubernetes 和 Istio 的分层架构图。\n\n![Kubernetes vs Service mesh](008i3skNly1gxdhnnh4lxj31820p0gps.jpg)\n\n从图中我们可以看到 kube-proxy 的设置是全局的，无法对每个服务进行细粒度的控制，Kubernetes 可以做的只有拓扑感知路由、将流量就近路由，为 Pod 设置进出站的网络策略。\n\n而服务网格通过 sidecar proxy 的方式将 Kubernetes 中的流量控制从服务层中抽离出来，为每个 Pod 中注入代理，并通过一个控制平面来操控这些分布式代理。这样可以实现更大的弹性。\n\nKube-proxy 实现了一个 Kubernetes 服务的多个 pod 实例之间的流量负载均衡，但如何对这些服务之间的流量进行精细化控制–比如将流量按百分比划分给不同的应用版本（这些应用版本都是同一个服务的一部分，但在不同的部署上），或者做金丝雀发布（灰度发布）和蓝绿发布？\n\nKubernetes 社区给出了一个使用 Deployment 做金丝雀发布的方法，本质上是通过修改 pod 的标签来给部署的服务分配不同的 pod。\n\n![Envoy 架构图](envoy-arch.jpg)\n\n目前在中国最流行的服务网格开源实现是 Istio，也有很多公司对 Istio 进行了二次开发，比如蚂蚁、网易、腾讯等，其实 Istio 是在 Envoy 的基础上开发的，从它开源的第一天起就默认使用了 Envoy 作为它的分布式代理。Envoy 开创性的创造了 xDS 协议，用于分布式网关配置，大大简化了大规模分布式网络的配置。2019 年蚂蚁开源的 MOSN 同样支持了 xDS。Envoy 还是 CNCF 中最早毕业的项目之一，经过大规模的生产应用考验。可以说 Istio 的诞生已经有了很好的基础。\n\n下表是 Kubernetes、xDS、Istio 三者之间的资源抽象对比。\n\n| **Kubernetes** | **xDS**  | **Istio 服务网格** |\n| -------------- | -------- | ------------------ |\n| Endpoint       | Endpoint | WorkloadEntry      |\n| Service        | Route    | VirtualService     |\n| kube-proxy     | Route    | DestinationRule    |\n| kube-proxy     | Listener | EnvoyFilter        |\n| Ingress        | Listener | Gateway            |\n| Service        | Cluster  | ServiceEntry       |\n\nkube-proxy 组件、xDS 和 Istio 对流量管理的抽象后，现在我们仅从流量管理的角度来看看这三个组件 \/ 协议的比较。请注意，三者并不完全等同。Kubernetes 更加注重的是应用层面的流量管理，xDS 是更加抽象的协议层面的配置下发，而 Istio 是服务层面的配置。\n\n### 服务网格——云原生网络基础设施\n\n在列举过以上 Kubernetes 和服务网格的对比后，我们可以看出服务网格在云原生应用架构中的地位。那就是构建一个云原生网络基础设施，具体来说就是：\n\n- 流量管理：控制服务间的流量和 API 调用流，使调用更可靠，增强不同环境下的网络鲁棒性。\n- 可观测性：了解服务之间的依赖关系和它们之间的性质和流量，提供快速识别定位问题的能力。\n- 策略实施：通过配置网格而不是以改变代码的方式来控制服务之间的访问策略。\n- 服务识别与安全：提供在网格里的服务可识别性和安全性保护。\n\n## 社区里关于 Istio 和服务网格的争论\n\n然而构建基础设施，可谓牵一发而动全身。理想很丰满，现实很骨感。关于服务网格和 Istio，在社区中也不乏争论。我们来看看有这些争论主要有哪些。\n\n这里列举了我在社区中观察到的关于 Istio 和服务网格最常见的几个问题。\n\n1. 有人在生产使用 Istio 吗？\n2. 为 pod 注入 sidecar 后带来的大量资源消耗，影响应用性能？\n3. Istio 支持的协议有限，不易扩展？\n4. Istio 太过复杂，老的服务迁移成本太高，业界经验太少，学习曲线陡峭？\n\n第一个问题，也是很多人刚加入社区和了解这门技术的时候，问的第一个问题，那是有人在生产使用 Istio 吗？\n\n随着对 Istio 研究的深入，很多人就会抛出第二个问题，为 pod 注入 sidecar 后带来的大量资源消耗，会影响应用性能吗？\n\n如果能问到第三个问题，说明对 Istio 有比较强的需求了，大多是使用了自定义的 RPC，对 Istio 的协议扩展有需求。\n 最后一个问题是抱怨 Istio 的概念太过复杂，也没有一个清晰的迁移路径可以使用，学习曲线太过陡峭。\n\n下面我将一一回答这些问题。\n\n### Istio 架构稳定，生产可用，生态渐起\n\n![Istio 发布时间表](008i3skNly1gwp7wvt1g8j32yo0nk78g.jpg)\n\n首先我们来看下 Istio 的发布时间表，1.12 版本在上周刚刚发布，这里列举了从它开源到 1.8 版本发布的时间表。2018 年可以说是服务网格爆发之年，Tetrate 也在这一年成立。自 1.5 版本起 Istio 正式确立了当前的架构。Istio 社区也也举办了丰富多彩的活动，2021 年 3 月首届 IstioCon 召开，7 月 Istio Meetup China 在北京举行，2022 年 1 月，Service Mesh Summit 2022 也将在上海举行。\n\nIstio 有着庞大的社区以及[供应商和用户群体](https:\/\/istio.io\/latest\/about\/case-studies\/)。目前主流公有云全都支持了 Istio 服务网格，如阿里云、华为云、腾讯云、网易云等，Istio 的官网上也列举了几十个社区用户，云原生社区 Istio SIG 还陆续举办了八场 Istio 大咖说，百度、腾讯、网易、小红书、小电科技都来分享过他们的 Istio 实践。\n\n还有很多企业基于 Istio 做了二次开发或者适配或者为其开发插件，可以说是 Istio 架构已稳定，生产可用，生态正在萌芽中。\n\n### 服务网格对应用性能的影响\n\n服务网格为了做到对应用程序透明，默认采用了 iptables 流量劫持的方式，当服务数量大的时候会有大量的 iptables 规则，影响网络性能，你可以使用 [eBPF](https:\/\/cloudnative.to\/blog\/how-ebpf-streamlines-the-service-mesh\/) 这样的技术来提高应用性能，但是该技术对操作系统内核的版本要求比较高，很少有企业能够达到。\n\n![Istio 中的智能 DNS 代理](008i3skNly1gwp81fy0vqj31lq0nq41q.jpg)\n\n来源：\u003chttps:\/\/cloudnative.to\/blog\/istio-dns-proxy\/\u003e\n\n还有一种方式，也是小红书使用的方式，那就是利用 Istio 1.8 中引入的智能 DNS 代理功能。首先使用 ServiceEntry 定义服务，让所有服务属于一个 VIP 范围，再利用 Istio 的智能 DNS 代理功能，让 sidecar 只拦截 VIP 网段的流量，这样可以减少 iptables 规则，从而提高性能。如果想深入了解这个做法的细节，大家可以去浏览 [Istio 大咖说第八期的分享视频](https:\/\/www.bilibili.com\/video\/BV12b4y187ae\/)。\n\nIstio 在初期是将整个网格内的所有服务的路由信息全量下发到所有的 proxy sidecar 中，会导致 sidecar 占用大量资源，后来 Istio 引入了 [Sidecar 资源](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)来精细化控制需要下发的代理配置范围，另外还有企业自己开发了配置懒加载功能，例如腾讯云开源的 [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)、网易开源的 [Slime](https:\/\/github.com\/slime-io\/slime) 都可以实现配置懒加载。我们会在 Istio 开源生态中介绍这两个开源项目。\n\n最后是一个涉及到 Sidecar proxy 运维的问题，如何在保证流量不断的情况下，升级所有 Envoy 代理，这个阿里开源的 [OpenKruise](https:\/\/github.com\/openkruise\/kruise) 中的 [SidecarSet](https:\/\/xie.infoq.cn\/article\/23ae6d3f0d0260b4797a708a0) 资源已经给出了解决方案。\n\n另外 Sidecar 的引入带来的资源消耗以及网络延迟也是在合理的范围内，大家可以参考 Istio 官方博客上的 [Service Mesh 基准性能测试](https:\/\/istio.io\/latest\/zh\/blog\/2019\/performance-best-practices\/)。\n\n### 扩展 Istio 服务网格\n\n下一个问题是关于扩展 Istio 服务网格的。目前官方社区给出的方案是使用 WebAssembly，目前这种扩展方式在国内用的还比较少，而且性能也堪忧。我观察到的大部分解决方案都是自定义 CRD，基于 Istio 构建服务网格管理平面。\n\n另外，让 Istio 支持异构环境，适用于一切工作负载，如虚拟机、容器，这个对于终端用户来说也有很强的需求，因为这可以让用户很方便的从传统负载迁移应用到服务网格中。最后是多集群、多网格的混合云流量管理，这个属于比较高阶的需求了。\n\n### 陡峭的学习曲线\n\n以下列举的是 Istio 学习资源：\n\n- [Istio 官网中文文档](https:\/\/istio.io\/latest\/zh\/)\n- [IstioCon 2021](https:\/\/events.istio.io\/istiocon-2021\/)\n- Istio Meetup China\n- [Istio 大咖说\/Istio Weekly](https:\/\/github.com\/tetratelabs\/istio-weekly)\n- 云原生社区 Istio SIG\n- [Istio 基础教程（中文）](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals-zh)\n- [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)\n\nIstio 开源至今已有 4 年时间，2018 年时我和敖小剑一起创建了 ServiceMesher 社区，当时组织过 9 次 Service Mesh Meetup，同其他服务网格爱好者一起翻译了 Istio 的官方文档。我还在今年初参与了 IstioCon 2021 的筹办及首届 Istio Meetup China。可以说是亲眼目睹了国内服务网格技术的应用和发展，在这期间也写过和翻译过大量的文章，加入 Tetrate 后，我还参与发布了 Istio 基础教程，免费提供给大家学习。同时 Tetrate 也推出了认证 Istio 管理员考试，用于培养更多行业人才。\n\n云原生社区组织了 Istio SIG，还推出了 Istio 大咖说直播栏目，为大家分享 Istio 服务网格实践经验。\n\n下图是 [Istio 基础教程](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals-zh)的首页截图。\n\n![Istio 基础教程（Tetrate 出品）](008i3skNly1gwp8rr51ikj31ah0u043i.jpg)\n\n如果你是刚开始接触服务网格和 Istio，可以先从 Istio 基础教程开始学起。这个线上系列课程是图文并茂的中文课程，可以免费参加。\n\n好了，我们再来了解下服务网格的社区项目。\n\n## Istio 开源生态\n\n下表中罗列的是基于 Istio 的开源项目。\n\n| **项目名称**                                                 | **开源时间**  | **类别** | **描述**                                               | **主导公司** | **Star 数量** | **与 Istio 的关系**                           |\n| ------------------------------------------------------------ | ------------- | -------- | ------------------------------------------------------ | ------------ | ------------- | --------------------------------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | 2016 年 9 月   | 网络代理 | 云原生高性能边缘\/中间服务代理                          | Lyft         | 18300         | 默认的数据平面                                |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | 2017 年 5 月  | 服务网格 | 连接、保护、控制和观察服务。                           | Google       | 28400         | 控制平面                                      |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | 2018 年 2 月  | 网关     | 用于微服务的 Kubernetes 原生 API 网关，基于 Envoy 构建 | Ambassador   | 3500          | 可连接 Istio                                  |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | 2019 年 6 月  | 网关     | 云原生 API 网关                                        | API7         | 7400          | 可作为 Istio 的数据平面运行也可以单独作为网关 |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | 2019 年 12 月 | 代理     | 云原生边缘网关及代理                                   | 蚂蚁         | 3400          | 可作为 Istio 数据平面                         |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | 2021 年 1 月   | 扩展     | 基于 Istio 的智能服务网格管理器                        | 网易         | 204           | 为 Istio 增加一个管理平面                     |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | 2021 年 2 月  | 工具     | Istio 集成和命令行管理工具                             | Tetrate      | 91            | 实用工具，可用于 Istio 多版本管理             |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | 2021 年 3 月  | 扩展     | 管理 Istio 的任何七层负载                              | 腾讯         | 280           | 扩展多协议支持                                |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | 2021 年 6 月  | 运行时   | 云原生应用运行时                                       | 蚂蚁         | 325           | 可以作为 Istio 的数据平面                     |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | 2021 年 8 月  | 网关     | 基于 Envoy 和 Istio 构建的 API 网关                    | 网易         | 187           | 可与 Istio 集成                               |\n\n从 2017 年 5 月 Istio 开源至今也有 4 年多了，虽然该项目在 GitHub 上已经有很高的关注度，并发布了 10 几个版本，但其开源生态还在萌芽期。这张表列举了 Istio 生态中的开源项目，统计截止到 2021 年 11 月 11 日，表格按照开源时间排序。这些项目在 Istio 服务网格之上增强了网关、扩展和实用工具等。我将挑选其中 2 个来着重分享下。\n\n### Slime：基于 Istio 的智能服务网格管理器\n\nSlime 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无缝对接 Istio，无须做任何定制化改造，定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\nSlime 试图解决以下问题：\n\n- 在 Istio 中如何实现高阶扩展的问题，比如扩展 HTTP 插件，限流功能比较单薄，无法根据服务的资源使用率做到自适应限流\n- 解决 Sidecar 配置全量下发消耗大量资源导致应用性能变差的问题\n\nSlime 解决以上问题的答案是构建 Istio 的管理平面，其核心思路是：\n\n- 构建可拔插控制器\n- 数据平面监控\n- CRD 转换\n\n下图是 Istio 作为 Istio 管理平面的流程图。\n\n![Slime 如何作为 Istio 的控制平面](008i3skNly1gwp8td6cowj31i90u0aei.jpg)\n\nSlime 管理 Istio 的具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；\n2. 开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n下图展示的 Slime 的内部架构图。\n\n![Slime 内部架构图](008i3skNly1gwp8uzsj2wj31ac0oktb4.jpg)\n\n作为 Istio 的管理平面，可以将 Slime 的核心看做是 Istio 的一个 Operator。\n\nSlime 内部分为三大组件：\n\n- **slime-boot**：在 Kubernetes 上部署 Slime 模块的 operator。\n- **slime-controller**：Slime 的核心组件，监听 Slime CRD 并将其转换为 Istio CRD。\n- **slime-metric**：用于获取服务 metrics 信息的组件，slime-controller 会根据其获取的信息动态调整服务治理规则。\n\n下图展示的是 Slime 自适应限流的架构图。\n\n![Slime 自适应限流架构图](008i3skNly1gwp8xghoh2j311k0u0dim.jpg)\n\nEnvoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。\n\nSlime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 [EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/) 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的 CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。\n\nSlime 创建的 CRD SmartLimiter 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  - action:\n      fill_interval:\n        seconds: 1\n      quota: \u002230\/{pod}\u0022    # 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10\n    condition: \u0022{cpu}\u003e0.8\u0022 # 根据监控项{cpu}的值自动填充该模板\n\u0060\u0060\u0060\n\n### Aeraki：在 Istio 中管理任何七层协议\n\nAeraki 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目。Aeraki 提供了一个端到端的云原生服务网格协议扩展解决方案，以一种非侵入的方式为 Istio 提供了强大的第三方协议扩展能力，支持在 Istio 中对 Dubbo、Thrift、Redis，以及对私有协议进行流量管理。Aeraki 的架构如下图所示：\n\n![Aeraki 架构图](008i3skNly1gwp8ytw57sj31f40u0785.png)\n\n来源：\u003chttps:\/\/istio.io\/latest\/blog\/2021\/aeraki\/\u003e\n\n从 Aeraki 架构图中可以看到，Aeraki 协议扩展解决方案包含了两个组件：\n\n- Aeraki：Aeraki 作为一个 Istio 增强组件运行在控制面，通过自定义 CRD 向运维提供了用户友好的流量规则配置。Aeraki 将这些流量规则配置翻译为 Envoy 配置，通过 Istio 下发到数据面的 sidecar 代理上。Aeraki 还作为一个 RDS 服务器为数据面的 MetaProtocol Proxy 提供动态路由。Aeraki 提供的 RDS 和 Envoy 的 RDS 有所不同，Envoy RDS 主要为 HTTP 协议提供动态路由，而 Aeraki RDS 旨在为所有基于 MetaProtocol 框架开发的七层协议提供动态路由能力。\n- MetaProtocol Proxy：基于 Envoy 实现的一个通用七层协议代理。依托 Envoy 成熟的基础库，MetaProtocol Proxy 是在 Envoy 代码基础上的扩展。它为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地\/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度，只需要实现编解码的接口，就可以基于 MetaProtocol 快速开发一个第三方协议插件。\n\n如果没有使用 MetaProtocol Proxy，要让 Envoy 识别一个七层协议，则需要编写一个完整的 TCP filter，这个 filter 需要实现路由、限流、遥测等能力，需要投入大量的人力。对于大部分的七层协议来说，需要的流量管理能力是类似的，因此没有必要在每个七层协议的 filter 实现中重复这部分工作。Aeraki 项目采用了一个 MetaProtocol Proxy 来统一实现这些能力，如下图所示：\n\n![MetaProtocol Proxy 架构图](metaprotocol-proxy.png)\n\n基于 MetaProtocol Proxy，只需要实现编解码接口部分的代码就可以编写一个新的七层协议 Envoy Filter。除此之外，无需添加一行代码，Aeraki 就可以在控制面提供该七层协议的配置下发和 RDS 动态路由配置。\n\n![采用 MetaProtocol 编写 Envoy Filter 的对比](metaprotocol-proxy-codec.png)\n\nAeraki \u002b MetaProtocol 套件降低了在 Istio 中管理第三方协议的难度，将 Istio 扩展成为一个支持所有协议的全栈服务网格。目前 Aeraki 项目已经基于 MetaProtocol 实现了 Dubbo 和 Thrift 协议。相对 Envoy 自带的 Dubbo 和 Thrift Filter，基于 MetaProtocol 的 Dubbo 和 Thrift 实现功能更为强大，提供了 RDS 动态路由，可以在不中断存量链接的情况下对流量进行高级的路由管理，并且提供了非常灵活的 Metadata 路由机制，理论上可以采用协议数据包中携带的任意字段进行路由。QQ 音乐和央视频 APP 等业务也正在基于 Aeraki 和 MetaProtocol 进行开发，以将一些私有协议纳入到服务网格中进行管理。\n\n除此之外，[Aeraki Framework](https:\/\/github.com\/aeraki-framework) 中还提供了 xDS 配置下发优化的 lazyXDS 插件、Consul、etcd、Zookeeper 等各种第三方服务注册表对接适配，Istio 运维实战电子书等工具，旨在解决 Istio 在落地中遇到的各种实际问题，加速服务网格的成熟和产品化。\n\n## 服务网格的未来发展\n\n最后我想讲一下对于服务网格未来发展的一些看法。\n\n### 让 Istio 适用于一切环境和一切工作负载\n\n我们看到了网易、腾讯主要是通过构建 Operator 来扩展 Istio，然而这种扩展对于多集群管理来说并不够用。我们知道我们目前的基础设施很多是在向云原生化或者是容器化转型，那么就存在一个容器、虚拟机等共存的环境。这就是异构环境，这些不同环境的流量如何统一管理呢？其实使用 Istio 是可以做到的。同样是要在 Istio 之上构建一个管理平面，并增加一个抽象层，增加适用于集群管理的 CRD，比如集群流量配置、集群策略配置等。另外还要在每个集群中部署一个 Gateway，统一连接到一个边缘代理，让所有的集群互联。这也是 Tetrate Service Bridge 的产品理念。\n\n下图展示的 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 架构图。\n\n![Tetrate Service Bridge 架构图](tsb.png)\n\n### API 网关与服务网格的融合\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![访问 Istio 网格中服务的几种方式](008i3skNly1gwp935mcd0j31200u0n10.jpg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 声明周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n下表中列出了 Istio Mesh 中暴露服务的四种方式。\n\n| **方式**              | **控制器**         | **功能**                                                     |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 Nginx Service Mesh，Traefik 构建了 Traefik Mesh。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 Kuma。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n### 你是否真的需要服务网格？\n\n在使用服务网格前，请考虑以下问题：\n\n- 你的团队多少人里投入服务网格开发？使用 Kubernetes、Istio 的经验？\n- 你有多少微服务？这些微服务使用什么语言？\n- 你的服务都运行在哪些平台上？\n- 你的应用已经容器化并使用 Kubernetes 管理了吗？\n- 你的服务有多少是部署在虚拟机、有多少是部署到 Kubernetes 集群上，比例如何？\n- 你的团队有制定转移到云原生架构的计划吗？\n- 你想使用 Istio 的什么功能？Istio 的稳定性是否能够满足你的需求？\n- 你是否可以忍受 Istio 带来的性能损耗？\n- 你选择自建或者采购？\n\n## 总结\n\n最后总结一下今天的分享：\n\n- 从容器编排争霸到服务网格，我们可以看到云原生乃至整个云计算就是标准之争。\n- 服务网格的目标是成为云原生的网络基础设施，任重而道远。\n- 服务网格只是云原生庞大技术栈中的一环，不要一叶障目，技术的发展是永无止境的。\n- Istio 架构已经稳定，生产可用，生态正处于萌芽中。\n- 对于终端用户来说适合自己的才是最好的。\n\n本人才疏学浅，因为时间的原因，很多内容没有深入展开和探讨，最后欢迎大家加入云原生社区 Istio SIG 一起交流学习 Istio 和服务网格技术。\n', '\/blog\/service-mesh-insight\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨了服务网格和云原生的关系，社区发展现状，开源生态，及未来发展。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/grpc-proxyless-service-mesh/">[译] 基于 gRPC 和 Istio 的无 sidecar 代理的服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2021/proxyless-grpc/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('基于 gRPC 和 Istio 的无 sidecar 代理的服务网格', '本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。', '\n译者注：本文译自 Istio 官方博客，博客原标题 [gRPC Proxyless Service Mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/)，其实是 Istio 1.11 版本中支持的实验特性，可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。本文中还给出了一个 Demo 性能测试数据，这种做法可以极大的提升应用性能，降低网络延迟。\n\n------\n\nIstio 使用一组发现 API（统称为 [xDS API](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/operations\/dynamic_configuration) 来动态配置其 Envoy sidecar 代理。这些 API 的目标是成为一个 [通用的数据平面 API](https:\/\/blog.envoyproxy.io\/the-universal-data-plane-api-d15cec7a?gi=64aa2eea0283)。gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。你可以在 [Megan Yahya 的 KubeCon EU 2021 演讲](https:\/\/www.youtube.com\/watch?v=cGJXkZ7jiDk)中了解更多关于该集成的信息。关于 gRPC 支持的最新情况，可以在他们的[提案](https:\/\/github.com\/grpc\/proposal\/search?q=xds)中找到，还有实现状态。\n\nIstio 1.11 增加了实验性支持，可以直接将 gRPC 服务添加到网格中。我们支持基本的服务发现，一些基于 VirtualService 的流量策略，以及双向 TLS。\n\n## 支持的功能\n\n与 Envoy 相比，目前 gRPC 内的 xDS API 的实现在某些方面是有限的。以下功能应该可以使用，尽管这不是一个详尽的列表，其他功能可能部分可用。\n\n- 基本的服务发现。你的 gRPC 服务可以接触到在网格中注册的其他 pod 和虚拟机。\n- \u0060DestinationRule\u0060\n  - \u0060Subset\u0060：你的 gRPC 服务可以根据标签选择器将流量分割到不同的实例组。\n  - 目前唯一支持的 Istio \u0060loadBalancer\u0060 是 \u0060ROUND_ROBIN\u0060，\u0060consistentHash\u0060 将在未来的 Istio 版本中加入（支持 gRPC）。\n  - \u0060tls\u0060 设置被限制为 \u0060DISABLE\u0060 或 \u0060ISTIO_MUTUAL\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n- \u0060VirtualService\u0060\n  - Header 匹配和 URI 匹配的格式为 \u0060\/ServiceName\/RPCName\u0060。\n  - 覆盖目标主机和子集。\n  - 加权的流量转移。\n- \u0060PeerAuthentication\u0060\n  - 只支持 \u0060DISABLE\u0060 和 \u0060STRICT\u0060。其他模式将被视为 \u0060DISABLE\u0060。\n  - 在未来的版本中可能会有对 auto-mTLS 的支持。\n\n其他功能包括故障、重试、超时、镜像和重写规则，可能会在未来的版本中支持。其中一些功能正等待在 gRPC 中实现，而其他功能则需要在 Istio 中支持。gRPC 中 xDS 功能的状态可以[在这里](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)找到。Istio 的支持状况将存在于未来的官方文档中。\n\n这个功能是[实验性的](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/)。标准的 Istio 功能将随着时间的推移和整体设计的改进而得到支持。\n\n## 架构概述\n\n![gRPC 服务如何与 istiod 通信的示意图](008i3skNly1gwp3lh9za5j311q0hm75n.jpg)\n\ngRPC 服务如何与 istiod 通信的示意图\n\n虽然不使用 proxy 进行数据面通信，但它仍然需要一个 agent 来进行初始化和与控制面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 istiod，在哪里可以找到数据面通信的证书，以及向控制面发送什么元数据。接下来，agent 作为一个 xDS proxy，代表应用程序与 istiod 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书。\n\n## 对应用程序代码的修改\n\n本节介绍了 gRPC 在 Go 中的 xDS 支持。其他语言也有类似的 API。\n\n为了启用 gRPC 中的 xDS 功能，你的应用程序必须做一些必要的修改。你的 gRPC 版本应该至少是 1.39.0。\n\n### 客户端\n\n下面的导入将在 gRPC 中注册 xDS 解析器和均衡器。它应该被添加到你的主包或调用 \u0060grpc.Dial\u0060 的同一个包中。\n\n\u0060\u0060\u0060go\nimport _ \u0022google.golang.org\/grpc\/xds\u0022\n\u0060\u0060\u0060\n\n当创建一个 gRPC 连接时，URL 必须使用 \u0060xds:\/\/\/\u0060 scheme。\n\n\u0060\u0060\u0060go\nconn, err := grpc.DialContext(ctx, \u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022)\n\u0060\u0060\u0060\n\n此外，为了支持（m）TLS，必须向 \u0060DialContext\u0060 传递一个特殊的 \u0060TransportCredentials\u0060 选项。\u0060FallbackCreds\u0060 允许我们在 istiod 不发送安全配置时成功。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/credentials\/xds\u0022\n\n...\n\ncreds, err := xds.NewClientCredentials(xds.ClientOptions{\nFallbackCreds: insecure.NewCredentials()\n})\n\/\/ handle err\nconn, err := grpc.DialContext(\nctx,\n\u0022xds:\/\/\/foo.ns.svc.cluster.local:7070\u0022,\ngrpc.WithTransportCredentials(creds),\n)\n\u0060\u0060\u0060\n\n### 服务端\n\n为了支持服务器端的配置，如 mTLS，必须做一些修改。\n\n首先，我们使用一个特殊的构造函数来创建 \u0060GRPCServer\u0060。\n\n\u0060\u0060\u0060go\nimport \u0022google.golang.org\/grpc\/xds\u0022\n\n...\n\nserver = xds.NewGRPCServer()\nRegisterFooServer(server, \u0026fooServerImpl)\n\u0060\u0060\u0060\n\n如果你的 \u0060protoc\u0060 生成的 Go 代码已经过期，你可能需要重新生成，以便与 xDS 服务器兼容。你生成的 \u0060RegisterFooServer\u0060 函数应该像下面这样。\n\n\u0060\u0060\u0060go\nfunc RegisterFooServer(s grpc.ServiceRegistrar, srv FooServer) {\ns.RegisterService(\u0026FooServer_ServiceDesc, srv)\n}\n\u0060\u0060\u0060\n\n最后，与客户端的变化一样，我们必须启用安全支持。\n\n\u0060\u0060\u0060go\ncreds, err := xds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})\n\/\/ handle err\nserver = xds.NewGRPCServer(grpc.Creds(creds))\n\u0060\u0060\u0060\n\n### 在你的 Kubernetes 部署中\n\n假设你的应用代码是兼容的，Pod 只需要注释 \u0060inject.istio.io\/templates：grpc-agent\u0060。这增加了一个运行上述代理的 sidecar 容器，以及一些环境变量，gRPC 使用这些变量来寻找引导文件并启用某些功能。\n\n对于 gRPC 服务端，你的 Pod 也应该用 \u0060proxy.istio.io\/config: \u0027{\u0022holdApplicationUntilProxyStarts\u0022: true}\u0027\u0060 来注释，以确保在你的 gRPC 服务端初始化之前，代理中的 xDS 代理和引导文件已经准备就绪。\n\n## 例子\n\n在本指南中，你将部署 echo，一个已经支持服务器端和客户端无代理的 gRPC 的应用。通过这个应用程序，你可以尝试一些支持的流量策略，启用 mTLS。\n\n### 先决条件\n\n本指南要求在进行之前[安装](https:\/\/istio.io\/latest\/docs\/setup\/install\/) Istio（1.11\u002b）控制平面。\n\n### 部署应用程序\n\n创建一个支持注入的命名空间 \u0060echo-grpc\u0060。接下来部署两个 \u0060echo\u0060 应用程序的实例以及服务。\n\n\u0060\u0060\u0060sh\n$ kubectl create namespace echo-grpc\n$ kubectl label namespace echo-grpc istio-injection=enabled\n$ kubectl -n echo-grpc apply -f samples\/grpc-echo\/grpc-echo.yaml\n\u0060\u0060\u0060\n\n确保两个 Pod 正在运行。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc get pods\n\nNAME                       READY   STATUS    RESTARTS   AGE\necho-v1-69d6d96cb7-gpcpd   2\/2     Running   0          58s\necho-v2-5c6cbf6dc7-dfhcb   2\/2     Running   0          58s\n\u0060\u0060\u0060\n\n### 测试 gRPC 解析器\n\n首先，将 17171 端口转发到其中一个 Pod 上。这个端口是一个非 xDS 支持的 gRPC 服务端，允许从端口转发的 Pod 发出请求。\n\n\u0060\u0060\u0060sh\n$ kubectl -n echo-grpc port-forward $(kubectl -n echo-grpc get pods -l version=v1 -ojsonpath=\u0027{.items[0].metadata.name}\u0027) 17171 \u0026\n\u0060\u0060\u0060\n\n接下来，我们可以发送一批 5 个请求。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 5}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n\nHandling connection for 17171\n[0 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[1 body] Hostname=echo-v2-cf97bd94d-qf628\n[2 body] Hostname=echo-v1-7cf5b76586-bgn6t\n[3 body] Hostname=echo-v2-cf97bd94d-qf628\n[4 body] Hostname=echo-v1-7cf5b76586-bgn6t\n\u0060\u0060\u0060\n\n你也可以使用类似 Kubernetes 名称解析的短名称。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join\n(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v1-7cf5b76586-ltr8q\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r\n\u0027.output | join(\u0022\u0022)\u0027  | grep Hostname\n[0 body] Hostname=echo-v2-cf97bd94d-jt5mf\n\u0060\u0060\u0060\n\n### 用目的地规则创建子集\n\n首先，为每个版本的工作负载创建一个子集。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-versions\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\nEOF\n\u0060\u0060\u0060\n\n### 流量转移\n\n使用上面定义的子集，你可以把 80% 的流量发送到一个特定的版本。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1beta1\nkind: VirtualService\nmetadata:\n  name: echo-weights\n  namespace: echo-grpc\nspec:\n  hosts:\n  - echo.echo-grpc.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v1\n      weight: 20\n    - destination:\n        host: echo.echo-grpc.svc.cluster.local\n        subset: v2\n      weight: 80\nEOF\n\u0060\u0060\u0060\n\n现在，发送一组 10 个请求。\n\n\u0060\u0060\u0060sh\ngrpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022, \u0022count\u0022: 10}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027  | grep ServiceVersion\n\u0060\u0060\u0060\n\n响应应主要包含 v2 响应。\n\n\u0060\u0060\u0060plain\n[0 body] ServiceVersion=v2\n[1 body] ServiceVersion=v2\n[2 body] ServiceVersion=v1\n[3 body] ServiceVersion=v2\n[4 body] ServiceVersion=v1\n[5 body] ServiceVersion=v2\n[6 body] ServiceVersion=v2\n[7 body] ServiceVersion=v2\n[8 body] ServiceVersion=v2\n[9 body] ServiceVersion=v2\n\u0060\u0060\u0060\n\n### 启用 mTLS\n\n由于在 gRPC 中启用安全所需的应用程序本身的变化，Istio 的自动检测 mTLS 支持的传统方法是不可靠的。出于这个原因，初始版本需要在客户端和服务端上明确启用 mTLS。\n\n要启用客户端的 mTLS，请应用带有 \u0060tls\u0060 设置的 \u0060DestinationRule\u0060。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  host: echo.echo-grpc.svc.cluster.local\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\nEOF\n\u0060\u0060\u0060\n\n现在，试图调用尚未配置 mTLS 的服务器将会失败。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\nERROR:\nCode: Unknown\nMessage: 1\/1 requests had errors; first error: rpc error: code = Unavailable desc = all SubConns are in TransientFailure\n\u0060\u0060\u0060\n\n为了启用服务器端的 mTLS，应用一个 \u0060PeerAuthentication\u0060。\n\n以下策略对整个命名空间强制采用 STRICT mTLS。\n\n\u0060\u0060\u0060sh\n$ cat \u003c\u003cEOF | kubectl apply -f -\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: echo-mtls\n  namespace: echo-grpc\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n应用该政策后，请求将开始成功。\n\n\u0060\u0060\u0060sh\n$ grpcurl -plaintext -d \u0027{\u0022url\u0022: \u0022xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070\u0022}\u0027 :17171 proto.EchoTestService\/ForwardEcho | jq -r \u0027.output | join(\u0022\u0022)\u0027\n\nHandling connection for 17171\n[0] grpcecho.Echo(\u0026{xds:\/\/\/echo.echo-grpc.svc.cluster.local:7070 map[] 0  5s false })\n[0 body] x-request-id=0\n[0 body] Host=echo.echo-grpc.svc.cluster.local:7070\n[0 body] content-type=application\/grpc\n[0 body] user-agent=grpc-go\/1.39.1\n[0 body] StatusCode=200\n[0 body] ServiceVersion=v1\n[0 body] ServicePort=17070\n[0 body] Cluster=\n[0 body] IP=10.68.1.18\n[0 body] IstioVersion=\n[0 body] Echo=\n[0 body] Hostname=echo-v1-7cf5b76586-z5p8l\n\u0060\u0060\u0060\n\n## 限制条件\n\n最初的版本有几个限制，可能会在未来的版本中修复。\n\n- 不支持自动 mTLS，也不支持许可模式。相反，我们需要在服务器上使用 \u0060STRICT\u0060，在客户端使用 \u0060ISTIO_MUTUAL\u0060 的明确 mTLS 配置。在迁移到 \u0060STRICT\u0060 的过程中，可以使用 Envoy。\n- \u0060grpc.Serve(listener)\u0060 或 \u0060grpc.Dial(\u0022xds:\/\/...\u0022)\u0060 在 bootstrap 被写入或 xDS 代理准备好之前被调用会导致失败。 \u0060holdApplicationUntilProxyStarts\u0060 可以用来解决这个问题，或者应用程序可以对这些失败更加稳健。\n- 如果支持 xDS 的 gRPC 服务器使用 mTLS，那么你将需要确保你的健康检查可以绕过这个问题。要么使用一个单独的端口，要么你的健康检查客户端需要一种方法来获得适当的客户端证书。\n- gRPC 中 xDS 的实现与 Envoy 不一致。某些行为可能不同，某些功能可能缺失。[gRPC 的功能状态](https:\/\/github.com\/grpc\/grpc\/blob\/master\/doc\/grpc_xds_features.md)提供了更多细节。请确保测试任何 Istio 配置是否真正适用于你的无代理的 gRPC 应用程序。\n\n## 性能\n\n### 实验设置\n\n- 使用 Fortio，一个基于 Go 的负载测试应用程序\n  - 稍作修改，以支持 gRPC 的 XDS 功能 (PR)\n- 资源：\n  - GKE 1.20 集群有 3 个 \u0060e2-standard-16\u0060 节点（每个节点有 16 个 CPU\u002b64GB 内存）\n  - Fortio 客户端和服务器应用程序：1.5 vCPU，1000 MiB 内存\n  - Sidecar（istio-agent 和可能的 Envoy 代理）：1 vCPU，512 MiB 内存\n- 测试的工作负载类型：\n  - 基线：常规的 gRPC，没有使用 Envoy 代理或 Proxyless xDS\n  - Envoy：标准的 istio-agent \u002b Envoy proxy sidecar\n  - 无代理：使用 xDS gRPC 服务器实现的 gRPC 和客户端的 \u0060xds:\/\/\/\u0060 解析器。\n  - 通过 \u0060PeerAuthentication\u0060 和 \u0060DestinationRule\u0060 启用 \/ 停用 mTLS\n\n### 延迟\n\n![P50 延迟对比图](008i3skNly1gwp512szlvj31260rgq57.jpg)\n\nP50 延迟对比图\n\n![P99 延迟对比图](008i3skNly1gwp51zjxqaj312q0r2jtl.jpg)\n\nP99 延迟对比图\n\n在使用无代理的 gRPC 解析器时，延迟会有微小的增加。与 Envoy 相比，这是一个巨大的改进，仍然可以实现先进的流量管理功能和 mTLS。\n\n### istio-proxy 容器的资源使用情况\n\n| 类别        | 客户端 \u0060mCPU\u0060 | 客户端内存 (\u0060MiB\u0060) | 服务端 \u0060mCPU\u0060 | 服务端内存 (\u0060MiB\u0060) |\n| ----------- | ------------- | ------------------ | ------------- | ------------------ |\n| Envoy 明文  | 320.44        | 66.93              | 243.78        | 64.91              |\n| Envoy mTLS  | 340.87        | 66.76              | 309.82        | 64.82              |\n| 无代理明文  | 0.72          | 23.54              | 0.84          | 24.31              |\n| 无代理 mTLS | 0.73          | 25.05              | 0.78          | 25.43              |\n\n尽管我们仍然需要一个代理，但代理使用的内存不到完整 vCPU 的 0.1%，而且只有 25 MiB，这还不到运行 Envoy 所需内存的一半。\n\n这些指标不包括应用容器中 gRPC 的额外资源使用量，但有助于展示 istio-agent 在此模式下运行时的资源使用影响。\n', '\/trans\/grpc-proxyless-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 对 gRPC 的无代理服务网格功能的支持。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-servicemesh-api-gateway/">如何理解 Istio Ingress，它与 API Gateway 有什么区别？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio Ingress，它与 API Gateway 有什么区别？', '服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。', '\nAPI 网关作为客户端访问后端的入口，已经存在很长时间了，它主要是用来管理”南北向“的流量；近几年服务网格开始流行，它主要是管理系统内部，即“东西向”流量，而像 Istio 这样的服务网格还内置了网关，从而将系统内外部的流量纳入了统一管控。这经常给初次接触 Istio 的人带来困惑——服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。\n\n## 主要观点\n\n- 服务网格诞生的初衷是为了解决分布式应用的内部流量的管理问题，而在此之前 API 网关已存在很久了。\n- 虽然 Istio 中内置了 Gateway，但是你仍可以使用自定义的 Ingress Controller 来代理外部流量。\n- API 网关和服务网格正朝着融合的方向发展。\n\n## 如何暴露 Istio mesh 中的服务？\n\n下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort\/LB 暴露 Istio mesh 中服务的四种方式。\n\n![暴露 Kubernetes 中服务的几种方式](access-cluster.svg)\n\n其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。\n\n| 方式                  | 控制器             | 功能                                                         |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | 负载均衡                                                     |\n| Kubernetes Ingress    | Ingress Controller | 负载均衡、TLS、虚拟主机、流量路由                            |\n| Istio Gateway         | Istio              | 负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能 |\n| API 网关              | API Gateway        | 负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制 |\n\n由于 NodePort\/LoadBalancer 是 Kubernetes 内置的基本的暴露服务的方式，本文就不讨论这种方式了。下文将对其他三种方式分别作出说明。\n\n## 使用 Kubernetes Ingress 暴露服务\n\n我们都知道 Kubernetes 集群的客户端是无法直接访问 Pod 的 IP 地址的，因为 Pod 是处于 Kubernetes 内置的一个网络平面中。我们可以将 Kubernetes 内的服务使用 NodePort 或者 LoadBlancer 的方式暴露到集群以外。同时为了支持虚拟主机、隐藏和节省 IP 地址，可以使用 [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来暴露 Kubernetes 中的服务。Kubernetes Ingress 原理如下图所示。\n\n![使用 Kubernetes Ingress 暴露服务](ingress.svg)\n\n简单的说，Ingress 就是从 Kubernetes 集群外访问集群的入口，将用户的 URL 请求转发到不同的服务上。Ingress 相当于 Nginx、Apache 等负载均衡方向代理服务器，其中还包括规则定义，即 URL 的路由信息，路由信息得的刷新由 [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers)来提供。\n\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\n上面的例子中的 \u0060kubernetes.io\/ingress.class: istio\u0060 注解表明该 Ingress 使用的 Istio Ingress Controller。 \n\n## 使用 Istio Gateway 暴露服务\n\n我们都知道 Istio 是继承 Kubernetes 之后发展出来的一个流行的服务网格实现，它实现了 Kubernetes 没有的一些功能，请参考[什么是 Istio？为什么 Kubernetes 需要 Istio？](https:\/\/jimmysong.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)简要来说，正是因为 Istio 补足了 Kubernetes 对于云原生应用的流量管理、可观测性和安全方面的短板，使得流量管理变得对应用程序透明，使这部分功能从应用程序中转移到了平台层，成为了云原生基础设施。\n\nIstio 0.8 以前版本中使用 Kubernetes [Ingress](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/) 来作为流量入口，其中使用 Envoy 作为 Ingress Controller。在 Istio 0.8 及以后的版本中，Istio 创建了 Gateway 对象。Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 sidecar 相同的 Envoy 代理。通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、遥测收集以及其他服务管控功能。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，它负责进出集群的南北流量。Istio Gateway 描述了一个负载均衡器，用于承载进出服务网格边缘的连接。该规范描述了一组开放端口和这些端口所使用的协议，以及用于负载均衡的 SNI 配置等。\n\nIstio Gateway 资源本身只能配置 L4 到 L6 的功能，例如暴露的端口、TLS 设置等；但 Gateway 可与 VirtualService 绑定，在 VirtualService 中可以配置七层路由规则，例如按比例和版本的流量路由，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。\n\n下面是一个 Gateway 与 VirtualService 绑定的示例。拥有 \u0060istio: ingressgateway\u0060 标签的 pod 将作为 Ingress Gateway 并路由对 \u0060httpbin.example.com\u0060 虚拟主机的 80 端口的 HTTP 访问，这相当于给 Kubernetes 敞开了一个外部访问的入口。这与使用 Kubernetes Ingress 最大的区别就是，需要我们手动将 VirtualService 与 Gateway 绑定，并指定 Gateway 所在的 pod。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\n下面这个 VirtualService 通过 \u0060gateways\u0060 与上面的网关绑定在了一起，以接受来自该网关的流量。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## 使用 API 网关暴露服务\n\nAPI 网关是位于客户端和后端服务之间的 API 管理工具，一种将客户端接口与后端实现分离的方式，在微服务中得到了广泛的应用。当客户端发出请求时，API 网关会将其分解为多个请求，然后将它们路由到正确的位置，生成响应，并跟踪所有内容。\n\nAPI Gateway 是微服务架构体系中的一类型特殊服务，它是所有微服务的入口，它的职责是执行路由请求、协议转换、聚合数据、认证、限流、熔断等。大多数企业 API 都是通过 API 网关部署的。API 网关通常会处理跨 API 服务系统的常见任务，例如用户身份验证、速率限制和统计信息。\n\n在网格中可以有一个或多个 API Gateway。API 网关的职责有：\n\n- 请求路由和版本控制\n- 方便单体应用到微服务的过渡\n- 权限认证\n- 数据聚合：监控和计费\n- 协议转换\n- 消息和缓存\n- 安全和报警\n\n以上很多基本功能比如路由和权限认证通过 Istio Gateway 也可以实现，只是在功能的丰富度和扩展性方面有些成熟的 API Gateway 可能更占优势，不过在 Istio mesh 中再引入 API Gateway 也可能带来一些弊端。\n\n- 引入了 API Gateway，需要考虑 API Gateway 本身的部署、运维、负载均衡等场景，增加了后端服务的复杂度\n- API Gateway 中承载了大量的接口适配，导致难以维护\n- 对于部分场景，增加了一跳可能导致性能的降低\n\n## 总结\n\n在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 生命周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。\n\n目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 [Nginx Service Mesh](https:\/\/www.nginx.com\/products\/nginx-service-mesh\/)，Traefik 构建了 [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 [Kuma](https:\/\/kuma.io)。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。\n\n## 参考\n\n- [利用 Gateway API 发展 Kubernetes 网络](https:\/\/cloudnative.to\/blog\/evolving-kubernetes-networking-with-the-gateway-api\/)\n- [如何为服务网格选择入口网关？](https:\/\/cloudnative.to\/blog\/how-to-pick-gateway-for-service-mesh\/)\n- [Service Mesh 和 API Gateway 关系深度探讨](https:\/\/cloudnative.to\/blog\/service-mesh-and-api-gateway\/)\n- [在 Istio 服务网格中使用 Traefik Ingress Controller](https:\/\/cloudnative.to\/blog\/using-traefik-ingress-controller-with-istio-service-mesh\/)\n', '\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">服务网格与 API 网关之间是什么关系？是不是使用了 Istio 就可以替代了 API 网关？Istio 的 API 网关是如何运作的？有哪些方式暴露 Istio mesh 中的服务？这篇文章给为你解答。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/7/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/9/" class="page-link">
             9
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/10/" class="page-link">
             10
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/9/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/page/10/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
