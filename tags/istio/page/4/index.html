<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-mode-limitations/">Istio Ambient 模式的局限性解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式的局限性解析', '深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。', '\n[Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) 版本的发布标志着 Ambient 模式正式进入 beta 阶段，随之发布了一篇标题为 [告别 Sidecar：Istio 的 Ambient 模式在 v1.22 中达到 Beta](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/) 的博客，声称 Layer 4 和 Layer 7 的功能现已可用于生产环境。其实社区早在一个月前的 KubeCon EU 上就宣布了这一里程碑。这种激动人心的宣传似乎在暗示我们可以彻底抛弃 Sidecar 模式，但事实真是如此吗？\n\n### 为什么不急于告别 Sidecar 模式？\n\n虽然我对新技术持开放态度，但完全告别 Sidecar 模式可能为时尚早。每种模式都有其特定的应用场景和优缺点。下面，我将详细分享 Ambient 模式相较于 Sidecar 模式的一些限制，帮助大家更好地理解两者之间的差异。\n\n### Ambient 模式与 Sidecar 模式的关键区别\n\n#### 流量管理\n\nAmbient 模式的 L7 流量管理支持尚未成熟，尚未达到生产环境的可用水平。相较之下，Sidecar 模式在这方面更为稳定和可靠。\n\n#### 安全性\n\n在 Ambient 模式下，mTLS 被强制在 namespace 级别开启，而 Sidecar 模式则赋予用户更大的灵活性，可以选择是否启用 mTLS。这种灵活性对于某些应用场景尤为重要。\n\n#### 可观测性\n\n对于 L7 层的遥测数据，Ambient 模式能否像 Sidecar 模式一样对每个 pod 进行精确的监控和追踪仍是一个疑问。Sidecar 模式在可观测性方面已被广泛验证，其能力更为成熟。\n\n#### 运维\n\n部署方面，Ambient 模式推荐使用 Helm，仅支持 Kubernetes 平台，而 Sidecar 模式还支持虚拟机和混合云环境。此外，Ambient 模式尚未得到主要云厂商的官方支持。在升级过程中，Ambient 模式的爆炸半径更大，暂不支持金丝雀发布，推荐使用蓝绿部署。对于从 Sidecar 模式向 Ambient 模式的迁移或二者共存，仍缺乏最佳实践。\n\n#### 扩展性\n\n目前对于 Wasm 插件的支持，Ambient 模式仍不明确，而 Sidecar 模式在这方面已经有了较为完善的支持。\n\n#### 其他功能特性\n\nDual Stack 模式在 Sidecar 模式下虽然仍处于实验阶段，但至少已有一定的实现，而 Ambient 模式是否支持这一特性仍不明朗。\n\n### 总结\n\n虽然 Istio 1.22 带来了令人兴奋的 Ambient 模式，但在完全告别 Sidecar 模式之前，我们需要慎重考虑这些限制和差异。每种模式都有其独特的优势和适用场景，用户应根据自身需求做出明智的选择。我将继续对 Ambient 模式进行测试和追踪，更多深入解读敬请关注本博客。', '\/blog\/istio-ambient-mode-limitations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入探讨 Istio 1.22 版本中的 Ambient 模式，与传统 Sidecar 模式的对比及其限制。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-gateway-introduction/">Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway 概述——使用 Gateway API 的现代 Kubernetes 入口', '本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。', '\n在 Kubernetes 环境下选择正确的网络通信工具至关重要。根据[Tetrate 的讨论](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/)，选择取决于网络通信的类型：南北向流量还是东西向流量。对于主要处理外部请求的服务，Envoy Gateway 是理想选择，它不仅高效管理流量，还能在你向微服务架构过渡时提供无缝集成。\n\n本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。\n\n## Envoy Gateway 及其在服务网格中的角色概述 {#overview}\n\nEnvoy Gateway 是一个围绕 Envoy Proxy 构建的 Kubernetes 原生 API 网关，它旨在降低用户采用 Envoy 作为 API 网关的难度，并为供应商建立 API 网关（例如 [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/)）增值产品奠定基础。\n\nEnvoy Gateway 不仅是管理南北流量的理想选择，也可作为连接和保护服务网格中服务的关键组件。它还通过提供安全的数据传输、流量路由、负均衡及故障恢复等功能，增强了微服务之间的通信效率和安全性。Envoy Gateway 利用其内置的 Envoy Proxy 技术，可以处理大量的并发连接和复杂的流量管理策略，同时保持较低的延迟和高吞吐量。\n\n此外，Envoy Gateway 与 Kubernetes Gateway API 的紧密集成使得它能够以声明式的方式进行配置和管理，极大简化了服务网格中网关的部署和更新过程。这种集成不仅提升了操作效率，还使得 Envoy Gateway 能够在不增加额外复杂性的前提下，与服务网格如 Istio 这样的解决方案无缝协作。\n\n下图展示了 Envoy Gateway 与服务网格的关系。\n\n\u0060\u0060\u0060mermaid \u0022Envoy Gateway 与服务网格的关系\u0022\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes 集群\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022服务\u0022]\n        pods[\u0022Pod\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022管理南北向流量\u0022 --\u003e svcs\n        eg -- \u0022由...配置\u0022 --\u003e gwapi\n        gwapi -. \u0022定义路由规格\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022服务网格\u0022]\n        smc[\u0022服务网格控制平面（如 Istio、Linkerd）\u0022]\n        smp[\u0022服务网格数据平面（Envoy Sidecars）\u0022]\n        smc -- \u0022配置\u0022 --\u003e smp\n        smp -- \u0022处理东西向流量\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022是...的一部分\u0022 .-\u003e SM\n    svcs -- \u0022连接到\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Envoy Gateway 与服务网格的关系](8691fed7a410e3a8f45252cc5c8e11db.svg)\n\n在 Kubernetes 集群中，Envoy Gateway 负责管理南北向流量，即进出集群的流量，并通过 Kubernetes Gateway API 进行配置，后者定义了服务的路由规格。集群内服务直接连接到 Pods。服务网格部分，由控制平面（如 Istio 或 Linkerd）配置数据平面中的 Envoy Sidecars，这些 Sidecars 负责处理集群内部的东西向流量。在这个系统中，Envoy Gateway 可以与服务网格相互协作，但它们各自独立地管理不同方向的流量。\n\n设想一下，Envoy Gateway 像是一个城市的主要入口（比如海关），所有的数据流，就像各种车辆，都得通过这个大门进出。它就像一个严格的守门员，负责审查、指导，确保每个数据包，就像每个乘客，都能被准确地送到目的地。在 Kubernetes 这座城市中，Envoy Gateway 管理着所有进城的流量，它确保数据流可以安全、高效地进入城市，并被准确地送达给城市内部的服务。\n\n进入城市之后，服务网格就接管了，这就像城市内部的一系列交通网络。服务网格中的 Envoy sidecars 就好比是这座城市内部的出租车或者公交车，负责把数据包从海带到它们在城市内部的具体目的地。Envoy Gateway 负责将外部请求顺利引入，之后服务网格负责在集群内部继续高效地处理这些请求。\n\nEnvoy Gateway 对 Kubernetes Gateway API 的支持，可以看作是对我们城市交通信号系统的一个重大升级。这不仅为进入城市的数据流提供了更加清晰和个性化的指引，而且让整个城市的交通运行更加智能化。\n\n## Envoy Gateway 的核心功能和优势 {#pros}\n\nEnvoy Gateway 提供了几个核心功能，使其成为 API 网关的突出选择：\n\n- **简化配置**：通过与 Kubernetes Gateway API 直接集成，Envoy Gateway 允许开发者使用 Kubernetes 自定义资源以声明方式配置路由规则、安全策略和流量管理。\n- **性能和可扩展性**：基于经过实战测试的 Envoy Proxy，它提供卓越的性能和可扩展性，轻松处理数千个服务和每秒数百万个请求。\n- **安全功能**：内置支持各种安全措施，如 SSL\/TLS 终止、OAuth2、OIDC 认证以及细粒度访问控制。\n- **可观测性**：提供全面的监控能力，包括详细的度量、日志和追踪，这对于诊断和理解流量行为至关重要。\n\n## 与 Gateway API 的关系 {#gateway-api}\n\n在 Kubernetes 环境中引入的 Gateway API 为集成和配置 Ingress 网关提供了一种新的强大方法，它与传统的 Ingress 相比具有更高的灵活性和功能性。正如我在 [Gateway API：Kubernetes 和服务网格入口中网关的未来](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) 中所讨论的，Gateway API 通过区分角色和提供跨命名空间支持，更适应多云环境，且已被多数 API 网关采用。这种 API 设计支持了 ingress 网关（南北向流量）与服务网格（东西向流量，跨集群路由）的融合，使得 Envoy Gateway 成为 Kubernetes 和服务网格中统一未来的网关解决方案。通过引入 Gateway API，Envoy Gateway 强化了其作为云原生环境中前沿代理的角色，使得用户能够更灵活地管理其流量和策略。\n\nKubernetes Gateway API 是 Envoy Gateway 的基石，它提供了一种更具表达性、灵活性和以角色为导向的方式来配置 Kubernetes 生态系统中的网关和路由。该 API 提供了如 GatewayClass、Gateway、HTTPRoute 等自定义资源定义（CRD），Envoy Gateway 利用这些资源创建用户友好且一致的配置模型，与 Kubernetes 的原生原则保持一致。\n\n{{\u003ccallout note \u0022什么是 API Gateway？\u0022\u003e}}\n\nAPI Gateway 是对 API 的全面管理和托管服务。它作为应用程序与后端服务之间的中间层，不仅处理创建、维护、发布、运行和下线等生命周期事件，还承担着更多关键职能。一个完善的 API Gateway 应该提供以下功能来丰富和扩展其基本定义：\n\n1. **流量控制**：API Gateway 应能够处理并控制到后端服务的流量，包括请求路由、负载均衡、熔断机制以及速率限制，以保证后端服务的稳定性和高可用性。\n2. **安全性保障**：应具备鉴权、授权和加密功能，能够有效地管理和保护 API 的安全。这涉及到身份验证机制、API 密钥管理、OAuth、JWT、mTLS 等，以确保只有授权的用户和服务能够访问 API。\n3. **监控和分析**：提供实时监控和日志记录功能，能够跟踪 API 的使用情况、性能指标、异常检测和分析流量模式，从而优化 API 的性能和响应能力。\n4. **变更管理**：支持对 API 变更进行管理，包括版本控制和渐进式部署（如蓝绿部署或金丝雀发布），以无缝过渡新版本且最小化对最终用户的影响。\n5. **请求和响应的转换**：允许对传入和传出的 API 调用进行转换，比如从 REST 到 GraphQL 的转换，或是添加、删除和修改请求头和响应头。\n6. **跨域资源共享（CORS）支持**：管理和控制跨域请求，允许不同域的前端应用安全地调用后端 API。\n7. **配额和计费**：为 API 使用设定配额限制，同时支持计费功能，以适用于商业化的 API 提供。\n8. **用户友好的开发者门户**：提供一个面向开发者的门户，使得第三方开发者可以轻松地发现、测试和集成 API。\n9. **协议支持**：支持各种网络协议，包括 HTTP\/HTTPS、WebSocket、gRPC 等，确保与多种客户端和服务的兼容性。\n10. **插件化和扩展性**：允许通过插件或中间件来扩展 API Gateway 的功能，使其可以根据业务需求灵活适配各种中间件服务。\n11. **服务治理**：集成服务注册和发现机制，以适应微服务架构下服务的动态性。\n\n综上所述，API Gateway 的角色远远超越了简单的 API 生命周期管理。它是实现微服务架构、确保服务安全性、提高运维效率和优化用户体验的关键组件。通过这些广泛的功能，API Gateway 成为现代云原生应用不可或缺的一部分。\n\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 架构概览 {#arch}\n\nEnvoy Gateway 的架构设计旨在轻量级和简洁。它包括一个动态配置运行作为数据平面的 Envoy 代理的控制平面。这种关注点的分离确保了网关可以随着流量的增长而扩展，而不影响控制平面的效率。\n\nEnvoy Gateway 的架构图如下所示。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n在这个架构图的核心是 Envoy Gateway，它是 Envoy 代理的执行实例，负责处理从 Kubernetes 集群进出的所有流量。初始启动时，Envoy Gateway 通过配置文件提供静态配置，建立其操作的基本参数。\n\nEnvoy Gateway 配置的动态方面由提供者处理，该提供者定义了网关与 Kubernetes 或其他动态配置输入源的交互。资源监视器负责监视 Kubernetes 资源的更改，特别关注与自定义资源定义（CRD）相关的 CRUD 操作。\n\n随着更改的发生，资源转换器介入将这些外部资源转换为 Envoy Gateway 可以理解的形式。这一转换过程进一步由特定于提供者的基础设施管理器促进，后者负责管理与特定云或基础设施提供商相关的资源，塑造中间表示形式的基础设施，这对于网关的功能至关重要。\n\n然后，该中间表示形式转变为 xDS 中间表示形式，作为 Envoy 理解和执行的最终 xDS 配置的先导。xDS 翻译器承担将这种中间表示形式转换为具体的 xDS 配置的角色。\n\n这些配置由 xDS 服务器交付并执行，该服务器作为服务，根据其收到的 xDS 配置，认真管理 Envoy 实例。Envoy 作为实际运行的代理，最终从 xDS 服务器接收这些配置，解释并实现它们以有效管理流量请求。\n\n最终，所有请求经过 Envoy 的处理后被重定向到了 Envoy Gateway 路由的流量的最终目的地，也就是后端服务。\n\n## 与其他网关的比较 {#comparations}\n\n与 Istio 的入口网关或 NGINX Ingress 等其他流行解决方案相比，Envoy Gateway 凭借其与 Kubernetes 的原生集成以及利用 Envoy 全部潜力的专注，而脱颖而出。下图从多方面对比了目前流行的一些开源的 API 网关。\n\n{{\u003ctable \u0022开源 API 网关对比\u0022\u003e}}\n| API 网关      | 支持的认证和授权策略                                         | 支持的服务发现组件                     | 支持的协议                       | 控制平面配置分发方法 | 支持的插件扩展机制   | 组织隶属               |\n| ------------- | ------------------------------------------------------------ | -------------------------------------- | -------------------------------- | -------------------- | -------------------- | -------------------------- |\n| Envoy Gateway | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                        | HTTP, HTTPS, gRPC                | xDS                  | 基于 Envoy Filter | CNCF                       |\n| Kuma          | mTLS, JWT                                                    | Kubernetes, Consul                     | HTTP, HTTPS, gRPC, TCP           | REST, gRPC           | 基于 Lua, Go       | CNCF                       |\n| NGINX Ingress | RBAC                                                         | Kubernetes                             | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD       | 基于 Nginx 模块    | N\/A                        |\n| APISIX        | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID 等 | Kubernetes, DNS, Consul, Nacos, Eureka | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI    | 基于 Lua, Wasm    | Apache Software Foundation |\n| Kong          | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI   | 基于 Lua          | N\/A                        |\n| Emissary      | Basic Auth                                                   | Kubernetes                             | HTTP, HTTPS, gRPC                | Kubernetes CRD       | 基于 Lua, Go      | CNCF                       |\n{{\u003c\/table\u003e}}\n\n## 快速开始使用 Envoy Gateway {#envoy-gateway-quick-start}\n\n要快速上手 Envoy Gateway，你可以通过以下简化步骤快速搭建一个本地实验环境。首先，启动一个本地 Kubernetes 集群：\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\n接下来，部署 Gateway API CRD 和 Envoy Gateway 本身：\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\n然后，安装网关配置并部署一个示例应用：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\n为了暴露 LoadBalancer 服务，这里我们使用端口转发作为示例。你也可以选择使用 \u0060minikube tunnel\u0060 或安装 [MetalLB](https:\/\/metallb.universe.tf\/installation\/) 作为负载均衡器：\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\n通过以下命令测试你的 Envoy Gateway 是否正常工作：\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\n想了解更多详细的安装和配置步骤，请访问 Envoy Gateway 网站。通过这些步骤，你可以快速开始探索 Envoy Gateway 的功能。\n\n## 总结 {#summary}\n\nEnvoy Gateway 不仅优化了云原生时代的七层网关配置，而且为从边缘网关向服务网格过渡提供了一个平滑的道路。由于服务网格的推广面临一些挑战，如对应用的侵入性和运维团队推动问题，边缘网关则更易于被开发团队接受。Envoy Gateway 采用简化的 Kubernetes Gateway API，提高了流量管理和可观测性的能力。此外，Envoy Gateway 到 Istio 的过渡对于已熟悉 Envoy 功能的团队来说，将是一个自信的技术进步，同时还支持从标准的 Kubernetes Gateway API 到 Istio Ingress Gateway 的无缝切换，或者作为一个定制解决方案继续与 Istio 协作。这些特点使得 Envoy Gateway 成为一个在云原生时代值得投资的网关选择。\n\n请继续关注本系列博客的后续部分，我们将深入探讨如何配置和优化 Envoy Gateway，提供实用指南并展示更广泛的实际应用案例。\n', '\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将探讨 Envoy Gateway 在 Kubernetes 上部署的优势，及其它与服务网格的关系，展示为何它是暴露服务到公网的理想选择。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-cni-deep-dive/">深入解析 Istio CNI：赋能无侵入式流量管理与强化服务网格安全</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/04/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解析 Istio CNI：赋能无侵入式流量管理与强化服务网格安全', '本文详细解释了 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 提升安全性和权限管理。', '\n本文将深入探讨 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 来解决传统模式中存在的安全和权限问题。本文内容包括：\n\n- Init 容器的安全风险及其解决方案。\n- Istio CNI 的工作原理及其优势。\n- Ambient Mode 的实现机制及其与 CNI 的集成。\n\n## Istio 网络要求与解决方案概览 {#overview}\n\nIstio 服务网格通过 Sidecar 模式实现应用流量的拦截和管理。该模式通过在应用程序 Pod 中注入 Sidecar Proxy 和 init 容器，并使用 iptables 规则来管理网络流量。详细的部署和操作过程请参见 [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](\/blog\/sidecar-injection-iptables-and-traffic-routing\/)。虽然此方法在多数 Kubernetes 平台上有效，但对高权限的依赖在多租户环境中引发了安全方面的担忧。\n\n### Istio-init 的局限性 {#istio-init}\n\nIstio 在其网络配置初期采用了 \u0060istio-init\u0060 容器来初始化流量拦截规则，这需要容器具有高级权限来修改网络配置，如 IPTables 规则。虽然这种方法实现了对流量的有效管理，但它也显著提高了权限需求并增加了安全风险。根据 [Istio 官方文档](https:\/\/istio.io\/latest\/zh\/docs\/setup\/additional-setup\/cni\/)，\u0060istio-init\u0060 容器默认被注入到 Istio 网格中的 Pod 里，以便将网络流量劫持到 Istio 的 Sidecar 代理。这一过程需要对部署 Pod 的 Service Account 赋予 [\u0060NET_ADMIN\u0060 容器权限](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/configure-pod-container\/security-context\/#set-capabilities-for-a-container)，可能与某些组织的安全政策相悖。\n\n### Istio CNI 插件 {#istio-cni-plugin}\n\n为响应这一挑战，Istio 社区推出了 [Istio CNI](https:\/\/github.com\/istio\/istio\/tree\/master\/cni) 插件，该插件避免了对 init 容器的需求，允许直接在 Kubernetes 的网络层面操作，从而降低权限需求并简化部署流程，但是存在 CNI 兼容性问题。\n\n### Ambient 模式的引入 {#ambient-mode}\n\nIstio 的 Ambient Mode 是一种创新的无 sidecar 方案，它通过 [使用 Geneve 隧道](\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/) 或 Istio CNI 提高网络的灵活性和安全性。\n\n直到最近 Istio 社区才推出[适配任意 CNI](https:\/\/istio.io\/latest\/zh\/blog\/2024\/inpod-traffic-redirection-ambient\/) 的通用的解决方案。此模式解决了与任意 CNI 的兼容性问题，使 Istio 能够在不影响现有网络策略的前提下，更有效地管理服务间的流量。\n\n## NET_ADMIN 权限的安全考虑 {#net-admin}\n\n在 Kubernetes 和 Docker 等容器化环境中，\u0060NET_ADMIN\u0060 权限允许容器内的进程执行广泛的网络相关操作。这包括修改 iptables 规则、更改网络接口配置、管理 IP 路由表，以及控制网络相关的内核参数。然而，这种权限的使用引发了安全上的考虑，特别是在权限过度和潜在的攻击面方面。\n\n**最佳实践包括**：\n\n- **限制使用范围**：只在必要时授予 \u0060NET_ADMIN\u0060 权限，并通过 Kubernetes 网络策略加以限制。\n- **持续监控与审计**：对使用 \u0060NET_ADMIN\u0060 权限的容器进行严格的日志记录和监控。\n\n## Istio CNI 插件的工作原理 {#istio-cni-principal}\n\nIstio CNI 插件是一个二进制文件，作为代理安装在每个节点的文件系统中。以下流程图说明了 Istio CNI 节点代理的工作原理：\n\n\u0060\u0060\u0060mermaid \u0022Istio CNI 插件的工作原理\u0022\nflowchart TB\n    subgraph istio_cni_node_agent[Istio CNI 节点代理]\n        direction LR\n        install_plugin[安装 Istio CNI 插件]\n        update_config[更新节点 CNI 配置位于 \/etc\/cni\/net.d]\n        monitor_paths[监控插件和配置路径]\n        \n        subgraph sidecar_mode[\u0022Sidecar 模式\u0022]\n            sidecar_setup[为 Pod 配置 iptables]\n        end\n        \n        subgraph ambient_mode[\u0022Ambient 模式\u0022]\n            ambient_server[Ambient 监控服务器]\n            sync_events[同步 Pod 事件]\n            configure_iptables[在 Pod 内配置 iptables]\n        end\n\n        install_plugin --\u003e update_config\n        update_config --\u003e monitor_paths\n        monitor_paths --\u003e sidecar_mode\n        monitor_paths --\u003e ambient_mode\n        ambient_mode --\u003e ambient_server\n        ambient_server --\u003e sync_events\n        sync_events --\u003e configure_iptables\n    end\n\u0060\u0060\u0060\n\n![Istio CNI 插件的工作原理](fb607dc081ac2cb19c109626ccfe368b.svg)\n\n\n\n- Istio CNI Node Agent 充当安装在每个节点上的代理。\n- 安装 Istio CNI 插件并更新节点的 CNI 配置。\n- 代理监控 CNI 插件和配置路径的更改。\n- 在 Sidecar 模式下，它使用 pod 的 iptables 处理 sidecar 网络设置。\n- 在 Ambient 模式下，它将 pod 事件同步到环境监控服务器，然后该服务器在 pod 内配置 iptables。\n- 节点需要提升权限，例如 \u0060CAP_SYS_ADMIN\u0060 、 \u0060CAP_NET_ADMIN\u0060 和 \u0060CAP_NET_RAW\u0060 才能在任一模式下运行。\n\n## 解析 Istio Ambient Mode 与 Kubernetes CNI 的冲突 {#confilct}\n\nIstio 的 Ambient Mode 是为了适配所有 CNI 而设计的一种模式，它通过 ztunnel 来透明地处理 Pod 内的流量转发，而不影响现有的 CNI 配置。这种模式下，Ambient Mode 通过 ztunnel 管理流量，使其流经 Istio 服务网格，而标准的 CNI 则侧重于为 Pod 提供标准化的网络接入。\n\nCNI 的主要职责是解决 Kubernetes Pod 之间的网络连通性，例如分配 IP 地址和转发数据包。相比之下，Ambient Mode 需要将流量导入 ztunnel，这与 CNI 的网络配置可能存在不兼容，主要问题包括：\n\n- 主流 CNI 的网络配置可能会与 Istio 的 CNI 扩展冲突，导致流量处理中断。\n- 如果部署的网络策略依赖于 CNI，那么使用 Istio CNI 时可能会影响这些策略的执行。\n\n为解决这些问题，可以通过将 ztunnel 运行在与 Pod 相同的用户空间中，避免与 CNI 修改过的内核空间的冲突。这样，Pod 可以直接连接到 ztunnel，绕过 CNI 的影响。\n\n下面的时序图描述了 Ambient mode 下的流程：\n\n\u0060\u0060\u0060mermaid \u0022Amibent mode 的运行流程\u0022\nsequenceDiagram\n    participant K8s_API as Kubernetes API\n    participant Plugin as CNI Plugin\n    participant Agent as Ambient CNI Agent\n    participant Server as Ambient Watch Server\n    participant Ztunnel as ztunnel\n\n    Plugin-\u003e\u003eAgent: CmdAdd (Pod 调度)\n    Agent-\u003e\u003eServer: 通知新的 Pod\n    Server-\u003e\u003eK8s_API: 检索 Pod 信息\n    K8s_API--\u003e\u003eServer: Pod 详情\n    Server-\u003e\u003eZtunnel: 设置 iptables\n    Ztunnel-\u003e\u003eServer: 确认设置\n    Server-\u003e\u003eAgent: 配置完成\n    Agent-\u003e\u003ePlugin: CmdDel (Pod 移除)\n    Server-\u003e\u003eZtunnel: 移除 iptables\n    Ztunnel--\u003e\u003eServer: 确认\n\u0060\u0060\u0060\n\n![Amibent mode 的运行流程](a513f6cb6fbbf1fd242a46a962706dd8.svg)\n\n\n\n- **Ambient CNI 代理** 通过监听信号着 Pod 创建的 UDS 事件来启动交互。\n- **Ambient 监控服务器** 根据需要修改 Pod 内的 iptables，将流量重定向到 ztunnel。\n- **ztunnel** 在 Kubernetes 集群内建立连接，并处理网络流量的重定向。\n\n## 解决 Istio Ambient Mode 和 Kubernetes CNI 的冲突 {#resolution}\n\n为缓解这些冲突，Istio 的 Ambient Mode 避免了对 CNI 修改过的内核空间的依赖：\n\n- **在用户空间运行 ztunnel**：这一策略让 ztunnel 与 Pod 运行在同一用户空间，避免了与 CNI 的直接冲突。\n- **确保 CNI 兼容性**：Istio CNI 配置必须在不影响现有 CNI 插件配置的前提下进行，确保 Pod 间的正常通信和流量管理。\n\n这些措施帮助 Istio 的 Ambient Mode 在不干扰现有 CNI 插件的情况下，有效管理服务间流量。\n\n## Istio Ambient Mode 的流量管理优化 {#optimization}\n\nAmbient Mode 在 Istio 中通过 **node-local Ztunnel** 实现了改进的流量转发机制，允许在 Pod 的网络命名空间中设置侦听套接字，实现从服务网格内部的加密（mTLS）和明文流量的有效重定向。这种方法不仅提高了流量管理的灵活性，还避免了与现有的 CNI 插件之间的潜在冲突。下面是该模式的具体实现流程：\n\n\u0060\u0060\u0060mermaid \u0022Ambient mode 的实现流程\u0022\ngraph TD\n    subgraph Kubernetes 集群\n    A[带有 istio.io\/dataplane-mode=ambient 的 Pod] --\u003e|被检测到| B(istio-cni 节点代理)\n    B --\u003e C{Pod 状态}\n    C --\u003e|新启动| D[CNI 插件触发]\n    C --\u003e|已运行| E[新 Pod 事件]\n    D \u0026 E --\u003e F[配置重定向]\n    F --\u003e|进入 Pod 的网络命名空间| G[建立网络重定向]\n    G --\u003e H[通知节点 Ztunnel]\n    H --\u003e|在 Pod 的命名空间中创建监听套接字| I[节点本地 Ztunnel 代理实例]\n    I --\u003e J[流量重定向已建立]\n    end\n\n    J --\u003e K{流量类型}\n    K --\u003e|mTLS| L[网格内的加密流量]\n    K --\u003e|明文| M[明文流量处理]\n\u0060\u0060\u0060\n\n![Ambient mode 的实现流程](37dcdcfa80a406219ebe4b580345b04d.svg)\n\n\n\n具体步骤如下：\n\n1. **侦测标记**：Istio CNI 节点代理侦测标记为 \u0060istio.io\/dataplane-mode=ambient\u0060 的 Pod。\n2. **触发 CNI 插件**：根据 Pod 事件（新启动或现有 Pod 加入网格）触发 CNI 插件，这一步会触发 Istio CNI 节点代理进行流量重定向配置。\n3. **配置重定向规则**：在 Pod 的网络命名空间内配置网络重定向规则，以便拦截并重定向至 node-local ztunnel 代理。\n4. **建立侦听套接字**：node-local ztunnel 在 Pod 的网络命名空间中创建侦听套接字，实现流量的重定向。\n5. **流量处理**：node-local ztunnel 处理网格内的加密（mTLS）和明文流量，确保数据传输的安全性和高效性。\n\n通过这种方法，Istio Ambient Mode 为 Kubernetes 环境中的服务间流量管理提供了一种更为高效和安全的解决方案。\n\n## 总结 {#summary}\n\n本文全面解析了 Istio CNI 插件的设计理念、实现方式和优势，特别是 Istio CNI 如何解决了传统 \u0060istio-init\u0060 方法中存在的权限和安全问题。通过这些创新，Istio 在网络安全和操作简便性上取得了重大进步，为 Kubernetes 环境中实施 Istio 提供了更灵活和高效的方法。\n', '\/blog\/istio-cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细解释了 Istio CNI 插件的设计理念、实现方式以及如何通过 Ambient Mode 提升安全性和权限管理。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/tetrate-vulnerability-scaner/">TVS：Istio 和 Envoy CVE 扫描解决方案</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('TVS：Istio 和 Envoy CVE 扫描解决方案', '本文将介绍 Tetrate 新推出的工具——Tetrate Vulnerability Scanner (TVS)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。', '\n本文将介绍 Tetrate 新推出的工具——[Tetrate Vulnerability Scanner (TVS)](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。在深入了解 TVS 的具体功能前，我们先简要回顾 CVE 的概念及其在软件安全性中的核心作用。\n\n## CVE 概览\n\nCVE，即通用漏洞和暴露，是一个公开的漏洞数据库，由 MITRE 公司负责维护。它旨在为软件中的漏洞提供一个标准化的命名体系，包含了漏洞的标识号、详细描述及参考链接。虽然 CVE 本身不提供漏洞的严重性评分，但它为网络安全专家、开发人员和企业提供了一个获取关键安全信息的重要平台。每个 CVE 记录的唯一标识号便于追踪漏洞相关信息，诸如受影响的软件系统、修复措施等。例如，2021 年著名的 Log4j 漏洞（CVE-2021-44228）由于影响广泛，严重程度评级为 10。\n\n## CVE 的实用场景\n\n一个典型的 CVE 使用案例是将 CVE 扫描功能集成到 CI\/CD 管道中，以自动化安全测试，从而阻止带有已知漏洞的代码合并到代码库并接收警报。这一过程有助于确保应用程序不会使用带有漏洞的包或库，从而提高了软件的安全性。\n\n例如 Github 将 CVE 检测和处理作为[供应链安全](https:\/\/docs.github.com\/en\/code-security\/supply-chain-security\/understanding-your-software-supply-chain\/about-supply-chain-security#what-is-dependabot)的关键一环，如果你在 Github 上托管了开源项目，并开启了 Dependabot，每当你的 PR 或 commit 存在漏洞时，你就可能收到类似下面的 CVE 通知：[jQuery Cross Site Scripting vulnerability](https:\/\/github.com\/advisories\/GHSA-257q-pv89-v3xv)。收到通知后你可以选择容忍该漏洞或者应用 patch。下图展示了 CVE 的处理流程。\n\n\u0060\u0060\u0060mermaid \u0022CVE 的处理流程\u0022\ngraph TD\n    A([Start]) --\u003e B(Discover Vulnerability)\n    B --\u003e|Security Researchers| C{Is it a new vulnerability?}\n    C --\u003e|Yes| D[Assign CVE ID]\n    C --\u003e|No| E[Refer to existing CVE entry]\n    D --\u003e|\u0022CVE Numbering Authorities (CNAs)\u0022| F[Publicly disclose details]\n    F --\u003e|Vendors\/Project Owners| G{Is patch available?}\n    G --\u003e|Yes| H[Develop and Release Patch]\n    G --\u003e|No| I[Issue Workaround or Mitigation Steps]\n    H --\u003e J[Deploy Patch]\n    I --\u003e J\n    J --\u003e|End Users\/System Administrators| K[Apply Patch or Mitigation]\n    K --\u003e L[Monitor for Issues\/Compliance]\n    L --\u003e M([End])\n\u0060\u0060\u0060\n\n![CVE 的处理流程](ba0a0031313b5067534b47482f51d78a.svg)\n\n\n\n\n\n## TVS 功能介绍\n\nIstio 经常在其官网发布 CVE 通知，例如 [ISTIO-SECURITY-2024-001](https:\/\/istio.io\/latest\/news\/security\/istio-security-2024-001\/)。以前，你必须手动跟踪这些通知，但现在你可以使用 TVS 自动执行 CVE 扫描任务，从而显着减少安全团队的工作量。\n\n目前 TVS 仅提供命令行工具，未来将作为服务集成到 TIS 中。下图展示了 TVS 运行结果。\n\n![TVS CLI](tvs.jpg)\n\n下图说明了 TVS 的工作流程。\n\n\u0060\u0060\u0060mermaid \u0022TVS 的工作流程示意图\u0022\ngraph TD\n    A([Start]) --\u003e B(Istio Containers Installed)\n    B --\u003e C(Collect SHA Digests)\n    C --\u003e D(Send Digests to Tetrate\u0027s APIs)\n    D --\u003e E{Is CVE Detected?}\n    E --\u003e|Yes| F[Log SHA Digests Without Personal Info]\n    E --\u003e|No| G[End, No Action Required]\n    F --\u003e H[Notify Users]\n    H --\u003e I[Apply Patches\/Workarounds]\n    I --\u003e J([End])\n\u0060\u0060\u0060\n\n![TVS 的工作流程示意图](9232ba9319ac498b7fcf50bb60bff86b.svg)\n\n\n\n1. 在 Istio 容器安装后开始。\n2. 收集安装的 Istio 容器的 SHA 摘要。\n3. 将摘要发送到 Tetrate 的 API。\n4. API 检测是否存在 CVE。\n   - 如果检测到 CVE，记录 SHA 摘要但不包含任何个人信息，并通知用户。\n   - 如果未检测到 CVE，则不需要采取任何行动。\n5. 用户收到通知后，应用补丁或缓解措施。\n6. 流程结束。\n\n所有人都可以免费下载和使用 TVS，不过在执行 CVE 扫描之前你需要先注册，详见 [TIS 文档](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)。\n\n## 供应链安全建议\n\n有[报告](https:\/\/www.slim.ai\/blog\/container-report-2023)指出，现在即使最流行的容器最新版本也有数百个 CVE，下面是为了保证的一些建议：\n\n- 尽早开始漏洞扫描和处理，而不是等到最后\n- 在 CI\/CD 中集成漏洞扫描工具\n- 定期更新 Istio 和 Envoy 到最新版本\n- 使用 Istio 官方推出的 [distroless 镜像](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/security\/harden-docker-images\/)，可以有效的减少攻击面并包含尽可能少的漏洞\n- 遵循 CNCF 推出的[软件供应链最佳实践](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/supply-chain-security\/supply-chain-security-paper\/sscsp.md)\n- 遵循 [Istio 安全最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n\n## TVS 的独特价值\n\nTVS 通过其命令行工具提供简便的 CVE 扫描操作，未来还计划在 Kubernetes 和 Tetrate Istio Subscription (TIS) 中集成，以进一步简化 Istio 和 Envoy 的 CVE 管理过程。TIS 提供自 Istio 发布起 14 个月内的 CVE 补丁和向后兼容支持，帮助用户及时获得安全更新，同时保持系统的稳定运行。\n\nTVS 为所有用户免费开放下载使用，使用前需进行简单的注册。更多信息请参阅 [TIS 文档](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/)。\n\n通过采纳 TVS 这一自动化的 CVE 扫描工具，企业能够更有效地识别和处理 Istio 及 Envoy 中的安全漏洞，提升基础设施的安全性，同时减轻安全团队的负担，推动安全管理流程的高效运作。\n', '\/blog\/tetrate-vulnerability-scaner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将介绍 Tetrate 新推出的工具——Tetrate Vulnerability Scanner (TVS)，一款针对 Istio 和 Envoy 定制的 CVE 扫描器。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/kubecon-eu-paris-recap/">KubeCon EU 2024 巴黎见闻与回顾</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon EU 2024 巴黎见闻与回顾', '探索 KubeCon EU 2024：从 Istio  与 Cilium 的最新动态，到云原生趋势如 AI 融合、Wasm 崛起、增强观测性的深入解读。', '\n上周我在巴黎参加了 [KubeCon EU 2024](https:\/\/events.linuxfoundation.org\/kubecon-cloudnativecon-europe\/)，这也是我第一次参加中国以外的 KubeCon。本次大会可谓盛况空前，据说有 1.2 万人参加了会议。本文将为你分享我对本次 KubeCon 的一些观察，主要着重在我关注的服务网格与云原生基础架构领域。\n\n![Istio Contributor 在 KubeCon EU Istio 展台](istio-day.jpg)\n\n## Istio、Cilium 及服务网格\n\n[Istio](https:\/\/istio.io) 和 Service Mesh 成为了热门讨论的话题，集中展示了在云原生生态系统中这两项技术的最新进展和应用。本次大会涵盖了从基础设施优化、数据本地化、分布式追踪到多集群部署等多个领域，反映了 Service Mesh 技术在实际应用中的广泛关注和持续创新。\n\n### 数据本地化和全局请求路由\n\nPigment 的 Arthur Busser 和 Baudouin Herlicq 分享了如何利用 Kubernetes 和 Istio 实现数据本地化的需求。他们介绍了利用 Istio 基于自定义头部进行请求路由的方法，这对于满足如 GDPR 和 CCPA 等法规的数据驻留要求至关重要。\n\n### 分布式跟踪和可观测性增强\n\nThousandEyes (part of Cisco) 的 Chris Detsicas 探讨了如何配置 Istio 以使用 OpenTelemetry 实现有效的分布式跟踪，这为微服务生态系统提供了宝贵的可见性，有助于问题诊断和性能优化。\n\n### 多集群部署和流量管理\n\nChina Mobile 的 Haiwen Zhang 和 Yongxi Zhang 介绍了一个简化 Istio 多集群部署的新方法，该方法使用一个全局唯一的 Istio 控制平面，通过主集群的 Apiserver 实现全局服务发现，自动连接多个集群的容器网络，为 Pod 提供直接网络连接。特别强调了 [Kosmos 项目](https:\/\/github.com\/kosmos-io\/kosmos)，它提供了一种新的解决方案，以简化多集群环境下的服务网格部署和管理。\n\nGoogle 的 Ameer Abbas 和 John Howard 探讨了如何在基础设施可靠性为 99.9% 的情况下构建出 99.99% 可靠性的服务，并提出了一系列应用架构原型（Archetypes），这些原型可以帮助设计和实现高可靠性的多集群应用程序。\n\n- **原型 1：活动 - 被动区域（Active Passive Zones）** - 在单个区域的两个区域部署所有服务，使用 SQL 数据库的只读副本，通过 L4 负载均衡器实现区域内的故障转移。\n- **原型 2：多区域（Multi Zonal）** - 在单个区域的三个区域部署所有服务，使用高可用性 SQL 数据库，通过全局或区域负载均衡器实现区域内的故障转移。\n- **原型 3：活动 - 被动区域（Active Passive Region）** - 在两个区域的三个区域部署所有服务，使用跨区域复制的 SQL 数据库，通过 DNS 和负载均衡器实现区域间的故障转移。\n- **原型 4：隔离区域（Isolated Regions）** - 在两个区域的三个区域部署所有服务，使用 Spanner 或 CockroachDB 等全局数据库，通过区域负载均衡器和 DNS 实现区域间的故障转移。\n- **原型 5：全局（Global）** - 在两个或更多区域的三个区域部署所有服务，使用 Spanner 或 CockroachDB 等全局数据库，通过全球负载均衡器实现全球范围内的故障转移。\n\n### 安全和零信任架构\n\n多个议题，如 Microsoft 的 Niranjan Shankar 所介绍的，聚焦于在生产环境中加固 Istio 的重要性和方法。他讨论了利用 Istio 与网络策略、第三方 Kubernetes 工具和云提供的安全服务相结合，构建零信任和深层防御架构的步骤和策略。\n\n### Ambient Mesh 的基础设施兼容性及未来\n\nBenjamin Leggett 和 Yuval Kohavi 引入了一种创新的方法，使 Istio 的 Amibent mode 能够支持任意 Kubernetes CNI，详见 [Istio 博客](https:\/\/istio.io\/latest\/zh\/blog\/2024\/inpod-traffic-redirection-ambient\/)。这一进步解决了 Ambient mesh 中 CNI 支持有限的问题，无需重启应用程序 Pod 即可将其纳入 Ambient mode，这对于简化操作和降低基础设施成本具有重要意义。\n\nIstio 社区宣布在即将到来的 Istio 1.22 版本，Ambient 模式将成为 beta，详见 [CNCF 博客](https:\/\/www.cncf.io\/blog\/2024\/03\/19\/istio-announces-the-beta-release-of-ambient-mode\/)。多个演讲和讨论聚焦于 Istio Ambient Mesh 的未来，特别是其简化工作负载操作和降低基础设施成本的潜力。Istio Ambient Mesh 的介绍预示了服务网格技术的一个新方向，即无 sidecar 的数据平面架构，提供了更高的性能和更低的资源消耗。\n\n### Sidecar-less 服务网格的革新\n\n在 KubeCon EU 2024 上，关于 Sidecar 的讨论主要集中在评估和比较使用 Sidecar 与无 Sidecar（如 Istio 的 Ambient Mesh）服务网格模式的优缺点。特别是 Christian Posta 对 Cilium 和 Istio 在无 sidecar 服务网格实现方面的设计决策和权衡进行了深入分析，突出了这种模式在提高性能、降低资源消耗和简化运维操作方面的潜力。通过分析纽约时报从 Istio 过渡到 Cilium 的案例，进一步证明了无 sidecar 模式在处理复杂、多区域服务网格时的有效性，同时指出了在这一转变过程中的挑战和实施考虑。这些讨论预示着服务网格技术未来可能朝向更加灵活和高效的方向发展，其中无 Sidecar 架构可能成为优化云原生应用性能和资源使用的关键策略。\n\n### Cilium 与服务网格的交集\n\n[Cilium](https:\/\/cilium.io) 在 KubeCon EU 2024 上被广泛讨论，作为一种基于 eBPF 的技术，Cilium 不仅被看作是一个高效的容器网络接口（CNI），而且还展示了其在服务网格领域的强大潜力。通过 Isovalent 和其他组织的演讲，Cilium 被展示为一种能够提供连接、观测和保障服务网格安全的先进解决方案。特别是 Cilium 的无 Sidecar 服务网格实现方式被认为是未来方向，其利用 eBPF 技术在不增加传统 Sidecar 代理负担的情况下实现了微服务的安全通信和精细流量管理。此外，Cilium 在服务网格之外的扩展能力，例如在多云网络和负载平衡方面的应用，凸显了其作为云原生生态系统基础设施核心组件的地位。Cilium 的这些讨论和案例研究证明了其在推动服务网格和云原生技术创新方面的重要作用。\n\n## 云原生趋势\n\n当前云原生领域的几个主要趋势：\n\n1. **可持续性和环保意识的增强**：例如，Deutsche Bahn 将开发者引入其基础设施绿化过程，强调了在设计和运营云原生解决方案时，越来越多的公司开始考虑环境因素。这反映了一个趋势，即企业在追求技术进步的同时，也在努力减少对环境的影响，通过绿色计算和能效优化来实现可持续的技术生态。\n\n2. **人工智能与云原生技术的融合**：人工智能（AI）正在成为 Kubernetes 和云原生生态系统面临的下一个主要挑战。Nvidia 关于 AI 策略的讨论、CNCF 对 AI 在云原生未来中标准化工作的推动，以及各种关于 AI 和机器学习（ML）集成的工具和平台的更新，都突显了这一点。这一趋势表明，将 AI 和 ML 无缝集成到云原生架构中，不仅可以加速应用开发和部署，还能够提供更加智能和自动化的操作能力。同时 CNCF 还宣布成立 AI WG，并发布了[人工智能白皮书](https:\/\/www.cncf.io\/reports\/cloud-native-artificial-intelligence-whitepaper\/)。\n\n3. **WebAssembly（Wasm）的兴起**：Cosmonic 对最新 Wasm 标准的支持，以及 Fermyon 将其开源 Wasm 平台 [SpinKube](https:\/\/www.spinkube.dev\/) 捐赠给 CNCF，显示了 WebAssembly 在云原生应用开发中日益增长的重要性。Wasm 提供了一种高效、安全的方式来运行在浏览器外的客户端和服务器端代码，这对于构建跨平台、高性能的云原生应用尤为重要。\n\n4. **云原生观测性的强化**：例如，New Relic 在其可观测性平台中添加了原生 Kubernetes 支持，凸显了对云原生应用的监控、日志记录和性能分析需求的增加。随着云原生架构的复杂性增加，企业需要更加强大的工具来保持系统的透明度和健康，从而优化性能和可靠性。\n\n5. **云原生社区的协作和开源精神的强化**：CNCF 成立[最终用户技术咨询委员会](https:\/\/www.cncf.io\/people\/end-user-technical-advisory-board\/)、Red Hat 与 Docker 合作开发 Testcontainers Cloud 框架等举措，反映了云原生社区致力于促进协作和分享的文化。这种开放的协作精神不仅加速了新技术的发展和采纳，也为云原生生态系统的健康成长提供了坚实的基础。\n\n这些趋势共同描绘了一个多元化、持续创新且日益成熟的云原生技术景观，其中可持续性、AI\/ML 集成、WebAssembly、加强的可观测性和社区协作是推动这一领域前进的关键因素。\n\n## 总结\n\nKubeCon EU 2024 的见闻为我们揭示了云原生技术领域的多个重要进展和未来方向。从服务网格的持续创新到云原生生态系统对环境可持续性的关注，再到人工智能与机器学习技术的深度整合，以及 WebAssembly 在应用开发中的日益重要性，这些趋势共同构成了当前云原生技术的前沿。\n\n特别值得注意的是，Istio 和 Cilium 在服务网格领域的最新动态，展现了无 Sidecar 架构的潜力以及 eBPF 技术在提升性能、安全性和可观测性方面的作用。这些进展不仅为开发者提供了更为高效和灵活的工具，也为云原生应用的设计和运营提出了新的思路。\n\n同时，云原生社区的持续发展和对开源精神的坚持，为技术创新和知识共享提供了坚实的基础。通过强化观测性、推动环境可持续性和促进技术标准化，云原生生态正展现出其深厚的发展潜力和广阔的应用前景。\n\n作为一名观察者和参与者，我深感云原生技术的快速发展给我们带来了前所未有的机遇和挑战。未来，随着技术的不断演进和社区的共同努力，我们有理由相信，云原生技术将在推动数字化转型和创造更加智能、可持续的技术世界方面发挥更大的作用。让我们拭目以待，并积极参与这一令人兴奋的技术旅程。\n\n', '\/blog\/kubecon-eu-paris-recap\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索 KubeCon EU 2024：从 Istio  与 Cilium 的最新动态，到云原生趋势如 AI 融合、Wasm 崛起、增强观测性的深入解读。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/automate-istio-ca-rotation-in-production-at-scale/">[译] 使用 Kyverno 更轻松地保护服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kyverno.io/blog/2024/02/04/securing-services-meshes-easier-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Kyverno 更轻松地保护服务网格', '利用 Kyverno 为服务网格提供更好的 Pod 安全性。', '如今在 Kubernetes 中，服务网格已经变得司空见惯，有些平台甚至默认将其构建到集群中。服务网格无疑在多种方面提供了诸多好处，这些好处众所周知，但也众所周知，它们显著增加了集群的复杂性。除了增加了复杂性之外，服务网格在强制执行 Pod 安全性方面也带来了（臭名昭著的）问题，因为它们需要提升的权限可能对其他准入控制器造成难以处理的困扰，例如 Kubernetes 自身的 Pod 安全准入控制器。在本文中，我们将更详细地解释这个问题以及在使用服务网格时 Kyverno 如何成为真正的救星，同时为你预览一下即将到来的 Kyverno 1.12 版本中的一些东西，这将使安全服务网格变得轻而易举！\n\n## 介绍\n\n服务网格[为 Kubernetes 应用程序提供了许多好处](https:\/\/konghq.com\/learning-center\/service-mesh\/what-is-a-service-mesh)，包括更好的负载均衡、双向 TLS、可观测性等。很可能你现在就在你的某个集群中使用了服务网格。最流行的开源服务网格包括 [Istio](https:\/\/istio.io\/) 和 [Linkerd](https:\/\/linkerd.io\/)。所有服务网格的工作方式基本相同，我们不会在这篇博文中深入探讨。一个显著的点是，为了将流量定向到其“旁路”代理并从其“旁路”代理，需要对底层 Linux 节点的 iptables 规则进行一些调整。这些调整或配置修改是服务网格重写网络堆栈路由规则的结果。为了做到这一点，像 Istio 和 Linkerd 这样的网格使用一个 [initContainer](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/pods\/init-containers\/) 在任何其他容器启动之前执行此操作。为了使该 initContainer 起作用，它需要一些权限，这往往在注重安全的集群中是困难的。至少，这些 initContainer 必须添加两个[Linux 权限](https:\/\/man7.org\/linux\/man-pages\/man7\/capabilities.7.html)，以允许它们对网络堆栈进行修改：\u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060。这些 initContainer 甚至可能以 root 用户身份运行，这在容器世界是绝对不允许的。\n\n例如，Linkerd 2.14 将在应该成为其网格的任何 Pod 中注入类似以下的 initContainer（为简洁起见，省略了一些字段）。\n\n\u0060\u0060\u0060yaml\ninitContainers:\n  - image: cr.l5d.io\/linkerd\/proxy-init:v2.2.3\n    name: linkerd-init\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        add:\n          - NET_ADMIN\n          - NET_RAW\n      privileged: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 65534\n      seccompProfile:\n        type: RuntimeDefault\n\u0060\u0060\u0060\n\n事实上，这些服务网格 initContainer 需要的额外权限被 Kubernetes 官方的 [Pod 安全标准](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/) 所禁止。这个事实本身并不是主要问题，而是根据使用的策略引擎，为这些特殊的 initContainer 提供许可是非常困难甚至根本不可能的。我们每周都在 [Kyverno 社区](https:\/\/kyverno.io\/community\/)听到用户的痛苦，似乎那些最严重受到影响的用户是那些使用 [Pod 安全准入](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-admission\/) 的人，这是实现 Pod 安全标准的进程中的准入控制器。这已经成为一个显著的问题，以至于 Istio 和 Linkerd [都尝试过](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/) 解决它（或者更准确地说，解决它的方法） ，通过提供另一种选择：一个自定义的 CNI 插件。\n\n## CNI 插件\n\n这些 CNI 插件适用于许多情况，但总的来说，它们大都是以牺牲一个问题来解决另一个问题。毕竟，iptables 规则仍然 **必须** 被重写，而网格中的某些东西仍然 **必须** 负责执行这个任务。在这两种情况下，CNI 插件实现了一个 DaemonSet，该 DaemonSet 运行一个特权容器，以在每个节点上执行这些修改，从而避免了在每个 Pod 中都需要一个 initContainer 的需求。这确实有它的优点，但也有缺点。\n\n- DaemonSet 更具特权，因为它需要 hostPath 卷，并将配置文件和二进制文件复制到每个节点。\n- 它需要了解 CNI 插件，这是专门的知识。\n- 增加了更多的操作和自动化复杂性。\n- 与其他 CNI 插件可能发生冲突，因为它们彼此不知道，并且确定如何链接多个插件不是标准化的。\n- 在水平集群缩放或节点重启期间可能会出现潜在的竞争条件，因为 DaemonSet Pod 可能在工作负载 Pod 之前启动。\n\n## 问题的关键\n\n但是为什么解决 initContainer 问题会是一个真正的问题呢？答案在于排除。排除，或者你如何免除某些资源不适用于策略，这是区分良好的准入控制器和优秀准入控制器的关键之一。目标是在尽可能不影响你确实需要的事物的同时，提供尽可能强大的 Pod 安全姿态。你希望能够将“好”与“坏”分开，而你的服务网格绝对属于“好”的范畴。但就像筛子筛沙子一样，你必须小心过滤掉“坏”的部分，使你只剩下“好”的部分。在上述 initContainer 示例中，你绝对不希望非服务网格 Pod 添加 \u0060NET_ADMIN\u0060 权限，因为那样会给予它们对网络堆栈的不受限制的访问，从而可能导致窥探和伪装等问题。减少漏斗大小的选项如下，从大到小排序。\n\n- 在整个集群中禁用 Pod 安全\n  - 这显然是一个不可行的方案，所以不需要进一步讨论。\n- 在受影响的 Namespace 中禁用 Pod 安全\n  - 因为我们谈论的是每个必须参与网格的 Pod 中都有一个 initContainer，这基本上意味着你必须在集群的大多数 Namespace 中禁用 Pod 安全，这实际上就像第一种选项一样——行不通。\n- 在包含此检查的配置文件中禁用此配置文件（如果适用）\n  - Pod 安全标准组织成称为配置文件的集合，每个配置文件包含多个控制。控制是关于*应该*检查哪些字段以及允许或不允许哪些值的命令。你可以找到包含此控制的配置文件，并禁用整个配置文件，但这显然会禁用同一配置文件中的其他控制。这也不是很好。并非所有策略准入控制器都提供此功能。\n- 在 Pod 上禁用此控制\n  - 请求 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 的这些 initContainer 违反了[Pod 安全标准的基线配置文件中的“Capabilities”控制](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#baseline)，这是 Pod 安全的基本配置文件（受限制配置文件建立在基线配置文件之上）。你可以简单地不在使用这种 initContainer 的任何 Pod 中检查此控制，但这也不好，因为那样一个恶意容器也可以添加 \u0060NET_ADMIN\u0060。你可能正在执行所有其他控制，但是简单地关闭一个控制还是太多。\n- 在一个镜像上禁用此控制\n  - 如果你已经达到了这个级别，那么你做得很好。你可以简单地不在与某种模式匹配的镜像上检查这些特权能力。但我们还可以做得更好。（顺便说一句，基于 initContainer 的名称这样做并不完全安全，因为一些恶意用户可能创建一个名为 \u0060istio-init\u0060 的 initContainer，该 initContainer 使用了一个名为 \u0060ubuntu:latest\u0060 的镜像。）\n- 在一个镜像上以及在 Pod 中的一个位置上禁用此控制\n  - 现在我们来谈谈。我们可以将一个豁免隔离到仅限于特定的镜像和 Pod 中的特定位置。例如，我们可以在 \u0060initContainers[]\u0060 数组中发现 \u0060istio\/proxyv2\u0060 镜像时，豁免 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 权限检查。如果同一镜像在主要的 \u0060containers[]\u0060 列表中使用，它将导致整个 Pod 被拒绝。\n\n许多人遇到此问题的原因之一是 Pod 安全准入（PSA）。使用 PSA，你可以实现的最精细的粒度是从顶部的第三个项目：禁用包含此检查的配置文件。由于受限制的配置文件包含基线配置文件，因此在 Namespace 上禁用基线配置文件本质上等同于不执行 Pod 安全检查。这个限制是创建 CNI 插件解决方案的主要原因。如果服务网格可以将对这些提升权限的需求分离到只有一个控制器（一个 DaemonSet）中，并且该控制器仅在一个 Namespace 中运行，那么我们基本上可以将该 Namespace 隔离为一个豁免区域。\n\n## Kyverno 中的策略\n\n在 Kyverno 中，您有几种选项来实施 Pod 安全标准。第一种和“原始”的方法是针对 Pod 安全标准中的每个控制编写一个 \u0060validate\u0060 规则。Kyverno 已经提供了完整的这些策略，打包为一个 [Helm 图表](https:\/\/github.com\/kyverno\/kyverno\/tree\/main\/charts\/kyverno-policies)，这些策略也可以作为 [单独的策略](https:\/\/kyverno.io\/policies\/?policytypes=Pod%20Security%20Standards%20(Baseline)%2BPod%20Security%20Standards%20(Restricted)) 使用。例如，基线配置文件中的“Capabilities”控制可以在[此处](https:\/\/kyverno.io\/policies\/pod-security\/baseline\/disallow-capabilities\/disallow-capabilities\/)找到。在这种策略样式中，您可以尽可能地细化。稍微的缺点是，当涉及到预构建的 Pod 安全标准时，它们需要在这些服务网格 initContainers 上进行一些修改。虽然其中一些修改相当温和，但其他可能需要更极端的修改。\n\n例如，以下是为了允许这些服务网格 initContainers 而进行的相同“Capabilities”检查可能的样子。\n\n\u003e 由于 Kyverno 在策略编写方面非常灵活，几乎总会有多种编写相同声明的方式，所以如果您已经这样做了而结果有所不同，请不用担心。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: disallow-capabilities\nspec:\n  validationFailureAction: Enforce\n  background: true\n  rules:\n    - name: adding-capabilities-service-mesh\n      match:\n        any:\n        - resources:\n            kinds:\n              - Pod\n      preconditions:\n        all:\n        - key: \u0022{{ request.operation || \u0027BACKGROUND\u0027 }}\u0022\n          operator: NotEquals\n          value: DELETE\n      validate:\n        message: \u003e-\n          Any capabilities added beyond the allowed list (AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER,\n          FSETID, KILL, MKNOD, NET_BIND_SERVICE, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT)\n          are disallowed. Service mesh initContainers may only add NET_ADMIN and NET_RAW to this list.     \n        foreach:\n          - list: request.object.spec.initContainers[]\n            preconditions:\n              all:\n              - key: \u0022{{ element.image }}\u0022\n                operator: AnyIn\n                value:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                operator: AnyNotIn\n                value: [\u0022NET_ADMIN\u0022,\u0022NET_RAW\u0022,\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n          - list: request.object.spec.[ephemeralContainers, containers][]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n\u0060\u0060\u0060\n\n请随时在 [Kyverno Playground](https:\/\/playground.kyverno.io\/#\/) 中试用一下，看看效果。里面包含了 Istio 和 Linkerd 的示例 Pod，所以尝试取消注释并复制元素来测试一下。\n\n由于 Istio 的 initContainer 需要比 Linkerd 的更多权限，因此还需要对一些其他策略进行一些轻微的修改，这些修改可以在[受限配置文件](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#restricted) 中找到。例如，以下是一个 [Kyverno Playground 链接](https:\/\/playground.kyverno.io\/#\/)，展示了如何修改 [require-run-as-nonroot 策略](https:\/\/kyverno.io\/policies\/pod-security\/restricted\/require-run-as-nonroot\/require-run-as-nonroot\/) 来豁免 \u0060istio-init\u0060。\n\n像上面展示的个别 Kyverno 策略允许最大的灵活性，但在 Kyverno 中实现 Pod 安全标准还有一种更简单的方式。实施这些标准的第二种方式是使用我们称之为“子规则”的方式来实现 \u0060validate\u0060 样式策略。[在这种样式](https:\/\/kyverno.io\/docs\/writing-policies\/validate\/#pod-security) 中，\u0060podSecurity\u0060 元素用于特指这些 Pod 安全标准。在幕后，Kyverno 使用与 Kubernetes 的 Pod 安全 Admission 完全相同的库，但使用不同的“包装器”使其应用更加灵活。\n\n例如，使用这种类型的子规则将允许您轻松实施 Pod 安全标准的整个基线配置文件，并在其中排除这些服务网格图像，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n  - name: baseline-service-mesh\n    match:\n      any:\n      - resources:\n          kinds:\n          - Pod\n    validate:\n      podSecurity:\n        level: baseline  ## 强制执行基线配置文件\n        version: latest  ## 强制执行此配置文件的最新版本\n        exclude:         ##\n\n 排除特定控制，可选特定图像\n        - controlName: Capabilities\n          images:\n          - \u0022*\/istio\/proxyv2*\u0022\n          - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这里的 \u0060exclude[]\u0060 块命名了我们到目前为止一直在讨论的“Capabilities”控制，\u0060images[]\u0060 字段命名了应该被排除的两个特定的服务网格图像。通过这种能力，您可以获得类似 PSA 的行为，但是具有简单不可能实现的细粒度。\n\n这两个选项为您提供了丰富的选择，但它们都涉及直接修改策略。还有另一种选择，允许将异常与策略本身分离，这就是 [策略异常](https:\/\/kyverno.io\/docs\/writing-policies\/exceptions\/)。例如，您可以编写一个策略异常资源，豁免给定 Pod 在特定策略中的特定规则。这对于开发人员自助服务特别有用，因为它允许其他用户请求异常，而无需查看 Kyverno 策略。但是，在 1.11 中，这在某些情况下还不够细粒度，因此在 Kyverno 1.12 中进行了一些很好的升级。接下来将更多介绍。\n\n## 1.12 中的增强功能\n\n在即将推出的 Kyverno 1.12 中，我们正在进行一些令人兴奋的增强，这些增强将使针对诸如服务网格容器等用例的排除变得更加容易。\n\n1.12 中的第一个增强功能是通过列出特定字段及其值来进一步分类 podSecurity 子规则的排除。这使您既可以使用简单的策略语言，又可以达到最低级别的细粒度。例如，这是您将能够强制执行 Pod 安全标准的整个基线配置文件，但仅从特定的 initContainers 列表中排除 Istio 和 Linkerd 图像的方法。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n    - name: baseline-service-mesh\n      match:\n        any:\n          - resources:\n              kinds:\n                - Pod\n      validate:\n        podSecurity:\n          level: baseline\n          version: latest\n          exclude:\n            - controlName: Capabilities\n              images:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              restrictedField: spec.initContainers[*].securityContext.capabilities.add\n              values:\n                - NET_ADMIN\n                - NET_RAW\n\u0060\u0060\u0060\n\n第二个增强功能是对策略异常的增强，使其具有 podSecurity 意识性，即您将能够在 PolicyException 资源中豁免策略异常的特定控制名称。例如，以下是您将能够在 Kyverno 1.12 中为先前的 \u0060validate.podSecurity\u0060 子规则创建的 PolicyException，使您可以将这些排除与只在 \u0060staging\u0060 命名空间中创建的 Pod 分离开来。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v2beta1\nkind: PolicyException\nmetadata:\n  name: pod-security-exception\n  namespace: kyverno\nspec:\n  exceptions:\n  - policyName: pod-security-standards\n    ruleNames:\n    - baseline-service-mesh\n  match:\n    any:\n    - resources:\n        namespaces:\n        - staging\n  podSecurity:\n    - controlName: Capabilities\n      images:\n        - \u0022*\/istio\/proxyv2*\u0022\n        - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这将在未来进一步增强，适用于特定容器。查看并关注 [此处的问题](https:\/\/github.com\/kyverno\/kyverno\/issues\/8570) 获取详情。\n\n## 结语\n\n本文介绍了一些有关服务网格的内容，以及为什么使用 initContainers 以及它们带来的安全问题。我们介绍了 Kyverno 如何以最精细的方式解决这些问题，同时提供了下一个版本的一瞥，以及如何使此过程更加简单。如果您有任何其他问题或反馈，请与 Kyverno 项目 [联系](https:\/\/kyverno.io\/community\/#get-in-touch)！\n', '\/trans\/automate-istio-ca-rotation-in-production-at-scale\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">利用 Kyverno 为服务网格提供更好的 Pod 安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/securing-services-meshes-easier-with-kyverno/">[译] 使用 Kyverno 更轻松地保护服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kyverno.io/blog/2024/02/04/securing-services-meshes-easier-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Kyverno 更轻松地保护服务网格', '利用 Kyverno 为服务网格提供更好的 Pod 安全性。', '\n如今在 Kubernetes 中，服务网格已经变得司空见惯，有些平台甚至默认将其构建到集群中。服务网格无疑在多种方面提供了诸多好处，这些好处众所周知，但也众所周知，它们显著增加了集群的复杂性。除了增加了复杂性之外，服务网格在强制执行 Pod 安全性方面也带来了（臭名昭著的）问题，因为它们需要提升的权限可能对其他准入控制器造成难以处理的困扰，例如 Kubernetes 自身的 Pod 安全准入控制器。在本文中，我们将更详细地解释这个问题以及在使用服务网格时 Kyverno 如何成为真正的救星，同时为你预览一下即将到来的 Kyverno 1.12 版本中的一些东西，这将使安全服务网格变得轻而易举！\n\n## 介绍\n\n服务网格[为 Kubernetes 应用程序提供了许多好处](https:\/\/konghq.com\/learning-center\/service-mesh\/what-is-a-service-mesh)，包括更好的负载均衡、双向 TLS、可观测性等。很可能你现在就在你的某个集群中使用了服务网格。最流行的开源服务网格包括 [Istio](https:\/\/istio.io\/) 和 [Linkerd](https:\/\/linkerd.io\/)。所有服务网格的工作方式基本相同，我们不会在这篇博文中深入探讨。一个显著的点是，为了将流量定向到其“旁路”代理并从其“旁路”代理，需要对底层 Linux 节点的 iptables 规则进行一些调整。这些调整或配置修改是服务网格重写网络堆栈路由规则的结果。为了做到这一点，像 Istio 和 Linkerd 这样的网格使用一个 [initContainer](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/pods\/init-containers\/) 在任何其他容器启动之前执行此操作。为了使该 initContainer 起作用，它需要一些权限，这往往在注重安全的集群中是困难的。至少，这些 initContainer 必须添加两个[Linux 权限](https:\/\/man7.org\/linux\/man-pages\/man7\/capabilities.7.html)，以允许它们对网络堆栈进行修改：\u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060。这些 initContainer 甚至可能以 root 用户身份运行，这在容器世界是绝对不允许的。\n\n例如，Linkerd 2.14 将在应该成为其网格的任何 Pod 中注入类似以下的 initContainer（为简洁起见，省略了一些字段）。\n\n\u0060\u0060\u0060yaml\ninitContainers:\n  - image: cr.l5d.io\/linkerd\/proxy-init:v2.2.3\n    name: linkerd-init\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        add:\n          - NET_ADMIN\n          - NET_RAW\n      privileged: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 65534\n      seccompProfile:\n        type: RuntimeDefault\n\u0060\u0060\u0060\n\n事实上，这些服务网格 initContainer 需要的额外权限被 Kubernetes 官方的 [Pod 安全标准](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/) 所禁止。这个事实本身并不是主要问题，而是根据使用的策略引擎，为这些特殊的 initContainer 提供许可是非常困难甚至根本不可能的。我们每周都在 [Kyverno 社区](https:\/\/kyverno.io\/community\/)听到用户的痛苦，似乎那些最严重受到影响的用户是那些使用 [Pod 安全准入](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-admission\/) 的人，这是实现 Pod 安全标准的进程中的准入控制器。这已经成为一个显著的问题，以至于 Istio 和 Linkerd [都尝试过](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/) 解决它（或者更准确地说，解决它的方法） ，通过提供另一种选择：一个自定义的 CNI 插件。\n\n## CNI 插件\n\n这些 CNI 插件适用于许多情况，但总的来说，它们大都是以牺牲一个问题来解决另一个问题。毕竟，iptables 规则仍然 **必须** 被重写，而网格中的某些东西仍然 **必须** 负责执行这个任务。在这两种情况下，CNI 插件实现了一个 DaemonSet，该 DaemonSet 运行一个特权容器，以在每个节点上执行这些修改，从而避免了在每个 Pod 中都需要一个 initContainer 的需求。这确实有它的优点，但也有缺点。\n\n- DaemonSet 更具特权，因为它需要 hostPath 卷，并将配置文件和二进制文件复制到每个节点。\n- 它需要了解 CNI 插件，这是专门的知识。\n- 增加了更多的操作和自动化复杂性。\n- 与其他 CNI 插件可能发生冲突，因为它们彼此不知道，并且确定如何链接多个插件不是标准化的。\n- 在水平集群缩放或节点重启期间可能会出现潜在的竞争条件，因为 DaemonSet Pod 可能在工作负载 Pod 之前启动。\n\n## 问题的关键\n\n但是为什么解决 initContainer 问题会是一个真正的问题呢？答案在于排除。排除，或者你如何免除某些资源不适用于策略，这是区分良好的准入控制器和优秀准入控制器的关键之一。目标是在尽可能不影响你确实需要的事物的同时，提供尽可能强大的 Pod 安全姿态。你希望能够将“好”与“坏”分开，而你的服务网格绝对属于“好”的范畴。但就像筛子筛沙子一样，你必须小心过滤掉“坏”的部分，使你只剩下“好”的部分。在上述 initContainer 示例中，你绝对不希望非服务网格 Pod 添加 \u0060NET_ADMIN\u0060 权限，因为那样会给予它们对网络堆栈的不受限制的访问，从而可能导致窥探和伪装等问题。减少漏斗大小的选项如下，从大到小排序。\n\n- 在整个集群中禁用 Pod 安全\n  - 这显然是一个不可行的方案，所以不需要进一步讨论。\n- 在受影响的 Namespace 中禁用 Pod 安全\n  - 因为我们谈论的是每个必须参与网格的 Pod 中都有一个 initContainer，这基本上意味着你必须在集群的大多数 Namespace 中禁用 Pod 安全，这实际上就像第一种选项一样——行不通。\n- 在包含此检查的配置文件中禁用此配置文件（如果适用）\n  - Pod 安全标准组织成称为配置文件的集合，每个配置文件包含多个控制。控制是关于*应该*检查哪些字段以及允许或不允许哪些值的命令。你可以找到包含此控制的配置文件，并禁用整个配置文件，但这显然会禁用同一配置文件中的其他控制。这也不是很好。并非所有策略准入控制器都提供此功能。\n- 在 Pod 上禁用此控制\n  - 请求 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 的这些 initContainer 违反了[Pod 安全标准的基线配置文件中的“Capabilities”控制](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#baseline)，这是 Pod 安全的基本配置文件（受限制配置文件建立在基线配置文件之上）。你可以简单地不在使用这种 initContainer 的任何 Pod 中检查此控制，但这也不好，因为那样一个恶意容器也可以添加 \u0060NET_ADMIN\u0060。你可能正在执行所有其他控制，但是简单地关闭一个控制还是太多。\n- 在一个镜像上禁用此控制\n  - 如果你已经达到了这个级别，那么你做得很好。你可以简单地不在与某种模式匹配的镜像上检查这些特权能力。但我们还可以做得更好。（顺便说一句，基于 initContainer 的名称这样做并不完全安全，因为一些恶意用户可能创建一个名为 \u0060istio-init\u0060 的 initContainer，该 initContainer 使用了一个名为 \u0060ubuntu:latest\u0060 的镜像。）\n- 在一个镜像上以及在 Pod 中的一个位置上禁用此控制\n  - 现在我们来谈谈。我们可以将一个豁免隔离到仅限于特定的镜像和 Pod 中的特定位置。例如，我们可以在 \u0060initContainers[]\u0060 数组中发现 \u0060istio\/proxyv2\u0060 镜像时，豁免 \u0060NET_ADMIN\u0060 和 \u0060NET_RAW\u0060 权限检查。如果同一镜像在主要的 \u0060containers[]\u0060 列表中使用，它将导致整个 Pod 被拒绝。\n\n许多人遇到此问题的原因之一是 Pod 安全准入（PSA）。使用 PSA，你可以实现的最精细的粒度是从顶部的第三个项目：禁用包含此检查的配置文件。由于受限制的配置文件包含基线配置文件，因此在 Namespace 上禁用基线配置文件本质上等同于不执行 Pod 安全检查。这个限制是创建 CNI 插件解决方案的主要原因。如果服务网格可以将对这些提升权限的需求分离到只有一个控制器（一个 DaemonSet）中，并且该控制器仅在一个 Namespace 中运行，那么我们基本上可以将该 Namespace 隔离为一个豁免区域。\n\n## Kyverno 中的策略\n\n在 Kyverno 中，您有几种选项来实施 Pod 安全标准。第一种和“原始”的方法是针对 Pod 安全标准中的每个控制编写一个 \u0060validate\u0060 规则。Kyverno 已经提供了完整的这些策略，打包为一个 [Helm 图表](https:\/\/github.com\/kyverno\/kyverno\/tree\/main\/charts\/kyverno-policies)，这些策略也可以作为 [单独的策略](https:\/\/kyverno.io\/policies\/?policytypes=Pod%20Security%20Standards%20(Baseline)%2BPod%20Security%20Standards%20(Restricted)) 使用。例如，基线配置文件中的“Capabilities”控制可以在[此处](https:\/\/kyverno.io\/policies\/pod-security\/baseline\/disallow-capabilities\/disallow-capabilities\/)找到。在这种策略样式中，您可以尽可能地细化。稍微的缺点是，当涉及到预构建的 Pod 安全标准时，它们需要在这些服务网格 initContainers 上进行一些修改。虽然其中一些修改相当温和，但其他可能需要更极端的修改。\n\n例如，以下是为了允许这些服务网格 initContainers 而进行的相同“Capabilities”检查可能的样子。\n\n\u003e 由于 Kyverno 在策略编写方面非常灵活，几乎总会有多种编写相同声明的方式，所以如果您已经这样做了而结果有所不同，请不用担心。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: disallow-capabilities\nspec:\n  validationFailureAction: Enforce\n  background: true\n  rules:\n    - name: adding-capabilities-service-mesh\n      match:\n        any:\n        - resources:\n            kinds:\n              - Pod\n      preconditions:\n        all:\n        - key: \u0022{{ request.operation || \u0027BACKGROUND\u0027 }}\u0022\n          operator: NotEquals\n          value: DELETE\n      validate:\n        message: \u003e-\n          Any capabilities added beyond the allowed list (AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER,\n          FSETID, KILL, MKNOD, NET_BIND_SERVICE, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT)\n          are disallowed. Service mesh initContainers may only add NET_ADMIN and NET_RAW to this list.     \n        foreach:\n          - list: request.object.spec.initContainers[]\n            preconditions:\n              all:\n              - key: \u0022{{ element.image }}\u0022\n                operator: AnyIn\n                value:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                operator: AnyNotIn\n                value: [\u0022NET_ADMIN\u0022,\u0022NET_RAW\u0022,\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n          - list: request.object.spec.[ephemeralContainers, containers][]\n            deny:\n              conditions:\n                all:\n                - key: \u0022{{ element.securityContext.capabilities.add[] || \u0060[]\u0060 }}\u0022\n                  operator: AnyNotIn\n                  value: [\u0022AUDIT_WRITE\u0022,\u0022CHOWN\u0022,\u0022DAC_OVERRIDE\u0022,\u0022FOWNER\u0022,\u0022FSETID\u0022,\u0022KILL\u0022,\u0022MKNOD\u0022,\u0022NET_BIND_SERVICE\u0022,\u0022SETFCAP\u0022,\u0022SETGID\u0022,\u0022SETPCAP\u0022,\u0022SETUID\u0022,\u0022SYS_CHROOT\u0022,\u0022\u0022]\n\u0060\u0060\u0060\n\n请随时在 [Kyverno Playground](https:\/\/playground.kyverno.io\/#\/) 中试用一下，看看效果。里面包含了 Istio 和 Linkerd 的示例 Pod，所以尝试取消注释并复制元素来测试一下。\n\n由于 Istio 的 initContainer 需要比 Linkerd 的更多权限，因此还需要对一些其他策略进行一些轻微的修改，这些修改可以在[受限配置文件](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/#restricted) 中找到。例如，以下是一个 [Kyverno Playground 链接](https:\/\/playground.kyverno.io\/#\/)，展示了如何修改 [require-run-as-nonroot 策略](https:\/\/kyverno.io\/policies\/pod-security\/restricted\/require-run-as-nonroot\/require-run-as-nonroot\/) 来豁免 \u0060istio-init\u0060。\n\n像上面展示的个别 Kyverno 策略允许最大的灵活性，但在 Kyverno 中实现 Pod 安全标准还有一种更简单的方式。实施这些标准的第二种方式是使用我们称之为“子规则”的方式来实现 \u0060validate\u0060 样式策略。[在这种样式](https:\/\/kyverno.io\/docs\/writing-policies\/validate\/#pod-security) 中，\u0060podSecurity\u0060 元素用于特指这些 Pod 安全标准。在幕后，Kyverno 使用与 Kubernetes 的 Pod 安全 Admission 完全相同的库，但使用不同的“包装器”使其应用更加灵活。\n\n例如，使用这种类型的子规则将允许您轻松实施 Pod 安全标准的整个基线配置文件，并在其中排除这些服务网格图像，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n  - name: baseline-service-mesh\n    match:\n      any:\n      - resources:\n          kinds:\n          - Pod\n    validate:\n      podSecurity:\n        level: baseline  ## 强制执行基线配置文件\n        version: latest  ## 强制执行此配置文件的最新版本\n        exclude:         ##\n\n 排除特定控制，可选特定图像\n        - controlName: Capabilities\n          images:\n          - \u0022*\/istio\/proxyv2*\u0022\n          - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这里的 \u0060exclude[]\u0060 块命名了我们到目前为止一直在讨论的“Capabilities”控制，\u0060images[]\u0060 字段命名了应该被排除的两个特定的服务网格图像。通过这种能力，您可以获得类似 PSA 的行为，但是具有简单不可能实现的细粒度。\n\n这两个选项为您提供了丰富的选择，但它们都涉及直接修改策略。还有另一种选择，允许将异常与策略本身分离，这就是 [策略异常](https:\/\/kyverno.io\/docs\/writing-policies\/exceptions\/)。例如，您可以编写一个策略异常资源，豁免给定 Pod 在特定策略中的特定规则。这对于开发人员自助服务特别有用，因为它允许其他用户请求异常，而无需查看 Kyverno 策略。但是，在 1.11 中，这在某些情况下还不够细粒度，因此在 Kyverno 1.12 中进行了一些很好的升级。接下来将更多介绍。\n\n## 1.12 中的增强功能\n\n在即将推出的 Kyverno 1.12 中，我们正在进行一些令人兴奋的增强，这些增强将使针对诸如服务网格容器等用例的排除变得更加容易。\n\n1.12 中的第一个增强功能是通过列出特定字段及其值来进一步分类 podSecurity 子规则的排除。这使您既可以使用简单的策略语言，又可以达到最低级别的细粒度。例如，这是您将能够强制执行 Pod 安全标准的整个基线配置文件，但仅从特定的 initContainers 列表中排除 Istio 和 Linkerd 图像的方法。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v1\nkind: ClusterPolicy\nmetadata:\n  name: pod-security-standards\nspec:\n  background: true\n  validationFailureAction: Enforce\n  rules:\n    - name: baseline-service-mesh\n      match:\n        any:\n          - resources:\n              kinds:\n                - Pod\n      validate:\n        podSecurity:\n          level: baseline\n          version: latest\n          exclude:\n            - controlName: Capabilities\n              images:\n                - \u0022*\/istio\/proxyv2*\u0022\n                - \u0022*\/linkerd\/proxy-init*\u0022\n              restrictedField: spec.initContainers[*].securityContext.capabilities.add\n              values:\n                - NET_ADMIN\n                - NET_RAW\n\u0060\u0060\u0060\n\n第二个增强功能是对策略异常的增强，使其具有 podSecurity 意识性，即您将能够在 PolicyException 资源中豁免策略异常的特定控制名称。例如，以下是您将能够在 Kyverno 1.12 中为先前的 \u0060validate.podSecurity\u0060 子规则创建的 PolicyException，使您可以将这些排除与只在 \u0060staging\u0060 命名空间中创建的 Pod 分离开来。\n\n\u0060\u0060\u0060yaml\n### 即将推出的 Kyverno 1.12 ###\napiVersion: kyverno.io\/v2beta1\nkind: PolicyException\nmetadata:\n  name: pod-security-exception\n  namespace: kyverno\nspec:\n  exceptions:\n  - policyName: pod-security-standards\n    ruleNames:\n    - baseline-service-mesh\n  match:\n    any:\n    - resources:\n        namespaces:\n        - staging\n  podSecurity:\n    - controlName: Capabilities\n      images:\n        - \u0022*\/istio\/proxyv2*\u0022\n        - \u0022*\/linkerd\/proxy-init*\u0022\n\u0060\u0060\u0060\n\n这将在未来进一步增强，适用于特定容器。查看并关注 [此处的问题](https:\/\/github.com\/kyverno\/kyverno\/issues\/8570) 获取详情。\n\n## 结语\n\n本文介绍了一些有关服务网格的内容，以及为什么使用 initContainers 以及它们带来的安全问题。我们介绍了 Kyverno 如何以最精细的方式解决这些问题，同时提供了下一个版本的一瞥，以及如何使此过程更加简单。如果您有任何其他问题或反馈，请与 Kyverno 项目 [联系](https:\/\/kyverno.io\/community\/#get-in-touch)！\n', '\/trans\/securing-services-meshes-easier-with-kyverno\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">利用 Kyverno 为服务网格提供更好的 Pod 安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ica-certificate/">ICA 认证：Istio 技能认证的最新变化和考试准备指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('ICA 认证：Istio 技能认证的最新变化和考试准备指南', '本文介绍了 ICA 认证的起源和最近的变化，以及考试准备指南。ICA 考试是由 Tetrate 贡献的 CIAT 考试演变而来，为 Istio 技能认证提供了全面的考核。读者将了解考试的背景、考试过程、建议以及参考资料，有助于准备和通过考试。ICA 考试对 Istio 文档的熟悉度至关重要，建议先完成 Tetrate 的 Istio 基础教程。参加考试前应熟悉 PSI 系统和考试环境，保持冷静和专注，以确保顺利通过考试。', '\n## ICA 认证的变化和提醒\n\n即将发生的政策变更：请注意，ICA 认证期限政策将于 2024 年 4 月 1 日 00:00UTC 发生变更。在此日期或之后获得的认证将于满足计划认证要求（包括通过考试）之日起 24 个月后到期。我们鼓励任何有兴趣并准备好的人在政策变更之前安排并参加考试。请在此处查看更多详细信息。\n\n当前的认证有效期是 3 年，4 月 1 日之后通过的认证有效期是 2 年。\n\n## Tetrate Academy 背景\n\nTetrate 运营的 [Tetrate Academy](https:\/\/academy.tetrate.io\/) 已经有好几年时间，期间推出了 Istio 基础教程、Envoy 基础教程和 CIAT 认证考试，一共有 13000 多人学习了 Tetrate Academy 的课程。去年 9 月 Tetrate 将 CIAT 贡献给了 CNCF，改名为 [ICA 考试](https:\/\/training.linuxfoundation.org\/certification\/istio-certified-associate-ica\/)，至 11 月该认证考试正式上线。\n\n{{\u003cfigure src=\u0022domains.jpg\u0022 caption=\u0022ICA 的考试内容（来自 [Linux Foundation](https:\/\/training.linuxfoundation.org\/certification\/istio-certified-associate-ica\/)）\u0022 alt=\u0022ICA 的考试内容\u0022\u003e}}\n\n## 考试背景\n\n- ICA 是由 Tetrate 贡献的 CIAT 考试而来，提供了对 Istio 的广泛知识和技能的验证。\n- 考试采用线上远程监考方式进行，时间限制为 2 小时，考生需要在虚拟机环境中操作 Kubernetes 集群和 Istio。\n- 考试过程中需要解决一系列问题还有一些多选题，需要达到 75% 的分数才能通过。\n- PSI 系统提供在线考试环境，考试结果将在考试结束后 24 小时内通过邮件发送给考生。\n- 考试环境中提供了 Kubernetes 集群、Istio 安装、VS Code、kubectl、istioctl 等工具。\n- 考试过程中可以访问 Istio 文档，试题和作答仅支持英语。\n\n## 建议与提醒\n\n- 考试前务必熟悉 [Istio 文档](https:\/\/istio.io)，并提前做好准备，包括检查 PSI 系统、身份证明和考试环境。\n- 参加 Tetrate 的免费 [Istio 基础教程](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals)，加深对 Istio 的理解。\n- 在考试中保持冷静，先解答熟悉的问题，再解答不熟悉的问题，确保高效完成考试。\n\n## 参考链接\n\n- [ICA 认证常见问题解答](https:\/\/docs.linuxfoundation.org\/tc-docs\/certification\/frequently-asked-questions-ica)\n- [ICA 认证重要说明](https:\/\/docs.linuxfoundation.org\/tc-docs\/certification\/important-instructions-ica)\n', '\/blog\/ica-certificate\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 ICA 认证的起源和最近的变化，以及考试准备指南。ICA 考试是由 Tetrate 贡献的 CIAT 考试演变而来，为 Istio 技能认证提供了全面的考核。读者将了解考试的背景、考试过程、建议以及参考资料，有助于准备和通过考试。ICA 考试对 Istio 文档的熟悉度至关重要，建议先完成 Tetrate 的 Istio 基础教程。参加考试前应熟悉 PSI 系统和考试环境，保持冷静和专注，以确保顺利通过考试。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/header-based-routing-in-istio-without-header-propagation/">[译] Istio 中基于标头的路由——无需标头传播</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/header-based-routing-in-istio-without-header-propagation/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中基于标头的路由——无需标头传播', '本文介绍了如何在 Istio 中使用头部信息进行路由，而无需修改应用程序内部。通过使用 Istio 的路由功能和头部匹配，可以实现基于头部信息的请求路由，同时展示了如何使用 delegate 功能和 sourceLabels 特性。', '\nIstio 使用 Envoy 代理作为 Pod sidecar，应用程序将网络责任（例如入站和出站流量）委托给它，但有一个责任仍然属于应用程序容器：标头传播。\n\nEnvoy 代理无法将其发送到应用程序的请求与应用程序响应的请求关联起来，因此 Istio 无法自动传播标头。\n\n![图 1：如果应用程序容器不转发回标头，Sidecar 无法将请求与响应关联起来。](f1.webp)\n\n在大多数情况下，基于标头的路由需要应用程序开发人员实现标头转发。例如，在 Istio 的 Bookinfo 应用程序中， \u0060productpage\u0060 微服务是[这样](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/src\/productpage\/productpage.py#L102)实现的。这让我们想到一个问题：\n\n\u003e 平台管理员如何在不修改应用程序内部的情况下使用基于标头的路由？\n\n## 泳道方法\n\n使用 Bookinfo 应用程序，我们将根据 \u0060x-version\u0060 标头对请求路径进行分段，如下图 2 所示：\n\n![图 2：根据 x-version 标头分段请求路径。](f2.webp)\n\n没有 \u0060x-version\u0060 标头的请求可能会被路由到任意后端。\n\n## 部署工作负载\n\n我们将使用 Istio 的 Bookinfo [示例](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) ，并对版本控制应用程序进行一些细微的更改作为示例实现。\n\n首先，我们创建三个 productpage 部署，仅更改 \u0060version\u0060 标签。\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: productpage-v{1,2,3}\n  labels:\n    app: productpage\n    version: v{1,2,3}\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: productpage\n      version: v{1,2,3}\n  template:\n    metadata:\n      labels:\n        app: productpage\n        version: v{1,2,3}\n...\n\u0060\u0060\u0060\n\n为它们创建服务：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: productpage\n  labels:\n    app: productpage\n    service: productpage\nspec:\n  ports:\n  - port: 9080\n    name: http\n  selector:\n    app: productpage\n\u0060\u0060\u0060\n\n然后，为 reviews 应用程序创建三个部署：\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: reviews-v{1,2,3}\n  labels:\n    app: reviews\n    version: v{1,2,3}\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: reviews\n      version: v{1,2,3}\n  template:\n    metadata:\n      labels:\n        app: reviews\n        version: v{1,2,3}\n...\n\u0060\u0060\u0060\n\nrating 和 details 应用程序与原始示例中的内容相同。\n\n## 部署 Istio 配置\n\n这就是 Istio 的路由功能发挥作用的地方。每个版本的 \u0060productpage\u0060 的 \u0060DestinationRule subsets\u0060 定义为：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: productpage\nspec:\n  host: productpage\n  trafficPolicy:\n    loadBalancer:\n      simple: RANDOM\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n  - name: v3\n    labels:\n      version: v3\n\u0060\u0060\u0060\n\n其中有几个 \u0060VirtualService\u0060 实现了泳道标头逻辑的前半部分。以下负责前缀匹配并使用 \u0060delegate\u0060 功能来使用第二个 \u0060VirtualService\u0060，因此配置是原子的并且 \u0060mesh\u0060 避免声明网关选择器（参见下面的引用）：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: bookinfo\nspec:\n  hosts:\n  - \u0022*\u0022\n  gateways:\n  - bookinfo-gateway\n  http:\n  - match:\n    - uri:\n        exact: \/productpage\n    - uri:\n        prefix: \/static\n    - uri:\n        exact: \/login\n    - uri:\n        exact: \/logout\n    - uri:\n        prefix: \/api\/v1\/products\n    delegate:\n      name: productpage-route\n\u0060\u0060\u0060\n\n现在指派 \u0060productpage-route\u0060：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: productpage-route\nspec:\n  http:\n  - name: \u0022productpage-v1-route\u0022\n    match:\n    - headers:\n        x-version:\n          exact: v1\n    route:\n    - destination:\n        host: productpage\n        subset: v1\n  - name: \u0022productpage-v2-route\u0022\n    match:\n    - headers:\n        x-version:\n          exact: v2\n    route:\n    - destination:\n        host: productpage\n        subset: v2\n  - name: \u0022productpage-v3-route\u0022\n    match:\n    - headers:\n        x-version:\n          exact: v3\n    route:\n    - destination:\n        host: productpage\n        subset: v3\n  - name: \u0022productpage-default-route\u0022\n    match:\n    - withoutHeaders:\n        x-version: {}\n    route:\n    - destination:\n        host: productpage\n\u0060\u0060\u0060\n\n然后，在 \u0060Reviews\u0060 级别，在 \u0060httpMatchRequest\u0060 中使用 \u0060sourceLabels\u0060 配置制作泳道的后半部分：\n\n\u003e 一个或多个标签，这些标签约束规则对具有给定标签的源 (客户机) 工作负载的适用性。如果 VirtualService 有一个在顶级 \u0060gateways\u0060 字段中指定的网关列表，那么它必须包含该字段适用的保留网关 \u0060mesh\u0060。\n\u003e\n\u003e *来源：* [*Istio 虚拟服务文档*](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/virtual-service\/#HTTPMatchRequest)\n\n这是 \u0060VirtualService\u0060 使用该 \u0060sourceLabels\u0060 功能：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: reviews-route\nspec:\n  hosts:\n  - reviews\n  http:\n  - name: \u0022reviews-v1-route\u0022\n    match:\n    - sourceLabels:\n        version: v1\n    route:\n    - destination:\n        host: reviews\n        subset: v1\n  - name: \u0022reviews-v2-route\u0022\n    match:\n    - sourceLabels:\n        version: v2\n    route:\n    - destination:\n        host: reviews\n        subset: v2\n  - name: \u0022reviews-v3-route\u0022\n    match:\n    - sourceLabels:\n        version: v3\n    route:\n    - destination:\n        host: reviews\n        subset: v3\n\u0060\u0060\u0060\n\n## 在没有标头传播的情况下测试标头路由\n\n首先，从无标头场景开始，您可以从所有通道获得响应：\n\n\u0060\u0060\u0060\n —————»  ns:bookinfo ❯ for i in {1..5}; do curl -s localhost:8080\/productpage | grep -A1 \u0022Reviews served by\u0022; done\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v2-955b74755-t4jkb\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v2-955b74755-t4jkb\u003c\/u\u003e\n\u0060\u0060\u0060\n\n然后检查 \u0060x-version: v1\u0060 header 是否有作用。您可以看到工作负载发出的所有对 \u0060productpage-v1\u0060 的调用均由  \u0060reviews-v1\u0060 专门提供服务。\n\n\u0060\u0060\u0060\n —————»  ns:bookinfo ❯ for i in {1..10}; \\\ndo curl -s localhost:8080\/productpage -H \u0022x-version: v1\u0022 \\\n| grep -A1 \u0022Reviews served by\u0022; done\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v1-5cf854487-hjtrg\u003c\/u\u003e\n\u0060\u0060\u0060\n\n使用 \u0060v3\u0060 标头值完成测试：\n\n\u0060\u0060\u0060\n  —————»  ns:bookinfo ❯ for i in {1..10}; \\\ndo curl -s localhost:8080\/productpage -H \u0022x-version: v3\u0022 \\\n| grep -A1 \u0022Reviews served by\u0022; done\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n        \u003cdt\u003eReviews served by:\u003c\/dt\u003e\n        \u003cu\u003ereviews-v3-797fc48bc9-wsg26\u003c\/u\u003e\n\u0060\u0060\u0060\n\n## 结论\n\n在本文中，我们在标头上使用 \u0060match\u0060 ，在 Istio 中使用 \u0060subsets\u0060 和 \u0060sourceLabels\u0060 基于标头进行路由，而无需标头传播。您还可以查看 \u0060delegate\u0060 功能以及 \u0060withoutHeaders\u0060 匹配的使用情况。\n\n---\n\n如果您是服务网格新手，Tetrate[在 Tetrate Academy](https:\/\/tetr8.io\/academy)提供了一系列免费在线课程，可帮助您快速熟悉 Istio 和 Envoy。如果您正在寻找使用 Istio 进行生产的最可靠方法，请查看 [Tetrate Istio Subscription](https:\/\/tetr8.io\/tid)。Tetrate Istio 订阅拥有在高度监管和任务关键型生产环境中运行 Istio 和 Envoy 所需的一切。它包括 [Tetrate Istio Distro](https:\/\/istio.tetratelabs.io\/)，这是 Istio 和 Envoy 的 100% 上游发行版，经过 FIPS 验证并准备好 FedRAMP。对于需要开源 Istio 和 Envoy 而无需专有供应商依赖的团队，Tetrate 提供唯一 100% 上游 Istio 企业支持产品。\n', '\/trans\/header-based-routing-in-istio-without-header-propagation\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何在 Istio 中使用头部信息进行路由，而无需修改应用程序内部。通过使用 Istio 的路由功能和头部匹配，可以实现基于头部信息的请求路由，同时展示了如何使用 delegate 功能和 sourceLabels 特性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-configure-global-rate-limits-by-path-in-istio/">[译] 如何在 Istio 中按路径配置全局速率限制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/02/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-configure-global-rate-limits-by-path-in-istio/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中按路径配置全局速率限制', '这篇文章介绍了如何在 Istio 中根据请求路径配置全局限流。解释了 Envoy 限流过滤器和外部限流服务的工作原理，并通过例子展示了如何使用多个 rate limit action 来实现 OR 逻辑限流 certain paths。', '\n本文是为那些刚开始使用 Istio 速率限制功能，希望了解基于请求路径的速率限制如何工作的人而写的。它源于我的实践，并澄清了关于\u0060rate_limit\u0060操作中 AND\/OR 操作的困惑。我花了比预期更多的时间来弄清楚我将在这里为你总结的内容，以便你在几分钟内学习。\n\n## 基础知识\n\nIstio 在 Envoy 之上运行，而我们将讨论的主要技术是 Envoy。Envoy 有在代理本身上实现的本地速率限制和在 L4 或 L7 上调用外部服务的全局速率限制的选项。\n\n## 外部速率限制服务\n\n外部速率限制服务（RLS）与 Redis 数据库配合使用，通过 gRPC 与 envoy 实例连接。该 RLS 是由 [filter](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_filters\/rate_limit_filter#rate-limit) 在 HTTP 路由过滤器之前的侦听器链中添加而被调用的。\n\n这个外部过滤器将描述符组织成域组。每个描述符都是一个键值对，由速率限制过滤器填充，并传递给 RLS 供其在规则执行逻辑中使用。请参阅 https:\/\/github.com\/envoyproxy\/ratelimit#overview 进行实现。\n\nRLS 需要由集群操作员（你）安装和管理，并且不会随 Istio 一起提供，尽管可以在你安装时从 Istio 包的示例目录中找到它。\n\n## Envoy HTTP 速率限制过滤器\n\nEnvoy 的设置由应用于入口网关的两个 Envoy 配置组成，一个在侦听器组件中添加速率限制过滤器，另一个在动态路由组件中定义虚拟主机级别的操作。\n\n![Envoy HTTP 速率限制过滤器](f1.jpg)\n\n带有速率限制过滤器的侦听器组件 filter_chains.filters[] 在路由器之前。\n\n![虚拟主机“httpbin.com:80”的路由组件中的速率限制操作](f2.jpg)\n\n*注意：你可以通过以下方式从任何 envoy 代理（当然是网关）获取此转储：*\n\n\u0060\u0060\u0060\nk exec \u003cPOD\u003e -c istio-proxy -- curl \u0027localhost:15000\/config_dump\u0027 \u003e config_dump.json\n\u0060\u0060\u0060\n\n侦听器过滤器配置了如何到达 RLS、它正在监视的域以及一些其他设置。当满足路由中定义的操作时，此过滤器将访问在路由中定义的操作，并触发到 RLS 上游的 gRPC 调用，其中包括域、描述符键和值，以便它返回一个判断。\n\n## Istio 中按请求路径设置速率限制的示例\n\n你需要按照[此](https:\/\/istio.io\/latest\/docs\/tasks\/policy-enforcement\/rate-limit\/)开始。花点时间分析基于前文介绍的配置。供你参考，我使用的是你也可以在 Istio 包的示例目录中访问的 \u0060httpbin\u0060 服务。\n\n### 错误的方法\n\n所以，我希望根据两个路径 \u0060\/delay\u0060 和 \u0060\/status\u0060 进行速率限制。看起来很容易，所以我配置了我的 Envoy Filter 和 RLS 如下：\n\n\u0060\u0060\u0060yaml\n# EnvoyFilter 配置路由操作\n      patch:\n        operation: MERGE\n        value:\n          rate_limits:\n            - actions:\n              - header_value_match:\n                  descriptor_key: \u0022PATH\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*delay.*\u0022\n              - header_value_match:\n                  descriptor_key: \u0022PATH\u0022\n                  descriptor_value: \u0022no\n\n\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*status.*\u0022\n# RLS configmap\n...\ndata:\n  config.yaml: |\n    domain: tetrate-ratelimit\n    descriptors:\n      - key: PATH\n        value: \u0022yes\u0022\n        rate_limit:\n          unit: minute\n          requests_per_unit: 3\n      - key: PATH\n        value: \u0022no\u0022\n        rate_limit:\n          unit: minute\n          requests_per_unit: 1\n\u0060\u0060\u0060\n\n有了这个，我期望通过调用以下命令来使其工作：\n\n\u0060\u0060\u0060\ncurl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -o \/dev\/null\n\u0060\u0060\u0060\n\n但是 RLS 甚至没有注意到这个调用，所以速率限制没有发生：\n\n\u0060\u0060\u0060\n# k logs -n default -f ratelimit-57bf5688c-f8q5k\ntime=\u00222023-11-29T17:34:10Z\u0022 level=debug msg=\u0022[gostats] Flush() called, all stats would be flushed\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.mallocs: 460\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.frees: 26\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing counter ratelimit.go.totalAlloc: 15624\u0022\ntime=\u00222023-11-29T17:34:20Z\u0022 level=debug msg=\u0022[gostats] flushing gauge ratelimit.go.sys: 0\u0022\n\u0060\u0060\u0060\n\n*为了设置调试模式，你可以编辑 ratelimit-server 部署的容器参数。在那里，你将找到日志级别标志。*\n\n我尝试了所有种类的组合在 \u0060rate_limits.actions\u0060 设置中，使用 \u0060string_match\u0060 和 \u0060prefix_match\u0060 替代了 \u0060safe_regex_match\u0060，但没有成功。\n\n还尝试使用单个 \u0060descriptor_key\u0060，不同的值以及甚至不设置它并使用默认的 \u0060header_match\u0060。\n\n## 顿悟时刻\n\n我发现过滤器没有发送任何东西到 RLS，因为前者在任何请求上都保持沉默。然后，通过文档我读到：\n\n\u003e \u0022如果操作不能添加描述符条目，则不会为配置生成描述符\u0022，见[这里](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/route\/v3\/route_components.proto#config-route-v3-ratelimit)。\n\n然后，发起调用：\n\n\u0060\u0060\u0060\ncurl http:\/\/127.0.0.1:8080\/status\/delay -H\u0022host: httpbin.com\u0022 -v -o \/dev\/null\n\u0060\u0060\u0060\n\n结果如下：\n\n\u0060\u0060\u0060\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022got descriptor: (PATH=yes),(PATH=no)\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022starting get limit lookup\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022looking up key: PATH_yes\u0022\ntime=\u00222023-11-29T16:07:07Z\u0022 level=debug msg=\u0022found rate limit: PATH_yes\u0022\n\u0060\u0060\u0060\n\n所以，只有当我的路径满足 *两个* \u0060header_value_match\u0060 时，描述符才会传递给 RLS。我的当前配置正如一个 AND 运算符一样工作。\n\n然后，一切都归结为：*如何在 rate_limit 操作中设置 OR 逻辑而不是 AND？*\n\n## 解决方案\n\n原始配置略有变化，如下：\n\n\u0060\u0060\u0060\n# EnvoyFilter 配置路由操作   \n        value:\n          rate_limits:\n            - actions: # 任何操作在此处\n              - header_value_match:\n                  descriptor_key: \u0022PATH_DELAY\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*delay.*\u0022\n            - actions:\n              - header_value_match:\n                  descriptor_key: \u0022PATH_STATUS\u0022\n                  descriptor_value: \u0022yes\u0022\n                  headers:\n                    - name: \u0022:path\u0022\n                      safe_regex_match:\n                        google_re2: {}\n                        regex: \u0022.*status.*\u0022\n\u0060\u0060\u0060\n\n看起来像一个有效的配置，就像：\n\n\u0060\u0060\u0060\n❯ curl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -s -o \/dev\/null \n*   Trying 127.0.0.1:8080...\n* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)\n\u003e GET \/delay\/1 HTTP\/1.1\n\u003e Host: httpbin.com\n\u003e User-Agent: curl\/7.81.0\n\u003e Accept: *\/*\n\u003e \n* Mark bundle as not supporting multiuse\n\u003c HTTP\/1.1 200 OK\n\u003c server: istio-envoy\n\u003c date: Wed, 29 Nov 2023 20:17:02 GMT\n\u003c content-type: application\/json\n\u003c content-length: 703\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 1005\n\u003c \n{ [703 bytes data]\n* Connection #0 to host 127.0.0.1 left intact\n\n❯ curl http:\/\/127.0.0.1:8080\/delay\/1 -H\u0022host: httpbin.com\u0022 -v -s -o \/dev\/null \n*   Trying 127.0.0.1:8080...\n* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)\n\u003e GET \/delay\/1 HTTP\/1.1\n\u003e Host: httpbin.com\n\u003e User-Agent: curl\/7.81.0\n\u003e Accept: *\/*\n\u003e \n* Mark bundle as not supporting multiuse\n\u003c HTTP\/1.1 429 Too Many Requests \u003c---------- 参见\n\u003c x-envoy-ratelimited: true\n\u003c date: Wed, 29 Nov 2023 20:17:06 GMT\n\u003c server: istio-envoy\n\u003c content-length: 0\n\u003c \n* Connection #0 to host 127.0.0.1 left intact\n\u0060\u0060\u0060\n\n和 RLS 日志：\n\n\u0060\u0060\u0060\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022starting cache lookup\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022looking up cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580 current: 1\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022returning normal response\u0022\ntime=\u00222023-11-29T16:33:57Z\u0022 level=debug msg=\u0022[gostats] flushing time ratelimit_server.ShouldRateLimit.response_time: 0.000000\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022got descriptor: (PATH_DELAY=yes)\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022starting get limit lookup\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022looking up key: PATH_DELAY_yes\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022found rate limit: PATH_DELAY_yes\u0022\ntime=\u00222023-11-29T16:33:59Z\u0022 level=debug msg=\u0022applying limit: 1 requests per MINUTE, shadow_mode: false\u0022\n\u0060\u0060\u0060\n\n相信我，\u0060\/status\u0060 的限制也是存在的。\n\nAND\/OR逻辑用于速率限制 \u0060rate_limits\u0060 配置在其数组中支持多个位置，因此 AND\/OR 逻辑操作取决于动作是否嵌套到相同的 \u0060actions\u0060 子集中。\n\n------\n\n**注意**：可能有一种更安全、更有效的路径匹配方式，而不是像这个例子中那样打开正则表达式。它很简单，所以我们专注于主题。\n', '\/trans\/how-to-configure-global-rate-limits-by-path-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了如何在 Istio 中根据请求路径配置全局限流。解释了 Envoy 限流过滤器和外部限流服务的工作原理，并通过例子展示了如何使用多个 rate limit action 来实现 OR 逻辑限流 certain paths。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/3/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/5/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/page/12/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(84)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题开启！</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
