<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-service-and-traffic-model/">Istio 中的服务和流量的抽象模型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的服务和流量的抽象模型', '本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。', '\n本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。虽然 Istio 一开始确定的抽象模型与对接的底层平台无关，但目前来看基本绑定 Kubernetes，本文仅以 Kubernetes 说明。另外在 ServiceMesher 社区中最近有很多关于 Istio、Envoy、Kubernetes 之中的服务模型关系的讨论，本文作为一个开篇说明，Kubernetes 和 Isito 之间有哪些共有的服务模型，Istio 在 Kubernetes 的服务模型之上又增加了什么。\n\n**服务具有多个版本。** 在 CI\/CD 过程中，同一个服务可能同时部署在多个环境中，如开发、生产和测试环境等，这些服务版本不一定具有不同的 API，可能只是一些小的更改导致的迭代版本。在 A\/B 测试和灰度发布中经常遇到这种情况。\n\n## Kubernetes 与 Istio 中共有的模型\n\n因为 Istio 基本就是绑定在 Kubernetes 上，下面是我们熟知的 Kubernetes 及 Istio 中共有的服务模型。\n\nKubernetes 中 iptables 代理模式（另外还有 IPVS 模式）下的 service，管理员可以在 kube-proxy 中配置简单的负载均衡，对整个 node 生效，无法配置到单个服务的负载均衡和其他微服务的高级功能，例如熔断、限流、追踪等，这些功能只能在应用中实现了，而在 Istio 的概念模型中完全去掉了 \u0060kube-proxy\u0060  这个组件，将其分散到每个应用 Pod 中同时部署的 Envoy 中实现。\n\n下面列举的是 Kubernetes 和 Istio 中共有的模型。\n\n### Service\n\n这实际上跟 Kubernetes 中的 service 概念是一致的，请参考 [Kubernetes 中的 service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)。Istio 推出了比 service 更复杂的模型 \u0060VirtualService\u0060，这不单纯是定义一个服务了，而是在服务之上定义了路由规则。\n\n每个服务都有一个完全限定的域名（FQDN），监听一个或多个端口。服务还可以有与其相关联的单个负载均衡器或虚拟 IP 地址。针对 FQDN 的 DNS 查询将解析为该负载均衡器或者虚拟 IP 的地址。\n\n例如 Kubernetes 中一个服务为 \u0060foo.default.svc.cluster.local\u0060 ，虚拟 IP \/ClusterIP 是 10.0.1.1，监听的端口是 80 和 8080。\n\n### Endpoint\n\n这里指的是 Kubernetes 中的 endpoint，一个 endpoint 是实现了某服务的具体实例，一个服务可能有一个或者多个 Endpoint，表示为 IP 地址加端口，也可以为 DNS 名称加端口。\n\n其实到底哪些实例属于同一个 service，还是需要 通过 label 匹配来选择。\n\n### Label\n\n服务的版本、对应的引用名称等是通过 label 来标记的，例如下面 Kubernetes 中一个应用的 YAML 配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Deployment\nmetadata:\n  name: ratings-v1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: ratings\n        version: v1\n    spec:\n      containers:\n      - name: ratings\n        image: istio\/examples-bookinfo-ratings-v1:1.8.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n\u0060\u0060\u0060\n\n \u0060version: v1\u0060 标记该服务是 v1 版本，\u0060version\u0060 是一个约定俗称的标签，建议大家的服务上都带上该标签。\n\n当然服务的 label 可以设置任意多个，这样的好处是在做路由的时候可以根据标签匹配来做细粒度的流量划分。\n\n## 数据平面 Envoy\n\nEnvoy 是 Istio 中默认的 sidecar proxy，负责服务间的流量管控、认证与安全加密、可观测性等。\n\n下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch-20190114.png)\n\n我再给大家介绍 Envoy 中的如下几个重要概念。\n\n### Cluster\n\n集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n这个与 Kubernetes 中的 Service 概念类似，只不过 Kubernetes 中的服务发现中并不包含健康状况检查，而是通过[配置 Pod 的 liveness 和 readiness 探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)来实现，服务发现默认也是通过 DNS 来实现。\n\n### Listener\n\n监听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n### Listener filter\n\nListener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n## Istio 中增加的流量模型\n\n\u0060VirtualService\u0060、\u0060DestinationRule\u0060、\u0060Gateway\u0060、\u0060ServiceEntry\u0060 和 \u0060EnvoyFilter\u0060 都是 Istio 中为流量管理所创建的 CRD，这些概念其实是做路由配置和流量管理的，而 Kubernetes 中的 service 只是用来做服务发现。Service Mesh 中真正的服务模型应该是 Envoy 的 [xDS 协议](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/)，其中包括了服务的流量治理，服务的端点是通过 EDS 来配置的。\n\n![Istio pilot 架构图](istio-pilot.png)\n\n上图是 Pilot 设计图，来自[Istio Pilot design overview](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/design.md)。\n\n### Routing\n\nKubernetes 中的 service 是没有任何路由属性可以配置的，Istio 在设计之初就通过在同一个 Pod 中，在应用容器旁运行一个 sidecar proxy 来透明得实现细粒度的路由控制。\n\n### VirtualService\n\n\u0060VirtualService\u0060 定义针对指定服务流量的路由规则。每个路由规则都针对特定协议的匹配规则。如果流量符合这些特征，就会根据规则发送到服务注册表中的目标服务（或者目标服务的子集或版本）。对于 A\/B 测试和灰度发布等场景，通常需要使用划分 \u0060subset\u0060，VirtualService 中根据 destination 中的 subset 配置来选择路由，但是这些 subset 究竟对应哪些服务示例，这就需要 \u0060DestionationRule\u0060。\n\n### DestinationRule\n\n\u0060DestinationRule\u0060 所定义的策略，决定了经过路由处理之后的流量的访问策略。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n\n### Gateway\n\n\u0060Gateway\u0060 描述了一个负载均衡器，用于承载网格边缘的进入和发出连接。这一规范中描述了一系列开放端口，以及这些端口所使用的协议、负载均衡的 SNI 配置等内容。\n\n这个实际上就是定义服务网格的边缘路由。\n\n### ServiceEntry\n\n\u0060ServiceEntry\u0060 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\u0060ServiceEntry\u0060 描述了服务的属性（DNS 名称、VIP、端口、协议以及端点）。这类服务可能是网格外的 API，或者是处于网格内部但却不存在于平台的服务注册表中的条目（例如需要和 Kubernetes 服务沟通的一组虚拟机服务）。\n\n如果没有配置 ServiceEntry 的话，Istio 实际上是无法发现服务网格外部的服务的。\n\n### EnvoyFilter\n\n\u0060EnvoyFilter\u0060 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这一功能一定要谨慎使用。错误的配置内容一旦完成传播，可能会令整个服务网格进入瘫痪状态。\n\nEnvoy 中的 listener 可以配置多个 filter，这也是一种通过 Istio 来扩展 Envoy 的机制。\n\n## 参考\n\n- [Kubernetes 中的 service - jimmysong.io](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)\n- [Istio services model - github.com](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/service-registry.md)\n- [Istio 文档 - istio.io](https:\/\/istio.io)\n', '\/blog\/istio-service-and-traffic-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持', '以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。', '\n本文最新更新于 2022 年 3 月 7 日。\n\n\u003e 以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。\n\n在讲解 Istio 如何将 Envoy 代理注入到应用程序 Pod 中之前，我们需要先了解以下几个概念：\n\n- Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式。\n- Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n- iptables：流量劫持是通过 iptables 转发实现的。\n\n查看目前 \u0060reviews-v1-745ffc55b7-2l2lw\u0060 Pod 中运行的容器：\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod reviews-v1-745ffc55b7-2l2lw -o=jsonpath=\u0027{..spec.containers[*].name}\u0027\nreviews istio-proxy\n\u0060\u0060\u0060\n\n\u0060reviews\u0060 即应用容器，\u0060istio-proxy\u0060 即 Envoy 代理的 sidecar 容器。另外该 Pod 中实际上还运行过一个 Init 容器，因为它执行结束就自动终止了，所以我们看不到该容器的存在。关注 \u0060jsonpath\u0060 的用法请参考 [JSONPath Support](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)。\n\n## Sidecar 模式\n\n在了解 Istio 使用 Sidecar 注入之前，需要先说明下什么是 Sidecar 模式。Sidecar 是容器应用模式的一种，也是在 Service Mesh 中发扬光大的一种模式。\n\n使用 Sidecar 模式部署服务网格时，无需在节点上运行代理（因此您不需要基础结构的协作），但是集群中将运行多个相同的 Sidecar 副本。从另一个角度看：我可以为一组微服务部署到一个服务网格中，你也可以部署一个有特定实现的服务网格。在 Sidecar 部署方式中，你会为每个应用的容器部署一个伴生容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边运行一个 Sidecar 容器，可以理解为两个容器共享存储、网络等资源，可以广义的将这个注入了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。\n\n下图展示的是 Service Mesh 的架构图，其中的位于每个 Pod 中的 proxy  组成了数据平面，而这些 proxy 正是以 sidecar 模式运行的。\n\n![Istio 架构](istio-sidecar.jpg)\n\n**注意**：下文中所指的 Sidecar 都是指的 Envoy 代理容器。\n\n## Init 容器\n\nInit 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n\n一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。\n\nInit 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。\n\n在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 \u0060restartPolicy\u0060 指定的策略进行重试。然而，如果 Pod 的 \u0060restartPolicy\u0060 设置为 Always，Init 容器失败时会使用 \u0060RestartPolicy\u0060 策略。\n\n在所有的 Init 容器没有成功之前，Pod 将不会变成 \u0060Ready\u0060 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 \u0060Pending\u0060 状态，但应该会将 \u0060Initializing\u0060 状态设置为 true。Init 容器运行完成以后就会自动终止。\n\n关于 Init 容器的详细信息请参考 [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册](\/book\/kubernetes-handbook\/objects\/init-containers\/)。\n\n## Sidecar 注入示例分析\n\n本文我们将以 Istio 官方示例 \u0060bookinfo\u0060 中 \u0060reivews\u0060 服务为例，来接讲解 Sidecar 容器注入的额流程，每个注入了 Sidecar 的 Pod 中除了原先应用的应用本身的容器外，都会多出来这样两个容器：\n\n- \u0060istio-init\u0060：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发\n- \u0060istio-proxy\u0060：Envoy 代理容器，运行 Envoy 代理\n\n接下来将分别解析下这两个容器。\n\n### Init 容器解析\n\nIstio 在 Pod 中注入的 Init 容器名为 \u0060istio-init\u0060，如果你查看 \u0060reviews\u0060 Deployment 配置，你将看到其中 \u0060initContaienrs\u0060 的启动参数：\n\n\u0060\u0060\u0060bash\n      initContainers:\n        - name: istio-init\n          image: docker.io\/istio\/proxyv2:1.13.1\n          args:\n            - istio-iptables\n            - \u0027-p\u0027\n            - \u002715001\u0027\n            - \u0027-z\u0027\n            - \u002715006\u0027\n            - \u0027-u\u0027\n            - \u00271337\u0027\n            - \u0027-m\u0027\n            - REDIRECT\n            - \u0027-i\u0027\n            - \u0027*\u0027\n            - \u0027-x\u0027\n            - \u0027\u0027\n            - \u0027-b\u0027\n            - \u0027*\u0027\n            - \u0027-d\u0027\n            - 15090,15021,15020\n\u0060\u0060\u0060\n\n我们看到 \u0060istio-init\u0060 容器的入口是 \u0060istio-iptables\u0060 命令，该命令是用于初始化路由表的。\n\n### Init 容器启动入口\n\nInit 容器的启动入口是 \u0060\/usr\/local\/bin\/istio-iptable\u0060 命令，该命令的用法如下：\n\n\u0060\u0060\u0060bash\n$ istio-iptables -p PORT -u UID -g GID [-m mode] [-b ports] [-d ports] [-i CIDR] [-x CIDR] [-h]\n  -p: 指定重定向所有 TCP 流量的 Envoy 端口（默认为 $ENVOY_PORT = 15001）\n  -u: 指定未应用重定向的用户的 UID。通常，这是代理容器的 UID（默认为 $ENVOY_USER 的 uid，istio_proxy 的 uid 或 1337）\n  -g: 指定未应用重定向的用户的 GID。（与 -u param 相同的默认值）\n  -m: 指定入站连接重定向到 Envoy 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE)\n  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS）\n  -d: 指定要从重定向到 Envoy 中排除（可选）的入站端口列表，以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS）\n  -i: 指定重定向到 Envoy（可选）的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR）\n  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。\n  -z: 所有入站 TCP 流量重定向端口（默认为 $INBOUND_CAPTURE_PORT 15006）\n\u0060\u0060\u0060\n\n关于该命令的详细代码请[查看 GitHub：\u0060tools\/istio-iptables\/pkg\/cmd\/root.go\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/tools\/istio-iptables\/pkg\/cmd\/root.go)。\n\n再参考 \u0060istio-init\u0060 容器的启动参数，完整的启动命令如下：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/istio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b * -d \u002215090,15201,15020\u0022\n\u0060\u0060\u0060\n\n该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。\n\n**命令解析**\n\n这条启动命令的作用是：\n\n- 将应用容器的所有流量都转发到 Envoy 的 15006 端口。\n- 使用 \u0060istio-proxy\u0060 用户身份运行，UID 为 1337，即 Envoy 所处的用户空间，这也是 \u0060istio-proxy\u0060 容器默认使用的用户，见 YAML 配置中的 \u0060runAsUser\u0060 字段。\n- 使用默认的 \u0060REDIRECT\u0060 模式来重定向流量。\n- 将所有出站流量都重定向到 Envoy 代理。\n- 将除了 15090、15201、15020 端口以外的所有端口的流量重定向到 Envoy 代理。\n\n因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 Sidecar 容器中。\n\n### istio-proxy 容器解析\n\n为了查看 iptables 配置，我们需要登陆到 Sidecar 容器中使用 root 用户来查看，因为 \u0060kubectl\u0060 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 \u0060reviews\u0060 Pod 所在的主机上使用 \u0060docker\u0060 命令登陆容器中查看。\n\n查看 \u0060reviews\u0060 Pod 所在的主机。\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod -l app=reviews -o wide\nNAME                              READY     STATUS    RESTARTS   AGE       IP             NODE\nreviews-v1-745ffc55b7-2l2lw   2\/2       Running   0          1d        172.33.78.10   node3\n\u0060\u0060\u0060\n\n从输出结果中可以看到该 Pod 运行在 \u0060node3\u0060 上，使用 \u0060vagrant\u0060 命令登陆到 \u0060node3\u0060 主机中并切换为 root 用户。\n\n\u0060\u0060\u0060bash\n$ vagrant ssh node3\n$ sudo -i\n\u0060\u0060\u0060\n\n查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给  \u0060istio-iptables.sh\u0060 传递的参数中指定将入站流量重定向到 Envoy 的模式为“REDIRECT”，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 \u0060TPROXY\u0060 还会有 \u0060mangle\u0060 表配置。\u0060iptables\u0060 命令的详细用法请参考 [iptables](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)，规则配置请参考 [iptables 规则配置](http:\/\/www.zsythink.net\/archives\/1517)。\n\n## 理解 iptables\n\n\u0060iptables\u0060 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。\n\n在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。\n\n下图展示了 iptables 调用链。\n\n![iptables 调用链](iptables_packetflow.png)\n\n### iptables 中的表\n\nInit 容器中使用的的 iptables 版本是 \u0060v1.6.0\u0060，共包含 5 张表：\n\n1. \u0060raw\u0060 用于配置数据包，\u0060raw\u0060 中的数据包不会被系统跟踪。\n2. \u0060filter\u0060 是用于存放所有与防火墙相关操作的默认表。\n3. \u0060nat\u0060 用于 [网络地址转换](https:\/\/en.wikipedia.org\/wiki\/Network_address_translation)（例如：端口转发）。\n4. \u0060mangle\u0060 用于对特定数据包的修改（参考[损坏数据包](https:\/\/en.wikipedia.org\/wiki\/Mangled_packet)）。\n5. \u0060security\u0060 用于[强制访问控制](https:\/\/wiki.archlinux.org\/index.php\/Security#Mandatory_access_control) 网络规则。\n\n**注**：在本示例中只用到了 \u0060nat\u0060 表。\n\n不同的表中的具有的链类型如下表所示：\n\n| 规则名称    | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      | ✓    | ✓      | ✓        |\n| OUTPUT      |      | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     | ✓    | ✓      |      | ✓      | ✓        |\n\n下图是 iptables 的调用链顺序。\n\n![iptables 调用链顺序](iptables-chains.jpg)\n\n\n### iptables 命令\n\n\u0060iptables\u0060 命令的主要用途是修改这些表中的规则。\u0060iptables\u0060 命令格式如下：\n\n\u0060\u0060\u0060bash\n$ iptables [-t 表名] 命令选项［链名]［条件匹配］[-j 目标动作或跳转］\n\u0060\u0060\u0060\n\nInit 容器中的 \u0060\/istio-iptables.sh\u0060 启动入口脚本就是执行 iptables 初始化的。\n\n### 理解 iptables 规则\n\n查看 \u0060istio-proxy\u0060 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\n我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为 INPUT\/FORWARD\/OUTPUT），后跟默认策略（ACCEPT）。\n\n每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。\n\n- **pkts**：处理过的匹配的报文数量\n- **bytes**：累计处理的报文大小（字节数）\n- **target**：如果报文与规则匹配，指定目标就会被执行。\n- **prot**：协议，例如 \u0060tdp\u0060、\u0060udp\u0060、\u0060icmp\u0060 和 \u0060all\u0060。 \n- **opt**：很少使用，这一列用于显示 IP 选项。\n- **in**：入站网卡。\n- **out**：出站网卡。\n- **source**：流量的源 IP 地址或子网，后者是 \u0060anywhere\u0060。\n- **destination**：流量的目的地 IP 地址或子网，或者是 \u0060anywhere\u0060。\n\n还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。\u0060prot\u0060、\u0060opt\u0060、\u0060in\u0060、\u0060out\u0060、\u0060source\u0060 和 \u0060destination\u0060 和显示在 \u0060destination\u0060 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 \u0060target\u0060。\n\n\n**target 支持的类型**\n\n\u0060target\u0060 类型包括 ACCEPT\u0060、REJECT\u0060、\u0060DROP\u0060、\u0060LOG\u0060 、\u0060SNAT\u0060、\u0060MASQUERADE\u0060、\u0060DNAT\u0060、\u0060REDIRECT\u0060、\u0060RETURN\u0060 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 \u0060RETURN\u0060 类型，类似编程语言中的 \u0060return\u0060 语句，返回到它的调用点，继续执行下一条规则。\u0060target\u0060 支持的配置详解请参考 [iptables 详解（1）：iptables 概念](http:\/\/www.zsythink.net\/archives\/1199)。\n\n从输出结果中可以看到 Init 容器没有在 iptables 的默认链路中创建任何规则，而是创建了新的链路。\n\n## 查看 iptables nat 表中注入的规则\n\nInit 容器通过向 iptables nat 表中注入转发规则来劫持流量的，下图显示的是三个 reviews 服务示例中的某一个 Pod，其中有 init 容器、应用容器和 sidecar 容器，图中展示了 iptables 流量劫持的详细过程。\n\n![Envoy sidecar 流量劫持与路由转发示意图](istio-iptables.svg)\n\nInit 容器启动时命令行参数中指定了 \u0060REDIRECT\u0060 模式，因此只创建了 NAT 表规则，接下来我们查看下 NAT 表中创建的规则，这是全文中的**重点部分**，前面讲了那么多都是为它做铺垫的。\n\n### 进入到 reviews pod\n\nReviews 服务有三个版本，我们进入到其中任意一个版本，例如 reviews-1，首先你需要搞清楚这个 pod 运行在哪个节点上，知道那个容器的具体 ID，然后使用 SSH 登录那个节点，使用 \u0060ps\u0060 命令查看到那个容器的具体 IP，使用 \u0060nsenter\u0060 命令进入该容器。\n\n\u0060\u0060\u0060sh\nnsenter -t{PID} -n\n\u0060\u0060\u0060\n\n**为什么不直接使用 kubectl 进入容器？**\n\nIstio 向 pod 中自动注入的 sidecar 容器（名为 \u0060istio-proxy\u0060）其中默认的用户是 \u0060istio-proxy\u0060，该用户没有权限查看路由表规则，即当你在该容器中运行 \u0060iptabes\u0060 命令时会得到 \u0060iptables -t nat -L -v\u0060 这样的结果，而且你又没有 root 权限。对于 reviews 容器也是一样，默认用户的 UID 是 \u00601000\u0060，而且这个用户又没有名字，一样也无法切换为 root 用户，系统中默认没有安装 iptabels 命令。所以我们只能登录到 Pod 的宿主节点上，使用 \u0060nsenter\u0060 命令进入容器内部。\n\n### 查看路由表\n\n下面是查看 nat 表中的规则，其中链的名字中包含 \u0060ISTIO\u0060 前缀的是由 Init 容器注入的，规则匹配是根据下面显示的顺序来执行的，其中会有多次跳转。\n\n\u0060\u0060\u0060bash\n# 查看 NAT 表中规则配置的详细信息\n$ iptables -t nat -L -v\n# PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链\nChain INPUT (policy ACCEPT 2 packets, 120 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上\nChain OUTPUT (policy ACCEPT 41146 packets, 3845K bytes)\n pkts bytes target     prot opt in     out     source               destination\n   93  5580 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理\nChain POSTROUTING (policy ACCEPT 41199 packets, 3848K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND 链：将所有目的地为 9080 端口的入站流量重定向到 ISTIO_IN_REDIRECT 链上\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere             tcp dpt:9080\n\n# ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 Envoy \nChain ISTIO_IN_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUPT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 ISTIO_REDIRECT  all  --  any    lo      anywhere            !localhost\n   40  2400 RETURN     all  --  any    any     anywhere             anywhere             owner UID match istio-proxy\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match istio-proxy\t\n    0     0 RETURN     all  --  any    any     anywhere             localhost\n   53  3180 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere\n\n# ISTIO_REDIRECT 链：将所有流量重定向到 Envoy（即本地） 的 15001 端口\nChain ISTIO_REDIRECT (2 references)\n pkts bytes target     prot opt in     out     source               destination\n   53  3180 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\n\u0060iptables\u0060 显示的链的顺序，即流量规则匹配的顺序。其中要特别注意 \u0060ISTIO_OUTPUT\u0060 链中的规则配置。为了避免流量一直在 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 \u0060ISTIO_OUTPUT\u0060 规则之后就进入下一条链 \u0060POSTROUTING\u0060。\n\n\u0060ISTIO_OUTPUT\u0060 链规则匹配的详细过程如下：\n\n- 如果目的地非 localhost 就跳转到 ISTIO_REDIRECT 链\n- 所有来自 istio-proxy 用户空间的非 localhost 流量跳转到它的调用点 \u0060OUTPUT\u0060 继续执行 \u0060OUTPUT\u0060 链的下一条规则，因为 \u0060OUTPUT\u0060 链中没有下一条规则了，所以会继续执行 \u0060POSTROUTING\u0060 链然后跳出 iptables，直接访问目的地\n- 如果流量不是来自 istio-proxy 用户空间，又是对 localhost 的访问，那么就跳出 iptables，直接访问目的地\n- 其它所有情况都跳转到 \u0060ISTIO_REDIRECT\u0060 链\n\n其实在最后这条规则前还可以增加 IP 地址过滤，让某些 IP 地址段不通过 Envoy 代理。\n\n以上 iptables 规则都是 Init 容器启动的时使用 [istio-iptables](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/istio-iptables) 命令生成的，详细过程可以查看该命令行程序。\n\n## 参考\n\n- [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册 - jimmysong.io](\/book\/kubernetes-handbook\/objects\/init-containers\/)\n- [JSONPath Support - kubernetes.io](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)\n- [iptables 命令使用说明 - wangchujiang.com](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)\n- [How To List and Delete Iptables Firewall Rules - digitalocean.com](https:\/\/www.digitalocean.com\/community\/tutorials\/how-to-list-and-delete-iptables-firewall-rules)\n- [一句一句解说 iptables 的详细中文手册 - cnblog.com](https:\/\/www.cnblogs.com\/fhefh\/archive\/2011\/04\/04\/2005249.html)\n', '\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/tracing-grpc-with-istio/">[译] 在 Istio 中跟踪 gRPC</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中跟踪 gRPC', '本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等', '\nAspen Mesh 很喜欢用[gRPC](https:\/\/grpc.io\/docs\/)。Apen Mesh 面向公众的 API 和许多内部 API 大多都是使用 gRPC 构建的。如果您还没有听说过 gRPC（熟练掌握 gRPC 真的很难），那么我先为您简单的介绍下，它是一种新型、高效和优化的远程过程调用（RPC）框架。gRPC 基于[protocol buffer](https:\/\/developers.google.com\/protocol-buffers\/)序列化格式和[HTTP\/2](https:\/\/http2.github.io\/)网络协议。\n\n使用 HTTP\/2 协议，gRPC 应用程序可以利用多路复用请求显著提高连接利用率，而且比起如 HTTP\/1.1 等[其他协议](https:\/\/http2.github.io\/faq\/)具有更多增强功能。此外，protocal buffer 是以二进制方式对结构化数据进行序列化，这比起基于文本的序列化方式更简单且可扩展，还可以显着提高性能。将这两个结果组合在一个低延迟和高度可扩展的 RPC 框架中，这实质上就是 gRPC。此外，不断增长的 gRPC 生态支持使用多种语言编写应用程序，例如（C \u002b\u002b、Java、Go 等），还包括大量第三方[库](https:\/\/github.com\/grpc-ecosystem)。\n\n除了上面列出的好处之外，gRPC 让我最喜欢的一点是可以让我以简单直观的方式指定 RPC（使用 protobuf IDL）以及客户端调用服务器端的方法，就好像是调用本地函数一样。很多代码（服务描述和处理程序、客户端方法等）都可以自动生成，这使得 gRPC 非常好用。\n\n现在我已经介绍了 gRPC 的一些背景知识，我们再把注意力转回到博客的主题。在这里，我将介绍如何在基于 gRPC 的应用程序中添加跟踪，特别是如果您使用 Istio 或 Aspen Mesh。\n\n跟踪（Tracing）非常适合于调试和理解应用程序的行为。理解所有跟踪数据的关键是能够关联来自与单个客户端请求相关的多个不同微服务的跨度（span）。\n\n为了实现这一点，应用程序中的所有微服务应该传播跟踪 header。如果您使用的是像 Istio 或 Aspen Mesh 这样的服务网格，ingress 和 sidecar 代理会自动添加适当的跟踪 header，并将这些 span 报告给跟踪收集器后端，如 Jaeger 或 Zipkin。应用程序唯一要做的就是将传入请求（sidecar 或 ingress 代理添加的）的跟踪 header 传播到其对其他微服务的所有传出请求。\n\n## gRPC 到 grpc 请求传播 header\n\n使用 gRPC，跟踪 header 传播的最简单方法是使用[grpc opentracing middleware](https:\/\/github.com\/grpc-ecosystem\/go-grpc-middleware\/tree\/master\/tracing\/opentracing)库的客户端拦截器。如果您的 gRPC 应用程序在收到传入请求时发出新的出站 gRPC 请求，则可以使用此功能。以下是将传入的跟踪 header 正确传播到传出的 gRPC 请求的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022github.com\/grpc-ecosystem\/go-grpc-middleware\/tracing\/opentracing\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address for the new outbound request\n  func createGRPCConn(ctx context.Context, addr string) (*grpc.ClientConn, error) {\n  \tvar opts []grpc.DialOption\n  \topts = append(opts, grpc.WithStreamInterceptor(\n  \t\tgrpc_opentracing.StreamClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \topts = append(opts, grpc.WithUnaryInterceptor(\n  \t\tgrpc_opentracing.UnaryClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \tconn, err := grpc.DialContext(ctx, addr, opts...)\n  \tif err != nil {\n  \t\tglog.Error(\u0022Failed to connect to application addr: \u0022, err)\n  \t\treturn nil, err\n  \t}\n  \treturn conn, nil\n  }\n\u0060\u0060\u0060\n\n很简单对吧？\n\n添加 opentracing 客户端拦截器可确保在客户端连接上创建任何新的一元（unary）或流式 gRPC 请求注入正确的跟踪 header。如果传递的上下文中存在跟踪 header（如使用 Aspen Mesh 或 Istio 传入入站 gRPC 请求上下文），则新创建的 span 将作为传递的上下文中已存在的 span 的子 span。另外，如果上下文中没有跟踪信息，则会为出站 gRPC 请求创建新的根 span。\n\n## gRPC 到 HTTP 请求传播 header\n\n我们再来看下这个场景，如果您的应用程序在收到一个新传入的 gRPC 请求时发出一个出站 HTTP\/1.1 请求。以下是在此情况下完成 header 传播的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022golang.org\/x\/net\/context\/ctxhttp\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address of the application being requested\n  func makeNewRequest(ctx context.Context, addr string) {\n    if span := ot.SpanFromContext(ctx); span != nil {\n      req, _ := http.NewRequest(\u0022GET\u0022, addr, nil)\n\n      ot.GlobalTracer().Inject(\n        span.Context(),\n        ot.HTTPHeaders,\n        ot.HTTPHeadersCarrier(req.Header))\n\n      resp, err := ctxhttp.Do(ctx, nil, req)\n      \/\/ Do something with resp\n    }\n  }\n\u0060\u0060\u0060\n\n这是序列化传入请求（HTTP 或 gRPC）上下文中跟踪 header 的标准方式。\n\n很好，至此我们已经能够使用库或标准实用程序代码来实现我们想要的功能。\n\n## 使用 grpc-gateway 时传播 header\n\ngRPC 应用程序中有一个常用的库[grpc-gateway](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway)，可以将 gRPC 服务作为 RESTful JSON API 暴露出来。当您想要了解 gRPC 或维护 RESTful 架构，使用 curl、web 浏览器等客户端时，这非常有用。有关如何使用\u0060grpc-gateway\u0060从 gRPC 中暴露 RESTful API 的更多细节请参考[这个博客](https:\/\/coreos.com\/blog\/grpc-protobufs-swagger.html)。如果您对此架构不熟悉，我强烈建议您阅读。\n\n当您开始使用\u0060grpc-gateway\u0060并想传播跟踪 header 时，有一些值得一提的非常有趣的交互。 \u0060grpc-gateway\u0060 [文档](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway#mapping-grpc-to-http)指出，作为 gRPC 请求 header，所有 IANA（互联网号码分配局）永久 HTTP header 都以\u0060grpcgateway-\u0060作为前缀并添加。这很好，但是像\u0060x-b3-traceid\u0060、\u0060x-b3-spanid\u0060等跟踪 header 不是 IANA 认可的永久 HTTP header，当\u0060grpc-gateway\u0060代理 HTTP 请求时，它们不会被复制到 gRPC 请求中。这意味着只要将\u0060grpc-gateway\u0060添加到您的应用程序中，header 传播逻辑就会停止工作。\n\n这是个特例吗？添加一个东西打断了当前的工作。不用担心，我为您解决问题！\n\n这是一种确保使用\u0060grpc-gateway\u0060在 HTTP 和 gRPC 之间进行代理时不会丢失跟踪信息的方法：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022google.golang.org\/grpc\/metadata\u0022\n    \u0022github.com\/grpc-ecosystem\/grpc-gateway\/runtime\u0022\n  )\n\n  const (\n  \tprefixTracerState  = \u0022x-b3-\u0022\n  \tzipkinTraceID      = prefixTracerState \u002b \u0022traceid\u0022\n  \tzipkinSpanID       = prefixTracerState \u002b \u0022spanid\u0022\n  \tzipkinParentSpanID = prefixTracerState \u002b \u0022parentspanid\u0022\n  \tzipkinSampled      = prefixTracerState \u002b \u0022sampled\u0022\n  \tzipkinFlags        = prefixTracerState \u002b \u0022flags\u0022\n  )\n\n  var otHeaders = []string{\n  \tzipkinTraceID,\n  \tzipkinSpanID,\n  \tzipkinParentSpanID,\n  \tzipkinSampled,\n  \tzipkinFlags}\n\n  func injectHeadersIntoMetadata(ctx context.Context, req *http.Request) metadata.MD {\n  \tpairs := []string{}\n  \tfor _, h := range otHeaders {\n  \t\tif v := req.Header.Get(h); len(v) \u003e 0 {\n  \t\t\tpairs = append(pairs, h, v)\n  \t\t}\n  \t}\n  \treturn metadata.Pairs(pairs...)\n  }\n\n  type annotator func(context.Context, *http.Request) metadata.MD\n\n  func chainGrpcAnnotators(annotators ...annotator) annotator {\n  \treturn func(c context.Context, r *http.Request) metadata.MD {\n  \t\tmds := []metadata.MD{}\n  \t\tfor _, a := range annotators {\n  \t\t\tmds = append(mds, a(c, r))\n  \t\t}\n  \t\treturn metadata.Join(mds...)\n  \t}\n  }\n\n  \/\/ Main function of your application. Insert tracing headers into gRPC\n  \/\/ metadata using annotators\n  func run() {\n    ...\n\t  annotators := []annotator{injectHeadersIntoMetadata}\n\n\t  gwmux := runtime.NewServeMux(\n\t\t  runtime.WithMetadata(chainGrpcAnnotators(annotators...)),\n\t  )\n    ...\n  }\n\u0060\u0060\u0060\n\n在上面的代码中，我使用了\u0060grpc-gateway\u0060库中的[\u0060runtime.WithMetadata\u0060](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway\/blob\/master\/runtime\/mux.go#L88)。该 API 从 HTTP 请求中读取属性并将其添加到 gRPC 元数据中，这一点非常有用，这正是我们想要的！虽然多了一步，但仍然使用库提供的 API。\n\n\u0060injectHeadersIntoMetadata\u0060注解器在 HTTP 请求中查找跟踪 header 并将其附加到 gRPC 元数据中，从而确保跟踪 header 可以使用前面部分中提到的技术从 gRPC 进一步传播到出站请求。\n\n您可能观察到的另一个有趣的事情是\u0060chainGrpcAnnotators\u0060包装函数。\u0060runtime.WithMetadata\u0060 API 只允许添加一个注释器，这可能不足以满足所有场景。在我们的例子中，我们有一个跟踪注释器（如上面的一个示例）和一个认证注释器，它将来自 HTTP 请求的认证数据附加到 gRPC 元数据。使用\u0060chainGrpcAnnotators\u0060允许您添加多个注释器，并且包装函数将来自各种注释器的元数据加入到 gRPC 请求的单个元数据中。\n', '\/trans\/tracing-grpc-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/gitops-for-istio-manage-istio-config-like-code/">[译] Istio 的 GitOps—像代码一样管理 Istio 配置</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/05/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.weave.works/blog/gitops-for-istio-manage-istio-config-like-code" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 的 GitOps—像代码一样管理 Istio 配置', '本文是 Weaveworks 的 CEO 对 GitOps 工作流程和 Istio 的看法。本文还介绍了如何使用 GitOps 上线和管理 Istio 的金丝雀部署。以上观点来自哥本哈根 Kubecon 上的 Weaveworks 的分享。', '\n在今年的哥本哈根 Kubecon 大会上，Weaveworks 的 CEO Alexis Richardson 与 Varun Talwar（来自一家隐形创业公司）谈到了 GitOps 工作流程和 Istio。会后 Weaveworks 的 Stefan Prodan 进行了的演示，介绍如何使用 GitOps 上线和管理 Istio 的金丝雀部署。\n\n会谈和演示中解释了：\n\n- 什么是 GitOps？为什么需要它？\n- Istio 和 GitOps 的最佳实践是如何管理在其上运行的应用程序的。\n- 如何使用 GitOps 工作流程和 Istio 进行金丝雀部署。\n\n### 什么是 GitOps？\n\n[GitOps 是实现持续交付的一种方式](https:\/\/www.weave.works\/blog\/the-gitops-pipeline)。“GitOps 使用 Git 作为声明式基础架构和应用程序的真实来源”Alexis Richardson 说。\n\n当对 Git 进行更改时，自动化交付管道会上线对基础架构的更改。但是这个想法还可以更进一步——使用工具来比较实际的生产状态和源代码控制中描述的状态，然后告诉你什么时候集群的状态跟描述的不符。\n\n### Git 启用声明式工具\n\n通过使用 Git 这样的声明式工具可以对整套配置文件做版本控制。通过将 Git 作为唯一的配置来源，可以很方便的复制整套基础架构，从而将系统的平均恢复时间从几小时缩短到几分钟。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruc9ao41vj317o0oqq80.jpg)\n\n### GitOps 赋能开发人员拥抱运维\n\n[Weave Cloud](https:\/\/cloud.weave.works\/signup) 的 GitOps 核心机制在于 CI\/CD 工具，其关键是[支持 Git 集群同步](https:\/\/github.com\/weaveworks\/flux\/blob\/master\/site\/introduction.md#automated-git-cluster-synchronisation)的持续部署（CD）和发布管理。Weave Cloud 部署专为版本控制系统和声明式应用程序堆栈而设计。以往开发人员都是使用 Git 管理代码和提交 PR（Pull Request），现在他们也可以使用 Git 来加速和简化 Kubernetes 和 Istio 等其他声明式技术的运维工作。\n\n#### GitOps 的三个核心原则\n\n根据 Alexis 的说法，下面描述的是为何 GitOps 既是 Kubernetes 又是云原生核心的原因：\n\n**1. GitOps 的核心是声明式配置**\n\n通过使用 Git 作为实体源，并使用 Kubernetes 做滚动更新，可以观察集群并将其与期望的状态进行比较。 [通过将声明性配置视为代码](https:\/\/www.weave.works\/blog\/gitops-operations-by-pull-request)，它允许您通过在未成功时重新应用更改来强制收敛。\n\n**2. 不应该直接使用 Kubectl**\n\n根据一般规则来看，将代码经过 CI 直接 push 到生产并不是个好主意。许多人通过 CI 工具驱动部署，但是当你这样做的时候[你可能不得不做一个访问生产的东西](https:\/\/www.weave.works\/blog\/how-secure-is-your-cicd-pipeline)。\n\n**3. 使用 operator 模式**\n\n通过 operator 模式，集群将始终与 Git 中签入的内容保持同步。Weave Flux 是开源的，它是使用 Istio 演示下面的金丝雀部署的基础，您可以使用 operator 管理集群中的更改。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruc9qogakj312t0ls41d.jpg)\n\n无论是开发流程还是生产流程，还是从预发到合并到生产，operator 都会将更改 pull 到集群中，即使是有多个更改也能以原子的方式部署。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1fruca1y7xqj312p0jmn09.jpg)\n\n### Istio 的 GitOps 工作流程\n\n接下来，Varun Talwar 谈到了 Istio 是什么以及如何使用 GitOps 工作流管理应用程序。\n\nIstio 是一年前发布的服务网格。它是一个专用的基础设施层，用于为微服务架构中的所有服务间交互提供服务。Istio 中的所有操作都是通过声明式配置文件驱动的。也就是说像 Istio 这样的服务网格可以让开发人员在 Git 中像管理代码一样完全的管理服务行为。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucacq5nij317u0oo46y.jpg)\n\n借助 Git 工作流程，开发人员可以对 Istio 中的任何内容进行建模，包括服务行为及其交互，如超时、断路器、流量路由、负载均衡及 A\/B 测试和金丝雀发布等。\n\n### 跨团队的多组配置\n\nIstio 有四个广泛的领域应用，都是通过声明式配置驱动的：\n\n1. 流量管理：与管理入口和服务流量有关。\n2. 可观测性：监控、流量延迟、QPS、错误率等。\n3. 安全性：所有服务间调用的认证与授权。\n4. 性能：包括重试超时、故障注入和断路等。\n\n因为所有这些领域都可以跨越组织内的不同团队，所以这使得在 Istio 上管理应用程序尤其具有挑战性。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucalfge7j317u0oq7aq.jpg)\n\n这些配置驱动的很多设置是跨团队的。例如，有的团队想用 Zipkin 进行跟踪，而另一个团队可能想用 Jaeger。这些决策可以针对某一项服务进行，也可以跨服务进行。当决策跨越团队时，审批工作流程将变得更加复杂，并不总是原子性的。金丝雀发布不是原子的一次性事情。\n\n### 通过 GitOps 工作流程在 Istio 上做金丝雀部署\n\nStefan Prodan 向我们展示了如何使用带有 Weave Flux 和 Prometheus 的 GitOps 工作流程在 Istio 中做一次金丝雀发布——您可以在 Weave Cloud 中使用这些工具以及金丝雀部署和可观测性。\n\n简而言之，当您想要用一部分用户测试某些新功能时，会使用金丝雀部署或发布。传统上，您可能拥有两台几乎完全相同的服务器：一台用于所有用户，另一台用于将新功能部署到某一组用户。\n\n但通过使用 GitOps 工作流程，您可以通过 Git 控制您的金丝雀，而不是设置两个独立的服务器。当出现问题时，可以回滚到旧版本，并且可以在金丝雀部署分支上进行迭代，并继续发布，直到满足预期为止。\n\n![](https:\/\/raw.githubusercontent.com\/servicemesher\/website\/master\/content\/blog\/gitops-for-istio-manage-istio-config-like-code\/00704eQkgy1frucatn3n3j312q0lw102.jpg)\n\n#### 在 Weave Cloud 中，Git 控制的金丝雀发布具有完全可观测性\n\n通过流水线推送变更，您可以向用户发送部分一定比例的流量。使用 Weave Cloud，您可以在仪表板中观察金丝雀是否按预期工作。如果有问题可以继续修改，然后推出下一个版本，对其进行标记后通过同一流水线部署。这就是 GitOps 工作流程帮助您管理的迭代过程。\n\n### 总结\n\nAlexis Richardson 给了我们关于 GitOps 的概述，以及为什么您需要在管理运行在 Kubernetes 和 Istio 上的应用程序时考虑这种方法。然后 Varun Talwar 谈到了 Istio 是什么以及如何使用 GitOps 工作流程来管理应用程序。最后，Stefan Prodan 向我们展示了一个特殊用例，其中非原子工作流程（如金丝雀发布）也可以通过像 Istio 这样的服务网格上的 GitOps 进行管理。\n\n本次演讲的视频请见：[GitOps for Istio - Manage Istio Config like Code - Varun Talwar \u0026 Alexis Richardson](https:\/\/www.youtube.com\/watch?v=VkKMf23ZokY)\n', '\/trans\/gitops-for-istio-manage-istio-config-like-code\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Weaveworks 的 CEO 对 GitOps 工作流程和 Istio 的看法。本文还介绍了如何使用 GitOps 上线和管理 Istio 的金丝雀部署。以上观点来自哥本哈根 Kubecon 上的 Weaveworks 的分享。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-tutorial/">Istio Service Mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Service Mesh 教程', '本文是 Istio 管理 Java 微服务的案例教程。', '\n本文是 Istio 管理 Java 微服务的案例教程，使用的所有工具和软件全部基于开源方案，替换了 [redhat-developer-demos\/istio-tutorial](https:\/\/github.com\/redhat-developer-demos\/istio-tutorial) 中的 minishift 环境，使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 替代，沿用了原有的微服务示例，使用 Zipkin 做分布式追踪而不是 Jaeger。\n\n本文中的代码和 YAML 文件见 \u003chttps:\/\/github.com\/rootsongjc\/istio-tutorial\u003e。\n\n## 准备环境\n\n在进行本教程前需要先准备以下工具和环境。\n\n- 8G 以上内存\n- Vagrant 2.0\u002b\n- Virtualbox 5.0 \u002b\n- 提前下载 kubernetes1.9.1 的 release 压缩包\n- docker 1.12\u002b\n- kubectl 1.9.1\u002b\n- maven 3.5.2\u002b\n- istioctl 0.7.1\n- git\n- curl、gzip、tar\n- [kubetail](https:\/\/github.com\/johanhaleby\/kubetail)\n- [siege](https:\/\/github.com\/JoeDog\/siege)\n\n## 安装 Kubernetes\n\n请参考 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 在本地启动拥有三个节点的 kubernetes 集群。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster.git\ncd kubernetes-vagrant-centos-cluster\nvagrant up\n\u0060\u0060\u0060\n\n## 安装 Istio\n\n在 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 中的包含 Istio 0.7.1 的安装 YAML 文件，运行下面的命令安装 Istio。\n\n\u0060\u0060\u0060bash\nkubectl apply -f addon\/istio\/\n\u0060\u0060\u0060\n\n**运行示例**\n\n\u0060\u0060\u0060bash\nkubectl apply -n default -f \u003c(istioctl kube-inject -f yaml\/istio-bookinfo\/bookinfo.yaml)\n\u0060\u0060\u0060\n\n在您自己的本地主机的\u0060\/etc\/hosts\u0060文件中增加如下配置项。\n\n\u0060\u0060\u0060ini\n172.17.8.102 grafana.istio.jimmysong.io\n172.17.8.102 servicegraph.istio.jimmysong.io\n172.17.8.102 zipkin.istio.jimmysong.io\n\u0060\u0060\u0060\n\n我们可以通过下面的 URL 地址访问以上的服务。\n\n| Service      | URL                                                          |\n| ------------ | ------------------------------------------------------------ |\n| grafana      | \u0060http:\/\/grafana.istio.jimmysong.io\u0060                          |\n| servicegraph | \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060，\u0060http:\/\/servicegraph.istio.jimmysong.io\/graph\u0060 |\n| zipkin       | \u0060http:\/\/zipkin.istio.jimmysong.io\u0060                           |\n\n详细信息请参阅 [Istio 文档](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)。\n\n## 部署示例应用\n\n在打包成镜像部署到 kubernetes 集群上运行之前，我们先在本地运行所有示例。\n\n本教程中三个服务之间的依赖关系如下：\n\n\u0060\u0060\u0060ini\ncustomer → preference → recommendation\n\u0060\u0060\u0060\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务是基于 Spring Boot 构建的，\u0060recommendation\u0060 微服务是基于 [vert.x](https:\/\/vertx.io) 构建的。\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务的 \u0060pom.xml\u0060 文件中都引入了 OpenTracing 和 Jeager 的依赖。\n\n\u0060\u0060\u0060xml\n\u003cdependency\u003e\n\t\u003cgroupId\u003eio.opentracing.contrib\u003c\/groupId\u003e\n\t\u003cartifactId\u003eopentracing-spring-cloud-starter\u003c\/artifactId\u003e\n\t\u003cversion\u003e0.1.7\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u003cdependency\u003e\n\t\u003cgroupId\u003ecom.uber.jaeger\u003c\/groupId\u003e\n\t\u003cartifactId\u003ejaeger-tracerresolver\u003c\/artifactId\u003e\n    \u003cversion\u003e0.25.0\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u0060\u0060\u0060\n\n### 本地运行\n\n我们首先在本地确定所有的微服务都可以正常运行，然后再打包镜像在 kubernetes 集群上运行。\n\n**启动 Jaeger**\n\n使用 docker 来运行 jagger。\n\n\u0060\u0060\u0060bash\ndocker run -d \\\n  --rm \\\n  -p5775:5775\/udp \\\n  -p6831:6831\/udp \\\n  -p6832:6832\/udp \\\n  -p16686:16686 \\\n  -p14268:14268 \\\n  jaegertracing\/all-in-one:1.3\n\u0060\u0060\u0060\n\nJaeger UI 地址 \u0060http:\/\/localhost:16686\u0060\n\n**Customer**\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nJAEGER_SERVICE_NAME=customer mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址： \u0060http:\/\/localhost:8280\u0060\n\n**Preference**\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nJAEGER_SERVICE_NAME=preference mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8180\u0060\n\n**Recommendation**\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn vertx:run\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8080\u0060\n\n所有服务都启动之后，此时访问 \u0060http:\/\/localhost:8280\u0060 将会看到如下输出。\n\n\u0060\u0060\u0060bash\ncustomer =\u003e preference =\u003e recommendation v1 from \u0027unknown\u0027: 1\n\u0060\u0060\u0060\n\n每访问一次最后的数字就会加 1。\n\n**Jaeger**\n\n此时访问 \u0060http:\/\/localhost:16686\u0060 将看到 Jaeger query UI，所有应用将 metrics 发送到 Jeager 中。\n\n可以在 Jaeger UI 中搜索 \u0060customer\u0060 和 \u0060preference\u0060 service 的 trace 并查看每次请求的 tracing。\n\n![Jaeger query UI](jaeger-query-ui.webp)\n\n### 构建镜像\n\n在本地运行测试无误之后就可以构建镜像了。本教程中的容器镜像都是在 [fabric8\/java-jboss-openjdk8-jdk](https:\/\/hub.docker.com\/r\/fabric8\/java-jboss-openjdk8-jdk\/~\/dockerfile\/) 的基础上构建的。只要将 Java 应用构建出 Jar 包然后放到 \u0060\/deployments\u0060 目录下基础镜像就可以自动帮我们运行，所以我们看到着几个应用的 \u0060Dockerfile\u0060 文件中都没有执行入口，真正的执行入口是 [run-java.sh](https:\/\/github.com\/fabric8io-images\/java\/blob\/master\/images\/jboss\/openjdk8\/jdk\/run-java.sh)。\n\n**Customer**\n\n构建 Customer 镜像。\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-customer:v1 .\ndocker push jimmysong\/istio-tutorial-customer:v1\n\u0060\u0060\u0060\n\n第一次构建和上传需要花费一点时间，下一次构建就会很快。\n\n**Preference**\n\n构建 Preference 镜像。\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-preference:v1 .\ndocker push jimmysong\/istio-tutorial-preference:v1\n\u0060\u0060\u0060\n\n**Recommendation**\n\n构建 Recommendation 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v1 .\ndocker push jimmysong\/istio-tutorial-recommendation:v1\n\u0060\u0060\u0060\n\n现在三个 docker 镜像都构建完成了，我们检查一下。\n\n\u0060\u0060\u0060bash\n$ docker images | grep istio-tutorial\nREPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE\njimmysong\/istio-tutorial-recommendation   v1                  d31dd858c300        51 seconds ago      443MB\njimmysong\/istio-tutorial-preference       v1                  e5f0be361477        6 minutes ago       459MB\njimmysong\/istio-tutorial-customer         v1                  d9601692673e        13 minutes ago      459MB\n\u0060\u0060\u0060\n\n### 部署到 Kubernetes\n\n使用下面的命令将以上服务部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# create new namespace\nkubectl create ns istio-tutorial\n\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f recommendation\/kubernetes\/Service.yml\n\n# deploy preferrence\nkubectl apply -f \u003c(istioctl kube-inject -f preference\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f preference\/kubernetes\/Service.yml\n\n# deploy customer\nkubectl apply -f \u003c(istioctl kube-inject -f customer\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f customer\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n**注意：**\u0060preference\u0060 和 \u0060customer\u0060 应用启动速度比较慢，我们将 livenessProb 配置中的 \u0060initialDelaySeconds\u0060 设置为 **20** 秒。\n\n查看 Pod 启动状态：\n\n\u0060\u0060\u0060bash\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加 Ingress 配置\n\n为了在 kubernetes 集群外部访问 customer 服务，我们需要增加 ingress 配置。\n\n\u0060\u0060\u0060bash\nkubectl apply -f ingress\/ingress.yaml\n\u0060\u0060\u0060\n\n修改本地的 \u0060\/etc\/hosts\u0060 文件，增加一条配置。\n\n\u0060\u0060\u0060ini\n172.17.8.102 customer.istio-tutorial.jimmysong.io\n\u0060\u0060\u0060\n\n现在访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\u0060 将看到如下输出：\n\n\u0060\u0060\u0060ini\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 1\n\u0060\u0060\u0060\n\n批量访问该地址。\n\n\u0060\u0060\u0060bash\n.\/bin\/poll_customer.sh\n\u0060\u0060\u0060\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务的分布式追踪和依赖关系。\n\n![分布式追踪](istio-tutorial-zipkin-trace.webp)\n\n![依赖关系](istio-tutorial-zipkin-dependency.webp)\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务间的关系图和 QPS。\n\n![服务关系图和 QPS](istio-tutorial-Servicegraph-dotviz.webp)\n\n访问 \u0060http:\/\/grafana.istio.jimmysong.io\u0060 查看 Service Mesh 的监控信息。\n\n![Grafana 监控](istio-tutorial-grafana.webp)\n\n## Istio 使用示例\n\n为了试用 Istio 中的各种功能，我们需要为应用构建多个版本，我们为 recommendation 构建 v2 版本的镜像，看看如何使用 Istio 控制微服务的流量。\n\n### 构建 recommendation:v2\n\n我们将构建新版的 \u0060recommendation\u0060 服务的镜像，并观察 \u0060customer\u0060 对不同版本的 \u0060recommendataion\u0060 服务的访问频率。\n\n修改 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 程序中代码。\n\n将 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v1 from \u0027%s\u0027: %d\\n\u0022;\u0060 修改为 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v2 from \u0027%s\u0027: %d\\n\u0022;\u0060\n\n并构建 \u0060recommendation:v2\u0060 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n将应用部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务，将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3581\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3582\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3583\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 4\n\u0060\u0060\u0060\n\n我们可以看到 v1 和 v2 版本的 \u0060recommendation\u0060 服务会被间隔访问到。\n\n我们再将 v2 版本的 \u0060recommendation\u0060 实例数设置成 2 个。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=2 deployment\/recommendation-v2 -n istio-tutorial\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n观察 \u0060recommendation-v2\u0060 Pod 达到两个之后再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 71\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3651\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 72\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3652\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 73\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3653\n\u0060\u0060\u0060\n\n观察输出中 v1 和 v2 版本 \u0060recommendation\u0060 的访问频率。\n\n将 \u0060recommendataion\u0060 服务的实例数恢复为 1。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=1 deployment\/recommendation-v2\n\u0060\u0060\u0060\n\n### 修改 Istio RouteRules\n\n以下所有路有规则都是针对 \u0060recommendation\u0060 服务，并在 repo 的根目录下执行。\n\n**将所有流量打给 v2**\n\n下面将演示如何动态的划分不同版本服务间的流量，将所有的流量都打到 \u0060recommendation:v2\u0060。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务将看到所有的流量都会打到 \u0060recommendation:v2\u0060。\n\n删除 RouteRules 后再访问 \u0060customer\u0060 服务将看到又恢复了 v1 和 v2 版本的 \u0060recommendation\u0060 服务的间隔访问。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-default\n\u0060\u0060\u0060\n\n**切分流量**\n\n将 90% 的流量给 v1，10% 的流量给 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行\u0060bin\/poll_customer.sh\u0060 观察访问情况。\n\n要想动态切分流量只要修改 RouteRules 中的 \u0060weight\u0060 配置即可。\n\n\u0060\u0060\u0060yaml\napiVersion: config.istio.io\/v1alpha2\nkind: RouteRule\nmetadata:\n  name: recommendation-v1-v2\nspec:\n  destination:\n    namespace: istio-tutorial\n    name: recommendation\n  precedence: 5\n  route:\n  - labels:\n      version: v1\n    weight: 90\n  - labels:\n      version: v2\n    weight: 10\n\u0060\u0060\u0060\n\n因为 RouteRule 有优先级，为了继续后面的实验，在验证完成后删除该 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 故障注入\n\n有时候我们为了增强系统的健壮性，需要对系统做混沌工程，故意注入故障，并保障服务可以自动处理这些故障。\n\n**注入 HTTP 503 错误**\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-503.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n有 50% 的几率报 503 错误。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 135\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3860\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 136\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3861\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 137\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\n\u0060\u0060\u0060\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加延迟\n\n增加服务的访问延迟。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-delay.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n会有 50% 的几率访问 \u0060recommendation\u0060 服务有 7 秒的延迟。百分比和延迟时间可以在 RouteRule 中配置。\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-delay -n istio-tutorial\n\u0060\u0060\u0060\n\n### 重试\n\n让服务不是直接失败，而是增加重试机制。\n\n我们下面将同时应用两条 RouteRule，让访问 \u0060recommendation\u0060 服务时有 50% 的几率出现 503 错误，并在出现错误的时候尝试访问 v2 版本，超时时间为 2 秒。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2_503.yml -n istio-tutorial\nistioctl create -f istiofiles\/route-rule-recommendation-v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行 \u0060bin\/poll_customer.sh\u0060 我们看到一开始有些 503 错误，然后所有的流量都流向了 v2。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v2-retry -n istio-tutorial\nistioctl delete routerule recommendation-v2-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 超时\n\n设置超时时间，只有服务访问超时才认定服务访问失败。\n\n取消注释 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 中的下面一行，增加超时时间为 3 秒。\n\n\u0060\u0060\u0060java\nrouter.get(\u0022\/\u0022).handler(this::timeout);\n\u0060\u0060\u0060\n\n重新生成镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n重新部署到 kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl delete -f recommendation\/kubernetes\/Deployment-v2.yml\n\u0060\u0060\u0060\n\n因为我们重新构建的镜像使用了同样的名字和 tag，而之前在 \u0060Deployment-v2.yml\u0060 中配置的镜像拉取策略是 \u0060IfNotPresent\u0060，这样的话即使我们构建了新的镜像也无法应用到集群上，因此将镜像拉取策略改成 \u0060Always\u0060 确保每次启动 Pod 的时候都会拉取镜像。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n启用超时 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-timeout.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n访问 \u0060customer\u0060 服务将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4002\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4003\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4004\n\u0060\u0060\u0060\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-timeout -n istio-tutorial\n\u0060\u0060\u0060\n\n### 基于 user-agent 的智能路由（金丝雀发布）\n\nUser-agent 是一个字符串，其中包含了浏览器的信息，访问 https:\/\/www.whoishostingthis.com\/tools\/user-agent 获取你的 user-agent。\n\n我的 user-agent 是：\n\n\u0060\u0060\u0060ini\nMozilla\/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/65.0.3325.181 Safari\/537.36\n\u0060\u0060\u0060\n\n将所有的流量打到 v1。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n将使用 Safari 浏览器访问的流量打到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-safari-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n谁用 Safari 或者 Chrome（Chrome 浏览器的 user-agent 中也包含 Safari 字段）访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\/\u0060 在经过 3 秒钟（我们在前面重新编译 v2 镜像，设置了 3 秒超时时间）后将看到访问 v2 的输出。\n\n或者使用 curl 访问。\n\n\u0060\u0060\u0060bash\ncurl -A Safari http:\/\/customer.istio-tutorial.jimmysong.io\/\ncurl -A Firefox http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察返回的结果。\n\n将移动端用户的流量导到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-mobile-recommendation-v2.yml -n istio-tutorial\n\ncurl -A \u0022Mozilla\/5.0 (iPhone; U; CPU iPhone OS 4(KHTML, like Gecko) Version\/5.0.2 Mobile\/8J2 Safari\/6533.18.5\u0022 http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察输出的结果。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-mobile -n istio-tutorial\nistioctl delete routerule recommendation-safari -n istio-tutorial\nistioctl delete routerule recommendation-default -n istio-tutorial\n\u0060\u0060\u0060\n\n### 镜像流量\n\n确保当前至少运行了两个版本的 \u0060recommendation\u0060 服务，并且没有 RouteRule。\n\n注：可以使用 \u0060istioctl get routerule\u0060 获取 RouteRule。\n\n设置流量镜像，将所有 v1 的流量都被镜像到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1-mirror-v2.yml -n istio-tutorial\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n查看 recommendation-v2 的日志。\n\n\u0060\u0060\u0060bash\nkubectl logs -f \u0060oc get pods|grep recommendation-v2|awk \u0027{ print $1 }\u0027\u0060 -c recommendation\n\u0060\u0060\u0060\n\n### 访问控制\n\nIstio 可以设置服务访问的黑白名单，如果没有权限的话会返回 HTTP 404 Not Found。\n\n#### 白名单\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 404 NOT_FOUND:preferencewhitelist.listchecker.istio-tutorial:customer is not whitelisted\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n#### 黑名单\n\n设置黑名单，所有位于黑名单中的流量将获得 403 Forbidden 返回码。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 403 PERMISSION_DENIED:denycustomerhandler.denier.istio-tutorial:Not allowed\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### 负载均衡\n\nKubernetes 中默认的负载均衡策略是 round-robin，当然我们可以使用 Istio 把它修改成 random。\n\n增加 v1 的实例数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v1 --replicas=2 -n istio-tutorial\n\u0060\u0060\u0060\n\n持续访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n保持前台输出，观察流量的行为。\n\n应用负载均衡策略。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n观察一段时间流量的行为后，重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\nkubectl scale deployment recommendation-v1 --replicas=1 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 速率限制\n\n暂时不可用\n\n### 断路器\n\n当达到最大连接数和最大挂起请求数时快速失败。\n\n将流量在 v1 和 v2 之间均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n未开启断路器的时候启动负载测试。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\nNew configuration template added to \/Users\/jimmysong\/.siege\nRun siege -C to view the current settings in that file\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.10 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.12 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.05 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.25 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.26 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.58 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.03 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.04 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.11 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.71 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.52 secs:      75 bytes ==\u003e GET  \/\n^C\nLifting the server siege...\nTransactions:\t\t          31 hits\nAvailability:\t\t      100.00 %\nElapsed time:\t\t        7.99 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        2.99 secs\nTransaction rate:\t        3.88 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t       11.60\nSuccessful transactions:          31\nFailed transactions:\t           0\nLongest transaction:\t        6.71\nShortest transaction:\t        0.05\n\u0060\u0060\u0060\n\n所有的请求都成功了，但是性能很差，因为 v2 版本设置了 3 秒的超时时间。\n\n我们启用下断路器。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n重新测试一下。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.16 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.14 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.29 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.11 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.39 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.44 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.44 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.40 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.47 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.42 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.57 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.52 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.65 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.04 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     4.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.01 secs:      75 bytes ==\u003e GET  \/\n\nTransactions:\t\t          19 hits\nAvailability:\t\t       47.50 %\nElapsed time:\t\t        4.16 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        0.72 secs\nTransaction rate:\t        4.57 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t        3.31\nSuccessful transactions:          19\nFailed transactions:\t          21\nLongest transaction:\t        4.15\nShortest transaction:\t        0.01\n\u0060\u0060\u0060\n\n我们可以看到在启用了断路器后各项性能都有提高。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Pool Ejection\n\n所谓的 Pool Ejection 就是当某些实例出现错误（如返回 5xx 错误码）临时将该实例弹出一段时间后（窗口期，可配置），然后再将其加入到负载均衡池中。我们的例子中配置的窗口期是 15 秒。\n\n将 v1 和 v2 的流量均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n增加 v2 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=2 -n istio-tutorial\nkubectl get pods -w\n\u0060\u0060\u0060\n\n等待所有的 Pod 的状态都启动完成。\n\n现在到 v2 的容器中操作。\n\n\u0060\u0060\u0060bash\n$ kubectl exec recommendation-v2-785465d9cd-225ms -c recommendation \/bin\/bash\n$ curl localhost:8080\/misbehave\nFollowing requests to \u0027\/\u0027 will return a 503\n\u0060\u0060\u0060\n\n增加 Pool Ejection 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10505\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2407\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10506\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2408\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10507\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10508\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10509\ncustomer =\u003e 503 preference =\u003e 503 recommendation misbehavior from \u0027785465d9cd-ldc6j\u0027\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2409\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2410\n\u0060\u0060\u0060\n\n我们看到窗口期生效了，当出现 503 错误后至少 15 秒后才会出现第二次。\n\n即使有了负载均衡池弹出策略对于系统的弹性来说依然还不够，如果你的服务有多个可用实例，可以将**断路器**、**重试**、**Pool Ejection** 等策略组合起来使用。\n\n例如在以上的 Pool Ejection 的基础上增加重试策略。\n\n\u0060\u0060\u0060bash\nistioctl replace -f istiofiles\/route-rule-recommendation-v1_and_v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务就看不到 503 错误了。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=1 -n istio-tutorial\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Egress\n\nEgress 是用来配置 Istio Service mesh 中的服务对外部服务的访问策略。\n\n具体配置请参考 [控制 Egress 流量](http:\/\/istio.doczh.cn\/docs\/tasks\/traffic-management\/egress.html)。\n\n以下示例还有问题，无法正常工作。\n\n构建示例镜像 egresshttpbin。\n\n\u0060\u0060\u0060bash\ncd egress\/egresshttpbin\/\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egresshttpbin:v1 .\ndocker push jimmysong\/istio-tutorial-egresshttpbin:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egresshttpbin\/src\/main\/kubernetes\/Deployment.yml) -n istio-toturial\nkubectl create -f egress\/egresshttpbin\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n为了在 kubernetes 集群外部访问到该服务，修改增加 ingress 配置并修改本地的\u0060\/etc\/hosts\u0060 文件，我们在前面已经完成了，此处不再赘述。\n\n构建示例镜像 egressgithub。\n\n\u0060\u0060\u0060bash\ncd egress\/egressgithub\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egressgithub:v1 .\ndocker push jimmysong\/istio-tutorial-egressgithub:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egressgithub\/src\/main\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl create -f egress\/egressgithub\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_httpbin.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egresshttpbin 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egresshttpbin,version=v1) -c egresshttpbin \/bin\/bash\n\ncurl localhost:8080\n\ncurl httpbin.org\/user-agent\n\ncurl httpbin.org\/headers\n\nexit\n\u0060\u0060\u0060\n\n增加对 [jimmysong.io](https:\/\/jimmysong.io) 的 egress 配置。\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | istioctl create -f -\napiVersion: config.istio.io\/v1alpha2\nkind: EgressRule\nmetadata:\n  name: jimmysong-egress-rule\n  namespace: istio-tutorial\nspec:\n  destination:\n    service: jimmysong.io\n  ports:\n    - port: 443\n      protocol: https\nEOF\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_github.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egressgithub 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egressgithub,version=v1) -c egressgithub \/bin\/bash\n\ncurl http:\/\/jimmysong:443\n\nexit\n\u0060\u0060\u0060\n\n清理环境。\n\n\u0060\u0060\u0060bash\nistioctl delete egressrule httpbin-egress-rule jimmysong-egress-rule github-egress-rule -n istio-tutorial\n\u0060\u0060\u0060\n\n## 参考\n\n- https:\/\/github.com\/redhat-developer-demos\/istio-tutorial\n- [Book - Introducing Istio Service Mesh for Microservices](https:\/\/developers.redhat.com\/books\/introducing-istio-service-mesh-microservices\/)\n', '\/blog\/istio-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Istio 管理 Java 微服务的案例教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-community-tips/">Istio 社区介绍与社区参与注意事项</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 社区介绍与社区参与注意事项', '本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。', '\n本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。\n\n### 工作组\n\n绝大多数复杂的开源项目都是以工作组的方式组织的，要想为 Istio 社区做贡献可以加入到以下的工作组（Working Group）：\n\n- [API Management](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#api-management)\n- [Config](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#config)\n- [Environments](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#environments)\n- [Networking](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#networking)\n- [Performance \u0026 Scalability](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#performance-and-scalability)\n- [Policies \u0026 Telemetry](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#policies-and-telemetry)\n- [Security](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#security)\n- [Test \u0026 Release](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#test-and-release)\n\n### 代码规范\n\nIstio 的代码规范沿用 [CNCF 社区的代码规范](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct.md)。\n\n### 开发指南\n\n进行 Istio 开发之前需要做下面几件事情：\n\n- 配置基础环境，如 Kubernetes\n- 配置代码库、下载依赖和测试\n- 配置 CircleCI 集成环境\n- 编写参考文档\n- Git workflow 配置\n\n详见 [Dev Guide wiki](https:\/\/github.com\/istio\/istio\/wiki\/Dev-Guide)。\n\n### 设计文档\n\n所有的设计文档都保存在 [Google Drive](https:\/\/drive.google.com\/drive\/u\/0\/folders\/0AIS5p3eW9BCtUk9PVA) 中，其中包括以下资源：\n\n- Technical Oversight Committee：ToC 管理的文档\n- Misc：一些杂项\n- Working Groups：最重要的部分，各个工作组相关的设计文档\n- Presentations：Istio 相关的演讲幻灯片，从这些文稿中可以快速了解 Istio\n- Logo：Istio logo\n- Eng：社区相关的维护文档\n\n### 社区角色划分\n\n根据对开发者和要求和贡献程度的不同，Istio 社区中包含以下角色：\n\n- [Collaborator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#collaborator)：非正式贡献者，偶尔贡献，任何人都可以成为该角色\n- [Member](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#member)：正式贡献者，经常贡献，必须有 2 个已有的 member 提名\n- [Approver](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#approver)：老手，可以批准 member 的贡献\n- [Lead](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#lead)：管理功能、项目和提议，必须由 [ToC](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUP-PROCESSES.md) 提名\n- [Administrator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#administrator)：管理员，管理和控制权限，必须由 ToC 提名\n- [Vendor](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#vendor)：贡献 Istio 项目的扩展\n\n详见 [Istio Community Roles](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md)。\n\n### 各种功能的状态\n\nIstio 中的所有 feature 根据**是否生产可用**、**API 兼容性**、**性能**、**维护策略**分为三种状态：\n\n- Alpha：仅仅可以作为 demo，无法生产上使用，也没有性能保证，随时都可能不维护\n- Beta：可以在生产上使用了，也有版本化的 API 但是无法保证性能，保证三个月的维护\n- Stable：可以上生产而且还能保证性能，API 向后兼容，保证一年的维护\n\nIstio 的 feature 分为四大类：\n\n- 流量管理：各种协议的支持、路由规则配置、Ingress TLS 等\n- 可观测性：监控、日志、分布式追踪、服务依赖拓扑\n- 安全性：各种 checker 和安全性配置\n- Core：核心功能\n\n功能划分与各种功能的状态详情请见：\u003chttps:\/\/istio.io\/latest\/about\/feature-stages\/\u003e\n\n### 云原生社区 Istio 讨论组\n\n[云原生社区](https:\/\/cloudnative.to)专门成立里 Istio SIG（微信讨论群），将原来 ServiceMesher 中关注 Istio 的人群专门集中到一个讨论组中，其中包含了百度、阿里巴巴、腾讯、网易、Tetrate、Intel、字节跳动等公司的服务网格专家及众多的终端用户，欢迎大家[申请加入群聊](https:\/\/i.cloudnative.to\/istio)。\n', '\/blog\/istio-community-tips\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-a-service-mesh/">什么是 Service Mesh（服务网格）？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/09/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('什么是 Service Mesh（服务网格）？', '本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。', '\nService Mesh 又译作“服务网格”，作为服务间通信的基础设施层。Buoyant 公司的 CEO Willian Morgan 在他的这篇文章 WHAT’S A Service Mesh? AND WHY DO I NEED ONE? 中解释了什么是 Service Mesh，为什么云原生应用需要 Service Mesh。\n\n下面是 [Willian Morgan](https:\/\/twitter.com\/wm) 对 Service Mesh 的解释。\n\n\u003e A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\n翻译成中文是：\n\n\u003e 服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。\n\n## Service Mesh 的特点\n\nService Mesh 有如下几个特点：\n\n- 应用程序间通信的中间层\n- 轻量级网络代理\n- 应用程序无感知\n- 解耦应用程序的重试\/超时、监控、追踪和服务发现\n\n目前两款流行的 Service Mesh 开源软件 [Istio](https:\/\/istio.io) 和 [Linkerd](https:\/\/linkerd.io) 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 中的项目。\n\n## 理解 Service Mesh\n\n如果用一句话来解释什么是 Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP\/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP\/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原本通过服务框架实现的事情，比如 Spring Cloud、Netflix OSS 和其他中间件，现在只要交给 Service Mesh 就可以了。\n\n[Phil Calçado](http:\/\/philcalcado.com\/) 在他的这篇博客 [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) 中详细解释了 Service Mesh 的来龙去脉：\n\n1. 从最原始的主机之间直接使用网线相连\n2. 网络层的出现\n3. 集成到应用程序内部的控制流\n4. 分解到应用程序外部的控制流\n5. 应用程序的中集成服务发现和断路器\n6. 出现了专门用于服务发现和断路器的软件包\/库，如 [Twitter 的 Finagle](https:\/\/finagle.github.io\/) 和 [Facebook  的 Proxygen](https:\/\/code.facebook.com\/posts\/1503205539947302)，这时候还是集成在应用程序内部\n7. 出现了专门用于服务发现和断路器的开源软件，如 [Netflix OSS](http:\/\/netflix.github.io\/)、Airbnb 的 [synapse](https:\/\/github.com\/airbnb\/synapse) 和 [nerve](https:\/\/github.com\/airbnb\/nerve)\n8. 最后作为微服务的中间层 Service Mesh 出现\n\nService Mesh 的架构如下图所示：\n\n![Service Mesh 架构图](service-mesh-arch.png)\n\n图片来自：[Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n\nService Mesh 作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 Service mesh 中实现。\n\n## Service Mesh 如何工作？\n\n下面以 Istio 为例讲解 Service Mesh 如何工作，后续文章将会详解 Istio 如何在 Kubernetes 中工作。\n\n1. Sidecar（Istio 中使用 [Envoy](https:\/\/envoyproxy.io) 作为 sidecar 代理）将服务请求路由到目的地址，根据请求中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。这些配置是由服务网格的控制平面推送给各个 sidecar 的，\n2. 当 sidecar 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。\n3. Sidecar 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。\n4. Sidecar 将请求发送给该实例，同时记录响应类型和延迟数据。\n5. 如果该实例挂了、不响应了或者进程不工作了，sidecar 会将把请求发送到其他实例上重试。\n6. 如果该实例持续返回 error，sidecar 会将该实例从负载均衡池中移除，稍后再周期性得重试。\n7. 如果请求的截止时间已过，sidecar 主动标记该请求为失败，而不是再次尝试添加负载。\n8. SIdecar 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。\n\n## 为何使用 Service Mesh？\n\nService Mesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。\n\n在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 twitter 开发的 [Finagle](https:\/\/twitter.github.io\/finagle\/)、Netflix 开发的 [Hystrix](https:\/\/github.com\/Netflix\/Hystrix) 和 Google 的 Stubby 这样的“胖客户端”库，这些就是早期的 Service Mesh，但是它们都仅适用于特定的环境和特定的开发语言，并不能作为平台级的 Service Mesh 支持。\n\n在 Cloud Native 架构下，容器的使用赋予了异构应用程序更多的可能性，Kubernetes 增强了应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情，进而专注于程序开发，赋予开发者更多的创造性。\n\n## 参考\n\n- What\u0027s a Service Mesh? And why do I need one?\n- [So what even is a Service Mesh? Hot take on Istio and Linkerd](http:\/\/redmonk.com\/jgovernor\/2017\/05\/31\/so-what-even-is-a-service-mesh-hot-take-on-istio-and-linkerd)\n- [linkerd: A Service Mesh for AWS ECS](https:\/\/medium.com\/attest-engineering\/linkerd-a-service-mesh-for-aws-ecs-937f201f847a)\n- [Introducing Istio: A robust Service Mesh for microservices](https:\/\/istio.io\/blog\/istio-service-mesh-for-microservices.html)\n- [Application Network Functions With ESBs, API Management, and Now.. Service Mesh?](http:\/\/blog.christianposta.com\/microservices\/application-network-functions-with-esbs-api-management-and-now-service-mesh\/)\n- [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n- [Envoy 官方文档](https:\/\/envoyproxy.io)\n- [Istio 官方文档](https:\/\/istio.io\/)\n\n', '\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/istio/page/11/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/9/" class="page-link">
             9
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/10/" class="page-link">
             10
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/tags/istio/page/11/" class="page-link">
             11
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/istio/page/12/" class="page-link">
             12
           </a>
         </li>
       
     
     
     
     
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(83)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-ext-proc-guide/">深入解析 Envoy 外部处理过滤器（ext_proc）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
