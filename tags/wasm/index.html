<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Wasm - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/wasm/" />
  <meta property="og:title" content="Wasm | Jimmy Song" />
  <meta property="twitter:title" content="Wasm | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/wasm/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Wasm
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/beyond-istio-oss/">Beyond Istio OSS —— Istio 服务网格的现状与未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/07/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Beyond Istio OSS —— Istio 服务网格的现状与未来', '本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。', '\n{{\u003ccallout note 关于本文\u003e}}\n本文根据笔者在 GIAC 深圳 2022 年大会上的的演讲[《Beyond Istio OSS —— Istio 的现状及未来》](https:\/\/giac.msup.com.cn\/2022sz\/course?id=16093)整理而成，演讲幻灯片见 [腾讯文档](https:\/\/docs.qq.com\/pdf\/DRWxETHNDZmRsS0l5)。\n{{\u003c\/callout\u003e}}\n\n本文回顾了 Istio 开源近五年来的发展，并展望了 Istio 服务网格的未来方向。本文的主要观点如下：\n\n- 因为 Kubernetes、微服务、DevOps 及云原生架构的流行，导致服务网格技术的兴起；\n- Kubernetes 和可编程代理，为 Istio 的出现打下了坚实的基础；\n- 虽然 eBPF 可以加速 Istio 中的透明流量劫持，但无法取代服务网格中的 sidecar；\n- Istio 的未来在于构建基于混合云的零信任网络；\n\n## Istio 诞生的前夜{#the-dawn-of-istio}\n\n2013 年起，随着移动互联网的爆发，企业对应用迭代的效率要求更高，应用程序架构开始从单体转向微服务，DevOps 也开始变得流行。同年随着 Docker 的开源，解决了应用封装和隔离的问题，使得应用在编排系统中调度变得更容易。2014 年 Kubernetes、Spring Boot 开源，Spring 框架开发微服务应用开始流行，在接下来的几年间大批的 RPC 中间件开源项目出现，如 Google 在 2016 年发布 gRPC 1.0，蚂蚁在 2018 年开源 [SOFAStack](https:\/\/www.sofastack.tech\/) 等，微服务框架百花齐放。为了节约成本，增加开发效率，使应用更具弹性，越来越多的企业正在迁移上云，但这不仅仅是将应用搬到云上那么简单，为了更高效地利用云计算，一套「云原生」方法和理念也呼之欲出。\n\n## Istio 开源时间线{#istio-open-time-line}\n\nIstio 开源发展时间线如下图所示。\n\n![Istio 开源发展时间线示意图](istio-history.svg)\n\n下面我们来简单回顾下 Istio 开源大事件：\n\n- 2016 年 9 月：因为 Envoy 是 Istio 中的重要组成，Istio 的开源时间线应该有 Envoy 一部分。起初 Envoy 在 Lyft 内部仅作为边缘代理，开源前已在 Lyft 内部得到大规模生产验证并受到了 Google 工程师的注意 [^1]，那时候 Google 正打算推出一个服务网格的开源项目。2017 年，Lyft 将 Envoy 捐献给了 [CNCF](https:\/\/cncf.io)。\n- 2017 年 5 月：Istio 由 Google、IBM 和 Lyft 联合宣布开源 [^2]。一开始就使用了微服务架构，确定了数据平面和控制平面的组成以及 Sidecar 模式。\n- 2018 年 3 月：Kubernetes 顺利的成为从 CNCF 中第一个毕业的项目，变得越来越「无聊」，基础 API 已经定型，CNCF 正式将服务网格（Service Mesh）写入到了云原生的第二版定义 [^3] 中。笔者当前就职的公司 [Tetrate](https:\/\/tetrate.io)，也是在那时由 Google Istio 初创团队创业成立的。服务网格在中国开始爆发，ServiceMesher 社区也在蚂蚁集团的支持下成立，在中国布道服务网格技术。\n- 2018 年 7 月：Istio 1.0 发布，号称「生产可用」，Istio 团队重组。\n- 2020 年 3 月：Istio 1.5 发布，架构回归单体，发布周期确定，每三个月发布一个大版本，API 趋于稳定。\n- 2020 年至今：Istio 的发展主要着重于 Day 2 Operation [^4]、性能优化和扩展性发面，多个围绕 Istio 生态的开源项目开始出现，例如 [Slime](https:\/\/github.com\/slime-io\/slime\/)、[Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki)、[Merbridge](https:\/\/github.com\/merbridge\/merbridge)。\n\n## 为什么 Istio 会在 Kubernetes 之后出现？{#why-istio-born-after-kubernetes}\n\n微服务和容器化之后，异构语言使用的增加，服务的数量激增，容器的生命周期变短是导致服务网格出现的根本原因。\n\n我们先来看下服务从部署在 Kubernetes 到 Istio 中架构的变迁，然后再探讨架构演进过程中 Istio 的需求，下文假定读者已了解 [Kubernetes](\/book\/kubernetes-handbook\/architecture\/) 和 [Istio 的架构](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/architecture\/)。\n\n![Kubernetes 到 Istio 的架构改变示意图](kubernetes-to-istio.svg)\n\n从 Kubernetes 到 Istio，概括的讲应用的部署架构有如下特点：\n\n- Kubernetes 管理应用的生命周期，具体来说，就是应用的部署和管理（扩缩容、自动恢复、发布策略）；\n- 基于 Kubernetes 的自动 sidecar 注入，实现了透明流量拦截。先通过 sidecar 代理拦截到微服务间流量，再通过控制平面配置管理微服务的行为。如今服务网格的部署模式也迎来了新的挑战，sidecar 已经不是 Istio 服务网格所必须的，基于 gRPC 的无代理的服务网格 [^5] 也在测试中。\n\n- 服务网格将流量管理从 Kubernetes 中解耦，服务网格内部的流量无须 \u0060kube-proxy\u0060 组件的支持，通过类似于微服务应用层的抽象，管理服务间的流量，实现安全性和可观测性功能。\n- 控制平面通过 xDS 协议发放代理配置给数据平面，已实现 xDS 的代理有 [Envoy](https:\/\/envoyproxy.io) 和蚂蚁开源的 [MOSN](https:\/\/mosn.io)。\n\n- Kubernetes 集群外部的客户端访问集群内部服务时，原先是通过 Kubernetes [Ingress](\/book\/kubernetes-handbook\/service-discovery\/ingress\/)，在有了 Istio 之后，会通过 Gateway 来访问 [^6]。\n\n\u003e *Kubernetes 容器编排与可编程代理 Envoy 为 Istio 的出现打下了坚实的基础。*\n\n从上面 Kubernetes 到 Istio 的架构的转变的描述中，我们可以看到为了让开发者最小成本地管理服务间的流量，Istio 需要解决三个问题：\n\n1. **透明劫持应用间的流量**：Istio 开源最初的目标是成为网络基础设施，就像水和电人类的基础设施一样，我们使用水电不需要关心如何取水和发电，只需要打开水龙头，按下开关即可。透明流量劫持对于开发者来说，就像使用水和电，不需要修改应用程序就可以快速使用 Istio 带来的流量管理能力；\n1. **代理集群的运维**：如何为每个应用注入一个代理，同时高效地管理这些分布式的 sidecar 代理；\n1. **可编程代理**：代理可以通过 API 动态配置，还要有出色的性能与可扩展性；\n\n以上三个条件对于 Istio 服务网格来说缺一不可，而且，从中我们可以看到，这些要求基本都是对于 sidecar 代理的要求，这个代理的选择将直接影响该项目的走向与成败。为了解决以上三个问题，Istio 选择了 Kubernetes 容器编排和可编程代理 Envoy。\n\n### 透明流量劫持{#traffic-intercept}\n\n如果你使用的是如 gRPC 这类中间件开发微服务，在程序中集成 SDK 后，SDK 中的拦截器会自动为你拦截流量，如下图所示。\n\n![gRPC 的拦截器示意图](grpc.svg)\n\n如何让 Kubernetes  pod 中的流量都通过代理呢？答案是在每个应用程序 pod 中注入一个代理，与应用共享网络空间，再通过修改 pod 内的流量路径，让所有进出 pod 的流量都经过 sidecar，其架构如下图所示。\n\n![Istio 中的透明流量劫持示意图](istio-route-iptables.svg)\n\n从图中我们可以看到其中有一套非常复杂的 iptables 流量劫持逻辑（详见 [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](\/blog\/sidecar-injection-iptables-and-traffic-routing\/)），使用 iptables 的好处是适用于任何 Linux 操作系统。但是这也带来了一些副作用：\n\n1. Istio 网格中所有的服务都需要在进出 pod 时都增加了一个网络跳跃点（hop），虽然每次 hop 可能只有两三毫秒，但是随着网格中服务和服务间的依赖增加，这种延迟可能会显著增加，对于那种追求低延迟的服务可能就不适用于服务网格了；\n2. 因为 Istio 向数据平面中注入了大量的 sidecar，尤其是当服务数量增大时，控制平面需要下发更多的 Envoy 代理配置到数据平面，这样会使数据平面占用大量的系统内存和网络资源；\n\n针对这两个问题，如何优化服务网格呢？\n\n1. 使用 proxyless 模式：取消 sidecar 代理，重新回到 SDK；\n2. 优化数据平面：减少下发到数据平面的配置的频率和大小；\n3. eBPF：使用 eBPF 优化网络劫持；\n\n本文将在后面[性能优化](#performance-optimizing)一节讲解这些细节。\n\n### Sidecar 运维管理{#sidecar-management}\n\nIstio 是在 Kubernetes 的基础上构建的，它可以利用 Kubernetes 的容器编排和生命周期管理，在 Kubernetes 创建 pod 时，通过准入控制器自动向 pod 中注入 sidecar。\n\n为了解决 Sidecar 的资源消耗问题，有人为服务网格提出了有四种部署模式，如下图所示。\n\n![服务网格的四种部署模式示意图](deployment-model.svg)\n\n下表中详细对比了这四种部署方式，它们各有优劣，具体选择哪种根据实际情况而定。\n\n{{\u003ctable \u0022服务网格的四种部署模式对比\u0022\u003e}}\n| **模式**                           | **内存开销**                                                 | **安全性**                                                   | **故障域**                                                   | **运维**                                                  |\n| :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------------------------------------------------- |\n| **Sidecar 代理**                   | 因为为每个 pod 都注入一个代理，所以开销最大。                | 由于 sidecar 必须与工作负载一起部署，工作负载有可能绕过 sidecar。 | Pod 级别隔离，如果有代理出现故障，只影响到 Pod 中的工作负载。 | 可以单独升级某个工作负载的 sidecar 而不影响其他工作负载。 |\n| **节点共享代理**                   | 每个节点上只有一个代理，为该节点上的所有工作负载所共享，开销小。 | 对加密内容和私钥的管理存在安全隐患。                         | 节点级别隔离，如果共享代理升级时出现版本冲突、配置冲突或扩展不兼容等问题，则可能会影响该节点上的所有工作负载。 | 不需要考虑注入 Sidecar 的问题。                           |\n| **Service Account \/ 节点共享代理** | 服务账户 \/ 身份下的所有工作负载都使用共享代理，开销小。      | 工作负载和代理之间的连接的认证及安全性无法保障。             | 节点和服务账号之间级别隔离，故障同“节点共享代理”。          | 同“节点共享代理”。                                       |\n| **带有微代理的共享远程代理**       | 因为为每个 pod 都注入一个微代理，开销比较大。                | 微代理专门处理 mTLS，不负责 L7 路由，可以保障安全性。        | 当需要应用 7 层策略时，工作负载实例的流量会被重定向到 L7 代理上，若不需要，则可以直接绕过。该 L7 代理可以采用共享节点代理、每个服务账户代理，或者远程代理的方式运行。 | 同“Sidecar 代理”。                                       |\n\n{{\u003c\/table\u003e}}\n\n### 可编程代理{#programmable-proxy}\n\nFlomesh 的张晓辉曾在 [为什么需要可编程代理](https:\/\/cloudnative.to\/blog\/what-and-why-programmable-proxy\/) 博客中详细说明了代理软件的发展演化过程，我下面将引用他的一些观点，说明可编程代理 Envoy 在 Istio 中的关键作用。\n\n下图展示了代理从配置到可编程模式的演化过程，及每个阶段中的代表性代理软件。\n\n![代理软件的演化示意图](proxy-evolution.svg)\n\n整个代理演化过程都是随着应用从本地和单体，越来越走向大规模和分布式。下面我将简要概括代理软件的发展过程：\n\n- **配置文件时代**：几乎所有软件都有配置文件，代理软件因为其相对复杂的功能，更离不开配置文件。该阶段的代理主要使用 C 语言开发，包括其扩展模块，突出的代理本身的能力。这也是我们使用代理最原始最基础的形式，这些代理包括 Nginx、Apache HTTP Server、[Squid](http:\/\/www.squid-cache.org\/) 等；\n- **配置语言时代**：这个时代的代理，更具扩展性和灵活性，比如动态数据获取和配套的逻辑判断。代表性代理包括扩 [Varnish](https:\/\/varnish-cache.org\/) 和 HAProxy；\n- **脚本语言时代**：从脚本语言的引入开始，代理软件才真正走向的可编程，我们可以更方便的使用脚本在代理中增加动态逻辑，增加了开发效率。代表性的代理是 Nginx 及其支持的脚本语言；\n- **集群时代**：随着云计算的普及，大规模部署和动态配置 API 成了代理所必需的能力，而且随着网络流量的增加，大规模代理集群也应运而生。这个时代的代表性代理有 Envoy、Kong 等；\n- **云原生时代**：多租户、弹性、异构混合云、多集群、安全和可观测，这些都是云原生时代对代理所提出的更高要求，代表性软件有 Istio、Linkerd、[Pypi](https:\/\/flomesh.io\/)，它们都为代理构建了控制平面。\n\n## 这些都是服务网格吗？{#are-they-service-mesh}\n\n现在我将列举一些流行的服务网格开源项目，让我们一起探索服务网格的发展规律和本质。下表对比了当前流行的服务网格开源项目 [^7]。\n\n{{\u003ctable 服务网格开源项目对比表\u003e}}\n\n| 对比项     | Istio                                                    | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)             |\n| :--------- | :------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | ----------------------------------- |\n| 当前版本   | 1.14                                                     | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0                                 |\n| 许可证     | Apache License 2.0                                       | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                  |\n| 发起者     | Google、IBM、Lyft                                        | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                           |\n| 服务代理   | Envoy，支持 gRPC 的 proxyless 模式                       | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | 默认为 [Envoy](https:\/\/www.envoyproxy.io\/)，可替换           | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/) |\n| 入口控制器 | Envoy，自定义的 Ingress，支持 Kubernetes  Gateway API    | 无内置                                                      | Envoy，支持 Kubernetes Gateway API                           | 无内置                                                       | Kong                                | 支持 Contour、Nginx，兼容其他       |\n| 治理       | Istio Community 和 Open Usage Commons，已提议捐献给 CNCF | CNCF                                                        | 查看 [贡献指南](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | 查看 [贡献指南](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                |\n\n{{\u003c \/table \u003e}}\n\n上表中列出的都是服务网格，下面再简单评论一下这些项目：\n\n- [Istio](https:\/\/istio.io)：目前最流行的服务网格项目之一，在中国几乎成为了服务网格的代名词；\n- [Linkerd](https:\/\/linkerd.io)：最早出现的服务网格，「Service Mesh」概念提出者，第一个进入 CNCF 的服务网格项目，使用自研的 Rust 语言编写轻量级 sidecar 代理；\n- [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)：由 Traefik 推出的服务网格项目，使用 Treafik proxy 作为 sidecar，支持 SMI（接下来会提到），它的特点是对应用的无侵入性，不会在 pod 中注入 sidecar；\n- [Kuma](https:\/\/kuma.io\/)：由 Kong 推出的服务网格项目，使用 Envoy 作为 Sidecar 代理，特色是使用 Kong 自家的网关作为入口网关；\n- [Consul Connect](https:\/\/www.consul.io\/docs\/connect)：Consul 服务网格，使用 Envoy 作为 sidecar 代理；\n- [Open Service Mesh](https:\/\/openservicemesh.io\/)：由微软开源的服务网格，使用 Envoy 作为 sidecar，兼容 SMI（同样是微软提出）；\n\n另外还有几个项目，也服务网格领域也经常被提及，但它们都不是服务网格：\n\n- [Envoy](https:\/\/envoyproxy.io)：Envoy 本身只是代理，也经常被作为其他基于 Envoy 的服务网格的 sidecar，也经常被用来构建 API Gateway；\n- [Service Mesh Performance（SMP）](https:\/\/smp-spec.io\/)：标准化了服务网格值的指标，通过捕获基础设施容量、服务网格配置和工作负载元数据的细节来描述任何部署的性能；\n- [Service Mesh Interface（SMI）](https:\/\/smi-spec.io\/)：它不是服务网格，而只是一套服务网格实现标准，与 OAM、SPIFFE、CNI、CSI 等类似都是定义接口标准，具体实现就不一而足了。目前 Traefik Mesh 和 Open Service Mesh 声明支持该规范；\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/)：有必要提一下这个项目，因为经常有人把它错认为是一个服务网格。实际上，它面向的是三层网络，使用它可以在不更换 CNI 插件的前提下，连接多云\/混合云。它并不是我们所定义的「服务网格」，而是服务网格的一个有力补充（虽然名字里带有服务网格比较有迷惑性）。\n\n纵观以上项目，我们可以看出大部分服务网格项目的发起者都是根据代理起家，然后做控制平面。而且 Istio、Consul Connect、Open Service Mesh、Kuma 都是使用 Envoy 作为 sidecar 代理。只有 Linkerd 和 Traefik Mesh 推出了自己的代理。而所有的服务网格项目都支持 sidecar 模式。除了 Istio、Linkerd、Consul Connect 已应用于生产上，其他服务网格项目还没有看到被大规模在生产上使用。\n\n## Istio 的性能优化{#performance-optimizing}\n\n在 Istio 1.5 版本确定了稳定的架构之后，社区的主要精力在于优化 Istio 的性能。下面我将向你详细介绍 Istio 中的性能优化方法，包括：\n\n- 采用 Proxyless 模式；\n- 使用 eBPF 优化流量劫持；\n- 控制平面性能优化；\n- 数据平面性能优化；\n\n### Proxyless 模式{#proxyless-pattern}\n\nProxyless 模式是 Istio 在 1.11 版本中提出的实验特性 —— [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。使用该模式可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。下图展示了 sidecar 模式与 proxyless 模式的对比图。\n\n![Sidecar 模式 vs Proxyless 模式](sidecar-to-proxyless.svg)\n\n从上图中我们可以看到，虽然 proxyless 模式不使用 proxy 进行数据平面通信，但仍然需要一个 agent（即 \u0060pilot-agent\u0060）来进行初始化和与控制平面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 \u0060istiod\u0060，在哪里可以找到用于数据平面通信的证书，向控制平面发送什么元数据。接下来，agent 作为 xDS proxy，代表应用程序与 \u0060istiod\u0060 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书，这其实与 Sidecar 模式的流程是一样的，只是将 Envoy 代理的功能内置到 SDK 中了。\n\n\u003e *服务网格的本质不是 Sidecar 模式，也不是配置中心或透明流量拦截，而是标准化的服务间通信标准。*\n\n有人说 proxyless 模式又回到了基于 SDK 开发微服务的老路，服务网格的优势丧失殆尽，那还能叫做服务网格吗 [^9]？其实这也是一种对性能的妥协 —— 如果你主要使用 gRPC 来开发微服务的话，只需要维护不同语言的 gRPC 版本，即可以通过控制平面来管理微服务了。\n\n\u003e *Envoy xDS 已经成为服务网格中服务间通信的事实标准。*\n\n### 使用 eBPF 优化流量劫持{#ebpf}\n\n在[透明流量劫持](#traffic-intercept)一节，我们可以看到一个服务间的流量在到达目的地 pod 时经过的 iptables 规则和路径，其中需要经过多条 iptables 规则，如 \u0060PREROUTING\u0060、\u0060ISTIO_INBOUND\u0060、\u0060ISTIO_IN_REDIRECT\u0060、\u0060OUTPUT\u0060、\u0060ISTIO_OUTPUT\u0060、\u0060POSTROUTING\u0060 等。假设现在有一个服务 A 想要调用非本地主机上的另一个 pod 中的服务 B，经过的网络堆栈如下图所示。\n\n![非同主机 Pod 间的服务访问路径（iptables 模式）](iptables-process.svg)\n\n从图中我们可以看到整个调用流程中经过四次 iptables，其中 Pod A 中的从 Envoy 的出站（iptables2）和 Pod B 中的从 eth0 的入站（iptables3）的 iptables 路由是无法避免的，那么剩下的两个 iptables1 和 iptables4 是否可以优化呢？让两个 socket 直接通信，不就可以缩短网络路径了吗？这就需要通过 eBPF 编程，使得：\n\n- Service A 的流量从直接发送到 Envoy 的 Inbound socket 上；\n- Pod B 中 Envoy 接收到入站流量后，已经确定流量是要发送给本地的服务，直接对接 Outbound socket 与 Service B；\n\n使用 eBPF 模式的透明流量拦截网络路径如下图所示。\n\n![非同主机 Pod 间的服务访问路径（eBPF 模式）](ebpf-diff-node.svg)\n\n如果要访问的服务 A 和服务 B 在同一个节点上，那么网络路径将更短。\n\n![同主机 Pod 间的网络访问路径（eBPF 模式）](ebpf-same-node.svg)\n\n同一个节点中的服务间访问完全绕过了 TCP\/IP 堆栈，变成了 socket 间的直接访问。\n\n{{\u003ccallout note \u0022什么是 eBPF？\u0022\u003e}}\n\n我们知道修改 Linux 内核代码很难，新特性发布到内核中需要很长的周期。eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。也就是说，有了 eBPF，你不需要直接修改内核，就可以扩展和改变内核的行为。下面我将简要的为大家介绍一下 eBPF：\n\n- eBPF 程序加载到内核中后需要通过验证器的验证才可以运行，验证器可以防止 eBPF 程序超越权限的访问，这样可以确保内核的安全；\n- eBPF 程序是附着于内核事件上的，当有进入或退出内核函数时被触发；\n- 内核空间的 eBPF 程序必须使用能够支持生成 eBPF 字节码格式的编译器的语言编写，目前你可以用 C 和 Rust 语言编写 eBPF 程序；\n- eBPF 程序对于不同的 Linux 版本存在兼容性问题；\n\n由于 eBPF 程序可以直接监听和操作 Linux 内核，具有对系统最底层的透视，就可以在流量管理、可观测性和安全发挥作用。有关 eBPF 的详细介绍请参考笔者翻译的[《什么是 eBPF》](https:\/\/jimmysong.io\/book\/what-is-ebpf\/)电子书。\n\n{{\u003c\/callout\u003e}}\n\n开源项目 [Merbridge](https:\/\/github.com\/merbridge\/merbridge) 正是利用 eBPF 缩短了透明流量劫持的路径，优化了服务网格的性能。关于 Merbridge 实现的一些细节，请参考 [Istio 博客](https:\/\/istio.io\/latest\/zh\/blog\/2022\/merbridge\/)。\n\n{{\u003ccallout warning 注意\u003e}}\n\nMerbridge 使用的 eBPF 函数需要 Linux 内核版本 ≥ 5.7。\n\n{{\u003c\/callout\u003e}}\n\n乍看上去 eBPF 似乎从更底层实现了 Istio 的功能，更大有取代 sidecar 的趋势。但是 eBPF 也存在很多局限性，导致在可以预见的未来无法取代服务网格和 Sidecar。如果取消 sidecar 转而使用每个主机一个代理的模式，会导致：\n\n1. 代理失败的爆炸半径扩大到整个节点，即一个代理失败了，代理所在节点上的所有工作负载都会受到影响；\n2. 使得安全问题更加复杂，因为一个节点上保存在太多负载的证书，一旦被攻击，会存在秘钥泄露的风险；\n3. 主机上的 Pod 之间的流量争抢问题，即节点上如果有一个工作负载消耗掉代理的所有资源，其他工作负载将无法获得流量；\n\n而且 eBPF 主要负责三\/四层流量，可以与 CNI 一起运行，但是七层流量使用 eBPF 来处理就不太合适了。\n\n\u003e *在可以预见的未来 eBPF 技术无法取代服务网格和 Sidecar。*\n\n关于 eBPF 与服务网格的关系的更详细介绍请参考博客[请暂时抛弃使用 eBPF 取代服务网格和 Sidecar 模式的幻想](\/blog\/ebpf-sidecar-and-service-mesh\/)。\n\n### 控制平面性能优化{#control-plane-perf-optimizing}\n\n以上两种优化都是针对数据平面进行的，我们再来看下控制平面的性能优化。你可以把服务网格想象成是一场演出，控制平面是总导演，数据平面是所有演员，导演不参与演出，但是负责指挥演员。如果这场演出的情节很简单，时长又很短，那要每个演员分配的戏份就会很少，排练起来就会很容易；如果是一个大型演出，演员的数量多，情节有很复杂，要想排练好这场演出，一个导演可能是不够的，他指挥不了这么多演员，因此我们需要多名副导演（扩大控制平面实例数量）；我们还需要给演员准备好台词和脚本，如果演员也可以一个镜头完成一连串的台词和场景的表演（减少都数据平面的打扰，批量推送更新），那我们的排练是不是更加高效？\n\n从上面的类比中，你应该可以找到控制平面性能优化的方向了，那就是：\n\n- 减少需要推送的配置大小；\n- 批处理代理推送；\n- 扩大控制平面规模；\n\n#### 减少需要推送的配置{#reduce-config-size}\n\n控制平面性能优化最直接的方式就是减少要向数据平面推送的代理配置大小。假设有工作负载 A，如果仅将与 A 相关的代理配置（即 A 依赖的服务）推送给 A，而不是将网格内所有服务的配置都推送给 A，这样就可以大大压缩要推送的工作负载范围及配置大小。Istio 中的 Sidecar 资源可以帮助我们实现这一点。下面是 Sidecar 配置示例：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: cn-bj\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022cn-bj\/*\u0022\n\u0060\u0060\u0060\n\n我们通过 \u0060workloadSelector\u0060 字段可以限制该 Sidecar 配置适用的工作负载范围，而 \u0060egress\u0060 字段可以确定该工作负载依赖的服务范围，这样控制平面就可以仅向服务 A 推送其依赖的服务配置，大大减低要向数据平面推送的配置大小，减少了服务网格的内存和网络消耗。\n\n#### 批处理代理配置推送{#batch-push-conf}\n\n控制平面 Istiod 向数据平面推送代理配置的过程比较复杂，下图展示了其中的流程。\n\n![Istiod 向数据平面推送代理配置的流程图](istiod-push.svg)\n\n管理员配置 Istio 网格后，Istiod 中推送代理配置的流程是这样的：\n\n1. 管理员更新 Istio 配置的事件会触发数据平面代理的配置同步；\n2. Istio 的 \u0060DiscoveryServer\u0060 组件监听到这些事件后不会立即将配置推送到数据平面，而是将这些事件添加到队列中，持续合并一段时间内的事件，这个过程叫做去抖动（debouncing），就是为了防止频繁的更新数据平面配置；\n3. 在去抖动周期过后，这些事件将被推送到队列中；\n4. Istiod 会限制同时推送的请求数量，以加快推送进度；\n5. 事件被转换成 Envoy 的配置推送到数据平面的工作负载上；\n\n从以上流程中我们可以看出，优化配置推送的关键就是步骤 2 中去抖动周期和步骤 4 中的限流设置。有这样几个环境变量可以帮助你设置控制平面的推送：\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060：指定去抖动的时间，将事件添加到推送队列中，默认为 100 毫秒；\n- \u0060PILOT_DEBOUNCE_MAX\u0060：指定允许事件去抖动的最长时间，如果在这段时间内事件没有新的变化则推送事件，默认为 10 秒；\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060：指定端点更新是否符合去抖动规则或具有优先权并立即落入推送队列，默认是开启的，关闭它后可以加速 EDS 推送；\n- \u0060PILOT_PUSH_THROTTLE\u0060：指定同时处理的推送请求，默认是 100；\n\n关于这些环境变量的默认值和具体配置请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars)。\n\n这些值究竟如何设置，可以遵循以下原则：\n\n- 如果控制平面资源空闲，为了加快配置更新的传播速度，你可以：\n  - 缩短去抖动周期，增加推送次数；\n  - 增加同时处理的推送请求数量；\n- 如果控制平面饱和，为了降低性能瓶颈，你可以：\n  - 延迟去抖动周期，减少推送次数；\n  - 增加同时处理的推送请求的数量；\n\n至于如何设置最优解，需要结合你的可观测系统来调试。\n\n#### 扩大控制平面规模{#scale-up-control-plane}\n\n如果设置去抖动批处理和 Sidecar 还无法优化控制平面性能的话，最后的选择就是扩大控制平面的规模，包括扩大单个 Istiod 实例的资源和增加 Istiod 的实例个数，究竟采用哪种扩展方式视情况而定：\n\n- 当单个 Istiod 的资源占用饱和时，优先推荐你扩大 Istiod 的实例大小，这通常是因为服务网格中有太多的资源（Istio 的自定义资源，如 VirtualService、DestinationRule 等）需要处理；\n- 如果增加 Istiod 实例的 CPU 和内存依然不起效的话，增加 Istiod 的实例个数，这样可以分散单个实例要管理的工作负载数量；\n\n### 数据平面性能优化{#data-plane-performance}\n\nApache SkyWalking 可以作为 Istio 提供可观测性工具，还可以帮助我们在进行服务动态调试和故障排除剖析服务的性能，其最新推出的 [Apache SkyWalking Rover](https:\/\/github.com\/apache\/skywalking-rover) 组件可以利用 eBPF 技术来准确定位 Istio 的关键性能问题 [^12]。在数据平面，我们可以通过以下方式来增加 Envoy 的吞吐量以优化 Istio 的性能：\n\n- 禁用 Zipkin 追踪或减少采样率\n- 简化访问日志格式\n- 禁用 Envoy 的访问日志服务（ALS）\n\n以上优化方式对 Envoy 吞吐量的影响数据请参阅 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/#introducing-skywalking-rover)。\n\n## Envoy —— 服务网格的领衔主演{#starring-envoy}\n\n我们知道服务网格是由数据平面和控制平面组成的，从上面的服务网格开源项目列表中我们可以看到，服务网格开源项目大部分都是基于 Envoy，然后开发自己的控制平面。还记得我在本文前面将服务网格比作演出吗？在这场服务网格的演出中，毫无疑问 Envoy 就是领衔主演 —— Envoy 发明的 xDS 协议，基本成为服务网格的通用 API。下面展示的是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch.svg)\n\nxDS 是 Envoy 区别于其他代理的关键，它的代码和解析流程十分复杂 [^10]，直接扩展起来也很有难度。下面展示的是 Istio 组件拓扑图，从图中我们可以看到 Istio 数据平面的 Sidecar 容器中不止有 \u0060envoy\u0060 这一个进程，还有一个 \u0060pilot-agent\u0060 进程。\n\n{{\u003cfigure title=\u0022Istio 组件拓扑图\u0022 alt=\u0022Istio 组件拓扑图\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\n\u0060pilot-agent\u0060 进程的作用如下：\n- 作为 \u0060envoy\u0060 的父进程，负责 Envoy 的生命周期管理；\n-  接收来自控制平面的推送，配置代理和证书；\n- 收集 Envoy 统计信息，汇总 sidecar 的统计数据供 Prometheus 搜集；\n- 内置本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景；\n- 对 Envoy 和 DNS 代理进行健康检查；\n\n从以上功能中我们可以看出 \u0060pilot-agent\u0060 进程主要是用于与 Istiod 交互，为 Envoy 起到指挥和辅助的作用，Istio 的核心组件是 Envoy。那么 Envoy 会不会「演而优则导」，不再配合 Istio，构建一套自己的控制平面呢？\n\n\u003e *在 Sidecar 容器中，\u0060pilot-agent\u0060 就像是 Envoy 的“Sidecar”。*\n\n{{\u003ccallout note 请读者思考一下\u003e}}\n\u0060pilot-agent\u0060 的功能能否直接内置到 Envoy 中，从而取消 \u0060pilot-agent\u0060 呢？\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 统一服务网格网关{#envoy-gateway}\n\n在 Kubernetes 中，除 Service 资源对象之外，最早用来暴露集群中服务的资源对象是 Ingress。使用 Ingress 你只需要为集群开放一个对外的访问点即可，通过 HTTP Hosts 和 \u0060path\u0060 来路由流量到具体的服务。相对于直接在 \u0060service\u0060 资源上暴露服务来说，可以减少集群的网络访问点（PEP）[^11] ，降低集群被网络攻击的风险。使用 Ingress 访问集群内的服务流程如下图所示。\n\n![Kubernetes Ingress 流量访问流程图](ingress.svg)\n\n在 Kubernetes 之前，API Gateway 软件就已经被广泛用作边缘路由了，在引用 Istio 时又增加了 Istio 自定义的 Gateway 资源，使得访问 Istio 服务网格中的资源又多了一种选择，如下图所示。\n\n![访问 Istio 网格中的服务的方式](access-cluster.svg)\n\n现在，要想暴露单个 Istio 网格中的服务，\u0060NodePort\u0060、\u0060LoadBalance\u0060、Istio 自定义 Gateway、Kubernetes Ingress 和 API Gateway 软件，如何选择？如果是多集群服务网格，客户端如何访问网格内的服务？我们的服务网格领衔主演 Envoy 已经在这方面做足了功夫，被以多种形式使用：\n\n- Sidecar Proxy：正如在[前文中](#are-they-service-mesh)提到的，Istio、Kuma、Consul Connect 都使用了 Envoy 作为 sidecar 代理；\n- Kubernetes Ingress Controller\/API Gateway：[Contour](https:\/\/github.com\/projectcontour\/contour)、[Emissary](https:\/\/github.com\/emissary-ingress\/emissary)、[Hango](https:\/\/github.com\/hango-io\/hango-gateway)、[Gloo](https:\/\/github.com\/solo-io\/gloo) 等；\n\n这些项目利用 Envoy 来实现服务网格和 API 网关，其中有很多功能重叠，同时又有很多专有功能，或者缺乏社区多样性，这种现状由于 Envoy 社区没有提供控制平面实现而导致的。为了改变现状，Envoy 社区发起了 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目，该项目旨在结合现有的基于 Envoy 的 API Gateway 相关项目的经验 [^13]，利用带有一些 Envoy 特定扩展的  [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 降低 Envoy 用户使用网关的门槛。因为 Envoy Gateway 仍然通过 xDS 下发配置给 Envoy 代理，因此你还可以用它来管理支持 xDS 的网关，如 Istio Gateway。\n\n我们现在所见的网关基本都是在单集群中作为入口网关，对于多集群和多网格就无能为力了。为了应对多集群，我们需要在 Istio 之上再添加一层网关，和一个全局的控制平面以在多集群间路由流量，如下图所示。\n\n![多集群多网格的两级网关示意图](t2-gateway.svg)\n\n{{\u003ccallout note 关于两级网关的简要介绍\u003e}}\n- 一级网关（下文简称 T1）位于应用边缘，用于多集群环境。同一应用会同时托管在不同的集群上，T1 网关将对该应用的请求流量在这些集群之间路由。\n- 二级网关（下文简称 T2）位于一个的集群边缘，用于将流量路由到该集群内由服务网格管理的服务。\n{{\u003c\/callout\u003e}}\n\n通过在 Istio 控制平面以外增加一层全局控制平面和 API，来实现多集群服务网格管理。将 T1 网关部署为集群，可以防止单点故障。想要了解关于两级网关的更多内容，请参考[通过两级网关设计来路由服务网格流量](https:\/\/cloudnative.to\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/)。\n\nT1 网关的配置如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\n该配置将 \u0060servicea.example.com\u0060 通过 T1 网关暴露到网格外，并将网格外访问该服务的流量的 \u006075%\u0060 转发到 \u0060cluster1\u0060，\u006025%\u0060 的流量转发到 \u0060cluster2\u0060，另外为了应对多集群中的流量、服务和安全配置，Tetrate 旗舰产品 Tetrate Service Bridge 中还增加了 一系列 Group API，详见 TSB 文档。\n\n## Istio 开源生态{#ecosystem}\n\nIstio 开源在至今已经五年多了，近两年来出现了很多基于 Istio 的开源项目，其中比较代表性的有：\n\n- 网易开源的 Slime\n- 腾讯开源的 Aeraki\n- Istio 官方对 Wasm 插件的支持\n\n它们的出现使得 Istio 更加智能化并扩展了 Istio 的适用范围。\n\n### Slime\n\n[Slime](https:\/\/github.com\/slime-io\/slime\/) 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n我们在前文的[控制平面性能优化](#control-plane-perf-optimizing)中提到了通过「减少需要推送的配置」的方式来优化 Istio 的性能，但是 Istio 无法做到自动识别无法依赖以最优化需要推送到每个 sidecar 的代理配置，Slime 提供了 \u0060lazyload\u0060 控制器，可以帮助我们实现配置懒加载，用户无须手动配置 \u0060SidecarScope\u0060 [^15]，Istio 可以按需加载服务配置和服务发现信息。\n\n下图展示的是 Slime 作为 Istio 的管理平面更新数据平面配置的流程图。\n\n![使用 Slime 更新 Istio 数据平面配置的流程图](slime-process.svg)\n\n其中，Global Proxy 使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n数据平面配置更新的具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化，开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n2. Slime 持续监听 Slime CRD 的创建；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将代理的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n因为数据平面中的所有服务的首次调用都通过 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060 的 CRD 来维护服务调用关系以解决服务信息缺失问题，详见 [Slime 简介](\/blog\/slime-intro\/)。\n\n### Aeraki\n\n[Aeraki Mesh](https:\/\/github.com\/aeraki-mesh\/aeraki) 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目，基于 Istio 扩展其对七层协议的支持，专注于解决 Istio 中的**非 HTTP 协议**的服务治理，已于 2022 年 6 月进入 CNCF Sandbox。\n\n下图展示了 Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图。\n\n![Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图](aeraki-arch.svg)\n\n 其详细流程如下：\n\n1. Aeraki 的 X2Istio 组件对接服务注册中心，获取非 HTTP 服务的注册信息，并生成 ServiceEntry 向 Istio 中注册；\n2. Aeraki 作为 Istio 之上的管理平面，它从 Istio 中获取 ServiceEntry 配置；\n3. Aeraki 通过端口命名规判断服务的协议类型（如 \u0060tcp-metaprotocol-dubbo\u0060），然后生成 MetaProtocol Proxy Filter（兼容 EnvoyFilter）配置，同时修改 RDS 地址，将其指向 Aeraki；\n4. Istio 使用 xDS 协议将配置（LDS、CDS、EDS 等）下发给数据平面；\n5. Aeraki 根据服务注册表中的信息和用户设置生成路由规则，通过 RDS 发送给数据平面；\n\n在 Istio 中接入非 HTTP 服务的整个流程中的关键是 **MetaProtocol Proxy** 。Istio 默认支持 HTTP\/HTTP2、TCP 和 gRPC 协议，实验性支持 Mongo、MySQL 和 Redis 协议 [^14]。若要使用 Istio 路由其他协议的流量，不仅需要修改 Istio 控制平面并扩展 Envoy，这将带来巨大的工作量，而且不同协议共享通用的控制逻辑，这还会带来很多重复性工作。MetaProtocol Proxy 是在 Envoy 代码基础上的扩展，为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地\/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度。\n\n下图展示的 MetaProtocol Proxy 的架构图。\n\n![MetaProtocol Proxy 架构图](metaprotocol-proxy.svg)\n\n当我们想扩展 Istio 使其支持 Kafka、Dubbo、Thrift 等其他七层协议时，只需要实现上图中的编解码的接口（Decode 和 Encode），就可以基于 MetaProtocol 快速开发一个第三方协议插件。MetaProtocol Proxy 是在 Envoy 基础上的扩展，因此你仍然可以使用多种语言为其开发过滤器，并使用 \u0060EnvoyFilter\u0060 资源将配置下发到数据平面。\n\n### WasmPlugin API\n\n[WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 是 Istio 1.12 版本引入的 API，作为代理扩展机制，我们可以使用它将自定义和第三方的 Wasm 模块添加到数据平面中。下图中展示了如何在 Istio 中使用 WasmPlugin。\n\n![在 Istio 中使用 WasmPlugin 的流程图](wasmplugin.svg)\n\n具体步骤如下：\n\n1. 用户使用 [Proxy-Wasm SDK](https:\/\/github.com\/proxy-wasm)（目前有 AssemblyScript、C\u002b\u002b、Rust、Zig 和 Go 语言版本）来开发扩展，并构建成 OCI 镜像（如 Docker 镜像）上传到镜像仓库；\n2. 用户编写 \u0060WasmPlugin\u0060 配置并应用到 Istio；\n3. Istio 控制平面根据 \u0060WasmPlugin\u0060 配置中的工作负载选择配置，将 Wasm 模块注入到指定的 Pod 中；\n4. Sidecar 中的 \u0060pilot-agent\u0060 [^16] 从远程或本地文件中获取 Wasm 模块并将其加载到 Envoy 中运行；\n\n## 谁应该使用 Istio？{#whos-should-use-istio}\n\n好了，说了这么说，这跟你有什么关系呢？Istio 跟你的关系取决于你的角色：\n\n- 如果你是平台负责人，应用服务网格后，可能增强你的平台可观测性，具有了一个统一的平台来管理微服务，你将是直接受益者，也应该是服务网格的主要实施者；\n- 如果是应用程序开发者，也会从服务网格中收益，因为你可以更加专属于业务逻辑，而不用担心重试策略、TLS 等其他非功能性问题；\n\n下图展示了服务网格的采用路径。\n\n![服务网格的采用路径](adopt.svg)\n\n是否采用服务网格取决于你公司的技术发展阶段，应用是否实现容器化和微服务，对多语言的需求，是否需要 mTLS 以及对性能损耗的接纳度等。\n\n## 服务网格在云原生技术栈中的定位{#service-mesh-positioning}\n\n技术的发展日新月异，近两年来有一些新技术出现，似乎挑战了服务网格的地位，更有人声称可以直接取代现有经典的 sidecar 模式的服务网格 [^8]，我们不要被外界嘈杂的声音所迷惑，认清服务网格在云原生技术栈中的定位。\n\n\u003e *一味地推广某项技术而忽略它的适用场景，就是耍流氓。*\n\n下图展示的是云原生技术堆栈。\n\n![云原生技术堆栈示意图](cloud-native-stack.svg)\n\n我们可以看到，在云原生技术堆栈图中的「云基础设施」、「中间件」和「应用」层都列举了一些标志性的开源项目，这些项目构建了它们所在领域的标准：\n\n- 在云基础设施领域，Kubernetes 统一了容器编排和应用生命周期管理的标准，Operator 模式奠定了扩展 Kubernetes API 及第三方应用接入的标准；\n- 在中间件领域，服务网格承担起了云原生技术栈中的七层网络、可观测性和安全等多个方面的部分或全部责任，它运行在应用程序下层，对于应用程序来说几乎是无感知的；Dapr（分布式应用程序运行时）定义云原生中间件的能力模型，开发者可以在应用中集成 Dapr 的多语言 SDK，面向 Dapr 提供的分布式能力编程，而不用关心应用所运行的环境及对接的后端基础设施。因为在和应用程序运行在同一个 Pod 中的 Dapr 运行时（Sidecar 模式部署，其中包含各种构建块）自动帮我们对接了后端组件（Component）；\n- 在应用程序领域：OAM 旨在建立一个应用模型标准，通过组件、特征、策略和工作流来一个应用程序；\n\n下图展示了 Istio 在云原生部署中定位于七层网格管理。\n\n![Istio 在云原生架构中定位在七层网络](istio-role.svg)\n\n{{\u003ccallout note \u0022Dapr 与 Istio 是什么关系？\u0022\u003e}}\n\n在云原生技术栈中，Istio 和 Dapr 同时位于中间件层，它们之间有很多区别和联系。\n\nIstio 和 Dapr 之间的相同点：\n\n- Istio 和 Dapr 都可以使用 Sidecar 模式的部署模型；\n- 同属于中间件，同样可以管理服务间通信；\n\nIstio 和 Dapr 之间的不同点：\n- 目标不同：Istio 的目标是构建零信任网络，定义服务间通信标准，Dapr 目标是构建标准的中间件能力的 API；\n- 架构不同：Istio = Envoy \u002b 透明流量劫持 \u002b 控制平面，Dapr = 多语言 SDK \u002b 标准化 API \u002b 分布式能力组件；\n- 面向的人群不同：但是应用 Istio 对于开发者来说几乎无感知，主要需要基础设施运维团队实施，而应用 Dapr 需要开发者自主选择集成 Dapr SDK；\n\n{{\u003c\/callout\u003e}}\n\n## 服务网格的未来{#istio-future}\n\n我在前文中介绍了 Istio 的发展脉络及开源生态，接下来我将为大家介绍 Istio 服务网格的未来趋势：\n\n- 构建零信任网络\n- 成为混合云管理平台的网络基础设施\n\n\u003e *服务网格的未来在于成为零信任网络和混合云的基础设施。*\n\n这也是笔者所在的公司企业级服务网格提供商 [Tetrate](https:\/\/www.tetrate.io\/) 的努力方向，我们致力于构建一个基于零信任的适用于任意环境、任意负载的应用感知网络。下面展示的是 Tetrate 旗舰产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 的架构图。\n\n![TSB 架构图](tsb.svg)\n\nTetrate 公司是由 Istio 项目的发起人创立的，TSB 是基于开源的 Istio、Envoy 和 Apache SkyWalking 开发的。我们同时积极得贡献上游社区，并参与了旨在简化将 Envoy 网关使用的 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目的创建（上图中的 XCP 即使用 Envoy 构建的网关）。\n\n## 零信任{#zero-trust}\n\n零信任（Zero Trust）是 IstioCon 2022 里的一个重要话题，Istio 正在成为零信任网络的一个重要组成部分。\n\n{{\u003ccallout note \u0022什么是零信任？\u0022\u003e}}\n零信任（Zero Trust）是一种安全理念，而不是一种所有安全团队都要遵循的最佳实践。零信任概念的提出是为了给云原生世界带来更安全的网络。零信任是一种理论状态，即网络内的所有消费者不仅没有任何权限，而且也不具备对周围网络的感知。零信任的主要挑战是就越来越细化的授权和和对用户授权的时间限制。关于更多零信任的介绍，请阅读[这篇博客](\/blog\/what-is-zero-trust\/)。\n{{\u003c\/callout\u003e}}\n\n### 身份认证{#authn}\n\n零信任网络中最重要的是**面向身份的控制**而不是面向网络的控制。Istio 1.14 中增加了对 SPIRE 的支持，SPIRE（SPIFFE Runtime Environment，CNCF 孵化项目）是 SPIFFE（Secure Production Identity Framework For Everyone，CNCF 孵化项目）的一个实现。在 Kubernetes 中我们使用 [ServiceAccount](\/book\/kubernetes-handbook\/auth\/serviceaccount\/) 为 Pod 中的工作负载提供身份信息，其核心是基于 Token（使用 Secret 资源存储）来表示负载身份。而 Token 是 Kubernetes 集群中的资源，对于多集群及运行在非 Kubernetes 环境（例如虚拟机）中的负载，如何统一它们的身份？这就是 SPIFFE 要解决的问题。\n\nSPIFFE 的目的是基于零信任的理念，建立一个开放、统一的工作负载身份标准，这有助于建立一个零信任的全面身份化的数据中心网络。SPIFFE 的核心是通过简单 API 定义了一个生命周期短暂的加密身份文件—— SVID（SPFFE Verifiable Identity Document），用作工作负载认证时使用的身份文件（基于 X.509 证书或 JWT 令牌）。SPIRE 可以根据管理员定义的策略自动轮换 SVID 证书和秘钥，动态地提供工作负载标识，同时 Istio 可以通过 SPIRE 动态的消费这些工作负载标识。\n\n基于 Kubernetes 的 SPIRE 架构图如下所示。\n\n![SPIRE 部署在 Kubernetes 中的架构图](spire-with-kubernetes.svg)\n\nIstio 中原先是使用 Istiod 中 Citadel 服务 [^17] 负责服务网格中证书管理，通过 xDS（准确的说是 SDS API）协议将证书下发给数据平面。有了 SPIRE 之后，证书管理的工作就交给了 SPIRE Server。SPIRE 同样支持 Envoy SDS API，我们在 Istio 中启用 SPIRE 之后，进入工作负载 Pod 中的流量在被透明拦截到 Sidecar 中后，会经过一次身份认证。身份认证的目的是对比该工作负载的身份，与它所运行的环境信息（所在的节点、Pod 的 ServiceAccount 和 Namespace 等）是否一致，以防止伪造身份。请参考[如何在 Istio 中集成 SPIRE](\/blog\/how-to-integrate-spire-with-istio\/) 以了解如何在 Istio 中使用 SPIRE 做身份认证。\n\n我们可以使用 [Kubernetes Workload Registrar](https:\/\/github.com\/spiffe\/spire\/blob\/main\/support\/k8s\/k8s-workload-registrar\/README.md) 在 Kubernetes 中部署 SPIRE，它会为我们自动注册 Kubernetes 中的工作负载并生成 SVID。该注册机是 Server-Agent 架构，它在每个 Node 上部署一个 SPIRE Agent，Agent 与工作负载通过共享的 UNIX Domain Socket 通信。零信任网络中每个流量会话都需要经过身份认证，Istio 在透明流量劫持时，Sidecar 同时对流量请求进行身份认证。下图展示了在 Istio 中使用 SPIRE 进行身份认证的过程。\n\n![Istio 中基于 SPIRE 的工作负载身份认证过程示意图](workload-attestation.svg)\n\nIstio 中使用 SPIRE 进行工作负载认证的步骤如下：\n\n1. 工作负载的 sidecar 中的 \u0060pilot-agent\u0060 通过共享的 UDS 调用 SPIRE Agent 来获取 SVID 并缓存在 SPIRE Agent 中用于后续身份认证；\n2. SPIRE Agent 询问 Kubernetes（准确的说是节点上的 kubelet）获取工作负载的信息，如所在的 namespace、节点名称、服务账号等；\n3. Kubelet 把从 API 服务器中查询到的信息返回给工作负载验证器；\n4. 验证器将 kubelet 返回的结果与 SPIRE 查询得到的身份信息比对，如果相同，则将正确的 SVID 缓存返回给工作负载，如果不同则认证失败，拒绝流量请求；\n\n关于工作负载的注册和认证的详细过程请参考 [SPIRE 文档](\/book\/kubernetes-handbook\/auth\/spire\/) 。\n\n### NGAC\n\n当每个工作负载都有准确的身份之后，如何对这些身份的权限进行限制？Kubernetes 中默认使用 RBAC 来做访问控制，正如其名，这种访问控制是基于角色的，虽然使用起来比较简单，但是对于大规模集群，存在角色爆炸问题 —— 即存在太多角色，而且角色的类型不是一成不变的，难以对角色权限机型跟踪和审计。另外 RBAC 中的角色的访问权限是固定，没有规定短暂的使用权限，也没有考虑位置、时间或设备等属性。使用 RBAC 的企业很难满足复杂的访问控制要求，以满足其他组织需求的监管要求。\n\nNGAC，即下一代访问控制，采用将访问决定数据建模为 DAG（有向无环图）的方法。NGAC 可以实现系统化、策略一致的访问控制方法，以高精细度授予或拒绝用户管理能力。NGAC 由 [NIST](https:\/\/www.nist.gov\/) （美国国家标准与技术研究所）开发，目前已用于 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 中的权限管理。关于为什么选择 NGAC，而不是 ABAC 和 RBAC 的更多内容请参考博客[为什么应该选择使用 NGAC 作为权限控制模型](\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/)。\n\n## 混合云{#hybrid-cloud}\n\n在实际应用中，我们可能出于负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复以及避免厂商锁定等原因，在多种环境下部署多个 Kubernetes 集群。Kubernetes 社区提供了「集群联邦」功能可以帮助我们创建多集群架构，例如下图所示的一种常用的 Kubernetes 多集群架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。\n\n![Kubernetes 集群联邦架构](multicluster.svg)\n\n集群联邦要求 Host 集群与成员集群的之间的网络能够互通，对成员集群之间的网络连接性没有要求。Host 集群作为 API 入口，外界所有对 Host 集群的资源请求会转发到成员集群中。Host 集群中部署有集群联邦的控制平面，其中的「Push Reconciler」会将联邦中的身份、角色及角色绑定传播到所有的成员集群中。集群联邦只是简单地将多个集群简单的「连接到了一起」，在多个集群之间复制工作负载，而成员集群之间的流量无法调度，也无法实现真正的多租户。\n\n集群联邦不足以实现混合云，为了实现真正意义上的混合云，就要让集群之间做到互联互通，同时实现多租户。TSB 在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。下面是 Istio 管理平面的多租户和 API 示意图。\n\n![TSB 在 Istio 之上构建的管理平面示意图](tsb-management-plane.svg)\n\nTSB 为管理混合云，基于 Istio 构建了一个管理平面，新建了 Tenant 和 Workspace 的资源，并通过选择器，将网关组、流量组和安全组应用到对应集群中的工作负载上。关于 TSB 的详细架构请参考 TSB 文档。\n\n## 更多{#more}\n\n如果你想了解更多关于 Istio 和云原生的内容，下面有一些资料分享给你：\n\n- 为了帮助大家更好的了解 Istio 和云原生，笔者在 2020 年发起了[云原生社区](https:\/\/cloudnative.to)，欢迎大家加入我们一起探索后 Kubernetes 时代的云原生新范式；\n- 2022 年 6 月，云原生社区著的[《深入理解 Istio —— 云原生服务网格进阶实战》](\/blog\/istio-service-mesh-book\/)已图书由电子工业出版社出版，欢迎大家购买；\n- 笔者于 2022 年 5 月，将之前所作电子书、教程和译文全部迁移到了[云原生资料库](\/book\/)欢迎阅读和留言评论。\n\n## 参考\n\n[^1]: 有关 Envoy 开源的详细过程，推荐你阅读 Envoy 作者 Matt Klein 的这篇文章[网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训](https:\/\/cloudnative.to\/blog\/envoy-oss-5-year\/)。\n\n[^2]: 后来 IBM 与 Google 反目，大举抨击 Google 没有遵守将 Istio 捐献给 CNCF 的约定，Google 对 Istio 商标的管理也受到了[质疑](https:\/\/thenewstack.io\/googles-management-of-the-istio-service-mesh-raises-questions-in-the-cloud-native-community\/)。\n[^3]: 2018 年，CNCF 为云原生的重新定义是：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n[^4]: Day-2 Operation 是在系统的生命周期结束前，对系统不断改进的过程，以实现效益最大化。参考 [什么是 Day-2 Operation](https:\/\/jimmysong.io\/blog\/what-is-day-2-operation\/)。\n[^5]: Istio 现已推出 proxyless 模式测试版，详见 [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。\n[^6]: Kubernetes 预计推出 [Gateway API](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)，Istio 也有计划使用 Kubernetes 的 Gateway API 替换当前 Istio 自定义的 Gateway 资源。\n[^7]: 有关服务网格项目的详细对比请参考 [servicemesh.es](https:\/\/servicemesh.es\/) 网站。\n[^8]: 《[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/)》这篇文章在云原生社区里引起了一系列关于服务网格将被 eBPF 技术所取代的讨论。[请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想](https:\/\/jimmysong.io\/blog\/epbf-sidecar-and-service-mesh\/)，不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。\n[^9]: 在百度的服务网格团队分享的 [殊途同归，Proxyless Service Mesh 在百度的实践与思考](https:\/\/mp.weixin.qq.com\/s\/G8vmlJyaimux_K-548kFbA) 这篇文章里，详细介绍了百度的服务网格采用路径，以及对服务网格本质的探索。\n[^10]: 关于 xDS 协议，请参考 [Envoy 中的 xDS REST 和 gRPC 协议详解](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/) 这篇文章。\n[^11]: [PEP](https:\/\/www.oreilly.com\/library\/view\/network-access-control\/9780470398678\/9780470398678_policy_enforcement_point.html)，全称 Policy Enforcement Point，策略执行点（PEP）是控制用户访问并确保策略决策点 (PDP) 做出授权决策的网络或安全设备。在一些 NAC 实现中，PDP 是有线交换机或无线接入点。在其他情况下，PEP 是防火墙、IPS、服务器或内联设备。根据实施情况，PEP 和 PDP 可以是独立设备，也可以合并为单个设备。\n[^12]: Apache SkyWalking 的 Rover 组件利用 eBPF 技术改进了 SkyWalking 的剖析功能，可用于分析服务网格的性能问题，请参考 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/)。\n[^13]: 有多家公司正在合作开发 Envoy Gateway，包括 [Ambassador Labs](https:\/\/www.getambassador.io\/)、[Fidelity Investments](https:\/\/www.fidelity.com\/)、[Project Contour](https:\/\/projectcontour.io\/) 和 [VMware](https:\/\/www.vmware.com\/)。\n[^14]: Istio 仅可以路由 TCP 流量，默认支持 HTTP、HTTPS、gRPC 和原始 TCP 协议，其中 Sidecar 和 Gateway 所支持的协议范围有所不同，详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/protocol-selection\/)。\n[^15]: SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n[^16]: \u0060pilot-agent\u0060 是 sidecar 容器中的主进程，你可以在 [Istio 的组成架构图](#istio-components)中看到。\u0060pilot-agent\u0060 中的镜像提取机制（在 Istio 1.9 中引入），从远程 HTTP 源可靠地检索 Wasm 二进制文件，已被扩展到支持从任何 OCI 注册处检索 Wasm OCI 镜像，包括 Docker Hub、Google Container Registry（GCR）、Amazon Elastic Container Registry（Amazon ECR）和其他地方。\n[^17]: Istio 具有身份和证书管理功能，可以实现服务间的终端用户认证，在控制平面还采用微服务架构的时候，其中的 Citadel 组件负责证书管理，在 Istio 1.5 版本被合并到单体 Istiod 中了。\n', '\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/validating-a-request-payload-with-wasm/">[译] 使用 WebAssembly 验证请求负载</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tetrate.io/blog/validating-a-request-payload-with-wasm/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 WebAssembly 验证请求负载', '本文是一个开发 Wasm 插件验证请求负载的教程。', '\n## 什么是 Wasm 插件？\n\n你可以使用 Wasm 插件在数据路径上添加自定义代码，轻松地扩展服务网格的功能。可以用你选择的语言编写插件。目前，有 AssemblyScript（TypeScript-ish）、C\u002b\u002b、Rust、Zig 和 Go 语言的 Proxy-Wasm SDK。\n\n在这篇博文中，我们描述了如何使用 Wasm 插件来验证一个请求的有效载荷。这是 Wasm 与 Istio 的一个重要用例，也是你可以使用 Wasm 扩展 Istio 的许多方法的一个例子。您可能有兴趣阅读我们关于[在 Istio 中使用 Wasm 的博文](https:\/\/www.tetrate.io\/blog\/category\/wasm\/)，并观看我们关于在 Istio 和 Envoy 中使用 Wasm 的免费研讨会的录音。\n\n## 何时使用 Wasm 插件？\n\n当你需要添加 Envoy 或 Istio 不支持的自定义功能时，你应该使用 Wasm 插件。使用 Wasm 插件来添加自定义验证、认证、日志或管理配额。\n\n在这个例子中，我们将构建和运行一个 Wasm 插件，验证请求 body 是 JSON，并包含两个必要的键 ——\u0060id\u0060 和 \u0060token\u0060。\n\n## 编写 Wasm 插件\n\n这个示例使用 [tinygo](https:\/\/tinygo.org\/) 来编译成 Wasm。确保你已经安装了 [tinygo 编译器](https:\/\/tinygo.org\/getting-started\/install\/)。\n\n### 配置 Wasm 上下文\n\n首先配置 Wasm 上下文，这样 tinygo 文件才能操作 HTTP 请求：\n\n\u0060\u0060\u0060go\npackage main\n\nimport (\n\t\u0022github.com\/tetratelabs\/proxy-wasm-go-sdk\/proxywasm\u0022\n\t\u0022github.com\/tetratelabs\/proxy-wasm-go-sdk\/proxywasm\/types\u0022\n\t\u0022github.com\/tidwall\/gjson\u0022\n)\n\nfunc main() {\n\t\/\/ SetVMContext 是配置整个 Wasm VM 的入口。请确保该入口在 main 函数中调用，否则 VM 将启动失败。\n\tproxywasm.SetVMContext(\u0026vmContext{})\n}\n\n\/\/ vmContext 实现 proxy-wasm-go SDK 的 types.VMContext 接口。\ntype vmContext struct {\n\t\/\/ 在这里嵌入默认的虚拟机环境，我们不需要实现所有方法。\n\ttypes.DefaultVMContext\n}\n\n\/\/ 复写 types.DefaultVMContext\nfunc (*vmContext) NewPluginContext(contextID uint32) types.PluginContext {\n\treturn \u0026pluginContext{}\n}\n\n\/\/ pluginContext 实现 proxy-wasm-go SDK 的 types.PluginContext 接口\ntype pluginContext struct {\n\t\/\/ 在这里侵入默认的插件上下文，我们不需要实现所有方法。\n\ttypes.DefaultPluginContext\n}\n\n\/\/ 复写 types.DefaultPluginContext\nfunc (ctx *pluginContext) NewHttpContext(contextID uint32) types.HttpContext {\n\treturn \u0026payloadValidationContext{}\n}\n\n\/\/ payloadValidationContext 实现 proxy-wasm-go SDK 的 types.HttpContext 接口\ntype payloadValidationContext struct {\n\t\/\/ 在这里嵌入默认的根 http 上下文，我们不需要实现所有方法。\n\ttypes.DefaultHttpContext\n\ttotalRequestBodySize int\n}\n\u0060\u0060\u0060\n\n### 验证负载\n\n内容类型头是通过实现 \u0060OnHttpRequestHeaders\u0060 来验证的，一旦从客户端收到请求头，就会调用该头。\n\n\u0060proxywasm.SendHttpResponse\u0060 用于响应 403 forbidden 的错误代码和信息，如果内容类型丢失的话。\n\n\u0060\u0060\u0060go\nfunc (ctx *payloadValidationContext) OnHttpRequestHeaders(numHeaders int, endOfStream bool) types.Action {\n\tcontentType, err := proxywasm.GetHttpRequestHeader(\u0022content-type\u0022)\n\tif err != nil || contentType != \u0022application\/json\u0022 {\n\t\t\/\/ 如果 header 没有期望的 content type，返回 403 响应\n\t\tif err := proxywasm.SendHttpResponse(403, nil, []byte(\u0022content-type must be provided\u0022), -1); err != nil {\n\t\t\tproxywasm.LogErrorf(\u0022failed to send the 403 response: %v\u0022, err)\n\t\t}\n\t\t\/\/ 终止 ActionPause 对流量的进一步处理\n\t\treturn types.ActionPause\n\t}\n\n\t\/\/ ActionContinue 让主机继续处理 body\n\treturn types.ActionContinue\n}\n\u0060\u0060\u0060\n\n请求主体是通过实现 \u0060OnHttpRequestBody\u0060 来验证的，每次从客户端接收到请求的一个块时，都会调用该请求。这是通过等待直到 \u0060endOfStream\u0060 为真并记录所有收到的块的总大小来完成的。一旦收到整个主体，就会使用 \u0060proxywasm.GetHttpRequestBody\u0060 读取，然后可以使用 golang 进行验证。\n\n这个例子使用 \u0060gjson\u0060，因为 tinygo 不支持 golang 的默认 JSON 库。它检查有效载荷是否是有效的 JSON，以及键 \u0060id\u0060 和 \u0060token\u0060 是否存在。\n\n\u0060\u0060\u0060go\nfunc (ctx *payloadValidationContext) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action {\n\tctx.totalRequestBodySize \u002b= bodySize\n\tif !endOfStream {\n\t\t\/\/ OnHttpRequestBody 等待收到到 body 的全部才开始处理。\n\t\treturn types.ActionPause\n\t}\n\n\tbody, err := proxywasm.GetHttpRequestBody(0, ctx.totalRequestBodySize)\n\tif err != nil {\n\t\tproxywasm.LogErrorf(\u0022failed to get request body: %v\u0022, err)\n\t\treturn types.ActionContinue\n\t}\n\n\tif !validatePayload(body) {\n\t\t\/\/ 如果验证失败，发送 403 响应。\n\t\tif err := proxywasm.SendHttpResponse(403, nil, []byte(\u0022invalid payload\u0022), -1); err != nil {\n\t\t\tproxywasm.LogErrorf(\u0022failed to send the 403 response: %v\u0022, err)\n\t\t}\n\t\t\/\/ 终止流量\n\t\treturn types.ActionPause\n\t}\n\n\treturn types.ActionContinue\n}\n\n\/\/ validatePayload 验证给定的 json 负载\n\/\/ 注意该函数使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\nfunc validatePayload(body []byte) bool {\n\tif !gjson.ValidBytes(body) {\n\t\tproxywasm.LogErrorf(\u0022body is not a valid json: %v\u0022, body)\n\t\treturn false\n\t}\n\tjsonData := gjson.ParseBytes(body)\n\n\t\/\/ 验证 json。检查示例中是否存在必须的键\n\tfor _, requiredKey := range []string{\u0022id\u0022, \u0022token\u0022} {\n\t\tif !jsonData.Get(requiredKey).Exists() {\n\t\t\tproxywasm.LogErrorf(\u0022required key (%v) is missing: %v\u0022, requiredKey, jsonData)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\u0060\u0060\u0060\n\n### 编译成 Wasm\n\n使用 tinygo 编译器编译成 Wasm：\n\n\u0060\u0060\u0060bash\ntinygo build -o main.wasm -scheduler=none -target=wasi main.go\n\u0060\u0060\u0060\n\n## 部署 Wasm 插件\n\n### 打包到 Docker 中部署到 Envoy\n\n对于开发，这个插件可以在 Docker 中部署到 Envoy。下面的 Envoy 配置文件将设置 Envoy 监听 \u0060localhost:18000\u0060，运行所提供的 Wasm 插件，并在成功后响应 HTTP 200 和文本 \u0060hello from server\u0060。突出显示的部分是配置 Wasm 插件。\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n    - name: main\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 18000\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              typed_config:\n                \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains:\n                        - \u0022*\u0022\n                      routes:\n                        - match:\n                            prefix: \u0022\/\u0022\n                          route:\n                            cluster: web_service\n \n                http_filters:\n                 - name: envoy.filters.http.wasm\n                    typed_config:\n                      \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n                      type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n                      value:\n                        config:\n                          vm_config:\n                            runtime: \u0022envoy.wasm.runtime.v8\u0022\n                            code:\n                              local:\n                                filename: \u0022.\/main.wasm\u0022\n                  - name: envoy.filters.http.router\n\n    - name: staticreply\n      address:\n        socket_address:\n          address: 127.0.0.1\n          port_value: 8099\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              typed_config:\n                \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains:\n                        - \u0022*\u0022\n                      routes:\n                        - match:\n                            prefix: \u0022\/\u0022\n                          direct_response:\n                            status: 200\n                            body:\n                              inline_string: \u0022hello from the server\\n\u0022\n                http_filters:\n                  - name: envoy.filters.http.router\n                    typed_config: {}\n\n  clusters:\n    - name: web_service\n      connect_timeout: 0.25s\n      type: STATIC\n      lb_policy: ROUND_ROBIN\n      load_assignment:\n        cluster_name: mock_service\n        endpoints:\n          - lb_endpoints:\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: 127.0.0.1\n                      port_value: 8099\n\nadmin:\n  access_log_path: \u0022\/dev\/null\u0022\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\n\u0060\u0060\u0060\n\n运行 Docker 容器：\n\n\u0060\u0060\u0060bash\ndocker run --rm -p 18000:18000 \\\n  -v $PWD\/envoy.yaml:\/envoy.yaml \\\n  -v $PWD\/main.wasm:\/main.wasm \\\n  --entrypoint envoy containers.istio.tetratelabs.com\/proxyv2:1.9.7-tetrate-v0 \\\n  -l debug \\\n  -c \/envoy.yaml\n\u0060\u0060\u0060\n\n通过 curl 测试。首先，没有设置内容类型，将返回 403：\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000\nHTTP\/1.1 403 Forbidden\ncontent-length: 29\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:13:37 GMT\nserver: envoy\n\ncontent-type must be provided\n\u0060\u0060\u0060\n\n然后，请求 body 不是 JSON，同样返回 403。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027not JSON\u0027\nHTTP\/1.1 403 Forbidden\ncontent-length: 15\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:15:53 GMT\nserver: envoy\n\ninvalid payload\n\u0060\u0060\u0060\n\nJSON 负载中没有 \u0060token\u0060 字段，还是返回 403。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022}\u0027\nHTTP\/1.1 403 Forbidden\ncontent-length: 15\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:17:18 GMT\nserver: envoy\n\ninvalid payload\n\u0060\u0060\u0060\n\n当 id 和 token 字段都被提供时，将返回一个成功的响应。\n\n\u0060\u0060\u0060bash\n% curl -i -X POST localhost:18000 -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022, \u0022token\u0022: \u0022xxx\u0022, \u0022anotherField\u0022: \u0022yyy\u0022}\u0027\nHTTP\/1.1 200 OK\ncontent-length: 22\ncontent-type: text\/plain\ndate: Sun, 13 Mar 2022 22:18:37 GMT\nserver: envoy\nx-envoy-upstream-service-time: 1\n\nhello from the server\n\u0060\u0060\u0060\n\n## 部署到 Istio\n\n### 部署 Istio 和 httpbin 示例应用\n\n我们使用 [kind](https:\/\/kind.sigs.k8s.io\/) 来创建测试集群，对于其他方式创建的 Kubernetes 集群同样适用。\n\n\u0060\u0060\u0060bash\nkind create cluster\n\u0060\u0060\u0060\n\n集群创建完毕后，安装 Istio，我们使用的是 Istio 1.12.3，安装 [Istio httpbin 示例应用](https:\/\/github.com\/istio\/istio\/tree\/master\/samples\/httpbin)。\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=demo\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.12\/samples\/httpbin\/httpbin.yaml\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.12\/samples\/httpbin\/httpbin-gateway.yaml\n\u0060\u0060\u0060\n\n在另一个终端中，将 Ingress 网关的 80 端口转发到你本地机器的 8080 端口上。\n\n\u0060\u0060\u0060bash\nkubectl port-forward -n istio-system svc\/istio-ingressgateway 8080:80\n\u0060\u0060\u0060\n\n发送 curl 请求，检查服务是否正常启动，你应该应该看到成功的响应。\n\n\u0060\u0060\u0060bash\ncurl -X POST -i http:\/\/localhost:8080\/post\n\u0060\u0060\u0060\n\n有两种方式在 Istio 中安装 Wasm 模块：\n\n1. 对于 Istio 1.12 和更新版本的 Istio，支持 [WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 资源\n2. 对于老版本的 Istio，可以使用 [EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/)\n\n### 使用 WasmPlugin 安装\n\nWasmPlugin 资源从镜像仓库中提取 wasm 模块。因此，让我们首先为我们的 wasm 模块构建并推送一个 Docker 镜像。下面的 Docker 文件允许从你的 wasm 模块建立一个 Docker 镜像。\n\n\u0060\u0060\u0060Docker\nFROM scratch\n\nCOPY main.wasm .\/\n\u0060\u0060\u0060\n\n构建镜像，推送到镜像仓库。\n\n\u0060\u0060\u0060bash\nexport HUB=your_registry # e.g. docker.io\/tetrate\ndocker build . -t $HUB\/json-validation:v1\ndocker push $HUB\/json-validation:v1\n\u0060\u0060\u0060\n\n现在我们创建 [WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 资源。这将适用于所有通过 Istio Ingress 网关暴露的路由，并对其应用我们的验证。确保你把 \u0060{your_registry}\u0060 替换为你上传 wasm 镜像的镜像仓库。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions.istio.io\/v1alpha1\nkind: WasmPlugin\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      istio: ingressgateway\n  url: oci:\/\/{your_registry}\/json-validation:v3\n  imagePullPolicy: IfNotPresent\n  phase: AUTHN\n\u0060\u0060\u0060\n\n### 使用 EnvoyFilter 安装\n\n为了使用 EnvoyFilter，我们创建一个包含已编译的 Wasm 插件的 ConfigMap，将 ConfigMap 挂载到网关 pod 中，然后通过 EnvoyFilter 配置 Envoy，从本地文件加载 Wasm 插件。这种方法的限制是，更大和更复杂的 Wasm 模块可能超出 ConfigMap 1MB 的大小限制。\n\n首先，创建一个包含编译好的 Wasm 模块的 ConfigMap：\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system create configmap wasm-plugins --from-file=main.wasm\n\u0060\u0060\u0060\n\n然后在 Istio Ingress 网关部署中打补丁，挂载这个 ConfigMap。\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system patch deployment istio-ingressgateway --patch=\u0027\nspec:\n  template:\n    spec:\n      containers:\n        - name: istio-proxy\n          volumeMounts:\n            - name: wasm-plugins\n              mountPath: \/var\/local\/lib\/wasm-plugins\n              readOnly: true\n      volumes:\n        - name: wasm-plugins\n          configMap:\n            name: wasm-plugins\u0027\n\u0060\u0060\u0060\n\n现在 Wasm 模块就挂载到了网关 Pod 中，应用这个 EnvoyFilter。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  configPatches:\n  - applyTo: HTTP_FILTER\n    match:\n      context: GATEWAY\n    patch:\n      operation: INSERT_BEFORE\n      value:\n        name: json-validation\n        typed_config:\n          \u0027@type\u0027: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n          config:\n            vm_config:\n              code:\n                local:\n                  filename: \/var\/local\/lib\/wasm-plugins\/main.wasm\n              runtime: envoy.wasm.runtime.v8\n              vm_id: json-validation\n\u0060\u0060\u0060\n\n### 测试 Wasm 插件\n\n重复之前的 curl 请求。\n\n\u0060\u0060\u0060bash\n% curl -X POST -i http:\/\/localhost:8080\/post\nHTTP\/1.1 403 Forbidden\ncontent-length: 29\ncontent-type: text\/plain\ndate: Tue, 15 Mar 2022 22:04:35 GMT\nserver: istio-envoy\n\ncontent-type must be provided\n\u0060\u0060\u0060\n\n如果提供了内容类型和 json 负载的话，请求将会成功。\n\n\u0060\u0060\u0060bash\ncurl -i http:\/\/localhost:8080\/post  -H \u0027Content-Type: application\/json\u0027 --data \u0027{\u0022id\u0022: \u0022xxx\u0022, \u0022token\u0022: \u0022xxx\u0022}\u0027\n\u0060\u0060\u0060\n\n## 让必填字段可配置\n\n与其在编译的 golang 代码中硬编码所需的 JSON 字段，不如允许通过 Envoy 配置来配置这些字段。\n\n当在 Docker 中运行 Envoy 时，可以通过向之前创建的 Wasm \u0060http_filter\u0060 添加配置来实现。\n\n\u0060\u0060\u0060yaml\n  http_filters:\n                  - name: envoy.filters.http.wasm\n                    typed_config:\n                      \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n                      type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n                      value:\n                        config:\n                          configuration:\n                            \u0022@type\u0022: type.googleapis.com\/google.protobuf.StringValue\n                            value: |\n                                                            { \u0022requiredKeys\u0022: [\u0022id\u0022, \u0022token\u0022] }\n                          vm_config:\n                            runtime: \u0022envoy.wasm.runtime.v8\u0022\n                            code:\n                              local:\n                                filename: \u0022.\/main.wasm\u0022\n\u0060\u0060\u0060\n\n当使用 WasmPlugin，在 \u0060pluginConfig\u0060 字段中配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions.istio.io\/v1alpha1\nkind: WasmPlugin\nmetadata:\n  name: json-validation\n  namespace: istio-system\nspec:\n  selector:\n    matchLabels:\n      istio: ingressgateway\n  url: oci:\/\/{your_registry}\/json-validation:v3\n  imagePullPolicy: IfNotPresent\n  phase: AUTHN\n  pluginConfig:\n    requiredKeys: [\u0022id\u0022, \u0022token\u0022]\n\u0060\u0060\u0060\n\n最后，当使用 EnvoyFilter 时，将它添加到 filter 配置中。\n\n\u0060\u0060\u0060yaml\n   value:\n        name: json-validation\n        typed_config:\n          \u0027@type\u0027: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n          config:\n            configuration:\n              \u0022@type\u0022: type.googleapis.com\/google.protobuf.StringValue\n              value: |\n                                { \u0022requiredKeys\u0022: [\u0022id\u0022, \u0022token\u0022] }\n            vm_config:\n              code:\n                local:\n                  filename: \/var\/local\/lib\/wasm-plugins\/main.wasm\n              runtime: envoy.wasm.runtime.v8\n              vm_id: json-validation\n\u0060\u0060\u0060\n\n在代码中，实现 \u0060OnPluginStart\u0060，使用 \u0060proxywasm.GetPluginConfiguration\u0060 加载。\n\n\u0060\u0060\u0060go\n\/\/ pluginContext 实现 proxy-wasm-go SDK 中的 types.PluginContext 接口\ntype pluginContext struct {\n\t\/\/ 在这里嵌入默认的 plugin 上下文，这样就不用实现所有方法\n\ttypes.DefaultPluginContext\n\tconfiguration *pluginConfiguration\n}\n\n\/\/ pluginConfiguration 代表这个 wasm 插件中的示例配置\ntype pluginConfiguration struct {\n\t\/\/ 示例配置字段，插件将验证 json 负载中是否存在这些字段。\n\trequiredKeys []string\n}\n\n\/\/ 复写 types.DefaultPluginContext\nfunc (ctx *pluginContext) OnPluginStart(pluginConfigurationSize int) types.OnPluginStartStatus {\n\tdata, err := proxywasm.GetPluginConfiguration()\n\tif err != nil {\n\t\tproxywasm.LogCriticalf(\u0022error reading plugin configuration: %v\u0022, err)\n\t\treturn types.OnPluginStartStatusFailed\n\t}\n\tconfig, err := parsePluginConfiguration(data)\n\tif err != nil {\n\t\tproxywasm.LogCriticalf(\u0022error parsing plugin configuration: %v\u0022, err)\n\t\treturn types.OnPluginStartStatusFailed\n\t}\n\tctx.configuration = config\n\treturn types.OnPluginStartStatusOK\n}\n\n\/\/ parsePluginConfiguration 解析 json 插件配置并返回 pluginConfiguration\n\/\/ 注意使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\n\/\/ 你也可以使用 https:\/\/github.com\/mailru\/easyjson，支持解析为结构体\nfunc parsePluginConfiguration(data []byte) (*pluginConfiguration, error) {\n\tconfig := \u0026pluginConfiguration{}\n\tif !gjson.ValidBytes(data) {\n\t\treturn nil, fmt.Errorf(\u0022the plugin configuration is not a valid json: %v\u0022, data)\n\t}\n\n\tjsonData := gjson.ParseBytes(data)\n\trequiredKeys := jsonData.Get(\u0022requiredKeys\u0022).Array()\n\tfor _, requiredKey := range requiredKeys {\n\t\tconfig.requiredKeys = append(config.requiredKeys, requiredKey.Str)\n\t}\n\n\treturn config, nil\n}\n\u0060\u0060\u0060\n\n现在它们被包含在 \u0060pluginConfiguration\u0060 结构中，它们可以像其他字段一样在验证过程中被使用。\n\n\u0060\u0060\u0060go\n\/\/ validatePayload 验证给定的 json 负载\n\/\/ 注意该函数使用 gjson 解析 json，因为 TinyGo 不支持 encoding\/json\nfunc (ctx *payloadValidationContext) validatePayload(body []byte) bool {\n\tif !gjson.ValidBytes(body) {\n\t\tproxywasm.LogErrorf(\u0022body is not a valid json: %v\u0022, body)\n\t\treturn false\n\t}\n\tjsonData := gjson.ParseBytes(body)\n\n\t\/\/ 验证 json。检查示例中是否包含必须的键。\n\t\/\/ 必须的键通过插件配置。\n\tfor _, requiredKey := range ctx.requiredKeys {\n\t\tif !jsonData.Get(requiredKey).Exists() {\n\t\t\tproxywasm.LogErrorf(\u0022required key (%v) is missing: %v\u0022, requiredKey, jsonData)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\u0060\u0060\u0060\n\n然后可以使用与之前相同的命令对其进行编译和测试。\n\n## 总结\n\n总而言之，要在 Istio 1.12 和更新的版本上使用 Wasm 插件，需要三个步骤：\n\n1. 在你选择的语言中实现插件的功能。我在本教程中使用 Golang。\n2. 编译 Wasm 插件并推送到镜像仓库。\n3. 配置 Istio 以加载和使用镜像仓库中的插件。\n\n该教程还详细介绍了如何使用 Docker 在 Envoy 容器中运行 Wasm 插件，以加快开发速度，以及如何将其部署到旧的 Istio 版本。\n', '\/trans\/validating-a-request-payload-with-wasm\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是一个开发 Wasm 插件验证请求负载的教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/importance-of-wasm-in-istio/">[译] 在 Istio 中引入 Wasm 意味着什么？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/02/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中引入 Wasm 意味着什么？', '本文回顾了 Istio 和 Envoy 中引入 Wasm 的历史并介绍了其重要性。', '\nWasmPlugin API 最近被添加到 Istio 项目中，作为一种新改进的可扩展性机制。在 Tetrate，我们最近成功举办了一个名为 Istio Wasm workshop 的研讨会。[点击这里](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ)观看研讨会的录音，并加入 [Slack 上的对话](https:\/\/tetr8.io\/tetrate-edu-slack)。\n\n我们谈论了 WebAssembly 及其在 Istio 和 Envoy 项目中的重要性，并通过使用 [Proxy-Wasm Go SDK](https:\/\/github.com\/tetratelabs\/proxy-wasm-go-sdk) 和 [func-e](https:\/\/func-e.io\/) 进行了多个演示。\n\n我们在 Tetrate 关注 Istio 的可扩展性已经有很长一段时间了。Tetrate 的工程师 Takeshi Yoneda 和周礼赞在为此做出了巨大的贡献，我们非常高兴地看到 Istio 的可扩展性因此而得到了极大的改善。\n\n在这篇博文中，我描述了在引入 WasmPlugin API 之前 Istio 和 Envoy 可扩展性的状况；目前大为改善的情况；以及将或多或少完成这条可扩展性改进弧线的变化，我们预计这些变化将在即将到来的版本中出现。\n\n## Istio 和 Wasm 的历史\n\n| Istio 1.4 之前                       | Istio 1.5                                                   | Istio 1.12 和未来         |\n| ------------------------------------ | ----------------------------------------------------------- | ------------------------- |\n| 用 C\u002b\u002b 扩展维护自己的 Envoy 代理构建 | 使用 EnvoyFilter 资源引入新的 Wasm 可扩展性模型（仍然复杂） | 引入专用的 WasmPlugin API |\n| 使用 Mixer（效率低）                 | 仅支持本地或 HTTP 位置                                      | 包括对 OCI 注册表的支持   |\n\n在 Istio 1.4（2019 年 11 月发布）之前，没有良好的机制来运行插件。当时，Istio 维护了他们自己的 Envoy 代理的分支，以运行自定义插件，如用 C\u002b\u002b 编写并与 Envoy 代理一起构建的 RBAC 和 JWT 过滤器。\n\n当时，Istio 使用 Mixer 组件，在应用程序代码和基础设施后端之间提供一个层。使用 Mixer，人们能够执行授权策略，收集遥测数据，并管理配额。在这种模式下，Envoy 代理在向后端发出请求之前会调用 Mixer 组件，以执行任何前提条件检查 —— 例如，“服务 A 能否调用服务 B”，并在每个请求完成后再次调用 Mixer 以报告遥测数据。使用这种模式导致了资源的低效使用，也导致了延迟。\n\nEnvoy 的扩展性依赖于开发者知道如何用 C\u002b\u002b 编写扩展。此外，任何 C\u002b\u002b 扩展都必须用 Envoy 代理来构建。这就是当时 Istio 维护他们自己的 Envoy 代理构建的原因。\n\n在这种模式下，人们必须用新的二进制文件替换整个现有的 Envoy 代理实例。\n\n## Envoy 和 Wasm 的历史\n\nEnvoy 希望将依赖一个单一的可扩展性堆栈，使 Envoy 的发布与扩展生态系统脱钩，并使扩展开发者能够使用 C\u002b\u002b 以外的东西。在 Envoy 中加入这个功能，可以让 Istio（以及其他 Envoy 代理用户）随时推出新的特性和功能，而不需要单独维护 Envoy 的构建。在 Envoy 和 Istio 双方的强烈推动下，在 Envoy 中[支持](https:\/\/github.com\/envoyproxy\/envoy\/issues\/4272) WebAssembly 的[工作](https:\/\/github.com\/envoyproxy\/envoy\/issues\/4272)于 2018 年开始。\n\n## 在 Envoy 中引入 WebAsssembly\n\n在 Envoy 和 Istio 中所做的关于可扩展性的艰苦工作被纳入了 Istio 1.5 版本（2020 年）。Istio 1.5 版本包括一个使用 WebAssembly 的可扩展性新模型。随着 WebAssembly 的引入，不再需要运行单独的 Mixer 组件，这也导致了 Istio 部署的简化 —— 少了一件部署的东西，也少了一件需要担心的东西。\n\n该版本包括通用的应用二进制接口（ABI）和 C\u002b\u002b、Rust 和 AssemblyScript SDK。现有的 Istio 功能，如统计、元数据交换和其他功能也被实现为 WebAssembly 扩展。一个名为 EnvoyFilter 的资源被引入，以处理这些扩展的部署。\n\nEnvoyFilter 资源是对 Envoy 配置的一个非常简单的抽象，它允许 Istio 操作者修改 Envoy 代理行为。然而，这种轻量级的抽象仍然意味着操作者必须熟悉 Envoy API 的细节以及如何有效地配置它们。\n\n为了让 Envoy 代理加载和使用扩展，你必须把 Wasm 二进制文件放在与 Envoy 代理容器相同的 pod 内。运维人员可以选择指向一个本地文件（即集群内的文件，Envoy 代理容器可以访问）或提供一个 HTTP 位置，代理可以从那里下载扩展。\n\n在 Istio 的后续版本中有多项改进，特别是 Istio 代理开始拦截 EnvoyFilter 资源并代表 Envoy 代理获取二进制文件的变化。\n\n## Istio 1.12 和 WasmPlugin API\n\n最近在 Istio 1.12 中引入了最重要的突破性功能。为 Wasm 插件引入了一个专门的 API，称为 WasmPlugin API，它使用一种新的方法从符合 OCI 的注册表中获取 Wasm 二进制文件。\n\n新 API 的引入消除了使用 EnvoyFilter 来部署扩展的需要。扩展开发者现在可以使用一个名为 WasmPlugin 的资源来指定要部署插件的工作负载。对符合 OCI 标准的注册表的新支持允许开发人员使用现有的工具（例如，Docker）来构建包含其扩展的镜像，并将其推送到符合 OCI 标准的注册表。这允许以对待容器镜像的相同方式对待 Wasm 插件。例如，使用镜像标签和不同的存储库。\n\n# 总结\n\nWasmPlugin API 的工作仍在进行中。一些功能，包括对镜像拉取 secret 的支持，更好的镜像缓存支持，以及对 singleton 扩展的支持还不能使用。\n\n要开始使用 Wasm，请[观看](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ) Wasm 研讨会的[录音](https:\/\/tetrate-io.zoom.us\/webinar\/register\/WN_OJG0hpo-RXSEJcH_SutlPQ)并加入 [Slack 上的 Wasm 对话](https:\/\/tetr8.io\/tetrate-edu-slack)。\n', '\/trans\/importance-of-wasm-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文回顾了 Istio 和 Envoy 中引入 Wasm 的历史并介绍了其重要性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-wasm-service-mesh/">[译] eBPF 和 Wasm：探索服务网格数据平面的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://infoq.com/news/2022/01/ebpf-wasm-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 和 Wasm：探索服务网格数据平面的未来', 'eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。', '\n## 编者按\n\n前段时间，有人提出使用 eBPF 取代服务网格中的 sidecar 代理，该观点已经发出，就在服务网格和云原生社区中引起了“轩然大波”。后来也有不少人指出该方案实属武断，不切实际。本文就总结了 eBPF 在服务网格数据平面中的作用，以及使用 Wasm 这种新的方案。\n\n## 正文\n\n2021 年 12 月 2 日，Cilium 项目宣布了 [Cilium Service Mesh](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta) 的 beta 测试计划。在谷歌云基于 eBPF 的 Google Cloud Kubernetes Service（GKS）Dataplane V2（于 2020 年 8 月发布）所开创的概念基础上，Cilium Service Mesh 提倡“无 sidecar 服务网格 \u0022 的理念。它扩展了 Cilium eBPF 产品，以处理服务网格中的大部分 sidecar 代理功能，包括 L7 路由和负载均衡、TLS 终止、访问策略、健康检查、日志和跟踪，以及内置的 Kubernetes Ingress。\n\nCillium 的创建者 Isovalent 在一篇题为“[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/) “的文章中解释了使用 eBPF 作为 sidecar 代理的理由。\n\n它将把我们从 sidecar 模型中解放出来，并允许我们将现有的代理技术整合到现有的内核命名空间概念中，使它们成为我们每天都在使用的容器抽象的一部分。\n\n简而言之，eBPF 有望解决服务网格中的一个主要痛点 —— 当有许多细粒度的微服务时，性能堪忧。然而，使用 eBPF 来取代 sidecar 代理这个想法也是存在争议的。\n\n![告别 sidecar](008i3skNly1gy9u3uba27j31x70u0dk7.jpg) \n\n（来源：[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/)）\n\n服务网格中的数据平面指的是管理数据流量如何被路由和交付给微服务应用的基础设施服务。目前，这是通过使用服务代理来实现的。这种设计模式通常也被称为 Sidecar 模式。Sidecar 允许其附属的微服务透明地与服务网格中的其他组件发出和接收请求。\n\nSidecar 通常包含一个 L7 网络代理，如 [Envoy](https:\/\/envoyproxy.io\/)、[Linkerd](https:\/\/linkerd.io\/) 或 [MOSN](https:\/\/mosn.io\/)。该代理处理流量路由、负载均衡、健康检查、认证、授权、加密、日志、跟踪和统计数据收集。Sidecar 还可以包含一个基于 SDK 的应用框架，如 [Dapr](https:\/\/dapr.io\/)，以提供网络代理以外的应用服务。这种应用服务的例子包括服务注册、服务发现、资源绑定、基于名称的服务调用、状态管理、行为者框架和秘密存储。\n\nSidecar 代理和服务通常在 Kubernetes pod 或容器内运行。微服务应用也在容器内运行，它们通过网络接口连接到 sidecar 上。然而，这些容器化应用程序的一个重要问题是资源消耗。Sidecar 服务随着微服务的数量呈几何级数增加。当一个应用程序有数百个相互联系和负载均衡的微服务时，开销可能变得不堪重负。服务网格代理供应商在性能上展开竞争。正如 [InfoQ 之前报道的](https:\/\/www.infoq.com\/news\/2021\/08\/linkerd-rust-cloud-native\/)那样，Linkerd 将其代理从 Go 重写成了 Rust，并取得了明显的性能提升。\n\n不足为奇的是，现有的服务网格供应商并不相信 eBPF 是能解决我们所有问题的圣杯。来自 Solo 的 Idit Levine 等人写了一篇文章来回应 Cilium 的公告。这篇文章的标题是“[服务网格将使用 eBPF？是的，但 Envoy 代理将继续存在](https:\/\/www.zhaohuabing.com\/post\/2021-12-19-ebpf-for-service-mesh\/) \u0022。\n\n\u003e 在 Solo.io，我们认为 eBPF 是优化服务网格的一种强大方式，我们认为 Envoy 代理是数据平面的基石。\n\nSolo.io 作者提出的关键点是，现在的 sidecar 代理所做的事情远远超过了简单的网络流量管理。在今天的服务网格部署中，有一些复杂的要求，远远超过了 eBPF 所支持的有限的编程模型，eBPF 是图灵不完整的，对内核的安全性有许多限制。Cilium eBPF 产品可以处理许多，但不是全部，由 sidecar 代理执行的各种任务。此外，Solo.io 的作者指出，eBPF 的每个节点一个代理的设置提供了更少的灵活性，因此与传统代理的每个节点一个代理的设置相比，增加了整体开销。这些 eBPF 的缺点对于开发者必须编写并部署到服务网格代理中的流量路由、负载均衡和授权的特定应用逻辑来说尤其明显。\n\nTerate.io 的开发者在对 Cilium 公告的回应中提出了类似的论点，标题是“[社区中关于 Istio 和服务网格的争论](https:\/\/www.tetrate.io\/blog\/the-debate-in-the-community-about-istio-and-service-mesh\/) \u0022。他们指出，今天的 sidecar 代理的性能是合理的，开源社区已经想出了进一步提高性能的方法。同时，对于开发者来说，在 eBPF 这种新颖的、图灵不完整的技术中构建特定应用的数据平面逻辑是非常困难的。\n\n\u003e Istio 架构是稳定的，可用于生产的，而且生态系统正在萌芽。\n\neBPF 的许多问题与以下事实有关：它是一种内核技术，因此必须有安全限制。有没有一种方法可以将复杂的特定应用的代理逻辑纳入数据平面，而不使用使用空间技术降低性能？事实证明，WebAssembly（Wasm）可能正是这种选择。Wasm 运行时可以安全地隔离并以接近原生的性能执行用户空间代码。\n\nEnvoy Proxy 开创了使用 Wasm 作为扩展机制对数据平面进行编程的方法。开发人员可以用 C、C\u002b\u002b、Rust、AssemblyScript、Swift 和 TinyGo 等语言编写特定应用的代理逻辑，并将该模块编译到 Wasm 中。通过 proxy-Wasm 标准，代理可以在 [Wasmtime](https:\/\/github.com\/bytecodealliance\/wasmtime) 和 [WasmEdge](https:\/\/github.com\/WasmEdge\/WasmEdge) 等高性能运行机制中执行那些 Wasm 插件。目前，[Envoy Proxy](https:\/\/envoyproxy.io\/)、[Istio Proxy](https:\/\/github.com\/istio\/proxy)、MOSN 和 [OpenResty](http:\/\/openresty.org\/) 支持 [proxy-Wasm](https:\/\/github.com\/proxy-wasm)。\n\n![容器生态](008i3skNly1gy9u3wo1dnj30u015yq70.jpg) \n\n（容器生态系统中的 Wasm，来源：[WasmEdge Book](https:\/\/wasmedge.org\/book\/en\/kubernetes.html)）\n\n此外，Wasm 可以作为一个通用的应用容器。它在服务网格数据平面上的应用并不限于 sidecar 代理。附在 sidecar 上的微服务可以在它自己的轻量级 Wasm 运行时运行。WasmEdge WebAssembly 运行时是一个安全、轻量级、快速、可移植和多元化的运行时，可以直接由 [Kubernetes 作为容器](https:\/\/wasmedge.org\/book\/en\/kubernetes.html)管理。到 2021 年 12 月，WasmEdge 社区的贡献者证明了基于 WasmEdge 的微服务可以与 [Dapr](https:\/\/github.com\/second-state\/dapr-wasm) 和 [Linkerd](https:\/\/github.com\/Liquid-Reply\/kind-crun-wasm) 一起工作，作为带有操作系统和完整软件堆栈的重量级全面的 Linux 容器的替代。WebAssembly 微服务消耗 1% 的资源，与 Linux 容器应用相比，冷启动的时间是 1%。\n\neBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。\n', '\/trans\/ebpf-wasm-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(74)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/shanxi-trip/">地上文物看山西：宝藏文物大省不该被埋没</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/multi-cluster-pki-istio-recipe/">多集群 PKI 与 Istio 实践：为服务网格构建可信且可扩展的 PKI</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
