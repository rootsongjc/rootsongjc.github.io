
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 多集群</title>
    <link>https://jimmysong.io/tags/%E5%A4%9A%E9%9B%86%E7%BE%A4/</link>
    <description>Recent content in 多集群 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    <lastBuildDate>Thu, 07 Sep 2023 20:16:49 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/%E5%A4%9A%E9%9B%86%E7%BE%A4/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>Istio 中的负载均衡详解及多集群路由实践</title>
      <link>https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/</link>
      <pubDate>Thu, 07 Sep 2023 20:16:49 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/</guid>
      <description>
        
        
        


&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    编者按
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    本文介绍了 Istio 中支持的负载均衡类型，然后提出多集群网格负载均衡的解决方案。如果您已经了解 Istio 中负载均衡，可以直接从&lt;a href=&#34;#multicluster&#34; title=&#34;多集群网格中的负载均衡&#34;&gt;多集群网格中的负载均衡&lt;/a&gt;部分开始阅读。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在之前的博客&lt;a href=&#34;https://jimmysong.io/blog/why-do-you-need-istio-when-you-already-have-kubernetes/&#34; title=&#34;为什么在使用了 Kubernetes 后你可能还需要 Istio&#34;&gt;为什么在使用了 Kubernetes 后你可能还需要 Istio&lt;/a&gt; 中提到 Istio 是在 Kubernetes 的基础之上构建起来的，Kubernetes 中的组件 kube-proxy 本身已有负载均衡功能，但是只支持四层流量的负载均衡，而且无法实现服务超时、熔断等高级功能。具体来说，服务网格比起 Kubernetes 新增了以下负载均衡及韧性（Resiliency）特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layer 7 负载均衡&lt;/strong&gt;：服务网格在应用层（Layer 7）操作和管理流量，可以更细粒度地识别和控制流量。这使得它可以实现更高级的负载均衡策略，如基于 HTTP 请求头、URL 路径、Cookie 等的路由和流量分发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态负载均衡&lt;/strong&gt;：服务网格通常具备自动负载均衡的能力，可以根据后端服务的实时健康状态和性能指标来动态分发流量。这允许它实现智能负载均衡策略，将流量路由到性能最佳的服务实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;故障检测和自动故障转移&lt;/strong&gt;：服务网格具备高级的故障检测和自动故障转移功能。它可以检测到后端服务实例的故障，并自动将流量从故障实例转移到健康实例，以确保应用程序的可用性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A/B 测试和金丝雀发布&lt;/strong&gt;：服务网格允许实施高级部署策略，如 A/B 测试和金丝雀发布。这些策略允许在不同的服务版本之间动态分配流量，并根据结果进行决策。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;熔断和重试&lt;/strong&gt;：服务网格通常包含熔断和重试机制，以提高应用程序的可用性和稳定性。它可以根据后端服务的性能和可用性情况来自动执行熔断操作，并在必要时重试请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局流量控制&lt;/strong&gt;：服务网格提供了集中式的流量控制和策略定义，允许对整个服务网格中的流量进行全局管理。这使得实现统一的安全性、监控和策略成为可能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;深度集成的监控和追踪&lt;/strong&gt;：服务网格通常集成了强大的监控和追踪工具，可以提供有关流量性能和可见性的详细信息，帮助进行故障排除和性能优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然 Kubernetes 提供了基本的负载均衡能力，但服务网格在其之上构建了更高级的负载均衡和流量管理功能，以满足微服务架构中复杂的需求。&lt;/p&gt;
&lt;h3 id=&#34;客户端负载均衡-vs-服务端负载均衡&#34;&gt;客户端负载均衡 vs 服务端负载均衡&lt;/h3&gt;
&lt;p&gt;客户端负载均衡和服务端负载均衡是两种不同的负载均衡方法，它们在不同的场景和应用中有各自的优势。以下是对它们的解释，适用的场景，实现案例以及相关的开源项目：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端负载均衡（Client-Side Load Balancing）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端负载均衡的示意图如图 1 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/client-side-load-balancing.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/client-side-load-balancing.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 1：客户端负载均衡&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 1：客户端负载均衡&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：在客户端负载均衡中，负载均衡决策是由服务的消费者（客户端）来做出的。客户端负载均衡器通常会维护一个服务实例列表，并根据配置和策略选择要发送请求的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：客户端负载均衡适用于以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个客户端需要访问同一组后端服务，每个客户端可以根据自己的需求和策略选择后端服务。&lt;/li&gt;
&lt;li&gt;服务消费者需要更多的流量控制和策略定义，例如 A/B 测试、金丝雀发布等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现案例&lt;/strong&gt;：常见的实现客户端负载均衡的开源项目包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ribbon&lt;/strong&gt;：Netflix Ribbon 是一个用于客户端负载均衡的开源项目，它可以与 Spring Cloud 集成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Envoy&lt;/strong&gt;：Envoy 是一个高性能的代理服务器，支持客户端负载均衡，广泛用于服务网格和微服务架构中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NGINX&lt;/strong&gt;：虽然 NGINX 通常用于反向代理，但也可以用作客户端负载均衡器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务端负载均衡（Server-Side Load Balancing）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端负载均衡如图 2 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/server-side-load-balancing.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/server-side-load-balancing.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 2：服务端负载均衡&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 2：服务端负载均衡&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：在服务端负载均衡中，负载均衡决策是由服务端的负载均衡器或代理来做出的。客户端只需将请求发送到服务端，然后服务端决定将请求路由到哪个后端服务实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：服务端负载均衡适用于以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端不关心后端服务的具体实例，只关心发送请求到服务的名称或地址。&lt;/li&gt;
&lt;li&gt;负载均衡策略需要在服务端进行全局配置，客户端不需要关心负载均衡细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现案例&lt;/strong&gt;：常见的实现服务端负载均衡的开源项目包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NGINX&lt;/strong&gt;：NGINX 可以用作反向代理服务器，执行服务端负载均衡，将请求路由到后端服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HAProxy&lt;/strong&gt;：HAProxy 是一种高性能的负载均衡器，通常用于服务端负载均衡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amazon ELB（Elastic Load Balancer）&lt;/strong&gt;：亚马逊提供的负载均衡服务，用于将请求路由到 AWS 后端服务实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，有时也会将客户端负载均衡和服务端负载均衡结合使用，以满足特定的需求。选择哪种负载均衡方法通常取决于您的架构、部署需求以及性能要求。服务网格（如 Istio）通常使用客户端负载均衡来实现细粒度的流量控制和策略定义，而在云服务提供商中，服务端负载均衡通常用于自动扩展和流量管理。&lt;/p&gt;
&lt;h3 id=&#34;how-istio-do-lb&#34;&gt;Istio 如何实现负载均衡&lt;/h3&gt;
&lt;p&gt;在服务网格（如 Istio）中，客户端负载均衡通常是通过 Envoy 代理实现的。Envoy 是一个高性能的代理服务器，它可以用于构建服务网格的数据平面，用于处理服务之间的通信。客户端负载均衡是一种在服务消费者（客户端）一侧实现的负载均衡策略，它决定了请求应该如何路由到后端服务实例。&lt;/p&gt;
&lt;p&gt;单集群单网络 Istio 服务网格的负载均衡如图 3 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/istio-load-balancing.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/istio-load-balancing.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 3：单集群单网络的 Istio 服务网格的负载均衡&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 3：单集群单网络的 Istio 服务网格的负载均衡&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;以下是服务网格中如何实现客户端负载均衡的一般流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sidecar 代理&lt;/strong&gt;: 在服务网格中，每个部署的服务实例通常都与一个 Sidecar 代理（通常是 Envoy）关联。这个 Sidecar 代理位于服务实例旁边，负责处理该服务实例的入站和出站流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务注册与发现&lt;/strong&gt;: 在服务网格中，服务实例的注册和发现通常由服务注册表（Kubernetes 的服务发现机制）处理。这些注册表维护了服务实例的信息，包括它们的网络地址和健康状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;客户端负载均衡配置&lt;/strong&gt;: 在客户端（服务消费者）发送请求时，Sidecar 代理会执行负载均衡策略。这些负载均衡策略通常在服务注册表中获取的服务实例列表上操作。策略可以基于多种因素进行选择，例如权重、健康状态、延迟等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;请求路由&lt;/strong&gt;: 根据负载均衡策略，Sidecar 代理将请求路由到选择的后端服务实例。这可以包括使用轮询、加权轮询、最少连接等算法来选择目标实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通信处理&lt;/strong&gt;: 一旦选择了目标实例，Sidecar 代理将请求转发给该实例，然后将响应传回给客户端。它还可以处理连接管理、故障检测和自动故障转移等任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，客户端负载均衡是在服务消费者一侧（通常是 Envoy 代理）实现的负载均衡策略，它使服务网格能够有效地分发流量并处理后端服务实例的故障。这种方式使得负载均衡决策在服务消费者的控制下，并允许更精细的流量控制和策略定义。Envoy 代理是实现客户端负载均衡的关键组件之一，它具有丰富的配置选项，可用于满足不同的负载均衡需求。&lt;/p&gt;
&lt;h2 id=&#34;lb-types&#34;&gt;Istio 中的负载均衡类型&lt;/h2&gt;
&lt;p&gt;在 Istio 的&lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/destination-rule/&#34; title=&#34;DestinationRule&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DestinationRule&lt;/a&gt;资源中，&lt;code&gt;loadBalancer&lt;/code&gt;部分用于配置负载均衡策略，控制请求如何分发到不同的服务实例或版本，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/istio-loadbalancer.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/istio-loadbalancer.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 4：Istio 中的负载均衡配置参数&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 4：Istio 中的负载均衡配置参数&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从图中我们可以看出，Istio 支持三种类型的负载均衡，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;simple&lt;/code&gt;：基于常用负载均衡算法的简单负载均衡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;consistentHashLB&lt;/code&gt;：基于一致性哈希算法的负载均衡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;localityLbSetting&lt;/code&gt;：基于地域的本地性负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是与负载均衡配置相关的字段的含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;simple&lt;/strong&gt;：这个部分定义了一些简单的负载均衡策略选项，其中包括以下选项：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ROUND_ROBIN&lt;/strong&gt;：请求会依次分发到所有可用的后端实例，以轮询的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LEAST_CONN&lt;/strong&gt;：请求将路由到当前连接数最少的后端实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RANDOM&lt;/strong&gt;：请求将随机路由到后端实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PASSTHROUGH&lt;/strong&gt;：Istio 不会进行负载均衡，而是将请求直接路由到服务的一个实例，适用于特定用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;consistentHashLB&lt;/strong&gt;：这个部分允许你配置一致性哈希负载均衡，其中包括以下字段：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;httpHeaderName&lt;/strong&gt;：用于哈希计算的 HTTP 标头的名称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;httpCookie&lt;/strong&gt;：用于哈希计算的 HTTP Cookie 的配置，包括名称、路径和生存时间（TTL）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;useSourceIp&lt;/strong&gt;：是否使用请求的源 IP 地址进行哈希计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;httpQueryParameterName&lt;/strong&gt;：用于哈希计算的 HTTP 查询参数的名称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ringHash&lt;/strong&gt;：配置环形哈希负载均衡，包括最小环大小（minimumRingSize）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maglev&lt;/strong&gt;：配置 Maglev 负载均衡，包括表格大小（tableSize）和最小环大小（minimumRingSize）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localityLbSetting&lt;/strong&gt;：这个部分用于配置本地性负载均衡设置，其中包括以下字段：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;distribute&lt;/strong&gt;：定义了请求的分布，包括起始位置（from）和结束位置（to）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;failover&lt;/strong&gt;：定义了故障切换，包括起始位置（from）和结束位置（to）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;failoverPriority&lt;/strong&gt;：故障切换的优先级设置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enabled&lt;/strong&gt;：是否启用本地性负载均衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些字段允许你根据你的需求选择适当的负载均衡策略，并配置额外的选项，以确保请求按照所需的方式分发到后端服务实例。不同的策略和配置选项可以满足各种负载均衡需求，如性能、可靠性和流量控制。关于这些字段的详细介绍请见 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/destination-rule/&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;istio-lb&#34;&gt;如何在 Istio 中为服务设置负载均衡&lt;/h2&gt;
&lt;p&gt;正如我在&lt;a href=&#34;https://jimmysong.io/blog/understand-istio-vs-and-dr/&#34; title=&#34;如何理解 Istio 中的 VirtualService 和 DestinationRule&#34;&gt;如何理解 Istio 中的 VirtualService 和 DestinationRule&lt;/a&gt;这篇文章中所说的，&lt;code&gt;VirtualService&lt;/code&gt; 主要用于设置路由规则，而服务弹性（负载均衡、超时、重试、熔断等）需要靠它和 DestinationRule 来共同维持。只有同时部署了以上两种资源，负载均衡才能真正生效。&lt;/p&gt;
&lt;p&gt;以下是设置负载均衡的一般步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建 DestinationRule 资源&lt;/strong&gt;：首先，你需要创建一个 DestinationRule 资源，该资源定义了服务的流量策略和目标规则。在 DestinationRule 中，你可以指定要设置负载均衡的服务的名称（host）以及负载均衡策略。&lt;/p&gt;
&lt;p&gt;以下是一个 DestinationRule 的示例，其中将流量分发到具有标签 &amp;ldquo;version: v1&amp;rdquo; 和 &amp;ldquo;version: v2&amp;rdquo; 的两个子集中，并使用 &lt;code&gt;ROUND_ROBIN&lt;/code&gt; 负载均衡策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-destination-rule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-service.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ROUND_ROBIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用 DestinationRule&lt;/strong&gt;：创建 DestinationRule 后，将其应用于要进行负载均衡的服务。这通常可以通过 Istio 的 VirtualService 资源来完成，通过在 VirtualService 中引用 DestinationRule。&lt;/p&gt;
&lt;p&gt;以下是一个 VirtualService 示例，将流量引导到名为 &amp;ldquo;my-destination-rule&amp;rdquo; 的 DestinationRule：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-virtual-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;my-service.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-service.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-service.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的示例中，根据权重配置，80% 的流量将路由到子集 v1，而 20% 的流量将路由到子集 v2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用配置&lt;/strong&gt;：最后，将 VirtualService 和 DestinationRule 资源应用到你的 Istio 环境中，以确保负载均衡规则生效。&lt;/p&gt;
&lt;p&gt;使用 kubectl 命令将 VirtualService 和 DestinationRule 应用到 Istio 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f your-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这些步骤，你可以为你的服务设置负载均衡策略，根据需要将流量分发到不同的服务版本或实例，并控制流量的权重。这有助于实现诸如金丝雀发布、A/B 测试和灰度发布等部署策略。请根据你的具体需求和环境调整负载均衡配置。&lt;/p&gt;
&lt;h3 id=&#34;devide&#34;&gt;为什么要分开配置？&lt;/h3&gt;
&lt;p&gt;在 Istio 中，负载均衡和路由是两个不同的概念，它们通常用于控制服务之间的流量和行为，因此通常分别配置在两个不同的资源对象中：&lt;code&gt;DestinationRule&lt;/code&gt; 用于负载均衡，&lt;code&gt;VirtualService&lt;/code&gt; 用于路由。这种分离的设计有一些优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块化和清晰性：&lt;/strong&gt; 将负载均衡和路由配置分离成两个资源对象可以使配置更加模块化和清晰。这样，您可以更容易地理解和维护这两个方面的配置，而不会使配置对象过于复杂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可维护性：&lt;/strong&gt; 将负载均衡和路由配置分开可以使它们更容易维护和修改，因为它们位于不同的资源对象中。这样，您可以针对不同的需求更改负载均衡策略而不会影响路由规则，反之亦然。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可重用性：&lt;/strong&gt; 模块化的配置允许您更容易地重用配置片段。您可以在不同的 &lt;code&gt;DestinationRule&lt;/code&gt; 或 &lt;code&gt;VirtualService&lt;/code&gt; 中使用相同的负载均衡策略或路由规则，以提高配置的可重用性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;精细控制：&lt;/strong&gt; 分离的配置允许您对每个方面进行更精细的控制。您可以根据需要为每个服务定制不同的路由规则和负载均衡策略，以满足特定的用例和要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然负载均衡和路由通常是分开配置的，但它们之间仍然存在紧密的关联，因为路由规则决定了请求将如何被路由到后端服务，而负载均衡策略决定了在所选目标服务之间如何分发流量。因此，在 Istio 中，这两个配置对象通常需要协同工作，以实现您的流量管理需求。通过将它们分开配置，使得配置更加清晰和可维护，并允许更灵活地满足不同的需求。&lt;/p&gt;
&lt;h2 id=&#34;multicluster&#34;&gt;多集群网格中的负载均衡&lt;/h2&gt;
&lt;p&gt;在微服务领域，Istio 已被证明是管理服务通信的无价之宝。虽然它在单集群场景下表现出色，但多集群设置引入了独特的挑战，特别是在负载均衡方面。接下来我们将揭秘 Istio 中的多集群负载均衡，为您提供解决这一复杂任务的清晰路线图。&lt;/p&gt;
&lt;h3 id=&#34;two-tier-ingress-gateway&#34;&gt;两层入口网关：实现多集群通信的关键&lt;/h3&gt;
&lt;p&gt;在涉及来自不同供应商的集群的多集群设置中，第一步是为每个集群建立一个网关。然而，需要特别注意的关键一点是需要一个唯一的用户访问入口点。尽管可以在同一集群中部署此网关，但通常建议将其放置在一个单独的集群中。&lt;/p&gt;
&lt;p&gt;两层入口网格的部署架构如图 4 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/tier1-gw-listening.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/tier1-gw-listening.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 4：两层入口网关&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 4：两层入口网关&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;components&#34;&gt;多集群通信所需组件&lt;/h3&gt;
&lt;p&gt;基于 Istio 创建的多集群网格，通常是&lt;a href=&#34;https://istio.io/latest/docs/setup/install/multicluster/multi-primary_multi-network/&#34; title=&#34;多网格多网络模式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多网格多网络模式&lt;/a&gt;，为了让网格互通，我们需要添加一个一级（Tier-1）集群，并在每个集群中创建如下组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;入口网关&lt;/strong&gt;：每个网格必须有一个入口网关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ServiceEntry&lt;/strong&gt;：用于允许集群发现彼此的端点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VirtualServices 和 DestinationRules&lt;/strong&gt;：对于每个集群内部的服务发现和路由至关重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;demo&#34;&gt;实战演示：一个多集群演示&lt;/h2&gt;
&lt;p&gt;在这个演示中，我将涵盖三个 GKE 上的 Kubernetes 集群，分布在不同的区域，如图 5 所示。当然你也可以使用不同的供应商或者跨供应商。在每个集群中部署了 Istio，为多集群通信奠定了基础。&lt;/p&gt;
&lt;p&gt;建立了两层集群：一个专门托管 &lt;code&gt;productpage&lt;/code&gt; 服务，另一个包含完整 &lt;a href=&#34;https://istio.io/latest/docs/examples/bookinfo/&#34; title=&#34;bookinfo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bookinfo&lt;/a&gt; 的服务套件。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/init-infra.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/init-infra.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 5：演示环境的部署情况&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 5：演示环境的部署情况&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;multicluster-routing-and-lb&#34;&gt;实现多集群路由和负载均衡&lt;/h3&gt;
&lt;p&gt;为了实现诸如负载均衡和故障转移等高级功能，解决多集群路由问题至关重要。由于一级集群也部署了 Istio，可以将先前讨论的负载均衡技巧应用于此网关。&lt;/p&gt;
&lt;p&gt;关键步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在每个集群中创建入口网关，并获取网关使用的负载均衡器的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个集群中创建 &lt;strong&gt;VirtualServices、DestinationRules 和 ServiceEntries&lt;/strong&gt;。确保 ServiceEntries 包含每个集群入口网关的入口点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为进一步的测试，&lt;strong&gt;检索 Tier 1 网关的 IP 地址&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;GATEWAY_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl -n tier1 get service tier1-gateway -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;{.status.loadBalancer.ingress[0].ip}&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：这一步需要在一级集群中操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一级集群的网关作为统一网关入口，你可以通过在这个集群中配置 Gateway、VirtualService、DestinationRule 和 ServiceEntry 资源对象，实现多集群的路由，如图 6 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/istio-resources.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/istio-resources.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 6：一级集群中的 Istio 资源&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 6：一级集群中的 Istio 资源&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在这个演示中我们将实现基于 HTTP header 和 prefix 的多集群的路由，最终的路由路径如图 7 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/demystifying-the-load-balancing-in-istio/final.svg&#34; data-img=&#34;/blog/demystifying-the-load-balancing-in-istio/final.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 7：路由路径&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 7：路由路径&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;关于操作的细节可以参考 TSB 文档中的&lt;a href=&#34;https://docs.tetrate.io/service-bridge/next/howto/gateway/unified-gateway&#34; title=&#34;统一网关&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;统一网关&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;test&#34;&gt;测试设置&lt;/h3&gt;
&lt;p&gt;演示继续进行实际测试，使用 &lt;code&gt;curl&lt;/code&gt; 命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无需 HTTP 标头的请求 URL。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -Ss &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://bookinfo.tetrate.io/productpage&amp;#34;&lt;/span&gt; --resolve &lt;span class=&#34;s2&#34;&gt;&amp;#34;bookinfo.tetrate.io:80:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GATEWAY_IP&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; -v &amp;gt; index1.html
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用指示首选集群的 HTTP 标头请求 URL。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -Ss &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://bookinfo.tetrate.io/productpage&amp;#34;&lt;/span&gt; --resolve &lt;span class=&#34;s2&#34;&gt;&amp;#34;bookinfo.tetrate.io:80:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GATEWAY_IP&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; -v -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;X-CLUSTER-SELECTOR: gke-jimmy-us-west1-1&amp;#34;&lt;/span&gt; &amp;gt; index2.html
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -Ss &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://bookinfo.tetrate.io/productpage&amp;#34;&lt;/span&gt; --resolve &lt;span class=&#34;s2&#34;&gt;&amp;#34;bookinfo.tetrate.io:80:&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$GATEWAY_IP&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; -v -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;X-CLUSTER-SELECTOR: gke-jimmy-us-west1-2&amp;#34;&lt;/span&gt; &amp;gt; index3.html
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过导出的 HTML 文件验证结果。在浏览器中分别打开 &lt;code&gt;index1.html&lt;/code&gt;、&lt;code&gt;index2.html&lt;/code&gt; 和 &lt;code&gt;index3.html&lt;/code&gt; 这三个文件，你将看到页面 1 和页面 2 中都显示 reviews 和 details 服务不可用，只有页面 3 中的所有服务都可访问。&lt;/p&gt;
&lt;h3 id=&#34;multicluster-lb&#34;&gt;多集群负载均衡&lt;/h3&gt;
&lt;p&gt;演示成功展示了如何利用 HTTP 标头和路径路由。路由是负载均衡的基础。实现了多集群路由之后，你就可以将来自二级（Tier-2）集群的端点添加到一个 subset 中，从而在 DestinationRule 中实现负载均衡配置。&lt;/p&gt;
&lt;p&gt;可以通过将二级集群中的入口网关配置为东西向网关，从而解决 Cluster 1 中的故障转移问题。请参考 &lt;a href=&#34;https://istio.io/latest/docs/setup/install/multicluster/multi-primary_multi-network/&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;automation&#34;&gt;自动化的呼声&lt;/h3&gt;
&lt;p&gt;尽管 Istio 提供了基于 Envoy 的各种负载均衡类型，但手动在多个集群中创建资源对象容易出错且效率低下。自动化，最好是在 Istio 之上添加一个解释层，是下一个发展阶段。&lt;/p&gt;
&lt;p&gt;Tetrate 使用 TSB 解决了这个需求，TSB 与上游的 Istio 兼容，为多集群部署提供了无缝的解决方案。有关更多信息，请访问 &lt;a href=&#34;https://tetrate.io&#34; title=&#34;Tetrate 网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate 网站&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;精通 Istio 中的多集群负载均衡对于在复杂环境中发挥微服务的全部潜力至关重要。通过谨慎的配置和合适的工具，您可以在集群之间实现强大且可靠的通信，确保您的应用程序无论部署在何处都能顺利运行。对于更精细的负载均衡调整，请考虑探索 EnvoyFilter。感谢您加入我们一起揭秘 Istio 中的多集群负载均衡之旅！&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/setup/install/multicluster/multi-primary_multi-network/&#34; title=&#34;Install Multi-Primary on different networks - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Install Multi-Primary on different networks - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.tetrate.io/service-bridge/next/howto/gateway/unified-gateway&#34; title=&#34;Unified Gateway - docs.tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unified Gateway - docs.tetrate.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/destination-rule/&#34; title=&#34;DestinationRule - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DestinationRule - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>是否选择多集群——使用服务网格的集群间通信</title>
      <link>https://jimmysong.io/trans/multi-cluster-service-mesh/</link>
      <pubDate>Wed, 31 Mar 2021 14:20:46 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/multi-cluster-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;本文翻译自 &lt;a href=&#34;https://www.infoq.com/articles/kubernetes-multicluster-comms/&#34; title=&#34;To Multicluster, or Not to Multicluster: Inter-Cluster Communication Using a Service Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;To Multicluster, or Not to Multicluster: Inter-Cluster Communication Using a Service Mesh&lt;/a&gt;。Istio 服务网格是解决 Kubernetes 集群间通信的一个关键，虽然翻译这篇文章距离原文发表也有快 2 年时间了，但是其中的很多观点仍不过时。&lt;/p&gt;
&lt;h2 id=&#34;主要观点&#34;&gt;主要观点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 已经成为容器编排的事实标准，许多组织都运行着多个集群。集群内的通信是一个解决了的问题，但是跨集群的通信需要更多的设计和操作开销。&lt;/li&gt;
&lt;li&gt;在决定是否实施多集群支持之前，你应该了解你的通信用例。&lt;/li&gt;
&lt;li&gt;你还应该确定你想要从解决方案中获得什么（单一界面的观察性、统一信任域等），然后制定一个关于如何实现这些的计划。&lt;/li&gt;
&lt;li&gt;有几种多集群服务网格方法，如共同管理、集群感知服务通过网关路由、扁平网络和 split-horizon 端点发现服务（EDS）。&lt;/li&gt;
&lt;li&gt;Istio 有现有的多集群支持，在 1.1 中还有额外的新功能，甚至未来还会有更多的功能出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 已经成为企业中容器编排的事实标准。这是有充分理由的 —— 它提供了一系列功能，使管理容器化应用变得更加容易。Kubernetes 也带来了一些新的挑战，一个主要的挑战就是需要部署和管理多个 Kubernetes 集群，以便有效地管理大规模分布式系统。&lt;/p&gt;
&lt;p&gt;想象一下，你已经设计和编码了一个应用，并且你已经构建了容器 —— 你只需要运行它们。从代码到运行应用是令人振奋的，但正如任何构建了容器化应用的人所知道的那样，它并不像乍看起来那样简单。在部署到生产之前，有各种开发 / 测试 / 阶段周期。此外，还有一个扩展方面的问题 —— 你的生产应用可能需要在许多不同的地方运行，原因包括水平扩展性、弹性或接近最终用户。&lt;/p&gt;
&lt;h2 id=&#34;环境越多集群问题越多&#34;&gt;环境越多，（集群）问题越多&lt;/h2&gt;
&lt;p&gt;即使是一个简单的绿地应用概念，最终也需要多个部署环境。如果你正在迁移一个现有的应用，你一定会遇到更多的挑战，比如不同的安全域，不同的组织 / 计费，以及对一个云供应商的机器学习工具包的亲和力。&lt;/p&gt;
&lt;p&gt;解决这个问题最常见的方法是创建多个 Kubernetes 集群，每个集群都致力于在其特定环境中运行你的应用组件。在高安全领域，你将广泛使用基于角色的访问控制（RBAC），并具有审计功能。测试环境应该重现很多生产行为，但要为便于调试和检查而定制。对于你的开发环境…… 好吧，也许你像我一样，你就打开 Docker 偏好设置，然后勾选 Kubernetes 框。易用性和短暂性是常态。&lt;/p&gt;
&lt;p&gt;你很可能最终会有多个 Kubernetes 集群，每个集群都会托管微服务。集群中这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供了通用的通信模式来提高弹性、安全性和可观测性。那么集群之间和跨集群呢？&lt;/p&gt;
&lt;p&gt;运行多个 Kubernetes 集群并不一定可怕，但运行多个集群确实需要你考虑它们如何通信和交互，以便轻松交付运行在上面的优秀应用。像 Istio 这样的服务网格可以让多集群通信变得毫无痛苦。Istio 拥有多集群支持，在 1.1 中增加了新功能，并计划在未来增加更多的功能。团队也应该考虑采用服务网格来简化跨多个集群的通信。&lt;/p&gt;
&lt;h2 id=&#34;常见的使用案例&#34;&gt;常见的使用案例&lt;/h2&gt;
&lt;p&gt;运行多集群服务网格最常见的是这些用户需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于我的组织规模，我有多个集群，我想在一个地方查看和管理它们。我的集群一般不做集群间的流量，或者当它们做的时候，是通过定义好的 API。&lt;/li&gt;
&lt;li&gt;我有多个集群以实现高可用性，它们是彼此的克隆，如果一个集群发生故障，另一个集群可以接管，这一点非常重要。&lt;/li&gt;
&lt;li&gt;我有多个集群，它们组合成一个更高级别的应用。其中一个集群中的微服务需要与另一个集群中的微服务进行通信，以提供适当的端到端应用体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三类多集群需要集群间的流量。如果你想要集群间流量支持，你的实现将取决于集群之间的网络，以及你对容错的要求。&lt;/p&gt;
&lt;h3 id=&#34;你能从多集群中得到什么&#34;&gt;你能从多集群中得到什么？&lt;/h3&gt;
&lt;p&gt;当你考虑多集群和服务网格时，你应该从确定你想要什么开始，然后转移到如何获得它。&lt;/p&gt;
&lt;h3 id=&#34;单一界面&#34;&gt;单一界面&lt;/h3&gt;
&lt;p&gt;你的多个服务网格从一个地方操作。你可以在一个单一的接口中查看所有集群的配置、指标和跟踪。&lt;/p&gt;
&lt;h3 id=&#34;统一信任域&#34;&gt;统一信任域&lt;/h3&gt;
&lt;p&gt;你使用服务网格来提供工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好：你依靠的是它们是什么的加密证明，而不是脆弱的外围堆栈来控制它们的来源。&lt;/p&gt;
&lt;p&gt;统一的信任域意味着所有的工作负载都可以通过绑定到一个共同的信任根来相互认证（它们是什么）。服务网格控制平面都是为这个共同的信任根配置的，无论这些平面有一个还是几个。&lt;/p&gt;
&lt;h3 id=&#34;独立的故障域&#34;&gt;独立的故障域&lt;/h3&gt;
&lt;p&gt;一个不依赖其他集群和相关基础设施，本身就可以正常运行的集群是一个独立的故障域。我是把服务网格列为相关基础设施 —— 如果你要安装服务网格，你是为了把通信弹性转移到应用下面的基础设施层。如果一个集群中的服务网格的故障可以破坏另一个集群中的服务网格，那么它就不能算是一个独立的故障域。&lt;/p&gt;
&lt;h3 id=&#34;集群间的流量&#34;&gt;集群间的流量&lt;/h3&gt;
&lt;p&gt;如果你想让一个集群中的服务与另一个集群中的服务直接通信，并且你想让这种通信具有服务网格的好处，如高级路由、可观测性或透明加密，那么你需要集群之间的流量保持为服务网格的一部分。换句话说，你希望你的东/西流量离开一个集群，中转一些中间网络，比如互联网，然后进入另一个集群。&lt;/p&gt;
&lt;p&gt;这可能是大多数人在考虑多集群服务网格时的第一想法，但我在这里单独把它列出来，因为它对容错有影响。&lt;/p&gt;
&lt;h3 id=&#34;异构非扁平化的网络&#34;&gt;异构/非扁平化的网络&lt;/h3&gt;
&lt;p&gt;非平面网络支持跨多个集群的服务，没有平面网络的要求。这意味着你可以做一些事情，比如在一个网格中分配 IP，而不考虑另一个网格，你不需要 VPN 或网络隧道来进行跨网格的通信。&lt;/p&gt;
&lt;p&gt;如果你的组织已经创建了一堆不同的集群，而没有冲突的 pod IP 地址范围，或者你只是永远不想再进入这种泥潭，这将是一个对你有吸引力的属性。&lt;/p&gt;
&lt;h2 id=&#34;多集群服务网格方法&#34;&gt;多集群服务网格方法&lt;/h2&gt;
&lt;p&gt;在阐述了你可能需要从多集群中寻找的不同属性之后，我可以介绍一下各种方法所带来的好处。&lt;/p&gt;
&lt;h3 id=&#34;独立集群&#34;&gt;独立集群&lt;/h3&gt;
&lt;p&gt;这就是解多集群。仅仅因为你有多个集群，而且每个集群都使用一个服务网格，并不意味着你必须采用统一的多集群服务网格。扪心自问，你当初为什么会有多个集群。如果你希望每个集群都是自己独立的故障域，那么隔离和消除跨集群的依赖关系是有意义的。如果这能满足你的需求，那么把服务网格当作另一个单集群的服务，比如 pod 调度或持久性磁盘管理，也没有什么坏处。&lt;/p&gt;
&lt;h3 id=&#34;共同管理&#34;&gt;共同管理&lt;/h3&gt;
&lt;p&gt;在独立集群方法之上的下一步是多个集群的共同管理系统。在这种模式下，每个集群都是独立运行的，但你通过一个共同的管理界面来管理这套网格。让你用来监控和调试系统（或者，在这种情况下，系统）的东西驻留在系统本身之外是一个很好的设计，这样当系统坏了的时候，你仍然可以检查和修复它。&lt;/p&gt;
&lt;p&gt;如果你选择在这些集群中使用一个共同的信任根（证书授权或签名证书），那么你也可以拥有一个统一的信任域。&lt;/p&gt;
&lt;p&gt;如果独立的故障域是首要任务，那么这是一个不错的选择。这种选择很适合将软件作为服务来消费，因为你可以得到一个外部的接口来统一一切，并得到服务级别协议的支持。&lt;/p&gt;
&lt;h3 id=&#34;通过网关进行集群感知的服务路由选择&#34;&gt;通过网关进行集群感知的服务路由选择&lt;/h3&gt;
&lt;p&gt;Istio 中的这种方法涉及多个独立的服务网格，每个集群中一个，以及一些配置技巧，以允许一个集群中的服务与另一个集群中的服务通信。首先，你要为所有网格创建一个统一的信任域。接下来，你配置一个入口网关，以接受来自另一个对等集群中的服务的可信流量。最后，配置服务条目，以允许某些服务的流量从一个集群路由出来并发送到另一个集群。&lt;/p&gt;
&lt;p&gt;这是第一种允许不同集群中的服务直接相互通信的方法。同时，每个集群仍然是一个独立的网格控制平面和故障域。这意味着，如果集群 B 中的服务网格发生故障，集群 A 仍然可以工作，只是看起来集群 B 中的服务不可用。配置这种跨集群流量的负担就落在了用户身上。&lt;/p&gt;
&lt;h3 id=&#34;扁平网络&#34;&gt;扁平网络&lt;/h3&gt;
&lt;p&gt;这种模式决定了你所有集群的服务网格。你安排它，使每个集群中的 pod 具有非重叠的 IP 地址，因此任何 pod 可以将流量路由到任何集群中的其他 pod。你可能在一个共同的防火墙后面有一堆集群，或者你可能在集群间建立 VPN 隧道。你配置服务网格，以将发现的 pod、服务和来自每个集群的配置结合到一个整体视图中。&lt;/p&gt;
&lt;p&gt;扁平化的网络使它看起来就像你有一个超级服务网格，横跨你的所有集群。也有一些缺点。这个超级服务网格由一个控制平面管理，所以如果它出现问题，所有集群的服务网格都会出现问题。如果你原来为了容错而划分成多个 Kubernetes 集群，这种方式就否定了这一点。另外一个考虑是控制平面必须要扩展来管理所有集群。而且你必须让这个扁平网络的性能足够好，以处理控制平面和跨集群的流量。&lt;/p&gt;
&lt;h3 id=&#34;分割区域端点发现服务eds&#34;&gt;分割区域端点发现服务（EDS）&lt;/h3&gt;
&lt;p&gt;这种方法也可以在集群间创建一个服务网格，但不需要扁平网络。你仍然有一个控制平面，可以从每个集群中发现 pod、服务和配置，但 Istio 的 EDS，其功能类似于分裂水平 DNS，取代了对扁平网络的要求。&lt;/p&gt;
&lt;p&gt;一个集群中的 pod 的 sidecar 被配置了它想要通信的每个服务的端点列表。如果 pod 在同一个集群中，它就会直接显示在 EDS 列表中。如果 pod 在另一个集群中，则会出现另一个集群的入口网关。pod 选择一个端点进行对话并发送流量 —— 如果端点是本地的，则通信是直接的 pod 到 pod。如果 pod 选择了一个远程端点，它就会将流量发送到相关入口网关的地址，并标记为 pod 想要访问的服务。入口网关接收流量，并将其发送到其集群中实现服务的 pod 之一。入口网关使用服务器名称指示（SNI）来了解流量的目的地。&lt;/p&gt;
&lt;p&gt;与扁平网络方式一样，这种方式创建了一个统一的服务网格控制平面，并增加了一个单一故障域和单一信任域。它不需要扁平网络，只需要一个集群可以将流量发送到其他集群的入口网关的公共地址。&lt;/p&gt;
&lt;h2 id=&#34;要不要多集群&#34;&gt;要不要多集群？&lt;/h2&gt;
&lt;p&gt;如果你出于开发和组织的原因要运行多个集群，那么了解你的需求并决定是否要在多集群环境中连接这些需求是很重要的，如果是这样，了解各种方法和每个选项的相关权衡。&lt;/p&gt;
&lt;p&gt;如果你已经读到这里，你可能已经决定了多集群。真正的问题是什么是最好的实现方法。希望下面的表格能帮助你决定适合你的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;统一管理&lt;/th&gt;
&lt;th&gt;统一信任&lt;/th&gt;
&lt;th&gt;异构网络&lt;/th&gt;
&lt;th&gt;独立故障域&lt;/th&gt;
&lt;th&gt;跨集群通信&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;独立集群&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;共同管理&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扁平网络&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分割区域端点发现服务（EDS）&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通过网关进行集群感知的服务路由选择&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;像 Istio 这样的服务网格可以提供帮助，如果使用得当，可以让多集群通信变得不痛苦。如果你想了解更多关于我对为什么以及团队应该如何考虑采用服务网格来简化跨多个集群的通信的看法。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;Andrew Jenkins 是 Aspen Mesh 的首席技术官，他正在构建一个企业服务网格，以帮助企业减轻管理微服务的负担。作为容器环境（如 Kubernetes）的软件和网络架构师，Jenkins 曾担任技术领导，推动快速发展的团队取得切实成果。他的专长包括 C++、JavaScript（Node.js）、Python、C、Go 和 Java 的软件开发。Jenkins 还在软件和硬件测试、FPGA 和空间科学仪器的电路板设计方面拥有丰富的经验。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
