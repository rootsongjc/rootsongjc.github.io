
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 可观测性</title>
    <link>https://jimmysong.io/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    <description>Recent content in 可观测性 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    
      <follow_challenge>
        <feedId>51621818828612637</feedId>
        <userId>59800919738273792</userId>
      </follow_challenge>
    
    
    <lastBuildDate>Mon, 20 Jan 2025 16:50:25 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>探索云原生可观测性：技术与团队协作的深度结合</title>
      <link>https://jimmysong.io/blog/cloud-native-observability-devops/</link>
      <pubDate>Mon, 20 Jan 2025 16:50:25 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cloud-native-observability-devops/</guid>
      <description>
        
        
        &lt;p&gt;最近读了 TheNewStack 发布的电子书《&lt;a href=&#34;https://thenewstack.io/ebooks/observability/cloud-native-observability-for-devops-teams/&#34; title=&#34;Cloud Native Observability for DevOps Teams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Observability for DevOps Teams&lt;/a&gt;》，虽然这本书是 2022 年出品的，但给我了很大的启发。它不仅讨论了技术工具，还深入探讨了团队协作、文化建设和未来趋势的结合点。在这本书里，“观察”不仅仅是看到数据，而是看清背后的意义。可以说，它从根本上改变了我对可观测性的理解。&lt;/p&gt;
&lt;h2 id=&#34;核心内容&#34;&gt;核心内容&lt;/h2&gt;
&lt;p&gt;本书从基础定义到实际操作，系统地阐述了云原生可观测性的重要性及其实现方式。通过具体的工具和策略，它帮助读者理解如何整合指标、日志、追踪和混沌工程等维度，全面掌控分布式系统的健康状况，为 DevOps 团队提供高效的决策支持。&lt;/p&gt;
&lt;h3 id=&#34;可观测性的定义与价值&#34;&gt;可观测性的定义与价值&lt;/h3&gt;
&lt;p&gt;书中开篇就点明：可观测性是通过系统的外部信号推断内部状态的能力。不仅是传统的指标（Metrics）、日志（Logs）、追踪（Tracing）三根支柱的组合，而是一种综合性、全局化的分析方法。正如作者所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Observability isn’t just the ability to see each piece at a time; it’s also the ability to understand the broader picture and how these pieces combine.&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;云原生环境的挑战&#34;&gt;云原生环境的挑战&lt;/h3&gt;
&lt;p&gt;书中特别强调了 Kubernetes 环境中日志和监控的复杂性。Kubernetes 没有内置的完整可观测性解决方案，只提供了基础功能，比如 &lt;code&gt;kubectl&lt;/code&gt; 查看对象状态，而更高级的功能需要依赖第三方工具如 Fluentd 和 Prometheus。&lt;/p&gt;
&lt;h3 id=&#34;实践指南&#34;&gt;实践指南&lt;/h3&gt;
&lt;p&gt;书中在实践部分提到了多种实现可观测性的具体策略和工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用日志&lt;/strong&gt;：通过 Fluentd 或类似工具采集容器内的标准输出日志，帮助开发者定位应用问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集群日志&lt;/strong&gt;：收集 Kubernetes 核心组件如 kube-apiserver 和 etcd 的日志，适合排查系统级别的故障。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件日志&lt;/strong&gt;：利用 &lt;code&gt;kubectl get events&lt;/code&gt; 快速了解集群中资源的状态变化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;审计日志&lt;/strong&gt;：记录 API 请求，便于安全审查和权限问题的定位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混沌工程&lt;/strong&gt;：利用工具如 Chaos Mesh 和 Litmus Chaos，验证系统在高压或异常情况下的表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些实践指南强调了工具与策略的结合，从而实现全面的可观测性。&lt;/p&gt;
&lt;h2 id=&#34;我的思考与观点&#34;&gt;我的思考与观点&lt;/h2&gt;
&lt;h3 id=&#34;超越数据本身的观察力&#34;&gt;超越数据本身的“观察力”&lt;/h3&gt;
&lt;p&gt;书中强调，单纯收集数据并不能解决问题，关键在于跨维度数据的整合与分析。例如，在性能问题排查时，指标和追踪往往无法直接关联，而这正是现有工具的短板。未来，统一数据存储和分析视角的工具，比如 OpenTelemetry 提倡的标准化方法，可能是突破口。&lt;/p&gt;
&lt;h3 id=&#34;ai-与可观测性的结合&#34;&gt;AI 与可观测性的结合&lt;/h3&gt;
&lt;p&gt;随着 AI 技术的发展，可观测性工具也可以更智能化。例如，通过机器学习预测异常，或是自动推荐优化策略。这不仅能减少人为干预，还能提升故障响应速度。正如作者在混沌工程部分提到的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Instead of waiting for something to happen and finding out how your application fares, you put it through duress under controlled conditions to identify weaknesses and fix them.&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;从团队协作到文化转型&#34;&gt;从团队协作到文化转型&lt;/h3&gt;
&lt;p&gt;书中提到“DevOps 的终极目标是跨团队的协作与同理心”，这点深有共鸣。尤其是在复杂分布式系统中，开发和运维团队往往各自为战，导致沟通断层。跨团队协作的关键在于工具提供的透明性与共享视角，而不仅仅是技术能力。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这本书的独到之处在于它从技术和人文两个角度同时切入，它让我意识到，可观测性不仅是一组工具的集合，而是一种文化、一种能力，帮助我们更深刻地理解系统，推动团队协作，并在复杂的云原生环境中建立起真正的“透明化”。&lt;/p&gt;
&lt;p&gt;最后，我想引用书中一段非常打动我的话来结尾：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Observability lets you see the beautiful and complete picture that is your production software systems.&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;

      </description>
    </item>
                           
    <item>
      <title>Envoy 代理如何处理用户请求以实现追踪</title>
      <link>https://jimmysong.io/blog/envoy-tracing/</link>
      <pubDate>Thu, 26 Sep 2024 15:24:35 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/envoy-tracing/</guid>
      <description>
        
        
        &lt;p&gt;在云原生环境中，提升对应用程序的可观测性以更好地理解用户体验是至关重要的。然而，单纯依靠指标和日志无法提供个别案例的具体细节。这时，追踪（Tracing）技术就显得尤为重要。&lt;/p&gt;
&lt;h2 id=&#34;追踪的基本原理&#34;&gt;追踪的基本原理&lt;/h2&gt;
&lt;p&gt;追踪通过为每个用户请求附加一个关联 ID，向开发人员提供完整的用户体验上下文。这个关联 ID 就像一根线，将跨越多个服务的追踪串联起来，从而实现全面的可观测性。&lt;/p&gt;
&lt;p&gt;下图展示了 Envoy 处理用户请求的流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/98285f54b4811bd9ece87523444f4e02.svg&#34; data-img=&#34;/blog/envoy-tracing/98285f54b4811bd9ece87523444f4e02.svg&#34; alt=&#34;image&#34; data-caption=&#34;用户请求与 Envoy 代理的处理流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;用户请求与 Envoy 代理的处理流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;追踪&lt;/strong&gt;可以通过为每个用户请求附加一个关联 ID，向开发人员提供完整的用户体验上下文。这个关联 ID 就像一根线，将跨越多个服务的追踪串联起来。&lt;/p&gt;
&lt;p&gt;尽管所有请求都会经过 Envoy 代理，但 Envoy 无法独立提供完整的追踪信息。它只看到应用程序作为网络的一部分，无法洞察内部处理。这使得 Envoy 无法区分入站请求和出站请求是否来自同一个用户，因此无法自动转发追踪上下文。&lt;/p&gt;
&lt;h2 id=&#34;服务网格中的请求上下文&#34;&gt;服务网格中的请求上下文&lt;/h2&gt;
&lt;p&gt;Envoy 可以在 Istio 服务网格中作为 Sidecar 或 Waypoint 代理，下图展示了 Envoy 在服务网格中如何处理请求上下文的。&lt;/p&gt;
&lt;h3 id=&#34;1-用户请求的开始&#34;&gt;1. 用户请求的开始&lt;/h3&gt;
&lt;p&gt;追踪涉及通过多个服务跟踪路径，以理解用户体验的完整上下文。追踪从一个用户请求开始，该请求被分配了一个关联 ID。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/51fd90d791099a4f158c823a821fba6d.svg&#34; data-img=&#34;/blog/envoy-tracing/51fd90d791099a4f158c823a821fba6d.svg&#34; alt=&#34;image&#34; data-caption=&#34;用户请求的开始&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;用户请求的开始&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;2-请求通过-envoy-代理&#34;&gt;2. 请求通过 Envoy 代理&lt;/h3&gt;
&lt;p&gt;Envoy 位于应用程序旁边，所有进入的请求都会经过 Envoy。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/aebbb0ea064ee93575ec5a1ec9bdf329.svg&#34; data-img=&#34;/blog/envoy-tracing/aebbb0ea064ee93575ec5a1ec9bdf329.svg&#34; alt=&#34;image&#34; data-caption=&#34;用户请求的开始&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;用户请求的开始&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;3-envoy-附加额外的-headers&#34;&gt;3. Envoy 附加额外的 Headers&lt;/h3&gt;
&lt;p&gt;Envoy 可以在请求中附加额外的 Headers，以收集关于应用程序内部发生情况的信息。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/7ab35160ac9d07cfdcaa9436b8706548.svg&#34; data-img=&#34;/blog/envoy-tracing/7ab35160ac9d07cfdcaa9436b8706548.svg&#34; alt=&#34;image&#34; data-caption=&#34;Envoy 附加额外的 Headers&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Envoy 附加额外的 Headers&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;4-应用程序处理请求并调用后端服务&#34;&gt;4. 应用程序处理请求并调用后端服务&lt;/h3&gt;
&lt;p&gt;应用程序在处理请求的过程中，可能需要联系其他系统来处理该请求。比如外部的认证和授权服务。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/d1016c81280b99d35a642a80caa3af52.svg&#34; data-img=&#34;/blog/envoy-tracing/d1016c81280b99d35a642a80caa3af52.svg&#34; alt=&#34;image&#34; data-caption=&#34;应用程序处理请求并调用后端服务&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;应用程序处理请求并调用后端服务&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;5-应用程序需要复制关联-id&#34;&gt;5. 应用程序需要复制关联 ID&lt;/h3&gt;
&lt;p&gt;应用程序知道出站请求是代表哪个入站请求发起的（例如 Trace ID 为 1234 的请求）。但是，Envoy 并不知道这一点。因此，应用程序需要将关联 ID 等上下文从入站请求复制到出站请求中。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/1409785fdd6f8909dffee3c5bd1b44ba.svg&#34; data-img=&#34;/blog/envoy-tracing/1409785fdd6f8909dffee3c5bd1b44ba.svg&#34; alt=&#34;image&#34; data-caption=&#34;应用程序需要复制关联 ID&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;应用程序需要复制关联 ID&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;6-多个请求的并发处理&#34;&gt;6. 多个请求的并发处理&lt;/h3&gt;
&lt;p&gt;在实际场景中，应用程序同时处理多个用户请求，这导致了并发性。由于 Envoy 只能看到网络层面的请求和响应，无法区分这些请求之间的因果关系。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/2aebfd544f726da5fe6f4389aed924bd.svg&#34; data-img=&#34;/blog/envoy-tracing/2aebfd544f726da5fe6f4389aed924bd.svg&#34; alt=&#34;image&#34; data-caption=&#34;多个请求的并发处理&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;多个请求的并发处理&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;7-envoy-的局限性&#34;&gt;7. Envoy 的局限性&lt;/h3&gt;
&lt;p&gt;因为 Envoy 无法看到应用程序内部的处理逻辑，它只能看到一系列的网络请求和响应，无法知道哪些出站请求是由哪些入站请求触发的。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/d048f6f9fc9af6f29a9f2e4bfe599613.svg&#34; data-img=&#34;/blog/envoy-tracing/d048f6f9fc9af6f29a9f2e4bfe599613.svg&#34; alt=&#34;image&#34; data-caption=&#34;Envoy 的局限性&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Envoy 的局限性&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;需要应用程序的参与&#34;&gt;需要应用程序的参与&lt;/h2&gt;
&lt;p&gt;由于 Envoy 无法自动转发追踪上下文，应用程序本身需要负责将入站请求的 Headers 复制到出站请求中，以保持追踪信息的完整性。&lt;/p&gt;
&lt;h3 id=&#34;应用程序复制-headers&#34;&gt;应用程序复制 Headers&lt;/h3&gt;
&lt;p&gt;应用程序在处理入站请求时，需要将必要的 Headers（如关联 ID、用户身份等）复制到任何出站请求中。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/d1f00ba65d1c61edf996a19a6b5145d7.svg&#34; data-img=&#34;/blog/envoy-tracing/d1f00ba65d1c61edf996a19a6b5145d7.svg&#34; alt=&#34;image&#34; data-caption=&#34;应用程序复制 Headers&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;应用程序复制 Headers&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;响应返回给用户&#34;&gt;响应返回给用户&lt;/h3&gt;
&lt;p&gt;应用程序完成对用户请求的处理后，将响应返回给用户。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/envoy-tracing/ed0816d0cb881c7c7d5eb19e6d0826bf.svg&#34; data-img=&#34;/blog/envoy-tracing/ed0816d0cb881c7c7d5eb19e6d0826bf.svg&#34; alt=&#34;image&#34; data-caption=&#34;响应返回给用户&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;响应返回给用户&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;解决方案与推荐&#34;&gt;解决方案与推荐&lt;/h2&gt;
&lt;p&gt;为了确保追踪信息的完整性，应用程序需要主动复制和传递追踪相关的 Headers。这可以通过集成如 &lt;a href=&#34;https://skywalking.apache.org/&#34; title=&#34;Apache SkyWalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt; 的工具来实现，SkyWalking 不仅支持分布式追踪，还包括性能监控、日志分析等功能。利用 SkyWalking 的库和代理，可以简化 Headers 的复制和追踪信息的传递。&lt;/p&gt;
&lt;p&gt;关于如何在 Istio 中使用 SkyWalking 实现分布式追踪详见&lt;a href=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/&#34; title=&#34;这篇博客&#34;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;追踪的重要性&lt;/strong&gt;：追踪为开发人员提供了用户请求的完整上下文，帮助更好地理解和改进用户体验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Envoy 的局限性&lt;/strong&gt;：Envoy 只能看到网络层面的请求和响应，无法跟踪请求的因果关系，因此无法自动转发追踪上下文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序的角色&lt;/strong&gt;：应用程序需要主动复制和传递追踪相关的 Headers，以确保追踪信息的完整性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐的工具&lt;/strong&gt;：使用 SkyWalking 等追踪工具的库，可以简化在应用程序中实现 Headers 复制的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/how-the-envoy-proxy-handles-a-user-request/&#34; title=&#34;How the Envoy proxy handles a user request - tetrate.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How the Envoy proxy handles a user request - tetrate.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/&#34; title=&#34;如何在 Istio 中使用 SkyWalking 进行分布式追踪？- jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何在 Istio 中使用 SkyWalking 进行分布式追踪？- jimmysong.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>OpenTelemetry 的最新进展及其对可观测性的影响</title>
      <link>https://jimmysong.io/trans/why-the-latest-advances-in-opentelemetry-are-significant/</link>
      <pubDate>Fri, 12 Jan 2024 08:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/why-the-latest-advances-in-opentelemetry-are-significant/</guid>
      <description>
        
        
        &lt;p&gt;今年，在云原生计算基金会（Cloud Native Computing Foundation）中，一个备受关注的项目是&lt;a href=&#34;https://thenewstack.io/observability-in-2024-more-opentelemetry-less-confusion/&#34; title=&#34;OpenTelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt;和&lt;a href=&#34;https://thenewstack.io/how-the-opentelemetry-collector-scales-observability/&#34; title=&#34;OpenTelemetry Collector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt;。这个项目是观测领域的一个非常令人兴奋的运动，旨在跨行业合作，达成观测和遥测的标准数据格式。&lt;/p&gt;
&lt;p&gt;这本身就非常重要，因为它允许多个观测和分析工具进行互操作，而以前的团队如果想要一个工具与另一个工具进行互操作，就必须多次转换数据。随着观测领域围绕人工智能/机器学习的炒作，公司更有可能从一个系统中存储和查看数据，然后在另一个系统中进行机器学习模型的训练。&lt;/p&gt;
&lt;p&gt;更棒的是，由于行业供应商和个人在&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; title=&#34;OpenTelemetry Collector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt;上合作，这个项目继续不断发展。它是一个标准化的代理和遥测收集器，提供高吞吐量的遥测数据收集和分析。该收集器已经支持跟踪和度量数据一段时间了，但直到去年的&lt;a href=&#34;https://thenewstack.io/kubeconcloudnativecon-2022-rolls-into-detroit/&#34; title=&#34;KubeCon Detroit 2022&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon Detroit 2022&lt;/a&gt;，社区才吸纳了 OpenLogs 项目，并开始实施日志收集和分析功能。现在，日志支持已经完全成熟。&lt;/p&gt;
&lt;p&gt;在接下来的部分中，我将分享一些关于这个项目的新特性以及它们对社区的重要性。&lt;/p&gt;
&lt;h2 id=&#34;1-新的转换语言&#34;&gt;1. 新的转换语言&lt;/h2&gt;
&lt;p&gt;我发现许多代理的语法使得进行有意义的转换非常困难，需要使用一些奇怪的 YAML 或 TOML。Otel Collector 仍然依赖于 YAML 格式，但它的新转换语言允许使用基于函数的语句，执行起来非常快速，可以管理复杂性。查看一些&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/pkg/ottl/README.md&#34; title=&#34;语法示例&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语法示例&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-日志正式发布&#34;&gt;2. 日志正式发布&lt;/h2&gt;
&lt;p&gt;在大约一年的开发时间内，日志收集和分析现在已经正式发布。该实施有一些收集日志的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，它作为一个独立的代理运行，并从文件系统收集日志。它可以直接发送到最终目的地，也可以转发到以收集器模式运行的 OpenTelemetry Collector，可以即时计算日志指标。&lt;/li&gt;
&lt;li&gt;其次，存在许多日志 SDK，可以直接在应用程序中实施，并将日志发送到中央收集器或直接发送到最终目的地，这有助于减少磁盘 IO 的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-自动仪器成熟度&#34;&gt;3. 自动仪器成熟度&lt;/h2&gt;
&lt;p&gt;自动仪器是自动将应用程序连接到发出跟踪和度量数据而无需或仅需进行最少代码更改的能力。Java 和.Net 得到了全面支持，其他语言正处于不同开发和发布阶段。这个功能是一些专有解决方案展示出来的特色，因为它通过减少开发人员的时间来降低部署复杂性，现在它将同样强大的功能带到了 OpenTelemetry 生态系统中。&lt;/p&gt;
&lt;h2 id=&#34;4-语义约定&#34;&gt;4. 语义约定&lt;/h2&gt;
&lt;p&gt;这一点非常重要，并且正在从 ElasticSearch 向 OpenTelemetry 项目捐赠 ECS（Elastic Common Schema）而受益。规范化日志和遥测结构具有挑战性，因为似乎几乎每个人都以稍微不同的格式生成遥测数据；但要能够分析、创建警报并以人性化的方式呈现数据，所有遥测字段都需要以某种方式映射。如果每个人和每个系统都略有不同，那么在创建可重用的仪表板和组件方面就会出现挑战。现在，软件供应商可以负责在多个平台上创建仪表板，合理地确保数据将以多个平台上的正确格式进行发送。与此同时，我们管理大量遥测数据的人可以通过使用众所周知的字段名称来提高摄取和查询效率，并且在大多数客户发送的内容依赖于这些字段名称时，可以提供更高级的功能，同时减少计算资源和内存开销。&lt;/p&gt;
&lt;p&gt;完整的架构仍然需要一段时间才能最终确定，但逐步正在批准这些约定。例如，在 KubeCon 上，他们宣布了 HTTP 架构的最终确定。&lt;/p&gt;
&lt;h2 id=&#34;5-插件框架和生态系统&#34;&gt;5. 插件框架和生态系统&lt;/h2&gt;
&lt;p&gt;生态系统正在不断成熟。可扩展性框架允许自定义任何摄取管道&lt;/p&gt;
&lt;p&gt;的任何阶段。有越来越多的接收器用于各种系统，处理器具有越来越先进的功能，目标也在增加。我特别对新版本的 OpenSearch 扩展感到兴奋，它可以发送预打包在简化的遥测或 ECS 格式中的日志数据。&lt;/p&gt;
&lt;p&gt;从开发者的角度来看，我发现模式和内部“p”消息模式的结构非常周到，内置了 protobuf。它在功能自由度和最小复杂度之间有一个良好的平衡。&lt;/p&gt;
&lt;h2 id=&#34;6-社区合作&#34;&gt;6. 社区合作&lt;/h2&gt;
&lt;p&gt;这对于 CNCF 社区来说并不是很新鲜，但这个项目的速度和影响体现了 CNCF 社区哲学的精神。竞争公司正在共同努力，使计算的一部分变得更好、更容易，以造福我们其他人。有些人可能担心去除供应商锁定会导致客户离开，或者共享代码可能泄漏专有 IP。&lt;/p&gt;
&lt;p&gt;然而，在遥测领域，代理和收集器的核心架构通常是已解决的问题。那么为什么不制作一些遵循惯例并在各个平台上运行的东西，以便公司不再必须维护代理代码，其中 80% 都是重复的呢？这使公司可以在互操作性和创新可以通过这个框架传递的专有处理器方面共同开发插件。好处也延伸到所有运营商和软件供应商。借助标准化的 Otel Collector SDK，供应商可以创建一个单一的集成来为其应用程序添加遥测，并极大简化了收集过程，试图让所有主要的观测提供商为你的应用程序实施支持。&lt;/p&gt;
&lt;p&gt;运营商也从“随处收集”和“随处发送”的理念中受益。通过标准的配置文件格式简化了设置，减少了新系统的引入复杂性。我还怀疑，许多日志系统的运营商在观测数据的语义约定项目减少了许多问题后，将大大减少字段映射的基数问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;向所有项目贡献者和社区成员表示衷心的“感谢”！这里有太多人要列出来了，但你可以在&lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/community-members.md&#34; title=&#34;GitHub 上的 OpenTelemetry 项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 上的 OpenTelemetry 项目&lt;/a&gt;上找到他们。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 和 OpenTelemetry Collector 的功能和未来路径正在以极快的速度前进，过去一年是 CNCF 组合中贡献第二多的项目，仅次于 Kubernetes。有这么多贡献者保持组织和合作，成熟度将继续加速。这将有望通过增加互操作性并简化仪表系统的仪器化过程来促进观测领域的创新。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>OpenTelemetry 与可观测性：展望未来</title>
      <link>https://jimmysong.io/trans/opentelemetry-and-observability-looking-forward/</link>
      <pubDate>Tue, 02 Jan 2024 08:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/opentelemetry-and-observability-looking-forward/</guid>
      <description>
        
        
        &lt;p&gt;让我们探讨一些令人兴奋的趋势，考虑到我们期待 2024 年会有什么样的可观测性发展。&lt;/p&gt;
&lt;p&gt;随着年底的临近，现在是一个停下来思考的好时机。2023 年对于 OpenTelemetry 来说是一个里程碑，因为其三个基本信号，跟踪、度量和日志，都达到了稳定版本。这一成就标志着&lt;a href=&#34;https://thenewstack.io/opentelemetry-gaining-traction-from-companies-and-vendors/&#34; title=&#34;OpenTelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt;最初愿景的实现，即提供一个基于标准的框架，用于仪器化和收集可观测性数据。&lt;/p&gt;
&lt;p&gt;让我们抓住这个机会，探讨一下我们所见证的一些令人兴奋的趋势，深入研究创新的产品和用例，并在期待 2024 年的到来时深思熟虑地考虑可观测性的不断演变。&lt;/p&gt;
&lt;h2 id=&#34;度量标准的崭露头角&#34;&gt;度量标准的崭露头角&lt;/h2&gt;
&lt;p&gt;尽管 OpenTelemetry 关于度量的规范在 2022 年 5 月被宣布为稳定版本，但今年看到了其被广泛采用。以下是一些从业者的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 VMware 的 Matthew Kocher 和 Carson Long 撰写的文章，标题为“&lt;a href=&#34;https://opentelemetry.io/blog/2023/cloud-foundry/&#34; title=&#34;体验报告：在 Cloud Foundry 中采用 OpenTelemetry 进行度量&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;体验报告：在 Cloud Foundry 中采用 OpenTelemetry 进行度量&lt;/a&gt;”。&lt;/li&gt;
&lt;li&gt;我们自己的 Matheus Nogueira 撰写的文章，标题为“&lt;a href=&#34;https://tracetest.io/blog/adding-opentelemetry-metrics-in-your-go-app&#34; title=&#34;在你的 Go 应用程序中添加 OpenTelemetry 度量&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在你的 Go 应用程序中添加 OpenTelemetry 度量&lt;/a&gt;”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;展望 2024 年，可以预期会看到类似的日志运动和采用。&lt;/p&gt;
&lt;h2 id=&#34;关注在负载测试中使用分布式跟踪&#34;&gt;关注在负载测试中使用分布式跟踪&lt;/h2&gt;
&lt;p&gt;2023 年，两个领先的负载测试工具，&lt;a href=&#34;https://k6.io/&#34; title=&#34;Grafana k6&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana k6&lt;/a&gt;和&lt;a href=&#34;https://artillery.io/&#34; title=&#34;Artillery.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;，都添加了对 OpenTelemetry 的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana k6 &lt;a href=&#34;https://github.com/grafana/xk6-distributed-tracing&#34; title=&#34;引入了跟踪&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引入了跟踪&lt;/a&gt;功能，使性能工程师能够在&lt;a href=&#34;https://thenewstack.io/trace-based-testing-the-next-step-in-observability/&#34; title=&#34;负载测试&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;负载测试&lt;/a&gt;期间识别系统瓶颈或故障。&lt;/li&gt;
&lt;li&gt;Artillery.io 随后也&lt;a href=&#34;https://www.artillery.io/blog/introducing-opentelemetry-support&#34; title=&#34;添加了度量和分布式跟踪&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;添加了度量和分布式跟踪&lt;/a&gt;，提供了对系统性能更详细的分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tracetest 利用了 k6 测试中暴露的功能，以&lt;a href=&#34;https://docs.tracetest.io/tools-and-integrations/k6&#34; title=&#34;启用基于跟踪的负载测试&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;启用基于跟踪的负载测试&lt;/a&gt;，在运行测试时进行深入的断言。我们已经看到许多客户广泛使用了这个功能，比如&lt;a href=&#34;https://tracetest.io/case-studies/how-sigma-software-built-load-testing-for-their-microservices-with-k6-tracetest&#34; title=&#34;Sigma Software&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sigma Software&lt;/a&gt;。在 2024 年，Tracetest 团队将考虑将这一能力添加到&lt;a href=&#34;http://artillery.io/&#34; title=&#34;Artillery.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;和其他负载测试工具中。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的支持和用例扩展&#34;&gt;OpenTelemetry 的支持和用例扩展&lt;/h2&gt;
&lt;p&gt;越来越多的供应商正在采用 OpenTelemetry 标准，以支持典型但非常重要的遥测数据分析之外的行动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些公司，比如&lt;a href=&#34;https://opentelemetry.io/blog/2023/tyk-api-gateway/&#34; title=&#34;Tyk 正在仪器化其 API 网关，以原生支持 OpenTelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tyk 正在仪器化其 API 网关，以原生支持 OpenTelemetry&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;终端用户正在发现 OpenTelemetry 的新用例，比如&lt;a href=&#34;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/&#34; title=&#34;使用分布式跟踪来观察你的 CI/CD 流水线&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用分布式跟踪来观察你的 CI/CD 流水线&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/&#34; title=&#34;Tracetest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracetest&lt;/a&gt;利用分布式跟踪数据进行集成和端到端测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;强调-opentelemetry-收集器&#34;&gt;强调 OpenTelemetry 收集器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/how-adobe-uses-opentelemetry-collector/&#34; title=&#34;OpenTelemetry 收集器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器&lt;/a&gt;位于 OpenTelemetry 世界的中心，接收来自应用程序的信号，处理和转换这些信号，然后将它们导出到任意数量的后端系统。随着对 OpenTelemetry 的集成和供应商支持的扩展，对这个集中式收集器的需求和要求也在增加。&lt;/p&gt;
&lt;p&gt;2023 年引入了 OpenTelemetry Transformation Language (OTTL)，增强了 OpenTelemetry 收集器处理和转换传入信号的能力。&lt;/p&gt;
&lt;p&gt;在 Tracetest 中，我们能够利用&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/filterprocessor/README.md&#34; title=&#34;在过滤器处理器中使用 OTTL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在过滤器处理器中使用 OTTL&lt;/a&gt;的能力，改进了我们从输出大量遥测数据的生产环境中收集跟踪数据的方式。这一变化对&lt;a href=&#34;https://tracetest.io/blog/opentelemetry-collectors-new-filter-processor&#34; title=&#34;OpenTelemetry 收集器的过滤器处理器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器的过滤器处理器&lt;/a&gt;使 Tracetest 适用于在高负载环境中运行测试，包括生产环境。&lt;/p&gt;
&lt;h2 id=&#34;无处不在的可观测性&#34;&gt;无处不在的可观测性&lt;/h2&gt;
&lt;p&gt;在最近的讨论中，我们发现了一种客户中不断增长的趋势，即“无处不在的可观测性”方法。这些公司不仅限于由网站可靠性工程师和 DevOps 传统使用，还包括了每个人，包括开发人员和测试人员，参与到可观测性中。这种转变重新定义&lt;/p&gt;
&lt;p&gt;了可观测性，使其从生产问题的一种反应性工具变成了在开发和测试中都有益的一种主动工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.honeycomb.io/&#34; title=&#34;Honeycomb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb&lt;/a&gt;强调了&lt;a href=&#34;https://www.honeycomb.io/blog/observability-driven-development&#34; title=&#34;在开发过程中使用可观测性&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在开发过程中使用可观测性&lt;/a&gt;，而像&lt;a href=&#34;http://digma.ai/&#34; title=&#34;Digma.ai&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Digma.ai&lt;/a&gt;和 Tracetest 这样的工具正在推动这一前进。&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 的主要作用一直局限于仪器化后端系统，而基于开放标准的浏览器仪器化仍然是实验性的，进展缓慢。正在努力改进和标准化这种仪器化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/case-studies/how-uzufly-built-end-to-end-testing-serverless-web-app-with-distributed-traces&#34; title=&#34;Uzufly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Uzufly&lt;/a&gt;在这方面脱颖而出。它使用现有的客户端仪器化来构建测试。展望未来，它的雄心是扩展基于跟踪的测试，以覆盖浏览器内部发起的前端操作所进行的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将实现前端和后端的全面端到端测试。请关注 2024 年更多关于这个主题的信息！&lt;/p&gt;
&lt;h2 id=&#34;2023-已经过去&#34;&gt;2023 已经过去&lt;/h2&gt;
&lt;p&gt;告别 2023，我们怀着热情期待 2024 年的到来。OpenTelemetry 具有势头，得到了标准和广泛采用的支持，推动了其增长。新的一年承诺带来令人兴奋的发展，围绕 OpenTelemetry 出现了创新的产品和用例。我迫不及待地想看到 2024 年将揭示的进步和创新。愿 OpenTelemetry 长存！&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>OpenTelemetry Protocol (OTLP) 1.0.0 发布</title>
      <link>https://jimmysong.io/trans/otlp-version-one-released/</link>
      <pubDate>Sun, 06 Aug 2023 13:05:42 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/otlp-version-one-released/</guid>
      <description>
        
        
        &lt;p&gt;最近，&lt;a href=&#34;https://opentelemetry.io/&#34; title=&#34;OpenTelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; Protocol (OTLP) 1.0.0 发布了。OTLP 规范描述了遥测数据在遥测源、收集器等中间节点和遥测后端之间的编码、传输和传递机制。它是 OpenTelemetry 项目中设计的通用遥测数据传递协议。&lt;/p&gt;
&lt;p&gt;OpenTelemetry (OTEL) 是一个由 OpenCensus 和 OpenTracing 项目合并形成的开源 Cloud Native Computing Foundation (CNCF) 项目。它是一个供仪表化、生成、收集和导出遥测数据（例如跟踪、指标和日志）使用的供应商中立的开源可观测性框架。该框架提供了一组 API、库、代理和收集器服务，用于捕获分布式跟踪和指标。此外，它的规范在 2021 年早些时候达到了 1.0.0 版本状态，并被 InfoQ 报道。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 通过使用 API 来仪表化应用程序代码，以生成遥测数据，并在不同的 SDK 实现之间无缝地引导收集指标。它提供了针对特定语言的集成和库，例如 Java、Golang、.NET 和 Python 的 OTel SDK，以使开发人员能够仪表化其代码并捕获遥测数据。这些库中的遥测数据被收集并传输到 OpenTelemetry Collector，利用 OTLP 在客户端和服务器之间进行数据交换。OTLP 定义了一个序列化模式，紧密遵循跟踪、指标和日志的数据模型。&lt;/p&gt;
&lt;p&gt;作为中央存储库，OpenTelemetry Collector 接收、处理和导出从各种源收集的遥测数据，既作为单个应用程序的本地代理，也作为多个应用程序的网关。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/trans/otlp-version-one-released/otel-diagram.svg&#34; data-img=&#34;/trans/otlp-version-one-released/otel-diagram.svg&#34; alt=&#34;image&#34; data-caption=&#34;OpenTelemetry 架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;OpenTelemetry 架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Open Telemetry Diagram（来源：&lt;a href=&#34;https://opentelemetry.io/docs/&#34; title=&#34;OpenTelemetry 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 文档&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OTLP 在数据序列化、反序列化和网络服务之间的传输方面发挥着重要作用。该协议旨在指定一个序列化模式，紧密遵循数据模型并解决其他遥测协议的问题。&lt;/p&gt;
&lt;p&gt;Honeycomb 开发者倡导者 &lt;a href=&#34;https://twitter.com/MartinDotNet&#34; title=&#34;Martin Thwaites&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Martin Thwaites&lt;/a&gt; 说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OTLP 是 OpenTelemetry 的生命力，使其比以往任何时候都更强大；转向 v1 将把这一点提升到一个新的水平。已经有大多数供应商适应了使用 OTLP 协议接收数据；通过 V1，这将给人们带来一些急需的信心，希望可以让最后几个顽固分子添加 OTLP 支持。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;此外，他表示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这很重要，因为它开启了更多的互操作性，减少了添加专有协议库到我们堆栈中的需求，这对于希望更好地了解其应用程序的情况下获得更多可见性的人来说只能是一个胜利。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;最后，OpenTelemetry 项目目前是 CNCF 的&lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;孵化项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;孵化项目&lt;/a&gt;。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>如何在 Istio 中使用 SkyWalking 进行分布式追踪？</title>
      <link>https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/</link>
      <pubDate>Wed, 07 Dec 2022 11:09:40 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/</guid>
      <description>
        
        
        &lt;p&gt;在云原生应用中，一次请求往往需要经过一系列的 API 或后台服务处理才能完成，这些服务有些是并行的，有些是串行的，而且位于不同的平台或节点。那么如何确定一次调用的经过的服务路径和节点以帮助我们进行问题排查？这时候就需要使用到分布式追踪。&lt;/p&gt;
&lt;p&gt;本文将向你介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式追踪的原理&lt;/li&gt;
&lt;li&gt;如何选择分布式追踪软件&lt;/li&gt;
&lt;li&gt;在 Istio 中如何使用分布式追踪&lt;/li&gt;
&lt;li&gt;以 Bookinfo 和 SkyWalking 为例说明如何查看分布式追踪数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tracing-basic&#34;&gt;分布式追踪基础&lt;/h2&gt;
&lt;p&gt;分布式追踪是一种用来跟踪分布式系统中请求的方法，它可以帮助用户更好地理解、控制和优化分布式系统。分布式追踪中用到了两个概念：TraceID 和 SpanID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TraceID 是一个全局唯一的 ID，用来标识一个请求的追踪信息。一个请求的所有追踪信息都属于同一个 TraceID，TraceID 在整个请求的追踪过程中都是不变的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SpanID 是一个局部唯一的 ID，用来标识一个请求在某一时刻的追踪信息。一个请求在不同的时间段会产生不同的 SpanID，SpanID 用来区分一个请求在不同时间段的追踪信息；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TraceID 和 SpanID 是分布式追踪的基础，它们为分布式系统中请求的追踪提供了一个统一的标识，方便用户查询、管理和分析请求的追踪信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/basic.svg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/basic.svg&#34; alt=&#34;image&#34; data-caption=&#34;分布式追踪原理图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;分布式追踪原理图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;下面是分布式追踪的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个系统收到请求后，分布式追踪系统会为该请求分配一个 TraceID，用于串联起整个调用链；&lt;/li&gt;
&lt;li&gt;分布式追踪系统会为该请求在系统内的每一次服务调用生成一个 SpanID 和 ParentID，用于记录调用的父子关系，没有 ParentID 的 Span 将作为调用链的入口；&lt;/li&gt;
&lt;li&gt;每个服务调用过程中都要传递 TraceID 和 SpanID；&lt;/li&gt;
&lt;li&gt;在查看分布式追踪时，通过 TraceID 查询某次请求的全过程；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;distributed-tracing-in-istio&#34;&gt;Istio 如何实现分布式追踪&lt;/h2&gt;
&lt;p&gt;Istio 中的分布式追踪是基于数据平面中的 Envoy 代理实现的。服务请求在被劫持到 Envoy 中后，Envoy 在转发请求时会附加大量 Header，其中与分布式追踪相关的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为 TraceID：&lt;code&gt;x-request-id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用于在 LightStep 追踪系统中建立 Span 的父子关系：&lt;code&gt;x-ot-span-context&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用于 Zipkin，同时适用于 Jaeger、SkyWalking，详见 &lt;a href=&#34;https://github.com/openzipkin/b3-propagation&#34; title=&#34;b3-propagation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;b3-propagation&lt;/a&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x-b3-traceid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-b3-spanid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-b3-parentspanid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-b3-sampled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-b3-flags&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于 Datadog：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x-datadog-trace-id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-datadog-parent-id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-datadog-sampling-priority&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于 SkyWalking：&lt;code&gt;sw8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用于 AWS X-Ray：&lt;code&gt;x-amzn-trace-id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这些 Header 的详细用法请参考 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers&#34; title=&#34;Envoy 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Envoy 会在 Ingress Gateway 中为你产生用于追踪的 Header，不论你的应用程序使用何种语言开发，Envoy 都会将这些 Header 转发到上游集群。但是，你还要对应用程序代码做一些小的修改，才能为使用分布式追踪功能。这是因为应用程序无法自动传播这些 Header，可以在程序中集成分布式追踪的 Agent，或者在代码中手动传播这些 Header。Envoy 会将追踪数据发送到 tracer 后端处理，然后就可以在 UI 中查看追踪数据了。&lt;/p&gt;
&lt;p&gt;例如在 Bookinfo 应用中的 Productpage 服务，如果你查看它的代码可以发现，其中集成了 Jaeger 客户端库，并在 &lt;code&gt;getForwardHeaders (request)&lt;/code&gt; 方法中将 Envoy 生成的 Header 同步给对 Details 和 Reviews 服务的 HTTP 请求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getForwardHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 使用 Jaeger agent 获取 x-b3-* header&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_current_span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;tracer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;span_context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTTP_HEADERS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 手动处理非 x-b3-* header&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;end-user&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;incoming_headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-request-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-ot-span-context&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-trace-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-parent-id&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-datadog-sampling-priority&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;traceparent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;tracestate&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;x-cloud-trace-context&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;grpc-trace-bin&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;sw8&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;user-agent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;cookie&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;authorization&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;jwt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;incoming_headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ihdr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于 Istio 中分布式追踪的常见问题请见 &lt;a href=&#34;https://istio.io/latest/zh/about/faq/#distributed-tracing&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;how-to-choose-a-distributed-tracing-system&#34;&gt;分布式追踪系统如何选择&lt;/h2&gt;
&lt;p&gt;分布式追踪系统的原理类似，市面上也有很多这样的系统，例如 &lt;a href=&#34;https://github.com/apache/skywalking&#34; title=&#34;Apache SkyWalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt;、&lt;a href=&#34;https://github.com/jaegertracing/jaeger&#34; title=&#34;Jaeger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jaeger&lt;/a&gt;、&lt;a href=&#34;https://github.com/openzipkin/zipkin/&#34; title=&#34;Zipkin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt;、LightStep、&lt;a href=&#34;https://github.com/pinpoint-apm/pinpoint&#34; title=&#34;Pinpoint&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pinpoint&lt;/a&gt; 等。我们将选择其中三个，从多个维度进行对比。之所以选择它们是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是当前最流行的开源分布式追踪系统；&lt;/li&gt;
&lt;li&gt;都是基于 OpenTracing 规范；&lt;/li&gt;
&lt;li&gt;都支持与 Istio 及 Envoy 集成；&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类别&lt;/th&gt;
          &lt;th&gt;Apache SkyWalking&lt;/th&gt;
          &lt;th&gt;Jaeger&lt;/th&gt;
          &lt;th&gt;Zipkin&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;实现方式&lt;/td&gt;
          &lt;td&gt;基于语言的探针、服务网格探针、eBPF agent、第三方指标库（当前支持 Zipkin）&lt;/td&gt;
          &lt;td&gt;基于语言的探针&lt;/td&gt;
          &lt;td&gt;基于语言的探针&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;数据存储&lt;/td&gt;
          &lt;td&gt;ES、H2、MySQL、TiDB、Sharding-sphere、BanyanDB&lt;/td&gt;
          &lt;td&gt;ES、MySQL、Cassandra、内存&lt;/td&gt;
          &lt;td&gt;ES、MySQL、Cassandra、内存&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;支持语言&lt;/td&gt;
          &lt;td&gt;Java、Rust、PHP、NodeJS、Go、Python、C++、.NET、Lua&lt;/td&gt;
          &lt;td&gt;Java、Go、Python、NodeJS、C#、PHP、Ruby、C++&lt;/td&gt;
          &lt;td&gt;Java、Go、Python、NodeJS、C#、PHP、Ruby、C++&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;发起者&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;Uber&lt;/td&gt;
          &lt;td&gt;Twitter&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;治理方式&lt;/td&gt;
          &lt;td&gt;Apache Foundation&lt;/td&gt;
          &lt;td&gt;CNCF&lt;/td&gt;
          &lt;td&gt;CNCF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;版本&lt;/td&gt;
          &lt;td&gt;9.3.0&lt;/td&gt;
          &lt;td&gt;1.39.0&lt;/td&gt;
          &lt;td&gt;2.23.19&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Star 数量&lt;/td&gt;
          &lt;td&gt;20.9k&lt;/td&gt;
          &lt;td&gt;16.8k&lt;/td&gt;
          &lt;td&gt;15.8k&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption class=&#34;text-center&#34;&gt;
    
    分布式追踪系统对比表（数据截止时间 2022-12-07）
    
&lt;/figcaption&gt;

&lt;p&gt;虽然 Apache SkyWalking 的 Agent 支持的语言没有 Jaeger 和 Zipkin 多，但是 SkyWalking 的实现方式更丰富，并且与 Jaeger、Zipkin 的追踪数据兼容，开发更为活跃，且为国人开发，中文资料丰富，是构建遥测平台的最佳选择之一。&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;实验&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://istio.io/latest/docs/tasks/observability/distributed-tracing/skywalking/&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;来安装和配置 Apache SkyWalking。&lt;/p&gt;
&lt;h3 id=&#34;environments&#34;&gt;环境说明&lt;/h3&gt;
&lt;p&gt;以下是我们实验的环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 1.24.5&lt;/li&gt;
&lt;li&gt;Istio 1.16&lt;/li&gt;
&lt;li&gt;SkyWalking 9.1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;install-istio&#34;&gt;安装 Istio&lt;/h3&gt;
&lt;p&gt;安装之前可以先检查下环境是否有问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ istioctl experimental precheck
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✔ No issues found when checking the cluster. Istio is safe to install or upgrade!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  To get started, check out https://istio.io/latest/docs/setup/getting-started/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 &lt;code&gt;istioctl&lt;/code&gt; 安装 Istio 同时配置发送追踪信息的目的地为 SkyWalking：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将安装配置保存到文件中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat&lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF&amp;gt;istio-install.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: install.istio.io/v1alpha1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: IstioOperator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: istio-with-skywalking
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  meshConfig:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    defaultProviders:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      tracing:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      - &amp;#34;skywalking&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    enableTracing: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    extensionProviders:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - name: &amp;#34;skywalking&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      skywalking:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        service: tracing.istio-system.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        port: 11800
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用 istioctl 安装 Istio&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -f istio-install.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;install-skywalking&#34;&gt;部署 Apache SkyWalking&lt;/h3&gt;
&lt;p&gt;Istio 1.16 支持使用 Apache SkyWalking 进行分布式追踪，执行下面的代码安装 SkyWalking：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/addons/extras/skywalking.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它将在 &lt;code&gt;istio-system&lt;/code&gt; 命名空间下安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SkyWalking OAP (Observability Analysis Platform) ：用于接收追踪数据，支持 SkyWalking 原生数据格式，Zipkin v1 和 v2 以及 Jaeger 格式。&lt;/li&gt;
&lt;li&gt;UI：用于查询分布式追踪数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 SkyWalking 的详细信息请参考 SkyWalking 文档。&lt;/p&gt;
&lt;h3 id=&#34;install-bookinfo&#34;&gt;部署 Bookinfo 应用&lt;/h3&gt;
&lt;p&gt;执行下面的命令安装 bookinfo 示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl label namespace default istio-injection&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;enabled
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后给 productpage 服务发送请求，如果你是在 Kind 中安装的 Istio，则默认的 IngressGateway 将是 LoadBalancer 类型，你可以使用端口转发的方式来暴露网关。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward -n istio-system svc/istio-ingressgateway 8081:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 &lt;code&gt;http://localhost:8081/productpage&lt;/code&gt; 就可以访问到 productpage 服务。多访问几次来制造一些流量，后面我们就能在 SkyWalking UI 上看到拓扑图了。&lt;/p&gt;
&lt;p&gt;打开 SkyWalking UI：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl dashboard skywalking
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SkyWalking 的 General Service 页面展示了 bookinfo 应用中的所有服务。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/general-service_hu_9fdbbc7c2dadf302.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/general-service.jpg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/general-service.jpg&#34; data-width=&#34;1622&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;SkyWalking 的 General Service 页面&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;SkyWalking 的 General Service 页面&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;你还可以看到实例、端点、拓扑、追踪等信息。例如下图展示了 bookinfo 应用的服务拓扑。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/topology_hu_36d38c181d7d208b.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/topology.jpg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/topology.jpg&#34; data-width=&#34;1622&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;Bookinfo 应用的服务拓扑&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Bookinfo 应用的服务拓扑&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;SkyWalking 的追踪视图有多种显示形式，如列表、树形、表格和统计。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/gs-styles_hu_84741d16d69e10f0.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/gs-styles.jpg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/gs-styles.jpg&#34; data-width=&#34;2062&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;SkyWalking 通用服务追踪支持多种显示样式&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;SkyWalking 通用服务追踪支持多种显示样式&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;为了方便我们检查，将追踪的采样率设置为 100%：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: telemetry.istio.io/v1alpha1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: Telemetry
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: mesh-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  tracing:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - randomSamplingPercentage: 100.00
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;purge&#34;&gt;卸载&lt;/h3&gt;
&lt;p&gt;在实验完后，执行下面的命令卸载 Istio 和 SkyWalking：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;samples/bookinfo/platform/kube/cleanup.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl unintall --purge
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl delete namespace istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;bookinfo-tracing&#34;&gt;Bookinfo demo 追踪信息说明&lt;/h2&gt;
&lt;p&gt;在 Apache SkyWalking UI 中导航到 General Service 分页，查看最近的 &lt;code&gt;istio-ingressgateway&lt;/code&gt; 服务的追踪信息，表视图如下所示。图中展示了此次请求所有 Span 的基本信息，点击每个 Span 可以查看详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/span-table_hu_8be8cb0f29152da2.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/span-table.jpg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/span-table.jpg&#34; data-width=&#34;1495&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;表格视图中显示了 Span 的基本信息&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;表格视图中显示了 Span 的基本信息&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;切换为列表视图，可以看到每个 Span 的执行顺序及持续时间，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/trace-list_hu_dd05aeb18b5d6253.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/trace-list.jpg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/trace-list.jpg&#34; data-width=&#34;1190&#34; data-height=&#34;816&#34; alt=&#34;image&#34; data-caption=&#34;列表视图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;列表视图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;你可能会感到困惑，为什么这么简单的一个应用会产生如此多的 Span 信息？因为我们为 Pod 注入了 Envoy 代理之后，每个服务间的请求都会被 Envoy 拦截和处理，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/span.svg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/span.svg&#34; alt=&#34;image&#34; data-caption=&#34;Envoy 拦截请求产生 Span&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Envoy 拦截请求产生 Span&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;整个追踪流程如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/distributed-tracing-with-skywalking-in-istio/bookinfo-spans-with-time.svg&#34; data-img=&#34;/blog/distributed-tracing-with-skywalking-in-istio/bookinfo-spans-with-time.svg&#34; alt=&#34;image&#34; data-caption=&#34;Bookinfo 的分布式追踪痕迹&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Bookinfo 的分布式追踪痕迹&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;图中给每一个 Span 标记了序号，并在括号里注明了耗时。为了便于说明我们将所有 Span 汇总在下面的表格中。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;序号&lt;/th&gt;
          &lt;th&gt;方法&lt;/th&gt;
          &lt;th&gt;总耗时（ms）&lt;/th&gt;
          &lt;th&gt;组件耗时（ms）&lt;/th&gt;
          &lt;th&gt;当前服务&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;/productpage&lt;/td&gt;
          &lt;td&gt;190&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;istio-ingressgateway&lt;/td&gt;
          &lt;td&gt;Envoy Outbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;/productpage&lt;/td&gt;
          &lt;td&gt;190&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;istio-ingressgateway&lt;/td&gt;
          &lt;td&gt;Ingress -&amp;gt; Productpage 网络传输&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;/productpage&lt;/td&gt;
          &lt;td&gt;189&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;Envoy Inbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;/productpage&lt;/td&gt;
          &lt;td&gt;188&lt;/td&gt;
          &lt;td&gt;21&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;应用内部处理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;/details/0&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;Envoy Outbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;/details/0&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;Productpage -&amp;gt; Details 网络传输&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;/details/0&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;details&lt;/td&gt;
          &lt;td&gt;Envoy Inbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;/details/0&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;details&lt;/td&gt;
          &lt;td&gt;应用内部&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;9&lt;/td&gt;
          &lt;td&gt;/reviews/0&lt;/td&gt;
          &lt;td&gt;159&lt;/td&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;Envoy Outbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;10&lt;/td&gt;
          &lt;td&gt;/reviews/0&lt;/td&gt;
          &lt;td&gt;159&lt;/td&gt;
          &lt;td&gt;14&lt;/td&gt;
          &lt;td&gt;productpage&lt;/td&gt;
          &lt;td&gt;Productpage -&amp;gt; Reviews 网络传输&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;11&lt;/td&gt;
          &lt;td&gt;/reviews/0&lt;/td&gt;
          &lt;td&gt;145&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;reviews&lt;/td&gt;
          &lt;td&gt;Envoy Inbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;12&lt;/td&gt;
          &lt;td&gt;/reviews/0&lt;/td&gt;
          &lt;td&gt;144&lt;/td&gt;
          &lt;td&gt;109&lt;/td&gt;
          &lt;td&gt;reviews&lt;/td&gt;
          &lt;td&gt;应用内部处理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;13&lt;/td&gt;
          &lt;td&gt;/ratings/0&lt;/td&gt;
          &lt;td&gt;35&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;reviews&lt;/td&gt;
          &lt;td&gt;Envoy Outbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;14&lt;/td&gt;
          &lt;td&gt;/ratings/0&lt;/td&gt;
          &lt;td&gt;33&lt;/td&gt;
          &lt;td&gt;16&lt;/td&gt;
          &lt;td&gt;reviews&lt;/td&gt;
          &lt;td&gt;Reviews -&amp;gt; Ratings 网络传输&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;15&lt;/td&gt;
          &lt;td&gt;/ratings/0&lt;/td&gt;
          &lt;td&gt;17&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;ratings&lt;/td&gt;
          &lt;td&gt;Envoy Inbound&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;16&lt;/td&gt;
          &lt;td&gt;/ratings/0&lt;/td&gt;
          &lt;td&gt;16&lt;/td&gt;
          &lt;td&gt;16&lt;/td&gt;
          &lt;td&gt;ratings&lt;/td&gt;
          &lt;td&gt;应用内部处理&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从以上信息可以发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本次请求总耗时 190ms；&lt;/li&gt;
&lt;li&gt;在 Istio sidecar 模式下，每次流量在进出应用容器时都需要经过一次 Envoy 代理，每次耗时在 0 到 2 ms；&lt;/li&gt;
&lt;li&gt;在 Pod 间的网络请求耗时在 1 到 16ms 之间；&lt;/li&gt;
&lt;li&gt;将耗时做多的调用链 Ingress Gateway -&amp;gt; Productpage -&amp;gt; Reviews -&amp;gt; Ratings 上的所有耗时累计 182 ms，小于请求总耗时 190ms，这是因为数据本身有误差，以及 Span 的开始时间并不一定等于父 Span 的结束时间，如果你在 SkyWalking 的追踪页面，选择「列表」样式查看追踪数据（见图 2）可以更直观的发现这个问题；&lt;/li&gt;
&lt;li&gt;我们可以查看到最耗时的部分是 Reviews 应用，耗时 109ms，因此我们可以针对该应用进行优化；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;只要对应用代码稍作修改就可以在 Istio 很方便的使用分布式追踪功能。在 Istio 支持的众多分布式追踪系统中，&lt;a href=&#34;https://skywalking.apache.org/&#34; title=&#34;Apache SkyWalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt; 是其中的佼佼者。它不仅支持分布式追踪，还支持指标和日志收集、报警、Kubernetes 和服务网格监控，&lt;a href=&#34;https://skywalking.apache.org/zh/diagnose-service-mesh-network-performance-with-ebpf/&#34; title=&#34;使用 eBPF 诊断服务网格性能&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 eBPF 诊断服务网格性能&lt;/a&gt;等功能，是一个功能完备的云原生应用分析平台。本文中为了方便演示，将追踪采样率设置为了 100%，在生产使用时请根据需要调整采样策略（采样百分比），防止产生过多的追踪日志。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/zh/docs/tasks/observability/distributed-tracing/overview/&#34; title=&#34;Istio 分布式追踪概览 - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 分布式追踪概览 - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/zh/about/faq/#distributed-tracing&#34; title=&#34;Istio 分布式追踪 FAQ - istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 分布式追踪 FAQ - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>KubeCon 北美 2022 可观测性开放日见闻</title>
      <link>https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/</link>
      <pubDate>Wed, 09 Nov 2022 09:16:27 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/</guid>
      <description>
        
        
        &lt;p&gt;2022 年 10 月底，作为在底特律举行的完整 KubeCon 和 CloudNativeCon 活动之前的场外活动，&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/&#34; title=&#34;Open Observability Day&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Observability Day&lt;/a&gt; 为期一天的活动首次举行。&lt;/p&gt;
&lt;p&gt;活动会场在亨廷顿广场会议中心，可以看到河对面加拿大的景色（很多人都不知道底特律离美国北部边境如此之近） 。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_hu_ae6322ee85dc59c1.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi.jpg&#34; data-img=&#34;/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;662&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;Open Observability Day 的&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/program/schedule/&#34; title=&#34;完整时间表可在线获得&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;完整时间表可在线获得&lt;/a&gt;，今天我想分享一下在那里的感受。&lt;/p&gt;
&lt;p&gt;这一天以所有与开放可观测性相关的 CNCF 项目为中心，充斥了供应商和以项目为中心的演讲。&lt;/p&gt;
&lt;p&gt;活动从 CNCF 项目创始人 Bartek Płotka 的概述开始，他叙述了 Thanos、Fluntd、OpenTelemetry、Jeager 等项目的更新。然后过渡到两个简短的主题演讲。&lt;/p&gt;
&lt;h2 id=&#34;分布式追踪斗争是真实的&#34;&gt;分布式追踪：斗争是真实的&lt;/h2&gt;
&lt;p&gt;Chronosphere 的现场首席技术官 Ian Smith 分享了他在该领域从事分布式跟踪解决方案 9 年后的想法。他带我们进行了一次旋风之旅，了解了它的来源和可能的发展方向，以及围绕支持分布式跟踪的工具存在哪些技术问题。下面是他给出的 tips：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;追踪已成为高承诺、高努力、低价值的故事。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;他继续强调对开发人员工具的关注需要如何扭转这种局面，并开始以更少的努力和更多的价值提供一些承诺。&lt;/p&gt;
&lt;h2 id=&#34;简化可观测性&#34;&gt;简化可观测性&lt;/h2&gt;
&lt;p&gt;Calyptia 首席执行官 Eduardo Silva 分享了从创建 Fluentd 项目到专注于云原生环境的新 Fluent-bit 项目的故事。然后，他介绍了他们在构建 Fluent Bit 项目的日志空间方面的经验，以及如何扩展生态系统以支持指标和追踪，从而帮助塑造简化的用户可观测性体验。他宣布发布 Calyptia Core，使用开源工具通过数据管道收集数据，而无需使用代理。现在可以免费使用，并且可以安装到现有的 Kubernetes 集群中。他们还有一个 Docker 桌面扩展。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hu_d3bdeaaabda26227.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82.jpg&#34; data-img=&#34;/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;750&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;两个主题演讲都很短，只有 10 分钟，之后主要演讲开始了。&lt;/p&gt;
&lt;h2 id=&#34;使用-fluent-bit-构建可观测性管道&#34;&gt;使用 Fluent Bit 构建可观测性管道&lt;/h2&gt;
&lt;p&gt;LinkedIn 的 Chao Xu 谈到了他们如何从现有的可观测性管道封闭工具过渡到开源和开放标准。他们主要使用 Fluent Bit 和 Open Telemetry。他们还将语言工具从 Java 应用程序扩展到 Go、C++ 和 Python。他们将跟踪和日志整合到单个管道中，而不是单独的数据管道中，从而创建更简单的维护标准和更少的资源负载。他们是 OTEL 收集器的忠实信徒，但他们将其扩展为新扩展的可观测性代理，以支持数据转换和过滤以及 OTEL 数据流的摄取。LinkedIn 也非常喜欢 Fluent Bit 提供的用于处理各种数据流的增强标签管理。&lt;/p&gt;
&lt;h2 id=&#34;为什么大规模可观测性需要图&#34;&gt;为什么大规模可观测性需要图&lt;/h2&gt;
&lt;p&gt;SquaredUp 的 Richard Benwell 深入研究了可观测性 Wikipedia 页面，这是一种相当有趣的方式来尝试构建我们所说的可观测性的基础。他用它来表明我们有带有指标、日志和跟踪的信号，但是我们在当前的可观测性平台中缺少我们的系统模型。这个演讲假设没有模型，信号是无用的。他继续使用架构作为我们正在收集的指标、日志和跟踪的模型。这就引出了一个问题：你是否需要架构师来设计模型，或者你是否只是像跟踪工具那样生成模型？此外，该模型很好（它有助于理解），但你需要能够深入了解你正在收集和建模的数据的含义。然后演讲深入到我们大学都学习过的图入门课程，从顶点到边到顶点类型的故事。它唤起了人们对数学课程和人工智能领域建模的美好回忆，以解决医疗诊断等问题领域。&lt;/p&gt;
&lt;h2 id=&#34;对混沌的-kubernetes-可观测性充满信心&#34;&gt;对混沌的 Kubernetes 可观测性充满信心&lt;/h2&gt;
&lt;p&gt;来自 GitLab 的 Michael Friedrich 分享了我们如何从运行云原生环境转变为使用 Prometheus、Perces、Graphans 等 CNCF 项目监控。现在我们被所有传入的数据所淹没，这不是一个新概念。所以现在我们有了这个，他分享了一些关于故意破坏事物的想法，以了解它的行为、监控和恢复方式。他强调了 Chaos Mesh 项目，这是一个有趣的想法，即如何查看整个环境将如何响应问题。演讲以 Chaos Mesh 使用的现场演示结束。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_hu_3a28c35db13da74b.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm.jpg&#34; data-img=&#34;/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm.jpg&#34; data-width=&#34;750&#34; data-height=&#34;1000&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;午餐前后有几个闪电演讲，只有短短的 10 分钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 FluentBit 实现云和边缘的统一可观测性&lt;/li&gt;
&lt;li&gt;通过自动发现的安全策略理解可观测性&lt;/li&gt;
&lt;li&gt;通过 OpAMP 协议管理 OpenTelemetry&lt;/li&gt;
&lt;li&gt;如何为可观测性构建数据管道&lt;/li&gt;
&lt;li&gt;eBPF 实际上可以为现代可观测性做什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下午结束了完整的分组会议：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu_60c8c7ec2efa1e97.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au.jpg&#34; data-img=&#34;/trans/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au.jpg&#34; data-width=&#34;750&#34; data-height=&#34;1000&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;在-ebay-采用开放遥测收集器在飞行中换引擎&#34;&gt;在 eBay 采用开放遥测收集器：在飞行中换引擎&lt;/h2&gt;
&lt;p&gt;来自 eBay 的 Vijay Samuel 分享了从 Elastic Beats for traces 迁移到 Open Telemetry 的经验。他谈到了他们的云原生规模、遇到的问题、从 Metric Beats 到 OTEL 收集器的旅程、弥合动态配置重新加载的差距以及确保迁移后的数据奇偶性。这很有趣，他们正在招聘工程师。&lt;/p&gt;
&lt;h2 id=&#34;使用--opentelemetry-的-prometheus-管道&#34;&gt;使用  OpenTelemetry 的 Prometheus 管道&lt;/h2&gt;
&lt;p&gt;来自 Grafana Labs 和作为 Prometheus 维护者超过五年的 Goutham Veeramachaneni 分享了如何在 Prometheus 数据管道中利用 OTEL 来为你的指标基础设施添加追踪。&lt;/p&gt;
&lt;p&gt;这个概述不包括今天举行的所有会谈，但给人留下了很好的印象。我必须承认，由于在休息期间出现的网络问题，我无法跟上所有会话。有几次，我进行了深入的讨论，使我在大厅或展位上的时间比计划的休息时间更长，但这就是这些活动的目的！&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>如何在产品中引入 eBPF 以增加可观测性</title>
      <link>https://jimmysong.io/trans/how-to-add-bpf-observability/</link>
      <pubDate>Thu, 27 Jan 2022 09:24:17 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/how-to-add-bpf-observability/</guid>
      <description>
        
        
        &lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文译自 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html&#34; title=&#34;How To Add eBPF Observability To Your Product&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How To Add eBPF Observability To Your Product&lt;/a&gt;，原文发布于 2021 年 7 月 3 日。本文作者 Brendan Gregg 是 eBPF 领域的专家，出版过多本相关书籍，本文是他给想要在产品中引入 eBPF 增加可观测性人员的忠告。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;现在有一场军备竞赛，即增加 eBPF 的军备竞赛，在这篇文章中，我将介绍如何快速做到这一点。这也适用于人们将其添加到自己的内部监测系统中。&lt;/p&gt;
&lt;p&gt;人们喜欢在他们建立了原型或构建了产品之后向我展示他们的 BPF 可观测性产品，但我常常在他们开始之前给出建议。作为 BPF 可观测性的领导者，这是我在最近的谈话中一直包含的建议，现在我把它纳入这篇文章中。&lt;/p&gt;
&lt;p&gt;首先，我知道你很忙。你甚至可能不喜欢 BPF。为了务实起见，我将描述如何花最少的精力来获得最大的价值。把这看成是“第一版”。一个相当有用的出发点。无论你是否遵循这个建议，至少请你理解它，以避免以后的遗憾和痛苦。&lt;/p&gt;
&lt;p&gt;如果你正在使用开源监控平台，首先检查它是否已经有一个 BPF 代理。这篇文章假设它没有，而且你将首次添加一些东西。&lt;/p&gt;
&lt;h2 id=&#34;1-运行第一个工具&#34;&gt;1. 运行第一个工具&lt;/h2&gt;
&lt;p&gt;首先安装 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具。例如，Ubuntu 上的 bcc。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# apt-get install bpfcc-tools&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后尝试运行一个工具。例如，使用 execsnoop (8) 查看带有时间戳的进程执行情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# execsnoop-bpfcc -T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TIME     PCOMM            PID    PPID   RET ARGS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 service          &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;6009&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/sbin/service --status-all
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828568&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828569&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/basename /usr/sbin/service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 env              &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/env -i &lt;span class=&#34;nv&#34;&gt;LANG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU.UTF-8 &lt;span class=&#34;nv&#34;&gt;LANGUAGE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU:en &lt;span class=&#34;nv&#34;&gt;LC_CTYPE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NUMERIC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_COLLATE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MONETARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_PAPER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ADDRESS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TELEPHONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MEASUREMENT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_IDENTIFICATION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ALL&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/opt/local/bin:/opt/local/sbin:/usr/local/git/bin:/home/bgregg/.local/bin:/home/bgregg/bin:/opt/local/bin:/opt/local/sbin:/ &lt;span class=&#34;nv&#34;&gt;TERM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;xterm-256color /etc/init.d/acpid 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 acpid            &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /etc/init.d/acpid status
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 run-parts        &lt;span class=&#34;m&#34;&gt;828571&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/run-parts --lsbsysinit --list /lib/lsb/init-functions.d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 systemctl        &lt;span class=&#34;m&#34;&gt;828572&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/systemctl -p LoadState --value show acpid.service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 readlink         &lt;span class=&#34;m&#34;&gt;828573&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/readlink -f /etc/init.d/acpid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然很基本，但我仅用这个工具就解决了很多 perf 问题，包括针对配置错误的系统，其中一个 shell 脚本正在循环启动失败的进程，以及当一些小程序崩溃并每隔几分钟就重启但还没有被注意到时。&lt;/p&gt;
&lt;h2 id=&#34;2-为你的产品添加一个工具&#34;&gt;2. 为你的产品添加一个工具&lt;/h2&gt;
&lt;p&gt;现在想象一下将 execsnoop (8) 添加到你的产品中。你可能已经在你所有的客户系统上运行了代理。他们是否有办法运行一个命令并返回文本输出？或者运行一个命令并将输出发送到其他地方进行聚合（S3、Hive、Druid 等）？有很多选择，这实际上是你自己基于现有系统和客户环境的偏好。&lt;/p&gt;
&lt;p&gt;当你把第一个工具添加到你的产品中时，让它在短时间内运行，比如 10 到 60 秒。我刚刚注意到 execsnoop (8) 还没有持续时间选项，所以在这期间你可以用 &lt;code&gt;watch -s2 60 execsnoop-bpfcc&lt;/code&gt; 来包装它。如果你想 24 小时运行这些工具，首先要研究开销以了解成本。低频率的事件，如进程的执行，捕捉起来应该是可以忽略不计的。&lt;/p&gt;
&lt;p&gt;不使用 bcc，你也可以使用 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 版本。这些通常没有封装选项（-v、-l 等），但有一个 json 输出模式。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# bpftrace -f json execsnoop.bt &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;attached_probes&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;probes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;TIME(ms)   PID   ARGS\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;2737       849176 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;ls -F&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;5641       849178 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;date&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加这种模式是为了使 BPF 的可观测性产品可以建立在 bpftrace 之上。&lt;/p&gt;
&lt;h2 id=&#34;3-不要担心依赖性问题&#34;&gt;3. 不要担心依赖性问题&lt;/h2&gt;
&lt;p&gt;我建议你在客户系统上安装 bcc 或 bpftrace，它们目前有 llvm 依赖。这可能会增加到几十 MB，这对一些资源有限的环境（嵌入式）是个问题。我们一直在做大量的工作，以便在未来解决这个问题。 &lt;a href=&#34;https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html&#34; title=&#34;BTF and CO-RE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF and CO-RE&lt;/a&gt;（而不是 Python），最终将意味着你可以安装 100KB 的无依赖性的工具二进制版本。bpftrace 也有一个类似的计划，使用较新的内核特性生成一个小的无依赖性的二进制版本。&lt;/p&gt;
&lt;p&gt;这确实需要至少 Linux 5.8 才能很好地工作，而你的客户可能几年都不会运行这个系统。在这期间，我建议暂时不要担心 llvm 的依赖关系，因为它以后会被修复。&lt;/p&gt;
&lt;p&gt;请注意，并不是所有的 Linux 发行版都启用了 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt;，这对于 BTF 和 CO-RE 的未来是必要的。主要的发行版已经设置了它，比如在 Ubuntu 20.10、Fedora 30 和 RHEL 8.2。但如果你知道你的一些客户正在运行一些不常见的东西，请检查并鼓励他们或发行商设置 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt; 和 &lt;code&gt;CONFIG_DEBUG_INFO_BTF_MODULES=y&lt;/code&gt;，以避免未来的痛苦。&lt;/p&gt;
&lt;h2 id=&#34;4-第-1-版仪表板&#34;&gt;4. 第 1 版仪表板&lt;/h2&gt;
&lt;p&gt;现在你的产品中有了一个 BPF 可观测性工具，是时候增加更多的工具了。下面是你可以运行的十大工具，并作为一个通用的 BPF 可观测性仪表盘来展示，同时还有建议的可视化。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;编号&lt;/th&gt;
          &lt;th&gt;工具&lt;/th&gt;
          &lt;th&gt;展示&lt;/th&gt;
          &lt;th&gt;可视化&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1.&lt;/td&gt;
          &lt;td&gt;execsnoop&lt;/td&gt;
          &lt;td&gt;新进程（通过 exec (2)）&lt;/td&gt;
          &lt;td&gt;表格&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2.&lt;/td&gt;
          &lt;td&gt;opensnoop&lt;/td&gt;
          &lt;td&gt;打开的文件&lt;/td&gt;
          &lt;td&gt;表格&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3.&lt;/td&gt;
          &lt;td&gt;ext4slower&lt;/td&gt;
          &lt;td&gt;慢速文件系统 I/O&lt;/td&gt;
          &lt;td&gt;表格&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4.&lt;/td&gt;
          &lt;td&gt;biolatency&lt;/td&gt;
          &lt;td&gt;磁盘 I/O 延迟柱状图&lt;/td&gt;
          &lt;td&gt;热力图&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;5.&lt;/td&gt;
          &lt;td&gt;biosnoop&lt;/td&gt;
          &lt;td&gt;每个事件的磁盘 I/O 细节&lt;/td&gt;
          &lt;td&gt;表格，偏移热图&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;6.&lt;/td&gt;
          &lt;td&gt;cachestat&lt;/td&gt;
          &lt;td&gt;文件系统高速缓存统计&lt;/td&gt;
          &lt;td&gt;线状图&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;7.&lt;/td&gt;
          &lt;td&gt;tcplife&lt;/td&gt;
          &lt;td&gt;TCP 连接&lt;/td&gt;
          &lt;td&gt;表格，分布式图表&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;8.&lt;/td&gt;
          &lt;td&gt;tcpretrans&lt;/td&gt;
          &lt;td&gt;TCP 重传&lt;/td&gt;
          &lt;td&gt;表格&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;9.&lt;/td&gt;
          &lt;td&gt;runqlat&lt;/td&gt;
          &lt;td&gt;CPU 调度器的延迟&lt;/td&gt;
          &lt;td&gt;热力图&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;10.&lt;/td&gt;
          &lt;td&gt;profile&lt;/td&gt;
          &lt;td&gt;CPU 堆栈跟踪样本&lt;/td&gt;
          &lt;td&gt;火焰图&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是在我的 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/docs/tutorial.md&#34; title=&#34;bcc Tutorial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc Tutorial&lt;/a&gt; 的，而且很多也存在于 bpftrace 中。我选择这些是为了用最少的工具找到最大的性能优势。&lt;/p&gt;
&lt;p&gt;请注意，runqlat 和 profile 会有明显的开销，所以我只运行这些工具 10 到 60 秒，然后生成一份报告。有些工具的开销很低，如果需要的话可以 24 小时运行（例如 execsnoop、biolatency、tcplife、tcpretrans）。&lt;/p&gt;
&lt;p&gt;在 bcc 和 bpftrace 资源库中，已经有以手册和实例文件形式存在的文档，你可以链接到这些文档，以帮助你的客户了解工具的输出。例如，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/execsnoop_example.txt&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/iovisor/bpftrace/blob/master/tools/execsnoop_example.txt&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 有 execsnoop (8) 的示例文件。&lt;/p&gt;
&lt;p&gt;完成这些后，你就有了第一版的仪表板。&lt;/p&gt;
&lt;h2 id=&#34;bcc-与-bpftrace&#34;&gt;bcc 与 bpftrace&lt;/h2&gt;
&lt;p&gt;bcc 工具是最容易使用的，因为它们通常有很多命令行选项。bpftrace 工具更容易编辑和定制，而且 bpftrace 有一个 json 输出模式。&lt;/p&gt;
&lt;p&gt;如果你是追踪的新手，就用 bcc 吧。如果你想做一些黑客和定制的工具，就用 bpftrace。最后，它们都是不错的选择。&lt;/p&gt;
&lt;h2 id=&#34;案例研究netflix&#34;&gt;案例研究：Netflix&lt;/h2&gt;
&lt;p&gt;Netflix 正在建立一个新的 GUI，在这些工具的 bpftrace 版本的基础上，做这个工具仪表盘和更多的工作。架构如图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu_4130f5c06888eb71.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj.jpg&#34; data-img=&#34;/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;769&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;虽然 bpftrace 二进制文件安装在所有目标系统上，但 bpftrace 工具（文本文件）却在网络服务器上，并在需要时被推送出去。这意味着我们可以通过在一个地方更新工具来确保我们一直在运行最新版本的工具。&lt;/p&gt;
&lt;p&gt;这是目前我们 FlameCommander 用户界面的一部分，它也在云端运行火焰图。我们以前的 BPF GUI 是 &lt;a href=&#34;https://github.com/Netflix/vector&#34; title=&#34;Vector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vector&lt;/a&gt; 的一部分，并使用了 bcc，但我们后来废弃了它。我们可能会在某个时候开源新的 GUI，并在 Netflix 技术博客上发表相关文章。&lt;/p&gt;
&lt;h2 id=&#34;案例研究facebook&#34;&gt;案例研究：Facebook&lt;/h2&gt;
&lt;p&gt;Facebook 是 BPF 的高级用户，但他们如何在整个集群中运行工具的深层细节并没有完全公开。根据 bcc 的活动，以及他们对 BTF 和 CO-RE 技术的开发，我十分怀疑他们的解决方案是基于 bcc 的 libbpf-tool 版本。&lt;/p&gt;
&lt;h2 id=&#34;移植的陷阱&#34;&gt;移植的陷阱&lt;/h2&gt;
&lt;p&gt;BPF 追踪工具就像应用程序和内核的补丁。它们需要不断的更新以保持在不同的软件版本中工作。把它们移植到不同的语言，然后不维护它们，可能就像试图把 Linux 4.15 的补丁应用于 Linux 5.12。如果你运气好，它就会工作！如果你不走运，补丁就会应用，但会以一种微妙的方式破坏一些东西，直到后来你才注意到。这取决于工具。&lt;/p&gt;
&lt;p&gt;作为一个极端的例子，我在 2014 年休假时写了 cachestat (8)，用于 Netflix cloud，当时是 Linux 3.2 和 3.13 的混合版本。BPF 在这些版本上并不存在，所以我使用了 Linux 3.2 上的基本 Ftrace 功能。我把这种方法描述为 &lt;a href=&#34;https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html&#34; title=&#34;brittle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;brittle&lt;/a&gt;， &lt;a href=&#34;https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat&#34; title=&#34;sandcastle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sandcastle&lt;/a&gt; 需要随着内核的变化而进行维护。后来，它被移植到了带有 kprobes 的 BPF 上，现在已经被重写并包含在商业可观测性产品中。我听说它在较新的内核上有问题，打印的输出没有意义。它真的需要一次大修。当我（或某人）做了这个工作，任何从 bcc 上拉取更新的人都会自动得到固定的版本，不需要费力。那些重写的人将需要重写自己的版本。我担心他们不会这样做，而客户将在多年来一直运行一个错误的 cachestat (8) 版本。&lt;/p&gt;
&lt;p&gt;请注意，如果在我写 cachestat (8) 的时候，BPF 在我的目标环境中是可用的，我的编码方式就会完全不同。人们正在移植为 Linux 3.2 编写的东西，并在 Linux 5.x 上运行它。&lt;/p&gt;
&lt;p&gt;在以前的一篇博文 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-04/an-unbelievable-demo.html&#34; title=&#34;An Unbelievable Demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;An Unbelievable Demo&lt;/a&gt; 中，谈到了很多年前发生的类似情况，即在没有更新的情况下使用旧的追踪工具版本。&lt;/p&gt;
&lt;p&gt;我所描述的问题是针对 BPF 软件和内核追踪的。作为一个不同的例子，我的火焰图软件已经被重写了十几次，由于它是一个简单而完备的算法，我不认为这有什么大问题。我更喜欢人们帮助更新 &lt;a href=&#34;https://github.com/spiermar/d3-flame-graph&#34; title=&#34;d3 version&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;d3 version&lt;/a&gt; 但如果人们自己做，那也没什么大不了的。你可以给它编码，它将永远工作。基于 uprobe 和 kprobe 的 BPF 工具就不是这样了，因为它们确实需要维护。&lt;/p&gt;
&lt;h2 id=&#34;像系统管理员一样思考而不是像程序员一样思考&#34;&gt;像系统管理员一样思考，而不是像程序员一样思考&lt;/h2&gt;
&lt;p&gt;总之，首先检查你的监控系统是否已经有一个 BPF 代理，如果没有，就在现有的基础上构建一个 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具，而不是从头开始重写一切。这是像一个安装和维护软件的系统管理员那样思考，而不是像一个编码所有东西的程序员那样思考。安装 bcc 或 bpftrace 工具，把它们添加到你的可观测性产品中，并根据需要拉取包的更新。这将是一个快速而有用的版本。BPF 启动和运行了！&lt;/p&gt;
&lt;p&gt;我看到人们反而像程序员一样思考，觉得他们必须从深入学习 bcc 和 BPF 编程。然后，在发现所有的东西都是 C 语言或 Python 写的之后，有些人就用不同的语言重写了。&lt;/p&gt;
&lt;p&gt;首先，学好 bcc 和 BPF 需要几周时间；学习系统跟踪的微妙之处和陷阱可能需要几个月或几年。为了让你了解你所面临的情况，请看我的 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-15/bpf-internals.html&#34; title=&#34;BPF Internals&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF Internals&lt;/a&gt; 讲座。如果你真的想做这个，并且有时间，你当然可以（你可能会在 Tracing 会议上遇到我。在 Linux Plumber’s 或追 Tracing 会上见！）但是，如果你在某个期限内要增加 BPF 的可观测性，那就试着像一个系统管理员那样思考，并在现有的工具基础上进行构建。这是快速的方法。以后再像程序员那样思考，如果你有时间的话。&lt;/p&gt;
&lt;p&gt;第二，BPF 软件，特别是某些基于 kprobe 的工具，需要持续的维护。一个工具可能在 Linux 5.3 上工作，但在 5.4 上就会坏掉，因为一个被追踪的函数被重新命名或增加了一个新的代码路径。BPF 库和框架也在变化和发展，最近的一次是 BTF 和 CO-RE 支持。这是我希望人们在选择重写它们之前要考虑的问题。你是否也有计划重写所有的更新，或者你最终会被困在一个旧的库的端口上？拉取所有的更新比维护你自己的版本更容易。&lt;/p&gt;
&lt;p&gt;最后，如果你有一个比我们在 bcc 和 bpftrace 中使用的更好的 BPF 库或框架的好主意呢？和我们谈谈，试试，创新一下。我们正处于 BPF 时代的开端，还有很多东西需要探索。但请先了解现有的情况以及你所承担的维护负担。你的精力可能会被用来在现有的基础上创造新的东西，而不是移植旧的东西。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
