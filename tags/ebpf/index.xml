<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – Ebpf</title>
    <link>https://jimmysong.io/tags/ebpf/</link>
    <description>Recent content in Ebpf on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 10 Jan 2024 12:00:00 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/ebpf/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>第一章：eBPF 简介</title>
      <link>https://jimmysong.io/book/what-is-ebpf/introduction/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/introduction/</guid>
      <description>
        
        
        &lt;p&gt;在过去的几年里，eBPF 已经从相对默默无闻变成了现代基础设施建设中最热门的技术领域之一。就我个人而言，自从看到 Thomas Graf 在 DockerCon 17 的&lt;a href=&#34;https://www.youtube.com/watch?v=ilKlmTDdFgk&amp;amp;ab_channel=Docker&#34; title=&#34;黑带会议&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;黑带会议&lt;/a&gt;（Black Blet）&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 上谈到 eBPF 时，我就对它的可能性感到兴奋。在云原生计算基金会（CNCF），我在技术监督委员会（TOC）的同事把 eBPF 作为我们预测 2021 年将会起飞的重点技术之一来关注。超过 2500 人报名参加了当年的 eBPF 峰会线上会议，世界上最先进的几家软件工程公司共同创建了 &lt;a href=&#34;https://ebpf.io/foundation&#34; title=&#34;eBPF 基金会&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 基金会&lt;/a&gt;。显然，人们对这项技术有很大的兴趣。&lt;/p&gt;
&lt;p&gt;在这个简短的报告中，我希望能给你一些启示，为什么人们对 eBPF 如此兴奋，以及它在现代计算环境中提供的工具能力。你会了解到 eBPF 是什么以及为什么它如此强大。还有一些代码实例，以使这种感觉更加具象化（但如果你愿意，你可以跳过这些）。&lt;/p&gt;
&lt;p&gt;你将了解到在建立支持 eBPF 的工具时涉及的内容，以及为什么 eBPF 在如此短的时间内变得如普遍。&lt;/p&gt;
&lt;p&gt;在这份简短的报告中，难免无法了解所有的细节，但如果你想更深入地了解，我将给你一些参考信息。&lt;/p&gt;
&lt;h2 id=&#34;扩展的伯克利数据包过滤器&#34;&gt;扩展的伯克利数据包过滤器&lt;/h2&gt;
&lt;p&gt;让我们把缩写说出来：eBPF 代表&lt;strong&gt;扩展的伯克利数据包过滤器（Extended Berkeley Packet Filter）&lt;/strong&gt;。从这个名字中，你可以看到它的根源在于过滤网络数据包，而且最初的 &lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34; title=&#34;论文&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;论文&lt;/a&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 是在伯克利实验室（Lawrence Berkeley National Laboratory）写的。但是（在我看来）这个名字对于传达 eBPF 的真正力量并没有很大的帮助，因为&amp;quot;扩展&amp;quot; 版本可以实现比数据包过滤多得多的功能。最近，eBPF 被用作一个独立的名称，它所包含的内容比它的缩写更多。&lt;/p&gt;
&lt;p&gt;那么，如果它不仅仅是包过滤，什么是 eBPF？eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。这意味着它可以扩展甚至修改内核的行为。&lt;/p&gt;
&lt;p&gt;当 eBPF 程序被加载到内核中时，有一个验证器确保它是安全运行的，如果无法确认，则拒绝它。一旦加载，eBPF 程序需要被附加到一个事件上，这样，每当事件发生时，程序就会被触发。&lt;/p&gt;
&lt;p&gt;eBPF 最初是为 Linux 开发的，这也是我在本报告中重点讨论的操作系统；但值得注意的是，截至本文写作时，微软正在 &lt;a href=&#34;https://oreil.ly/J0N1H&#34; title=&#34;为 Windows 开发 eBPF 的实现&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为 Windows 开发 eBPF 的实现&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在，广泛使用的 Linux 内核都支持 &amp;ldquo;扩展&amp;rdquo; 部分，eBPF 和 BPF 这两个术语现在基本上可以互换使用。&lt;/p&gt;
&lt;h2 id=&#34;基于-ebpf-的工具&#34;&gt;基于 eBPF 的工具&lt;/h2&gt;
&lt;p&gt;正如你在本报告中所看到的，动态改变内核行为的能力非常有用。传统上，如果我们想观察应用程序的行为，我们在应用程序中添加代码，以产生日志和追踪。eBPF 允许我们收集关于应用程序行为的定制信息，通过在内核中观察它，而不必修改应用程序。我们可以在这种可观测性的基础上创建 eBPF 安全工具，从内核中检测甚至防止恶意活动。我们可以用 eBPF 创建强大的、高性能的网络功能，在内核内处理网络数据包，避免昂贵的用户空间转换。&lt;/p&gt;
&lt;p&gt;从内核的角度来观测应用程序的概念并不新颖——这建立在较早的 Linux 功能之上，比如 perf &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，它也从内核内部收集行为和性能信息，而不需要修改被测量的应用程序。但是这些工具定义了可以收集的数据种类以及数据的格式。有了 eBPF，我们就有了更大的灵活性，因为我们可以编写完全自定义的程序，允许我们出于不同的目的建立广泛的工具。&lt;/p&gt;
&lt;p&gt;eBPF 编程的能力异常强大，但也很复杂。对于我们大多数人来说，eBPF 的效用不是来自于自己写的程序，而是来自于使用别人创造的工具。有越来越多的项目和供应商在 eBPF 平台上创建了新一代的工具，包括可观测性、安全性、网络等。&lt;/p&gt;
&lt;p&gt;我将在本报告后面讨论这些更高级别的工具，但是，如果你对 Linux 命令行很熟悉，迫不及待地想看到 eBPF 的运行，推荐你从 BCC 项目开始。BCC 包含丰富的追踪工具集合；即使只是瞥一眼列表也可以领略到 eBPF 广泛的应用，包括文件操作、内存使用、CPU 统计，甚至观察在系统任意位置输入的 bash 命令。&lt;/p&gt;
&lt;p&gt;在下一章，我们将介绍改变内核行为的作用，为什么使用 eBPF 比直接编写内核代码更容易操作。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Thomas Graf，《Cilium——使用 BPF 和 XDP 的网络和应用安全》（DockerCon 2017 年 4 月 17-20 日）&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Steven McCanne 和 Van Jacobson，《BSD 数据包过滤器：用户级数据包捕获的新架构》（工作文件，劳伦斯伯克利国家实验室，伯克利，1992 年 12 月 19 日）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;perf 是一个 Linux 子系统，用于收集性能数据。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第二章：修改内核很困难</title>
      <link>https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/</guid>
      <description>
        
        
        &lt;p&gt;由于 eBPF 允许在 Linux 内核中运行自定义代码，在解释 eBPF 之前我需要确保你对内核的作用有所了解。然后我们将讨论为什么在修改内核行为这件事情上，eBPF 改变了游戏规则。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核&#34;&gt;Linux 内核&lt;/h2&gt;
&lt;p&gt;Linux 内核是应用程序和它们所运行的硬件之间的软件层。应用程序运行在被称为&lt;strong&gt;用户空间&lt;/strong&gt;的非特权层，它不能直接访问硬件。相反，应用程序使用系统调用（syscall）接口发出请求，要求内核代表它行事。这种硬件访问可能涉及到文件的读写，发送或接收网络流量，或者只是访问内存。内核还负责协调并发进程，使许多应用程序可以同时运行。&lt;/p&gt;
&lt;p&gt;应用程序开发者通常不直接使用系统调用接口，因为编程语言给了我们更高级别的抽象和&lt;strong&gt;标准库&lt;/strong&gt;，开发者更容易掌握这些接口。因此，很多人都不知道在程序运行时内核做了什么。如果你想了解内核调用频率，你可以使用 strace 工具来显示程序所做的所有系统调用。这里有一个例子，用 cat 从文件中读取 hello 这个词并将其写到屏幕上涉及到 100 多个系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;liz@liz-ebpf-demo-1:~$ strace -c cat liz.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;     seconds  usecs/call     calls    errors syscall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         5	  &lt;span class=&#34;nb&#34;&gt;read&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  write
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        21	  close
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        20	  fstat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        23	  mmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  mprotect
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	  munmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         3	  brk
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  pread64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; access
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  execve
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; arch_prctl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  fadvise64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        19	  openat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;100.00    0.000000              &lt;span class=&#34;m&#34;&gt;107&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; total
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于应用程序在很大程度上依赖于内核，这意味着如果我们能够观测到应用程序与内核的交互，我们就可以了解到很多关于它的行为方式。例如，如果你能够截获打开文件的系统调用，你就可以准确地看到任何应用程序访问了哪些文件。但是，怎么才能做到这种拦截呢？让我们考虑一下，如果我们想修改内核，添加新的代码，在系统调用时创建某种输出，会涉及到什么问题。&lt;/p&gt;
&lt;h2 id=&#34;向内核添加新功能&#34;&gt;向内核添加新功能&lt;/h2&gt;
&lt;p&gt;Linux 内核很复杂，在写这篇文章的时候有大约 3000 万行代码 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。对任何代码库进行修改都需要对现有的代码有一定的熟悉，所以除非你已经是一个内核开发者，否则这很可能是一个挑战。&lt;/p&gt;
&lt;p&gt;但你将面临的挑战并不是纯粹的技术问题。Linux 是一个通用的操作系统，在不同的环境和情况下使用。这意味着，如果你想对内核进行修改，这并不是简单地写出能用的代码。它必须被社区（更确切地说，是被 Linux 的创造者和主要开发者 Linus Torvalds）接受，你的改变将是为了大家的更大利益。而这并不是必然的——提交的内核补丁只有三分之一被接受 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;假如，你已经想出了一个好方法来拦截打开文件的系统调用。经过几个月的讨论和一些艰苦的开发工作，让我们想象一下，这个变化被接受到内核中。很好！但是，要到什么时候它才会出现在每个人的机器上呢？&lt;/p&gt;
&lt;p&gt;每隔两三个月就会有一个新的 Linux 内核版本，但是即使一个变化已经进入了其中一个版本，它仍然需要一段时间才能在大多数人的生产环境中使用。这是因为我们大多数人并不直接使用 Linux 内核——我们使用像 Debian、Red Hat、Alpine、Ubuntu 等 Linux 发行版，它们将 Linux 内核的一个版本与其他各种组件打包在一起。你可能会发现，你最喜欢的发行版使用的是几年前的内核版本。&lt;/p&gt;
&lt;p&gt;例如，很多企业用户都采用红帽 ® Enterprise Linux®（RHEL）。在撰写本文时，目前的版本是 RHEL8.5，发行日期为 2021 年 11 月。这使用的是基于 4.18 版本的内核。这个内核是在 2018 年 8 月发布的。&lt;/p&gt;
&lt;p&gt;如 &lt;a href=&#34;#figure-f-2-1&#34; title=&#34;图 2-1&#34;&gt;图 2-1&lt;/a&gt; 中的漫画所示，将新功能从想法阶段转化为生产环境中的 Linux 内核，需要数年时间 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-2-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）&#34; id=&#34;f-2-1&#34;data-img=&#34;f-2-1.jpg&#34;
         data-caption=&#34;图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）&#34;
         
         
         data-width=&#34;1780&#34;
         data-height=&#34;1140&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;内核模块&#34;&gt;内核模块&lt;/h2&gt;
&lt;p&gt;如果你不想等上好几年才把你的改动写进内核，还有一个选择。Linux 内核可以接受内核模块（module），这些模块可以根据需要加载和卸载。如果你想改变或扩展内核行为，编写一个模块是理所当然的。在我们打开文件的系统调用的例子中，你可以写一个内核模块来实现。&lt;/p&gt;
&lt;p&gt;这里最大的挑战是，这仍然是全面的内核编程。用户在使用内核模块时历来非常谨慎，原因很简单：如果内核代码崩溃了，就会导致机器和上面运行的所有东西瘫痪。用户如何确保内核模块可以安全运行呢？&lt;/p&gt;
&lt;p&gt;“安全运行”并不仅仅意味着不崩溃——用户想知道内核模块从安全角度来看是否安全。是否包括攻击者可以利用的漏洞？我们是否相信模块的作者不会在其中加入恶意代码？因为内核是特权代码，它可以访问机器上的一切，包括所有的数据，所以内核中的恶意代码将是一个令人担忧的严重问题。这也适用于内核模块。&lt;/p&gt;
&lt;p&gt;考虑到内核的安全性，这就是为什么 Linux 发行商需要这么长时间来发布新版本的一个重要原因。如果其他人已经在各种情况下运行了数月或数年的内核版本，那些漏洞可能已经被修复。发行版的维护者可以有一些信心，他们提供给用户 / 客户的内核是经过加固的，也就是说，可以安全运行。&lt;/p&gt;
&lt;p&gt;eBPF 提供了一个非常不同的安全方法：&lt;strong&gt;eBPF 验证器（verifier）&lt;/strong&gt;，它确保一个 eBPF 程序只有在安全运行的情况下才被加载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-验证和安全&#34;&gt;eBPF 验证和安全&lt;/h2&gt;
&lt;p&gt;由于 eBPF 允许我们在内核中运行任意代码，需要有一种机制来确保它的安全运行，不会使用户的机器崩溃，也不会损害他们的数据。这个机制就是 eBPF 验证器。&lt;/p&gt;
&lt;p&gt;验证器对 eBPF 程序进行分析，以确保无论输入什么，它都会在一定数量的指令内安全地终止。例如，如果一个程序解除对一个指针的定义，验证器要求该程序首先检查指针，以确保它不是空的（null）。解除对指针的引用意味着 &amp;ldquo;查找这个地址的值&amp;rdquo;，而空值或零值不是一个有效的查找地址。如果你在一个应用程序中解引用一个空指针，该应用程序就会崩溃；而在内核中解引用一个空指针则会使整个机器崩溃，所以避免这种情况至关重要。&lt;/p&gt;
&lt;p&gt;验证也确保了 eBPF 程序只能访问其应该访问的内存。例如，有一个 eBPF 程序在网络堆栈中触发，并通过内核的 &lt;strong&gt;套接字缓冲区（socket buffer）&lt;/strong&gt;，其中包括正在传输的数据。有一些特殊的辅助函数，如 &lt;code&gt;bpf_skb_load_bytes()&lt;/code&gt;，这个 eBPF 程序可以调用，从套接字缓冲区读取字节数据。另一个由系统调用触发的 eBPF 程序，没有可用的套接字缓冲区，将不允许使用这个辅助函数。验证器还确保程序只读取套接字缓冲区内的数据字节——它不允许访问任意的内存。这里的目的是确保 eBPF 程序是安全的。&lt;/p&gt;
&lt;p&gt;当然，仍然有可能编写一个恶意的 eBPF 程序。如果你可以出于合法的原因观测数据，你也可以出于非法的原因观测它。要注意只从可验证的来源加载可信的 eBPF 程序，并且只将管理 eBPF 工具的权限授予你信任的拥有 root 权限的人。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-程序的动态加载&#34;&gt;eBPF 程序的动态加载&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以动态地加载到内核中和从内核中删除。不管是什么原因导致该事件的发生，一旦它们被附加到一个事件上就会被该事件所触发。例如，如果你将一个程序附加到打开文件的系统调用，那么只要任何进程试图打开一个文件，它就会被触发。当程序被加载时，该进程是否已经在运行，这并不重要。&lt;/p&gt;
&lt;p&gt;这也是使用 eBPF 的可观测性或安全工具的巨大优势之一——即刻获得了对机器上发生的一切事件的可视性。&lt;/p&gt;
&lt;p&gt;此外，如 &lt;a href=&#34;#figure-f-2-2&#34; title=&#34;图 2-2&#34;&gt;图 2-2&lt;/a&gt; 所示，人们可以通过 eBPF 非常快速地创建新的内核功能，而不要求其他 Linux 用户都接受同样的变更。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-2-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）&#34; id=&#34;f-2-2&#34;data-img=&#34;f-2-2.jpg&#34;
         data-caption=&#34;图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）&#34;
         
         
         data-width=&#34;1484&#34;
         data-height=&#34;1290&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;现在你已经看到了 eBPF 是如何允许对内核进行动态的、自定义的修改的，让我们来看看如果你想写一个 eBPF 程序会涉及哪些内容。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Linux 5.12 有大约 2880 万行代码，Phoronix（2021 年 3 月）。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Yujuan Jiang 等人，《我的补丁能用了吗？要多久？》（论文，2013 年）。根据这篇研究论文，33% 的补丁将在 3 - 6 个月后被接受。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;值得庆幸的是，现有功能的安全补丁会更快地被提供。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第三章：eBPF 程序</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-programs/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-programs/</guid>
      <description>
        
        
        &lt;p&gt;在这一章中，让我们来谈谈编写 eBPF 代码。我们需要考虑在内核中运行的 eBPF 程序本身，以及与之交互的用户空间代码。&lt;/p&gt;
&lt;h2 id=&#34;内核和用户空间代码&#34;&gt;内核和用户空间代码&lt;/h2&gt;
&lt;p&gt;首先，你可以用什么编程语言来编写 eBPF 程序？&lt;/p&gt;
&lt;p&gt;内核接受字节码形式的 eBPF 程序 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。人工编写这种字节码是可能的，就像用汇编语言写应用程序代码一样——但对人类来说，使用一种可以被编译（即自动翻译）为字节码的高级语言通常更实用。&lt;/p&gt;
&lt;p&gt;由于一些原因，eBPF 程序不能用任意的高级语言编写。首先，语言编译器需要支持发出内核所期望的 eBPF 字节码格式。其次，许多编译语言都有运行时特性——例如 Go 的内存管理和垃圾回收，使它们不适合。在撰写本文时，编写 eBPF 程序的唯一选择是 C（用 clang/llvm 编译）和最新的 Rust。迄今为止，绝大多数的 eBPF 代码都是用 C 语言发布的，考虑到它是 Linux 内核的语言，这是有道理的。&lt;/p&gt;
&lt;p&gt;至少，用户空间的程序需要加载到内核中，并将其附加到正确的事件中。有一些实用程序，如 bpftool，可以帮助我们解决这个问题，但这些都是低级别的工具，假定你有丰富的 eBPF 知识，它们是为 eBPF 专家设计的，而不是普通用户。在大多数基于 eBPF 的工具中，有一个用户空间的应用程序，负责将 eBPF 程序加载到内核中，传入任何配置参数，并以用户友好的方式显示 eBPF 程序收集的信息。&lt;/p&gt;
&lt;p&gt;至少在理论上，eBPF 工具的用户空间部分可以用任何语言编写，但在实践中，有一些库只支持相当少的语言。其中包括 C、Go、Rust 和 Python。这种语言的选择更加复杂，因为并不是所有的语言都有支持 libbpf 的库，libbpf 已经成为使 eBPF 程序在不同版本的内核中可移植的流行选择。(我们将在 &lt;a href=&#34;../ebpf-complexity&#34; title=&#34;第四章&#34;&gt;第四章&lt;/a&gt; 中讨论 libbpf）。&lt;/p&gt;
&lt;h2 id=&#34;附属于事件的自定义程序&#34;&gt;附属于事件的自定义程序&lt;/h2&gt;
&lt;p&gt;eBPF 程序本身通常是用 C 或 Rust 编写的，并编入一个对象文件 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。这是一个标准的 ELF（可执行和可链接格式，Executable and Linkable Format）文件，可以用像 &lt;strong&gt;readelf&lt;/strong&gt; 这样的工具来检查，它包含程序字节码和任何映射的定义（我们很快就会讨论）。如 &lt;a href=&#34;#figure-f-3-1&#34; title=&#34;图 3-1&#34;&gt;图 3-1&lt;/a&gt; 所示，如果在前一章中提到的验证器允许的话，用户空间程序会读取这个文件并将其加载到内核中。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-3-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中&#34; id=&#34;f-3-1&#34;data-img=&#34;f-3-1.jpg&#34;
         data-caption=&#34;图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中&#34;
         
         
         data-width=&#34;1486&#34;
         data-height=&#34;518&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;eBPF 程序加载到内核中时必须被附加到事件上。每当事件发生，相关的 eBPF 程序就会运行。有一个非常广泛的事件，你可以将程序附加到其中；我不会涵盖所有的事件，但以下是一些更常用的选项。&lt;/p&gt;
&lt;h3 id=&#34;从函数中进入或退出&#34;&gt;从函数中进入或退出&lt;/h3&gt;
&lt;p&gt;你可以附加一个 eBPF 程序，在内核函数进入或退出时被触发。当前的许多 eBPF 例子都使用了 &lt;code&gt;kprobes&lt;/code&gt;（附加到一个内核函数入口点）和 &lt;code&gt;kretprobes&lt;/code&gt;（函数退出）的机制。在最新的内核版本中，有一个更有效的替代方法，叫做 &lt;code&gt;fentry/fexit&lt;/code&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;请注意，你不能保证在一个内核版本中定义的所有函数一定会在未来的版本中可用，除非它们是稳定 API 的一部分，如 syscall 接口。&lt;/p&gt;
&lt;p&gt;你也可以用 &lt;code&gt;uprobes&lt;/code&gt; 和 &lt;code&gt;uretprobes&lt;/code&gt; 将 eBPF 程序附加到用户空间函数上。&lt;/p&gt;
&lt;h3 id=&#34;tracepoints&#34;&gt;Tracepoints&lt;/h3&gt;
&lt;p&gt;你也可以将 eBPF 程序附加到内核内定义的 &lt;code&gt;tracepoints&lt;/code&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。通过在 &lt;code&gt;/sys/kernel/debug/tracing/events&lt;/code&gt; 下查找机器上的事件。&lt;/p&gt;
&lt;h3 id=&#34;perf-事件&#34;&gt;Perf 事件&lt;/h3&gt;
&lt;p&gt;Perf &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 是一个收集性能数据的子系统。你可以将 eBPF 程序挂到所有收集 perf 数据的地方，这可以通过在你的机器上运行 perf list 来确定。&lt;/p&gt;
&lt;h3 id=&#34;linux-安全模块接口&#34;&gt;Linux 安全模块接口&lt;/h3&gt;
&lt;p&gt;LSM 接口在内核允许某些操作之前检查安全策略。你可能见过 AppArmor 或 SELinux，利用了这个接口。通过 eBPF，你可以将自定义程序附加到相同的检查点上，从而实现灵活、动态的安全策略和一些运行时安全工具的新方法。&lt;/p&gt;
&lt;h3 id=&#34;网络接口express-data-path&#34;&gt;网络接口——eXpress Data Path&lt;/h3&gt;
&lt;p&gt;eXpress Data Path（XDP）允许将 eBPF 程序附加到网络接口上，这样一来，每当收到一个数据包就会触发 eBPF 程序。它可以检查甚至修改数据包，程序的退出代码可以告诉内核如何处理该数据包：传递、放弃或重定向。这可以构成一些非常有效的网络功能 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; 的基础。&lt;/p&gt;
&lt;h3 id=&#34;套接字和其他网络钩子&#34;&gt;套接字和其他网络钩子&lt;/h3&gt;
&lt;p&gt;当应用程序在网络套接字上打开或执行其他操作时，以及当消息被发送或接收时，你可以附加运行 eBPF 程序。在内核的网络堆栈中也有称为 &lt;strong&gt;流量控制（traffic control）&lt;/strong&gt; 或 &lt;strong&gt;tc&lt;/strong&gt; 的 钩子，eBPF 程序可以在初始数据包处理后运行。&lt;/p&gt;
&lt;p&gt;一些功能可以单独用 eBPF 程序实现，但在许多情况下，我们希望 eBPF 代码能从用户空间的应用程序接收信息，或将数据传递给用户空间的应用程序。允许数据在 eBPF 程序和用户空间之间，或在不同的 eBPF 程序之间传递的机制被称为 &lt;strong&gt;map&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-map&#34;&gt;eBPF Map&lt;/h2&gt;
&lt;p&gt;map 的开发是 eBPF 缩略语中的 &lt;strong&gt;e&lt;/strong&gt; 代表 &lt;strong&gt;extended&lt;/strong&gt; 重要区别之一。&lt;/p&gt;
&lt;p&gt;map 是与 eBPF 程序一起定义的数据结构体。有各种不同类型的 map，但它们本质上都是键值存储。eBPF 程序可以读取和写入 map，用户空间代码也可以。map 的常见用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF 程序写入关于事件的指标和其他数据，供用户空间代码以后检索。&lt;/li&gt;
&lt;li&gt;用户空间代码编写配置信息，供 eBPF 程序读取并作出相应的行为。&lt;/li&gt;
&lt;li&gt;eBPF 程序将数据写入 map，供另一个 eBPF 程序以后检索，允许跨多个内核事件的信息协调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果内核和用户空间的代码都要访问同一个映射，它们需要对存储在该映射中的数据结构体有一个共同的理解。这可以通过在用户空间和内核代码中加入定义这些数据结构体的头文件来实现，但是如果这些代码不是用相同的语言编写的，作者将需要仔细创建逐个字节兼容的结构体定义。&lt;/p&gt;
&lt;p&gt;我们已经讨论了 eBPF 工具的主要组成部分：在内核中运行的 eBPF 程序，加载和与这些程序交互的用户空间代码，以及允许程序共享数据的 map。为了更具体化，让我们看一个例子。&lt;/p&gt;
&lt;h2 id=&#34;opensnoop-示例&#34;&gt;Opensnoop 示例&lt;/h2&gt;
&lt;p&gt;在 eBPF 程序的例子中，我选择了 &lt;code&gt;opensnoop&lt;/code&gt;，一个可以显示任何进程所打开的文件的工具。这个工具的原始版本是 Brendan Gregg 最初在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; title=&#34;BCC 项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BCC 项目&lt;/a&gt;中编写的许多 BPF 工具之一，你可以在 GitHub 上找到。它后来被重写为 &lt;code&gt;libbpf&lt;/code&gt;（你将在下一章见到它），在这个例子中，我使用 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录下的较新版本。&lt;/p&gt;
&lt;p&gt;当你运行 &lt;code&gt;opensnoop&lt;/code&gt; 时，你将看到的输出在很大程度上取决于当时在虚拟机上发生了什么，但它应该看起来像这样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PID    COMM	FD	ERR	PATH
93965  cat	3	0	/etc/ld.so.cache
93965  cat	3	0	/lib/x86_64-linux-gnu/libc.so.6
93965  cat	3	0	/usr/lib/locale/locale-archive
93965  cat	3	0	/usr/share/locale/locale.alias
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行输出表示一个进程打开（或试图打开）一个文件。这些列显示了进程的 ID，运行的命令，文件描述符，错误代码的指示，以及被打开的文件的路径。&lt;/p&gt;
&lt;p&gt;Opensnoop 的工作方式是将 eBPF 程序附加到 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt; 系统调用上，所有应用程序都必须通过这些调用来要求内核打开文件。让我们深入了解一下这是如何实现的。为了简洁起见，我们将不看每一行代码，但我希望这足以让你了解它是如何工作的（如果你对这么深的内容不感兴趣的话，请跳到下一章！）。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-ebpf-代码&#34;&gt;Opensnoop eBPF 代码&lt;/h3&gt;
&lt;p&gt;eBPF 代码是用 C 语言编写的，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/libbpf-tools/opensnoop.bpf.c&#34; title=&#34;&amp;lt;code&amp;gt;opensnoop.bpf.c&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opensnoop.bpf.c&lt;/code&gt;&lt;/a&gt; 文件中。在这个文件的开头，你可以看到两个 eBPF map 的定义 —— &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;events&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10240&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;args_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 ELF 对象文件被创建时，它包含了每个 map 和每个要加载到内核的程序的部分，&lt;code&gt;SEC()&lt;/code&gt; 宏定义了这些部分。&lt;/p&gt;
&lt;p&gt;当我们研究这个程序的时候，你会看到，在系统调用被处理的时候，&lt;code&gt;start&lt;/code&gt; map 被用来临时存储系统调用的参数 —— 包括被打开的文件的名称。&lt;code&gt;events&lt;/code&gt; map &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; 用于将事件信息从内核中的 eBPF 代码传递给用户空间的可执行程序。如 &lt;a href=&#34;#figure-f-3-2&#34; title=&#34;图 3-2&#34;&gt;图 3-2&lt;/a&gt; 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-3-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中&#34; id=&#34;f-3-2&#34;data-img=&#34;f-3-2.jpg&#34;
         data-caption=&#34;图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中&#34;
         
         
         data-width=&#34;1486&#34;
         data-height=&#34;686&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 文件的后面，你会发现两个极其相似的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_open&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tracepoint__syscalls__sys_enter_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_openat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tracepoint__syscalls__sys_enter_openat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个不同的系统调用用于打开文件 &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;：&lt;code&gt;openat()&lt;/code&gt; 和
&lt;code&gt;open()&lt;/code&gt;。它们是相同的，除了 &lt;code&gt;openat()&lt;/code&gt; 有一个额外的参数是目录文件描述符，而且要打开的文件的路径名是相对于该目录而言的。同样，除了处理参数上的差异，opensnoop 中的两个函数也是相同的。&lt;/p&gt;
&lt;p&gt;正如你所看到的，它们都需要一个参数，即一个指向名为 &lt;code&gt;trace_event_raw_sys_enter&lt;/code&gt; 结构体的指针。你可以在你运行的特定内核生成的 &lt;code&gt;vmlinux&lt;/code&gt; 头文件中找到这个结构体的定义。编写 eBPF 程序之道包括找出每个程序接收的结构体作为其上下文，以及如何访问其中的信息。&lt;/p&gt;
&lt;p&gt;这两个函数使用一个 BPF 辅助函数来检索调用这个 syscall 的进程 ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_get_current_pid_tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码得到了文件名和传递给系统调用的标志，并把它们放在一个叫做 &lt;code&gt;args&lt;/code&gt; 的结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个结构体被写入 &lt;code&gt;start&lt;/code&gt; map 中，使用当前程序 ID 作为键。&lt;/p&gt;
&lt;p&gt;这就是 eBPF 程序在进入 syscall 时所做的一切。但在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 中定义了另一对 eBPF 程序，当系统调用退出时被触发。&lt;/p&gt;
&lt;p&gt;这个程序和它的双胞胎 &lt;code&gt;openat()&lt;/code&gt; 在函数 &lt;code&gt;trace_exit()&lt;/code&gt; 中共享代码。你有没有注意到，所有被 eBPF 程序调用的函数的前缀都是 &lt;code&gt;static __always_inline&lt;/code&gt;？这迫使编译器将这些函数的指令放在内联中，因为在旧的内核中，BPF 程序不允许跳转到一个单独的函数。新的内核和 LLVM 版本可以支持非内联的函数调用，但这是一种安全的方式，可以确保 BPF 验证器满意（现在还有一个 BPF 尾部调用的概念，即执行从一个 BPF 程序跳转到另一个程序。你可以在 &lt;a href=&#34;https://docs.cilium.io/en/v1.10/bpf/#bpf-to-bpf-calls&#34; title=&#34;eBPF 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 文档&lt;/a&gt;中阅读更多关于 BPF 函数调用和尾部调用的内容）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;trace_exit()&lt;/code&gt; 函数创建一个空的事件结构体：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该结构体将用即将结束的 &lt;code&gt;open/openat&lt;/code&gt; 系统调用的信息填充，并通过 &lt;code&gt;events&lt;/code&gt; map 发送到用户空间。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;start&lt;/code&gt; 哈希 map 中应该有一个与当前进程 ID 相对应的条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有先前在调用 &lt;code&gt;sys_enter_open(at)&lt;/code&gt; 时写入的关于文件名和标志的信息。标志字段是一个直接存储在结构体中的整数，所以直接从结构体中读取它是可以的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相反，文件名被写入用户空间内存的一些字节中，验证者需要确定这个 eBPF 程序从内存的那个位置读取这个字节数是安全的。这是用另一个辅助函数 &lt;code&gt;bpf_probe_read_user_str()&lt;/code&gt; 完成的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_probe_read_user_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前的命令名称（即进行 &lt;code&gt;open(at)&lt;/code&gt; 系统调用的可执行文件的名称）也被复制到事件结构体中，使用另一个 BPF 辅助函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_get_current_comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事件结构体被写入 &lt;code&gt;events&lt;/code&gt; perf buffer map 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_perf_event_output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_F_CURRENT_CPU&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户空间的代码从这个 map 中读取事件信息。在我们讨论这个问题之前，让我们简单看看 Makefile。&lt;/p&gt;
&lt;h3 id=&#34;libbpf-tools-makefile&#34;&gt;libbpf-tools Makefile&lt;/h3&gt;
&lt;p&gt;当你构建 eBPF 代码时，你得到一个包含 eBPF 程序和 map 的二进制定义的对象文件。你还需要一个额外的用户空间可执行文件，它将把这些程序和 map 加载到内核中，作为用户 &lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; 的接口。我们看看如何构建 &lt;code&gt;opensnoop&lt;/code&gt; 的 Makefile，看看它是如何创建 eBPF 对象文件和可执行文件的。&lt;/p&gt;
&lt;p&gt;Makefile 由一组规则组成，这些规则的语法可能有点不透明，所以如果你不熟悉 Makefile，也不特别关心这些细节，请随意跳过这一节。&lt;/p&gt;
&lt;p&gt;我们正在看的 opensnoop 的例子是一大批示例工具的其中之一，它们都是用 Makefile 构建的，你可以在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到。在这个文件中，并不是所有的东西都特别有意义，但有几个规则我想强调一下。第一条规则是使用 &lt;code&gt;bpf.c&lt;/code&gt; 文件并使用 clang 编译器来创建一个 BPF 目标对象文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.bpf.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;AR&lt;/span&gt;.. 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BPF&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CLANG&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bpf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;D__TARGET_ARCH_&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              -&lt;span class=&#34;nv&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@ &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LLVM_STRIP&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，&lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 被编译成 &lt;code&gt;\$(OUTPUT)/open snoop.bpf.o&lt;/code&gt;。这个对象文件包含将被加载到内核的 eBPF 程序和 map。&lt;/p&gt;
&lt;p&gt;另一条规则使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt;，从该 &lt;code&gt;bpf.o&lt;/code&gt; 对象文件中包含的 map 和程序定义中创建一个骨架头文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.skel.h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;GEN&lt;/span&gt;-&lt;span class=&#34;nv&#34;&gt;SKEL&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BPFTOOL&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;gen&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;skeleton&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;opensnoop.c&lt;/code&gt; 用户空间代码包括这个 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 头文件，以获得它与内核中的 eBPF 程序共享的 map 的定义。这使得用户空间和内核代码能够了解存储在这些 map 中的数据结构体的布局。&lt;/p&gt;
&lt;p&gt;下面的规则将用户空间的代码 &lt;code&gt;opensnoop.c&lt;/code&gt; 的编译成为 &lt;code&gt;$(OUTPUT)/opensnoop.o&lt;/code&gt; 的二进制对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，有一条规则是使用 &lt;code&gt;cc&lt;/code&gt; 将用户空间的应用对象（在我们的例子中是 &lt;code&gt;opensnoop.o&lt;/code&gt;）链接成一组可执行文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(APPS)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;COMMON_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUT&lt;/span&gt;... 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BINARY&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lelf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lz&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在你已经看到 eBPF 和用户空间程序分别是如何生成的，让我们看看用户空间的代码。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-用户空间代码&#34;&gt;Opensnoop 用户空间代码&lt;/h3&gt;
&lt;p&gt;如前所述，与 eBPF 代码交互的用户空间代码几乎可以用任何编程语言编写。我们在本节讨论的例子是用 C 语言写的，但如果你有兴趣，你可以把它与用 Python 写的原始 BCC 版本相比较，你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; title=&#34;bcc/tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc/tools&lt;/a&gt; 中找到。&lt;/p&gt;
&lt;p&gt;用户空间的代码在 &lt;code&gt;opensnoop.c&lt;/code&gt; 文件中。文件的前半部分有 &lt;code&gt;#include&lt;/code&gt; 指令（其中之一是自动生成的 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 文件），各种定义，以及处理不同命令行选项的代码，我们在此不再赘述。我们还将略过 &lt;code&gt;print_event()&lt;/code&gt; 等函数，该函数将一个事件的信息显示到屏幕上。从 eBPF 的角度来看，所有有趣的代码都在 &lt;code&gt;main()&lt;/code&gt; 函数中。&lt;/p&gt;
&lt;p&gt;你会看到像 &lt;code&gt;opensnoop_bpf__open()&lt;/code&gt;、&lt;code&gt;opensnoop_bpf__load()&lt;/code&gt; 和 &lt;code&gt;opensnoop_bpf__attach()&lt;/code&gt; 这样的函数。这些都是在由 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; &lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;  自动生成的代码中定义的。这个自动生成的代码处理所有在 eBPF 对象文件中定义的单个 eBPF 程序、map 和附着点。&lt;/p&gt;
&lt;p&gt;opensnoop 启动和运行后，它的工作就是监听 &lt;code&gt;events&lt;/code&gt; 的 perf
buffer，并将每个事件中包含的信息写到屏幕上。首先，它打开与 perf buffer 相关的文件描述符，并将 &lt;code&gt;handle_event()&lt;/code&gt; 设置为新事件到来时要调用的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perf_buffer__new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;bpf_map__fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PERF_BUFFER_PAGES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_lost_events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后它对缓冲区事件进行轮询，直到达到一个时间限制，或者用户中断程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exiting&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perf_buffer__poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PERF_POLL_TIMEOUT_MS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传递给 &lt;code&gt;handle_event()&lt;/code&gt; 的数据参数指向 eBPF 程序为该事件写进 map 的事件结构体。&lt;/p&gt;
&lt;p&gt;用户空间的代码可以检索这些信息，将其格式化并写出来给用户看。&lt;/p&gt;
&lt;p&gt;正如你所看到的，opensnoop 注册了 eBPF 程序，每当有应用程序进行 &lt;code&gt;open()&lt;/code&gt; 或 &lt;code&gt;openat()&lt;/code&gt; 系统调用时都会被调用。这些运行在内核中的 eBPF 程序收集有关该系统调用的上下文信息 —— 可执行文件名和进程 ID—— 以及被打开的文件的信息。这些信息被写进一个 map，用户空间可以从中读取并显示给用户。&lt;/p&gt;
&lt;p&gt;你会在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到几十个这样的 eBPF 工具的例子，每个例子通常都是一个系统调用，或者是一系列相关的系统调用，如 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统调用是一个稳定的内核接口，它提供了一个非常强大的方式来观察（虚拟）机器上正在发生的事情。但是，不要以为 eBPF 编程只能用于拦截系统调用。还有很多其他的固定接口，包括 LSM 和网络堆栈中的各种点，eBPF 可以连接到这些接口。如果你愿意承担内核版本变更的风险，eBPF 程序可以附加的范围是绝对宽广的。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;见 &lt;a href=&#34;https://oreil.ly/4MMPL&#34; title=&#34;BPF 指令集文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF 指令集文档&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;也可以跳过对象文件，使用 bpf() 系统调用直接将字节码加载到内核。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;code&gt;entry/fexit&lt;/code&gt; 在 Alexei Starovoitov 的文章中描述：《引入 BPF Trampoline》（LWN.net，2019 年 11 月 14 日）。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Oracle Linux 博客，《Taming Tracepoints in the Linux Kernel》，作者 Matt Keenan，2020 年 3 月 9 日发布。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Brendan Gregg 的网站是一个关于 &lt;a href=&#34;https://www.brendangregg.com/perf.html&#34; title=&#34;perf events&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf events&lt;/a&gt;的良好信息来源。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;如果你有兴趣看到这方面的具体例子，你可以看一下我在 2021 年 eBPF 峰会上的&lt;a href=&#34;https://www.youtube.com/watch?v=L3_AOFSNKK8&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;，我在几分钟内实现了一个非常基本的负载均衡器，以此来说明我们如何使用 eBPF 来改变内核处理网络数据包的方式。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;在写这篇文章的时候，这段代码使用的是事件映射的 perf 缓冲器。如果你今天为最近的内核编写这段代码，你会从一个 &lt;a href=&#34;https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf&#34; title=&#34;ring buffer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ring buffer&lt;/a&gt; 中获得更好的性能，这是一个更新的替代方案。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;在一些内核中，你还会发现 &lt;code&gt;openat2()&lt;/code&gt;，但这个版本的 opensnoop 没有处理这个问题，至少在写作本文时是这样的。&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;你可以使用一个通用的工具，如 bpftool，它可以读取 BPF 对象文件并对其进行操作，但这需要用户知道关于加载什么以及将程序附加到什么事件的细节。对于大多数应用来说，编写一个特定的工具来为最终用户简化这一点是有意义的。&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;见 Andrii Nakryiko 描述 BPF 骨架代码生成的&lt;a href=&#34;https://lwn.net/Articles/806328/&#34; title=&#34;帖子&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第四章：eBPF 的复杂性</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/</guid>
      <description>
        
        
        &lt;p&gt;现在你已经看到了 eBPF 编程的例子，了解到它是如何工作的。虽然基础示例使得 eBPF 看起来相对简单，但也有一些复杂的地方使得 eBPF 编程充满挑战。&lt;/p&gt;
&lt;p&gt;长期以来，有个问题使得编写和发布 eBPF 程序相对困难，那就是内核兼容性。&lt;/p&gt;
&lt;h2 id=&#34;跨内核的可移植性&#34;&gt;跨内核的可移植性&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以访问内核数据结构，而这些结构可能在不同的内核版本中发生变化。这些结构本身被定义在头文件中，构成了 Linux 源代码的一部分。在过去编译 eBPF 程序时，必须基于你想运行这些程序的内核兼容的头文件集。&lt;/p&gt;
&lt;h3 id=&#34;bcc-对可移植性的处理方法&#34;&gt;BCC 对可移植性的处理方法&lt;/h3&gt;
&lt;p&gt;为了解决跨内核的可移植性问题，BCC &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（BPF 编译器集合，BPF Compiler Collection）项目采取了在运行时编译 eBPF 代码的方法，在目标机器上就地进行。这意味着编译工具链需要安装到每个你想让代码运行 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的目标机器上，而且你必须在工具启动之前等待编译完成，而且文件系统上必须有内核头文件（实际上并不总是这样）。这就引出了 BPF CO-RE。&lt;/p&gt;
&lt;h3 id=&#34;co-re&#34;&gt;CO-RE&lt;/h3&gt;
&lt;p&gt;CO-RE（Compile Once, Run Everyone，编译一次，到处运行）方法由以下元素组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BTF (BPF Type Format)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种用于表达数据结构和函数签名布局的格式。现代 Linux 内核支持 BTF，因此你可以从运行中的系统中生成一个名为 &lt;code&gt;vmlinux.h&lt;/code&gt; 的头文件，其中包含一个 BPF 程序可能需要的关于内核的所有数据结构信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libbpf，BPF 库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;libbpf 一方面提供了加载 eBPF 程序和映射到内核的功能，另一方面也在可移植性方面也起着重要的作用：它依靠 BTF 信息来调整 eBPF 代码，以弥补其编译时的数据结构与目标机器上的数据结构之间的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译器支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clang 编译器得到了增强，因此当它编译 eBPF 程序时，它包括所谓的 BTF 重定位（relocation），这使得 libbpf 在加载 BPF 程序和映射到内核时知道要调整什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可选的 BPF 骨架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; 可以从编译的 BPF 对象文件中自动生成一个骨架，其中包含用户空间代码可以方便调用的函数，以管理 BPF 程序的生命周期 —— 将它们加载到内核，附加到事件等等。这些函数是更高层次的抽象，对开发者来说比直接使用 libbpf 更方便。&lt;/p&gt;
&lt;p&gt;关于 CO-RE 的更详细的解释，请阅读 Andrii Nakryiko 的出色 &lt;a href=&#34;https://nakryiko.com/posts/bpf-portability-and-co-re/&#34; title=&#34;描述&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;描述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;自 5.4 版本 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 以来，&lt;code&gt;vmlinux&lt;/code&gt; 文件形式的 BTF 信息已经包含在 Linux 内核中，但 libbpf 可以利用的原始 BTF 数据也可以为旧内核生成。在 &lt;a href=&#34;https://github.com/aquasecurity/btfhub&#34; title=&#34;BTF Hub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF Hub&lt;/a&gt; 上有关于如何生成 BTF 文件的信息，以及用于各种 Linux 发行版的文件档案。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 方法使得 eBPF 程序更易于在任意 Linux 发行版上运行 —— 或者至少在新 Linux 发行版上支持任意 eBPF 能力。但这并不能使 eBPF 更优雅：它本质上仍然是内核编程。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核知识&#34;&gt;Linux 内核知识&lt;/h2&gt;
&lt;p&gt;很快就会发现，为了编写更高级的工具，你需要一些关于 Linux 内核的领域知识。你需要了解你可以访问的数据结构，取决于你的 eBPF 代码被调用的环境。不是所有应用程序的开发者都有解析网络数据包、访问套接字缓冲区或处理系统调用参数的经验。&lt;/p&gt;
&lt;p&gt;内核将如何对你 eBPF 代码的行为做出反应？正如你在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34; title=&#34;第二章&#34;&gt;第二章&lt;/a&gt; 中了解到的，内核由数百万行代码组成。它的文档可能是稀少的，所以你可能会发现自己不得不阅读内核的源代码来弄清楚某些东西是如何工作的。&lt;/p&gt;
&lt;p&gt;你还需要弄清楚你的 eBPF 代码应该附加到哪些事件。由于可以将 &lt;code&gt;kprobe&lt;/code&gt; 附加到整个内核的任何函数入口点，这可能不是一个简单的决定。在某些情况下，这可能很明确 —— 例如，如果你想访问一个传入的网络数据包，那么适当的网络接口上的 XDP 钩子是一个明显的选择。如果你想提供对特定内核事件的可观测性，在内核代码中找到合适的点可能并不难。&lt;/p&gt;
&lt;p&gt;但在其他情况下，选择可能不那么明显。例如，简单地使用 &lt;code&gt;kprobes&lt;/code&gt; 来钩住构成内核系统调用接口的函数的工具，可能会被名为 &lt;code&gt;time-of-check&lt;/code&gt; 到 &lt;code&gt;time-of-use&lt;/code&gt;（TOCTTOU）的安全漏洞所影响。攻击者有一个小的机会窗口，他们可以在 eBPF 代码读取参数后，但在参数被复制到内核内存之前，改变系统调用的参数。在 DEF CON 29 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 上，Rex Guo 和 Junyuan Zeng 做了一个关于这个问题的 &lt;a href=&#34;https://www.youtube.com/watch?v=yaAdM8pWKG8&amp;amp;ab_channel=DEFCONConference&#34; title=&#34;出色演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;出色演讲&lt;/a&gt;。一些被最广泛使用的 eBPF 工具是以相当天真的方式编写的，极易受到这种攻击。这不是一个简单的漏洞，而且有办法减轻这些攻击，但如果你正在保护高度敏感的数据，对抗复杂的、有动机的对手，请深入了解你使用的工具是否可能受到影响。&lt;/p&gt;
&lt;p&gt;你已经看到了 BPF CO-RE 是如何使 eBPF 程序在不同的内核版本上工作的，但它只考虑到了数据结构布局的变化，而没有考虑到内核行为的更大变化。例如，如果你想把一个 eBPF 程序附加到内核中的一个特定的函数或 tracepoint 上，你可能需要一个 B 计划，如果该函数或 tracepoint 在不同的内核版本中不存在，该怎么做。&lt;/p&gt;
&lt;h2 id=&#34;编排多个-ebpf-程序&#34;&gt;编排多个 eBPF 程序&lt;/h2&gt;
&lt;p&gt;当前有很多基于 eBPF 的工具提供了一套可观测能力，通过将 eBPF 程序与一组内核事件挂钩来实现。其中大部分是由 Brendan Gregg 和其他人在 BCC 和 &lt;code&gt;bpftrace&lt;/code&gt; 工具中所做的工作而开创的。很多工具（通常是商业的）可能会提供更漂亮的图形和用户界面，但他们还是在这些 eBPF 程序的基础上实现的。&lt;/p&gt;
&lt;p&gt;当你想写代码来编排不同类型的事件之间的交互时，事情就变得相当复杂了。举个例子，Cilium 通过内核的网络堆栈 &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 在不同的点上观察到网络数据包，基于来自 Kubernetes CNI（容器网络接口）关于 Kubernetes pod 的信息，对流量进行操作。构建这个系统需要 Cilium 开发人员深入了解内核如何处理网络流量，以及用户空间的 &lt;strong&gt;pod&lt;/strong&gt; 和 &lt;strong&gt;容器&lt;/strong&gt; 概念如何映射到内核概念，如 cgroups 和命 namespace。在实践中，一些 Cilium 的维护者也是内核的开发者，他们致力于增强 eBPF 和网络支持；因此，他们拥有这些知识。&lt;/p&gt;
&lt;p&gt;底线是，尽管 eBPF 提供了一个极其有效和强大的平台来连接到内核，但对于没有大量内核经验的普通开发者来说，这并不容易。如果你对 eBPF 编程感兴趣，我非常鼓励你把它作为练习来学习；在这个领域积累经验可能是非常有价值的，因为它在未来几年内一定会成为受欢迎的专业技能。但实际上，大多数组织不太可能在内部建立许多定制的 eBPF 工具，而是利用专业 eBPF 社区的项目和产品。&lt;/p&gt;
&lt;p&gt;让我们继续思考为什么这些基于 eBPF 的项目和产品在云原生环境中如此强大。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;GitHub 页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 页面&lt;/a&gt; 上找到 BCC。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;一些项目采取了将 eBPF 源和所需工具链打包成一个容器镜像的方法。这避免了安装工具链的复杂性和任何随之而来的依赖管理，但这仍意味着编译步骤在目标机器上运行。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;更多信息见 Andrii Nakryiko 的 IO Visor &lt;a href=&#34;https://lists.iovisor.org/g/iovisor-dev/message/1966&#34; title=&#34;帖子&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Rex Guo and Junyuan Zeng, &amp;ldquo;Phantom Attack: 逃离系统调用监控，&amp;quot;（DEF CON，2021 年 8 月 5-8 日）。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Cilium 文档描述了 eBPF 程序如何附加到不同的网络能力钩子，组合起来以实现复杂的网络能力。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第五章：云原生环境中的 eBPF</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/</guid>
      <description>
        
        
        &lt;p&gt;近年来，云原生应用已呈指数级增长。在本章中，我将讨论为什么 eBPF 如此适合于云原生环境。为了更具象化，我将提到 Kubernetes，但同样适用于任何容器平台。&lt;/p&gt;
&lt;h2 id=&#34;每台主机一个内核&#34;&gt;每台主机一个内核&lt;/h2&gt;
&lt;p&gt;要理解为什么 eBPF 在云原生世界中如此强大，你需要搞清楚一个概念：每台机器（或虚拟机）只有一个内核，所有运行在该机器上的容器都共享同一个内核 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 如 &lt;a href=&#34;#figure-f-5-1&#34; title=&#34;图 5-1&#34;&gt;图 5-1&lt;/a&gt; 所示，内核了解主机上运行的所有应用代码。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-5-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 5-1. 同一主机上的所有容器共享一个内核&#34; id=&#34;f-5-1&#34;data-img=&#34;f-5-1.jpg&#34;
         data-caption=&#34;图 5-1. 同一主机上的所有容器共享一个内核&#34;
         
         
         data-width=&#34;1490&#34;
         data-height=&#34;582&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 5-1. 同一主机上的所有容器共享一个内核
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;通过对内核的检测，就像我们在使用 eBPF 时做的那样，我们可以同时检测在该机器上运行的所有应用程序代码。当我们将 eBPF 程序加载到内核并将其附加到事件上时，它就会被触发，而不考虑哪个进程与该事件有关。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-与-sidecar-模式的比较&#34;&gt;eBPF 与 sidecar 模式的比较&lt;/h2&gt;
&lt;p&gt;在 eBPF 之前，Kubernetes 的可观测性和安全工具大多都采用了 sidecar 模式。这种模式允许你在与应用程序相同的 pod 中，单独部署一个工具容器。这种模式的发明是一个进步，因为这意味着不再需要直接在应用程序中编写工具代码。仅仅通过部署 sidecar，工具就获得了同一 pod 中的其他容器的可视性。注入 sidecar 的过程通常是自动化的，所以这提供了一种机制，以确保你的所有应用程序都被仪器化。&lt;/p&gt;
&lt;p&gt;每个 sidecar 容器都会消耗资源，而这要乘以注入了 sidecar 的 pod 的数量。这可能是非常重要的 —— 例如，如果每个 sidecar 需要它自己的路由信息副本，或策略规则，这就是浪费（关于这一点，Thomas Graf 写了一篇 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; title=&#34;关于服务网格 sidecar 与 eBPF 的比较&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于服务网格 sidecar 与 eBPF 的比较&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;Sidecar 的另一个问题是，你不能保证机器上的每一个应用程序都被正确检测。设想下有一个攻击者设法破坏了你的一台主机，并启动了一个单独的 pod 来运行，比如，加密货币挖矿程序。他们不可能对你有礼貌，用你的 sidecar 可观测或安全工具来检测他们的挖矿 pod。你需要一个单独的系统来了解这种活动。&lt;/p&gt;
&lt;p&gt;但同样的加密货币矿工与运行在该主机上的合法 pod 共享内核。如果你使用基于 eBPF 的工具，如 &lt;a href=&#34;#figure-f-5-2&#34; title=&#34;图 5-2&#34;&gt;图 5-2&lt;/a&gt; 所示，矿工会自动受到它的影响。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-5-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动&#34; id=&#34;f-5-2&#34;data-img=&#34;f-5-2.jpg&#34;
         data-caption=&#34;图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动&#34;
         
         
         data-width=&#34;1488&#34;
         data-height=&#34;818&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;ebpf-和进程隔离&#34;&gt;eBPF 和进程隔离&lt;/h2&gt;
&lt;p&gt;我主张将功能整合到一个单一的、基于 eBPF 的代理中，而不是每个 pod 的 sidecar 中。如果该代理可以访问机器上运行的所有 pod，这不是一种安全风险吗？我们不是失去了应用程序之间的隔离，而这种隔离可以防止它们相互干扰吗？&lt;/p&gt;
&lt;p&gt;作为一个容器安全领域的过来人，我可以体会到你对此的担忧，但重要的是要挖掘底层机制，以真正理解为什么它不是一开始可能出现的缺陷。&lt;/p&gt;
&lt;p&gt;请注意，这些 pod 共享同一个内核，而内核原生不能感知 pod 或容器。相反，内核对进程进行操作，并使用 cgroup 和 namespace 来隔离进程。这些结构由内核监管，以隔离用户空间中的进程，防止它们互相干扰。只要数据在内核中处理（例如，从磁盘中读取或发送到网络中），你就依赖于内核的正确行为。只有内核代码控制文件权限。没有其他层面的东西可以阻止内核忽略文件权限的东西，内核可以从任何文件中读取数据 —— 只是内核本身不会这样做。&lt;/p&gt;
&lt;p&gt;存在于 Linux 系统中的安全控制措施假定内核本身是可以信任的。它们的存在是为了防止在用户空间运行的代码产生不良行为。&lt;/p&gt;
&lt;p&gt;我们在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34; title=&#34;第二章&#34;&gt;第二章&lt;/a&gt; 中看到，eBPF 检查器确保 eBPF 程序只能访问它有权限的内存。检查器检查程序时不可能超出其职权范围，包括确保内存为当前进程所拥有或为当前网络包的一部分。这意味着 eBPF 代码比它周围的内核代码受到更严格的控制，内核代码不需要通过任何类型的检查器。&lt;/p&gt;
&lt;p&gt;如果攻击者逃脱了容器化的应用程序而到了节点上，而且还能够提升权限，那么该攻击者就可以危害到同一节点上的其他应用程序。由于这些逃逸是未知的，作为一个容器安全专家，我不建议在没有额外安全工具的情况下，在共享机器上与不受信任的应用程序或用户一起运行敏感的应用程序。对于高度敏感的数据，你甚至可能不希望在虚拟机中与不受信任的用户在同一裸机上运行。但是，如果你准备在同一台虚拟机上并行运行应用程序（这在许多不是特别敏感的应用程序中是完全合理的），那么 eBPF 就不会在共享内核已经存在的风险之上增加额外的风险。&lt;/p&gt;
&lt;p&gt;当然，恶意的 eBPF 程序可能造成各种破坏，当然也很容易写出劣迹的 eBPF 代码 —— 例如，复制每个网络数据包并将其发送给窃听者。默认情况下，非 root 用户没有加载 eBPF 程序 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的权限，只有当你真正信任他们时，你才应该授予用户或软件系统这种权限，就像 root 权限一样。因此，必须小心你所运行的代码的出处（有一个倡议正在进行中，以支持 eBPF 程序的签名检查来帮助解决这个问题）。你也可以使用 eBPF 程序来监视其他的 eBPF 程序！现在你已经对为什么 eBPF 是云原生工具的强大基础有了一个概念，下一章给你举一些来自云原生生态系统中的 eBPF 工具的具体例子。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;这基本正确，除非你使用的是虚拟化技术，像 KataContainer、Firecracker 或 unikernels 这样的方法，每个 &amp;ldquo;容器&amp;rdquo; 在自己的虚拟机中运行。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Linux &lt;code&gt;CAP_BPF&lt;/code&gt; 授予加载 BPF 程序的权限。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第六章：eBPF 工具</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-tools/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-tools/</guid>
      <description>
        
        
        &lt;p&gt;现在你已经了解了什么是 eBPF 以及它是如何工作的，我们再探索一些可能会在生产部署中使用的基于 eBPF 技术的工具。我们将举一些基于 eBPF 的开源项目的例子，这些项目提供了三方面的能力：网络、可观测性和安全。&lt;/p&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以连接到网络接口和内核的网络堆栈的各个点。在每个点上，eBPF 程序可以丢弃数据包，将其发送到不同的目的地，甚至修改其内容。这就实现了一些非常强大的功能。让我们来看看通常用 eBPF 实现的几个网络功能。&lt;/p&gt;
&lt;h3 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;Facebook 正在大规模的使用 eBPF 的网络功能，因此你不必对 eBPF 用于网络的可扩展性有任何怀疑。他们是 BPF 的早期采用者，并在 2018 年推出了 &lt;a href=&#34;https://engineering.fb.com/2018/05/22/open-source/open-sourcing-katran-a-scalable-network-load-balancer/&#34; title=&#34;Katran&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katran&lt;/a&gt;，一个开源的四层负载均衡器。&lt;/p&gt;
&lt;p&gt;另一个高度扩展的负载均衡器的例子是来自 Cloudflare 的 &lt;a href=&#34;https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/&#34; title=&#34;Unimog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unimog&lt;/a&gt; 边缘负载均衡器。通过在内核中运行，eBPF 程序可以操作网络数据包，并将其转发到适当的目的地，而不需要数据包通过网络堆栈和用户空间。&lt;/p&gt;
&lt;p&gt;Cilium 项目作为一个 eBPF Kubernetes 网络插件更为人所知（我一会儿会讨论），但作为独立的负载均衡器，它也被用于大型电信公司和企业内部部署。同样，因为它能够在早期阶段处理数据包，而不需要进入到用户空间，它具有很高的性能。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-网络&#34;&gt;Kubernetes 网络&lt;/h3&gt;
&lt;p&gt;CNCF 项目 Cilium 最初基于 eBPF 的 CNI 实现。它最初是由一群从事 eBPF 工作的内核维护者发起的，他们认识到 eBPF 在云原生网络中的应用潜力。它现在被用作谷歌 Kubernetes 引擎、亚马逊 EKS Anywhere 和阿里云的默认数据平面。&lt;/p&gt;
&lt;p&gt;在云原生环境下，pod 在不断的启停，每个 pod 都会被分配一个 IP 地址。在启用 eBPF 网络之前，当 pod 启停的时候，每个节点都必须为它们更新 iptables 规则，以便在 pod 之间进行路由；而当这些 iptable 规则规模变大后，将十分不便于管理。如 &lt;a href=&#34;#figure-f-6-1&#34; title=&#34;图 6-1&#34;&gt;图 6-1&lt;/a&gt; 所示，Cilium 极大地简化了路由，仅需在 eBPF 中创建的一个简单的查找表，就可以获得 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark/&#34; title=&#34;可观的性能改进&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观的性能改进&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另一个在传统的 iptables 版本之外还增加了 eBPF 实现的 Kubernetes CNI 是 &lt;a href=&#34;https://github.com/projectcalico/calico&#34; title=&#34;Calico&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calico&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-1. 用 eBPF 绕过主机网络堆栈&#34; id=&#34;f-6-1&#34;data-img=&#34;f-6-1.jpg&#34;
         data-caption=&#34;图 6-1. 用 eBPF 绕过主机网络堆栈&#34;
         
         
         data-width=&#34;968&#34;
         data-height=&#34;1546&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-1. 用 eBPF 绕过主机网络堆栈
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;服务网格&#34;&gt;服务网格&lt;/h3&gt;
&lt;p&gt;eBPF 作为服务网格数据平面的基础也是非常有意义的。许多服务网格在七层，即应用层运行，并使用代理组件（如 Envoy）来辅助应用程序。在 Kubernetes 中，这些代理通常以 sidecar 模式部署，每个 pod 中有一个代理容器，这样代理就可以访问 pod 的网络命名空间。正如你在 &lt;a href=&#34;../ebpf-in-cloud-native-environments&#34; title=&#34;第五章&#34;&gt;第五章&lt;/a&gt; 中看到的，eBPF 有一个比 sidecar 模型更有效的方法。由于内核可以访问主机中所有 pod 的命名空间，我们可以使用 eBPF 连接 pod 中的应用和主机上的代理，如 &lt;a href=&#34;#figure-f-6-2&#34; title=&#34;图 6-2&#34;&gt;图 6-2&lt;/a&gt; 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理&#34; id=&#34;f-6-2&#34;data-img=&#34;f-6-2.jpg&#34;
         data-caption=&#34;图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理&#34;
         
         
         data-width=&#34;1608&#34;
         data-height=&#34;1336&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;我还有一篇关于使用 eBPF 实现更高效的服务网格数据平面的文章，Solo.io 上也有发布过类似文章。在写这篇文章的时候，Cilium 服务网格已进入测试阶段，并显示出比传统的 sidecar 代理方法具有更大的 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; title=&#34;性能提升&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能提升&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;可观测性&#34;&gt;可观测性&lt;/h2&gt;
&lt;p&gt;正如你在本报告前面所看到的，eBPF 程序可以获得对机器上发生的一切的可观测性。通过收集事件数据并将其传递给用户空间，eBPF 实现了一系列强大的可观测性工具，可以向你展示你的应用程序是如何执行和表现的，而不需要对这些应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;在本报告的前面，你已经看到了 BCC 项目，几年来，Brendan Gregg 在 Netflix 做了开创性的工作，展示了这些 eBPF 工具如何被用来 &lt;a href=&#34;https://www.brendangregg.com/&#34; title=&#34;观测我们感兴趣的几乎任何指标&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;观测我们感兴趣的几乎任何指标&lt;/a&gt;，而且是大规模和高性能的。&lt;/p&gt;
&lt;p&gt;Kinvolk 的 &lt;a href=&#34;https://github.com/kinvolk/inspektor-gadget&#34; title=&#34;Inspektor Gadget&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inspektor Gadget&lt;/a&gt; 将其中一些起源于 BCC 的工具带入了 Kubernetes 的世界，这样你就可以在命令行上轻松观测特定的工作负载。&lt;/p&gt;
&lt;p&gt;新一代的项目和工具正在这项工作的基础上，提供基于 GUI 的观测能力。CNCF 项目 &lt;a href=&#34;https://px.dev/&#34; title=&#34;Pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt; 可以让你运行预先写好的或自定义的脚本，通过一个强大的、视觉上吸引人的用户界面查看指标和日志。因为它是基于 eBPF 的，这意味着你可以自动检测所有应用程序，获得性能数据，而无需进行任何代码修改或配置。&lt;a href=&#34;#figure-f-6-3&#34; title=&#34;图 6-3&#34;&gt;图 6-3&lt;/a&gt; 显示的只是 Pixie 中众多可视化的一个例子。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-3.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图&#34; id=&#34;f-6-3&#34;data-img=&#34;f-6-3.jpg&#34;
         data-caption=&#34;图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;892&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;另一个名为 &lt;a href=&#34;https://github.com/parca-dev/parca&#34; title=&#34;Parca&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Parca&lt;/a&gt; 的可观测性项目专注于连续剖析，使用 eBPF 对 CPU 使用率等指标进行有效采样，可以用来检测性能瓶颈。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/hubble&#34; title=&#34;Hubble&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hubble&lt;/a&gt; 组件是一个具有命令行界面和用户界面的可观测性工具（如 &lt;a href=&#34;#figure-f-6-4&#34; title=&#34;图 6-4&#34;&gt;图 6-4&lt;/a&gt; 所示），它专注于 Kubernetes 集群中的网络流。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-4.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量&#34; id=&#34;f-6-4&#34;data-img=&#34;f-6-4.jpg&#34;
         data-caption=&#34;图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;894&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;在云原生环境中，IP 地址不断被动态重新分配，基于 IP 地址的传统网络观测工具的作用非常有限。作为一个 CNI，Cilium 可以访问工作负载身份信息，这意味着 Hubble 可以显示由 Kubernetes pod、服务和命名空间标识的服务映射和流量数据。这对于诊断网络问题十分有用。&lt;/p&gt;
&lt;p&gt;能够观测到活动，这是安全工具的基础，这些工具将正在发生的事情与策略或规则相比较，以了解该活动是预期的还是可疑的。让我们来看看一些使用 eBPF 来提供云原生安全能力的工具。&lt;/p&gt;
&lt;h2 id=&#34;安全&#34;&gt;安全&lt;/h2&gt;
&lt;p&gt;有一些强大的云原生工具，通过使用 eBPF 检测甚至防止恶意活动来增强安全性。我将其分为两类：一类是确保网络活动的安全，另一类是确保应用程序在运行时的预期行为。&lt;/p&gt;
&lt;h3 id=&#34;网络安全&#34;&gt;网络安全&lt;/h3&gt;
&lt;p&gt;由于 eBPF 可以检查和操纵网络数据包，它在网络安全方面有许多用途。基本原理是，如果一个网络数据包被认为是恶意的或有问题的，因为它不符合一些安全验证标准，就可以被简单地丢弃。eBPF 可以很高效的来验证这一点，因为它可以钩住内核中网络堆栈的相关部分，甚至在网卡上 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。这意味着策略外的或恶意的数据包可以在产生网络堆栈处理和传递到用户空间的处理成本之前被丢弃。&lt;/p&gt;
&lt;p&gt;这里有一个 eBPF 早期在生产中大规模使用的一个例子 —— &lt;a href=&#34;https://blog.cloudflare.com/how-to-drop-10-million-packets/&#34; title=&#34;Cloudflare&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudflare&lt;/a&gt; 的 DDoS（分布式拒绝服务）保护。DDoS 攻击者用许多网络信息淹没目标机，希望目标机忙于处理这些信息，导致无法提供有效工作。Cloudflare 的工程师使用 eBPF 程序，在数据包到达后立即对其进行检查，并迅速确定一个数据包是否是这种攻击的一部分，如果是，则将其丢弃。数据包不必通过内核的网络堆栈，因此需要的处理资源要少得多，而且目标可以应对更大规模的恶意流量。&lt;/p&gt;
&lt;p&gt;eBPF 程序也被用于动态缓解”死亡数据包“的内核漏洞 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。攻击者以这样的方式制作一个网络工作数据包——利用了内核中的一个错误，使其无法正确处理该数据包。与其等待内核补丁的推出，不如通过加载一个 eBPF 程序来缓解攻击，该程序可以寻找这些特别制作的数据包并将其丢弃。这一点的真正好处是，eBPF 程序可以动态加载，而不必改变机器上的任何东西。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中，&lt;a href=&#34;https://networkpolicy.io/&#34; title=&#34;网络策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络策略&lt;/a&gt; 是一等资源，但它是由网络插件来执行的。一些 CNI，包括 Cilium 和 Calico，为更强大的规则提供了扩展的网络策略功能，例如允许或禁止流量到一个由完全限定域名而不是仅仅由 IP 地址指定的目的地。在 &lt;a href=&#34;https://app.networkpolicy.io/&#34; title=&#34;app.networkpolicy.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;app.networkpolicy.io&lt;/a&gt; 有一个探索网络策略及其效果的好工具，如 &lt;a href=&#34;#figure-f-6-5&#34; title=&#34;图 6-5&#34;&gt;图 6-5&lt;/a&gt; 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-5.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示&#34; id=&#34;f-6-5&#34;data-img=&#34;f-6-5.jpg&#34;
         data-caption=&#34;图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;1728&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;标准的 Kubernetes 网络策略规则适用于进出应用 pod 的流量，但由于 eBPF 对所有网络流量都有可视性，它也可用于主机防火墙功能，限制进出主机（虚拟机）的流量 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;eBPF 也可以被用来提供透明的加密，无论是通过 WireGuard 还是 IPsec &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。在这里，&lt;strong&gt;透明&lt;/strong&gt; 意味着应用程序不需要任何修改 —— 事实上，应用程序可以完全不知道其网络流量是被加密的。&lt;/p&gt;
&lt;h3 id=&#34;运行时安全&#34;&gt;运行时安全&lt;/h3&gt;
&lt;p&gt;eBPF 也被用来构建工具，检测恶意程序，防止恶意行为。这些恶意程序包括访问未经许可的文件，运行可执行程序，或试图获得额外的权限。&lt;/p&gt;
&lt;p&gt;事实上，你很可能已经以 seccomp 的形式使用了基于 BPF 的安全策略，这是一个 Linux 功能，限制应用程序可以调用的系统调用集。&lt;/p&gt;
&lt;p&gt;CNCF 项目 &lt;a href=&#34;https://falco.org/&#34; title=&#34;Falco&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falco&lt;/a&gt; 扩展了这种限制应用程序可以进行系统调用的想法。Falco 的规则定义是用 YAML 创建的，这比 seccomp 配置文件更容易阅读和理解。默认的 Falco 驱动是一个内核模块，但也有一个 eBPF 探针驱动，它与”原始系统调用“事件相联系。它不会阻止这些系统调用的完成，但它可以生成日志或其他通知，提醒操作人员注意潜在的恶意程序。&lt;/p&gt;
&lt;p&gt;正如我们在 &lt;a href=&#34;../ebpf-programs&#34; title=&#34;第三章&#34;&gt;第三章&lt;/a&gt; 中看到的，eBPF 程序可以附加到 LSM 接口上，以防止恶意行为或修复已知的漏洞。例如，Denis Efremov 写了一个 &lt;a href=&#34;https://github.com/evdenis/lsm_bpf_check_argc0&#34; title=&#34;eBPF 程序&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 程序&lt;/a&gt; 来防止 &lt;code&gt;exec()&lt;/code&gt; 系统调用在没有传递任何参数的情况下运行，以修复 PwnKit &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 的高危漏洞。eBPF 也可用于缓解投机执行的”Spectre“攻击 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aquasecurity/tracee&#34; title=&#34;Tracee&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracee&lt;/a&gt; 是另一个使用 eBPF 的运行时安全开源项目。除了基于系统调用的检查之外，它还使用 LSM 接口。这有助于避免受到 &lt;a href=&#34;https://lwn.net/Articles/245630/&#34; title=&#34;TOCTTOU 竞争&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOCTTOU 竞争&lt;/a&gt; 条件的影响，因为只检查系统调用时可能会出现这种情况。Tracee 支持用 Open Policy Agent 的 Rego 语言定义的规则，也允许用 Go 定义的插件规则。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/tetragon&#34; title=&#34;Tetragon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetragon&lt;/a&gt; 组件提供了另一种强大的方法，使用 eBPF 来监控 &lt;strong&gt;容器安全可观测性的四个黄金信号&lt;/strong&gt;：进程执行、网络套接字、文件访问和七层网络身份。这使操作人员能够准确地看到所有恶意或可疑事件，直击特定 pod 中的可执行文件名称和用户身份。例如，如果你受到加密货币挖矿的攻击，你可以看到到底是什么可执行程序打开了与矿池的网络连接，什么时候，从哪个 pod。这些取证是非常有价值的，可以了解漏洞是如何发生的，并使其容易建立安全策略，以防止类似的攻击再次发生。&lt;/p&gt;
&lt;p&gt;如果你想更深入地了解 eBPF 的安全可观测性这一主题，请查看 Natália Ivánkó 和 Jed Salazar 的报告 &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。请关注云原生 eBPF 领域，因为不久之后我们就会看到利用 BPF LSM 和其他 eBPF 定制的工具来提供安全执行和可以观测能力。&lt;/p&gt;
&lt;p&gt;我们在网络、可观测性和安全方面对几个云原生工具进行了考察。与前几代相比，eBPF 的使用为它们两个关键优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从内核中的有利位置来看，eBPF 程序对所有进程都有可视性。&lt;/li&gt;
&lt;li&gt;通过避免内核和用户空间执行之间的转换，eBPF 程序为收集事件数据或处理网络数据包提供了一种极其有效的方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着我们应该使用 eBPF 来处理所有的事情！在 eBPF 中编写特定业务的应用程序是没有意义的，就像我们不可能将应用程序写成内核模块一样。但是也有一些例外情况，比如对于高频交易这样对性能有极高的情况下。正如我们在本章中所看到的那样，eBPF 主要是用于为其他应用程序提供工具。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;有些网卡或驱动支持 XDP 或 eXpress Data Path 钩子，允许 eBPF 程序完全从内核中卸载出来。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Daniel Borkmann 在他的&lt;a href=&#34;https://www.youtube.com/watch?v=Qhm1Zn_BNi4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;中讨论了这个问题，《BPF 更适合作为数据平面》（eBPF 峰会（线上），2020 年）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;见 Cilium 的主机防火墙文档。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Tailscale 有这两种加密协议的&lt;a href=&#34;https://tailscale.com/kb/1173/ipsec-vs-wireguard/&#34; title=&#34;比较&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;比较&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;见 Bharat Jogi 的&lt;a href=&#34;https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034&#34; title=&#34;博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;，《PwnKit: 本地权限升级漏洞》（Qualys，2022 年 1 月 25 日）。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;见 Daniel Borkmann 的&lt;a href=&#34;https://www.youtube.com/watch?v=6N30Yp5f9c4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;，《BPF 和 Spectre：缓解瞬时执行攻击问题》（eBPF 峰会（线上），2021 年 8 月 18-19 日）。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Natália Ivánkó 和 Jed Salazar，《&lt;a href=&#34;https://learning.oreilly.com/library/view/security-observability-with/9781492096719/&#34; title=&#34;Security Observability with eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Security Observability with eBPF&lt;/a&gt;》（O’Reilly，2022）。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第七章：结论</title>
      <link>https://jimmysong.io/book/what-is-ebpf/conclusion/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/conclusion/</guid>
      <description>
        
        
        &lt;p&gt;我希望这个简短的报告能让你了解 eBPF 和它的强大之处。我真正希望的是，你已经准备好尝试一些基于 eBPF 的工具！如果你想在技术方面深入研究，可以从 &lt;a href=&#34;https://ebpf.io/&#34; title=&#34;ebpf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io&lt;/a&gt; 开始，在那里你会找到更多关于技术和 ebPF 基金会的信息。对于编码实例，可以在 GitHub 上的 &lt;a href=&#34;https://github.com/lizrice/ebpf-beginners&#34; title=&#34;ebpf-beginners&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf-beginners&lt;/a&gt; 仓库里找到。&lt;/p&gt;
&lt;p&gt;为了了解其他人是如何利用 eBPF 工具的，请参加 &lt;a href=&#34;https://twitter.com/ebpfsummit&#34; title=&#34;eBPF Summit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF Summit&lt;/a&gt; 和 &lt;a href=&#34;https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/&#34; title=&#34;Cloud Native eBPF Day&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native eBPF Day&lt;/a&gt; 等活动，在这些活动中，用户分享他们的成功和学习经验。还有一个活跃的 Slack 频道 &lt;a href=&#34;https://cilium.herokuapp.com/&#34; title=&#34;ebpf.io/slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io/slack&lt;/a&gt;。我希望能在那里见到你！&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>用 eBPF 洞察应用层网络流量</title>
      <link>https://jimmysong.io/trans/application-traffic-with-ebpf/</link>
      <pubDate>Wed, 10 Jan 2024 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/application-traffic-with-ebpf/</guid>
      <description>
        
        
        &lt;p&gt;在&lt;a href=&#34;../ebpf-adventures-in-networking/&#34; title=&#34;先前的帖子&#34;&gt;先前的帖子&lt;/a&gt;中，我稍微谈到了建立 eBPF 知识，以开始更多地了解网络适配器的输入和输出情况。基本上，将以太网帧并剥离标头（以太网标头+IP 标头+TCP/UDP 标头），最终你将得到来自应用程序或数据角度的数据包中剩余的内容。&lt;/p&gt;
&lt;p&gt;所有的代码都在“学习 eBPF”存储库中，具体的 eBPF 代码在&lt;a href=&#34;https://github.com/thebsdbox/learning-ebpf/blob/main/ebpf/http/http.c&#34; title=&#34;这里&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。这篇文章的计划是逐步介绍我认为有用或可能重要的部分&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此代码确实对入口/出口数据包进行了一些修改，因此需要 6.1+ 的 Linux 内核才能使用一些 eBPF 助手函数。&lt;/p&gt;
&lt;h2 id=&#34;映射&#34;&gt;映射！&lt;/h2&gt;
&lt;p&gt;你可能以前遇到过这些吧？如果没有，不用担心！简而言之，eBPF 映射是在用户空间和内核中的 eBPF 程序之间通信的机制。在我看来，非常酷的一点是这些映射使用键和值&amp;hellip;所以我不必循环比较数据并寻找匹配的内容，我传递一个键，如果有匹配的内容，我就得到相应的数据:D&lt;/p&gt;
&lt;p&gt;下面是我将要使用的映射，称为&lt;code&gt;url_map&lt;/code&gt;，键是 20 个字符长（可以说是有界的“字符串”），分配给该键的值是我在上面定义的结构体。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 定义与键关联的不同URL
struct url_path {
  __u8 path_len;
  __u8 path[max_path_len]; // 这应该是一个char，但在这里和Go之间的代码生成有点不同...
};

// 定义我的URL映射
struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 1024);
  __type(key, char[max_path_len]);
  __type(value, struct url_path);
}
url_map SEC(&amp;#34;.maps&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ebpf-程序&#34;&gt;eBPF 程序！&lt;/h2&gt;
&lt;p&gt;代码中定义了两个 eBPF 程序&lt;code&gt;tc_egress&lt;/code&gt;和&lt;code&gt;tc_ingress&lt;/code&gt;，如果你能猜到它们是如何连接的，那就加分！在这篇文章中，我们只关注&lt;code&gt;tc_ingress&lt;/code&gt;程序。&lt;/p&gt;
&lt;p&gt;就像我们在已经存在的众多示例中看到的那样，我们需要进行标头识别的操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进行合理性检查，并将&lt;code&gt;data&lt;/code&gt;强制转换为&lt;code&gt;ethhdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet_frame&#34; title=&#34;以太网标头&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以太网标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;通过读取以太网标头内部的&lt;code&gt;h_proto&lt;/code&gt;（也称为&lt;code&gt;Ethertype&lt;/code&gt;）来查找以太网帧内部的协议。&lt;/li&gt;
&lt;li&gt;将以太网标头后的数据强制转换为&lt;code&gt;iphdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Header&#34; title=&#34;IP 标头&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IP 标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;在 IP 标头内查找协议，我们还需要确定 IP 标头的大小（原来它们可以有不同的大小！&lt;code&gt;¯\_(ツ)_/¯&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;为了确定标头的大小，我们将其值乘以四，你可能会问为什么！好吧，这个值乘以 32 位以确定标头的大小，所以如果值为 6，那么标头将是 192 位（或 24 字节）。所以，为了简单地确定 IP 标头的字节数，我们可以将这个值乘以 4！&lt;/li&gt;
&lt;li&gt;将以 IP 标头后的数据强制转换为&lt;code&gt;tcphdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure&#34; title=&#34;TCP 标头&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;像步骤（5）一样，我们需要确定 TCP 标头的大小（它也可以是动态的），在这里的步骤也是一样的，我们只需要将值&lt;code&gt;doff&lt;/code&gt;乘以四来确定标头的大小（以字节为单位）。&lt;/li&gt;
&lt;li&gt;通过计算所有这些，我们现在可以推断出数据位于以太网标头大小、IP 标头大小和 TCP 标头大小的末尾。&lt;/li&gt;
&lt;li&gt;最后，我们可以通过从 IP 标头中减去 IP 和 TCP 标头的大小来确定应用程序数据的大小，使用&lt;code&gt;tot_len&lt;/code&gt;（总长度）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用数据&#34;&gt;应用数据！！&lt;/h3&gt;
&lt;p&gt;为了读取这些数据，我们将需要上面提到的一些东西！&lt;/p&gt;
&lt;p&gt;首先，我们需要数据偏移量（数据起始位置），它位于以太网标头+IP 标头大小（一旦计算出来）和 TCP 标头（再次，一旦计算出来）之后。我们还需要一个缓冲区来存储我们将从套接字缓冲区中读取的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 用于存储我们应用程序数据的数据缓冲区
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 计算数据实际位置的偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;poffset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ETH_HLEN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip_hlen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tcp_hlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 从套接字缓冲区加载数据，poffset 从 TCP 标头的末尾开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_skb_load_bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poffset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们使用&lt;code&gt;bpf_skb_load_bytes&lt;/code&gt;从套接字缓冲区（&lt;code&gt;skb&lt;/code&gt;）中读取一定量的数据（60 个字节）到我们的缓冲区（&lt;code&gt;pdata&lt;/code&gt;），起始位置是我们知道数据位于的偏移量（&lt;code&gt;poffset&lt;/code&gt;）！&lt;/p&gt;
&lt;p&gt;此时，我们有了 60 字节的数据，应该足够让我们编写一些代码来理解它。&lt;/p&gt;
&lt;h3 id=&#34;http-数据--&#34;&gt;HTTP 数据 :-)&lt;/h3&gt;
&lt;p&gt;让我们看看当我们尝试进行 HTTP 请求时会发生什么！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ~ curl code/test -vvv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*   Trying 192.168.0.22:80...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* Connected to code (192.168.0.22) port 80 (#0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; GET /test HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Host: code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; User-Agent: curl/7.87.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Accept: */*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我正在使用&lt;code&gt;curl&lt;/code&gt;从主机&lt;code&gt;code&lt;/code&gt;（code 是我的开发 VM，运行 code-server）请求 URL &lt;code&gt;/test&lt;/code&gt;。我们可以看到发送到服务器的数据（每行以&lt;code&gt;&amp;gt;&lt;/code&gt;开头，用于确定通信的方向）。HTTP 请求中的第一行数据通常是一个&lt;em&gt;动词&lt;/em&gt;，后面是我们希望与之交互的资源，然后是 HTTP 规范和回车符，如&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP#HTTP/1.1_request_messages&#34; title=&#34;HTTP 标准&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 标准&lt;/a&gt;中定义。因此，我们可以看到我们关心的行是&lt;code&gt;GET /test&lt;/code&gt;（在这一点上，我们/我不太关心 HTTP 规范:D）。&lt;/p&gt;
&lt;p&gt;第一步是读取&lt;code&gt;pdata&lt;/code&gt;的前三个字符，查找&lt;code&gt;pdata[0] == G&lt;/code&gt;，&lt;code&gt;pdata[1] == E&lt;/code&gt;和&lt;code&gt;pdata[2] == T&lt;/code&gt;，这将有效地帮助我们确定首先是否是 HTTP 请求，特别是是否是 HTTP 请求！&lt;/p&gt;
&lt;p&gt;一旦我们验证了这前 3 个字节，我们将想要从第 4 个字节（请求的前三个字节加上一个用于分隔的空格）开始读取更多数据！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_path_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;memset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 查找请求 URI（从偏移量 4 开始），以空格结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的函数将从 HTTP 数据的第 4 个字节开始（从第 4 个字节开始）读取其余的数据，直到遇到空格为止，留下我们要&lt;code&gt;GET&lt;/code&gt;的 URL！我们可以通过一个调试打印语句来验证这一点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;lt;- incoming path [%s], length [%d]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在日志中显示如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017812: bpf_trace_printk: &amp;lt;- incoming path [/test], length [5]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;对-http-应用程序请求采取行动&#34;&gt;对 HTTP 应用程序请求采取行动&lt;/h3&gt;
&lt;p&gt;上述解释详细说明了我们如何读取数据以及如何读取数据，但如果我们想要“动态”查找 HTTP 请求，我们将需要使用 eBPF 映射。&lt;/p&gt;
&lt;p&gt;在我们的 Go 用户空间代码中，我们执行以下操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;The URL Path to watch for&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Parse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建一个 uint8 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 将我们的字节复制到 uint8 数组中（我们可以进行类型转换）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:],&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 将我们的 urlPath 作为键
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;objs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UrlMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;bpfUrlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;PathLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如我们在上面的代码中看到的，当我们启动 Go 程序时，它将从标志&lt;code&gt;-path&lt;/code&gt;中读取，并将其用作我们 eBPF 映射中的&lt;strong&gt;键&lt;/strong&gt;，可以暂时忽略值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;found_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;url_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;found_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;bpf_printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Looks like we&amp;#39;ve found your path [%s]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 可能进行更多操作，阻止流量或重定向？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们的 eBPF 程序中，我们将对 HTTP 请求进行映射查找，如果该请求作为 char 数组存在于&lt;strong&gt;键&lt;/strong&gt;中，那么我们就可以对其进行操作！&lt;/p&gt;
&lt;p&gt;现在启动我们的 Go 程序 &lt;code&gt;sudo ./http -interface ens160 -path /test&lt;/code&gt; 将得到以下结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Starting 🐝 the eBPF HTTP watcher, on interface [ens160] for path [/test]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Loaded TC QDisc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Press Ctrl-C to exit and remove the program
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.015575: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] D.s3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;. 2252901.015642: bpf_trace_printk: -&amp;gt; 192.168.0.22:80 -&amp;gt; 192.168.0.180:56345
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.017552: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.017793: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017812: bpf_trace_printk: &amp;lt;- incoming path [/test], length [5]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017814: bpf_trace_printk: Looks like we&amp;#39;ve found your path [/test]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;解析 HTTP 并不太困难，因为它是一个相对简单的协议，它使用简单的动词和结构的简单方法，使用空格和回车符来区分。这种方法可能也适用于其他协议，如 DNS、POP3 或 SMTP。当数据加密时，我们需要一种解密的方法，然后才能解析数据（这超出了我的能力&amp;hellip;）。但是，我希望这会激发你更多地尝试使用 eBPF 来解析和操作应用程序的想法！&lt;/p&gt;
&lt;p&gt;我一直想写一些有希望有用的关于 eBPF 的帖子，尽管通常在我想出可能有用的东西之后，别人已经抢先一步。鉴于我已经在一段时间里以某种方式关注网络，这基本上是我关注的领域，尽管我确实为最近的 eBPF 峰会 2023 编写了一些有趣的内容。如上所述，有很多人开始撰写 eBPF 内容，所以我可能会参考他们的帖子，而不是重复内容。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>如何用 eBPF 改变网络编程的游戏规则</title>
      <link>https://jimmysong.io/trans/ebpf-adventures-in-networking/</link>
      <pubDate>Wed, 10 Jan 2024 08:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/ebpf-adventures-in-networking/</guid>
      <description>
        
        
        &lt;p&gt;我一直想写一些关于 eBPF 的帖子，希望它们能有所帮助，尽管通常在我想到可能有用的东西时，其他人已经先我一步了。鉴于我已经在网络方面集中精力一段时间，这基本上是我专注的领域，尽管我确实设法为最近的 eBPF 峰会 2023 准备了一些我认为很有趣的东西。正如我之前提到的，有很多人开始撰写关于 eBPF 的内容，因此我可能会参考他们的帖子，而不是重复内容。&lt;/p&gt;
&lt;p&gt;我将从一些在 Linux 内核中可能或可能不会遇到的首字母缩写或技术开始。但基本上从我的角度来看，这些是你修改正在运行的系统以与网络数据交互的主要选项。&lt;/p&gt;
&lt;h3 id=&#34;xdp&#34;&gt;XDP&lt;/h3&gt;
&lt;p&gt;关于 eXpress Data Plane 已经存在大量信息，因此我不会深入探讨太多细节。&lt;code&gt;tl;dr&lt;/code&gt;是 XDP eBPF 程序挂钩到 XDP 将使其能够访问由内核自身处理之前的传入网络帧。在某些情况下，eBPF 程序将加载到 NIC 驱动程序本身中，这将有效地将程序卸载到 NIC 本身。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最佳性能&lt;/li&gt;
&lt;li&gt;非常适用于防火墙、DDoS 防护或负载均衡等用例&lt;/li&gt;
&lt;li&gt;在任何其他内容进行修改之前看到传入的流量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;仅支持入站流量，使用 XDP 程序看到的任何流量都只是传入流量，目前无法看到出站流量&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;XDP&lt;/code&gt;数据结构，与大多数套接字编程的默认数据结构&lt;code&gt;SKB&lt;/code&gt;有一些不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tctraffic-control或流量控制&#34;&gt;TC（Traffic Control）或流量控制&lt;/h3&gt;
&lt;p&gt;Traffic Control 是内核网络结构的一个重要组成部分，主要包括添加诸如 qdisc 和过滤器之类的功能到接口的能力。qdisc 主要集中在为 TBD（待定）提供服务，而过滤器通常在底层实际上是一个 eBPF 程序。&lt;/p&gt;
&lt;p&gt;常见的工作流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个关注入口或出口的 qdisc，或者替换一个现有的 qdisc。qdisc 将附加到接口上。&lt;/li&gt;
&lt;li&gt;加载你的 eBPF 程序。&lt;/li&gt;
&lt;li&gt;创建一个过滤器，将其附加到通过接口上的 qdisc 上的入口或出口之一。该过滤器将与 eBPF 程序相关联，这意味着所有传入或传出的流量现在都会通过一个程序运行（如果连接）。&lt;/li&gt;
&lt;li&gt;获利 💰&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优点-1&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供入口和出口的挂钩点&lt;/li&gt;
&lt;li&gt;使用传统的&lt;code&gt;SKB&lt;/code&gt;数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点-1&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将 TC 程序附加到入口或出口队列稍微复杂一些。用户需要使用 qdisc 来做到这一点，某些 eBPF SDK 不会原生支持 TC 程序的使用。&lt;/li&gt;
&lt;li&gt;TC eBPF 程序看到的流量可能已经被之前的 XDP 程序或内核本身修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;
&lt;p&gt;与其他两种专门设计用于处理网络的方法相比，这可能会显得有些奇怪，因为它是将一些 eBPF 代码附加到内核中的系统调用的一种替代方法，具体来说是&lt;code&gt;tcp4_connect()&lt;/code&gt; / &lt;code&gt;tcp6_connect()&lt;/code&gt;等调用。这在协议栈中略微靠后，因为在此时，传入数据包已经经过了很多内核逻辑，而 eBPF 内省点是当流量即将与应用程序本身交互时。&lt;/p&gt;
&lt;h2 id=&#34;编写网络程序&#34;&gt;编写网络程序！&lt;/h2&gt;
&lt;p&gt;所以在这一点上，我们（希望）意识到我们有许多不同的入口点，允许我们在“传送带”上注入我们的代码，这个传送带从 NIC 开始，一直到应用程序（以及在出站的情况下）。&lt;/p&gt;
&lt;h3 id=&#34;回顾&#34;&gt;回顾&lt;/h3&gt;
&lt;p&gt;在我们所谓的“传送带”的开头，我们可以附加我们的 XDP 程序并获得未经触碰的原始网络数据。在“传送带”的中间，我们的 TC 程序将成为通过内核的路径的一部分，并接收可能被修改的网络数据。在传送带的末端，我们可以将代码附加到应用程序将在它被运行之前获取网络数据的函数，这些函数可以在传送带的末端进行附加。&lt;/p&gt;
&lt;h3 id=&#34;数据表示&#34;&gt;数据表示&lt;/h3&gt;
&lt;p&gt;你的程序附加到的位置决定了两个主要事物，一个是潜在的流量修改的相对级别，另一个是流量的表示方式。&lt;/p&gt;
&lt;h3 id=&#34;xdp-结构&#34;&gt;XDP 结构&lt;/h3&gt;
&lt;p&gt;我会写关于它的内容，但是 DataDog 已经做了，你可以在&lt;a href=&#34;https://www.datadoghq.com/blog/xdp-intro/#the-flow-of-an-xdp-program&#34; title=&#34;这里&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;阅读。&lt;/p&gt;
&lt;h3 id=&#34;skb套接字缓冲区&#34;&gt;SKB（套接字缓冲区）&lt;/h3&gt;
&lt;p&gt;SKB 是在 eBPF 添加到内核之前就存在于内核中的数据类型，它已经具备了一些使与 SKB 对象交互变得稍微容易一些的辅助功能。有关更深入的 SKB 介绍，你可以阅读此文 -&amp;gt; &lt;a href=&#34;http://vger.kernel.org/~davem/skb_data.html&#34; title=&#34;http://vger.kernel.org/~davem/skb_data.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://vger.kernel.org/~davem/skb_data.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;解析数据&#34;&gt;解析数据&lt;/h3&gt;
&lt;p&gt;无论与哪个结构进行交互，它们都共享一些共同之处，这主要是两个变量，对于这两种数据类型来说是相同的。&lt;/p&gt;
&lt;p&gt;这些变量是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;，它是 eBPF 程序接收到的数据的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data_len&lt;/code&gt;，它是一个整数，指定了有多少数据可用（以帮助确保你永远不会访问&lt;code&gt;data&lt;/code&gt;超过&lt;code&gt;data_len&lt;/code&gt;（显而易见的真理 🤓））&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以这一切似乎很简单，但等等&amp;hellip; &lt;code&gt;*data&lt;/code&gt;中实际上有什么？（这取决于你的发现）&lt;/p&gt;
&lt;p&gt;通过不断“转换”&lt;code&gt;*data&lt;/code&gt;并沿着它移动以剥离各种标头，我们可以了解和查找底层数据！&lt;/p&gt;
&lt;h3 id=&#34;转换&#34;&gt;转换？&lt;/h3&gt;
&lt;p&gt;如果你愿意，你可以跳过此部分，但这是一个快速（且糟糕）的示例，说明了我们通常如何将一些原始数据转换为有意义的东西。目前，&lt;code&gt;*data&lt;/code&gt;将只是一串随机数据，毫无意义，我们需要有效地为其添加“格式”以便我们可以理解其外观。&lt;/p&gt;
&lt;p&gt;考虑一下随机数据行：“Bobby0004500100.503 Harvard Drive90210”，其中一些对裸眼来说是有意义的，但有些是不清楚的。&lt;/p&gt;
&lt;p&gt;想象一下名为“person”的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Name: string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Age: number
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Balance: float
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Street: string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ZipCode: number
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们要将我们的随机数据“转换”为上面的“person”结构，它将突然变成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Name: Bobby
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Age: &lt;span class=&#34;m&#34;&gt;45&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Balance: 100.50
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Street: &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; Harvard Drive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ZipCode: &lt;span class=&#34;m&#34;&gt;90210&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在突然间，我能够理解并访问结构中的底层变量，因为它们现在是有意义的，即 person-&amp;gt;Name，并且发现此特定的 person 类型对象具有名称变量“Bobby”！&lt;/p&gt;
&lt;p&gt;这正是我们将对我们的&lt;code&gt;*data&lt;/code&gt;所做的！&lt;/p&gt;
&lt;h3 id=&#34;数据中包含什么&#34;&gt;数据中包含什么？&lt;/h3&gt;
&lt;p&gt;因此，第一步是确定数据是否以以太网帧开头！几乎所有传输的数据都以以太网帧开头，这相当简单，但其作用是具有源和目标硬件地址（无论虚拟化/容器化/有线网络还是 WiFi 如何）。因此，我们的第一步是将我们的&lt;code&gt;*data&lt;/code&gt;转换为类型&lt;code&gt;ETHHDR&lt;/code&gt;，如果成功，我们现在将能够了解组成以太网头数据类型的变量。这些包括源和目标 MAC 地址，但更重要的是剩余数据的内容是什么。再次，在大多数情况下，以太网头之后的&lt;code&gt;*data&lt;/code&gt;内容通常是 IP 头，但我们将通过检查以太网帧的 TBD 变量来验证。&lt;/p&gt;
&lt;p&gt;一旦我们验证下一组数据是 IP 头，我们将需要将以太网头之后的数据转换为 IPHDR 类型。一旦我们这样做，我们将能够访问 IP 特定的数据，例如源 IP（&lt;code&gt;saddr&lt;/code&gt;）或目标地址（&lt;code&gt;daddr&lt;/code&gt;），再次重要的是 IP 头包含一个变量，详细说明了 IP 头之后的数据是什么。这通常是 TCP 头或 UDP 头，但还有其他选择，例如 sctp 等。&lt;/p&gt;
&lt;p&gt;一旦我们查看了 IP 头的内部并确定数据类型是 TCP（也可能是 UDP 或其他内容），我们将把以太网头和 IP 头之后的数据都转换为 TCP 头类型！（几乎完成了）。通过访问 TCP 头的内容，我们可以获得 TCP 特定的数据，例如源端口或目标端口，用于验证数据的有效性的校验和以及其他有用的变量。&lt;/p&gt;
&lt;p&gt;现在我们几乎拥有一切，但是 TCP 头的长度可能是可变的，因此我们需要通过查看 tcl_len 变量来确定这一点，我们需要将其乘以 4。现在我们拥有了访问最终数据所需的一切！&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;*data&lt;/code&gt;指向数据的开头！我们已经确定了以太网头之后是 IP 头，最后是 TCP 头，这意味着`*data + 以太网头 + IP 头 + TCP 头 = 实际应用程序数据！&lt;/p&gt;
&lt;h3 id=&#34;我们可以用这些信息做什么&#34;&gt;我们可以用这些信息做什么？&lt;/h3&gt;
&lt;p&gt;当我们解析各种标头时，实际上在 OSI 模型的不同层次上解锁了越来越多的信息！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 2 层]&lt;/strong&gt; 以太网头为我们提供了源和目标硬件地址，我们可以使用此信息来潜在地阻止从我们知道危险的源 MAC 地址处理的帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 3 层]&lt;/strong&gt; IP 头包含源和目标 IP 地址，再次，我们可以像防火墙一样运作，通过使用 eBPF 程序丢弃特定 IP 地址的所有流量。或者，我们可以根据 IP 地址重定向流量，或者甚至在这一层实施负载均衡逻辑，以将流量重定向到其他底层 IP 地址集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 4 层]&lt;/strong&gt; TCP 或 UDP 标头定义了目标端口号，我们可以使用这些信息来确定应用程序协议是什么（即端口 80 通常意味着剩余的*data 可能是 HTTP 数据）。在这一层，我们通常会执行负载均衡等操作，基于目标（即在多个其他负载均衡器地址之间平衡）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 7 层]&lt;/strong&gt; 正如前面提到的，各种标头集合的末尾的数据是实际的应用程序数据，只要我们知道格式，我们也可以解析它。例如，如果外部 Web 浏览器尝试访问我的计算机上的&lt;code&gt;/index.html&lt;/code&gt;并附加了 eBPF 程序，我会解析到 TCP，然后确定它是端口 80，然后应用程序数据应该是 HTTP 格式。我可以通过查看应用程序数据的前三个字符（在所有标头之后）来验证这一点，使用以下伪代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ApplicationData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; EthernetHDR + IPHDR + TCPHDR // 将所有标头长度相加以找到数据
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;If &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;G&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData+1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData+2&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;T&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 这是一个HTTP GET请求
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 做一些令人兴奋的事情
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;现在我们“有点”理解了这个逻辑，也许我们应该考虑实施一些代码来完成所有这些&amp;hellip;但这将是另一天的事情。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>使用 Geneve 隧道实现 Istio Ambient Mesh 的流量拦截</title>
      <link>https://jimmysong.io/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/</link>
      <pubDate>Fri, 24 Mar 2023 15:03:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/</guid>
      <description>
        
        
        &lt;p&gt;在我&lt;a href=&#34;https://jimmysong.io/blog/ambient-mesh-l4-traffic-path/&#34; title=&#34;之前的博客&#34;&gt;之前的博客&lt;/a&gt;分享中提到 Istio Ambient Mesh 使用 iptables 和 Geneve 隧道将应用程序 Pod 中的流量拦截到 Ztunnel 中。很多读者可能还不了解这种隧道协议，本文将为你介绍 Geneve 隧道的定义，报文结构，以及与 VXLAN 协议的比较有哪些优势。最后，本文将介绍 Istio Ambient Mesh 如何应用 Geneve 隧道来实现流量拦截，以及 Istio 1.18 中新推出的 eBPF 模式。&lt;/p&gt;
&lt;h2 id=&#34;geneve-隧道简介&#34;&gt;Geneve 隧道简介&lt;/h2&gt;
&lt;p&gt;GENEVE（Generic Network Virtualization Encapsulation）是一种网络虚拟化封装（隧道）协议，它的设计的初衷是为了解决当前数据传输缺乏灵活性和安全性的问题。Geneve 只定义了一种数据封装格式，不包括控制平面的信息。GENEVE 相较于 VXLAN 封装的关键优势在于其通过添加 TLV 格式的选项来扩展可封装的协议类型。&lt;/p&gt;
&lt;h2 id=&#34;geneve-vs-vxlan&#34;&gt;Geneve vs VXLAN&lt;/h2&gt;
&lt;p&gt;VXLAN 和 Geneve 都是网络虚拟化协议，它们之间有很多共同点。虚拟化协议是一种将虚拟网络与物理网络分离的技术，它允许网络管理员在虚拟环境中创建多个虚拟网络，每个虚拟网络都可以拥有自己的 VLAN 标识符、IP 地址和路由。此外，VXLAN 和 Geneve 协议都使用 UDP 封装，这使得它们能够通过现有网络基础设施进行扩展。VXLAN 和 Geneve 协议还具有灵活性，它们可以在不同的网络拓扑结构中使用，并且可以与不同的虚拟化平台兼容。&lt;/p&gt;
&lt;p&gt;图 1 展示了 VXLAN 与 Geneve 协议的报文结构及其各自的 Header 区别。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/vxlan-vs-geneve.svg&#34; data-img=&#34;/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/vxlan-vs-geneve.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 1：VXLAN 与 Geneve 报文格式示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 1：VXLAN 与 Geneve 报文格式示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从图中我们可以看到，VXLAN 与 Geneve 隧道报文的结构类似，其主要区别在于使用不同的 UDP 端口号和协议头 ——VXLAN 使用 4789 端口，Geneve 使用 6081 端口；Geneve 协议头比 VXLAN 更具扩展性。&lt;/p&gt;
&lt;p&gt;Geneve 隧道协议比 VXLAN 更加可扩展是因为 Geneve 隧道协议中增加了变长选项，它可以包含零或多个 TLV 格式的选项数据。TLV 是指类型 - 长度 - 值（Type-Length-Value）格式，用于传输和解析网络包的元数据信息。在 Geneve 协议中，每个元数据信息都由一个 TLV 格式的字段组成，以便于灵活地添加、删除和修改这些元数据。&lt;/p&gt;
&lt;p&gt;具体来说，TLV 格式的字段包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type：8 位的类型字段。&lt;/li&gt;
&lt;li&gt;Length：5 位的选项长度字段，以 4 字节倍数表示，不包括选项头。&lt;/li&gt;
&lt;li&gt;Data：可变长的选项数据字段，可以不存在或者为 4 到 128 字节之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过使用 TLV 格式，Geneve 协议可以轻松地扩展和修改元数据信息，同时保持兼容性和灵活性。&lt;/p&gt;
&lt;p&gt;关于 VXLAN 隧道报文的详细信息请参考 &lt;a href=&#34;https://tools.ietf.org/html/rfc7348&#34; title=&#34;RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;关于 Geneve 隧道报文的详细信息请参考 &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8926#name-geneve-packet-format-over-i&#34; title=&#34;RFC 8926 Geneve: Generic Network Virtualization Encapsulation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 8926 Geneve: Generic Network Virtualization Encapsulation&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;Geneve 隧道主要应用在云计算和虚拟机化场景，它可以将数据包封装在一个新的数据包中，以便在虚拟网络中传输。Geneve 隧道使用一个 24 位的虚拟网络标识符 (VNI)，将数据包从一个物理网络传输到另一个物理网络。Geneve 隧道还可以使用安全性协议，如 IPsec、TL，来保护数据包的传输。&lt;/p&gt;
&lt;p&gt;当数据包到达目的主机时，Geneve 隧道协议会将数据包从 Geneve 协议头中解封装出来，并将其传递给虚拟网络中的目的地。在解封装过程中，Geneve 协议头中的 VNI 信息会被来判断数据包的目的地，以确保数据包被正确地路由到虚拟网络中的目的地。&lt;/p&gt;
&lt;p&gt;假设有一个虚拟网络，其 VNI 为 1001。当数据包从一个物理网络传输到另一个物理网络时，可以使用隧道将数据包从一个物理网络传输到另一个物理网络。在这种情况下，隧道将源物理网络和目标物理网络之间的虚拟网络标识符 (VNI) 设置为 1001，以便在传输期间跟踪数据包。当数据包到达目标物理网络时，隧道将 VNI 从数据包中删除，并将数据包传递给目标物理网络。&lt;/p&gt;
&lt;h3 id=&#34;安全性&#34;&gt;安全性&lt;/h3&gt;
&lt;p&gt;Geneve 隧道协议本身并没有提供任何安全机制，因此在 Geneve 隧道中传输的数据包可能会受到威胁，例如数据包被篡改、截获、重放等。&lt;/p&gt;
&lt;p&gt;为了保障 Geneve 隧道中传输的数据包的安全性，可以使用一些安全协议。以下是一些常见的安全协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPsec（Internet Protocol Security）：IPsec 是一种网络层安全协议，可以对 Geneve 隧道中的数据包进行加密、认证和完整性保护。使用 IPsec 可以提供端到端的安全性。&lt;/li&gt;
&lt;li&gt;TLS（Transport Layer Security）：TLS 是一种基于传输层的加密协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 TLS 可以提供端到端的安全性。&lt;/li&gt;
&lt;li&gt;MACSec（Media Access Control Security）：MACSec 是一种数据链路层的安全协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 MACSec 可以提供链路层的安全性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，以上安全协议都需要进行相应的配置和部署，且可能会对性能产生一定的影响。在选择合适的安全协议时，需要考虑安全性、性能、可管理性等方面的因素。&lt;/p&gt;
&lt;h3 id=&#34;为什么选择-geneve&#34;&gt;为什么选择 Geneve？&lt;/h3&gt;
&lt;p&gt;下表对比了 VXLAN 与 Geneve 在多个方面的特点。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;VXLAN&lt;/th&gt;
&lt;th&gt;Geneve&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;头部格式&lt;/td&gt;
&lt;td&gt;固定格式&lt;/td&gt;
&lt;td&gt;可扩展格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可扩展性&lt;/td&gt;
&lt;td&gt;更多地专注于 L2 扩展&lt;/td&gt;
&lt;td&gt;更好地支持新兴网络服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可操作性&lt;/td&gt;
&lt;td&gt;较难管理和扩展&lt;/td&gt;
&lt;td&gt;更容易管理和扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;头部较短，性能较高&lt;/td&gt;
&lt;td&gt;头部较长，性能略低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用 Geneve 协议的主要原因是将目前网络虚拟化封装技术（例如 VXLAN、NVGRE 和 STT）中的优点合并到一个协议中。我们通过多年的网络虚拟化开发经验得知，其中一个重要的需求是可扩展性。Geneve 协议使用可扩展的 TLV 结构对元数据进行编码，因此可以独立地发展软件和硬件端点的功能，以满足不断增长的需求。&lt;/p&gt;
&lt;h2 id=&#34;istio-ambient-mesh-如何应用-geneve-隧道&#34;&gt;Istio Ambient Mesh 如何应用 Geneve 隧道&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://jimmysong.io/blog/ambient-mesh-l4-traffic-path/&#34; title=&#34;之前的博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;之前的博客&lt;/a&gt;中，我讲解了 Istio Ambient Mesh 如何使用 Ztunnel 实现 L4 代理的，图 2 展示使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/geneve-tunnel.svg&#34; data-img=&#34;/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/geneve-tunnel.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 2：使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 2：使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从图中我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio CNI 在节点上创建 &lt;code&gt;istioout&lt;/code&gt; 网卡和 iptables 规则，将节点中的出站流量透明劫持到 &lt;code&gt;pistioout&lt;/code&gt; 虚拟网卡；&lt;/li&gt;
&lt;li&gt;Istio CNI 在节点上创建 &lt;code&gt;istioin&lt;/code&gt; 网卡和 iptables 规则，将节点中的入站流量透明劫持到 &lt;code&gt;pistioin&lt;/code&gt; 虚拟网卡；&lt;/li&gt;
&lt;li&gt;Istio CNI 在 ztunnel 中创建 &lt;code&gt;pistioin&lt;/code&gt; 和 &lt;code&gt;pistioout&lt;/code&gt; 网卡，用于接收 Geneve 隧道中的发来的数据包；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pistioin&lt;/code&gt; 和 &lt;code&gt;pistioout&lt;/code&gt; 这两个网卡是由 ztunnel 中的 init 容器或 Istio CNI（见 &lt;a href=&#34;https://github.com/istio/istio/blob/master/cni/pkg/ambient/net_linux.go#L910&#34; title=&#34;&amp;lt;code&amp;gt;CreateRulesWithinNodeProxyNS&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;CreateRulesWithinNodeProxyNS&lt;/code&gt;&lt;/a&gt; 函数）创建的，其 IP 地址和端口也是固定的。应用容器发出的数据包需要经过 &lt;code&gt;istioout&lt;/code&gt; 网卡并使用 Geneve 隧道封装后转发给 ztunnel 容器。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-进行透明流量劫持&#34;&gt;使用 eBPF 进行透明流量劫持&lt;/h2&gt;
&lt;p&gt;eBPF（extended Berkeley Packet Filter）是一个功能强大的技术，它可以在 Linux 内核中运行安全的用户态程序。eBPF 最初是一种用于过滤网络数据包的技术，但现在已经扩展到其他领域，如跟踪系统调用、性能分析和安全监控等。eBPF 的优势在于其轻量级、高效、安全和可编程性。它可以被用于实时监控、网络安全、应用程序调试和优化、容器网络等多个领域。&lt;/p&gt;
&lt;p&gt;在 Istio 1.18 之前，Ambient 模式中使用 iptables 和 Geneve 隧道将应用程序流量透明劫持到 ztunnel 中。在 Istio 1.18 中，增加了 eBPF 选项，你可以选择使用 iptables 或 eBPF 来做流量劫持。如图 3 所示，eBPF 程序直接运行在宿主机内核，将应用程序的流量转发到 ztunnel 中。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/ebpf.svg&#34; data-img=&#34;/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/ebpf.svg&#34; alt=&#34;image&#34; data-caption=&#34;图 3：使用 eBPF 劫持应用程序的流量&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 3：使用 eBPF 劫持应用程序的流量&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;图 3：使用 eBPF 劫持应用程序的流量&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比项&lt;/th&gt;
&lt;th&gt;eBPF 方式&lt;/th&gt;
&lt;th&gt;使用 iptables 和 Geneve 隧道&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;效率&lt;/td&gt;
&lt;td&gt;更高&lt;/td&gt;
&lt;td&gt;略低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;兼容性&lt;/td&gt;
&lt;td&gt;需要较高的 Linux 内核版本&lt;/td&gt;
&lt;td&gt;更好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实现难度&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;td&gt;较低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扩展性&lt;/td&gt;
&lt;td&gt;较好&lt;/td&gt;
&lt;td&gt;较差&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://istio.io/latest/blog/2023/ambient-ebpf-redirection/&#34; title=&#34;Istio 官方博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 官方博客&lt;/a&gt;介绍，使用 eBPF 方式避免了部分 iptables 规则和隧道封装，相比使用 iptables 和 Geneve 隧道更加高效。然而，eBPF 对 Linux 内核版本的要求更高（至少 4.20），而 iptables 方式则具有更好的兼容性。此外，eBPF 方式的实现难度较高，但扩展性较好。&lt;/p&gt;
&lt;p&gt;要想使用 eBPF 模式运行 Ambient Mesh，只需要在安装 Istio 时设置 &lt;code&gt;values.cni.ambient.redirectMode&lt;/code&gt; 参数即可，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ambient --set values.cni.ambient.redirectMode&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ebpf&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了 Geneve 隧道协议的工作原理、安全性和与 VXLAN 的比较。此外，还介绍了 Istio Ambient Mesh 如何使用 Geneve 隧道实现流量拦截，并讨论了使用 eBPF 进行透明流量劫持的优缺点。Geneve 隧道协议是一种通用的隧道协议，可以在虚拟网络中传输数据包，具有更多的优势，因此在选择隧道协议时，用户可以考虑使用 Geneve 隧道。在 Istio 1.18 中新推出了 Ambient Mesh 的的 eBPF 模式，可以提供网络效率，但对 Linux 内核版本有更高要求，用户可以根据自己的实际情况选用。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7348&#34; title=&#34;RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8926#name-geneve-packet-format-over-i&#34; title=&#34;RFC 8926 Geneve: Generic Network Virtualization Encapsulation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 8926 Geneve: Generic Network Virtualization Encapsulation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/ops/deployment/architecture/#istio-ambient-mesh&#34; title=&#34;Istio Ambient Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Ambient Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mankier.com/8/ovs-vswitchd.conf.db%285%29&#34; title=&#34;Open vSwitch Geneve(8) man page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open vSwitch Geneve(8) man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Beyond Istio OSS —— Istio 服务网格的现状与未来</title>
      <link>https://jimmysong.io/blog/beyond-istio-oss/</link>
      <pubDate>Sat, 23 Jul 2022 15:27:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/beyond-istio-oss/</guid>
      <description>
        
        
        


&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    关于本文
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    本文根据笔者在 GIAC 深圳 2022 年大会上的的演讲&lt;a href=&#34;https://giac.msup.com.cn/2022sz/course?id=16093&#34; title=&#34;《Beyond Istio OSS —— Istio 的现状及未来》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Beyond Istio OSS —— Istio 的现状及未来》&lt;/a&gt;整理而成，演讲幻灯片见 &lt;a href=&#34;https://docs.qq.com/pdf/DRWxETHNDZmRsS0l5&#34; title=&#34;腾讯文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;腾讯文档&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;本文回顾了 Istio 开源近五年来的发展，并展望了 Istio 服务网格的未来方向。本文的主要观点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 Kubernetes、微服务、DevOps 及云原生架构的流行，导致服务网格技术的兴起；&lt;/li&gt;
&lt;li&gt;Kubernetes 和可编程代理，为 Istio 的出现打下了坚实的基础；&lt;/li&gt;
&lt;li&gt;虽然 eBPF 可以加速 Istio 中的透明流量劫持，但无法取代服务网格中的 sidecar；&lt;/li&gt;
&lt;li&gt;Istio 的未来在于构建基于混合云的零信任网络；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-dawn-of-istio&#34;&gt;Istio 诞生的前夜&lt;/h2&gt;
&lt;p&gt;2013 年起，随着移动互联网的爆发，企业对应用迭代的效率要求更高，应用程序架构开始从单体转向微服务，DevOps 也开始变得流行。同年随着 Docker 的开源，解决了应用封装和隔离的问题，使得应用在编排系统中调度变得更容易。2014 年 Kubernetes、Spring Boot 开源，Spring 框架开发微服务应用开始流行，在接下来的几年间大批的 RPC 中间件开源项目出现，如 Google 在 2016 年发布 gRPC 1.0，蚂蚁在 2018 年开源 &lt;a href=&#34;https://www.sofastack.tech/&#34; title=&#34;SOFAStack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAStack&lt;/a&gt; 等，微服务框架百花齐放。为了节约成本，增加开发效率，使应用更具弹性，越来越多的企业正在迁移上云，但这不仅仅是将应用搬到云上那么简单，为了更高效地利用云计算，一套「云原生」方法和理念也呼之欲出。&lt;/p&gt;
&lt;h2 id=&#34;istio-open-time-line&#34;&gt;Istio 开源时间线&lt;/h2&gt;
&lt;p&gt;Istio 开源发展时间线如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/istio-history.svg&#34; data-img=&#34;/blog/beyond-istio-oss/istio-history.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio 开源发展时间线示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istio 开源发展时间线示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;下面我们来简单回顾下 Istio 开源大事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016 年 9 月：因为 Envoy 是 Istio 中的重要组成，Istio 的开源时间线应该有 Envoy 一部分。起初 Envoy 在 Lyft 内部仅作为边缘代理，开源前已在 Lyft 内部得到大规模生产验证并受到了 Google 工程师的注意 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，那时候 Google 正打算推出一个服务网格的开源项目。2017 年，Lyft 将 Envoy 捐献给了 &lt;a href=&#34;https://cncf.io&#34; title=&#34;CNCF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;2017 年 5 月：Istio 由 Google、IBM 和 Lyft 联合宣布开源 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。一开始就使用了微服务架构，确定了数据平面和控制平面的组成以及 Sidecar 模式。&lt;/li&gt;
&lt;li&gt;2018 年 3 月：Kubernetes 顺利的成为从 CNCF 中第一个毕业的项目，变得越来越「无聊」，基础 API 已经定型，CNCF 正式将服务网格（Service Mesh）写入到了云原生的第二版定义 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 中。笔者当前就职的公司 &lt;a href=&#34;https://tetrate.io&#34; title=&#34;Tetrate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;，也是在那时由 Google Istio 初创团队创业成立的。服务网格在中国开始爆发，ServiceMesher 社区也在蚂蚁集团的支持下成立，在中国布道服务网格技术。&lt;/li&gt;
&lt;li&gt;2018 年 7 月：Istio 1.0 发布，号称「生产可用」，Istio 团队重组。&lt;/li&gt;
&lt;li&gt;2020 年 3 月：Istio 1.5 发布，架构回归单体，发布周期确定，每三个月发布一个大版本，API 趋于稳定。&lt;/li&gt;
&lt;li&gt;2020 年至今：Istio 的发展主要着重于 Day 2 Operation &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;、性能优化和扩展性发面，多个围绕 Istio 生态的开源项目开始出现，例如 &lt;a href=&#34;https://github.com/slime-io/slime/&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;、&lt;a href=&#34;https://github.com/aeraki-mesh/aeraki&#34; title=&#34;Areaki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Areaki&lt;/a&gt;、&lt;a href=&#34;https://github.com/merbridge/merbridge&#34; title=&#34;Merbridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Merbridge&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-istio-born-after-kubernetes&#34;&gt;为什么 Istio 会在 Kubernetes 之后出现？&lt;/h2&gt;
&lt;p&gt;微服务和容器化之后，异构语言使用的增加，服务的数量激增，容器的生命周期变短是导致服务网格出现的根本原因。&lt;/p&gt;
&lt;p&gt;我们先来看下服务从部署在 Kubernetes 到 Istio 中架构的变迁，然后再探讨架构演进过程中 Istio 的需求，下文假定读者已了解 &lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/&#34; title=&#34;Kubernetes&#34;&gt;Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://istio.io/latest/zh/docs/ops/deployment/architecture/&#34; title=&#34;Istio 的架构&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 的架构&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/kubernetes-to-istio.svg&#34; data-img=&#34;/blog/beyond-istio-oss/kubernetes-to-istio.svg&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 到 Istio 的架构改变示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes 到 Istio 的架构改变示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从 Kubernetes 到 Istio，概括的讲应用的部署架构有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes 管理应用的生命周期，具体来说，就是应用的部署和管理（扩缩容、自动恢复、发布策略）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 Kubernetes 的自动 sidecar 注入，实现了透明流量拦截。先通过 sidecar 代理拦截到微服务间流量，再通过控制平面配置管理微服务的行为。如今服务网格的部署模式也迎来了新的挑战，sidecar 已经不是 Istio 服务网格所必须的，基于 gRPC 的无代理的服务网格 &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 也在测试中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务网格将流量管理从 Kubernetes 中解耦，服务网格内部的流量无须 &lt;code&gt;kube-proxy&lt;/code&gt; 组件的支持，通过类似于微服务应用层的抽象，管理服务间的流量，实现安全性和可观测性功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制平面通过 xDS 协议发放代理配置给数据平面，已实现 xDS 的代理有 &lt;a href=&#34;https://envoyproxy.io&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 和蚂蚁开源的 &lt;a href=&#34;https://mosn.io&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes 集群外部的客户端访问集群内部服务时，原先是通过 Kubernetes &lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/service-discovery/ingress/&#34; title=&#34;Ingress&#34;&gt;Ingress&lt;/a&gt;，在有了 Istio 之后，会通过 Gateway 来访问 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Kubernetes 容器编排与可编程代理 Envoy 为 Istio 的出现打下了坚实的基础。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面 Kubernetes 到 Istio 的架构的转变的描述中，我们可以看到为了让开发者最小成本地管理服务间的流量，Istio 需要解决三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;透明劫持应用间的流量&lt;/strong&gt;：Istio 开源最初的目标是成为网络基础设施，就像水和电人类的基础设施一样，我们使用水电不需要关心如何取水和发电，只需要打开水龙头，按下开关即可。透明流量劫持对于开发者来说，就像使用水和电，不需要修改应用程序就可以快速使用 Istio 带来的流量管理能力；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理集群的运维&lt;/strong&gt;：如何为每个应用注入一个代理，同时高效地管理这些分布式的 sidecar 代理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可编程代理&lt;/strong&gt;：代理可以通过 API 动态配置，还要有出色的性能与可扩展性；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上三个条件对于 Istio 服务网格来说缺一不可，而且，从中我们可以看到，这些要求基本都是对于 sidecar 代理的要求，这个代理的选择将直接影响该项目的走向与成败。为了解决以上三个问题，Istio 选择了 Kubernetes 容器编排和可编程代理 Envoy。&lt;/p&gt;
&lt;h3 id=&#34;traffic-intercept&#34;&gt;透明流量劫持&lt;/h3&gt;
&lt;p&gt;如果你使用的是如 gRPC 这类中间件开发微服务，在程序中集成 SDK 后，SDK 中的拦截器会自动为你拦截流量，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/grpc.svg&#34; data-img=&#34;/blog/beyond-istio-oss/grpc.svg&#34; alt=&#34;image&#34; data-caption=&#34;gRPC 的拦截器示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;gRPC 的拦截器示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;如何让 Kubernetes  pod 中的流量都通过代理呢？答案是在每个应用程序 pod 中注入一个代理，与应用共享网络空间，再通过修改 pod 内的流量路径，让所有进出 pod 的流量都经过 sidecar，其架构如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/istio-route-iptables.svg&#34; data-img=&#34;/blog/beyond-istio-oss/istio-route-iptables.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio 中的透明流量劫持示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istio 中的透明流量劫持示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从图中我们可以看到其中有一套非常复杂的 iptables 流量劫持逻辑（详见 &lt;a href=&#34;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&#34; title=&#34;Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解&#34;&gt;Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解&lt;/a&gt;），使用 iptables 的好处是适用于任何 Linux 操作系统。但是这也带来了一些副作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio 网格中所有的服务都需要在进出 pod 时都增加了一个网络跳跃点（hop），虽然每次 hop 可能只有两三毫秒，但是随着网格中服务和服务间的依赖增加，这种延迟可能会显著增加，对于那种追求低延迟的服务可能就不适用于服务网格了；&lt;/li&gt;
&lt;li&gt;因为 Istio 向数据平面中注入了大量的 sidecar，尤其是当服务数量增大时，控制平面需要下发更多的 Envoy 代理配置到数据平面，这样会使数据平面占用大量的系统内存和网络资源；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这两个问题，如何优化服务网格呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 proxyless 模式：取消 sidecar 代理，重新回到 SDK；&lt;/li&gt;
&lt;li&gt;优化数据平面：减少下发到数据平面的配置的频率和大小；&lt;/li&gt;
&lt;li&gt;eBPF：使用 eBPF 优化网络劫持；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将在后面&lt;a href=&#34;#performance-optimizing&#34; title=&#34;性能优化&#34;&gt;性能优化&lt;/a&gt;一节讲解这些细节。&lt;/p&gt;
&lt;h3 id=&#34;sidecar-management&#34;&gt;Sidecar 运维管理&lt;/h3&gt;
&lt;p&gt;Istio 是在 Kubernetes 的基础上构建的，它可以利用 Kubernetes 的容器编排和生命周期管理，在 Kubernetes 创建 pod 时，通过准入控制器自动向 pod 中注入 sidecar。&lt;/p&gt;
&lt;p&gt;为了解决 Sidecar 的资源消耗问题，有人为服务网格提出了有四种部署模式，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/deployment-model.svg&#34; data-img=&#34;/blog/beyond-istio-oss/deployment-model.svg&#34; alt=&#34;image&#34; data-caption=&#34;服务网格的四种部署模式示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;服务网格的四种部署模式示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;下表中详细对比了这四种部署方式，它们各有优劣，具体选择哪种根据实际情况而定。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;模式&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;内存开销&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;故障域&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;运维&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Sidecar 代理&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;因为为每个 pod 都注入一个代理，所以开销最大。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于 sidecar 必须与工作负载一起部署，工作负载有可能绕过 sidecar。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Pod 级别隔离，如果有代理出现故障，只影响到 Pod 中的工作负载。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以单独升级某个工作负载的 sidecar 而不影响其他工作负载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;节点共享代理&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每个节点上只有一个代理，为该节点上的所有工作负载所共享，开销小。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对加密内容和私钥的管理存在安全隐患。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;节点级别隔离，如果共享代理升级时出现版本冲突、配置冲突或扩展不兼容等问题，则可能会影响该节点上的所有工作负载。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要考虑注入 Sidecar 的问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Service Account / 节点共享代理&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务账户 / 身份下的所有工作负载都使用共享代理，开销小。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;工作负载和代理之间的连接的认证及安全性无法保障。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;节点和服务账号之间级别隔离，故障同“节点共享代理”。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同“节点共享代理”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;带有微代理的共享远程代理&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;因为为每个 pod 都注入一个微代理，开销比较大。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;微代理专门处理 mTLS，不负责 L7 路由，可以保障安全性。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当需要应用 7 层策略时，工作负载实例的流量会被重定向到 L7 代理上，若不需要，则可以直接绕过。该 L7 代理可以采用共享节点代理、每个服务账户代理，或者远程代理的方式运行。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同“Sidecar 代理”。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption class=&#34;text-center&#34;&gt;
    
    服务网格的四种部署模式对比
    
&lt;/figcaption&gt;

&lt;h3 id=&#34;programmable-proxy&#34;&gt;可编程代理&lt;/h3&gt;
&lt;p&gt;Flomesh 的张晓辉曾在 &lt;a href=&#34;https://cloudnative.to/blog/what-and-why-programmable-proxy/&#34; title=&#34;为什么需要可编程代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为什么需要可编程代理&lt;/a&gt; 博客中详细说明了代理软件的发展演化过程，我下面将引用他的一些观点，说明可编程代理 Envoy 在 Istio 中的关键作用。&lt;/p&gt;
&lt;p&gt;下图展示了代理从配置到可编程模式的演化过程，及每个阶段中的代表性代理软件。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/proxy-evolution.svg&#34; data-img=&#34;/blog/beyond-istio-oss/proxy-evolution.svg&#34; alt=&#34;image&#34; data-caption=&#34;代理软件的演化示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;代理软件的演化示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;整个代理演化过程都是随着应用从本地和单体，越来越走向大规模和分布式。下面我将简要概括代理软件的发展过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;配置文件时代&lt;/strong&gt;：几乎所有软件都有配置文件，代理软件因为其相对复杂的功能，更离不开配置文件。该阶段的代理主要使用 C 语言开发，包括其扩展模块，突出的代理本身的能力。这也是我们使用代理最原始最基础的形式，这些代理包括 Nginx、Apache HTTP Server、&lt;a href=&#34;http://www.squid-cache.org/&#34; title=&#34;Squid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Squid&lt;/a&gt; 等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置语言时代&lt;/strong&gt;：这个时代的代理，更具扩展性和灵活性，比如动态数据获取和配套的逻辑判断。代表性代理包括扩 &lt;a href=&#34;https://varnish-cache.org/&#34; title=&#34;Varnish&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Varnish&lt;/a&gt; 和 HAProxy；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;脚本语言时代&lt;/strong&gt;：从脚本语言的引入开始，代理软件才真正走向的可编程，我们可以更方便的使用脚本在代理中增加动态逻辑，增加了开发效率。代表性的代理是 Nginx 及其支持的脚本语言；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集群时代&lt;/strong&gt;：随着云计算的普及，大规模部署和动态配置 API 成了代理所必需的能力，而且随着网络流量的增加，大规模代理集群也应运而生。这个时代的代表性代理有 Envoy、Kong 等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云原生时代&lt;/strong&gt;：多租户、弹性、异构混合云、多集群、安全和可观测，这些都是云原生时代对代理所提出的更高要求，代表性软件有 Istio、Linkerd、&lt;a href=&#34;https://flomesh.io/&#34; title=&#34;Pypi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pypi&lt;/a&gt;，它们都为代理构建了控制平面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;are-they-service-mesh&#34;&gt;这些都是服务网格吗？&lt;/h2&gt;
&lt;p&gt;现在我将列举一些流行的服务网格开源项目，让我们一起探索服务网格的发展规律和本质。下表对比了当前流行的服务网格开源项目 &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对比项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Istio&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Linkerd&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Consul Connect&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Traefik Mesh&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Kuma&lt;/th&gt;
&lt;th&gt;Open Service Mesh (OSM)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当前版本&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.14&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2.11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1.5&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;许可证&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Apache License 2.0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Apache License 2.0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Mozilla License&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Apache License 2.0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Apache License 2.0&lt;/td&gt;
&lt;td&gt;Apache License 2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发起者&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Google、IBM、Lyft&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Buoyant&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HashiCorp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Traefik Labs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Kong&lt;/td&gt;
&lt;td&gt;Microsoft&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务代理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Envoy，支持 gRPC 的 proxyless 模式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://github.com/linkerd/linkerd2-proxy&#34; title=&#34;Linkerd2-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd2-proxy&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;默认为 &lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;，可替换&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://traefik.io/traefik/&#34; title=&#34;Traefik Proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik Proxy&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;入口控制器&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Envoy，自定义的 Ingress，支持 Kubernetes  Gateway API&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无内置&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Envoy，支持 Kubernetes Gateway API&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无内置&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Kong&lt;/td&gt;
&lt;td&gt;支持 Contour、Nginx，兼容其他&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;治理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Istio Community 和 Open Usage Commons，已提议捐献给 CNCF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CNCF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看 &lt;a href=&#34;https://github.com/hashicorp/consul/blob/master/.github/CONTRIBUTING.md&#34; title=&#34;贡献指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;贡献指南&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看 &lt;a href=&#34;https://github.com/traefik/mesh/blob/master/CONTRIBUTING.md&#34; title=&#34;贡献指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;贡献指南&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CNCF&lt;/td&gt;
&lt;td&gt;CNCF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption class=&#34;text-center&#34;&gt;
    
    服务网格开源项目对比表
    
&lt;/figcaption&gt;

&lt;p&gt;上表中列出的都是服务网格，下面再简单评论一下这些项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;：目前最流行的服务网格项目之一，在中国几乎成为了服务网格的代名词；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkerd.io&#34; title=&#34;Linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt;：最早出现的服务网格，「Service Mesh」概念提出者，第一个进入 CNCF 的服务网格项目，使用自研的 Rust 语言编写轻量级 sidecar 代理；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/traefik-mesh/&#34; title=&#34;Traefik Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik Mesh&lt;/a&gt;：由 Traefik 推出的服务网格项目，使用 Treafik proxy 作为 sidecar，支持 SMI（接下来会提到），它的特点是对应用的无侵入性，不会在 pod 中注入 sidecar；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kuma.io/&#34; title=&#34;Kuma&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuma&lt;/a&gt;：由 Kong 推出的服务网格项目，使用 Envoy 作为 Sidecar 代理，特色是使用 Kong 自家的网关作为入口网关；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/docs/connect&#34; title=&#34;Consul Connect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul Connect&lt;/a&gt;：Consul 服务网格，使用 Envoy 作为 sidecar 代理；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openservicemesh.io/&#34; title=&#34;Open Service Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Service Mesh&lt;/a&gt;：由微软开源的服务网格，使用 Envoy 作为 sidecar，兼容 SMI（同样是微软提出）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有几个项目，也服务网格领域也经常被提及，但它们都不是服务网格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://envoyproxy.io&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;：Envoy 本身只是代理，也经常被作为其他基于 Envoy 的服务网格的 sidecar，也经常被用来构建 API Gateway；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://smp-spec.io/&#34; title=&#34;Service Mesh Performance（SMP）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Performance（SMP）&lt;/a&gt;：标准化了服务网格值的指标，通过捕获基础设施容量、服务网格配置和工作负载元数据的细节来描述任何部署的性能；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://smi-spec.io/&#34; title=&#34;Service Mesh Interface（SMI）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Interface（SMI）&lt;/a&gt;：它不是服务网格，而只是一套服务网格实现标准，与 OAM、SPIFFE、CNI、CSI 等类似都是定义接口标准，具体实现就不一而足了。目前 Traefik Mesh 和 Open Service Mesh 声明支持该规范；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://networkservicemesh.io/&#34; title=&#34;Network Service Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Network Service Mesh&lt;/a&gt;：有必要提一下这个项目，因为经常有人把它错认为是一个服务网格。实际上，它面向的是三层网络，使用它可以在不更换 CNI 插件的前提下，连接多云/混合云。它并不是我们所定义的「服务网格」，而是服务网格的一个有力补充（虽然名字里带有服务网格比较有迷惑性）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;纵观以上项目，我们可以看出大部分服务网格项目的发起者都是根据代理起家，然后做控制平面。而且 Istio、Consul Connect、Open Service Mesh、Kuma 都是使用 Envoy 作为 sidecar 代理。只有 Linkerd 和 Traefik Mesh 推出了自己的代理。而所有的服务网格项目都支持 sidecar 模式。除了 Istio、Linkerd、Consul Connect 已应用于生产上，其他服务网格项目还没有看到被大规模在生产上使用。&lt;/p&gt;
&lt;h2 id=&#34;performance-optimizing&#34;&gt;Istio 的性能优化&lt;/h2&gt;
&lt;p&gt;在 Istio 1.5 版本确定了稳定的架构之后，社区的主要精力在于优化 Istio 的性能。下面我将向你详细介绍 Istio 中的性能优化方法，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用 Proxyless 模式；&lt;/li&gt;
&lt;li&gt;使用 eBPF 优化流量劫持；&lt;/li&gt;
&lt;li&gt;控制平面性能优化；&lt;/li&gt;
&lt;li&gt;数据平面性能优化；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;proxyless-pattern&#34;&gt;Proxyless 模式&lt;/h3&gt;
&lt;p&gt;Proxyless 模式是 Istio 在 1.11 版本中提出的实验特性 —— &lt;a href=&#34;https://cloudnative.to/blog/grpc-proxyless-service-mesh/&#34; title=&#34;基于 gRPC 和 Istio 的无 sidecar 代理的服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 gRPC 和 Istio 的无 sidecar 代理的服务网格&lt;/a&gt;。使用该模式可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。下图展示了 sidecar 模式与 proxyless 模式的对比图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/sidecar-to-proxyless.svg&#34; data-img=&#34;/blog/beyond-istio-oss/sidecar-to-proxyless.svg&#34; alt=&#34;image&#34; data-caption=&#34;Sidecar 模式 vs Proxyless 模式&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Sidecar 模式 vs Proxyless 模式&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从上图中我们可以看到，虽然 proxyless 模式不使用 proxy 进行数据平面通信，但仍然需要一个 agent（即 &lt;code&gt;pilot-agent&lt;/code&gt;）来进行初始化和与控制平面的通信。首先，agent 在启动时生成一个&lt;a href=&#34;https://github.com/grpc/proposal/blob/master/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file&#34; title=&#34;引导文件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引导文件&lt;/a&gt;，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 &lt;code&gt;istiod&lt;/code&gt;，在哪里可以找到用于数据平面通信的证书，向控制平面发送什么元数据。接下来，agent 作为 xDS proxy，代表应用程序与 &lt;code&gt;istiod&lt;/code&gt; 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书，这其实与 Sidecar 模式的流程是一样的，只是将 Envoy 代理的功能内置到 SDK 中了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;服务网格的本质不是 Sidecar 模式，也不是配置中心或透明流量拦截，而是标准化的服务间通信标准。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有人说 proxyless 模式又回到了基于 SDK 开发微服务的老路，服务网格的优势丧失殆尽，那还能叫做服务网格吗 &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;？其实这也是一种对性能的妥协 —— 如果你主要使用 gRPC 来开发微服务的话，只需要维护不同语言的 gRPC 版本，即可以通过控制平面来管理微服务了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Envoy xDS 已经成为服务网格中服务间通信的事实标准。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ebpf&#34;&gt;使用 eBPF 优化流量劫持&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&#34;#traffic-intercept&#34; title=&#34;透明流量劫持&#34;&gt;透明流量劫持&lt;/a&gt;一节，我们可以看到一个服务间的流量在到达目的地 pod 时经过的 iptables 规则和路径，其中需要经过多条 iptables 规则，如 &lt;code&gt;PREROUTING&lt;/code&gt;、&lt;code&gt;ISTIO_INBOUND&lt;/code&gt;、&lt;code&gt;ISTIO_IN_REDIRECT&lt;/code&gt;、&lt;code&gt;OUTPUT&lt;/code&gt;、&lt;code&gt;ISTIO_OUTPUT&lt;/code&gt;、&lt;code&gt;POSTROUTING&lt;/code&gt; 等。假设现在有一个服务 A 想要调用非本地主机上的另一个 pod 中的服务 B，经过的网络堆栈如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/iptables-process.svg&#34; data-img=&#34;/blog/beyond-istio-oss/iptables-process.svg&#34; alt=&#34;image&#34; data-caption=&#34;非同主机 Pod 间的服务访问路径（iptables 模式）&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;非同主机 Pod 间的服务访问路径（iptables 模式）&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从图中我们可以看到整个调用流程中经过四次 iptables，其中 Pod A 中的从 Envoy 的出站（iptables2）和 Pod B 中的从 eth0 的入站（iptables3）的 iptables 路由是无法避免的，那么剩下的两个 iptables1 和 iptables4 是否可以优化呢？让两个 socket 直接通信，不就可以缩短网络路径了吗？这就需要通过 eBPF 编程，使得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service A 的流量从直接发送到 Envoy 的 Inbound socket 上；&lt;/li&gt;
&lt;li&gt;Pod B 中 Envoy 接收到入站流量后，已经确定流量是要发送给本地的服务，直接对接 Outbound socket 与 Service B；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 eBPF 模式的透明流量拦截网络路径如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/ebpf-diff-node.svg&#34; data-img=&#34;/blog/beyond-istio-oss/ebpf-diff-node.svg&#34; alt=&#34;image&#34; data-caption=&#34;非同主机 Pod 间的服务访问路径（eBPF 模式）&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;非同主机 Pod 间的服务访问路径（eBPF 模式）&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;如果要访问的服务 A 和服务 B 在同一个节点上，那么网络路径将更短。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/ebpf-same-node.svg&#34; data-img=&#34;/blog/beyond-istio-oss/ebpf-same-node.svg&#34; alt=&#34;image&#34; data-caption=&#34;同主机 Pod 间的网络访问路径（eBPF 模式）&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;同主机 Pod 间的网络访问路径（eBPF 模式）&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;同一个节点中的服务间访问完全绕过了 TCP/IP 堆栈，变成了 socket 间的直接访问。&lt;/p&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    什么是 eBPF？
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    &lt;p&gt;我们知道修改 Linux 内核代码很难，新特性发布到内核中需要很长的周期。eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。也就是说，有了 eBPF，你不需要直接修改内核，就可以扩展和改变内核的行为。下面我将简要的为大家介绍一下 eBPF：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF 程序加载到内核中后需要通过验证器的验证才可以运行，验证器可以防止 eBPF 程序超越权限的访问，这样可以确保内核的安全；&lt;/li&gt;
&lt;li&gt;eBPF 程序是附着于内核事件上的，当有进入或退出内核函数时被触发；&lt;/li&gt;
&lt;li&gt;内核空间的 eBPF 程序必须使用能够支持生成 eBPF 字节码格式的编译器的语言编写，目前你可以用 C 和 Rust 语言编写 eBPF 程序；&lt;/li&gt;
&lt;li&gt;eBPF 程序对于不同的 Linux 版本存在兼容性问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 eBPF 程序可以直接监听和操作 Linux 内核，具有对系统最底层的透视，就可以在流量管理、可观测性和安全发挥作用。有关 eBPF 的详细介绍请参考笔者翻译的&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/&#34; title=&#34;《什么是 eBPF》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《什么是 eBPF》&lt;/a&gt;电子书。&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;开源项目 &lt;a href=&#34;https://github.com/merbridge/merbridge&#34; title=&#34;Merbridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Merbridge&lt;/a&gt; 正是利用 eBPF 缩短了透明流量劫持的路径，优化了服务网格的性能。关于 Merbridge 实现的一些细节，请参考 &lt;a href=&#34;https://istio.io/latest/zh/blog/2022/merbridge/&#34; title=&#34;Istio 博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 博客&lt;/a&gt;。&lt;/p&gt;



&lt;div class=&#34;alert alert-warning-container&#34;&gt;
  
  &lt;div class=&#34;alert-warning-title px-2 py-2&#34;&gt;
    注意
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-warning px-2&#34;&gt;
    Merbridge 使用的 eBPF 函数需要 Linux 内核版本 ≥ 5.7。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;乍看上去 eBPF 似乎从更底层实现了 Istio 的功能，更大有取代 sidecar 的趋势。但是 eBPF 也存在很多局限性，导致在可以预见的未来无法取代服务网格和 Sidecar。如果取消 sidecar 转而使用每个主机一个代理的模式，会导致：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理失败的爆炸半径扩大到整个节点，即一个代理失败了，代理所在节点上的所有工作负载都会受到影响；&lt;/li&gt;
&lt;li&gt;使得安全问题更加复杂，因为一个节点上保存在太多负载的证书，一旦被攻击，会存在秘钥泄露的风险；&lt;/li&gt;
&lt;li&gt;主机上的 Pod 之间的流量争抢问题，即节点上如果有一个工作负载消耗掉代理的所有资源，其他工作负载将无法获得流量；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且 eBPF 主要负责三/四层流量，可以与 CNI 一起运行，但是七层流量使用 eBPF 来处理就不太合适了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在可以预见的未来 eBPF 技术无法取代服务网格和 Sidecar。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 eBPF 与服务网格的关系的更详细介绍请参考博客&lt;a href=&#34;https://jimmysong.io/blog/ebpf-sidecar-and-service-mesh/&#34; title=&#34;请暂时抛弃使用 eBPF 取代服务网格和 Sidecar 模式的幻想&#34;&gt;请暂时抛弃使用 eBPF 取代服务网格和 Sidecar 模式的幻想&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;control-plane-perf-optimizing&#34;&gt;控制平面性能优化&lt;/h3&gt;
&lt;p&gt;以上两种优化都是针对数据平面进行的，我们再来看下控制平面的性能优化。你可以把服务网格想象成是一场演出，控制平面是总导演，数据平面是所有演员，导演不参与演出，但是负责指挥演员。如果这场演出的情节很简单，时长又很短，那要每个演员分配的戏份就会很少，排练起来就会很容易；如果是一个大型演出，演员的数量多，情节有很复杂，要想排练好这场演出，一个导演可能是不够的，他指挥不了这么多演员，因此我们需要多名副导演（扩大控制平面实例数量）；我们还需要给演员准备好台词和脚本，如果演员也可以一个镜头完成一连串的台词和场景的表演（减少都数据平面的打扰，批量推送更新），那我们的排练是不是更加高效？&lt;/p&gt;
&lt;p&gt;从上面的类比中，你应该可以找到控制平面性能优化的方向了，那就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少需要推送的配置大小；&lt;/li&gt;
&lt;li&gt;批处理代理推送；&lt;/li&gt;
&lt;li&gt;扩大控制平面规模；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;reduce-config-size&#34;&gt;减少需要推送的配置&lt;/h4&gt;
&lt;p&gt;控制平面性能优化最直接的方式就是减少要向数据平面推送的代理配置大小。假设有工作负载 A，如果仅将与 A 相关的代理配置（即 A 依赖的服务）推送给 A，而不是将网格内所有服务的配置都推送给 A，这样就可以大大压缩要推送的工作负载范围及配置大小。Istio 中的 Sidecar 资源可以帮助我们实现这一点。下面是 Sidecar 配置示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cn-bj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;app-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;egress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;cn-bj/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们通过 &lt;code&gt;workloadSelector&lt;/code&gt; 字段可以限制该 Sidecar 配置适用的工作负载范围，而 &lt;code&gt;egress&lt;/code&gt; 字段可以确定该工作负载依赖的服务范围，这样控制平面就可以仅向服务 A 推送其依赖的服务配置，大大减低要向数据平面推送的配置大小，减少了服务网格的内存和网络消耗。&lt;/p&gt;
&lt;h4 id=&#34;batch-push-conf&#34;&gt;批处理代理配置推送&lt;/h4&gt;
&lt;p&gt;控制平面 Istiod 向数据平面推送代理配置的过程比较复杂，下图展示了其中的流程。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/istiod-push.svg&#34; data-img=&#34;/blog/beyond-istio-oss/istiod-push.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istiod 向数据平面推送代理配置的流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istiod 向数据平面推送代理配置的流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;管理员配置 Istio 网格后，Istiod 中推送代理配置的流程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理员更新 Istio 配置的事件会触发数据平面代理的配置同步；&lt;/li&gt;
&lt;li&gt;Istio 的 &lt;code&gt;DiscoveryServer&lt;/code&gt; 组件监听到这些事件后不会立即将配置推送到数据平面，而是将这些事件添加到队列中，持续合并一段时间内的事件，这个过程叫做去抖动（debouncing），就是为了防止频繁的更新数据平面配置；&lt;/li&gt;
&lt;li&gt;在去抖动周期过后，这些事件将被推送到队列中；&lt;/li&gt;
&lt;li&gt;Istiod 会限制同时推送的请求数量，以加快推送进度；&lt;/li&gt;
&lt;li&gt;事件被转换成 Envoy 的配置推送到数据平面的工作负载上；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上流程中我们可以看出，优化配置推送的关键就是步骤 2 中去抖动周期和步骤 4 中的限流设置。有这样几个环境变量可以帮助你设置控制平面的推送：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PILOT_DEBOUNCE_AFTER&lt;/code&gt;：指定去抖动的时间，将事件添加到推送队列中，默认为 100 毫秒；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PILOT_DEBOUNCE_MAX&lt;/code&gt;：指定允许事件去抖动的最长时间，如果在这段时间内事件没有新的变化则推送事件，默认为 10 秒；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PILOT_ENABLE_EDS_DEBOUNCE&lt;/code&gt;：指定端点更新是否符合去抖动规则或具有优先权并立即落入推送队列，默认是开启的，关闭它后可以加速 EDS 推送；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PILOT_PUSH_THROTTLE&lt;/code&gt;：指定同时处理的推送请求，默认是 100；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这些环境变量的默认值和具体配置请参考 &lt;a href=&#34;https://istio.io/latest/docs/reference/commands/pilot-agent/#envvars&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这些值究竟如何设置，可以遵循以下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果控制平面资源空闲，为了加快配置更新的传播速度，你可以：
&lt;ul&gt;
&lt;li&gt;缩短去抖动周期，增加推送次数；&lt;/li&gt;
&lt;li&gt;增加同时处理的推送请求数量；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果控制平面饱和，为了降低性能瓶颈，你可以：
&lt;ul&gt;
&lt;li&gt;延迟去抖动周期，减少推送次数；&lt;/li&gt;
&lt;li&gt;增加同时处理的推送请求的数量；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于如何设置最优解，需要结合你的可观测系统来调试。&lt;/p&gt;
&lt;h4 id=&#34;scale-up-control-plane&#34;&gt;扩大控制平面规模&lt;/h4&gt;
&lt;p&gt;如果设置去抖动批处理和 Sidecar 还无法优化控制平面性能的话，最后的选择就是扩大控制平面的规模，包括扩大单个 Istiod 实例的资源和增加 Istiod 的实例个数，究竟采用哪种扩展方式视情况而定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当单个 Istiod 的资源占用饱和时，优先推荐你扩大 Istiod 的实例大小，这通常是因为服务网格中有太多的资源（Istio 的自定义资源，如 VirtualService、DestinationRule 等）需要处理；&lt;/li&gt;
&lt;li&gt;如果增加 Istiod 实例的 CPU 和内存依然不起效的话，增加 Istiod 的实例个数，这样可以分散单个实例要管理的工作负载数量；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-plane-performance&#34;&gt;数据平面性能优化&lt;/h3&gt;
&lt;p&gt;Apache SkyWalking 可以作为 Istio 提供可观测性工具，还可以帮助我们在进行服务动态调试和故障排除剖析服务的性能，其最新推出的 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; title=&#34;Apache SkyWalking Rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking Rover&lt;/a&gt; 组件可以利用 eBPF 技术来准确定位 Istio 的关键性能问题 &lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。在数据平面，我们可以通过以下方式来增加 Envoy 的吞吐量以优化 Istio 的性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;禁用 Zipkin 追踪或减少采样率&lt;/li&gt;
&lt;li&gt;简化访问日志格式&lt;/li&gt;
&lt;li&gt;禁用 Envoy 的访问日志服务（ALS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上优化方式对 Envoy 吞吐量的影响数据请参阅 &lt;a href=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/#introducing-skywalking-rover&#34; title=&#34;使用 eBPF 准确定位服务网格的关键性能问题&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 eBPF 准确定位服务网格的关键性能问题&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;starring-envoy&#34;&gt;Envoy —— 服务网格的领衔主演&lt;/h2&gt;
&lt;p&gt;我们知道服务网格是由数据平面和控制平面组成的，从上面的服务网格开源项目列表中我们可以看到，服务网格开源项目大部分都是基于 Envoy，然后开发自己的控制平面。还记得我在本文前面将服务网格比作演出吗？在这场服务网格的演出中，毫无疑问 Envoy 就是领衔主演 —— Envoy 发明的 xDS 协议，基本成为服务网格的通用 API。下面展示的是 Envoy 的架构图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/envoy-arch.svg&#34; data-img=&#34;/blog/beyond-istio-oss/envoy-arch.svg&#34; alt=&#34;image&#34; data-caption=&#34;Envoy 架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Envoy 架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;xDS 是 Envoy 区别于其他代理的关键，它的代码和解析流程十分复杂 &lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;，直接扩展起来也很有难度。下面展示的是 Istio 组件拓扑图，从图中我们可以看到 Istio 数据平面的 Sidecar 容器中不止有 &lt;code&gt;envoy&lt;/code&gt; 这一个进程，还有一个 &lt;code&gt;pilot-agent&lt;/code&gt; 进程。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;istio-components.svg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;Istio 组件拓扑图&#34; id=&#34;istio-components&#34;data-img=&#34;istio-components.svg&#34;
         data-caption=&#34;Istio 组件拓扑图&#34;
         
         
         
    /&gt;&lt;figcaption&gt;
            Istio 组件拓扑图
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;pilot-agent&lt;/code&gt; 进程的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为 &lt;code&gt;envoy&lt;/code&gt; 的父进程，负责 Envoy 的生命周期管理；&lt;/li&gt;
&lt;li&gt;接收来自控制平面的推送，配置代理和证书；&lt;/li&gt;
&lt;li&gt;收集 Envoy 统计信息，汇总 sidecar 的统计数据供 Prometheus 搜集；&lt;/li&gt;
&lt;li&gt;内置本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景；&lt;/li&gt;
&lt;li&gt;对 Envoy 和 DNS 代理进行健康检查；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从以上功能中我们可以看出 &lt;code&gt;pilot-agent&lt;/code&gt; 进程主要是用于与 Istiod 交互，为 Envoy 起到指挥和辅助的作用，Istio 的核心组件是 Envoy。那么 Envoy 会不会「演而优则导」，不再配合 Istio，构建一套自己的控制平面呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在 Sidecar 容器中，&lt;code&gt;pilot-agent&lt;/code&gt; 就像是 Envoy 的“Sidecar”。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    请读者思考一下
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    &lt;code&gt;pilot-agent&lt;/code&gt; 的功能能否直接内置到 Envoy 中，从而取消 &lt;code&gt;pilot-agent&lt;/code&gt; 呢？
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;envoy-gateway&#34;&gt;Envoy Gateway 统一服务网格网关&lt;/h2&gt;
&lt;p&gt;在 Kubernetes 中，除 Service 资源对象之外，最早用来暴露集群中服务的资源对象是 Ingress。使用 Ingress 你只需要为集群开放一个对外的访问点即可，通过 HTTP Hosts 和 &lt;code&gt;path&lt;/code&gt; 来路由流量到具体的服务。相对于直接在 &lt;code&gt;service&lt;/code&gt; 资源上暴露服务来说，可以减少集群的网络访问点（PEP）&lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt; ，降低集群被网络攻击的风险。使用 Ingress 访问集群内的服务流程如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/ingress.svg&#34; data-img=&#34;/blog/beyond-istio-oss/ingress.svg&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes Ingress 流量访问流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes Ingress 流量访问流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在 Kubernetes 之前，API Gateway 软件就已经被广泛用作边缘路由了，在引用 Istio 时又增加了 Istio 自定义的 Gateway 资源，使得访问 Istio 服务网格中的资源又多了一种选择，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/access-cluster.svg&#34; data-img=&#34;/blog/beyond-istio-oss/access-cluster.svg&#34; alt=&#34;image&#34; data-caption=&#34;访问 Istio 网格中的服务的方式&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;访问 Istio 网格中的服务的方式&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;现在，要想暴露单个 Istio 网格中的服务，&lt;code&gt;NodePort&lt;/code&gt;、&lt;code&gt;LoadBalance&lt;/code&gt;、Istio 自定义 Gateway、Kubernetes Ingress 和 API Gateway 软件，如何选择？如果是多集群服务网格，客户端如何访问网格内的服务？我们的服务网格领衔主演 Envoy 已经在这方面做足了功夫，被以多种形式使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sidecar Proxy：正如在&lt;a href=&#34;#are-they-service-mesh&#34; title=&#34;前文中&#34;&gt;前文中&lt;/a&gt;提到的，Istio、Kuma、Consul Connect 都使用了 Envoy 作为 sidecar 代理；&lt;/li&gt;
&lt;li&gt;Kubernetes Ingress Controller/API Gateway：&lt;a href=&#34;https://github.com/projectcontour/contour&#34; title=&#34;Contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Contour&lt;/a&gt;、&lt;a href=&#34;https://github.com/emissary-ingress/emissary&#34; title=&#34;Emissary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emissary&lt;/a&gt;、&lt;a href=&#34;https://github.com/hango-io/hango-gateway&#34; title=&#34;Hango&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hango&lt;/a&gt;、&lt;a href=&#34;https://github.com/solo-io/gloo&#34; title=&#34;Gloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt; 等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些项目利用 Envoy 来实现服务网格和 API 网关，其中有很多功能重叠，同时又有很多专有功能，或者缺乏社区多样性，这种现状由于 Envoy 社区没有提供控制平面实现而导致的。为了改变现状，Envoy 社区发起了 &lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; title=&#34;Envoy Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway&lt;/a&gt; 项目，该项目旨在结合现有的基于 Envoy 的 API Gateway 相关项目的经验 &lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;，利用带有一些 Envoy 特定扩展的  &lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; title=&#34;Kubernetes Gateway API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Gateway API&lt;/a&gt; 降低 Envoy 用户使用网关的门槛。因为 Envoy Gateway 仍然通过 xDS 下发配置给 Envoy 代理，因此你还可以用它来管理支持 xDS 的网关，如 Istio Gateway。&lt;/p&gt;
&lt;p&gt;我们现在所见的网关基本都是在单集群中作为入口网关，对于多集群和多网格就无能为力了。为了应对多集群，我们需要在 Istio 之上再添加一层网关，和一个全局的控制平面以在多集群间路由流量，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/t2-gateway.svg&#34; data-img=&#34;/blog/beyond-istio-oss/t2-gateway.svg&#34; alt=&#34;image&#34; data-caption=&#34;多集群多网格的两级网关示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;多集群多网格的两级网关示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    关于两级网关的简要介绍
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    &lt;ul&gt;
&lt;li&gt;一级网关（下文简称 T1）位于应用边缘，用于多集群环境。同一应用会同时托管在不同的集群上，T1 网关将对该应用的请求流量在这些集群之间路由。&lt;/li&gt;
&lt;li&gt;二级网关（下文简称 T2）位于一个的集群边缘，用于将流量路由到该集群内由服务网格管理的服务。&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;通过在 Istio 控制平面以外增加一层全局控制平面和 API，来实现多集群服务网格管理。将 T1 网关部署为集群，可以防止单点故障。想要了解关于两级网关的更多内容，请参考&lt;a href=&#34;https://cloudnative.to/blog/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways/&#34; title=&#34;通过两级网关设计来路由服务网格流量&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过两级网关设计来路由服务网格流量&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;T1 网关的配置如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway.tsb.tetrate.io/v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Tier1Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service1-tier1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;demo-gw-group&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;organization&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;demo-org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tenant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;demo-tenant&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workspace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;demo-ws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway-t1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;externalServers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;servicea.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cluster1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;75&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cluster2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该配置将 &lt;code&gt;servicea.example.com&lt;/code&gt; 通过 T1 网关暴露到网格外，并将网格外访问该服务的流量的 &lt;code&gt;75%&lt;/code&gt; 转发到 &lt;code&gt;cluster1&lt;/code&gt;，&lt;code&gt;25%&lt;/code&gt; 的流量转发到 &lt;code&gt;cluster2&lt;/code&gt;，另外为了应对多集群中的流量、服务和安全配置，Tetrate 旗舰产品 Tetrate Service Bridge 中还增加了 一系列 Group API，详见 TSB 文档。&lt;/p&gt;
&lt;h2 id=&#34;ecosystem&#34;&gt;Istio 开源生态&lt;/h2&gt;
&lt;p&gt;Istio 开源在至今已经五年多了，近两年来出现了很多基于 Istio 的开源项目，其中比较代表性的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网易开源的 Slime&lt;/li&gt;
&lt;li&gt;腾讯开源的 Aeraki&lt;/li&gt;
&lt;li&gt;Istio 官方对 Wasm 插件的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的出现使得 Istio 更加智能化并扩展了 Istio 的适用范围。&lt;/p&gt;
&lt;h3 id=&#34;slime&#34;&gt;Slime&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/slime-io/slime/&#34; title=&#34;Slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt; 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。&lt;/p&gt;
&lt;p&gt;我们在前文的&lt;a href=&#34;#control-plane-perf-optimizing&#34; title=&#34;控制平面性能优化&#34;&gt;控制平面性能优化&lt;/a&gt;中提到了通过「减少需要推送的配置」的方式来优化 Istio 的性能，但是 Istio 无法做到自动识别无法依赖以最优化需要推送到每个 sidecar 的代理配置，Slime 提供了 &lt;code&gt;lazyload&lt;/code&gt; 控制器，可以帮助我们实现配置懒加载，用户无须手动配置 &lt;code&gt;SidecarScope&lt;/code&gt; &lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;，Istio 可以按需加载服务配置和服务发现信息。&lt;/p&gt;
&lt;p&gt;下图展示的是 Slime 作为 Istio 的管理平面更新数据平面配置的流程图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/slime-process.svg&#34; data-img=&#34;/blog/beyond-istio-oss/slime-process.svg&#34; alt=&#34;image&#34; data-caption=&#34;使用 Slime 更新 Istio 数据平面配置的流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;使用 Slime 更新 Istio 数据平面配置的流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;其中，Global Proxy 使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。&lt;/p&gt;
&lt;p&gt;数据平面配置更新的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化，开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；&lt;/li&gt;
&lt;li&gt;Slime 持续监听 Slime CRD 的创建；&lt;/li&gt;
&lt;li&gt;Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；&lt;/li&gt;
&lt;li&gt;Istio 监听 Istio CRD 的创建；&lt;/li&gt;
&lt;li&gt;Istio 将代理的配置信息推送到数据平面相应的 Sidecar Proxy 中；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为数据平面中的所有服务的首次调用都通过 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 &lt;code&gt;ServiceFence&lt;/code&gt; 的 CRD 来维护服务调用关系以解决服务信息缺失问题，详见 &lt;a href=&#34;https://jimmysong.io/blog/slime-intro/&#34; title=&#34;Slime 简介&#34;&gt;Slime 简介&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;aeraki&#34;&gt;Aeraki&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aeraki-mesh/aeraki&#34; title=&#34;Aeraki Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki Mesh&lt;/a&gt; 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目，基于 Istio 扩展其对七层协议的支持，专注于解决 Istio 中的&lt;strong&gt;非 HTTP 协议&lt;/strong&gt;的服务治理，已于 2022 年 6 月进入 CNCF Sandbox。&lt;/p&gt;
&lt;p&gt;下图展示了 Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/aeraki-arch.svg&#34; data-img=&#34;/blog/beyond-istio-oss/aeraki-arch.svg&#34; alt=&#34;image&#34; data-caption=&#34;Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;其详细流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Aeraki 的 X2Istio 组件对接服务注册中心，获取非 HTTP 服务的注册信息，并生成 ServiceEntry 向 Istio 中注册；&lt;/li&gt;
&lt;li&gt;Aeraki 作为 Istio 之上的管理平面，它从 Istio 中获取 ServiceEntry 配置；&lt;/li&gt;
&lt;li&gt;Aeraki 通过端口命名规判断服务的协议类型（如 &lt;code&gt;tcp-metaprotocol-dubbo&lt;/code&gt;），然后生成 MetaProtocol Proxy Filter（兼容 EnvoyFilter）配置，同时修改 RDS 地址，将其指向 Aeraki；&lt;/li&gt;
&lt;li&gt;Istio 使用 xDS 协议将配置（LDS、CDS、EDS 等）下发给数据平面；&lt;/li&gt;
&lt;li&gt;Aeraki 根据服务注册表中的信息和用户设置生成路由规则，通过 RDS 发送给数据平面；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Istio 中接入非 HTTP 服务的整个流程中的关键是 &lt;strong&gt;MetaProtocol Proxy&lt;/strong&gt; 。Istio 默认支持 HTTP/HTTP2、TCP 和 gRPC 协议，实验性支持 Mongo、MySQL 和 Redis 协议 &lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;。若要使用 Istio 路由其他协议的流量，不仅需要修改 Istio 控制平面并扩展 Envoy，这将带来巨大的工作量，而且不同协议共享通用的控制逻辑，这还会带来很多重复性工作。MetaProtocol Proxy 是在 Envoy 代码基础上的扩展，为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度。&lt;/p&gt;
&lt;p&gt;下图展示的 MetaProtocol Proxy 的架构图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/metaprotocol-proxy.svg&#34; data-img=&#34;/blog/beyond-istio-oss/metaprotocol-proxy.svg&#34; alt=&#34;image&#34; data-caption=&#34;MetaProtocol Proxy 架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;MetaProtocol Proxy 架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;当我们想扩展 Istio 使其支持 Kafka、Dubbo、Thrift 等其他七层协议时，只需要实现上图中的编解码的接口（Decode 和 Encode），就可以基于 MetaProtocol 快速开发一个第三方协议插件。MetaProtocol Proxy 是在 Envoy 基础上的扩展，因此你仍然可以使用多种语言为其开发过滤器，并使用 &lt;code&gt;EnvoyFilter&lt;/code&gt; 资源将配置下发到数据平面。&lt;/p&gt;
&lt;h3 id=&#34;wasmplugin-api&#34;&gt;WasmPlugin API&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/proxy_extensions/wasm-plugin/&#34; title=&#34;WasmPlugin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmPlugin&lt;/a&gt; 是 Istio 1.12 版本引入的 API，作为代理扩展机制，我们可以使用它将自定义和第三方的 Wasm 模块添加到数据平面中。下图中展示了如何在 Istio 中使用 WasmPlugin。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/wasmplugin.svg&#34; data-img=&#34;/blog/beyond-istio-oss/wasmplugin.svg&#34; alt=&#34;image&#34; data-caption=&#34;在 Istio 中使用 WasmPlugin 的流程图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;在 Istio 中使用 WasmPlugin 的流程图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户使用 &lt;a href=&#34;https://github.com/proxy-wasm&#34; title=&#34;Proxy-Wasm SDK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy-Wasm SDK&lt;/a&gt;（目前有 AssemblyScript、C++、Rust、Zig 和 Go 语言版本）来开发扩展，并构建成 OCI 镜像（如 Docker 镜像）上传到镜像仓库；&lt;/li&gt;
&lt;li&gt;用户编写 &lt;code&gt;WasmPlugin&lt;/code&gt; 配置并应用到 Istio；&lt;/li&gt;
&lt;li&gt;Istio 控制平面根据 &lt;code&gt;WasmPlugin&lt;/code&gt; 配置中的工作负载选择配置，将 Wasm 模块注入到指定的 Pod 中；&lt;/li&gt;
&lt;li&gt;Sidecar 中的 &lt;code&gt;pilot-agent&lt;/code&gt; &lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt; 从远程或本地文件中获取 Wasm 模块并将其加载到 Envoy 中运行；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;whos-should-use-istio&#34;&gt;谁应该使用 Istio？&lt;/h2&gt;
&lt;p&gt;好了，说了这么说，这跟你有什么关系呢？Istio 跟你的关系取决于你的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你是平台负责人，应用服务网格后，可能增强你的平台可观测性，具有了一个统一的平台来管理微服务，你将是直接受益者，也应该是服务网格的主要实施者；&lt;/li&gt;
&lt;li&gt;如果是应用程序开发者，也会从服务网格中收益，因为你可以更加专属于业务逻辑，而不用担心重试策略、TLS 等其他非功能性问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了服务网格的采用路径。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/adopt.svg&#34; data-img=&#34;/blog/beyond-istio-oss/adopt.svg&#34; alt=&#34;image&#34; data-caption=&#34;服务网格的采用路径&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;服务网格的采用路径&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;是否采用服务网格取决于你公司的技术发展阶段，应用是否实现容器化和微服务，对多语言的需求，是否需要 mTLS 以及对性能损耗的接纳度等。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-positioning&#34;&gt;服务网格在云原生技术栈中的定位&lt;/h2&gt;
&lt;p&gt;技术的发展日新月异，近两年来有一些新技术出现，似乎挑战了服务网格的地位，更有人声称可以直接取代现有经典的 sidecar 模式的服务网格 &lt;sup id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;16&lt;/a&gt;&lt;/sup&gt;，我们不要被外界嘈杂的声音所迷惑，认清服务网格在云原生技术栈中的定位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;一味地推广某项技术而忽略它的适用场景，就是耍流氓。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图展示的是云原生技术堆栈。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/cloud-native-stack.svg&#34; data-img=&#34;/blog/beyond-istio-oss/cloud-native-stack.svg&#34; alt=&#34;image&#34; data-caption=&#34;云原生技术堆栈示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生技术堆栈示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;我们可以看到，在云原生技术堆栈图中的「云基础设施」、「中间件」和「应用」层都列举了一些标志性的开源项目，这些项目构建了它们所在领域的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在云基础设施领域，Kubernetes 统一了容器编排和应用生命周期管理的标准，Operator 模式奠定了扩展 Kubernetes API 及第三方应用接入的标准；&lt;/li&gt;
&lt;li&gt;在中间件领域，服务网格承担起了云原生技术栈中的七层网络、可观测性和安全等多个方面的部分或全部责任，它运行在应用程序下层，对于应用程序来说几乎是无感知的；Dapr（分布式应用程序运行时）定义云原生中间件的能力模型，开发者可以在应用中集成 Dapr 的多语言 SDK，面向 Dapr 提供的分布式能力编程，而不用关心应用所运行的环境及对接的后端基础设施。因为在和应用程序运行在同一个 Pod 中的 Dapr 运行时（Sidecar 模式部署，其中包含各种构建块）自动帮我们对接了后端组件（Component）；&lt;/li&gt;
&lt;li&gt;在应用程序领域：OAM 旨在建立一个应用模型标准，通过组件、特征、策略和工作流来一个应用程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了 Istio 在云原生部署中定位于七层网格管理。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/istio-role.svg&#34; data-img=&#34;/blog/beyond-istio-oss/istio-role.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio 在云原生架构中定位在七层网络&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istio 在云原生架构中定位在七层网络&lt;/figcaption&gt;
  
&lt;/figure&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    Dapr 与 Istio 是什么关系？
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    &lt;p&gt;在云原生技术栈中，Istio 和 Dapr 同时位于中间件层，它们之间有很多区别和联系。&lt;/p&gt;
&lt;p&gt;Istio 和 Dapr 之间的相同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio 和 Dapr 都可以使用 Sidecar 模式的部署模型；&lt;/li&gt;
&lt;li&gt;同属于中间件，同样可以管理服务间通信；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 和 Dapr 之间的不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标不同：Istio 的目标是构建零信任网络，定义服务间通信标准，Dapr 目标是构建标准的中间件能力的 API；&lt;/li&gt;
&lt;li&gt;架构不同：Istio = Envoy + 透明流量劫持 + 控制平面，Dapr = 多语言 SDK + 标准化 API + 分布式能力组件；&lt;/li&gt;
&lt;li&gt;面向的人群不同：但是应用 Istio 对于开发者来说几乎无感知，主要需要基础设施运维团队实施，而应用 Dapr 需要开发者自主选择集成 Dapr SDK；&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;istio-future&#34;&gt;服务网格的未来&lt;/h2&gt;
&lt;p&gt;我在前文中介绍了 Istio 的发展脉络及开源生态，接下来我将为大家介绍 Istio 服务网格的未来趋势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建零信任网络&lt;/li&gt;
&lt;li&gt;成为混合云管理平台的网络基础设施&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;服务网格的未来在于成为零信任网络和混合云的基础设施。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也是笔者所在的公司企业级服务网格提供商 &lt;a href=&#34;https://www.tetrate.io/&#34; title=&#34;Tetrate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt; 的努力方向，我们致力于构建一个基于零信任的适用于任意环境、任意负载的应用感知网络。下面展示的是 Tetrate 旗舰产品 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; title=&#34;Tetrate Service Bridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 的架构图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/tsb.svg&#34; data-img=&#34;/blog/beyond-istio-oss/tsb.svg&#34; alt=&#34;image&#34; data-caption=&#34;TSB 架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;TSB 架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Tetrate 公司是由 Istio 项目的发起人创立的，TSB 是基于开源的 Istio、Envoy 和 Apache SkyWalking 开发的。我们同时积极得贡献上游社区，并参与了旨在简化将 Envoy 网关使用的 &lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; title=&#34;Envoy Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway&lt;/a&gt; 项目的创建（上图中的 XCP 即使用 Envoy 构建的网关）。&lt;/p&gt;
&lt;h2 id=&#34;zero-trust&#34;&gt;零信任&lt;/h2&gt;
&lt;p&gt;零信任（Zero Trust）是 IstioCon 2022 里的一个重要话题，Istio 正在成为零信任网络的一个重要组成部分。&lt;/p&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    什么是零信任？
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    零信任（Zero Trust）是一种安全理念，而不是一种所有安全团队都要遵循的最佳实践。零信任概念的提出是为了给云原生世界带来更安全的网络。零信任是一种理论状态，即网络内的所有消费者不仅没有任何权限，而且也不具备对周围网络的感知。零信任的主要挑战是就越来越细化的授权和和对用户授权的时间限制。关于更多零信任的介绍，请阅读&lt;a href=&#34;https://jimmysong.io/blog/what-is-zero-trust/&#34; title=&#34;这篇博客&#34;&gt;这篇博客&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;authn&#34;&gt;身份认证&lt;/h3&gt;
&lt;p&gt;零信任网络中最重要的是&lt;strong&gt;面向身份的控制&lt;/strong&gt;而不是面向网络的控制。Istio 1.14 中增加了对 SPIRE 的支持，SPIRE（SPIFFE Runtime Environment，CNCF 孵化项目）是 SPIFFE（Secure Production Identity Framework For Everyone，CNCF 孵化项目）的一个实现。在 Kubernetes 中我们使用 &lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/auth/serviceaccount/&#34; title=&#34;ServiceAccount&#34;&gt;ServiceAccount&lt;/a&gt; 为 Pod 中的工作负载提供身份信息，其核心是基于 Token（使用 Secret 资源存储）来表示负载身份。而 Token 是 Kubernetes 集群中的资源，对于多集群及运行在非 Kubernetes 环境（例如虚拟机）中的负载，如何统一它们的身份？这就是 SPIFFE 要解决的问题。&lt;/p&gt;
&lt;p&gt;SPIFFE 的目的是基于零信任的理念，建立一个开放、统一的工作负载身份标准，这有助于建立一个零信任的全面身份化的数据中心网络。SPIFFE 的核心是通过简单 API 定义了一个生命周期短暂的加密身份文件—— SVID（SPFFE Verifiable Identity Document），用作工作负载认证时使用的身份文件（基于 X.509 证书或 JWT 令牌）。SPIRE 可以根据管理员定义的策略自动轮换 SVID 证书和秘钥，动态地提供工作负载标识，同时 Istio 可以通过 SPIRE 动态的消费这些工作负载标识。&lt;/p&gt;
&lt;p&gt;基于 Kubernetes 的 SPIRE 架构图如下所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/spire-with-kubernetes.svg&#34; data-img=&#34;/blog/beyond-istio-oss/spire-with-kubernetes.svg&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE 部署在 Kubernetes 中的架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE 部署在 Kubernetes 中的架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Istio 中原先是使用 Istiod 中 Citadel 服务 &lt;sup id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;17&lt;/a&gt;&lt;/sup&gt; 负责服务网格中证书管理，通过 xDS（准确的说是 SDS API）协议将证书下发给数据平面。有了 SPIRE 之后，证书管理的工作就交给了 SPIRE Server。SPIRE 同样支持 Envoy SDS API，我们在 Istio 中启用 SPIRE 之后，进入工作负载 Pod 中的流量在被透明拦截到 Sidecar 中后，会经过一次身份认证。身份认证的目的是对比该工作负载的身份，与它所运行的环境信息（所在的节点、Pod 的 ServiceAccount 和 Namespace 等）是否一致，以防止伪造身份。请参考&lt;a href=&#34;https://jimmysong.io/blog/how-to-integrate-spire-with-istio/&#34; title=&#34;如何在 Istio 中集成 SPIRE&#34;&gt;如何在 Istio 中集成 SPIRE&lt;/a&gt; 以了解如何在 Istio 中使用 SPIRE 做身份认证。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;a href=&#34;https://github.com/spiffe/spire/blob/main/support/k8s/k8s-workload-registrar/README.md&#34; title=&#34;Kubernetes Workload Registrar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Workload Registrar&lt;/a&gt; 在 Kubernetes 中部署 SPIRE，它会为我们自动注册 Kubernetes 中的工作负载并生成 SVID。该注册机是 Server-Agent 架构，它在每个 Node 上部署一个 SPIRE Agent，Agent 与工作负载通过共享的 UNIX Domain Socket 通信。零信任网络中每个流量会话都需要经过身份认证，Istio 在透明流量劫持时，Sidecar 同时对流量请求进行身份认证。下图展示了在 Istio 中使用 SPIRE 进行身份认证的过程。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/workload-attestation.svg&#34; data-img=&#34;/blog/beyond-istio-oss/workload-attestation.svg&#34; alt=&#34;image&#34; data-caption=&#34;Istio 中基于 SPIRE 的工作负载身份认证过程示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Istio 中基于 SPIRE 的工作负载身份认证过程示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Istio 中使用 SPIRE 进行工作负载认证的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工作负载的 sidecar 中的 &lt;code&gt;pilot-agent&lt;/code&gt; 通过共享的 UDS 调用 SPIRE Agent 来获取 SVID 并缓存在 SPIRE Agent 中用于后续身份认证；&lt;/li&gt;
&lt;li&gt;SPIRE Agent 询问 Kubernetes（准确的说是节点上的 kubelet）获取工作负载的信息，如所在的 namespace、节点名称、服务账号等；&lt;/li&gt;
&lt;li&gt;Kubelet 把从 API 服务器中查询到的信息返回给工作负载验证器；&lt;/li&gt;
&lt;li&gt;验证器将 kubelet 返回的结果与 SPIRE 查询得到的身份信息比对，如果相同，则将正确的 SVID 缓存返回给工作负载，如果不同则认证失败，拒绝流量请求；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于工作负载的注册和认证的详细过程请参考 &lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/auth/spire/&#34; title=&#34;SPIRE 文档&#34;&gt;SPIRE 文档&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;ngac&#34;&gt;NGAC&lt;/h3&gt;
&lt;p&gt;当每个工作负载都有准确的身份之后，如何对这些身份的权限进行限制？Kubernetes 中默认使用 RBAC 来做访问控制，正如其名，这种访问控制是基于角色的，虽然使用起来比较简单，但是对于大规模集群，存在角色爆炸问题 —— 即存在太多角色，而且角色的类型不是一成不变的，难以对角色权限机型跟踪和审计。另外 RBAC 中的角色的访问权限是固定，没有规定短暂的使用权限，也没有考虑位置、时间或设备等属性。使用 RBAC 的企业很难满足复杂的访问控制要求，以满足其他组织需求的监管要求。&lt;/p&gt;
&lt;p&gt;NGAC，即下一代访问控制，采用将访问决定数据建模为 DAG（有向无环图）的方法。NGAC 可以实现系统化、策略一致的访问控制方法，以高精细度授予或拒绝用户管理能力。NGAC 由 &lt;a href=&#34;https://www.nist.gov/&#34; title=&#34;NIST&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NIST&lt;/a&gt; （美国国家标准与技术研究所）开发，目前已用于 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; title=&#34;Tetrate Service Bridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 中的权限管理。关于为什么选择 NGAC，而不是 ABAC 和 RBAC 的更多内容请参考博客&lt;a href=&#34;https://jimmysong.io/blog/why-you-should-choose-ngac-as-your-access-control-model/&#34; title=&#34;为什么应该选择使用 NGAC 作为权限控制模型&#34;&gt;为什么应该选择使用 NGAC 作为权限控制模型&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;hybrid-cloud&#34;&gt;混合云&lt;/h2&gt;
&lt;p&gt;在实际应用中，我们可能出于负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复以及避免厂商锁定等原因，在多种环境下部署多个 Kubernetes 集群。Kubernetes 社区提供了「集群联邦」功能可以帮助我们创建多集群架构，例如下图所示的一种常用的 Kubernetes 多集群架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/multicluster.svg&#34; data-img=&#34;/blog/beyond-istio-oss/multicluster.svg&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 集群联邦架构&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes 集群联邦架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;集群联邦要求 Host 集群与成员集群的之间的网络能够互通，对成员集群之间的网络连接性没有要求。Host 集群作为 API 入口，外界所有对 Host 集群的资源请求会转发到成员集群中。Host 集群中部署有集群联邦的控制平面，其中的「Push Reconciler」会将联邦中的身份、角色及角色绑定传播到所有的成员集群中。集群联邦只是简单地将多个集群简单的「连接到了一起」，在多个集群之间复制工作负载，而成员集群之间的流量无法调度，也无法实现真正的多租户。&lt;/p&gt;
&lt;p&gt;集群联邦不足以实现混合云，为了实现真正意义上的混合云，就要让集群之间做到互联互通，同时实现多租户。TSB 在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。下面是 Istio 管理平面的多租户和 API 示意图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/beyond-istio-oss/tsb-management-plane.svg&#34; data-img=&#34;/blog/beyond-istio-oss/tsb-management-plane.svg&#34; alt=&#34;image&#34; data-caption=&#34;TSB 在 Istio 之上构建的管理平面示意图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;TSB 在 Istio 之上构建的管理平面示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;TSB 为管理混合云，基于 Istio 构建了一个管理平面，新建了 Tenant 和 Workspace 的资源，并通过选择器，将网关组、流量组和安全组应用到对应集群中的工作负载上。关于 TSB 的详细架构请参考 TSB 文档。&lt;/p&gt;
&lt;h2 id=&#34;more&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;如果你想了解更多关于 Istio 和云原生的内容，下面有一些资料分享给你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了帮助大家更好的了解 Istio 和云原生，笔者在 2020 年发起了&lt;a href=&#34;https://cloudnative.to&#34; title=&#34;云原生社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，欢迎大家加入我们一起探索后 Kubernetes 时代的云原生新范式；&lt;/li&gt;
&lt;li&gt;2022 年 6 月，云原生社区著的&lt;a href=&#34;https://jimmysong.io/blog/istio-service-mesh-book/&#34; title=&#34;《深入理解 Istio —— 云原生服务网格进阶实战》&#34;&gt;《深入理解 Istio —— 云原生服务网格进阶实战》&lt;/a&gt;已图书由电子工业出版社出版，欢迎大家购买；&lt;/li&gt;
&lt;li&gt;笔者于 2022 年 5 月，将之前所作电子书、教程和译文全部迁移到了&lt;a href=&#34;https://jimmysong.io/book/&#34; title=&#34;云原生资料库&#34;&gt;云原生资料库&lt;/a&gt;欢迎阅读和留言评论。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;有关 Envoy 开源的详细过程，推荐你阅读 Envoy 作者 Matt Klein 的这篇文章&lt;a href=&#34;https://cloudnative.to/blog/envoy-oss-5-year/&#34; title=&#34;网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;后来 IBM 与 Google 反目，大举抨击 Google 没有遵守将 Istio 捐献给 CNCF 的约定，Google 对 Istio 商标的管理也受到了&lt;a href=&#34;https://thenewstack.io/googles-management-of-the-istio-service-mesh-raises-questions-in-the-cloud-native-community/&#34; title=&#34;质疑&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;质疑&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;2018 年，CNCF 为云原生的重新定义是：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Day-2 Operation 是在系统的生命周期结束前，对系统不断改进的过程，以实现效益最大化。参考 &lt;a href=&#34;https://jimmysong.io/blog/what-is-day-2-operation/&#34; title=&#34;什么是 Day-2 Operation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是 Day-2 Operation&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Istio 现已推出 proxyless 模式测试版，详见 &lt;a href=&#34;https://cloudnative.to/blog/grpc-proxyless-service-mesh/&#34; title=&#34;基于 gRPC 和 Istio 的无 sidecar 代理的服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 gRPC 和 Istio 的无 sidecar 代理的服务网格&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;Kubernetes 预计推出 &lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/service-discovery/gateway/&#34; title=&#34;Gateway API&#34;&gt;Gateway API&lt;/a&gt;，Istio 也有计划使用 Kubernetes 的 Gateway API 替换当前 Istio 自定义的 Gateway 资源。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;有关服务网格项目的详细对比请参考 &lt;a href=&#34;https://servicemesh.es/&#34; title=&#34;servicemesh.es&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;servicemesh.es&lt;/a&gt; 网站。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;在百度的服务网格团队分享的 &lt;a href=&#34;https://mp.weixin.qq.com/s/G8vmlJyaimux_K-548kFbA&#34; title=&#34;殊途同归，Proxyless Service Mesh 在百度的实践与思考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;殊途同归，Proxyless Service Mesh 在百度的实践与思考&lt;/a&gt; 这篇文章里，详细介绍了百度的服务网格采用路径，以及对服务网格本质的探索。&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;Apache SkyWalking 的 Rover 组件利用 eBPF 技术改进了 SkyWalking 的剖析功能，可用于分析服务网格的性能问题，请参考 &lt;a href=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/&#34; title=&#34;使用 eBPF 准确定位服务网格的关键性能问题&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 eBPF 准确定位服务网格的关键性能问题&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;关于 xDS 协议，请参考 &lt;a href=&#34;https://cloudnative.to/blog/envoy-xds-protocol/&#34; title=&#34;Envoy 中的 xDS REST 和 gRPC 协议详解&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 中的 xDS REST 和 gRPC 协议详解&lt;/a&gt; 这篇文章。&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oreilly.com/library/view/network-access-control/9780470398678/9780470398678_policy_enforcement_point.html&#34; title=&#34;PEP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PEP&lt;/a&gt;，全称 Policy Enforcement Point，策略执行点（PEP）是控制用户访问并确保策略决策点 (PDP) 做出授权决策的网络或安全设备。在一些 NAC 实现中，PDP 是有线交换机或无线接入点。在其他情况下，PEP 是防火墙、IPS、服务器或内联设备。根据实施情况，PEP 和 PDP 可以是独立设备，也可以合并为单个设备。&amp;#160;&lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;
&lt;p&gt;有多家公司正在合作开发 Envoy Gateway，包括 &lt;a href=&#34;https://www.getambassador.io/&#34; title=&#34;Ambassador Labs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador Labs&lt;/a&gt;、&lt;a href=&#34;https://www.fidelity.com/&#34; title=&#34;Fidelity Investments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fidelity Investments&lt;/a&gt;、&lt;a href=&#34;https://projectcontour.io/&#34; title=&#34;Project Contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Project Contour&lt;/a&gt; 和 &lt;a href=&#34;https://www.vmware.com/&#34; title=&#34;VMware&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VMware&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;
&lt;p&gt;SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 &lt;code&gt;egress&lt;/code&gt; 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。&amp;#160;&lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:14&#34;&gt;
&lt;p&gt;Istio 仅可以路由 TCP 流量，默认支持 HTTP、HTTPS、gRPC 和原始 TCP 协议，其中 Sidecar 和 Gateway 所支持的协议范围有所不同，详见 &lt;a href=&#34;https://istio.io/latest/docs/ops/configuration/traffic-management/protocol-selection/&#34; title=&#34;Istio 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:14&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:15&#34;&gt;
&lt;p&gt;&lt;code&gt;pilot-agent&lt;/code&gt; 是 sidecar 容器中的主进程，你可以在 &lt;a href=&#34;#istio-components&#34; title=&#34;Istio 的组成架构图&#34;&gt;Istio 的组成架构图&lt;/a&gt;中看到。&lt;code&gt;pilot-agent&lt;/code&gt; 中的镜像提取机制（在 Istio 1.9 中引入），从远程 HTTP 源可靠地检索 Wasm 二进制文件，已被扩展到支持从任何 OCI 注册处检索 Wasm OCI 镜像，包括 Docker Hub、Google Container Registry（GCR）、Amazon Elastic Container Registry（Amazon ECR）和其他地方。&amp;#160;&lt;a href=&#34;#fnref:15&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:16&#34;&gt;
&lt;p&gt;《&lt;a href=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/&#34; title=&#34;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&lt;/a&gt;》这篇文章在云原生社区里引起了一系列关于服务网格将被 eBPF 技术所取代的讨论。&lt;a href=&#34;https://jimmysong.io/blog/epbf-sidecar-and-service-mesh/&#34; title=&#34;请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想&lt;/a&gt;，不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。&amp;#160;&lt;a href=&#34;#fnref:16&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:17&#34;&gt;
&lt;p&gt;Istio 具有身份和证书管理功能，可以实现服务间的终端用户认证，在控制平面还采用微服务架构的时候，其中的 Citadel 组件负责证书管理，在 Istio 1.5 版本被合并到单体 Istiod 中了。&amp;#160;&lt;a href=&#34;#fnref:17&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想</title>
      <link>https://jimmysong.io/blog/ebpf-sidecar-and-service-mesh/</link>
      <pubDate>Sat, 11 Jun 2022 11:08:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/ebpf-sidecar-and-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;最近 eBPF 技术在云原生社区中持续火热，在我翻译了《&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/&#34; title=&#34;什么是 eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是 eBPF&lt;/a&gt;》之后，当阅读“云原生环境中的 eBPF”之后就一直在思考 eBPF 在云原生环境中究竟处于什么地位，发挥什么样的作用。当时我评论说“eBPF 开启了上帝视角，可以看到主机上所有的活动，而 sidecar 只能观测到 pod 内的活动，只要搞好进程隔离，基于 eBPF 的 proxy per-node 才是最佳选择”，再看到 William Morgan 的&lt;a href=&#34;https://buoyant.io/2022/06/07/ebpf-sidecars-and-the-future-of-the-service-mesh/&#34; title=&#34;这篇文章&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文章&lt;/a&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;之后，让我恍然大悟。下面节选翻译了文章我比统同意的观点，即 eBPF 无法替代服务网格和 sidecar，感兴趣的读者可以阅读 William 的原文。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ebpf&#34;&gt;什么是 eBPF&lt;/h2&gt;
&lt;p&gt;在过去，如果你想让应用程序处理网络数据包，那是不可能的。因为应用程序运行在 Linux 用户空间，它是不能直接访问主机的网络缓冲区。缓冲区是由内核管理的，受到内核保护，内核需要确保进程隔离，进程之间不能直接读取对方的网络数据包。正确的做法是，应用程序通过系统调用（syscall）来请求网络数据包信息，这本质上是内核 API 调用——应用程序调用 syscall，内核检查应用程序是否有权限获得其请求的数据包；如果有，就把返回数据包。&lt;/p&gt;
&lt;p&gt;有了 eBPF 之后，应用程序不再需要 syscall，数据包不需要在内核空间和用户空间之间来回交互传递。而是我们将代码直接交给内核，让内核自己执行，这样就可以让代码全速运行，效率更高。eBPF 允许应用程序和内核以安全的方式共享内存，eBPF 允许应用程序直接向内核提交代码，目标都是通过超越系统调用的方式来实现性能提升。&lt;/p&gt;
&lt;p&gt;eBPF 不是银弹，你不能用 eBPF 运行任意程序，实际上 eBPF 可以做的事情是非常有限的。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-的局限性&#34;&gt;eBPF 的局限性&lt;/h2&gt;
&lt;p&gt;eBPF 的局限性也是因为内核造成的。内核中运行的应用程序应当有自己的租户，这些租户之间会争抢系统的内存、磁盘和网络，内核的职责就是隔离和调度这些应用程序的资源，同时内核还要保护确认应用程序的权限，保护其不被其他程序破坏。&lt;/p&gt;
&lt;p&gt;因为我们直接将 eBPF 代码交给内核执行，这绕过了内核安全保护（如 syscall），内核将面临直接的安全风险。为了保护内核，所有 eBPF 程序要想运行都必须先通过一个&lt;strong&gt;验证器&lt;/strong&gt;。但是要想自动验证程序是很困难的，验证器可能会过度限制程序的功能。比如 eBPF 程序不能是阻塞的，不能有无限循环，不能超过预定的大小；其复杂性也受到限制，验证器会评估所有可能的执行路径，如果 eBPF 程序不能在某些范围内完成，或者不能证明每个循环都有一个退出条件，那么验证器就不会允许该程序运行。有很多应用程序都违反了这些限制，要想将它们作为 eBPF 程序来运行的话，要么重写以满足验证器的需求，要么给内核打补丁，来绕过一些验证（这可能比较困难）。不过随着内核版本的升级，这些验证器也变得更加智能，限制也逐渐变得宽松，也有一些创造性的方法来绕过这些限制。&lt;/p&gt;
&lt;p&gt;但总的来说，eBPF 程序能做的事情非常有限。对于一些重量级事件的处理，例如处理全局范围内的 HTTP/2 流量，或者 TLS 握手协商不能在纯 eBPF 环境中完成。充其量，eBPF 可以做其中的一小部分工作，然后调用用户空间应用程序来处理对于 eBPF 来说过于复杂而无法处理的部分。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-与服务网格的关系&#34;&gt;eBPF 与服务网格的关系&lt;/h2&gt;
&lt;p&gt;因为上文所述的 eBPF 的各项限制，七层流量仍然需要用户空间的网络代理来完成，eBPF 并不能替代服务网格。eBPF 可以与 CNI（容器网络接口）一起运行，处理三层/四层流量，而服务网格处理七层流量。&lt;/p&gt;
&lt;h2 id=&#34;每个主机一个代理的模式比-sidecar-更糟&#34;&gt;每个主机一个代理的模式比 sidecar 更糟&lt;/h2&gt;
&lt;p&gt;对于每个主机一个代理（per-host）的模式，服务网格的早期实践者 Linkerd 1.x 就是这么用的，笔者也是从那个时候开始关注服务网格，Linkerd 1.x 还使用了 JVM 虚拟机！但是经过 Linkerd 1.x 的用户实践证明，这种模式相对于 sidecar 模式，对于运维和安全来说会更糟糕。&lt;/p&gt;
&lt;p&gt;为什么说 sidecar 模式比 per-host 模式更好呢？因为 sidecar 模式有以下几个优势，这是 per-host 模式所不具备的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理的资源消耗随着应用程序的负载而变化。随着实例流量的增加，sidecar 会消耗更多的资源，就像应用程序一样。如果应用程序的流量非常小，那么 sidecar 就不需要消耗很多资源。Kubernetes 现有的管理资源消耗的机制，如资源请求和限制以及 OOM kill，都会继续工作。&lt;/li&gt;
&lt;li&gt;代理失败的爆炸半径只限于一个 pod。代理失败与应用失败相同，由 Kubernetes 负责处理失败的 pod。&lt;/li&gt;
&lt;li&gt;代理维护。例如代理版本的升级，是通过如滚动更新，灰度发布等应用程序本身相同的机制完成的。&lt;/li&gt;
&lt;li&gt;安全边界很清楚（而且很小）：在 pod 级别。Sidecar 在应用程序实例的同一安全上下文中运行。它是 pod 的一部分，与应用程序具有一样的 IP 地址。Sidecar 执行策略，并将 mTLS 应用于进出该 pod 的流量，而且它只需要该 pod 的密钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而对于 per-host 模式，就没有上述好处了。代理与应用程序 pod 完全解耦，处理主机上所有 pod 的流量，这样会代理各种问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理消耗的资源是高度可变的，这取决于在某个时间点 Kubernetes 调度了多少个 pod 在该主机上。你无法有效的预测特定代理的资源消耗情况，这样代理就有崩溃的风险（原文是这么说的，这点笔者还是存疑的，希望有点读者能解帮忙解释下）。&lt;/li&gt;
&lt;li&gt;主机上 pod 之间的流量争抢问题。因为主机上的所有流量都经过同一个代理，如果有一个应用程序 pod 的流量极高，消耗了代理的所有资源，主机上的其他应用程序就有被饿死的危险。&lt;/li&gt;
&lt;li&gt;代理的爆炸半径很大，而且是不断变化的。代理的故障和升级现在影响到随机的应用程序集合中的一个随机的 pod 子集，意味着任何故障或维护任务都有难以预测的风险。&lt;/li&gt;
&lt;li&gt;使得安全问题更加复杂。以 TLS 为例，主机上的代理必须包含该主机上所有应用程序的密钥，这使得它成为一个新的攻击媒介，容易受到&lt;a href=&#34;https://en.wikipedia.org/wiki/Confused_deputy_problem&#34; title=&#34;混淆代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混淆代理&lt;/a&gt;问题的影响——代理中的任何 CVE 或漏洞都是潜在的密钥泄露风险。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简而言之，sidecar 模式继续贯彻了容器级别的隔离保护——内核可以在容器级别执行所有安全保护和公平的多租户调度。容器的隔离仍然可以完美的运行，而 per-host 模式却破坏了这一切，重新引入了争抢式的多租户隔离问题。&lt;/p&gt;
&lt;p&gt;当然 per-host 也不是一无是处，该模式最大的好处是可以成数量级的减少代理的数量，减少网络跳数，这也就减少了资源消耗和网络延迟。但是与该模式带来的运维和安全性问题相比，这些优势都是次要的。我们也可以通过持续优化 sidecar 来弥补 sidecar 模式在这方面的不足，而 per-host 模式的缺陷确是致命性的。&lt;/p&gt;
&lt;p&gt;其实归根结底还是回到了争抢式多租户问题上，那么能否利用现有的内核解决方案，改进一下 per-host 模式中的代理，让其支持多租户呢？比如改造 Envoy 代理，使其支持多租户模式。虽然从理论来说这是可行的，但是工作量巨大，Matt Klein 也觉得不值得这样做 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，还不如使用容器来实现租户隔离。而且即使让 per-host 模式中的代理支持了多租户，仍然还有爆炸半径和安全问题需要解决。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。Sidecar 模式虽然也有弊端，但它依然是既能保持容器隔离和操作的优势，又能处理云原生网络复杂性的最优方案。eBPF 的能力将来是否会发展到可以处理七层网络流量，从而替代服务网格和 sidecar，也许吧，但那一天可能很遥远。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;William Morgan 的 &lt;a href=&#34;https://buoyant.io/2022/06/07/ebpf-sidecars-and-the-future-of-the-service-mesh/&#34; title=&#34;eBPF, sidecars, and the future of the service mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF, sidecars, and the future of the service mesh&lt;/a&gt; 这篇文章正好回答了我的关于 eBPF、sidecar 的疑问。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;关于 per-host 模式中的代理改造问题，Twitter 上有一个精彩的&lt;a href=&#34;https://twitter.com/mattklein123/status/1522925333053272065&#34; title=&#34;讨论&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>什么是 eBPF？</title>
      <link>https://jimmysong.io/book/what-is-ebpf/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/</guid>
      <description>
        
        
        &lt;p&gt;《什么是 eBPF —— 新一代网络、安全和可观测性工具介绍》译自 O&amp;rsquo;Reilly 发布的报告“What is eBPF”，作者是 Liz Rice，由 JImmy Song 翻译，英文原版可以在 &lt;a href=&#34;https://www.oreilly.com/library/view/what-is-ebpf/9781492097266/&#34; title=&#34;O&amp;amp;rsquo;Reilly 网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly 网站&lt;/a&gt;上获取。&lt;/p&gt;
&lt;h2 id=&#34;译者序&#34;&gt;译者序&lt;/h2&gt;
&lt;p&gt;最近两年来关于 eBPF 的讨论在云原生社区里越来越多，尤其是当谈到 Cilium 的商业化，使用 eBPF 来优化 Istio 服务网格，甚至扬言干掉 Sidecar 时，eBPF 更是赚足了眼球。&lt;/p&gt;
&lt;p&gt;这本报告是由基于 Cilium  的创业公司 Isovalent 的 Liz Rice 撰写，由 O&amp;rsquo;Reilly 发布，相信可以为你揭开 eBPF 技术的神秘面纱，带你了解什么是 eBPF 还有它的强大之处。更重要的是它在云原生环境中，在服务网格、可观测性和安全中的应用。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;Liz Rice 是云原生网络和安全专家，Isovalent 的首席开源官，是基于 eBPF 的 Cilium 网络项目的创建者。她在 2019-2022 年担任 CNCF 的技术监督委员会（TOC）主席，并在 2018 年担任 KubeCon + CloudNativeCon 的联合主席。她也是 Container Security 一书的作者，由 O&#39;Reilly 出版。她拥有丰富的软件开发、团队和产品管理经验，曾在网络协议和分布式系统以及数字技术领域（如 VOD、音乐和 VoIP）工作。在不写代码的时候，Liz 喜欢在天气比她的家乡伦敦好的地方骑自行车，和在 Zwift 上参加虚拟比赛。&lt;/p&gt;
&lt;h2 id=&#34;本书大纲&#34;&gt;本书大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/introduction/&#34;&gt;第一章：eBPF 简介&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/&#34;&gt;第二章：修改内核很困难&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-programs/&#34;&gt;第三章：eBPF 程序&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/&#34;&gt;第四章：eBPF 的复杂性&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/&#34;&gt;第五章：云原生环境中的 eBPF&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-tools/&#34;&gt;第六章：eBPF 工具&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/conclusion/&#34;&gt;第七章：结论&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;


&lt;div class=&#34;cta-group&#34;&gt;
  
    &lt;a href=&#34;introduction&#34;  class=&#34;btn btn-sm btn-primary&#34;&gt;开始阅读&lt;/a&gt;
  
  
&lt;/dv&gt;


      </description>
    </item>
    
    <item>
      <title>如何在产品中引入 eBPF 以增加可观测性</title>
      <link>https://jimmysong.io/trans/how-to-add-bpf-observability/</link>
      <pubDate>Thu, 27 Jan 2022 09:24:17 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/how-to-add-bpf-observability/</guid>
      <description>
        
        
        &lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文译自 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html&#34; title=&#34;How To Add eBPF Observability To Your Product&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How To Add eBPF Observability To Your Product&lt;/a&gt;，原文发布于 2021 年 7 月 3 日。本文作者 Brendan Gregg 是 eBPF 领域的专家，出版过多本相关书籍，本文是他给想要在产品中引入 eBPF 增加可观测性人员的忠告。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;现在有一场军备竞赛，即增加 eBPF 的军备竞赛，在这篇文章中，我将介绍如何快速做到这一点。这也适用于人们将其添加到自己的内部监测系统中。&lt;/p&gt;
&lt;p&gt;人们喜欢在他们建立了原型或构建了产品之后向我展示他们的 BPF 可观测性产品，但我常常在他们开始之前给出建议。作为 BPF 可观测性的领导者，这是我在最近的谈话中一直包含的建议，现在我把它纳入这篇文章中。&lt;/p&gt;
&lt;p&gt;首先，我知道你很忙。你甚至可能不喜欢 BPF。为了务实起见，我将描述如何花最少的精力来获得最大的价值。把这看成是“第一版”。一个相当有用的出发点。无论你是否遵循这个建议，至少请你理解它，以避免以后的遗憾和痛苦。&lt;/p&gt;
&lt;p&gt;如果你正在使用开源监控平台，首先检查它是否已经有一个 BPF 代理。这篇文章假设它没有，而且你将首次添加一些东西。&lt;/p&gt;
&lt;h2 id=&#34;1-运行第一个工具&#34;&gt;1. 运行第一个工具&lt;/h2&gt;
&lt;p&gt;首先安装 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具。例如，Ubuntu 上的 bcc。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# apt-get install bpfcc-tools&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后尝试运行一个工具。例如，使用 execsnoop (8) 查看带有时间戳的进程执行情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# execsnoop-bpfcc -T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TIME     PCOMM            PID    PPID   RET ARGS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 service          &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;6009&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/sbin/service --status-all
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828568&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828569&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/basename /usr/sbin/service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 env              &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/env -i &lt;span class=&#34;nv&#34;&gt;LANG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU.UTF-8 &lt;span class=&#34;nv&#34;&gt;LANGUAGE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU:en &lt;span class=&#34;nv&#34;&gt;LC_CTYPE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NUMERIC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_COLLATE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MONETARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_PAPER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ADDRESS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TELEPHONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MEASUREMENT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_IDENTIFICATION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ALL&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/opt/local/bin:/opt/local/sbin:/usr/local/git/bin:/home/bgregg/.local/bin:/home/bgregg/bin:/opt/local/bin:/opt/local/sbin:/ &lt;span class=&#34;nv&#34;&gt;TERM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;xterm-256color /etc/init.d/acpid 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 acpid            &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /etc/init.d/acpid status
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 run-parts        &lt;span class=&#34;m&#34;&gt;828571&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/run-parts --lsbsysinit --list /lib/lsb/init-functions.d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 systemctl        &lt;span class=&#34;m&#34;&gt;828572&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/systemctl -p LoadState --value show acpid.service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 readlink         &lt;span class=&#34;m&#34;&gt;828573&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/readlink -f /etc/init.d/acpid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然很基本，但我仅用这个工具就解决了很多 perf 问题，包括针对配置错误的系统，其中一个 shell 脚本正在循环启动失败的进程，以及当一些小程序崩溃并每隔几分钟就重启但还没有被注意到时。&lt;/p&gt;
&lt;h2 id=&#34;2-为你的产品添加一个工具&#34;&gt;2. 为你的产品添加一个工具&lt;/h2&gt;
&lt;p&gt;现在想象一下将 execsnoop (8) 添加到你的产品中。你可能已经在你所有的客户系统上运行了代理。他们是否有办法运行一个命令并返回文本输出？或者运行一个命令并将输出发送到其他地方进行聚合（S3、Hive、Druid 等）？有很多选择，这实际上是你自己基于现有系统和客户环境的偏好。&lt;/p&gt;
&lt;p&gt;当你把第一个工具添加到你的产品中时，让它在短时间内运行，比如 10 到 60 秒。我刚刚注意到 execsnoop (8) 还没有持续时间选项，所以在这期间你可以用 &lt;code&gt;watch -s2 60 execsnoop-bpfcc&lt;/code&gt; 来包装它。如果你想 24 小时运行这些工具，首先要研究开销以了解成本。低频率的事件，如进程的执行，捕捉起来应该是可以忽略不计的。&lt;/p&gt;
&lt;p&gt;不使用 bcc，你也可以使用 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 版本。这些通常没有封装选项（-v、-l 等），但有一个 json 输出模式。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# bpftrace -f json execsnoop.bt &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;attached_probes&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;probes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;TIME(ms)   PID   ARGS\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;2737       849176 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;ls -F&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;5641       849178 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;date&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加这种模式是为了使 BPF 的可观测性产品可以建立在 bpftrace 之上。&lt;/p&gt;
&lt;h2 id=&#34;3-不要担心依赖性问题&#34;&gt;3. 不要担心依赖性问题&lt;/h2&gt;
&lt;p&gt;我建议你在客户系统上安装 bcc 或 bpftrace，它们目前有 llvm 依赖。这可能会增加到几十 MB，这对一些资源有限的环境（嵌入式）是个问题。我们一直在做大量的工作，以便在未来解决这个问题。 &lt;a href=&#34;https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html&#34; title=&#34;BTF and CO-RE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF and CO-RE&lt;/a&gt;（而不是 Python），最终将意味着你可以安装 100KB 的无依赖性的工具二进制版本。bpftrace 也有一个类似的计划，使用较新的内核特性生成一个小的无依赖性的二进制版本。&lt;/p&gt;
&lt;p&gt;这确实需要至少 Linux 5.8 才能很好地工作，而你的客户可能几年都不会运行这个系统。在这期间，我建议暂时不要担心 llvm 的依赖关系，因为它以后会被修复。&lt;/p&gt;
&lt;p&gt;请注意，并不是所有的 Linux 发行版都启用了 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt;，这对于 BTF 和 CO-RE 的未来是必要的。主要的发行版已经设置了它，比如在 Ubuntu 20.10、Fedora 30 和 RHEL 8.2。但如果你知道你的一些客户正在运行一些不常见的东西，请检查并鼓励他们或发行商设置 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt; 和 &lt;code&gt;CONFIG_DEBUG_INFO_BTF_MODULES=y&lt;/code&gt;，以避免未来的痛苦。&lt;/p&gt;
&lt;h2 id=&#34;4-第-1-版仪表板&#34;&gt;4. 第 1 版仪表板&lt;/h2&gt;
&lt;p&gt;现在你的产品中有了一个 BPF 可观测性工具，是时候增加更多的工具了。下面是你可以运行的十大工具，并作为一个通用的 BPF 可观测性仪表盘来展示，同时还有建议的可视化。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;展示&lt;/th&gt;
&lt;th&gt;可视化&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;execsnoop&lt;/td&gt;
&lt;td&gt;新进程（通过 exec (2)）&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;opensnoop&lt;/td&gt;
&lt;td&gt;打开的文件&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;ext4slower&lt;/td&gt;
&lt;td&gt;慢速文件系统 I/O&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;biolatency&lt;/td&gt;
&lt;td&gt;磁盘 I/O 延迟柱状图&lt;/td&gt;
&lt;td&gt;热力图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;biosnoop&lt;/td&gt;
&lt;td&gt;每个事件的磁盘 I/O 细节&lt;/td&gt;
&lt;td&gt;表格，偏移热图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;cachestat&lt;/td&gt;
&lt;td&gt;文件系统高速缓存统计&lt;/td&gt;
&lt;td&gt;线状图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;tcplife&lt;/td&gt;
&lt;td&gt;TCP 连接&lt;/td&gt;
&lt;td&gt;表格，分布式图表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8.&lt;/td&gt;
&lt;td&gt;tcpretrans&lt;/td&gt;
&lt;td&gt;TCP 重传&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9.&lt;/td&gt;
&lt;td&gt;runqlat&lt;/td&gt;
&lt;td&gt;CPU 调度器的延迟&lt;/td&gt;
&lt;td&gt;热力图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10.&lt;/td&gt;
&lt;td&gt;profile&lt;/td&gt;
&lt;td&gt;CPU 堆栈跟踪样本&lt;/td&gt;
&lt;td&gt;火焰图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是在我的 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/docs/tutorial.md&#34; title=&#34;bcc Tutorial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc Tutorial&lt;/a&gt; 的，而且很多也存在于 bpftrace 中。我选择这些是为了用最少的工具找到最大的性能优势。&lt;/p&gt;
&lt;p&gt;请注意，runqlat 和 profile 会有明显的开销，所以我只运行这些工具 10 到 60 秒，然后生成一份报告。有些工具的开销很低，如果需要的话可以 24 小时运行（例如 execsnoop、biolatency、tcplife、tcpretrans）。&lt;/p&gt;
&lt;p&gt;在 bcc 和 bpftrace 资源库中，已经有以手册和实例文件形式存在的文档，你可以链接到这些文档，以帮助你的客户了解工具的输出。例如，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/execsnoop_example.txt&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/iovisor/bpftrace/blob/master/tools/execsnoop_example.txt&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 有 execsnoop (8) 的示例文件。&lt;/p&gt;
&lt;p&gt;完成这些后，你就有了第一版的仪表板。&lt;/p&gt;
&lt;h2 id=&#34;bcc-与-bpftrace&#34;&gt;bcc 与 bpftrace&lt;/h2&gt;
&lt;p&gt;bcc 工具是最容易使用的，因为它们通常有很多命令行选项。bpftrace 工具更容易编辑和定制，而且 bpftrace 有一个 json 输出模式。&lt;/p&gt;
&lt;p&gt;如果你是追踪的新手，就用 bcc 吧。如果你想做一些黑客和定制的工具，就用 bpftrace。最后，它们都是不错的选择。&lt;/p&gt;
&lt;h2 id=&#34;案例研究netflix&#34;&gt;案例研究：Netflix&lt;/h2&gt;
&lt;p&gt;Netflix 正在建立一个新的 GUI，在这些工具的 bpftrace 版本的基础上，做这个工具仪表盘和更多的工作。架构如图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu43dc48a3fd9e0abea6a3bc0df7ed9b91_99509_1000x769_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj.jpg&#34; data-img=&#34;/trans/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;769&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;虽然 bpftrace 二进制文件安装在所有目标系统上，但 bpftrace 工具（文本文件）却在网络服务器上，并在需要时被推送出去。这意味着我们可以通过在一个地方更新工具来确保我们一直在运行最新版本的工具。&lt;/p&gt;
&lt;p&gt;这是目前我们 FlameCommander 用户界面的一部分，它也在云端运行火焰图。我们以前的 BPF GUI 是 &lt;a href=&#34;https://github.com/Netflix/vector&#34; title=&#34;Vector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vector&lt;/a&gt; 的一部分，并使用了 bcc，但我们后来废弃了它。我们可能会在某个时候开源新的 GUI，并在 Netflix 技术博客上发表相关文章。&lt;/p&gt;
&lt;h2 id=&#34;案例研究facebook&#34;&gt;案例研究：Facebook&lt;/h2&gt;
&lt;p&gt;Facebook 是 BPF 的高级用户，但他们如何在整个集群中运行工具的深层细节并没有完全公开。根据 bcc 的活动，以及他们对 BTF 和 CO-RE 技术的开发，我十分怀疑他们的解决方案是基于 bcc 的 libbpf-tool 版本。&lt;/p&gt;
&lt;h2 id=&#34;移植的陷阱&#34;&gt;移植的陷阱&lt;/h2&gt;
&lt;p&gt;BPF 追踪工具就像应用程序和内核的补丁。它们需要不断的更新以保持在不同的软件版本中工作。把它们移植到不同的语言，然后不维护它们，可能就像试图把 Linux 4.15 的补丁应用于 Linux 5.12。如果你运气好，它就会工作！如果你不走运，补丁就会应用，但会以一种微妙的方式破坏一些东西，直到后来你才注意到。这取决于工具。&lt;/p&gt;
&lt;p&gt;作为一个极端的例子，我在 2014 年休假时写了 cachestat (8)，用于 Netflix cloud，当时是 Linux 3.2 和 3.13 的混合版本。BPF 在这些版本上并不存在，所以我使用了 Linux 3.2 上的基本 Ftrace 功能。我把这种方法描述为 &lt;a href=&#34;https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html&#34; title=&#34;brittle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;brittle&lt;/a&gt;， &lt;a href=&#34;https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat&#34; title=&#34;sandcastle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sandcastle&lt;/a&gt; 需要随着内核的变化而进行维护。后来，它被移植到了带有 kprobes 的 BPF 上，现在已经被重写并包含在商业可观测性产品中。我听说它在较新的内核上有问题，打印的输出没有意义。它真的需要一次大修。当我（或某人）做了这个工作，任何从 bcc 上拉取更新的人都会自动得到固定的版本，不需要费力。那些重写的人将需要重写自己的版本。我担心他们不会这样做，而客户将在多年来一直运行一个错误的 cachestat (8) 版本。&lt;/p&gt;
&lt;p&gt;请注意，如果在我写 cachestat (8) 的时候，BPF 在我的目标环境中是可用的，我的编码方式就会完全不同。人们正在移植为 Linux 3.2 编写的东西，并在 Linux 5.x 上运行它。&lt;/p&gt;
&lt;p&gt;在以前的一篇博文 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-04/an-unbelievable-demo.html&#34; title=&#34;An Unbelievable Demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;An Unbelievable Demo&lt;/a&gt; 中，谈到了很多年前发生的类似情况，即在没有更新的情况下使用旧的追踪工具版本。&lt;/p&gt;
&lt;p&gt;我所描述的问题是针对 BPF 软件和内核追踪的。作为一个不同的例子，我的火焰图软件已经被重写了十几次，由于它是一个简单而完备的算法，我不认为这有什么大问题。我更喜欢人们帮助更新 &lt;a href=&#34;https://github.com/spiermar/d3-flame-graph&#34; title=&#34;d3 version&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;d3 version&lt;/a&gt; 但如果人们自己做，那也没什么大不了的。你可以给它编码，它将永远工作。基于 uprobe 和 kprobe 的 BPF 工具就不是这样了，因为它们确实需要维护。&lt;/p&gt;
&lt;h2 id=&#34;像系统管理员一样思考而不是像程序员一样思考&#34;&gt;像系统管理员一样思考，而不是像程序员一样思考&lt;/h2&gt;
&lt;p&gt;总之，首先检查你的监控系统是否已经有一个 BPF 代理，如果没有，就在现有的基础上构建一个 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; title=&#34;bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具，而不是从头开始重写一切。这是像一个安装和维护软件的系统管理员那样思考，而不是像一个编码所有东西的程序员那样思考。安装 bcc 或 bpftrace 工具，把它们添加到你的可观测性产品中，并根据需要拉取包的更新。这将是一个快速而有用的版本。BPF 启动和运行了！&lt;/p&gt;
&lt;p&gt;我看到人们反而像程序员一样思考，觉得他们必须从深入学习 bcc 和 BPF 编程。然后，在发现所有的东西都是 C 语言或 Python 写的之后，有些人就用不同的语言重写了。&lt;/p&gt;
&lt;p&gt;首先，学好 bcc 和 BPF 需要几周时间；学习系统跟踪的微妙之处和陷阱可能需要几个月或几年。为了让你了解你所面临的情况，请看我的 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-15/bpf-internals.html&#34; title=&#34;BPF Internals&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF Internals&lt;/a&gt; 讲座。如果你真的想做这个，并且有时间，你当然可以（你可能会在 Tracing 会议上遇到我。在 Linux Plumber’s 或追 Tracing 会上见！）但是，如果你在某个期限内要增加 BPF 的可观测性，那就试着像一个系统管理员那样思考，并在现有的工具基础上进行构建。这是快速的方法。以后再像程序员那样思考，如果你有时间的话。&lt;/p&gt;
&lt;p&gt;第二，BPF 软件，特别是某些基于 kprobe 的工具，需要持续的维护。一个工具可能在 Linux 5.3 上工作，但在 5.4 上就会坏掉，因为一个被追踪的函数被重新命名或增加了一个新的代码路径。BPF 库和框架也在变化和发展，最近的一次是 BTF 和 CO-RE 支持。这是我希望人们在选择重写它们之前要考虑的问题。你是否也有计划重写所有的更新，或者你最终会被困在一个旧的库的端口上？拉取所有的更新比维护你自己的版本更容易。&lt;/p&gt;
&lt;p&gt;最后，如果你有一个比我们在 bcc 和 bpftrace 中使用的更好的 BPF 库或框架的好主意呢？和我们谈谈，试试，创新一下。我们正处于 BPF 时代的开端，还有很多东西需要探索。但请先了解现有的情况以及你所承担的维护负担。你的精力可能会被用来在现有的基础上创造新的东西，而不是移植旧的东西。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>eBPF 和 Wasm：探索服务网格数据平面的未来</title>
      <link>https://jimmysong.io/trans/ebpf-wasm-service-mesh/</link>
      <pubDate>Tue, 11 Jan 2022 10:55:44 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/ebpf-wasm-service-mesh/</guid>
      <description>
        
        
        &lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;前段时间，有人提出使用 eBPF 取代服务网格中的 sidecar 代理，该观点已经发出，就在服务网格和云原生社区中引起了“轩然大波”。后来也有不少人指出该方案实属武断，不切实际。本文就总结了 eBPF 在服务网格数据平面中的作用，以及使用 Wasm 这种新的方案。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;2021 年 12 月 2 日，Cilium 项目宣布了 &lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; title=&#34;Cilium Service Mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium Service Mesh&lt;/a&gt; 的 beta 测试计划。在谷歌云基于 eBPF 的 Google Cloud Kubernetes Service（GKS）Dataplane V2（于 2020 年 8 月发布）所开创的概念基础上，Cilium Service Mesh 提倡“无 sidecar 服务网格 &amp;quot; 的理念。它扩展了 Cilium eBPF 产品，以处理服务网格中的大部分 sidecar 代理功能，包括 L7 路由和负载均衡、TLS 终止、访问策略、健康检查、日志和跟踪，以及内置的 Kubernetes Ingress。&lt;/p&gt;
&lt;p&gt;Cillium 的创建者 Isovalent 在一篇题为“&lt;a href=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/&#34; title=&#34;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&lt;/a&gt; “的文章中解释了使用 eBPF 作为 sidecar 代理的理由。&lt;/p&gt;
&lt;p&gt;它将把我们从 sidecar 模型中解放出来，并允许我们将现有的代理技术整合到现有的内核命名空间概念中，使它们成为我们每天都在使用的容器抽象的一部分。&lt;/p&gt;
&lt;p&gt;简而言之，eBPF 有望解决服务网格中的一个主要痛点 —— 当有许多细粒度的微服务时，性能堪忧。然而，使用 eBPF 来取代 sidecar 代理这个想法也是存在争议的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7_hucc6e13ab1ab06b504dc435006cd3c795_55331_1000x434_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7.jpg&#34; data-img=&#34;/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;434&#34; alt=&#34;image&#34; data-caption=&#34;告别 sidecar&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;告别 sidecar&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;（来源：&lt;a href=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/&#34; title=&#34;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;服务网格中的数据平面指的是管理数据流量如何被路由和交付给微服务应用的基础设施服务。目前，这是通过使用服务代理来实现的。这种设计模式通常也被称为 Sidecar 模式。Sidecar 允许其附属的微服务透明地与服务网格中的其他组件发出和接收请求。&lt;/p&gt;
&lt;p&gt;Sidecar 通常包含一个 L7 网络代理，如 &lt;a href=&#34;https://envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;、&lt;a href=&#34;https://linkerd.io/&#34; title=&#34;Linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 或 &lt;a href=&#34;https://mosn.io/&#34; title=&#34;MOSN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;。该代理处理流量路由、负载均衡、健康检查、认证、授权、加密、日志、跟踪和统计数据收集。Sidecar 还可以包含一个基于 SDK 的应用框架，如 &lt;a href=&#34;https://dapr.io/&#34; title=&#34;Dapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt;，以提供网络代理以外的应用服务。这种应用服务的例子包括服务注册、服务发现、资源绑定、基于名称的服务调用、状态管理、行为者框架和秘密存储。&lt;/p&gt;
&lt;p&gt;Sidecar 代理和服务通常在 Kubernetes pod 或容器内运行。微服务应用也在容器内运行，它们通过网络接口连接到 sidecar 上。然而，这些容器化应用程序的一个重要问题是资源消耗。Sidecar 服务随着微服务的数量呈几何级数增加。当一个应用程序有数百个相互联系和负载均衡的微服务时，开销可能变得不堪重负。服务网格代理供应商在性能上展开竞争。正如 &lt;a href=&#34;https://www.infoq.com/news/2021/08/linkerd-rust-cloud-native/&#34; title=&#34;InfoQ 之前报道的&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 之前报道的&lt;/a&gt;那样，Linkerd 将其代理从 Go 重写成了 Rust，并取得了明显的性能提升。&lt;/p&gt;
&lt;p&gt;不足为奇的是，现有的服务网格供应商并不相信 eBPF 是能解决我们所有问题的圣杯。来自 Solo 的 Idit Levine 等人写了一篇文章来回应 Cilium 的公告。这篇文章的标题是“&lt;a href=&#34;https://www.zhaohuabing.com/post/2021-12-19-ebpf-for-service-mesh/&#34; title=&#34;服务网格将使用 eBPF？是的，但 Envoy 代理将继续存在&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格将使用 eBPF？是的，但 Envoy 代理将继续存在&lt;/a&gt; &amp;ldquo;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Solo.io，我们认为 eBPF 是优化服务网格的一种强大方式，我们认为 Envoy 代理是数据平面的基石。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Solo.io 作者提出的关键点是，现在的 sidecar 代理所做的事情远远超过了简单的网络流量管理。在今天的服务网格部署中，有一些复杂的要求，远远超过了 eBPF 所支持的有限的编程模型，eBPF 是图灵不完整的，对内核的安全性有许多限制。Cilium eBPF 产品可以处理许多，但不是全部，由 sidecar 代理执行的各种任务。此外，Solo.io 的作者指出，eBPF 的每个节点一个代理的设置提供了更少的灵活性，因此与传统代理的每个节点一个代理的设置相比，增加了整体开销。这些 eBPF 的缺点对于开发者必须编写并部署到服务网格代理中的流量路由、负载均衡和授权的特定应用逻辑来说尤其明显。&lt;/p&gt;
&lt;p&gt;Terate.io 的开发者在对 Cilium 公告的回应中提出了类似的论点，标题是“&lt;a href=&#34;https://www.tetrate.io/blog/the-debate-in-the-community-about-istio-and-service-mesh/&#34; title=&#34;社区中关于 Istio 和服务网格的争论&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区中关于 Istio 和服务网格的争论&lt;/a&gt; &amp;ldquo;。他们指出，今天的 sidecar 代理的性能是合理的，开源社区已经想出了进一步提高性能的方法。同时，对于开发者来说，在 eBPF 这种新颖的、图灵不完整的技术中构建特定应用的数据平面逻辑是非常困难的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Istio 架构是稳定的，可用于生产的，而且生态系统正在萌芽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;eBPF 的许多问题与以下事实有关：它是一种内核技术，因此必须有安全限制。有没有一种方法可以将复杂的特定应用的代理逻辑纳入数据平面，而不使用使用空间技术降低性能？事实证明，WebAssembly（Wasm）可能正是这种选择。Wasm 运行时可以安全地隔离并以接近原生的性能执行用户空间代码。&lt;/p&gt;
&lt;p&gt;Envoy Proxy 开创了使用 Wasm 作为扩展机制对数据平面进行编程的方法。开发人员可以用 C、C++、Rust、AssemblyScript、Swift 和 TinyGo 等语言编写特定应用的代理逻辑，并将该模块编译到 Wasm 中。通过 proxy-Wasm 标准，代理可以在 &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime&#34; title=&#34;Wasmtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasmtime&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/WasmEdge/WasmEdge&#34; title=&#34;WasmEdge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge&lt;/a&gt; 等高性能运行机制中执行那些 Wasm 插件。目前，&lt;a href=&#34;https://envoyproxy.io/&#34; title=&#34;Envoy Proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;、&lt;a href=&#34;https://github.com/istio/proxy&#34; title=&#34;Istio Proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Proxy&lt;/a&gt;、MOSN 和 &lt;a href=&#34;http://openresty.org/&#34; title=&#34;OpenResty&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenResty&lt;/a&gt; 支持 &lt;a href=&#34;https://github.com/proxy-wasm&#34; title=&#34;proxy-Wasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proxy-Wasm&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70_hu7a2a222547ac097e607aceb17e3f940d_96912_715x1000_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70.jpg&#34; data-img=&#34;/trans/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70.jpg&#34; data-width=&#34;715&#34; data-height=&#34;1000&#34; alt=&#34;image&#34; data-caption=&#34;容器生态&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;容器生态&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;（容器生态系统中的 Wasm，来源：&lt;a href=&#34;https://wasmedge.org/book/en/kubernetes.html&#34; title=&#34;WasmEdge Book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge Book&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;此外，Wasm 可以作为一个通用的应用容器。它在服务网格数据平面上的应用并不限于 sidecar 代理。附在 sidecar 上的微服务可以在它自己的轻量级 Wasm 运行时运行。WasmEdge WebAssembly 运行时是一个安全、轻量级、快速、可移植和多元化的运行时，可以直接由 &lt;a href=&#34;https://wasmedge.org/book/en/kubernetes.html&#34; title=&#34;Kubernetes 作为容器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 作为容器&lt;/a&gt;管理。到 2021 年 12 月，WasmEdge 社区的贡献者证明了基于 WasmEdge 的微服务可以与 &lt;a href=&#34;https://github.com/second-state/dapr-wasm&#34; title=&#34;Dapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/Liquid-Reply/kind-crun-wasm&#34; title=&#34;Linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 一起工作，作为带有操作系统和完整软件堆栈的重量级全面的 Linux 容器的替代。WebAssembly 微服务消耗 1% 的资源，与 Linux 容器应用相比，冷启动的时间是 1%。&lt;/p&gt;
&lt;p&gt;eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>告别 Sidecar——使用 eBPF 解锁内核级服务网格</title>
      <link>https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/</link>
      <pubDate>Thu, 09 Dec 2021 21:03:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/</guid>
      <description>
        
        
        &lt;p&gt;译者注：本文作者是 Isovalent 联合创始人&amp;amp;CTO，原文标题 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; title=&#34;How eBPF will solve Service Mesh - Goodbye Sidecars&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How eBPF will solve Service Mesh - Goodbye Sidecars&lt;/a&gt;，作者回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hua6c2cd571585fb65a70eadebc0ec1003_20153_1000x333_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;333&#34; alt=&#34;image&#34; data-caption=&#34;服务网格示意图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;服务网格示意图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;纵观今天服务网格的功能设置，可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弹性连接&lt;/strong&gt;：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L7 流量管理&lt;/strong&gt;：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于身份的安全&lt;/strong&gt;：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观测性和跟踪&lt;/strong&gt;：追踪和指标形式的可观测性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明&lt;/strong&gt;：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_huc07436ee8edf5797da1225297f3d73d5_34631_1000x325_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;325&#34; alt=&#34;image&#34; data-caption=&#34;基于库的服务网格模型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于库的服务网格模型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为“挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_huaf93cae986db9eaf01d794ad4e833541_34035_1000x369_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;369&#34; alt=&#34;image&#34; data-caption=&#34;基于 Sidecar 的服务网格模型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于 Sidecar 的服务网格模型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。&lt;/p&gt;
&lt;p&gt;这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。&lt;/p&gt;
&lt;h2 id=&#34;连接性转移到内核中的历史&#34;&gt;连接性转移到内核中的历史&lt;/h2&gt;
&lt;p&gt;几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Wrappers&#34; title=&#34;TCP 包装器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 包装器&lt;/a&gt;和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。&lt;/p&gt;
&lt;p&gt;然而，iptables 显然不适合解决现代应用的连接性、安全性和可观测性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu8a5473f255e424c714bce0ef0dc797bf_57615_1000x565_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;565&#34; alt=&#34;image&#34; data-caption=&#34;服务网格的进化&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;服务网格的进化&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。&lt;/p&gt;
&lt;h2 id=&#34;扩展内核命名空间概念&#34;&gt;扩展内核命名空间概念&lt;/h2&gt;
&lt;p&gt;Linux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 &amp;ldquo;容器&amp;rdquo; 概念中。&lt;/p&gt;
&lt;p&gt;符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0231bbb9093297f602ab036f13fd844c_60777_1000x426_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;426&#34; alt=&#34;image&#34; data-caption=&#34;Service Mesh Namespace&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Service Mesh Namespace&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。&lt;/p&gt;
&lt;h3 id=&#34;注入-sidecar-的成本&#34;&gt;注入 Sidecar 的成本&lt;/h3&gt;
&lt;p&gt;如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu8a5473f255e424c714bce0ef0dc797bf_57615_1000x565_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;565&#34; alt=&#34;image&#34; data-caption=&#34;注入 Sidecar 的成本&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;注入 Sidecar 的成本&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。&lt;/p&gt;
&lt;h2 id=&#34;用-ebpf-解锁内核服务网格&#34;&gt;用 eBPF 解锁内核服务网格&lt;/h2&gt;
&lt;p&gt;为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见&lt;a href=&#34;https://www.youtube.com/watch?v=lUF88T16YqY&amp;amp;ab_channel=CloudNativeRejekts&#34; title=&#34;我们已经构建了相当多的服务网格 - Tim Hockin, Google&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们已经构建了相当多的服务网格 - Tim Hockin, Google&lt;/a&gt;）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。&lt;/p&gt;
&lt;p&gt;eBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观测性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观测性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_huef89581372e3d2d6460499fe849d7582_45764_1000x440_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;440&#34; alt=&#34;image&#34; data-caption=&#34;eBPF 服务网格架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;eBPF 服务网格架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;有人可能想知道为什么 Linux 内核社区不直接解决这些需求&lt;/strong&gt;。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。&lt;strong&gt;新的内核版本需要几年时间才能进入用户手中&lt;/strong&gt;。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。&lt;/p&gt;
&lt;h2 id=&#34;无-sidecar-的基于-ebpf-的-l7-追踪和度量&#34;&gt;无 Sidecar 的基于 eBPF 的 L7 追踪和度量&lt;/h2&gt;
&lt;p&gt;让我们看看 L7 追踪和指标可观测性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观测性应该没有明显的成本（延迟、复杂性、资源…）。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hu1e4ac016ebc928d7a057881be1715063_60109_1000x317_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;317&#34; alt=&#34;image&#34; data-caption=&#34;基于 eBPF 的可视性&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于 eBPF 的可视性&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu2d8acacafd20e3778dae86b39c157b1b_22234_1000x456_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;456&#34; alt=&#34;image&#34; data-caption=&#34;基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。&lt;strong&gt;几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-加速的-per-node-代理&#34;&gt;使用 eBPF 加速的 per-node 代理&lt;/h2&gt;
&lt;p&gt;越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。&lt;/p&gt;
&lt;p&gt;我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。&lt;/p&gt;
&lt;p&gt;当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu0cace0b51a36ab5ebf81e1babd7d4fc9_63694_1000x443_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;443&#34; alt=&#34;image&#34; data-caption=&#34;eBPF per-node Proxy&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;eBPF per-node Proxy&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;eBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-与-per-node-代理&#34;&gt;Sidecar 与 per-Node 代理&lt;/h2&gt;
&lt;p&gt;即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。&lt;/p&gt;
&lt;h3 id=&#34;每个连接的代理&#34;&gt;每个连接的代理&lt;/h3&gt;
&lt;p&gt;所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hu986159b4e232c7961a9a9aeda960997f_17519_1000x251_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;251&#34; alt=&#34;image&#34; data-caption=&#34;基于 eBPF 的模型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于 eBPF 的模型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_huab3be886213e4ac57c5bd81133a2a75d_24827_1000x267_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;267&#34; alt=&#34;image&#34; data-caption=&#34;基于 Sidecar 代理的模型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;基于 Sidecar 代理的模型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hueca18b1a0d51d8f422c3ba1be248960a_21017_1000x297_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;297&#34; alt=&#34;image&#34; data-caption=&#34;Per-node 代理模式&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Per-node 代理模式&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;所需的代理总数&#34;&gt;所需的代理总数&lt;/h3&gt;
&lt;p&gt;在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hucca097a7d2b6683e670c6328dc47e158_52881_1000x345_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;345&#34; alt=&#34;image&#34; data-caption=&#34;代理数量&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;代理数量&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。&lt;/p&gt;
&lt;h3 id=&#34;多租户&#34;&gt;多租户&lt;/h3&gt;
&lt;p&gt;当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu588ae9502772a2ece0f3403c0248a501_70295_1000x556_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;556&#34; alt=&#34;image&#34; data-caption=&#34;Envoy Namespace&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Envoy Namespace&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（&lt;a href=&#34;https://www.youtube.com/watch?v=08opgZkdYIw&#34; title=&#34;Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;想参与其中吗--加入-cilium-服务网格测试版&#34;&gt;想参与其中吗？- 加入 Cilium 服务网格测试版&lt;/h2&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_hueac9918fc9393273000a54501e65fa1e_47275_1000x376_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm.jpg&#34; data-img=&#34;/trans/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;376&#34; alt=&#34;image&#34; data-caption=&#34;测试版&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;测试版&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L7 流量管理和负载均衡（HTTP，gRPC，…）&lt;/li&gt;
&lt;li&gt;跨集群、云和集群的拓扑感知路由&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等&lt;/li&gt;
&lt;li&gt;用 OpenTelemetry 和 Jaeger 集成进行追踪&lt;/li&gt;
&lt;li&gt;内置 Kubernetes Ingress 支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述所有功能都可以在 &lt;a href=&#34;https://github.com/cilium/cilium&#34; title=&#34;github.com/cilium/cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github.com/cilium/cilium&lt;/a&gt; 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 &lt;a href=&#34;https://forms.gle/j9fwhAC6HnHRJQKeA&#34; title=&#34;这个表格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个表格&lt;/a&gt;，或者你可以在 Cilium 社区的&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; title=&#34;公告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公告&lt;/a&gt;中阅读更多关于该计划的信息。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;eBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。&lt;/p&gt;
&lt;p&gt;如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 &lt;a href=&#34;https://twitter.com/tgraf__&#34; title=&#34;Twitter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; 或 &lt;a href=&#34;http://ebpf.io/slack&#34; title=&#34;eBPF &amp;amp;amp; Cilium Slack 联系我们&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF &amp;amp; Cilium Slack 联系我们&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;进一步阅读&#34;&gt;进一步阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/&#34; title=&#34;eBPF 如何简化服务网格&#34;&gt;eBPF 如何简化服务网格&lt;/a&gt;，Liz Rice，The New Stack&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; title=&#34;Cilium 服务网格测试计划&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 服务网格测试计划&lt;/a&gt;，Cilium 社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/learn&#34; title=&#34;了解更多关于 Cilium 的信息&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;了解更多关于 Cilium 的信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>eBPF 如何简化服务网格</title>
      <link>https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/</link>
      <pubDate>Wed, 27 Oct 2021 13:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对额外的&lt;a href=&#34;https://engineering.hellofresh.com/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb&#34; title=&#34;复杂性&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;复杂性&lt;/a&gt;和&lt;a href=&#34;https://pklinker.medium.com/performance-impacts-of-an-istio-service-mesh-63957a0000b&#34; title=&#34;开销的&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开销的&lt;/a&gt;实际&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; title=&#34;担忧所抑制&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;担忧所抑制&lt;/a&gt;。让我们来探讨一下 &lt;a href=&#34;https://ebpf.io/&#34; title=&#34;eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是如何让我们精简&lt;a href=&#34;https://thenewstack.io/category/service-mesh/&#34; title=&#34;服务网格&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;，使服务网格的数据平面更有效率，更容易部署。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-问题&#34;&gt;Sidecar 问题&lt;/h2&gt;
&lt;p&gt;今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 &lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 或 &lt;a href=&#34;https://linkerd.io/&#34; title=&#34;Linkerd-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd-proxy&lt;/a&gt;。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。&lt;/p&gt;
&lt;p&gt;每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; title=&#34;经验&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;经验&lt;/a&gt;，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu446b6895590d0bfbfa3a8560a0fad8f5_76212_1000x440_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8.jpg&#34; data-img=&#34;/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;440&#34; alt=&#34;image&#34; data-caption=&#34;来自 &amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; title=&amp;#34;redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理 sidecar&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;来自 &amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; title=&amp;#34;redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理 sidecar&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。&lt;/p&gt;
&lt;h2 id=&#34;引入-ebpf&#34;&gt;引入 eBPF&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ebpf.io/&#34; title=&#34;eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。&lt;/p&gt;
&lt;p&gt;重要的是，&lt;strong&gt;每个节点只有一个内核&lt;/strong&gt;；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_hu82c6f19b59d0aedaafd4c57822109e76_64671_1000x597_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg&#34; data-img=&#34;/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;597&#34; alt=&#34;image&#34; data-caption=&#34;每台主机一个内核&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;每台主机一个内核&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 &lt;a href=&#34;http://cilium.io/&#34; title=&#34;Cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 项目（最近 &lt;a href=&#34;https://www.cncf.io/blog/2021/10/13/cilium-joins-cncf-as-an-incubating-project/&#34; title=&#34;以孵化级别加入云计算基金会&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以孵化级别加入云计算基金会&lt;/a&gt;）将这种“无 sidecar&amp;quot; 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu5b3618fa84b4187fcc1006fa4a80037a_47992_1000x430_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg&#34; data-img=&#34;/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;430&#34; alt=&#34;image&#34; data-caption=&#34;用无 sidecar 代理模式减少代理实例&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;用无 sidecar 代理模式减少代理实例&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;减少-yaml&#34;&gt;减少 YAML&lt;/h2&gt;
&lt;p&gt;在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。&lt;/p&gt;
&lt;p&gt;以 Istio 为例，这需要&lt;a href=&#34;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#controlling-the-injection-policy&#34; title=&#34;标记&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标记&lt;/a&gt; Kubernetes 命名空间和 / 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。&lt;/p&gt;
&lt;p&gt;但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。&lt;/p&gt;
&lt;p&gt;相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。&lt;/p&gt;
&lt;p&gt;如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-支持的网络效率&#34;&gt;eBPF 支持的网络效率&lt;/h2&gt;
&lt;p&gt;支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的&lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark&#34; title=&#34;性能得到显著改善&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能得到显著改善&lt;/a&gt;。让我们看看这在服务网格数据平面中是如何应用的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu99fe30579521a751f54e46340b89eed8_69860_1000x482_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg&#34; data-img=&#34;/trans/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;482&#34; alt=&#34;image&#34; data-caption=&#34;在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的&lt;a href=&#34;https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/#latency-at-20-rps&#34; title=&#34;显著增加&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;显著增加&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。&lt;/p&gt;
&lt;h2 id=&#34;网络中的加密&#34;&gt;网络中的加密&lt;/h2&gt;
&lt;p&gt;如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。&lt;/p&gt;
&lt;p&gt;通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec&#34; title=&#34;IPSec 或 WireGuard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPSec 或 WireGuard&lt;/a&gt;。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-是服务网格的数据平面&#34;&gt;eBPF 是服务网格的数据平面&lt;/h2&gt;
&lt;p&gt;现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。&lt;/p&gt;
&lt;p&gt;去年，我代表 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; title=&#34;CNCF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 &lt;a href=&#34;https://youtu.be/bESogtuHwX0&#34; title=&#34;预测&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;预测&lt;/a&gt;。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
