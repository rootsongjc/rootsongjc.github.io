<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Ebpf · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/ebpf/" />
  <meta property="og:title" content="Ebpf | Jimmy Song" />
  <meta property="twitter:title" content="Ebpf | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/ebpf/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Ebpf
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/application-traffic-with-ebpf/">[译] 用 eBPF 洞察应用层网络流量</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/12/08/Application-traffic-with-eBPF/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('用 eBPF 洞察应用层网络流量', '本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。', '在[先前的帖子](..\/ebpf-adventures-in-networking\/)中，我稍微谈到了建立 eBPF 知识，以开始更多地了解网络适配器的输入和输出情况。基本上，将以太网帧并剥离标头（以太网标头\u002bIP 标头\u002bTCP\/UDP 标头），最终你将得到来自应用程序或数据角度的数据包中剩余的内容。\n\n所有的代码都在“学习 eBPF”存储库中，具体的 eBPF 代码在[这里](https:\/\/github.com\/thebsdbox\/learning-ebpf\/blob\/main\/ebpf\/http\/http.c)。这篇文章的计划是逐步介绍我认为有用或可能重要的部分...\n\n**注意**：此代码确实对入口\/出口数据包进行了一些修改，因此需要 6.1\u002b 的 Linux 内核才能使用一些 eBPF 助手函数。\n\n## 映射！\n\n你可能以前遇到过这些吧？如果没有，不用担心！简而言之，eBPF 映射是在用户空间和内核中的 eBPF 程序之间通信的机制。在我看来，非常酷的一点是这些映射使用键和值...所以我不必循环比较数据并寻找匹配的内容，我传递一个键，如果有匹配的内容，我就得到相应的数据:D\n\n下面是我将要使用的映射，称为\u0060url_map\u0060，键是 20 个字符长（可以说是有界的“字符串”），分配给该键的值是我在上面定义的结构体。\n\n\u0060\u0060\u0060\n\/\/ 定义与键关联的不同URL\nstruct url_path {\n  __u8 path_len;\n  __u8 path[max_path_len]; \/\/ 这应该是一个char，但在这里和Go之间的代码生成有点不同...\n};\n\n\/\/ 定义我的URL映射\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 1024);\n  __type(key, char[max_path_len]);\n  __type(value, struct url_path);\n}\nurl_map SEC(\u0022.maps\u0022);\n\u0060\u0060\u0060\n\n## eBPF 程序！\n\n代码中定义了两个 eBPF 程序\u0060tc_egress\u0060和\u0060tc_ingress\u0060，如果你能猜到它们是如何连接的，那就加分！在这篇文章中，我们只关注\u0060tc_ingress\u0060程序。\n\n就像我们在已经存在的众多示例中看到的那样，我们需要进行标头识别的操作。\n\n1. 进行合理性检查，并将\u0060data\u0060强制转换为\u0060ethhdr\u0060类型（[以太网标头](https:\/\/en.wikipedia.org\/wiki\/Ethernet_frame)）。\n2. 通过读取以太网标头内部的\u0060h_proto\u0060（也称为\u0060Ethertype\u0060）来查找以太网帧内部的协议。\n3. 将以太网标头后的数据强制转换为\u0060iphdr\u0060类型（[IP 标头](https:\/\/en.wikipedia.org\/wiki\/Internet_Protocol_version_4#Header)）。\n4. 在 IP 标头内查找协议，我们还需要确定 IP 标头的大小（原来它们可以有不同的大小！\u0060¯\\_(ツ)_\/¯\u0060）。\n5. 为了确定标头的大小，我们将其值乘以四，你可能会问为什么！好吧，这个值乘以 32 位以确定标头的大小，所以如果值为 6，那么标头将是 192 位（或 24 字节）。所以，为了简单地确定 IP 标头的字节数，我们可以将这个值乘以 4！\n6. 将以 IP 标头后的数据强制转换为\u0060tcphdr\u0060类型（[TCP 标头](https:\/\/en.wikipedia.org\/wiki\/Transmission_Control_Protocol#TCP_segment_structure)）。\n7. 像步骤（5）一样，我们需要确定 TCP 标头的大小（它也可以是动态的），在这里的步骤也是一样的，我们只需要将值\u0060doff\u0060乘以四来确定标头的大小（以字节为单位）。\n8. 通过计算所有这些，我们现在可以推断出数据位于以太网标头大小、IP 标头大小和 TCP 标头大小的末尾。\n9. 最后，我们可以通过从 IP 标头中减去 IP 和 TCP 标头的大小来确定应用程序数据的大小，使用\u0060tot_len\u0060（总长度）。\n\n### 应用数据！！\n\n为了读取这些数据，我们将需要上面提到的一些东西！\n\n首先，我们需要数据偏移量（数据起始位置），它位于以太网标头\u002bIP 标头大小（一旦计算出来）和 TCP 标头（再次，一旦计算出来）之后。我们还需要一个缓冲区来存储我们将从套接字缓冲区中读取的数据。\n\n\u0060\u0060\u0060c\n\/\/ 用于存储我们应用程序数据的数据缓冲区\nchar pdata[60];\n\n\/\/ 计算数据实际位置的偏移量\npoffset = ETH_HLEN \u002b ip_hlen \u002b tcp_hlen;\n\n\/\/ 从套接字缓冲区加载数据，poffset 从 TCP 标头的末尾开始\nint ret = bpf_skb_load_bytes(skb, poffset, pdata, 60);\nif (ret != 0) {\n   return 0;\n}\n\u0060\u0060\u0060\n\n我们使用\u0060bpf_skb_load_bytes\u0060从套接字缓冲区（\u0060skb\u0060）中读取一定量的数据（60 个字节）到我们的缓冲区（\u0060pdata\u0060），起始位置是我们知道数据位于的偏移量（\u0060poffset\u0060）！\n\n此时，我们有了 60 字节的数据，应该足够让我们编写一些代码来理解它。\n\n### HTTP 数据 :-)\n\n让我们看看当我们尝试进行 HTTP 请求时会发生什么！\n\n\u0060\u0060\u0060plaintext\n ~ curl code\/test -vvv\n*   Trying 192.168.0.22:80...\n* Connected to code (192.168.0.22) port 80 (#0)\n\u003e GET \/test HTTP\/1.1\n\u003e Host: code\n\u003e User-Agent: curl\/7.87.0\n\u003e Accept: *\/*\n\n...\n\u0060\u0060\u0060\n\n我正在使用\u0060curl\u0060从主机\u0060code\u0060（code 是我的开发 VM，运行 code-server）请求 URL \u0060\/test\u0060。我们可以看到发送到服务器的数据（每行以\u0060\u003e\u0060开头，用于确定通信的方向）。HTTP 请求中的第一行数据通常是一个*动词*，后面是我们希望与之交互的资源，然后是 HTTP 规范和回车符，如[HTTP 标准](https:\/\/en.wikipedia.org\/wiki\/HTTP#HTTP\/1.1_request_messages)中定义。因此，我们可以看到我们关心的行是\u0060GET \/test\u0060（在这一点上，我们\/我不太关心 HTTP 规范:D）。\n\n第一步是读取\u0060pdata\u0060的前三个字符，查找\u0060pdata[0] == G\u0060，\u0060pdata[1] == E\u0060和\u0060pdata[2] == T\u0060，这将有效地帮助我们确定首先是否是 HTTP 请求，特别是是否是 HTTP 请求！\n\n一旦我们验证了这前 3 个字节，我们将想要从第 4 个字节（请求的前三个字节加上一个用于分隔的空格）开始读取更多数据！\n\n\u0060\u0060\u0060c\nchar path[max_path_len];\nmemset(\u0026path, 0, sizeof(path));\n\nint path_len = 0;\n\n\/\/ 查找请求 URI（从偏移量 4 开始），以空格结束\nfor (int i = 4; i \u003c sizeof(pdata) ; i\u002b\u002b)\n{\n    if (pdata[i] != \u0027 \u0027) {\n        path[i-4] = pdata[i];\n    } else {\n        path[i-4] = \u0027\\0\u0027;\n        path_len = i-4;\n        break;\n    }\n}\n\u0060\u0060\u0060\n\n上面的函数将从 HTTP 数据的第 4 个字节开始（从第 4 个字节开始）读取其余的数据，直到遇到空格为止，留下我们要\u0060GET\u0060的 URL！我们可以通过一个调试打印语句来验证这一点：\n\n\u0060\u0060\u0060c\nbpf_printk(\u0022\u003c- incoming path [%s], length [%d]\u0022, path, path_len);\n\u0060\u0060\u0060\n\n这将在日志中显示如下：\n\n\u0060\u0060\u0060plaintext\n\u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n\u0060\u0060\u0060\n\n### 对 HTTP 应用程序请求采取行动\n\n上述解释详细说明了我们如何读取数据以及如何读取数据，但如果我们想要“动态”查找 HTTP 请求，我们将需要使用 eBPF 映射。\n\n在我们的 Go 用户空间代码中，我们执行以下操作：\n\n\u0060\u0060\u0060go\npath := flag.String(\u0022path\u0022, \u0022\u0022, \u0022The URL Path to watch for\u0022)\nflag.Parse()\n\n\/\/ ...\n\n\/\/ 创建一个 uint8 数组\nvar urlPath [20]uint8\n\/\/ 将我们的字节复制到 uint8 数组中（我们可以进行类型转换）\ncopy(urlPath[:], *path)\n\n\/\/ 将我们的 urlPath 作为键\nerr = objs.UrlMap.Put(urlPath,\n  bpfUrlPath{\n    Path:    urlPath,\n    PathLen: uint8(len(urlPath)),\n  })\nif err != nil {\n  panic(err)\n}\n\u0060\u0060\u0060\n\n正如我们在上面的代码中看到的，当我们启动 Go 程序时，它将从标志\u0060-path\u0060中读取，并将其用作我们 eBPF 映射中的**键**，可以暂时忽略值。\n\n\u0060\u0060\u0060c\nstruct url_path *found_path = bpf_map_lookup_elem(\u0026url_map, path);\nif (found_path \u003e 0) {\n    bpf_printk(\u0022Looks like we\u0027ve found your path [%s]\u0022, path);\n    \/\/ 可能进行更多操作，阻止流量或重定向？\n}\n\u0060\u0060\u0060\n\n在我们的 eBPF 程序中，我们将对 HTTP 请求进行映射查找，如果该请求作为 char 数组存在于**键**中，那么我们就可以对其进行操作！\n\n现在启动我们的 Go 程序 \u0060sudo .\/http -interface ens160 -path \/test\u0060 将得到以下结果：\n\n\u0060\u0060\u0060plaintext\nINFO[0000] Starting 🐝 the eBPF HTTP watcher, on interface [ens160] for path [\/test]\nINFO[0000] Loaded TC QDisc\nINFO[0000] Press Ctrl-C to exit and remove the program\n          \u003cidle\u003e-0       [001] d.s3. 2252901.015575: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] D.s3\n\n. 2252901.015642: bpf_trace_printk: -\u003e 192.168.0.22:80 -\u003e 192.168.0.180:56345\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017552: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017793: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017814: bpf_trace_printk: Looks like we\u0027ve found your path [\/test]\n\u0060\u0060\u0060\n\n## 结论\n\n解析 HTTP 并不太困难，因为它是一个相对简单的协议，它使用简单的动词和结构的简单方法，使用空格和回车符来区分。这种方法可能也适用于其他协议，如 DNS、POP3 或 SMTP。当数据加密时，我们需要一种解密的方法，然后才能解析数据（这超出了我的能力...）。但是，我希望这会激发你更多地尝试使用 eBPF 来解析和操作应用程序的想法！\n\n我一直想写一些有希望有用的关于 eBPF 的帖子，尽管通常在我想出可能有用的东西之后，别人已经抢先一步。鉴于我已经在一段时间里以某种方式关注网络，这基本上是我关注的领域，尽管我确实为最近的 eBPF 峰会 2023 编写了一些有趣的内容。如上所述，有很多人开始撰写 eBPF 内容，所以我可能会参考他们的帖子，而不是重复内容。\n', '\/trans\/application-traffic-with-ebpf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-adventures-in-networking/">[译] 如何用 eBPF 改变网络编程的游戏规则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/11/18/eBPF-adventures-in-networking/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何用 eBPF 改变网络编程的游戏规则', '这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。', '\n我一直想写一些关于 eBPF 的帖子，希望它们能有所帮助，尽管通常在我想到可能有用的东西时，其他人已经先我一步了。鉴于我已经在网络方面集中精力一段时间，这基本上是我专注的领域，尽管我确实设法为最近的 eBPF 峰会 2023 准备了一些我认为很有趣的东西。正如我之前提到的，有很多人开始撰写关于 eBPF 的内容，因此我可能会参考他们的帖子，而不是重复内容。\n\n我将从一些在 Linux 内核中可能或可能不会遇到的首字母缩写或技术开始。但基本上从我的角度来看，这些是你修改正在运行的系统以与网络数据交互的主要选项。\n\n### XDP\n\n关于 eXpress Data Plane 已经存在大量信息，因此我不会深入探讨太多细节。\u0060tl;dr\u0060是 XDP eBPF 程序挂钩到 XDP 将使其能够访问由内核自身处理之前的传入网络帧。在某些情况下，eBPF 程序将加载到 NIC 驱动程序本身中，这将有效地将程序卸载到 NIC 本身。\n\n### 优点\n\n- 最佳性能\n- 非常适用于防火墙、DDoS 防护或负载均衡等用例\n- 在任何其他内容进行修改之前看到传入的流量\n\n### 缺点\n\n- 仅支持入站流量，使用 XDP 程序看到的任何流量都只是传入流量，目前无法看到出站流量\n- 使用\u0060XDP\u0060数据结构，与大多数套接字编程的默认数据结构\u0060SKB\u0060有一些不同。\n\n### TC（Traffic Control）或流量控制\n\nTraffic Control 是内核网络结构的一个重要组成部分，主要包括添加诸如 qdisc 和过滤器之类的功能到接口的能力。qdisc 主要集中在为 TBD（待定）提供服务，而过滤器通常在底层实际上是一个 eBPF 程序。\n\n常见的工作流程是：\n\n1. 创建一个关注入口或出口的 qdisc，或者替换一个现有的 qdisc。qdisc 将附加到接口上。\n2. 加载你的 eBPF 程序。\n3. 创建一个过滤器，将其附加到通过接口上的 qdisc 上的入口或出口之一。该过滤器将与 eBPF 程序相关联，这意味着所有传入或传出的流量现在都会通过一个程序运行（如果连接）。\n4. 获利 💰\n\n### 优点\n\n- 提供入口和出口的挂钩点\n- 使用传统的\u0060SKB\u0060数据结构\n\n### 缺点\n\n- 将 TC 程序附加到入口或出口队列稍微复杂一些。用户需要使用 qdisc 来做到这一点，某些 eBPF SDK 不会原生支持 TC 程序的使用。\n- TC eBPF 程序看到的流量可能已经被之前的 XDP 程序或内核本身修改。\n\n### 系统调用\n\n与其他两种专门设计用于处理网络的方法相比，这可能会显得有些奇怪，因为它是将一些 eBPF 代码附加到内核中的系统调用的一种替代方法，具体来说是\u0060tcp4_connect()\u0060 \/ \u0060tcp6_connect()\u0060等调用。这在协议栈中略微靠后，因为在此时，传入数据包已经经过了很多内核逻辑，而 eBPF 内省点是当流量即将与应用程序本身交互时。\n\n## 编写网络程序！\n\n所以在这一点上，我们（希望）意识到我们有许多不同的入口点，允许我们在“传送带”上注入我们的代码，这个传送带从 NIC 开始，一直到应用程序（以及在出站的情况下）。\n\n### 回顾\n\n在我们所谓的“传送带”的开头，我们可以附加我们的 XDP 程序并获得未经触碰的原始网络数据。在“传送带”的中间，我们的 TC 程序将成为通过内核的路径的一部分，并接收可能被修改的网络数据。在传送带的末端，我们可以将代码附加到应用程序将在它被运行之前获取网络数据的函数，这些函数可以在传送带的末端进行附加。\n\n### 数据表示\n\n你的程序附加到的位置决定了两个主要事物，一个是潜在的流量修改的相对级别，另一个是流量的表示方式。\n\n### XDP 结构\n\n我会写关于它的内容，但是 DataDog 已经做了，你可以在[这里](https:\/\/www.datadoghq.com\/blog\/xdp-intro\/#the-flow-of-an-xdp-program)阅读。\n\n### SKB（套接字缓冲区）\n\nSKB 是在 eBPF 添加到内核之前就存在于内核中的数据类型，它已经具备了一些使与 SKB 对象交互变得稍微容易一些的辅助功能。有关更深入的 SKB 介绍，你可以阅读此文 -\u003e http:\/\/vger.kernel.org\/~davem\/skb_data.html\n\n### 解析数据\n\n无论与哪个结构进行交互，它们都共享一些共同之处，这主要是两个变量，对于这两种数据类型来说是相同的。\n\n这些变量是：\n\n- \u0060data\u0060，它是 eBPF 程序接收到的数据的指针\n\n- \u0060data_len\u0060，它是一个整数，指定了有多少数据可用（以帮助确保你永远不会访问\u0060data\u0060超过\u0060data_len\u0060（显而易见的真理 🤓））\n\n所以这一切似乎很简单，但等等... \u0060*data\u0060中实际上有什么？（这取决于你的发现）\n\n通过不断“转换”\u0060*data\u0060并沿着它移动以剥离各种标头，我们可以了解和查找底层数据！\n\n### 转换？\n\n如果你愿意，你可以跳过此部分，但这是一个快速（且糟糕）的示例，说明了我们通常如何将一些原始数据转换为有意义的东西。目前，\u0060*data\u0060将只是一串随机数据，毫无意义，我们需要有效地为其添加“格式”以便我们可以理解其外观。\n\n考虑一下随机数据行：“Bobby0004500100.503 Harvard Drive90210”，其中一些对裸眼来说是有意义的，但有些是不清楚的。\n\n想象一下名为“person”的数据结构：\n\n\u0060\u0060\u0060bash\nName: string\nAge: number\nBalance: float\nStreet: string\nZipCode: number\n\u0060\u0060\u0060\n\n如果我们要将我们的随机数据“转换”为上面的“person”结构，它将突然变成：\n\n\u0060\u0060\u0060bash\nName: Bobby\nAge: 45\nBalance: 100.50\nStreet: 3 Harvard Drive\nZipCode: 90210\n\u0060\u0060\u0060\n\n现在突然间，我能够理解并访问结构中的底层变量，因为它们现在是有意义的，即 person-\u003eName，并且发现此特定的 person 类型对象具有名称变量“Bobby”！\n\n这正是我们将对我们的\u0060*data\u0060所做的！\n\n### 数据中包含什么？\n\n因此，第一步是确定数据是否以以太网帧开头！几乎所有传输的数据都以以太网帧开头，这相当简单，但其作用是具有源和目标硬件地址（无论虚拟化\/容器化\/有线网络还是 WiFi 如何）。因此，我们的第一步是将我们的\u0060*data\u0060转换为类型\u0060ETHHDR\u0060，如果成功，我们现在将能够了解组成以太网头数据类型的变量。这些包括源和目标 MAC 地址，但更重要的是剩余数据的内容是什么。再次，在大多数情况下，以太网头之后的\u0060*data\u0060内容通常是 IP 头，但我们将通过检查以太网帧的 TBD 变量来验证。\n\n一旦我们验证下一组数据是 IP 头，我们将需要将以太网头之后的数据转换为 IPHDR 类型。一旦我们这样做，我们将能够访问 IP 特定的数据，例如源 IP（\u0060saddr\u0060）或目标地址（\u0060daddr\u0060），再次重要的是 IP 头包含一个变量，详细说明了 IP 头之后的数据是什么。这通常是 TCP 头或 UDP 头，但还有其他选择，例如 sctp 等。\n\n一旦我们查看了 IP 头的内部并确定数据类型是 TCP（也可能是 UDP 或其他内容），我们将把以太网头和 IP 头之后的数据都转换为 TCP 头类型！（几乎完成了）。通过访问 TCP 头的内容，我们可以获得 TCP 特定的数据，例如源端口或目标端口，用于验证数据的有效性的校验和以及其他有用的变量。\n\n现在我们几乎拥有一切，但是 TCP 头的长度可能是可变的，因此我们需要通过查看 tcl_len 变量来确定这一点，我们需要将其乘以 4。现在我们拥有了访问最终数据所需的一切！\n\n因此，\u0060*data\u0060指向数据的开头！我们已经确定了以太网头之后是 IP 头，最后是 TCP 头，这意味着\u0060*data \u002b 以太网头 \u002b IP 头 \u002b TCP 头 = 实际应用程序数据！\n\n### 我们可以用这些信息做什么？\n\n当我们解析各种标头时，实际上在 OSI 模型的不同层次上解锁了越来越多的信息！\n\n**[第 2 层]** 以太网头为我们提供了源和目标硬件地址，我们可以使用此信息来潜在地阻止从我们知道危险的源 MAC 地址处理的帧。\n\n**[第 3 层]** IP 头包含源和目标 IP 地址，再次，我们可以像防火墙一样运作，通过使用 eBPF 程序丢弃特定 IP 地址的所有流量。或者，我们可以根据 IP 地址重定向流量，或者甚至在这一层实施负载均衡逻辑，以将流量重定向到其他底层 IP 地址集合。\n\n**[第 4 层]** TCP 或 UDP 标头定义了目标端口号，我们可以使用这些信息来确定应用程序协议是什么（即端口 80 通常意味着剩余的*data 可能是 HTTP 数据）。在这一层，我们通常会执行负载均衡等操作，基于目标（即在多个其他负载均衡器地址之间平衡）。\n\n**[第 7 层]** 正如前面提到的，各种标头集合的末尾的数据是实际的应用程序数据，只要我们知道格式，我们也可以解析它。例如，如果外部 Web 浏览器尝试访问我的计算机上的\u0060\/index.html\u0060并附加了 eBPF 程序，我会解析到 TCP，然后确定它是端口 80，然后应用程序数据应该是 HTTP 格式。我可以通过查看应用程序数据的前三个字符（在所有标头之后）来验证这一点，使用以下伪代码：\n\n\u0060\u0060\u0060bash\nApplicationData = EthernetHDR \u002b IPHDR \u002b TCPHDR \/\/ 将所有标头长度相加以找到数据\nIf ( data[ApplicationData] = \u0022G\u0022 \u0026\u0026 data[ApplicationData\u002b1] = \u0022E\u0022 \u0026\u0026 data[ApplicationData\u002b2] = \u0022T\u0022 ) {\n\t\/\/ 这是一个HTTP GET请求\n\t\/\/ 做一些令人兴奋的事情\n}\n\u0060\u0060\u0060\n\n## 总结\n\n现在我们“有点”理解了这个逻辑，也许我们应该考虑实施一些代码来完成所有这些...但这将是另一天的事情。\n', '\/trans\/ebpf-adventures-in-networking\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/">使用 Geneve 隧道实现 Istio Ambient Mesh 的流量拦截</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/03/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Geneve 隧道实现 Istio Ambient Mesh 的流量拦截', '本文介绍了什么是 Geneve 隧道，与 VXLAN 的区别，以及它在 Istio Ambient Mesh 中的应用，最后谈及使用 eBPF 优化流量拦截。', '\n在我[之前的博客](\/blog\/ambient-mesh-l4-traffic-path\/)分享中提到 Istio Ambient Mesh 使用 iptables 和 Geneve 隧道将应用程序 Pod 中的流量拦截到 Ztunnel 中。很多读者可能还不了解这种隧道协议，本文将为你介绍 Geneve 隧道的定义，报文结构，以及与 VXLAN 协议的比较有哪些优势。最后，本文将介绍 Istio Ambient Mesh 如何应用 Geneve 隧道来实现流量拦截，以及 Istio 1.18 中新推出的 eBPF 模式。\n\n## Geneve 隧道简介\n\nGENEVE（Generic Network Virtualization Encapsulation）是一种网络虚拟化封装（隧道）协议，它的设计的初衷是为了解决当前数据传输缺乏灵活性和安全性的问题。Geneve 只定义了一种数据封装格式，不包括控制平面的信息。GENEVE 相较于 VXLAN 封装的关键优势在于其通过添加 TLV 格式的选项来扩展可封装的协议类型。\n\n## Geneve vs VXLAN\n\nVXLAN 和 Geneve 都是网络虚拟化协议，它们之间有很多共同点。虚拟化协议是一种将虚拟网络与物理网络分离的技术，它允许网络管理员在虚拟环境中创建多个虚拟网络，每个虚拟网络都可以拥有自己的 VLAN 标识符、IP 地址和路由。此外，VXLAN 和 Geneve 协议都使用 UDP 封装，这使得它们能够通过现有网络基础设施进行扩展。VXLAN 和 Geneve 协议还具有灵活性，它们可以在不同的网络拓扑结构中使用，并且可以与不同的虚拟化平台兼容。\n\n图 1 展示了 VXLAN 与 Geneve 协议的报文结构及其各自的 Header 区别。\n\n![图 1：VXLAN 与 Geneve 报文格式示意图](vxlan-vs-geneve.svg)\n\n从图中我们可以看到，VXLAN 与 Geneve 隧道报文的结构类似，其主要区别在于使用不同的 UDP 端口号和协议头 ——VXLAN 使用 4789 端口，Geneve 使用 6081 端口；Geneve 协议头比 VXLAN 更具扩展性。\n\nGeneve 隧道协议比 VXLAN 更加可扩展是因为 Geneve 隧道协议中增加了变长选项，它可以包含零或多个 TLV 格式的选项数据。TLV 是指类型 - 长度 - 值（Type-Length-Value）格式，用于传输和解析网络包的元数据信息。在 Geneve 协议中，每个元数据信息都由一个 TLV 格式的字段组成，以便于灵活地添加、删除和修改这些元数据。\n\n具体来说，TLV 格式的字段包括：\n\n- Type：8 位的类型字段。\n- Length：5 位的选项长度字段，以 4 字节倍数表示，不包括选项头。\n- Data：可变长的选项数据字段，可以不存在或者为 4 到 128 字节之间。\n\n通过使用 TLV 格式，Geneve 协议可以轻松地扩展和修改元数据信息，同时保持兼容性和灵活性。\n\n关于 VXLAN 隧道报文的详细信息请参考 [RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks](https:\/\/tools.ietf.org\/html\/rfc7348) 。\n\n关于 Geneve 隧道报文的详细信息请参考 [RFC 8926 Geneve: Generic Network Virtualization Encapsulation](https:\/\/www.rfc-editor.org\/rfc\/rfc8926#name-geneve-packet-format-over-i) 。\n\n### 工作原理\n\nGeneve 隧道主要应用在云计算和虚拟机化场景，它可以将数据包封装在一个新的数据包中，以便在虚拟网络中传输。Geneve 隧道使用一个 24 位的虚拟网络标识符 (VNI)，将数据包从一个物理网络传输到另一个物理网络。Geneve 隧道还可以使用安全性协议，如 IPsec、TL，来保护数据包的传输。\n\n当数据包到达目的主机时，Geneve 隧道协议会将数据包从 Geneve 协议头中解封装出来，并将其传递给虚拟网络中的目的地。在解封装过程中，Geneve 协议头中的 VNI 信息会被来判断数据包的目的地，以确保数据包被正确地路由到虚拟网络中的目的地。\n\n假设有一个虚拟网络，其 VNI 为 1001。当数据包从一个物理网络传输到另一个物理网络时，可以使用隧道将数据包从一个物理网络传输到另一个物理网络。在这种情况下，隧道将源物理网络和目标物理网络之间的虚拟网络标识符 (VNI) 设置为 1001，以便在传输期间跟踪数据包。当数据包到达目标物理网络时，隧道将 VNI 从数据包中删除，并将数据包传递给目标物理网络。\n\n### 安全性\n\nGeneve 隧道协议本身并没有提供任何安全机制，因此在 Geneve 隧道中传输的数据包可能会受到威胁，例如数据包被篡改、截获、重放等。\n\n为了保障 Geneve 隧道中传输的数据包的安全性，可以使用一些安全协议。以下是一些常见的安全协议：\n\n1. IPsec（Internet Protocol Security）：IPsec 是一种网络层安全协议，可以对 Geneve 隧道中的数据包进行加密、认证和完整性保护。使用 IPsec 可以提供端到端的安全性。\n2. TLS（Transport Layer Security）：TLS 是一种基于传输层的加密协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 TLS 可以提供端到端的安全性。\n3. MACSec（Media Access Control Security）：MACSec 是一种数据链路层的安全协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 MACSec 可以提供链路层的安全性。\n\n需要注意的是，以上安全协议都需要进行相应的配置和部署，且可能会对性能产生一定的影响。在选择合适的安全协议时，需要考虑安全性、性能、可管理性等方面的因素。\n\n### 为什么选择 Geneve？\n\n下表对比了 VXLAN 与 Geneve 在多个方面的特点。\n\n| 特性 | VXLAN | Geneve |\n| --- | --- | --- |\n| 头部格式 | 固定格式 | 可扩展格式 |\n| 可扩展性 | 更多地专注于 L2 扩展 | 更好地支持新兴网络服务 |\n| 可操作性 | 较难管理和扩展 | 更容易管理和扩展 |\n| 性能 | 头部较短，性能较高 | 头部较长，性能略低 |\n\n使用 Geneve 协议的主要原因是将目前网络虚拟化封装技术（例如 VXLAN、NVGRE 和 STT）中的优点合并到一个协议中。我们通过多年的网络虚拟化开发经验得知，其中一个重要的需求是可扩展性。Geneve 协议使用可扩展的 TLV 结构对元数据进行编码，因此可以独立地发展软件和硬件端点的功能，以满足不断增长的需求。\n\n## Istio Ambient Mesh 如何应用 Geneve 隧道\n\n在[之前的博客](https:\/\/jimmysong.io\/blog\/ambient-mesh-l4-traffic-path\/)中，我讲解了 Istio Ambient Mesh 如何使用 Ztunnel 实现 L4 代理的，图 2 展示使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径。\n\n![图 2：使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径示意图](geneve-tunnel.svg)\n\n从图中我们可以看到：\n\n- Istio CNI 在节点上创建 \u0060istioout\u0060 网卡和 iptables 规则，将节点中的出站流量透明劫持到 \u0060pistioout\u0060 虚拟网卡；\n- Istio CNI 在节点上创建 \u0060istioin\u0060 网卡和 iptables 规则，将节点中的入站流量透明劫持到 \u0060pistioin\u0060 虚拟网卡；\n- Istio CNI 在 ztunnel 中创建 \u0060pistioin\u0060 和 \u0060pistioout\u0060 网卡，用于接收 Geneve 隧道中的发来的数据包；\n\n\u0060pistioin\u0060 和 \u0060pistioout\u0060 这两个网卡是由 ztunnel 中的 init 容器或 Istio CNI（见 [\u0060CreateRulesWithinNodeProxyNS\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/ambient\/net_linux.go#L910) 函数）创建的，其 IP 地址和端口也是固定的。应用容器发出的数据包需要经过 \u0060istioout\u0060 网卡并使用 Geneve 隧道封装后转发给 ztunnel 容器。\n\n## 使用 eBPF 进行透明流量劫持\n\neBPF（extended Berkeley Packet Filter）是一个功能强大的技术，它可以在 Linux 内核中运行安全的用户态程序。eBPF 最初是一种用于过滤网络数据包的技术，但现在已经扩展到其他领域，如跟踪系统调用、性能分析和安全监控等。eBPF 的优势在于其轻量级、高效、安全和可编程性。它可以被用于实时监控、网络安全、应用程序调试和优化、容器网络等多个领域。\n\n在 Istio 1.18 之前，Ambient 模式中使用 iptables 和 Geneve 隧道将应用程序流量透明劫持到 ztunnel 中。在 Istio 1.18 中，增加了 eBPF 选项，你可以选择使用 iptables 或 eBPF 来做流量劫持。如图 3 所示，eBPF 程序直接运行在宿主机内核，将应用程序的流量转发到 ztunnel 中。\n\n![图 3：使用 eBPF 劫持应用程序的流量](ebpf.svg)\n\n图 3：使用 eBPF 劫持应用程序的流量\n\n| 对比项 | eBPF 方式 | 使用 iptables 和 Geneve 隧道 |\n| --- | --- | --- |\n| 效率 | 更高 | 略低 |\n| 兼容性 | 需要较高的 Linux 内核版本 | 更好 |\n| 实现难度 | 较高 | 较低 |\n| 扩展性 | 较好 | 较差 |\n\n根据 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2023\/ambient-ebpf-redirection\/)介绍，使用 eBPF 方式避免了部分 iptables 规则和隧道封装，相比使用 iptables 和 Geneve 隧道更加高效。然而，eBPF 对 Linux 内核版本的要求更高（至少 4.20），而 iptables 方式则具有更好的兼容性。此外，eBPF 方式的实现难度较高，但扩展性较好。\n\n要想使用 eBPF 模式运行 Ambient Mesh，只需要在安装 Istio 时设置 \u0060values.cni.ambient.redirectMode\u0060 参数即可，如下：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=ambient --set values.cni.ambient.redirectMode=\u0022ebpf\u0022\n\u0060\u0060\u0060\n\n## 总结\n\n本文介绍了 Geneve 隧道协议的工作原理、安全性和与 VXLAN 的比较。此外，还介绍了 Istio Ambient Mesh 如何使用 Geneve 隧道实现流量拦截，并讨论了使用 eBPF 进行透明流量劫持的优缺点。Geneve 隧道协议是一种通用的隧道协议，可以在虚拟网络中传输数据包，具有更多的优势，因此在选择隧道协议时，用户可以考虑使用 Geneve 隧道。在 Istio 1.18 中新推出了 Ambient Mesh 的的 eBPF 模式，可以提供网络效率，但对 Linux 内核版本有更高要求，用户可以根据自己的实际情况选用。\n\n## 参考\n\n- [RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks](https:\/\/tools.ietf.org\/html\/rfc7348)\n- [RFC 8926 Geneve: Generic Network Virtualization Encapsulation](https:\/\/www.rfc-editor.org\/rfc\/rfc8926#name-geneve-packet-format-over-i)\n- [Istio Ambient Mesh](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/architecture\/#istio-ambient-mesh)\n- [Open vSwitch Geneve(8) man page](https:\/\/www.mankier.com\/8\/ovs-vswitchd.conf.db(5))\n', '\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了什么是 Geneve 隧道，与 VXLAN 的区别，以及它在 Istio Ambient Mesh 中的应用，最后谈及使用 eBPF 优化流量拦截。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/beyond-istio-oss/">Beyond Istio OSS —— Istio 服务网格的现状与未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/07/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Beyond Istio OSS —— Istio 服务网格的现状与未来', '本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。', '\n{{\u003ccallout note 关于本文\u003e}}\n本文根据笔者在 GIAC 深圳 2022 年大会上的的演讲[《Beyond Istio OSS —— Istio 的现状及未来》](https:\/\/giac.msup.com.cn\/2022sz\/course?id=16093)整理而成，演讲幻灯片见 [腾讯文档](https:\/\/docs.qq.com\/pdf\/DRWxETHNDZmRsS0l5)。\n{{\u003c\/callout\u003e}}\n\n本文回顾了 Istio 开源近五年来的发展，并展望了 Istio 服务网格的未来方向。本文的主要观点如下：\n\n- 因为 Kubernetes、微服务、DevOps 及云原生架构的流行，导致服务网格技术的兴起；\n- Kubernetes 和可编程代理，为 Istio 的出现打下了坚实的基础；\n- 虽然 eBPF 可以加速 Istio 中的透明流量劫持，但无法取代服务网格中的 sidecar；\n- Istio 的未来在于构建基于混合云的零信任网络；\n\n## Istio 诞生的前夜{#the-dawn-of-istio}\n\n2013 年起，随着移动互联网的爆发，企业对应用迭代的效率要求更高，应用程序架构开始从单体转向微服务，DevOps 也开始变得流行。同年随着 Docker 的开源，解决了应用封装和隔离的问题，使得应用在编排系统中调度变得更容易。2014 年 Kubernetes、Spring Boot 开源，Spring 框架开发微服务应用开始流行，在接下来的几年间大批的 RPC 中间件开源项目出现，如 Google 在 2016 年发布 gRPC 1.0，蚂蚁在 2018 年开源 [SOFAStack](https:\/\/www.sofastack.tech\/) 等，微服务框架百花齐放。为了节约成本，增加开发效率，使应用更具弹性，越来越多的企业正在迁移上云，但这不仅仅是将应用搬到云上那么简单，为了更高效地利用云计算，一套「云原生」方法和理念也呼之欲出。\n\n## Istio 开源时间线{#istio-open-time-line}\n\nIstio 开源发展时间线如下图所示。\n\n![Istio 开源发展时间线示意图](istio-history.svg)\n\n下面我们来简单回顾下 Istio 开源大事件：\n\n- 2016 年 9 月：因为 Envoy 是 Istio 中的重要组成，Istio 的开源时间线应该有 Envoy 一部分。起初 Envoy 在 Lyft 内部仅作为边缘代理，开源前已在 Lyft 内部得到大规模生产验证并受到了 Google 工程师的注意 [^1]，那时候 Google 正打算推出一个服务网格的开源项目。2017 年，Lyft 将 Envoy 捐献给了 [CNCF](https:\/\/cncf.io)。\n- 2017 年 5 月：Istio 由 Google、IBM 和 Lyft 联合宣布开源 [^2]。一开始就使用了微服务架构，确定了数据平面和控制平面的组成以及 Sidecar 模式。\n- 2018 年 3 月：Kubernetes 顺利的成为从 CNCF 中第一个毕业的项目，变得越来越「无聊」，基础 API 已经定型，CNCF 正式将服务网格（Service Mesh）写入到了云原生的第二版定义 [^3] 中。笔者当前就职的公司 [Tetrate](https:\/\/tetrate.io)，也是在那时由 Google Istio 初创团队创业成立的。服务网格在中国开始爆发，ServiceMesher 社区也在蚂蚁集团的支持下成立，在中国布道服务网格技术。\n- 2018 年 7 月：Istio 1.0 发布，号称「生产可用」，Istio 团队重组。\n- 2020 年 3 月：Istio 1.5 发布，架构回归单体，发布周期确定，每三个月发布一个大版本，API 趋于稳定。\n- 2020 年至今：Istio 的发展主要着重于 Day 2 Operation [^4]、性能优化和扩展性发面，多个围绕 Istio 生态的开源项目开始出现，例如 [Slime](https:\/\/github.com\/slime-io\/slime\/)、[Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki)、[Merbridge](https:\/\/github.com\/merbridge\/merbridge)。\n\n## 为什么 Istio 会在 Kubernetes 之后出现？{#why-istio-born-after-kubernetes}\n\n微服务和容器化之后，异构语言使用的增加，服务的数量激增，容器的生命周期变短是导致服务网格出现的根本原因。\n\n我们先来看下服务从部署在 Kubernetes 到 Istio 中架构的变迁，然后再探讨架构演进过程中 Istio 的需求，下文假定读者已了解 [Kubernetes](\/book\/kubernetes-handbook\/architecture\/) 和 [Istio 的架构](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/architecture\/)。\n\n![Kubernetes 到 Istio 的架构改变示意图](kubernetes-to-istio.svg)\n\n从 Kubernetes 到 Istio，概括的讲应用的部署架构有如下特点：\n\n- Kubernetes 管理应用的生命周期，具体来说，就是应用的部署和管理（扩缩容、自动恢复、发布策略）；\n- 基于 Kubernetes 的自动 sidecar 注入，实现了透明流量拦截。先通过 sidecar 代理拦截到微服务间流量，再通过控制平面配置管理微服务的行为。如今服务网格的部署模式也迎来了新的挑战，sidecar 已经不是 Istio 服务网格所必须的，基于 gRPC 的无代理的服务网格 [^5] 也在测试中。\n\n- 服务网格将流量管理从 Kubernetes 中解耦，服务网格内部的流量无须 \u0060kube-proxy\u0060 组件的支持，通过类似于微服务应用层的抽象，管理服务间的流量，实现安全性和可观测性功能。\n- 控制平面通过 xDS 协议发放代理配置给数据平面，已实现 xDS 的代理有 [Envoy](https:\/\/envoyproxy.io) 和蚂蚁开源的 [MOSN](https:\/\/mosn.io)。\n\n- Kubernetes 集群外部的客户端访问集群内部服务时，原先是通过 Kubernetes [Ingress](\/book\/kubernetes-handbook\/service-discovery\/ingress\/)，在有了 Istio 之后，会通过 Gateway 来访问 [^6]。\n\n\u003e *Kubernetes 容器编排与可编程代理 Envoy 为 Istio 的出现打下了坚实的基础。*\n\n从上面 Kubernetes 到 Istio 的架构的转变的描述中，我们可以看到为了让开发者最小成本地管理服务间的流量，Istio 需要解决三个问题：\n\n1. **透明劫持应用间的流量**：Istio 开源最初的目标是成为网络基础设施，就像水和电人类的基础设施一样，我们使用水电不需要关心如何取水和发电，只需要打开水龙头，按下开关即可。透明流量劫持对于开发者来说，就像使用水和电，不需要修改应用程序就可以快速使用 Istio 带来的流量管理能力；\n1. **代理集群的运维**：如何为每个应用注入一个代理，同时高效地管理这些分布式的 sidecar 代理；\n1. **可编程代理**：代理可以通过 API 动态配置，还要有出色的性能与可扩展性；\n\n以上三个条件对于 Istio 服务网格来说缺一不可，而且，从中我们可以看到，这些要求基本都是对于 sidecar 代理的要求，这个代理的选择将直接影响该项目的走向与成败。为了解决以上三个问题，Istio 选择了 Kubernetes 容器编排和可编程代理 Envoy。\n\n### 透明流量劫持{#traffic-intercept}\n\n如果你使用的是如 gRPC 这类中间件开发微服务，在程序中集成 SDK 后，SDK 中的拦截器会自动为你拦截流量，如下图所示。\n\n![gRPC 的拦截器示意图](grpc.svg)\n\n如何让 Kubernetes  pod 中的流量都通过代理呢？答案是在每个应用程序 pod 中注入一个代理，与应用共享网络空间，再通过修改 pod 内的流量路径，让所有进出 pod 的流量都经过 sidecar，其架构如下图所示。\n\n![Istio 中的透明流量劫持示意图](istio-route-iptables.svg)\n\n从图中我们可以看到其中有一套非常复杂的 iptables 流量劫持逻辑（详见 [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](\/blog\/sidecar-injection-iptables-and-traffic-routing\/)），使用 iptables 的好处是适用于任何 Linux 操作系统。但是这也带来了一些副作用：\n\n1. Istio 网格中所有的服务都需要在进出 pod 时都增加了一个网络跳跃点（hop），虽然每次 hop 可能只有两三毫秒，但是随着网格中服务和服务间的依赖增加，这种延迟可能会显著增加，对于那种追求低延迟的服务可能就不适用于服务网格了；\n2. 因为 Istio 向数据平面中注入了大量的 sidecar，尤其是当服务数量增大时，控制平面需要下发更多的 Envoy 代理配置到数据平面，这样会使数据平面占用大量的系统内存和网络资源；\n\n针对这两个问题，如何优化服务网格呢？\n\n1. 使用 proxyless 模式：取消 sidecar 代理，重新回到 SDK；\n2. 优化数据平面：减少下发到数据平面的配置的频率和大小；\n3. eBPF：使用 eBPF 优化网络劫持；\n\n本文将在后面[性能优化](#performance-optimizing)一节讲解这些细节。\n\n### Sidecar 运维管理{#sidecar-management}\n\nIstio 是在 Kubernetes 的基础上构建的，它可以利用 Kubernetes 的容器编排和生命周期管理，在 Kubernetes 创建 pod 时，通过准入控制器自动向 pod 中注入 sidecar。\n\n为了解决 Sidecar 的资源消耗问题，有人为服务网格提出了有四种部署模式，如下图所示。\n\n![服务网格的四种部署模式示意图](deployment-model.svg)\n\n下表中详细对比了这四种部署方式，它们各有优劣，具体选择哪种根据实际情况而定。\n\n{{\u003ctable \u0022服务网格的四种部署模式对比\u0022\u003e}}\n| **模式**                           | **内存开销**                                                 | **安全性**                                                   | **故障域**                                                   | **运维**                                                  |\n| :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------------------------------------------------- |\n| **Sidecar 代理**                   | 因为为每个 pod 都注入一个代理，所以开销最大。                | 由于 sidecar 必须与工作负载一起部署，工作负载有可能绕过 sidecar。 | Pod 级别隔离，如果有代理出现故障，只影响到 Pod 中的工作负载。 | 可以单独升级某个工作负载的 sidecar 而不影响其他工作负载。 |\n| **节点共享代理**                   | 每个节点上只有一个代理，为该节点上的所有工作负载所共享，开销小。 | 对加密内容和私钥的管理存在安全隐患。                         | 节点级别隔离，如果共享代理升级时出现版本冲突、配置冲突或扩展不兼容等问题，则可能会影响该节点上的所有工作负载。 | 不需要考虑注入 Sidecar 的问题。                           |\n| **Service Account \/ 节点共享代理** | 服务账户 \/ 身份下的所有工作负载都使用共享代理，开销小。      | 工作负载和代理之间的连接的认证及安全性无法保障。             | 节点和服务账号之间级别隔离，故障同“节点共享代理”。          | 同“节点共享代理”。                                       |\n| **带有微代理的共享远程代理**       | 因为为每个 pod 都注入一个微代理，开销比较大。                | 微代理专门处理 mTLS，不负责 L7 路由，可以保障安全性。        | 当需要应用 7 层策略时，工作负载实例的流量会被重定向到 L7 代理上，若不需要，则可以直接绕过。该 L7 代理可以采用共享节点代理、每个服务账户代理，或者远程代理的方式运行。 | 同“Sidecar 代理”。                                       |\n\n{{\u003c\/table\u003e}}\n\n### 可编程代理{#programmable-proxy}\n\nFlomesh 的张晓辉曾在 [为什么需要可编程代理](https:\/\/cloudnative.to\/blog\/what-and-why-programmable-proxy\/) 博客中详细说明了代理软件的发展演化过程，我下面将引用他的一些观点，说明可编程代理 Envoy 在 Istio 中的关键作用。\n\n下图展示了代理从配置到可编程模式的演化过程，及每个阶段中的代表性代理软件。\n\n![代理软件的演化示意图](proxy-evolution.svg)\n\n整个代理演化过程都是随着应用从本地和单体，越来越走向大规模和分布式。下面我将简要概括代理软件的发展过程：\n\n- **配置文件时代**：几乎所有软件都有配置文件，代理软件因为其相对复杂的功能，更离不开配置文件。该阶段的代理主要使用 C 语言开发，包括其扩展模块，突出的代理本身的能力。这也是我们使用代理最原始最基础的形式，这些代理包括 Nginx、Apache HTTP Server、[Squid](http:\/\/www.squid-cache.org\/) 等；\n- **配置语言时代**：这个时代的代理，更具扩展性和灵活性，比如动态数据获取和配套的逻辑判断。代表性代理包括扩 [Varnish](https:\/\/varnish-cache.org\/) 和 HAProxy；\n- **脚本语言时代**：从脚本语言的引入开始，代理软件才真正走向的可编程，我们可以更方便的使用脚本在代理中增加动态逻辑，增加了开发效率。代表性的代理是 Nginx 及其支持的脚本语言；\n- **集群时代**：随着云计算的普及，大规模部署和动态配置 API 成了代理所必需的能力，而且随着网络流量的增加，大规模代理集群也应运而生。这个时代的代表性代理有 Envoy、Kong 等；\n- **云原生时代**：多租户、弹性、异构混合云、多集群、安全和可观测，这些都是云原生时代对代理所提出的更高要求，代表性软件有 Istio、Linkerd、[Pypi](https:\/\/flomesh.io\/)，它们都为代理构建了控制平面。\n\n## 这些都是服务网格吗？{#are-they-service-mesh}\n\n现在我将列举一些流行的服务网格开源项目，让我们一起探索服务网格的发展规律和本质。下表对比了当前流行的服务网格开源项目 [^7]。\n\n{{\u003ctable 服务网格开源项目对比表\u003e}}\n\n| 对比项     | Istio                                                    | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)             |\n| :--------- | :------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | ----------------------------------- |\n| 当前版本   | 1.14                                                     | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0                                 |\n| 许可证     | Apache License 2.0                                       | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                  |\n| 发起者     | Google、IBM、Lyft                                        | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                           |\n| 服务代理   | Envoy，支持 gRPC 的 proxyless 模式                       | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | 默认为 [Envoy](https:\/\/www.envoyproxy.io\/)，可替换           | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/) |\n| 入口控制器 | Envoy，自定义的 Ingress，支持 Kubernetes  Gateway API    | 无内置                                                      | Envoy，支持 Kubernetes Gateway API                           | 无内置                                                       | Kong                                | 支持 Contour、Nginx，兼容其他       |\n| 治理       | Istio Community 和 Open Usage Commons，已提议捐献给 CNCF | CNCF                                                        | 查看 [贡献指南](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | 查看 [贡献指南](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                |\n\n{{\u003c \/table \u003e}}\n\n上表中列出的都是服务网格，下面再简单评论一下这些项目：\n\n- [Istio](https:\/\/istio.io)：目前最流行的服务网格项目之一，在中国几乎成为了服务网格的代名词；\n- [Linkerd](https:\/\/linkerd.io)：最早出现的服务网格，「Service Mesh」概念提出者，第一个进入 CNCF 的服务网格项目，使用自研的 Rust 语言编写轻量级 sidecar 代理；\n- [Traefik Mesh](https:\/\/traefik.io\/traefik-mesh\/)：由 Traefik 推出的服务网格项目，使用 Treafik proxy 作为 sidecar，支持 SMI（接下来会提到），它的特点是对应用的无侵入性，不会在 pod 中注入 sidecar；\n- [Kuma](https:\/\/kuma.io\/)：由 Kong 推出的服务网格项目，使用 Envoy 作为 Sidecar 代理，特色是使用 Kong 自家的网关作为入口网关；\n- [Consul Connect](https:\/\/www.consul.io\/docs\/connect)：Consul 服务网格，使用 Envoy 作为 sidecar 代理；\n- [Open Service Mesh](https:\/\/openservicemesh.io\/)：由微软开源的服务网格，使用 Envoy 作为 sidecar，兼容 SMI（同样是微软提出）；\n\n另外还有几个项目，也服务网格领域也经常被提及，但它们都不是服务网格：\n\n- [Envoy](https:\/\/envoyproxy.io)：Envoy 本身只是代理，也经常被作为其他基于 Envoy 的服务网格的 sidecar，也经常被用来构建 API Gateway；\n- [Service Mesh Performance（SMP）](https:\/\/smp-spec.io\/)：标准化了服务网格值的指标，通过捕获基础设施容量、服务网格配置和工作负载元数据的细节来描述任何部署的性能；\n- [Service Mesh Interface（SMI）](https:\/\/smi-spec.io\/)：它不是服务网格，而只是一套服务网格实现标准，与 OAM、SPIFFE、CNI、CSI 等类似都是定义接口标准，具体实现就不一而足了。目前 Traefik Mesh 和 Open Service Mesh 声明支持该规范；\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/)：有必要提一下这个项目，因为经常有人把它错认为是一个服务网格。实际上，它面向的是三层网络，使用它可以在不更换 CNI 插件的前提下，连接多云\/混合云。它并不是我们所定义的「服务网格」，而是服务网格的一个有力补充（虽然名字里带有服务网格比较有迷惑性）。\n\n纵观以上项目，我们可以看出大部分服务网格项目的发起者都是根据代理起家，然后做控制平面。而且 Istio、Consul Connect、Open Service Mesh、Kuma 都是使用 Envoy 作为 sidecar 代理。只有 Linkerd 和 Traefik Mesh 推出了自己的代理。而所有的服务网格项目都支持 sidecar 模式。除了 Istio、Linkerd、Consul Connect 已应用于生产上，其他服务网格项目还没有看到被大规模在生产上使用。\n\n## Istio 的性能优化{#performance-optimizing}\n\n在 Istio 1.5 版本确定了稳定的架构之后，社区的主要精力在于优化 Istio 的性能。下面我将向你详细介绍 Istio 中的性能优化方法，包括：\n\n- 采用 Proxyless 模式；\n- 使用 eBPF 优化流量劫持；\n- 控制平面性能优化；\n- 数据平面性能优化；\n\n### Proxyless 模式{#proxyless-pattern}\n\nProxyless 模式是 Istio 在 1.11 版本中提出的实验特性 —— [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。使用该模式可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。下图展示了 sidecar 模式与 proxyless 模式的对比图。\n\n![Sidecar 模式 vs Proxyless 模式](sidecar-to-proxyless.svg)\n\n从上图中我们可以看到，虽然 proxyless 模式不使用 proxy 进行数据平面通信，但仍然需要一个 agent（即 \u0060pilot-agent\u0060）来进行初始化和与控制平面的通信。首先，agent 在启动时生成一个[引导文件](https:\/\/github.com\/grpc\/proposal\/blob\/master\/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file)，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 \u0060istiod\u0060，在哪里可以找到用于数据平面通信的证书，向控制平面发送什么元数据。接下来，agent 作为 xDS proxy，代表应用程序与 \u0060istiod\u0060 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书，这其实与 Sidecar 模式的流程是一样的，只是将 Envoy 代理的功能内置到 SDK 中了。\n\n\u003e *服务网格的本质不是 Sidecar 模式，也不是配置中心或透明流量拦截，而是标准化的服务间通信标准。*\n\n有人说 proxyless 模式又回到了基于 SDK 开发微服务的老路，服务网格的优势丧失殆尽，那还能叫做服务网格吗 [^9]？其实这也是一种对性能的妥协 —— 如果你主要使用 gRPC 来开发微服务的话，只需要维护不同语言的 gRPC 版本，即可以通过控制平面来管理微服务了。\n\n\u003e *Envoy xDS 已经成为服务网格中服务间通信的事实标准。*\n\n### 使用 eBPF 优化流量劫持{#ebpf}\n\n在[透明流量劫持](#traffic-intercept)一节，我们可以看到一个服务间的流量在到达目的地 pod 时经过的 iptables 规则和路径，其中需要经过多条 iptables 规则，如 \u0060PREROUTING\u0060、\u0060ISTIO_INBOUND\u0060、\u0060ISTIO_IN_REDIRECT\u0060、\u0060OUTPUT\u0060、\u0060ISTIO_OUTPUT\u0060、\u0060POSTROUTING\u0060 等。假设现在有一个服务 A 想要调用非本地主机上的另一个 pod 中的服务 B，经过的网络堆栈如下图所示。\n\n![非同主机 Pod 间的服务访问路径（iptables 模式）](iptables-process.svg)\n\n从图中我们可以看到整个调用流程中经过四次 iptables，其中 Pod A 中的从 Envoy 的出站（iptables2）和 Pod B 中的从 eth0 的入站（iptables3）的 iptables 路由是无法避免的，那么剩下的两个 iptables1 和 iptables4 是否可以优化呢？让两个 socket 直接通信，不就可以缩短网络路径了吗？这就需要通过 eBPF 编程，使得：\n\n- Service A 的流量从直接发送到 Envoy 的 Inbound socket 上；\n- Pod B 中 Envoy 接收到入站流量后，已经确定流量是要发送给本地的服务，直接对接 Outbound socket 与 Service B；\n\n使用 eBPF 模式的透明流量拦截网络路径如下图所示。\n\n![非同主机 Pod 间的服务访问路径（eBPF 模式）](ebpf-diff-node.svg)\n\n如果要访问的服务 A 和服务 B 在同一个节点上，那么网络路径将更短。\n\n![同主机 Pod 间的网络访问路径（eBPF 模式）](ebpf-same-node.svg)\n\n同一个节点中的服务间访问完全绕过了 TCP\/IP 堆栈，变成了 socket 间的直接访问。\n\n{{\u003ccallout note \u0022什么是 eBPF？\u0022\u003e}}\n\n我们知道修改 Linux 内核代码很难，新特性发布到内核中需要很长的周期。eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。也就是说，有了 eBPF，你不需要直接修改内核，就可以扩展和改变内核的行为。下面我将简要的为大家介绍一下 eBPF：\n\n- eBPF 程序加载到内核中后需要通过验证器的验证才可以运行，验证器可以防止 eBPF 程序超越权限的访问，这样可以确保内核的安全；\n- eBPF 程序是附着于内核事件上的，当有进入或退出内核函数时被触发；\n- 内核空间的 eBPF 程序必须使用能够支持生成 eBPF 字节码格式的编译器的语言编写，目前你可以用 C 和 Rust 语言编写 eBPF 程序；\n- eBPF 程序对于不同的 Linux 版本存在兼容性问题；\n\n由于 eBPF 程序可以直接监听和操作 Linux 内核，具有对系统最底层的透视，就可以在流量管理、可观测性和安全发挥作用。有关 eBPF 的详细介绍请参考笔者翻译的[《什么是 eBPF》](https:\/\/jimmysong.io\/book\/what-is-ebpf\/)电子书。\n\n{{\u003c\/callout\u003e}}\n\n开源项目 [Merbridge](https:\/\/github.com\/merbridge\/merbridge) 正是利用 eBPF 缩短了透明流量劫持的路径，优化了服务网格的性能。关于 Merbridge 实现的一些细节，请参考 [Istio 博客](https:\/\/istio.io\/latest\/zh\/blog\/2022\/merbridge\/)。\n\n{{\u003ccallout warning 注意\u003e}}\n\nMerbridge 使用的 eBPF 函数需要 Linux 内核版本 ≥ 5.7。\n\n{{\u003c\/callout\u003e}}\n\n乍看上去 eBPF 似乎从更底层实现了 Istio 的功能，更大有取代 sidecar 的趋势。但是 eBPF 也存在很多局限性，导致在可以预见的未来无法取代服务网格和 Sidecar。如果取消 sidecar 转而使用每个主机一个代理的模式，会导致：\n\n1. 代理失败的爆炸半径扩大到整个节点，即一个代理失败了，代理所在节点上的所有工作负载都会受到影响；\n2. 使得安全问题更加复杂，因为一个节点上保存在太多负载的证书，一旦被攻击，会存在秘钥泄露的风险；\n3. 主机上的 Pod 之间的流量争抢问题，即节点上如果有一个工作负载消耗掉代理的所有资源，其他工作负载将无法获得流量；\n\n而且 eBPF 主要负责三\/四层流量，可以与 CNI 一起运行，但是七层流量使用 eBPF 来处理就不太合适了。\n\n\u003e *在可以预见的未来 eBPF 技术无法取代服务网格和 Sidecar。*\n\n关于 eBPF 与服务网格的关系的更详细介绍请参考博客[请暂时抛弃使用 eBPF 取代服务网格和 Sidecar 模式的幻想](\/blog\/ebpf-sidecar-and-service-mesh\/)。\n\n### 控制平面性能优化{#control-plane-perf-optimizing}\n\n以上两种优化都是针对数据平面进行的，我们再来看下控制平面的性能优化。你可以把服务网格想象成是一场演出，控制平面是总导演，数据平面是所有演员，导演不参与演出，但是负责指挥演员。如果这场演出的情节很简单，时长又很短，那要每个演员分配的戏份就会很少，排练起来就会很容易；如果是一个大型演出，演员的数量多，情节有很复杂，要想排练好这场演出，一个导演可能是不够的，他指挥不了这么多演员，因此我们需要多名副导演（扩大控制平面实例数量）；我们还需要给演员准备好台词和脚本，如果演员也可以一个镜头完成一连串的台词和场景的表演（减少都数据平面的打扰，批量推送更新），那我们的排练是不是更加高效？\n\n从上面的类比中，你应该可以找到控制平面性能优化的方向了，那就是：\n\n- 减少需要推送的配置大小；\n- 批处理代理推送；\n- 扩大控制平面规模；\n\n#### 减少需要推送的配置{#reduce-config-size}\n\n控制平面性能优化最直接的方式就是减少要向数据平面推送的代理配置大小。假设有工作负载 A，如果仅将与 A 相关的代理配置（即 A 依赖的服务）推送给 A，而不是将网格内所有服务的配置都推送给 A，这样就可以大大压缩要推送的工作负载范围及配置大小。Istio 中的 Sidecar 资源可以帮助我们实现这一点。下面是 Sidecar 配置示例：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: cn-bj\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022cn-bj\/*\u0022\n\u0060\u0060\u0060\n\n我们通过 \u0060workloadSelector\u0060 字段可以限制该 Sidecar 配置适用的工作负载范围，而 \u0060egress\u0060 字段可以确定该工作负载依赖的服务范围，这样控制平面就可以仅向服务 A 推送其依赖的服务配置，大大减低要向数据平面推送的配置大小，减少了服务网格的内存和网络消耗。\n\n#### 批处理代理配置推送{#batch-push-conf}\n\n控制平面 Istiod 向数据平面推送代理配置的过程比较复杂，下图展示了其中的流程。\n\n![Istiod 向数据平面推送代理配置的流程图](istiod-push.svg)\n\n管理员配置 Istio 网格后，Istiod 中推送代理配置的流程是这样的：\n\n1. 管理员更新 Istio 配置的事件会触发数据平面代理的配置同步；\n2. Istio 的 \u0060DiscoveryServer\u0060 组件监听到这些事件后不会立即将配置推送到数据平面，而是将这些事件添加到队列中，持续合并一段时间内的事件，这个过程叫做去抖动（debouncing），就是为了防止频繁的更新数据平面配置；\n3. 在去抖动周期过后，这些事件将被推送到队列中；\n4. Istiod 会限制同时推送的请求数量，以加快推送进度；\n5. 事件被转换成 Envoy 的配置推送到数据平面的工作负载上；\n\n从以上流程中我们可以看出，优化配置推送的关键就是步骤 2 中去抖动周期和步骤 4 中的限流设置。有这样几个环境变量可以帮助你设置控制平面的推送：\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060：指定去抖动的时间，将事件添加到推送队列中，默认为 100 毫秒；\n- \u0060PILOT_DEBOUNCE_MAX\u0060：指定允许事件去抖动的最长时间，如果在这段时间内事件没有新的变化则推送事件，默认为 10 秒；\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060：指定端点更新是否符合去抖动规则或具有优先权并立即落入推送队列，默认是开启的，关闭它后可以加速 EDS 推送；\n- \u0060PILOT_PUSH_THROTTLE\u0060：指定同时处理的推送请求，默认是 100；\n\n关于这些环境变量的默认值和具体配置请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars)。\n\n这些值究竟如何设置，可以遵循以下原则：\n\n- 如果控制平面资源空闲，为了加快配置更新的传播速度，你可以：\n  - 缩短去抖动周期，增加推送次数；\n  - 增加同时处理的推送请求数量；\n- 如果控制平面饱和，为了降低性能瓶颈，你可以：\n  - 延迟去抖动周期，减少推送次数；\n  - 增加同时处理的推送请求的数量；\n\n至于如何设置最优解，需要结合你的可观测系统来调试。\n\n#### 扩大控制平面规模{#scale-up-control-plane}\n\n如果设置去抖动批处理和 Sidecar 还无法优化控制平面性能的话，最后的选择就是扩大控制平面的规模，包括扩大单个 Istiod 实例的资源和增加 Istiod 的实例个数，究竟采用哪种扩展方式视情况而定：\n\n- 当单个 Istiod 的资源占用饱和时，优先推荐你扩大 Istiod 的实例大小，这通常是因为服务网格中有太多的资源（Istio 的自定义资源，如 VirtualService、DestinationRule 等）需要处理；\n- 如果增加 Istiod 实例的 CPU 和内存依然不起效的话，增加 Istiod 的实例个数，这样可以分散单个实例要管理的工作负载数量；\n\n### 数据平面性能优化{#data-plane-performance}\n\nApache SkyWalking 可以作为 Istio 提供可观测性工具，还可以帮助我们在进行服务动态调试和故障排除剖析服务的性能，其最新推出的 [Apache SkyWalking Rover](https:\/\/github.com\/apache\/skywalking-rover) 组件可以利用 eBPF 技术来准确定位 Istio 的关键性能问题 [^12]。在数据平面，我们可以通过以下方式来增加 Envoy 的吞吐量以优化 Istio 的性能：\n\n- 禁用 Zipkin 追踪或减少采样率\n- 简化访问日志格式\n- 禁用 Envoy 的访问日志服务（ALS）\n\n以上优化方式对 Envoy 吞吐量的影响数据请参阅 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/#introducing-skywalking-rover)。\n\n## Envoy —— 服务网格的领衔主演{#starring-envoy}\n\n我们知道服务网格是由数据平面和控制平面组成的，从上面的服务网格开源项目列表中我们可以看到，服务网格开源项目大部分都是基于 Envoy，然后开发自己的控制平面。还记得我在本文前面将服务网格比作演出吗？在这场服务网格的演出中，毫无疑问 Envoy 就是领衔主演 —— Envoy 发明的 xDS 协议，基本成为服务网格的通用 API。下面展示的是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch.svg)\n\nxDS 是 Envoy 区别于其他代理的关键，它的代码和解析流程十分复杂 [^10]，直接扩展起来也很有难度。下面展示的是 Istio 组件拓扑图，从图中我们可以看到 Istio 数据平面的 Sidecar 容器中不止有 \u0060envoy\u0060 这一个进程，还有一个 \u0060pilot-agent\u0060 进程。\n\n{{\u003cfigure title=\u0022Istio 组件拓扑图\u0022 alt=\u0022Istio 组件拓扑图\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\n\u0060pilot-agent\u0060 进程的作用如下：\n- 作为 \u0060envoy\u0060 的父进程，负责 Envoy 的生命周期管理；\n-  接收来自控制平面的推送，配置代理和证书；\n- 收集 Envoy 统计信息，汇总 sidecar 的统计数据供 Prometheus 搜集；\n- 内置本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景；\n- 对 Envoy 和 DNS 代理进行健康检查；\n\n从以上功能中我们可以看出 \u0060pilot-agent\u0060 进程主要是用于与 Istiod 交互，为 Envoy 起到指挥和辅助的作用，Istio 的核心组件是 Envoy。那么 Envoy 会不会「演而优则导」，不再配合 Istio，构建一套自己的控制平面呢？\n\n\u003e *在 Sidecar 容器中，\u0060pilot-agent\u0060 就像是 Envoy 的“Sidecar”。*\n\n{{\u003ccallout note 请读者思考一下\u003e}}\n\u0060pilot-agent\u0060 的功能能否直接内置到 Envoy 中，从而取消 \u0060pilot-agent\u0060 呢？\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway 统一服务网格网关{#envoy-gateway}\n\n在 Kubernetes 中，除 Service 资源对象之外，最早用来暴露集群中服务的资源对象是 Ingress。使用 Ingress 你只需要为集群开放一个对外的访问点即可，通过 HTTP Hosts 和 \u0060path\u0060 来路由流量到具体的服务。相对于直接在 \u0060service\u0060 资源上暴露服务来说，可以减少集群的网络访问点（PEP）[^11] ，降低集群被网络攻击的风险。使用 Ingress 访问集群内的服务流程如下图所示。\n\n![Kubernetes Ingress 流量访问流程图](ingress.svg)\n\n在 Kubernetes 之前，API Gateway 软件就已经被广泛用作边缘路由了，在引用 Istio 时又增加了 Istio 自定义的 Gateway 资源，使得访问 Istio 服务网格中的资源又多了一种选择，如下图所示。\n\n![访问 Istio 网格中的服务的方式](access-cluster.svg)\n\n现在，要想暴露单个 Istio 网格中的服务，\u0060NodePort\u0060、\u0060LoadBalance\u0060、Istio 自定义 Gateway、Kubernetes Ingress 和 API Gateway 软件，如何选择？如果是多集群服务网格，客户端如何访问网格内的服务？我们的服务网格领衔主演 Envoy 已经在这方面做足了功夫，被以多种形式使用：\n\n- Sidecar Proxy：正如在[前文中](#are-they-service-mesh)提到的，Istio、Kuma、Consul Connect 都使用了 Envoy 作为 sidecar 代理；\n- Kubernetes Ingress Controller\/API Gateway：[Contour](https:\/\/github.com\/projectcontour\/contour)、[Emissary](https:\/\/github.com\/emissary-ingress\/emissary)、[Hango](https:\/\/github.com\/hango-io\/hango-gateway)、[Gloo](https:\/\/github.com\/solo-io\/gloo) 等；\n\n这些项目利用 Envoy 来实现服务网格和 API 网关，其中有很多功能重叠，同时又有很多专有功能，或者缺乏社区多样性，这种现状由于 Envoy 社区没有提供控制平面实现而导致的。为了改变现状，Envoy 社区发起了 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目，该项目旨在结合现有的基于 Envoy 的 API Gateway 相关项目的经验 [^13]，利用带有一些 Envoy 特定扩展的  [Kubernetes Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 降低 Envoy 用户使用网关的门槛。因为 Envoy Gateway 仍然通过 xDS 下发配置给 Envoy 代理，因此你还可以用它来管理支持 xDS 的网关，如 Istio Gateway。\n\n我们现在所见的网关基本都是在单集群中作为入口网关，对于多集群和多网格就无能为力了。为了应对多集群，我们需要在 Istio 之上再添加一层网关，和一个全局的控制平面以在多集群间路由流量，如下图所示。\n\n![多集群多网格的两级网关示意图](t2-gateway.svg)\n\n{{\u003ccallout note 关于两级网关的简要介绍\u003e}}\n- 一级网关（下文简称 T1）位于应用边缘，用于多集群环境。同一应用会同时托管在不同的集群上，T1 网关将对该应用的请求流量在这些集群之间路由。\n- 二级网关（下文简称 T2）位于一个的集群边缘，用于将流量路由到该集群内由服务网格管理的服务。\n{{\u003c\/callout\u003e}}\n\n通过在 Istio 控制平面以外增加一层全局控制平面和 API，来实现多集群服务网格管理。将 T1 网关部署为集群，可以防止单点故障。想要了解关于两级网关的更多内容，请参考[通过两级网关设计来路由服务网格流量](https:\/\/cloudnative.to\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/)。\n\nT1 网关的配置如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\n该配置将 \u0060servicea.example.com\u0060 通过 T1 网关暴露到网格外，并将网格外访问该服务的流量的 \u006075%\u0060 转发到 \u0060cluster1\u0060，\u006025%\u0060 的流量转发到 \u0060cluster2\u0060，另外为了应对多集群中的流量、服务和安全配置，Tetrate 旗舰产品 Tetrate Service Bridge 中还增加了 一系列 Group API，详见 TSB 文档。\n\n## Istio 开源生态{#ecosystem}\n\nIstio 开源在至今已经五年多了，近两年来出现了很多基于 Istio 的开源项目，其中比较代表性的有：\n\n- 网易开源的 Slime\n- 腾讯开源的 Aeraki\n- Istio 官方对 Wasm 插件的支持\n\n它们的出现使得 Istio 更加智能化并扩展了 Istio 的适用范围。\n\n### Slime\n\n[Slime](https:\/\/github.com\/slime-io\/slime\/) 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。\n\n我们在前文的[控制平面性能优化](#control-plane-perf-optimizing)中提到了通过「减少需要推送的配置」的方式来优化 Istio 的性能，但是 Istio 无法做到自动识别无法依赖以最优化需要推送到每个 sidecar 的代理配置，Slime 提供了 \u0060lazyload\u0060 控制器，可以帮助我们实现配置懒加载，用户无须手动配置 \u0060SidecarScope\u0060 [^15]，Istio 可以按需加载服务配置和服务发现信息。\n\n下图展示的是 Slime 作为 Istio 的管理平面更新数据平面配置的流程图。\n\n![使用 Slime 更新 Istio 数据平面配置的流程图](slime-process.svg)\n\n其中，Global Proxy 使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。\n\n数据平面配置更新的具体步骤如下：\n\n1. Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化，开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；\n2. Slime 持续监听 Slime CRD 的创建；\n3. Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；\n4. Istio 监听 Istio CRD 的创建；\n5. Istio 将代理的配置信息推送到数据平面相应的 Sidecar Proxy 中；\n\n因为数据平面中的所有服务的首次调用都通过 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；当某个服务的调用链被 VirtualService 中的路由信息重新定义时，Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 \u0060ServiceFence\u0060 的 CRD 来维护服务调用关系以解决服务信息缺失问题，详见 [Slime 简介](\/blog\/slime-intro\/)。\n\n### Aeraki\n\n[Aeraki Mesh](https:\/\/github.com\/aeraki-mesh\/aeraki) 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目，基于 Istio 扩展其对七层协议的支持，专注于解决 Istio 中的**非 HTTP 协议**的服务治理，已于 2022 年 6 月进入 CNCF Sandbox。\n\n下图展示了 Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图。\n\n![Aeraki 将非 HTTP 协议纳入到 Istio 网格中的流程图](aeraki-arch.svg)\n\n 其详细流程如下：\n\n1. Aeraki 的 X2Istio 组件对接服务注册中心，获取非 HTTP 服务的注册信息，并生成 ServiceEntry 向 Istio 中注册；\n2. Aeraki 作为 Istio 之上的管理平面，它从 Istio 中获取 ServiceEntry 配置；\n3. Aeraki 通过端口命名规判断服务的协议类型（如 \u0060tcp-metaprotocol-dubbo\u0060），然后生成 MetaProtocol Proxy Filter（兼容 EnvoyFilter）配置，同时修改 RDS 地址，将其指向 Aeraki；\n4. Istio 使用 xDS 协议将配置（LDS、CDS、EDS 等）下发给数据平面；\n5. Aeraki 根据服务注册表中的信息和用户设置生成路由规则，通过 RDS 发送给数据平面；\n\n在 Istio 中接入非 HTTP 服务的整个流程中的关键是 **MetaProtocol Proxy** 。Istio 默认支持 HTTP\/HTTP2、TCP 和 gRPC 协议，实验性支持 Mongo、MySQL 和 Redis 协议 [^14]。若要使用 Istio 路由其他协议的流量，不仅需要修改 Istio 控制平面并扩展 Envoy，这将带来巨大的工作量，而且不同协议共享通用的控制逻辑，这还会带来很多重复性工作。MetaProtocol Proxy 是在 Envoy 代码基础上的扩展，为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地\/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度。\n\n下图展示的 MetaProtocol Proxy 的架构图。\n\n![MetaProtocol Proxy 架构图](metaprotocol-proxy.svg)\n\n当我们想扩展 Istio 使其支持 Kafka、Dubbo、Thrift 等其他七层协议时，只需要实现上图中的编解码的接口（Decode 和 Encode），就可以基于 MetaProtocol 快速开发一个第三方协议插件。MetaProtocol Proxy 是在 Envoy 基础上的扩展，因此你仍然可以使用多种语言为其开发过滤器，并使用 \u0060EnvoyFilter\u0060 资源将配置下发到数据平面。\n\n### WasmPlugin API\n\n[WasmPlugin](https:\/\/istio.io\/latest\/docs\/reference\/config\/proxy_extensions\/wasm-plugin\/) 是 Istio 1.12 版本引入的 API，作为代理扩展机制，我们可以使用它将自定义和第三方的 Wasm 模块添加到数据平面中。下图中展示了如何在 Istio 中使用 WasmPlugin。\n\n![在 Istio 中使用 WasmPlugin 的流程图](wasmplugin.svg)\n\n具体步骤如下：\n\n1. 用户使用 [Proxy-Wasm SDK](https:\/\/github.com\/proxy-wasm)（目前有 AssemblyScript、C\u002b\u002b、Rust、Zig 和 Go 语言版本）来开发扩展，并构建成 OCI 镜像（如 Docker 镜像）上传到镜像仓库；\n2. 用户编写 \u0060WasmPlugin\u0060 配置并应用到 Istio；\n3. Istio 控制平面根据 \u0060WasmPlugin\u0060 配置中的工作负载选择配置，将 Wasm 模块注入到指定的 Pod 中；\n4. Sidecar 中的 \u0060pilot-agent\u0060 [^16] 从远程或本地文件中获取 Wasm 模块并将其加载到 Envoy 中运行；\n\n## 谁应该使用 Istio？{#whos-should-use-istio}\n\n好了，说了这么说，这跟你有什么关系呢？Istio 跟你的关系取决于你的角色：\n\n- 如果你是平台负责人，应用服务网格后，可能增强你的平台可观测性，具有了一个统一的平台来管理微服务，你将是直接受益者，也应该是服务网格的主要实施者；\n- 如果是应用程序开发者，也会从服务网格中收益，因为你可以更加专属于业务逻辑，而不用担心重试策略、TLS 等其他非功能性问题；\n\n下图展示了服务网格的采用路径。\n\n![服务网格的采用路径](adopt.svg)\n\n是否采用服务网格取决于你公司的技术发展阶段，应用是否实现容器化和微服务，对多语言的需求，是否需要 mTLS 以及对性能损耗的接纳度等。\n\n## 服务网格在云原生技术栈中的定位{#service-mesh-positioning}\n\n技术的发展日新月异，近两年来有一些新技术出现，似乎挑战了服务网格的地位，更有人声称可以直接取代现有经典的 sidecar 模式的服务网格 [^8]，我们不要被外界嘈杂的声音所迷惑，认清服务网格在云原生技术栈中的定位。\n\n\u003e *一味地推广某项技术而忽略它的适用场景，就是耍流氓。*\n\n下图展示的是云原生技术堆栈。\n\n![云原生技术堆栈示意图](cloud-native-stack.svg)\n\n我们可以看到，在云原生技术堆栈图中的「云基础设施」、「中间件」和「应用」层都列举了一些标志性的开源项目，这些项目构建了它们所在领域的标准：\n\n- 在云基础设施领域，Kubernetes 统一了容器编排和应用生命周期管理的标准，Operator 模式奠定了扩展 Kubernetes API 及第三方应用接入的标准；\n- 在中间件领域，服务网格承担起了云原生技术栈中的七层网络、可观测性和安全等多个方面的部分或全部责任，它运行在应用程序下层，对于应用程序来说几乎是无感知的；Dapr（分布式应用程序运行时）定义云原生中间件的能力模型，开发者可以在应用中集成 Dapr 的多语言 SDK，面向 Dapr 提供的分布式能力编程，而不用关心应用所运行的环境及对接的后端基础设施。因为在和应用程序运行在同一个 Pod 中的 Dapr 运行时（Sidecar 模式部署，其中包含各种构建块）自动帮我们对接了后端组件（Component）；\n- 在应用程序领域：OAM 旨在建立一个应用模型标准，通过组件、特征、策略和工作流来一个应用程序；\n\n下图展示了 Istio 在云原生部署中定位于七层网格管理。\n\n![Istio 在云原生架构中定位在七层网络](istio-role.svg)\n\n{{\u003ccallout note \u0022Dapr 与 Istio 是什么关系？\u0022\u003e}}\n\n在云原生技术栈中，Istio 和 Dapr 同时位于中间件层，它们之间有很多区别和联系。\n\nIstio 和 Dapr 之间的相同点：\n\n- Istio 和 Dapr 都可以使用 Sidecar 模式的部署模型；\n- 同属于中间件，同样可以管理服务间通信；\n\nIstio 和 Dapr 之间的不同点：\n- 目标不同：Istio 的目标是构建零信任网络，定义服务间通信标准，Dapr 目标是构建标准的中间件能力的 API；\n- 架构不同：Istio = Envoy \u002b 透明流量劫持 \u002b 控制平面，Dapr = 多语言 SDK \u002b 标准化 API \u002b 分布式能力组件；\n- 面向的人群不同：但是应用 Istio 对于开发者来说几乎无感知，主要需要基础设施运维团队实施，而应用 Dapr 需要开发者自主选择集成 Dapr SDK；\n\n{{\u003c\/callout\u003e}}\n\n## 服务网格的未来{#istio-future}\n\n我在前文中介绍了 Istio 的发展脉络及开源生态，接下来我将为大家介绍 Istio 服务网格的未来趋势：\n\n- 构建零信任网络\n- 成为混合云管理平台的网络基础设施\n\n\u003e *服务网格的未来在于成为零信任网络和混合云的基础设施。*\n\n这也是笔者所在的公司企业级服务网格提供商 [Tetrate](https:\/\/www.tetrate.io\/) 的努力方向，我们致力于构建一个基于零信任的适用于任意环境、任意负载的应用感知网络。下面展示的是 Tetrate 旗舰产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 的架构图。\n\n![TSB 架构图](tsb.svg)\n\nTetrate 公司是由 Istio 项目的发起人创立的，TSB 是基于开源的 Istio、Envoy 和 Apache SkyWalking 开发的。我们同时积极得贡献上游社区，并参与了旨在简化将 Envoy 网关使用的 [Envoy Gateway](https:\/\/github.com\/envoyproxy\/gateway) 项目的创建（上图中的 XCP 即使用 Envoy 构建的网关）。\n\n## 零信任{#zero-trust}\n\n零信任（Zero Trust）是 IstioCon 2022 里的一个重要话题，Istio 正在成为零信任网络的一个重要组成部分。\n\n{{\u003ccallout note \u0022什么是零信任？\u0022\u003e}}\n零信任（Zero Trust）是一种安全理念，而不是一种所有安全团队都要遵循的最佳实践。零信任概念的提出是为了给云原生世界带来更安全的网络。零信任是一种理论状态，即网络内的所有消费者不仅没有任何权限，而且也不具备对周围网络的感知。零信任的主要挑战是就越来越细化的授权和和对用户授权的时间限制。关于更多零信任的介绍，请阅读[这篇博客](\/blog\/what-is-zero-trust\/)。\n{{\u003c\/callout\u003e}}\n\n### 身份认证{#authn}\n\n零信任网络中最重要的是**面向身份的控制**而不是面向网络的控制。Istio 1.14 中增加了对 SPIRE 的支持，SPIRE（SPIFFE Runtime Environment，CNCF 孵化项目）是 SPIFFE（Secure Production Identity Framework For Everyone，CNCF 孵化项目）的一个实现。在 Kubernetes 中我们使用 [ServiceAccount](\/book\/kubernetes-handbook\/auth\/serviceaccount\/) 为 Pod 中的工作负载提供身份信息，其核心是基于 Token（使用 Secret 资源存储）来表示负载身份。而 Token 是 Kubernetes 集群中的资源，对于多集群及运行在非 Kubernetes 环境（例如虚拟机）中的负载，如何统一它们的身份？这就是 SPIFFE 要解决的问题。\n\nSPIFFE 的目的是基于零信任的理念，建立一个开放、统一的工作负载身份标准，这有助于建立一个零信任的全面身份化的数据中心网络。SPIFFE 的核心是通过简单 API 定义了一个生命周期短暂的加密身份文件—— SVID（SPFFE Verifiable Identity Document），用作工作负载认证时使用的身份文件（基于 X.509 证书或 JWT 令牌）。SPIRE 可以根据管理员定义的策略自动轮换 SVID 证书和秘钥，动态地提供工作负载标识，同时 Istio 可以通过 SPIRE 动态的消费这些工作负载标识。\n\n基于 Kubernetes 的 SPIRE 架构图如下所示。\n\n![SPIRE 部署在 Kubernetes 中的架构图](spire-with-kubernetes.svg)\n\nIstio 中原先是使用 Istiod 中 Citadel 服务 [^17] 负责服务网格中证书管理，通过 xDS（准确的说是 SDS API）协议将证书下发给数据平面。有了 SPIRE 之后，证书管理的工作就交给了 SPIRE Server。SPIRE 同样支持 Envoy SDS API，我们在 Istio 中启用 SPIRE 之后，进入工作负载 Pod 中的流量在被透明拦截到 Sidecar 中后，会经过一次身份认证。身份认证的目的是对比该工作负载的身份，与它所运行的环境信息（所在的节点、Pod 的 ServiceAccount 和 Namespace 等）是否一致，以防止伪造身份。请参考[如何在 Istio 中集成 SPIRE](\/blog\/how-to-integrate-spire-with-istio\/) 以了解如何在 Istio 中使用 SPIRE 做身份认证。\n\n我们可以使用 [Kubernetes Workload Registrar](https:\/\/github.com\/spiffe\/spire\/blob\/main\/support\/k8s\/k8s-workload-registrar\/README.md) 在 Kubernetes 中部署 SPIRE，它会为我们自动注册 Kubernetes 中的工作负载并生成 SVID。该注册机是 Server-Agent 架构，它在每个 Node 上部署一个 SPIRE Agent，Agent 与工作负载通过共享的 UNIX Domain Socket 通信。零信任网络中每个流量会话都需要经过身份认证，Istio 在透明流量劫持时，Sidecar 同时对流量请求进行身份认证。下图展示了在 Istio 中使用 SPIRE 进行身份认证的过程。\n\n![Istio 中基于 SPIRE 的工作负载身份认证过程示意图](workload-attestation.svg)\n\nIstio 中使用 SPIRE 进行工作负载认证的步骤如下：\n\n1. 工作负载的 sidecar 中的 \u0060pilot-agent\u0060 通过共享的 UDS 调用 SPIRE Agent 来获取 SVID 并缓存在 SPIRE Agent 中用于后续身份认证；\n2. SPIRE Agent 询问 Kubernetes（准确的说是节点上的 kubelet）获取工作负载的信息，如所在的 namespace、节点名称、服务账号等；\n3. Kubelet 把从 API 服务器中查询到的信息返回给工作负载验证器；\n4. 验证器将 kubelet 返回的结果与 SPIRE 查询得到的身份信息比对，如果相同，则将正确的 SVID 缓存返回给工作负载，如果不同则认证失败，拒绝流量请求；\n\n关于工作负载的注册和认证的详细过程请参考 [SPIRE 文档](\/book\/kubernetes-handbook\/auth\/spire\/) 。\n\n### NGAC\n\n当每个工作负载都有准确的身份之后，如何对这些身份的权限进行限制？Kubernetes 中默认使用 RBAC 来做访问控制，正如其名，这种访问控制是基于角色的，虽然使用起来比较简单，但是对于大规模集群，存在角色爆炸问题 —— 即存在太多角色，而且角色的类型不是一成不变的，难以对角色权限机型跟踪和审计。另外 RBAC 中的角色的访问权限是固定，没有规定短暂的使用权限，也没有考虑位置、时间或设备等属性。使用 RBAC 的企业很难满足复杂的访问控制要求，以满足其他组织需求的监管要求。\n\nNGAC，即下一代访问控制，采用将访问决定数据建模为 DAG（有向无环图）的方法。NGAC 可以实现系统化、策略一致的访问控制方法，以高精细度授予或拒绝用户管理能力。NGAC 由 [NIST](https:\/\/www.nist.gov\/) （美国国家标准与技术研究所）开发，目前已用于 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 中的权限管理。关于为什么选择 NGAC，而不是 ABAC 和 RBAC 的更多内容请参考博客[为什么应该选择使用 NGAC 作为权限控制模型](\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/)。\n\n## 混合云{#hybrid-cloud}\n\n在实际应用中，我们可能出于负载均衡、隔离开发和生产环境、解耦数据处理和数据存储、跨云备份和灾难恢复以及避免厂商锁定等原因，在多种环境下部署多个 Kubernetes 集群。Kubernetes 社区提供了「集群联邦」功能可以帮助我们创建多集群架构，例如下图所示的一种常用的 Kubernetes 多集群架构，其中 Host Cluster 作为控制平面，有两个成员集群，分别是 West 和 East。\n\n![Kubernetes 集群联邦架构](multicluster.svg)\n\n集群联邦要求 Host 集群与成员集群的之间的网络能够互通，对成员集群之间的网络连接性没有要求。Host 集群作为 API 入口，外界所有对 Host 集群的资源请求会转发到成员集群中。Host 集群中部署有集群联邦的控制平面，其中的「Push Reconciler」会将联邦中的身份、角色及角色绑定传播到所有的成员集群中。集群联邦只是简单地将多个集群简单的「连接到了一起」，在多个集群之间复制工作负载，而成员集群之间的流量无法调度，也无法实现真正的多租户。\n\n集群联邦不足以实现混合云，为了实现真正意义上的混合云，就要让集群之间做到互联互通，同时实现多租户。TSB 在 Istio 之上构建一个多集群管理的通用控制平面，然后再增加一个管理平面来管理多集群，提供多租户、管理配置、可观测性等功能。下面是 Istio 管理平面的多租户和 API 示意图。\n\n![TSB 在 Istio 之上构建的管理平面示意图](tsb-management-plane.svg)\n\nTSB 为管理混合云，基于 Istio 构建了一个管理平面，新建了 Tenant 和 Workspace 的资源，并通过选择器，将网关组、流量组和安全组应用到对应集群中的工作负载上。关于 TSB 的详细架构请参考 TSB 文档。\n\n## 更多{#more}\n\n如果你想了解更多关于 Istio 和云原生的内容，下面有一些资料分享给你：\n\n- 为了帮助大家更好的了解 Istio 和云原生，笔者在 2020 年发起了[云原生社区](https:\/\/cloudnative.to)，欢迎大家加入我们一起探索后 Kubernetes 时代的云原生新范式；\n- 2022 年 6 月，云原生社区著的[《深入理解 Istio —— 云原生服务网格进阶实战》](\/blog\/istio-service-mesh-book\/)已图书由电子工业出版社出版，欢迎大家购买；\n- 笔者于 2022 年 5 月，将之前所作电子书、教程和译文全部迁移到了[云原生资料库](\/book\/)欢迎阅读和留言评论。\n\n## 参考\n\n[^1]: 有关 Envoy 开源的详细过程，推荐你阅读 Envoy 作者 Matt Klein 的这篇文章[网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训](https:\/\/cloudnative.to\/blog\/envoy-oss-5-year\/)。\n\n[^2]: 后来 IBM 与 Google 反目，大举抨击 Google 没有遵守将 Istio 捐献给 CNCF 的约定，Google 对 Istio 商标的管理也受到了[质疑](https:\/\/thenewstack.io\/googles-management-of-the-istio-service-mesh-raises-questions-in-the-cloud-native-community\/)。\n[^3]: 2018 年，CNCF 为云原生的重新定义是：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n[^4]: Day-2 Operation 是在系统的生命周期结束前，对系统不断改进的过程，以实现效益最大化。参考 [什么是 Day-2 Operation](https:\/\/jimmysong.io\/blog\/what-is-day-2-operation\/)。\n[^5]: Istio 现已推出 proxyless 模式测试版，详见 [基于 gRPC 和 Istio 的无 sidecar 代理的服务网格](https:\/\/cloudnative.to\/blog\/grpc-proxyless-service-mesh\/)。\n[^6]: Kubernetes 预计推出 [Gateway API](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)，Istio 也有计划使用 Kubernetes 的 Gateway API 替换当前 Istio 自定义的 Gateway 资源。\n[^7]: 有关服务网格项目的详细对比请参考 [servicemesh.es](https:\/\/servicemesh.es\/) 网站。\n[^8]: 《[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/)》这篇文章在云原生社区里引起了一系列关于服务网格将被 eBPF 技术所取代的讨论。[请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想](https:\/\/jimmysong.io\/blog\/epbf-sidecar-and-service-mesh\/)，不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。\n[^9]: 在百度的服务网格团队分享的 [殊途同归，Proxyless Service Mesh 在百度的实践与思考](https:\/\/mp.weixin.qq.com\/s\/G8vmlJyaimux_K-548kFbA) 这篇文章里，详细介绍了百度的服务网格采用路径，以及对服务网格本质的探索。\n[^10]: 关于 xDS 协议，请参考 [Envoy 中的 xDS REST 和 gRPC 协议详解](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/) 这篇文章。\n[^11]: [PEP](https:\/\/www.oreilly.com\/library\/view\/network-access-control\/9780470398678\/9780470398678_policy_enforcement_point.html)，全称 Policy Enforcement Point，策略执行点（PEP）是控制用户访问并确保策略决策点 (PDP) 做出授权决策的网络或安全设备。在一些 NAC 实现中，PDP 是有线交换机或无线接入点。在其他情况下，PEP 是防火墙、IPS、服务器或内联设备。根据实施情况，PEP 和 PDP 可以是独立设备，也可以合并为单个设备。\n[^12]: Apache SkyWalking 的 Rover 组件利用 eBPF 技术改进了 SkyWalking 的剖析功能，可用于分析服务网格的性能问题，请参考 [使用 eBPF 准确定位服务网格的关键性能问题](https:\/\/cloudnative.to\/blog\/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf\/)。\n[^13]: 有多家公司正在合作开发 Envoy Gateway，包括 [Ambassador Labs](https:\/\/www.getambassador.io\/)、[Fidelity Investments](https:\/\/www.fidelity.com\/)、[Project Contour](https:\/\/projectcontour.io\/) 和 [VMware](https:\/\/www.vmware.com\/)。\n[^14]: Istio 仅可以路由 TCP 流量，默认支持 HTTP、HTTPS、gRPC 和原始 TCP 协议，其中 Sidecar 和 Gateway 所支持的协议范围有所不同，详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/protocol-selection\/)。\n[^15]: SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 Sidecar 资源中的 \u0060egress\u0060 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。\n[^16]: \u0060pilot-agent\u0060 是 sidecar 容器中的主进程，你可以在 [Istio 的组成架构图](#istio-components)中看到。\u0060pilot-agent\u0060 中的镜像提取机制（在 Istio 1.9 中引入），从远程 HTTP 源可靠地检索 Wasm 二进制文件，已被扩展到支持从任何 OCI 注册处检索 Wasm OCI 镜像，包括 Docker Hub、Google Container Registry（GCR）、Amazon Elastic Container Registry（Amazon ECR）和其他地方。\n[^17]: Istio 具有身份和证书管理功能，可以实现服务间的终端用户认证，在控制平面还采用微服务架构的时候，其中的 Citadel 组件负责证书管理，在 Istio 1.5 版本被合并到单体 Istiod 中了。\n', '\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文从云原生大背景下重新审视 Istio，讲解 Istio 诞生，在云原生技术栈中的地位及发展方向。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ebpf-sidecar-and-service-mesh/">请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('请暂时抛弃使用 eBPF 取代服务网格和 sidecar 模式的幻想', '不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。', '\n最近 eBPF 技术在云原生社区中持续火热，在我翻译了《[什么是 eBPF](https:\/\/jimmysong.io\/book\/what-is-ebpf\/)》之后，当阅读“云原生环境中的 eBPF”之后就一直在思考 eBPF 在云原生环境中究竟处于什么地位，发挥什么样的作用。当时我评论说“eBPF 开启了上帝视角，可以看到主机上所有的活动，而 sidecar 只能观测到 pod 内的活动，只要搞好进程隔离，基于 eBPF 的 proxy per-node 才是最佳选择”，再看到 William Morgan 的[这篇文章](https:\/\/buoyant.io\/2022\/06\/07\/ebpf-sidecars-and-the-future-of-the-service-mesh\/) [^1]之后，让我恍然大悟。下面节选翻译了文章我比统同意的观点，即 eBPF 无法替代服务网格和 sidecar，感兴趣的读者可以阅读 William 的原文。\n\n## 什么是 eBPF\n\n在过去，如果你想让应用程序处理网络数据包，那是不可能的。因为应用程序运行在 Linux 用户空间，它是不能直接访问主机的网络缓冲区。缓冲区是由内核管理的，受到内核保护，内核需要确保进程隔离，进程之间不能直接读取对方的网络数据包。正确的做法是，应用程序通过系统调用（syscall）来请求网络数据包信息，这本质上是内核 API 调用——应用程序调用 syscall，内核检查应用程序是否有权限获得其请求的数据包；如果有，就把返回数据包。\n\n有了 eBPF 之后，应用程序不再需要 syscall，数据包不需要在内核空间和用户空间之间来回交互传递。而是我们将代码直接交给内核，让内核自己执行，这样就可以让代码全速运行，效率更高。eBPF 允许应用程序和内核以安全的方式共享内存，eBPF 允许应用程序直接向内核提交代码，目标都是通过超越系统调用的方式来实现性能提升。\n\neBPF 不是银弹，你不能用 eBPF 运行任意程序，实际上 eBPF 可以做的事情是非常有限的。\n\n## eBPF 的局限性\n\neBPF 的局限性也是因为内核造成的。内核中运行的应用程序应当有自己的租户，这些租户之间会争抢系统的内存、磁盘和网络，内核的职责就是隔离和调度这些应用程序的资源，同时内核还要保护确认应用程序的权限，保护其不被其他程序破坏。\n\n因为我们直接将 eBPF 代码交给内核执行，这绕过了内核安全保护（如 syscall），内核将面临直接的安全风险。为了保护内核，所有 eBPF 程序要想运行都必须先通过一个**验证器**。但是要想自动验证程序是很困难的，验证器可能会过度限制程序的功能。比如 eBPF 程序不能是阻塞的，不能有无限循环，不能超过预定的大小；其复杂性也受到限制，验证器会评估所有可能的执行路径，如果 eBPF 程序不能在某些范围内完成，或者不能证明每个循环都有一个退出条件，那么验证器就不会允许该程序运行。有很多应用程序都违反了这些限制，要想将它们作为 eBPF 程序来运行的话，要么重写以满足验证器的需求，要么给内核打补丁，来绕过一些验证（这可能比较困难）。不过随着内核版本的升级，这些验证器也变得更加智能，限制也逐渐变得宽松，也有一些创造性的方法来绕过这些限制。\n\n但总的来说，eBPF 程序能做的事情非常有限。对于一些重量级事件的处理，例如处理全局范围内的 HTTP\/2 流量，或者 TLS 握手协商不能在纯 eBPF 环境中完成。充其量，eBPF 可以做其中的一小部分工作，然后调用用户空间应用程序来处理对于 eBPF 来说过于复杂而无法处理的部分。\n\n## eBPF 与服务网格的关系\n\n因为上文所述的 eBPF 的各项限制，七层流量仍然需要用户空间的网络代理来完成，eBPF 并不能替代服务网格。eBPF 可以与 CNI（容器网络接口）一起运行，处理三层\/四层流量，而服务网格处理七层流量。\n\n## 每个主机一个代理的模式比 sidecar 更糟\n\n对于每个主机一个代理（per-host）的模式，服务网格的早期实践者 Linkerd 1.x 就是这么用的，笔者也是从那个时候开始关注服务网格，Linkerd 1.x 还使用了 JVM 虚拟机！但是经过 Linkerd 1.x 的用户实践证明，这种模式相对于 sidecar 模式，对于运维和安全来说会更糟糕。\n\n为什么说 sidecar 模式比 per-host 模式更好呢？因为 sidecar 模式有以下几个优势，这是 per-host 模式所不具备的：\n\n1. 代理的资源消耗随着应用程序的负载而变化。随着实例流量的增加，sidecar 会消耗更多的资源，就像应用程序一样。如果应用程序的流量非常小，那么 sidecar 就不需要消耗很多资源。Kubernetes 现有的管理资源消耗的机制，如资源请求和限制以及 OOM kill，都会继续工作。\n2. 代理失败的爆炸半径只限于一个 pod。代理失败与应用失败相同，由 Kubernetes 负责处理失败的 pod。\n3. 代理维护。例如代理版本的升级，是通过如滚动更新，灰度发布等应用程序本身相同的机制完成的。\n4. 安全边界很清楚（而且很小）：在 pod 级别。Sidecar 在应用程序实例的同一安全上下文中运行。它是 pod 的一部分，与应用程序具有一样的 IP 地址。Sidecar 执行策略，并将 mTLS 应用于进出该 pod 的流量，而且它只需要该 pod 的密钥。\n\n而对于 per-host 模式，就没有上述好处了。代理与应用程序 pod 完全解耦，处理主机上所有 pod 的流量，这样会代理各种问题：\n\n1. 代理消耗的资源是高度可变的，这取决于在某个时间点 Kubernetes 调度了多少个 pod 在该主机上。你无法有效的预测特定代理的资源消耗情况，这样代理就有崩溃的风险（原文是这么说的，这点笔者还是存疑的，希望有点读者能解帮忙解释下）。\n2. 主机上 pod 之间的流量争抢问题。因为主机上的所有流量都经过同一个代理，如果有一个应用程序 pod 的流量极高，消耗了代理的所有资源，主机上的其他应用程序就有被饿死的危险。\n3. 代理的爆炸半径很大，而且是不断变化的。代理的故障和升级现在影响到随机的应用程序集合中的一个随机的 pod 子集，意味着任何故障或维护任务都有难以预测的风险。\n4. 使得安全问题更加复杂。以 TLS 为例，主机上的代理必须包含该主机上所有应用程序的密钥，这使得它成为一个新的攻击媒介，容易受到[混淆代理](https:\/\/en.wikipedia.org\/wiki\/Confused_deputy_problem)问题的影响——代理中的任何 CVE 或漏洞都是潜在的密钥泄露风险。\n\n简而言之，sidecar 模式继续贯彻了容器级别的隔离保护——内核可以在容器级别执行所有安全保护和公平的多租户调度。容器的隔离仍然可以完美的运行，而 per-host 模式却破坏了这一切，重新引入了争抢式的多租户隔离问题。\n\n当然 per-host 也不是一无是处，该模式最大的好处是可以成数量级的减少代理的数量，减少网络跳数，这也就减少了资源消耗和网络延迟。但是与该模式带来的运维和安全性问题相比，这些优势都是次要的。我们也可以通过持续优化 sidecar 来弥补 sidecar 模式在这方面的不足，而 per-host 模式的缺陷确是致命性的。\n\n其实归根结底还是回到了争抢式多租户问题上，那么能否利用现有的内核解决方案，改进一下 per-host 模式中的代理，让其支持多租户呢？比如改造 Envoy 代理，使其支持多租户模式。虽然从理论来说这是可行的，但是工作量巨大，Matt Klein 也觉得不值得这样做 [^2]，还不如使用容器来实现租户隔离。而且即使让 per-host 模式中的代理支持了多租户，仍然还有爆炸半径和安全问题需要解决。\n\n## 总结\n\n不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。Sidecar 模式虽然也有弊端，但它依然是既能保持容器隔离和操作的优势，又能处理云原生网络复杂性的最优方案。eBPF 的能力将来是否会发展到可以处理七层网络流量，从而替代服务网格和 sidecar，也许吧，但那一天可能很遥远。\n\n## 参考\n\n[^1]: William Morgan 的 [eBPF, sidecars, and the future of the service mesh](https:\/\/buoyant.io\/2022\/06\/07\/ebpf-sidecars-and-the-future-of-the-service-mesh\/) 这篇文章正好回答了我的关于 eBPF、sidecar 的疑问。\n[^2]: 关于 per-host 模式中的代理改造问题，Twitter 上有一个精彩的[讨论](https:\/\/twitter.com\/mattklein123\/status\/1522925333053272065)。\n', '\/blog\/ebpf-sidecar-and-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">不管有没有 eBPF，在可预见的未来，服务网格都会基于运行在用户空间的 sidecar 代理（proxyless 模式除外）。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/book/what-is-ebpf/">什么是 eBPF？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6"> 
             翻译电子书
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('什么是 eBPF？', '新一代网络、安全和可观测性工具简介。', '\n《什么是 eBPF —— 新一代网络、安全和可观测性工具介绍》译自 O\u0027Reilly 发布的报告“What is eBPF”，作者是 Liz Rice，由 JImmy Song 翻译，英文原版可以在 [O\u0027Reilly 网站](https:\/\/www.oreilly.com\/library\/view\/what-is-ebpf\/9781492097266\/)上获取。\n\n## 译者序\n\n最近两年来关于 eBPF 的讨论在云原生社区里越来越多，尤其是当谈到 Cilium 的商业化，使用 eBPF 来优化 Istio 服务网格，甚至扬言干掉 Sidecar 时，eBPF 更是赚足了眼球。\n\n这本报告是由基于 Cilium  的创业公司 Isovalent 的 Liz Rice 撰写，由 O\u0027Reilly 发布，相信可以为你揭开 eBPF 技术的神秘面纱，带你了解什么是 eBPF 还有它的强大之处。更重要的是它在云原生环境中，在服务网格、可观测性和安全中的应用。\n\n## 关于作者\n\nLiz Rice 是云原生网络和安全专家，Isovalent 的首席开源官，是基于 eBPF 的 Cilium 网络项目的创建者。她在 2019-2022 年担任 CNCF 的技术监督委员会（TOC）主席，并在 2018 年担任 KubeCon \u002b CloudNativeCon 的联合主席。她也是 Container Security 一书的作者，由 O\\\u0027Reilly 出版。她拥有丰富的软件开发、团队和产品管理经验，曾在网络协议和分布式系统以及数字技术领域（如 VOD、音乐和 VoIP）工作。在不写代码的时候，Liz 喜欢在天气比她的家乡伦敦好的地方骑自行车，和在 Zwift 上参加虚拟比赛。\n\n## 本书大纲\n\n{{\u003c list_children show_summary=\u0022false\u0022\u003e}}\n\n{{\u003c cta cta_text=\u0022开始阅读\u0022 cta_link=\u0022introduction\u0022 \u003e}}\n', '\/book\/what-is-ebpf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">新一代网络、安全和可观测性工具简介。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-add-bpf-observability/">[译] 如何在产品中引入 eBPF 以增加可观测性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在产品中引入 eBPF 以增加可观测性', '本文是给想要在产品中引入 eBPF 增加可观测性人员的忠告。', '\n## 编者按\n\n本文译自 [How To Add eBPF Observability To Your Product](https:\/\/www.brendangregg.com\/blog\/2021-07-03\/how-to-add-bpf-observability.html)，原文发布于 2021 年 7 月 3 日。本文作者 Brendan Gregg 是 eBPF 领域的专家，出版过多本相关书籍，本文是他给想要在产品中引入 eBPF 增加可观测性人员的忠告。\n\n## 正文\n\n现在有一场军备竞赛，即增加 eBPF 的军备竞赛，在这篇文章中，我将介绍如何快速做到这一点。这也适用于人们将其添加到自己的内部监测系统中。\n\n人们喜欢在他们建立了原型或构建了产品之后向我展示他们的 BPF 可观测性产品，但我常常在他们开始之前给出建议。作为 BPF 可观测性的领导者，这是我在最近的谈话中一直包含的建议，现在我把它纳入这篇文章中。\n\n首先，我知道你很忙。你甚至可能不喜欢 BPF。为了务实起见，我将描述如何花最少的精力来获得最大的价值。把这看成是“第一版”。一个相当有用的出发点。无论你是否遵循这个建议，至少请你理解它，以避免以后的遗憾和痛苦。\n\n如果你正在使用开源监控平台，首先检查它是否已经有一个 BPF 代理。这篇文章假设它没有，而且你将首次添加一些东西。\n\n## 1. 运行第一个工具\n\n首先安装 [bcc](https:\/\/github.com\/iovisor\/bcc) 或 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 工具。例如，Ubuntu 上的 bcc。\n\n\u0060\u0060\u0060sh\n# apt-get install bpfcc-tools\n\u0060\u0060\u0060\n\n然后尝试运行一个工具。例如，使用 execsnoop (8) 查看带有时间戳的进程执行情况。\n\n\u0060\u0060\u0060sh\n# execsnoop-bpfcc -T\nTIME     PCOMM            PID    PPID   RET ARGS\n19:36:15 service          828567 6009     0 \/usr\/sbin\/service --status-all\n19:36:15 basename         828568 828567   0 \n19:36:15 basename         828569 828567   0 \/usr\/bin\/basename \/usr\/sbin\/service\n19:36:15 env              828570 828567   0 \/usr\/bin\/env -i LANG=en_AU.UTF-8 LANGUAGE=en_AU:en LC_CTYPE= LC_NUMERIC= LC_TIME= LC_COLLATE= LC_MONETARY= LC_MESSAGES= LC_PAPER= LC_NAME= LC_ADDRESS= LC_TELEPHONE= LC_MEASUREMENT= LC_IDENTIFICATION= LC_ALL= PATH=\/opt\/local\/bin:\/opt\/local\/sbin:\/usr\/local\/git\/bin:\/home\/bgregg\/.local\/bin:\/home\/bgregg\/bin:\/opt\/local\/bin:\/opt\/local\/sbin:\/ TERM=xterm-256color \/etc\/init.d\/acpid \n19:36:15 acpid            828570 828567   0 \/etc\/init.d\/acpid status\n19:36:15 run-parts        828571 828570   0 \/usr\/bin\/run-parts --lsbsysinit --list \/lib\/lsb\/init-functions.d\n19:36:15 systemctl        828572 828570   0 \/usr\/bin\/systemctl -p LoadState --value show acpid.service\n19:36:15 readlink         828573 828570   0 \/usr\/bin\/readlink -f \/etc\/init.d\/acpid\n[...]\n\u0060\u0060\u0060\n\n虽然很基本，但我仅用这个工具就解决了很多 perf 问题，包括针对配置错误的系统，其中一个 shell 脚本正在循环启动失败的进程，以及当一些小程序崩溃并每隔几分钟就重启但还没有被注意到时。\n\n## 2. 为你的产品添加一个工具\n\n现在想象一下将 execsnoop (8) 添加到你的产品中。你可能已经在你所有的客户系统上运行了代理。他们是否有办法运行一个命令并返回文本输出？或者运行一个命令并将输出发送到其他地方进行聚合（S3、Hive、Druid 等）？有很多选择，这实际上是你自己基于现有系统和客户环境的偏好。\n\n当你把第一个工具添加到你的产品中时，让它在短时间内运行，比如 10 到 60 秒。我刚刚注意到 execsnoop (8) 还没有持续时间选项，所以在这期间你可以用 \u0060watch -s2 60 execsnoop-bpfcc\u0060 来包装它。如果你想 24 小时运行这些工具，首先要研究开销以了解成本。低频率的事件，如进程的执行，捕捉起来应该是可以忽略不计的。\n\n不使用 bcc，你也可以使用 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 版本。这些通常没有封装选项（-v、-l 等），但有一个 json 输出模式。例如：\n\n\u0060\u0060\u0060sh\n# bpftrace -f json execsnoop.bt \n{\u0022type\u0022: \u0022attached_probes\u0022, \u0022data\u0022: {\u0022probes\u0022: 2}}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u0022TIME(ms)   PID   ARGS\\n\u0022}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u00222737       849176 \u0022}\n{\u0022type\u0022: \u0022join\u0022, \u0022data\u0022: \u0022ls -F\u0022}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u00225641       849178 \u0022}\n{\u0022type\u0022: \u0022join\u0022, \u0022data\u0022: \u0022date\u0022}\n\u0060\u0060\u0060\n\n添加这种模式是为了使 BPF 的可观测性产品可以建立在 bpftrace 之上。\n\n## 3. 不要担心依赖性问题\n\n我建议你在客户系统上安装 bcc 或 bpftrace，它们目前有 llvm 依赖。这可能会增加到几十 MB，这对一些资源有限的环境（嵌入式）是个问题。我们一直在做大量的工作，以便在未来解决这个问题。 [BTF and CO-RE](https:\/\/www.brendangregg.com\/blog\/2020-11-04\/bpf-co-re-btf-libbpf.html)（而不是 Python），最终将意味着你可以安装 100KB 的无依赖性的工具二进制版本。bpftrace 也有一个类似的计划，使用较新的内核特性生成一个小的无依赖性的二进制版本。\n\n这确实需要至少 Linux 5.8 才能很好地工作，而你的客户可能几年都不会运行这个系统。在这期间，我建议暂时不要担心 llvm 的依赖关系，因为它以后会被修复。\n\n请注意，并不是所有的 Linux 发行版都启用了 \u0060CONFIG_DEBUG_INFO_BTF=y\u0060，这对于 BTF 和 CO-RE 的未来是必要的。主要的发行版已经设置了它，比如在 Ubuntu 20.10、Fedora 30 和 RHEL 8.2。但如果你知道你的一些客户正在运行一些不常见的东西，请检查并鼓励他们或发行商设置 \u0060CONFIG_DEBUG_INFO_BTF=y\u0060 和 \u0060CONFIG_DEBUG_INFO_BTF_MODULES=y\u0060，以避免未来的痛苦。\n\n## 4. 第 1 版仪表板\n\n现在你的产品中有了一个 BPF 可观测性工具，是时候增加更多的工具了。下面是你可以运行的十大工具，并作为一个通用的 BPF 可观测性仪表盘来展示，同时还有建议的可视化。\n\n| 编号 | 工具       | 展示                    | 可视化           |\n| ---- | ---------- | ----------------------- | ---------------- |\n| 1.   | execsnoop  | 新进程（通过 exec (2)） | 表格             |\n| 2.   | opensnoop  | 打开的文件              | 表格             |\n| 3.   | ext4slower | 慢速文件系统 I\/O        | 表格             |\n| 4.   | biolatency | 磁盘 I\/O 延迟柱状图     | 热力图           |\n| 5.   | biosnoop   | 每个事件的磁盘 I\/O 细节 | 表格，偏移热图   |\n| 6.   | cachestat  | 文件系统高速缓存统计    | 线状图           |\n| 7.   | tcplife    | TCP 连接                | 表格，分布式图表 |\n| 8.   | tcpretrans | TCP 重传                | 表格             |\n| 9.   | runqlat    | CPU 调度器的延迟        | 热力图           |\n| 10.  | profile    | CPU 堆栈跟踪样本        | 火焰图           |\n\n这是在我的 [bcc Tutorial](https:\/\/github.com\/iovisor\/bcc\/blob\/master\/docs\/tutorial.md) 的，而且很多也存在于 bpftrace 中。我选择这些是为了用最少的工具找到最大的性能优势。\n\n请注意，runqlat 和 profile 会有明显的开销，所以我只运行这些工具 10 到 60 秒，然后生成一份报告。有些工具的开销很低，如果需要的话可以 24 小时运行（例如 execsnoop、biolatency、tcplife、tcpretrans）。\n\n在 bcc 和 bpftrace 资源库中，已经有以手册和实例文件形式存在的文档，你可以链接到这些文档，以帮助你的客户了解工具的输出。例如，在 [bcc](https:\/\/github.com\/iovisor\/bcc\/blob\/master\/tools\/execsnoop_example.txt) 和 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace\/blob\/master\/tools\/execsnoop_example.txt) 有 execsnoop (8) 的示例文件。\n\n完成这些后，你就有了第一版的仪表板。\n\n## bcc 与 bpftrace\n\nbcc 工具是最容易使用的，因为它们通常有很多命令行选项。bpftrace 工具更容易编辑和定制，而且 bpftrace 有一个 json 输出模式。\n\n如果你是追踪的新手，就用 bcc 吧。如果你想做一些黑客和定制的工具，就用 bpftrace。最后，它们都是不错的选择。\n\n## 案例研究：Netflix\n\nNetflix 正在建立一个新的 GUI，在这些工具的 bpftrace 版本的基础上，做这个工具仪表盘和更多的工作。架构如图。\n\n![](008i3skNly1gys3a6aaa2j31310u0tcj.jpg) \n\n虽然 bpftrace 二进制文件安装在所有目标系统上，但 bpftrace 工具（文本文件）却在网络服务器上，并在需要时被推送出去。这意味着我们可以通过在一个地方更新工具来确保我们一直在运行最新版本的工具。\n\n这是目前我们 FlameCommander 用户界面的一部分，它也在云端运行火焰图。我们以前的 BPF GUI 是 [Vector](https:\/\/github.com\/Netflix\/vector) 的一部分，并使用了 bcc，但我们后来废弃了它。我们可能会在某个时候开源新的 GUI，并在 Netflix 技术博客上发表相关文章。\n\n## 案例研究：Facebook\n\nFacebook 是 BPF 的高级用户，但他们如何在整个集群中运行工具的深层细节并没有完全公开。根据 bcc 的活动，以及他们对 BTF 和 CO-RE 技术的开发，我十分怀疑他们的解决方案是基于 bcc 的 libbpf-tool 版本。\n\n## 移植的陷阱\n\nBPF 追踪工具就像应用程序和内核的补丁。它们需要不断的更新以保持在不同的软件版本中工作。把它们移植到不同的语言，然后不维护它们，可能就像试图把 Linux 4.15 的补丁应用于 Linux 5.12。如果你运气好，它就会工作！如果你不走运，补丁就会应用，但会以一种微妙的方式破坏一些东西，直到后来你才注意到。这取决于工具。\n\n作为一个极端的例子，我在 2014 年休假时写了 cachestat (8)，用于 Netflix cloud，当时是 Linux 3.2 和 3.13 的混合版本。BPF 在这些版本上并不存在，所以我使用了 Linux 3.2 上的基本 Ftrace 功能。我把这种方法描述为 [brittle](https:\/\/www.brendangregg.com\/blog\/2014-12-31\/linux-page-cache-hit-ratio.html)， [sandcastle](https:\/\/github.com\/brendangregg\/perf-tools\/blob\/master\/fs\/cachestat) 需要随着内核的变化而进行维护。后来，它被移植到了带有 kprobes 的 BPF 上，现在已经被重写并包含在商业可观测性产品中。我听说它在较新的内核上有问题，打印的输出没有意义。它真的需要一次大修。当我（或某人）做了这个工作，任何从 bcc 上拉取更新的人都会自动得到固定的版本，不需要费力。那些重写的人将需要重写自己的版本。我担心他们不会这样做，而客户将在多年来一直运行一个错误的 cachestat (8) 版本。\n\n请注意，如果在我写 cachestat (8) 的时候，BPF 在我的目标环境中是可用的，我的编码方式就会完全不同。人们正在移植为 Linux 3.2 编写的东西，并在 Linux 5.x 上运行它。\n\n在以前的一篇博文 [An Unbelievable Demo](https:\/\/www.brendangregg.com\/blog\/2021-06-04\/an-unbelievable-demo.html) 中，谈到了很多年前发生的类似情况，即在没有更新的情况下使用旧的追踪工具版本。\n\n我所描述的问题是针对 BPF 软件和内核追踪的。作为一个不同的例子，我的火焰图软件已经被重写了十几次，由于它是一个简单而完备的算法，我不认为这有什么大问题。我更喜欢人们帮助更新 [d3 version](https:\/\/github.com\/spiermar\/d3-flame-graph) 但如果人们自己做，那也没什么大不了的。你可以给它编码，它将永远工作。基于 uprobe 和 kprobe 的 BPF 工具就不是这样了，因为它们确实需要维护。\n\n## 像系统管理员一样思考，而不是像程序员一样思考\n\n总之，首先检查你的监控系统是否已经有一个 BPF 代理，如果没有，就在现有的基础上构建一个 [bcc](https:\/\/github.com\/iovisor\/bcc) 或 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 工具，而不是从头开始重写一切。这是像一个安装和维护软件的系统管理员那样思考，而不是像一个编码所有东西的程序员那样思考。安装 bcc 或 bpftrace 工具，把它们添加到你的可观测性产品中，并根据需要拉取包的更新。这将是一个快速而有用的版本。BPF 启动和运行了！\n\n我看到人们反而像程序员一样思考，觉得他们必须从深入学习 bcc 和 BPF 编程。然后，在发现所有的东西都是 C 语言或 Python 写的之后，有些人就用不同的语言重写了。\n\n首先，学好 bcc 和 BPF 需要几周时间；学习系统跟踪的微妙之处和陷阱可能需要几个月或几年。为了让你了解你所面临的情况，请看我的 [BPF Internals](https:\/\/www.brendangregg.com\/blog\/2021-06-15\/bpf-internals.html) 讲座。如果你真的想做这个，并且有时间，你当然可以（你可能会在 Tracing 会议上遇到我。在 Linux Plumber’s 或追 Tracing 会上见！）但是，如果你在某个期限内要增加 BPF 的可观测性，那就试着像一个系统管理员那样思考，并在现有的工具基础上进行构建。这是快速的方法。以后再像程序员那样思考，如果你有时间的话。\n\n第二，BPF 软件，特别是某些基于 kprobe 的工具，需要持续的维护。一个工具可能在 Linux 5.3 上工作，但在 5.4 上就会坏掉，因为一个被追踪的函数被重新命名或增加了一个新的代码路径。BPF 库和框架也在变化和发展，最近的一次是 BTF 和 CO-RE 支持。这是我希望人们在选择重写它们之前要考虑的问题。你是否也有计划重写所有的更新，或者你最终会被困在一个旧的库的端口上？拉取所有的更新比维护你自己的版本更容易。\n\n最后，如果你有一个比我们在 bcc 和 bpftrace 中使用的更好的 BPF 库或框架的好主意呢？和我们谈谈，试试，创新一下。我们正处于 BPF 时代的开端，还有很多东西需要探索。但请先了解现有的情况以及你所承担的维护负担。你的精力可能会被用来在现有的基础上创造新的东西，而不是移植旧的东西。\n', '\/trans\/how-to-add-bpf-observability\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是给想要在产品中引入 eBPF 增加可观测性人员的忠告。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-wasm-service-mesh/">[译] eBPF 和 Wasm：探索服务网格数据平面的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://infoq.com/news/2022/01/ebpf-wasm-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 和 Wasm：探索服务网格数据平面的未来', 'eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。', '\n## 编者按\n\n前段时间，有人提出使用 eBPF 取代服务网格中的 sidecar 代理，该观点已经发出，就在服务网格和云原生社区中引起了“轩然大波”。后来也有不少人指出该方案实属武断，不切实际。本文就总结了 eBPF 在服务网格数据平面中的作用，以及使用 Wasm 这种新的方案。\n\n## 正文\n\n2021 年 12 月 2 日，Cilium 项目宣布了 [Cilium Service Mesh](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta) 的 beta 测试计划。在谷歌云基于 eBPF 的 Google Cloud Kubernetes Service（GKS）Dataplane V2（于 2020 年 8 月发布）所开创的概念基础上，Cilium Service Mesh 提倡“无 sidecar 服务网格 \u0022 的理念。它扩展了 Cilium eBPF 产品，以处理服务网格中的大部分 sidecar 代理功能，包括 L7 路由和负载均衡、TLS 终止、访问策略、健康检查、日志和跟踪，以及内置的 Kubernetes Ingress。\n\nCillium 的创建者 Isovalent 在一篇题为“[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/) “的文章中解释了使用 eBPF 作为 sidecar 代理的理由。\n\n它将把我们从 sidecar 模型中解放出来，并允许我们将现有的代理技术整合到现有的内核命名空间概念中，使它们成为我们每天都在使用的容器抽象的一部分。\n\n简而言之，eBPF 有望解决服务网格中的一个主要痛点 —— 当有许多细粒度的微服务时，性能堪忧。然而，使用 eBPF 来取代 sidecar 代理这个想法也是存在争议的。\n\n![告别 sidecar](008i3skNly1gy9u3uba27j31x70u0dk7.jpg) \n\n（来源：[告别 Sidecar—— 使用 eBPF 解锁内核级服务网格](https:\/\/cloudnative.to\/blog\/ebpf-solve-service-mesh-sidecar\/)）\n\n服务网格中的数据平面指的是管理数据流量如何被路由和交付给微服务应用的基础设施服务。目前，这是通过使用服务代理来实现的。这种设计模式通常也被称为 Sidecar 模式。Sidecar 允许其附属的微服务透明地与服务网格中的其他组件发出和接收请求。\n\nSidecar 通常包含一个 L7 网络代理，如 [Envoy](https:\/\/envoyproxy.io\/)、[Linkerd](https:\/\/linkerd.io\/) 或 [MOSN](https:\/\/mosn.io\/)。该代理处理流量路由、负载均衡、健康检查、认证、授权、加密、日志、跟踪和统计数据收集。Sidecar 还可以包含一个基于 SDK 的应用框架，如 [Dapr](https:\/\/dapr.io\/)，以提供网络代理以外的应用服务。这种应用服务的例子包括服务注册、服务发现、资源绑定、基于名称的服务调用、状态管理、行为者框架和秘密存储。\n\nSidecar 代理和服务通常在 Kubernetes pod 或容器内运行。微服务应用也在容器内运行，它们通过网络接口连接到 sidecar 上。然而，这些容器化应用程序的一个重要问题是资源消耗。Sidecar 服务随着微服务的数量呈几何级数增加。当一个应用程序有数百个相互联系和负载均衡的微服务时，开销可能变得不堪重负。服务网格代理供应商在性能上展开竞争。正如 [InfoQ 之前报道的](https:\/\/www.infoq.com\/news\/2021\/08\/linkerd-rust-cloud-native\/)那样，Linkerd 将其代理从 Go 重写成了 Rust，并取得了明显的性能提升。\n\n不足为奇的是，现有的服务网格供应商并不相信 eBPF 是能解决我们所有问题的圣杯。来自 Solo 的 Idit Levine 等人写了一篇文章来回应 Cilium 的公告。这篇文章的标题是“[服务网格将使用 eBPF？是的，但 Envoy 代理将继续存在](https:\/\/www.zhaohuabing.com\/post\/2021-12-19-ebpf-for-service-mesh\/) \u0022。\n\n\u003e 在 Solo.io，我们认为 eBPF 是优化服务网格的一种强大方式，我们认为 Envoy 代理是数据平面的基石。\n\nSolo.io 作者提出的关键点是，现在的 sidecar 代理所做的事情远远超过了简单的网络流量管理。在今天的服务网格部署中，有一些复杂的要求，远远超过了 eBPF 所支持的有限的编程模型，eBPF 是图灵不完整的，对内核的安全性有许多限制。Cilium eBPF 产品可以处理许多，但不是全部，由 sidecar 代理执行的各种任务。此外，Solo.io 的作者指出，eBPF 的每个节点一个代理的设置提供了更少的灵活性，因此与传统代理的每个节点一个代理的设置相比，增加了整体开销。这些 eBPF 的缺点对于开发者必须编写并部署到服务网格代理中的流量路由、负载均衡和授权的特定应用逻辑来说尤其明显。\n\nTerate.io 的开发者在对 Cilium 公告的回应中提出了类似的论点，标题是“[社区中关于 Istio 和服务网格的争论](https:\/\/www.tetrate.io\/blog\/the-debate-in-the-community-about-istio-and-service-mesh\/) \u0022。他们指出，今天的 sidecar 代理的性能是合理的，开源社区已经想出了进一步提高性能的方法。同时，对于开发者来说，在 eBPF 这种新颖的、图灵不完整的技术中构建特定应用的数据平面逻辑是非常困难的。\n\n\u003e Istio 架构是稳定的，可用于生产的，而且生态系统正在萌芽。\n\neBPF 的许多问题与以下事实有关：它是一种内核技术，因此必须有安全限制。有没有一种方法可以将复杂的特定应用的代理逻辑纳入数据平面，而不使用使用空间技术降低性能？事实证明，WebAssembly（Wasm）可能正是这种选择。Wasm 运行时可以安全地隔离并以接近原生的性能执行用户空间代码。\n\nEnvoy Proxy 开创了使用 Wasm 作为扩展机制对数据平面进行编程的方法。开发人员可以用 C、C\u002b\u002b、Rust、AssemblyScript、Swift 和 TinyGo 等语言编写特定应用的代理逻辑，并将该模块编译到 Wasm 中。通过 proxy-Wasm 标准，代理可以在 [Wasmtime](https:\/\/github.com\/bytecodealliance\/wasmtime) 和 [WasmEdge](https:\/\/github.com\/WasmEdge\/WasmEdge) 等高性能运行机制中执行那些 Wasm 插件。目前，[Envoy Proxy](https:\/\/envoyproxy.io\/)、[Istio Proxy](https:\/\/github.com\/istio\/proxy)、MOSN 和 [OpenResty](http:\/\/openresty.org\/) 支持 [proxy-Wasm](https:\/\/github.com\/proxy-wasm)。\n\n![容器生态](008i3skNly1gy9u3wo1dnj30u015yq70.jpg) \n\n（容器生态系统中的 Wasm，来源：[WasmEdge Book](https:\/\/wasmedge.org\/book\/en\/kubernetes.html)）\n\n此外，Wasm 可以作为一个通用的应用容器。它在服务网格数据平面上的应用并不限于 sidecar 代理。附在 sidecar 上的微服务可以在它自己的轻量级 Wasm 运行时运行。WasmEdge WebAssembly 运行时是一个安全、轻量级、快速、可移植和多元化的运行时，可以直接由 [Kubernetes 作为容器](https:\/\/wasmedge.org\/book\/en\/kubernetes.html)管理。到 2021 年 12 月，WasmEdge 社区的贡献者证明了基于 WasmEdge 的微服务可以与 [Dapr](https:\/\/github.com\/second-state\/dapr-wasm) 和 [Linkerd](https:\/\/github.com\/Liquid-Reply\/kind-crun-wasm) 一起工作，作为带有操作系统和完整软件堆栈的重量级全面的 Linux 容器的替代。WebAssembly 微服务消耗 1% 的资源，与 Linux 容器应用相比，冷启动的时间是 1%。\n\neBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。\n', '\/trans\/ebpf-wasm-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-solve-service-mesh-sidecar/">[译] 告别 Sidecar——使用 eBPF 解锁内核级服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/12/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('告别 Sidecar——使用 eBPF 解锁内核级服务网格', '本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。', '\n译者注：本文作者是 Isovalent 联合创始人\u0026CTO，原文标题 [How eBPF will solve Service Mesh - Goodbye Sidecars](https:\/\/isovalent.com\/blog\/post\/2021-12-08-ebpf-servicemesh)，作者回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。\n\n------\n\n## 什么是服务网格？\n\n随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。\n\n![服务网格示意图](008i3skNly1gx7wyna8jsj32e20sojtx.jpg)\n\n纵观今天服务网格的功能设置，可以总结为以下几点：\n\n- **弹性连接**：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。\n- **L7 流量管理**：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。\n- **基于身份的安全**：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。\n- **可观测性和跟踪**：追踪和指标形式的可观测性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。\n- **透明**：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。\n\n在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP\/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。\n\n![基于库的服务网格模型](008i3skNly1gx7wyowb55j31pi0k076p.jpg)\n\n今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为“挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。\n\n![基于 Sidecar 的服务网格模型](008i3skNly1gx7wyqsefhj31pe0moq5h.jpg)\n\n这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。\n\n这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。\n\n## 连接性转移到内核中的历史\n\n几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 [TCP 包装器](https:\/\/en.wikipedia.org\/wiki\/TCP_Wrappers)和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。\n\n然而，iptables 显然不适合解决现代应用的连接性、安全性和可观测性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。\n\n![服务网格的进化](008i3skNly1gx7y8ybphhj31h30u041s.jpg) \n\n在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。\n\n## 扩展内核命名空间概念\n\nLinux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 \u0022容器\u0022 概念中。\n\n符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。\n\n![Service Mesh Namespace](008i3skNly1gx7wypvr2zj31p20q0q75.jpg)\n\n不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。\n\n### 注入 Sidecar 的成本\n\n如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。\n\n![注入 Sidecar 的成本](008i3skNly1gx7y8nu479j31h30u041s.jpg) \n\n \n\n这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。\n\n## 用 eBPF 解锁内核服务网格\n\n为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见[我们已经构建了相当多的服务网格 - Tim Hockin, Google](https:\/\/www.youtube.com\/watch?v=lUF88T16YqY\u0026ab_channel=CloudNativeRejekts)）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。\n\neBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观测性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观测性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。\n\n![eBPF 服务网格架构](008i3skNly1gx7wyrufdyj31w90u0q6o.jpg) \n\n**有人可能想知道为什么 Linux 内核社区不直接解决这些需求**。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。**新的内核版本需要几年时间才能进入用户手中**。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。\n\n## 无 Sidecar 的基于 eBPF 的 L7 追踪和度量\n\n让我们看看 L7 追踪和指标可观测性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观测性应该没有明显的成本（延迟、复杂性、资源…）。\n\n![基于 eBPF 的可视性](008i3skNly1gx7wysxpr4j31ne0iugq1.jpg)\n\n在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。\n\n![基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性](008i3skNly1gx7wyt6izdj31ns0rawfw.jpg)\n\n我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。**几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。**\n\n这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。\n\n## 使用 eBPF 加速的 per-node 代理\n\n越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。\n\n我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。\n\n当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。\n\n![eBPF per-node Proxy](008i3skNly1gx7wyvrfmfj31vq0u0q87.jpg) \n\neBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。\n\n## Sidecar 与 per-Node 代理\n\n即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。\n\n### 每个连接的代理\n\n所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。\n\n![基于 eBPF 的模型](008i3skNly1gx7wyy16o4j32960kcwg9.jpg)\n\n用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。\n\n![基于 Sidecar 代理的模型](008i3skNly1gx7wz3o1f6j32860lego3.jpg)\n\n切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。\n\n![Per-node 代理模式](008i3skNly1gx7wyx2lulj32980o4dhz.jpg)\n\n### 所需的代理总数\n\n在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。\n\n![代理数量](008i3skNly1gx7y8synvej31z40oiq6n.jpg) \n\n \n\n让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。\n\n### 多租户\n\n当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。\n\n![Envoy Namespace](008i3skNly1gx7z3klyfhj31hx0u0djs.jpg)\n\n如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（[Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019](https:\/\/www.youtube.com\/watch?v=08opgZkdYIw)）。\n\n## 想参与其中吗？- 加入 Cilium 服务网格测试版\n\n![测试版](008i3skNly1gx7wz1obexj327t0u0dkm.jpg) \n\n伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。\n\n- L7 流量管理和负载均衡（HTTP，gRPC，…）\n- 跨集群、云和集群的拓扑感知路由\n- TLS 终止\n- 通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等\n- 用 OpenTelemetry 和 Jaeger 集成进行追踪\n- 内置 Kubernetes Ingress 支持\n\n上述所有功能都可以在 [github.com\/cilium\/cilium](https:\/\/github.com\/cilium\/cilium) 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 [这个表格](https:\/\/forms.gle\/j9fwhAC6HnHRJQKeA)，或者你可以在 Cilium 社区的[公告](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)中阅读更多关于该计划的信息。\n\n## 总结\n\neBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。\n\n如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 [Twitter](https:\/\/twitter.com\/tgraf__) 或 [eBPF \u0026 Cilium Slack 联系我们](http:\/\/ebpf.io\/slack)。\n\n## 进一步阅读\n\n- [eBPF 如何简化服务网格](\/trans\/how-ebpf-streamlines-the-service-mesh\/)，Liz Rice，The New Stack\n- [Cilium 服务网格测试计划](https:\/\/cilium.io\/blog\/2021\/12\/01\/cilium-service-mesh-beta)，Cilium 社区\n- [了解更多关于 Cilium 的信息](https:\/\/cilium.io\/learn)\n', '\/trans\/ebpf-solve-service-mesh-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-ebpf-streamlines-the-service-mesh/">[译] eBPF 如何简化服务网格</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('eBPF 如何简化服务网格', '本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。', '\n今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对额外的[复杂性](https:\/\/engineering.hellofresh.com\/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb)和[开销的](https:\/\/pklinker.medium.com\/performance-impacts-of-an-istio-service-mesh-63957a0000b)实际[担忧所抑制](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)。让我们来探讨一下 [eBPF](https:\/\/ebpf.io\/) 是如何让我们精简[服务网格](https:\/\/thenewstack.io\/category\/service-mesh\/)，使服务网格的数据平面更有效率，更容易部署。\n\n## Sidecar 问题\n\n今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 [Envoy](https:\/\/www.envoyproxy.io\/) 或 [Linkerd-proxy](https:\/\/linkerd.io\/)。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。\n\n每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的[经验](https:\/\/medium.com\/geekculture\/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d)，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。\n\n![来自 [redhat.com\/architect\/why-when-service-mesh](https:\/\/redhat.com\/architect\/why-when-service-mesh)——每个微服务都有自己的代理 sidecar](008i3skNly1gvtp69o74jj31w50u0jy8.jpg) \n\n为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。\n\n## 引入 eBPF\n\n[eBPF](http:\/\/ebpf.io\/) 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。\n\n重要的是，**每个节点只有一个内核**；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。\n\n![每台主机一个内核](008i3skNly1gvtp6c8mn9j31ea0u0n0t.jpg) \n\n这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。\n\n基于 eBPF 的 [Cilium](http:\/\/cilium.io\/) 项目（最近 [以孵化级别加入云计算基金会](https:\/\/www.cncf.io\/blog\/2021\/10\/13\/cilium-joins-cncf-as-an-incubating-project\/)）将这种“无 sidecar\u0022 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。\n\n![用无 sidecar 代理模式减少代理实例](008i3skNly1gvtp67ocjkj31xt0u0jvp.jpg) \n\n## 减少 YAML\n\n在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。\n\n以 Istio 为例，这需要[标记](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#controlling-the-injection-policy) Kubernetes 命名空间和 \/ 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。\n\n但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。\n\n相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。\n\n如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。\n\n## eBPF 支持的网络效率\n\n支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的[性能得到显著改善](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark)。让我们看看这在服务网格数据平面中是如何应用的。\n\n![在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多](008i3skNly1gvtp6ao3lqj31q90u0gqw.jpg) \n\n在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP\/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的[显著增加](https:\/\/linkerd.io\/2021\/05\/27\/linkerd-vs-istio-benchmarks\/#latency-at-20-rps)。\n\n基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。\n\n## 网络中的加密\n\n如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。\n\n通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。\n\n但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 [IPSec 或 WireGuard](https:\/\/cilium.io\/blog\/2021\/05\/11\/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec)。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。\n\n## eBPF 是服务网格的数据平面\n\n现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。\n\n去年，我代表 [CNCF](https:\/\/cncf.io\/?utm_content=inline-mention) 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 [预测](https:\/\/youtu.be\/bESogtuHwX0)。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。\n', '\/trans\/how-ebpf-streamlines-the-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨一下 eBPF 是如何让我们精简服务网格，使服务网格的数据平面更有效率，更容易部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
