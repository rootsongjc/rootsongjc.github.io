<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>HBONE - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/hbone/" />
  <meta property="og:title" content="HBONE | Jimmy Song" />
  <meta property="twitter:title" content="HBONE | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/hbone/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    HBONE
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/02/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式：图解及概念解读', '本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。', '\nIstio 的 Ambient 模式是一种创新的、无 Sidecar 的服务网格部署方式，通过 ztunnel 和 waypoint proxy 分离数据平面功能，简化了操作并降低了资源消耗。本篇博客将通过一份详细的术语表，帮助你更好地理解 Istio Ambient 模式中的关键概念及其背后的技术实现。\n\n## Ambient 模式\n\n![Ambient 模式架构图](ambient-mode-architecture.svg)\n\n  - **定义**：Istio 的一种无 Sidecar 的数据平面模式，通过 ztunnel 和 waypoint proxy 实现服务之间的安全通信和管理。相较于 Sidecar 模式，Ambient 模式更加轻量，降低了资源消耗并简化了配置。\n  - **架构**：数据平面功能分为 L4 层的安全覆盖层（由 ztunnel 提供）和 L7 层的策略处理层（由 waypoint proxy 提供）。\n\n## 控制平面与数据平面\n\n![控制平面与数据平面](control-plane-and-data-plane.svg)\n\n  - **定义**：在 Ambient 模式中，控制平面（\u0060istiod\u0060）负责管理集群内 ztunnel 和 waypoint proxy 的配置和策略，而数据平面由 ztunnel 和 waypoint proxy 组成，负责处理实际的网络流量。\n  - **组件交互**：ztunnel 使用 xDS APIs 从 \u0060istiod\u0060 获取配置并执行策略，管理 Pod 之间的 L4 和 L7 流量。\n\n## Istio Control Plane (\u0060istiod\u0060)\n\n  - **定义**：Istio 的控制平面组件，负责与 ztunnel 和 waypoint proxy 通信，提供 xDS 接口用于动态配置。\n  - **功能**：\u0060istiod\u0060 使用 xDS APIs 进行配置推送，动态管理 Ambient 模式中的流量策略、证书分发以及与 Kubernetes 集群的交互。\n\n## 透明性与非侵入性\n\n  - **定义**：Ambient 模式的架构旨在减少对应用的侵入性，应用无需感知数据平面的存在，Pod 无需重启或注入 Sidecar 即可加入网格。\n  - **优势**：提高了服务网格的灵活性，降低了操作复杂度，使应用和基础设施的生命周期更加解耦。\n\n## Sidecar Proxy\n\n![Sidecar 模式](sidecar-mode.svg)\n\n  - **定义**：传统 Istio 中的 Envoy 代理，与应用容器共同部署在一个 Pod 中。\n  - **问题**：对应用具有侵入性，Sidecar 必须在 Pod 中注入并伴随应用运行，增加了资源开销，并且使应用与代理的生命周期耦合。\n\n## Ztunnel (Zero-Trust Tunnel)\n\n![ztunnel](ztunnel.svg)\n\n  - **定义**：Ambient 模式中的关键组件，部署为 DaemonSet，为每个节点提供 L4 层的零信任隧道。\n  - **功能**:\n    - **安全**：提供 mTLS 加密和基于 SPIFFE ID 的身份验证，确保节点和工作负载之间的安全通信。\n    - **可观测性**：收集 L4 层的 TCP 指标和日志。\n    - **连接多路复用和均衡**：在节点之间建立安全的流量隧道，以优化连接和网络性能。\n    - **多租户架构**：单个 ztunnel 可以代表同一节点上的多个工作负载进行 L4 数据平面功能处理，这与每个应用 Pod 拥有自己代理的 Sidecar 模式形成对比。\n    - **证书管理**：ztunnel 代表节点内的所有 Pod 从 Istio 控制平面 (\u0060istiod\u0060) 获取 mTLS 证书，并负责证书的管理和轮换。\n  - **接口**:\n    - **\u0060pistioin\u0060 和 \u0060pistioout\u0060**：用于与节点上的 \u0060istioin\u0060 和 \u0060istioout\u0060 接口通过 GENEVE 隧道连接。\n\n## Waypoint Proxy\n\n![Waypoint Proxy](waypoint-proxy.svg)\n\n  - **定义**：Ambient 模式中的 L7 层代理，部署在每个命名空间级别，用于处理 L7 层请求。\n  - **功能**：提供 L7 授权策略，如基于 HTTP headers 的访问控制、L7 级别的遥测等。Waypoint Proxy 只处理需要的 L7 代理流量，其他 L4 流量由 ztunnel 处理。\n\n## GENEVE 隧道 (Generic Network Virtualization Encapsulation)\n\n![GENEVE 协议组成](geneve.svg)\n\n  - **定义**：用于在 Kubernetes 节点之间建立虚拟隧道连接，将流量从节点上的 Pod 转发到 ztunnel。\n  - **在 Ambient 模式中的应用**：GENEVE 隧道用于连接节点上的虚拟网络接口（\u0060istioin\u0060 和 \u0060istioout\u0060）与 ztunnel 内的接口（\u0060pistioin\u0060 和 \u0060pistioout\u0060）。\n\n## HBONE (HTTP-Based Overlay Network Environment)\n\n![HBONE 数据包格式](hbone.svg)\n\n\u003c!--\n\u0060\u0060\u0060\n\u002b-----------------\u002b\n|    IP Header    | \u003c-- 源 IP，目标 IP，协议类型\n\u002b-----------------\u002b\n|    TCP Header   | \u003c-- 源端口，目标端口，序列号，确认号，标志位等\n\u002b-----------------\u002b\n|    TLS Header   | \u003c-- 握手消息，证书，加密应用数据\n\u002b-----------------\u002b\n| HTTP\/2 \u0026 CONNECT| \u003c-- HTTP 方法，目标地址，请求头，路径等\n\u002b-----------------\u002b\n|  Application    | \u003c-- 应用层数据，字节流，例如 HTTP 请求\n\u002b-----------------\u002b\n\u0060\u0060\u0060\n--\u003e\n\n  - **定义**：Istio 特有的安全隧道协议，用于在 Ambient 模式组件之间传输数据。HBONE 是一种基于 HTTP\/2 和 HTTP CONNECT 建立的安全 mTLS 加密通道。\n  - **实现方式**：通过 HTTP\/2 进行多路复用，通过 HTTP CONNECT 建立隧道，并使用 mTLS 确保安全性。详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## Istioin 和 Istioout 虚拟接口\n\n![Ambient 模式中两个位于两个不同节点上的 Pod 访问路径](ambient-ztunnel-routing.svg)\n\n  - **定义**：由 Istio CNI 插件在每个节点上配置的两个虚拟接口，用于处理进入和离开节点的流量。\n  - **功能**：\u0060istioin\u0060 处理进入节点的流量，\u0060istioout\u0060 处理离开节点的流量。两者通过 GENEVE 隧道连接到 ztunnel 中相应的接口。\n\n## iptables 和流量重定向\n\n  - **定义**：用于配置 Linux 内核中的流量规则，将来自 Ambient 工作负载的流量进行重定向和标记。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件通过 iptables 规则，将流量标记并重定向到 \u0060istioin\u0060 或 \u0060istioout\u0060，然后通过 GENEVE 隧道传递给 ztunnel。\n\n## 流量拦截与重定向 (Traffic Redirection)\n\n  - **定义**：Ambient 模式中，ztunnel 负责透明拦截所有进出 \u0022in-mesh\u0022 Pod 的流量并将其加密后重定向到其他节点上的目标 Pod，确保网络流量符合服务网格的安全策略。\n  - **机制**：通过 Istio CNI 插件安装的 iptables 规则或 eBPF 程序，ztunnel 能够透明地捕获工作负载的流量，并在不改变客户端应用的情况下进行安全代理。\n\n## 流量路径分类\n\n  - **Out of Mesh**：Pod 没有加入服务网格，流量不会被 Ambient 数据平面处理。\n  - **In Mesh**：Pod 被纳入 Ambient 数据平面，L4 层的流量被 ztunnel 拦截和处理，提供 L4 授权和安全加密。\n  - **In Mesh, Waypoint Enabled**：Pod 被纳入 Ambient 数据平面且启用了 waypoint proxy，L7 层的流量通过 waypoint 进行高级策略处理。\n\n## TPROXY\n\n![TPROXY 作为透明代理，客户端和服务端都对其无感知](tproxy.svg)\n\n  - **定义**：Linux 内核功能，用于透明拦截和重定向网络流量。\n  - **在 Ambient 模式中的应用**：ztunnel 使用 TPROXY 来拦截和处理流量，保留原始源 IP 和端口信息，从而实现透明代理功能。\n\n## Mutual TLS (mTLS)\n\n![Istio 中的安全身份架构（以 Sidecar 模式为例）](istio-mtls-process.svg)\n\n  - **定义**：一种双向 TLS 认证机制，确保通信双方的身份验证和数据加密。\n  - **在 Ambient 模式中的应用**：通过 ztunnel 和 waypoint proxy 确保工作负载之间的 mTLS 加密，实现零信任安全。\n\n详见 [如何理解 Istio 中的 MTLS 流量加密？](\/blog\/understanding-the-tls-encryption-in-istio\/)\n\n## SPIFFE ID\n\n![SPIFFE ID 格式](spiffe.svg)\n\nIstio 服务网格中所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式：\u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n  - **定义**：用于标识工作负载的身份标识符，在服务网格中用于身份管理。\n  - **在 Ambient 模式中的应用**：SPIFFE ID 被用于对节点和工作负载进行身份验证，以确保网络通信的安全性。\n\n详见 [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n\n## eBPF (Extended Berkeley Packet Filter)\n\n  - **定义**：eBPF 是 Linux 内核中的一种技术，用于在内核空间中运行沙盒程序，实现网络数据包处理等功能。\n  - **在 Ambient 模式中的应用**：eBPF 可以替代传统的 iptables 和 GENEVE 隧道，用于流量重定向和管理。eBPF 更高效、复杂度更低且易于管理。\n  - **eBPF 程序**:\n    - 应用入站\n    - 应用出站\n    - Ztunnel 主机入站\n    - Ztunnel 入站\n  - **作用**：Istio CNI 使用 eBPF 程序将它们挂载在特定的 TC 点，用于处理应用和 ztunnel 的网络流量。\n\n## Waypoint Proxy 的弹性扩展\n\n![Waypoing Proxy 作为 Deployment 部署在 Kubernetes 中](ambient-waypoint-proxy-scale.svg)\n\n  - **定义**：在 Ambient 模式中，waypoint proxy 可以根据流量需求动态扩展，而无需为每个工作负载实例部署独立代理。\n  - **优势**：通过动态扩展 waypoint proxy，可以降低基础设施成本并提高资源利用率。\n\n## Ztunnel 的弹性和故障恢复\n\n  - **定义**：ztunnel 部署为 DaemonSet，如果 ztunnel 容器失效，Kubernetes 会自动重新调度，以确保节点流量的继续处理。\n  - **特点**：使得故障的影响范围最小化，仅影响该节点上的工作负载。\n\n## IP Set 和 ztunnel-pods-ips\n\n  - **定义**：IP Set 是用于存储 IP 地址的工具，\u0060ztunnel-pods-ips\u0060 是每个节点上用于存储 Ambient 网格 Pod IP 的集合。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件会将每个加入 Ambient 网格的 Pod IP 添加到 \u0060ztunnel-pods-ips\u0060 中，以确保这些 Pod 的流量可以被 iptables 规则识别和处理。\n\n## 连接多路复用 (Connection Multiplexing)\n\n  - **定义**：在单个物理连接中传输多条逻辑连接的技术。\n  - **在 Ambient 模式中的应用**：ztunnel 实现了连接多路复用，使多个工作负载可以共享相同的连接，提升网络效率。\n\n## 节点网络的虚拟接口对 (veth)\n\n  - 定义：每个 Pod 在运行时会在节点上创建一个虚拟接口对，用于将 Pod 的网络连接到节点的网络。\n  - 在 Ambient 模式中的应用：veth 接口用于将 Pod 的流量连接到节点的虚拟接口（如 \u0060istioin\u0060 和 \u0060istioout\u0060），从而将流量引导至 ztunnel 进行处理。\n\n## Waypoint Proxy 的流量路径\n\n![Waypoint Proxy 的流量路径](waypoint-proxy-routing.svg)\n\n  - **定义**：Waypoint Proxy 只参与服务器端的流量路径，作为 L7 代理执行服务端的请求。\n  - **应用场景**：当部署了 Waypoint Proxy 时，来自同一服务账户的工作负载将通过 ztunnel 重定向至 Waypoint Proxy 进行处理，然后到达目标 Pod，确保 L7 级别的策略和认证得以执行。\n\n## Istio CNI (Container Network Interface)\n\n- **定义**：Istio 的容器网络接口插件，用于在 Kubernetes 集群中自动配置流量拦截规则。\n- **功能**：Istio CNI 负责为每个新创建或加入网格的 Pod 设置必要的网络重定向规则。它通过修改 iptables 规则或应用 eBPF 程序来确保所有流量能够被 ztunnel 或 waypoint proxy 拦截和处理，从而实现服务网格的透明流量管理。\n- **Istio CNI Node Agent**：Istio CNI Node Agent 负责在每个节点上安装 Istio CNI 插件，并更新节点的 CNI 配置，确保当 Pod 加入服务网格时能够正确地配置流量重定向规则。在 Sidecar 模式中，CNI 插件通过 iptables 配置 Pod 的网络。在 Ambient 模式中，CNI 插件负责将新的 Pod 事件推送到 Ambient 监控服务器，以便配置 Pod 的网络重定向规则。\n\n## 总结\n\nIstio Ambient 模式通过将数据平面功能分为 L4 和 L7 层的独立组件，为用户提供了更轻量且灵活的服务网格解决方案。这种方式不仅简化了服务的部署，还大幅降低了资源开销。通过术语表的方式，我们探讨了 Ambient 模式中的各种核心概念，从 ztunnel 到 waypoint proxy，再到 iptables 和 eBPF 的使用，帮助你全面了解 Istio Ambient 模式的架构和运行机制。如果你对服务网格感兴趣或正在考虑如何优化微服务通信，希望这篇文章对你有所帮助。\n', '\/blog\/istio-ambient-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 实现 HTTP\/2 CONNECT 隧道：原理与实践', '深入讲解如何利用 HTTP\/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。', '\n在最近对 Istio Ambient 模式的研究中，我发现 HTTP2 Connect 方法被用作创建隧道的核心技术，以实现透明流量的拦截和转发。HTTP\/2 CONNECT 隧道是一种强大的工具，可以在已有的 HTTP\/2 连接中创建高效的隧道，用于传输原始的 TCP 数据。这篇文章通过一个简单的 Demo，展示了如何使用 Envoy 来实现 HTTP\/2 CONNECT 隧道的基本功能。\n\n## 什么是 HTTP2 Connect 方法以及 HBONE 隧道？\n\nHTTP2 Connect 方法是一种标准化的方式来创建隧道，用于透明地传输数据。特别是在 Istio 的 Ambient 模式中，它为代理数据平面之间的通信提供了一种高效的手段。HBONE（HTTP-Based Overlay Network Environment）隧道则是基于这种 HTTP2 Connect 技术的实现，用于 Istio 中的透明流量拦截和转发。通过使用 HBONE，数据可以有效地通过 HTTP2 隧道安全传输，替代了传统的 Sidecar 模式。这一创新设计极大地简化了服务网格的管理和部署。\n\nHBONE 是 Istio 特有的术语，它是一种安全隧道协议，用于在 Istio 组件之间进行通信。在当前的 Istio 实现中，HBONE 协议包含了三个开放标准：\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT 用于建立隧道连接，mTLS 用于安全地加密连接，而 HTTP\/2 用于在单一安全隧道中多路复用应用连接流并传输附加的流级元数据。更多关于 HBONE 隧道的细节可以参考官方文档：[HBONE 详细介绍](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## 使用 HTTP2 Connect 建立隧道的基本原理\n\nHTTP2 Connect 方法允许我们创建一个类似于 VPN 的隧道，通过这个隧道可以安全地传递数据。建立隧道的基本步骤如下：\n\n1. 首先，客户端向代理发送一个普通的 TCP 或 HTTP 链接请求。\n2. 代理接收到请求后，代表客户端向目标服务器发送一个带有 CONNECT 方法的 HTTP2 请求。\n3. 如果服务器允许建立隧道，那么它会返回一个 HTTP2 200 OK 的响应给代理。\n5. 随后，客户端、代理和服务器之间的双向流数据就可以通过这个隧道进行传输。\n\n这种方法能够使得数据的传输过程更加透明且安全，特别适用于需要高效通信和端到端加密的场景。\n\n下图展示了 HTTP2 Connect 方法建立隧道的基本过程。\n\n\u0060\u0060\u0060mermaid \u0022HTTP2 Connect 方法建立隧道的基本过程\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: 普通 TCP 请求\n    Proxy-\u003e\u003eServer: 发送 CONNECT 请求 (HTTP2 CONNECT)\n    Server--\u003e\u003eProxy: 返回 200 OK 响应\n    Proxy--\u003e\u003eClient: 转发 200 OK 响应\n    Client-\u003e\u003eProxy: 开始传输数据\n    Proxy-\u003e\u003eServer: 转发数据\n    Server-\u003e\u003eProxy: 返回处理后的数据\n    Proxy-\u003e\u003eClient: 转发处理后的数据\n\u0060\u0060\u0060\n\n![HTTP2 Connect 方法建立隧道的基本过程](1f4003a92425618f8bf5b9c1403169a7.svg)\n\n## Demo：使用 Envoy 与上游 Server 建立 HTTP\/2 Connect 隧道\n\n本示例展示了一个基础场景：\n\n1. **客户端**：向 Envoy 代理发送文本消息。\n2. **Envoy**：接收客户端的 TCP 数据，将其封装为 HTTP\/2 CONNECT 请求，并与上游服务器建立加密隧道。\n3. **服务器**：接收来自 Envoy 的 HTTP\/2 CONNECT 流量，解封装并返回响应给客户端。\n\n架构图如下：\n\n\u0060\u0060\u0060mermaid \u0022架构图\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![架构图](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n我们将使用 Node.js 来编写客户端和服务端，并将服务端和 Envoy 代理运行在容器中，在本地通过客户端访问 Envoy 代理从而达到访问客户端的目的。\n\n完整的目录结构如下：\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### 核心功能展示\n\n#### **1. HTTP\/2 CONNECT 隧道的基本实现**\n\n- 客户端通过普通的 TCP 连接与 Envoy 通信。\n- Envoy 将 TCP 数据封装为 HTTP\/2 CONNECT 请求，发送到上游服务器。\n- 服务器接收并解封装隧道中的数据，进行处理后返回响应。\n- 隧道通信对客户端完全透明。\n\n#### **2. Envoy 的透明代理能力**\n\n- Envoy 作为中间代理，将客户端与服务器之间的通信逻辑完全封装。\n- 客户端无需支持复杂的协议（如 HTTP\/2 或 TLS），Envoy 代理完成所有协议转换。\n\n#### **3. 加密通信的实现**\n\n- Envoy 与服务器之间的通信通过 TLS 加密，确保隧道内的数据安全。\n- 服务器终止 TLS，处理解密后的数据。\n\n#### **4. 隧道的简化使用场景**\n\n- 通过该 Demo，可以快速理解 HTTP\/2 CONNECT 隧道的建立和基本数据传输流程。\n\n### 环境准备\n\n#### 1. 安装 Node.js\n\n确保你的系统已安装 **Node.js**（版本 \u003e= **10.10.0**），因为 \u0060http2\u0060 模块在该版本后稳定。\n\n- **下载链接：** [Node.js 官方网站](https:\/\/nodejs.org\/)\n\n#### 2. 安装 Docker 和 Docker Compose\n\n- **Docker 下载链接：** [Docker 官方网站](https:\/\/www.docker.com\/get-started)\n- **Docker Compose 下载链接：** [Docker Compose 官方文档](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. 创建项目目录\n\n在你的工作空间中创建一个新目录并进入：\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### 生成自签名证书\n\n由于 Envoy 和服务器之间需要加密通信，我们需要生成包含正确配置的自签名证书。\n\n#### 1. 创建证书目录和 OpenSSL 配置文件\n\n创建 \u0060certs\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\n创建 \u0060openssl.cnf\u0060，内容如下：\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. 生成密钥和证书\n\n运行以下命令生成密钥和证书：\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\n这将在 \u0060certs\u0060 目录中生成 \u0060server.key\u0060 和 \u0060server.crt\u0060 文件。\n\n### 配置 Envoy 代理\n\n我们需要配置 Envoy，使其能够接受客户端的普通 TCP 连接，将数据通过 HTTP\/2 CONNECT 隧道传递给服务器。\n\n#### 1. 创建 Envoy 配置文件\n\n在项目根目录创建 \u0060envoy.yaml\u0060，内容如下：\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. 关键点\n\n- **Envoy 监听 TCP 连接**，将流量通过 **HTTP\/2 CONNECT 隧道**转发到服务器。\n- **客户端**只需与 **Envoy** 建立 TCP 连接，发送文本消息。\n- **Envoy**负责隧道的建立和加密，**客户端**无需感知。\n\n### 实现服务器\n\n#### 1. 创建服务器目录和文件\n\n在项目根目录创建 \u0060server\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\n在 \u0060server\u0060 目录中创建 \u0060server.js\u0060 和 \u0060Dockerfile\u0060。\n\n#### 2. 编写 \u0060server.js\u0060\n\n在 \u0060server\/server.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ 响应 200，建立隧道\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ 在隧道内处理数据\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ 回应客户端\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ 对于非 CONNECT 请求，返回 404\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**注意：**\n\n- 监听 \u0060secureConnection\u0060 事件，直接处理 TLS 连接后的 socket。\n- 在 socket 上接收数据，处理来自客户端的文本消息，并回复。\n\n#### 3. 创建 \u0060Dockerfile\u0060\n\n在 \u0060server\/Dockerfile\u0060 中添加以下内容：\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### 实现客户端\n\n#### 1. 创建客户端目录和文件\n\n在项目根目录创建 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\n在 \u0060client\u0060 目录中创建 \u0060client.js\u0060。\n\n#### 2. 编写 \u0060client.js\u0060\n\n在 \u0060client\/client.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ 创建与 Envoy 的 TCP 连接\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ 发送消息给服务器\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ 关闭连接\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**说明：**\n\n- **客户端**与 **Envoy** 建立普通的 TCP 连接，发送文本消息。\n- 该客户端的存在只是为了触发 Envoy 与服务器建立隧道。\n\n### 创建 Docker Compose 文件\n\n在项目根目录创建 \u0060docker-compose.yml\u0060：\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # 挂载证书目录\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # 挂载证书目录\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\n### 运行示例\n\n#### 1. 启动 Docker Compose\n\n在项目根目录下，运行：\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**预期输出：**\n\n- **Envoy 容器：** 显示启动信息和调试日志。\n- **服务器容器：** 显示 \u0060Secure HTTP\/2 server is listening on port 8080\u0060。\n\n#### 2. 运行客户端\n\n打开新的终端窗口，进入 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\n运行客户端：\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**预期输出：**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. 检查服务器日志\n\n在 Docker Compose 的输出中，你应该能看到服务器的日志：\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. 检查 Envoy 日志\n\n在 Envoy 的日志中，你可以看到它使用 **HTTP\/2 CONNECT 隧道**与服务器建立连接的记录。\n\n### 测试通信\n\n- **客户端**通过 TCP 连接向 **Envoy 代理**发送文本消息。\n- **Envoy**将客户端的 TCP 流量通过 **HTTP\/2 CONNECT 隧道**转发给 **服务器**。\n- **服务器**接收到来自客户端的消息，处理并回复。\n- **Envoy**将服务器的回复通过隧道传回给 **客户端**。\n- **客户端**收到服务器的回复。\n\n### 注意事项\n\n- **证书管理：** 确保证书正确配置，并在 Envoy 和服务器中正确使用。\n- **Docker 网络：** 使用 Docker Compose 定义的网络，容器可以通过服务名称互相通信。\n- **端口冲突：** 确保端口 \u006010000\u0060（Envoy）和 \u00608080\u0060（服务器）未被占用。\n- **TLS 配置：** 在示例中，Envoy 与服务器之间的通信使用 TLS 和 HTTP\/2，确保了安全性。\n\n## 隧道建立过程\n\n下图展示了客户端、Envoy 代理和服务器之间的交互，反映了数据的传递和隧道连接的建立的流程。\n\n\u0060\u0060\u0060mermaid \u0022隧道建立流程\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% 客户端与 Envoy 建立 TCP 连接\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy 创建新的 TCP 代理会话\nNote over Envoy: 创建新的 TCP 代理会话 (ConnectionId: 0)\n\n%% Envoy 创建到上游服务器的连接\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: 尝试创建新的连接 (ConnectionId: 1)\n\n%% Envoy 与服务器建立 HTTP\/2 连接\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy 通过 HTTP\/2 CONNECT 建立隧道\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: 隧道建立成功\n\n%% 客户端发送数据\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% 客户端关闭连接\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: 隧道关闭\nNote over Envoy,Client: 连接关闭\n\n%% 连接关闭日志\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![隧道建立流程](f426fb19b797e505aed4758bdc372f45.svg)\n\n说明：\n\n1. **客户端与 Envoy 建立 TCP 连接**：\n    - 客户端向 Envoy 发起 TCP 连接请求。\n    - Envoy 接受连接，建立新的 TCP 代理会话（ConnectionId: 0）。\n2. **Envoy 创建到服务器的连接**：\n\n    - Envoy 尝试连接上游集群 \u0060tunnel_cluster\u0060，创建新的连接（ConnectionId: 1）。\n3. **建立 HTTP\/2 CONNECT 隧道**：\n\n    - Envoy 与服务器建立 HTTP\/2 连接。\n    - Envoy 发送 HTTP\/2 CONNECT 请求，目标主机名为 \u0060server:8080\u0060。\n    - 服务器响应 \u0060200 OK\u0060，隧道建立成功。\n4. **数据传输**：\n\n    - **消息传递循环**：\n        - 客户端发送数据（\u0060Message N\u0060）到 Envoy。\n        - Envoy 将数据通过隧道转发给服务器。\n        - 服务器处理数据并返回响应（\u0060Echo Message N\u0060）给 Envoy。\n        - Envoy 将响应转发给客户端。\n    - **日志记录**：\n        - 服务器记录收到的消息，例如 \u0060Received from client: Message N from client!\u0060。\n5. **连接关闭**：\n\n    - 客户端发送 FIN 请求，通知关闭连接。\n    - Envoy 将 FIN 转发给服务器，关闭隧道。\n    - 服务器响应 ACK 确认关闭。\n    - Envoy 向客户端发送 ACK，完成连接关闭。\n6. **日志记录**：\n\n    - Envoy 记录连接关闭日志，包括 ConnectionId 和统计信息。\n    - 服务器记录日志，显示流已由客户端结束，例如 \u0060Stream ended by client.\u0060。\n\n## 结语\n\n虽然这是一个入门示例，但它为理解和进一步探索 HTTP\/2 CONNECT 隧道功能提供了坚实的基础。在下一篇博客中讲解通过两个 Envoy 代理实现的隧道，带你进一步了解 Istio ambient 模式中的 HBONE 透明隧道。\n\n## 参考\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n - [Istio Ambient 模式流量管理实现机制详解（一）- 赵化冰的博客 | Zhaohuabing Blog](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n', '\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入讲解如何利用 HTTP/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ambient-mesh-l4-traffic-path/">Istio Ambient 模式中的透明流量劫持四层网络路由路径详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的透明流量劫持四层网络路由路径详解', '本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。', '\n本文通过动手操作，带领读者一步步了解 Istio ambient 模式中的四层流量路径。如果你还不了解什么是 Ambient 模式，以下文章可以帮助你了解：\n\n- [关于 Istio 推出 Ambient 数据平面模式的看法](\/blog\/istio-ambient-mode\/)\n- [Istio 无 sidecar 代理数据平面 ambient 模式简介](https:\/\/cloudnativecn.com\/blog\/introducing-ambient-mesh\/)\n- [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnativecn.com\/blog\/ambient-security\/)\n- [什么是 Ambient Mesh，它与 sidecar 模式有什么区别？](https:\/\/cloudnativecn.com\/blog\/what-is-ambient-mesh\/)\n\n如果你想略过实际动手步骤，只是想知道 Ambient 模式中的四层流量路径，请看下面服务 A 的一个 Pod 访问不同节点上服务 B 的 Pod 的四层流量路径图。\n\n![Ambient 模式中的四层流量路径](ambient-mesh-l4-traffic-path.svg)\n\n## 原理 {#principles}\n\nAmbient 模式使用 **tproxy** 和 **HBONE** 这两个关键技术实现透明流量劫持和路由的：\n\n- 使用 tproxy 将主机 Pod 中的流量劫持到 Ztunnel（Envoy Proxy）中，实现透明流量劫持；\n- 使用 HBONE 建立在 Ztunnel 之间传递 TCP 数据流隧道；\n\n### 什么是 tproxy？{#what-is-tproxy}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt) 。\n\n### 什么是 HBONE？{#what-is-hbone}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n## 环境说明 {#environment}\n\n在开始动手操作之前，需要先说明一下笔者的演示环境，本文中对应的对象名称：\n\n| 代号           | 名称                                         | IP            |\n| -------------- | -------------------------------------------- | ------------- |\n| 服务 A Pod     | sleep-5644bdc767-2dfg7                       | 10.4.4.19     |\n| 服务 B Pod     | productpage-v1-5586c4d4ff-qxz9f              | 10.4.3.20     |\n| Ztunnel A Pod  | ztunnel-rts54                                | 10.4.4.18     |\n| Ztunnel B Pod  | ztunnel-z4qmh                                | 10.4.3.14     |\n| 节点 A         | gke-jimmy-cluster-default-pool-d5041909-d10i | 10.168.15.222 |\n| 节点 B         | gke-jimmy-cluster-default-pool-d5041909-c1da | 10.168.15.224 |\n| 服务 B Cluster | productpage                                  | 10.8.14.226   |\n\n注意：因为这些名称将在后续的命令行中用到，文中将使用代称，以便你在自己的环境中实验。\n\n笔者在 GKE 中安装了 Ambient 模式的 Istio，请参考[该步骤](\/blog\/istio-ambient-mode\/#setup)安装，注意不要安装 Gateway，以免启用 L7 功能，否则流量路径将于 L4 流量不同。\n\n下面我们将动手实验，深入探究 \u0060sleep\u0060 服务的 Pod 访问不同节点上 \u0060productpage\u0060 服务的 Pod 的四层流量路径。我们将分别检视 Pod 的 outbound 和 inbound 流量。\n\n## Outbound 流量劫持 {#outbound}\n\nAmbient mesh 的 pod 出站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioout\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 [IP 集](https:\/\/ipset.netfilter.org\/)，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioout\u0060 虚拟网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioout\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15001 端口；\n3. Envoy 对数据包进行处理，并与上游端点建立 HBONE 隧道（HTTP CONNECT），将数据包转发到上游。\n\n### 检查节点 A 上的路由规则 {#node-a-rules}\n\n登录到服务 A 所在的节点 A，使用 \u0060iptables-save\u0060 查看规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=3 4 6 35\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A PREROUTING -m comment --comment \u0022kubernetes service portals\u0022 -j KUBE-SERVICES\n-A ztunnel-POSTROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n-A ztunnel-PREROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n\/* 省略 *\/\n*mangle\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A INPUT -j ztunnel-INPUT\n-A FORWARD -j ztunnel-FORWARD\n-A OUTPUT -j ztunnel-OUTPUT\n-A OUTPUT -s 169.254.169.254\/32 -j DROP\n-A POSTROUTING -j ztunnel-POSTROUTING\n-A ztunnel-FORWARD -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-FORWARD -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-INPUT -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-INPUT -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-OUTPUT -s 10.4.4.1\/32 -j MARK --set-xmark 0x220\/0xffffffff\n-A ztunnel-PREROUTING -i istioin -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioin -j RETURN\n-A ztunnel-PREROUTING -i istioout -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioout -j RETURN\n-A ztunnel-PREROUTING -p udp -m udp --dport 6081 -j RETURN\n-A ztunnel-PREROUTING -m connmark --mark 0x220\/0x220 -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING ! -i veth300a1d80 -m connmark --mark 0x210\/0x210 -j MARK --set-xmark 0x40\/0x40\n-A ztunnel-PREROUTING -m mark --mark 0x40\/0x40 -j RETURN\n-A ztunnel-PREROUTING ! -s 10.4.4.18\/32 -i veth300a1d80 -j MARK --set-xmark 0x210\/0x210\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -i veth300a1d80 -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -p udp -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n{{\u003c\/highlight\u003e}}\n\niptables 规则说明：\n\n- 第 3 行：PREROUTING 链是最先运行的，所有数据包将先进入 \u0060ztunnel-PREROUTING\u0060 链；\n- 第 4 行：将数据包发往 \u0060KUBE-SERVICES\u0060 链，在那里将 Kubernetes Service 的 Cluster IP 进行 DNAT 转换为 Pod IP；\n- 第 6 行：带有 \u00600x100\/0x100\u0060 标记的数据包通过 PREROUTING 链，不再经过 \u0060KUBE-SERVICES\u0060 链；\n- 第 35 行：这是添加到 \u0060ztunnel-PREROUTING\u0060 链上的最后一条规则，进入 \u0060ztunnel-PREROUTING\u0060 链中的在 \u0060ztunnel-pods-ips\u0060 IP 集中的所有 TCP 数据包都会被打上 \u00600x100\/0x100\u0060 的标记，它将覆盖前面的所有标记；\n\n{{\u003ccallout note \u0022关于 iptables 设置 mark 和 xmark 标记\u0022\u003e}}\n\n\u0060MARK\u0060 这个扩展目标可以用来给数据包打标记，标记分两种：一种是用于标记链接的 \u0060ctmark\u0060，一种是用于标记数据包的 \u0060nfmark\u0060 。\u0060nfmark\u0060占四个字节共 32 位，我们可以把它看成是一个长度为 32 位的无符号整数，一般用 16 进制来表示。\n\nMark 的设置一共有五个选项，分别是 \u0060--set-xmark\u0060、\u0060--set-mark\u0060、\u0060--and-mark\u0060、\u0060--and-mark\u0060、\u0060--or-mark\u0060 和 \u0060--xor-mark\u0060。在本文用到了前两种，下面将分别为大家介绍。\n\n**\u0060--set-xmark value[\/mask]\u0060**\n\n上面的 \u0060value\u0060 和掩码 \u0060mask\u0060 都是 32 位无符号整数，一般用 16 进制表示。内核设置数据包 nfmark 值的流程分为两步：\n\n1. 首先，内核会先用 mask 预处理数据包原来的 nfmark，处理方法是：如果 mask 的第 N 位（二进制）为 1，则将数据包的 nfmark 第的 N 位（二进制）清零（Zero out） ，如果 mask 的第 N 位为 0，那么数据包的 nfmark 位保持不变\n2. 再用上面预处理后的 nfmark 和 value 做异或运算，得到数据包最后的 nfmark 值。\n\n举个例子：假设我们设置了 \u0060--set-xmark 0x4000\/0xffffffff\u0060，掩码为 \u00600xffffffff\u0060，掩码表示为二进制的话 32 位每一位都是 \u00601\u0060，那么内核首先会将数据包原来的 \u0060nfmark\u0060 所有的位都清零（异或运算，相当于是先把 \u0060nfmark\u0060 置 0），然后再和 value 做异或操作，那么得到的最后的 \u0060nfmark\u0060 值就是 \u00600x4000\u0060。所以，数据包经过这条规则后，它的 nfmark 值就是 \u00600x4000\u0060。\n\n上面的掩码 \u0060mask\u0060 是个可选项，如果没有设置的话，默认为 \u00600xffffffff\u0060。\n\n根据上面的规则，省略 \u0060mask\u0060 的值或者将 \u0060mask\u0060 和 \u0060value\u0060 的值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF XOR value =value\u0060，\u0060value XOR value XOR value = value\u0060。\n\n**\u0060--set-mark value[\/mask]\u0060**\n\n设置步骤与上文类似。第一步预处理也是将原来的 \u0060nfmark\u0060 与 mask 进行异或运算，第二步不同，该方法是将预处理的 nfmark 和 value 做或（OR）运算。\n\n根据上面的规则，省略 \u0060mask\u0060 的值，或者将 \u0060mask\u0060 与 \u0060value\u0060 值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF OR value = value\u0060，\u00600 OR value = value\u0060）。\n\n查看 [netfilter 文档](https:\/\/ipset.netfilter.org\/iptables-extensions.man.html#lbDD) 了解详情。\n\n{{\u003c\/callout\u003e}}\n\n通过执行以上 iptables 规则，可以确保 Ambient Mesh 仅拦截 \u0060ztunnel-pods-ips\u0060 IP 集 Pod 中的数据包并给数据包打上 \u00600x100\/0x100\u0060 标记（\u0060nfmark\u0060，格式为 \u0060值\/掩码\u0060，值和掩码都是 32 位的二进制整数，），而不影响其他 Pod。\n\n{{\u003ccallout note \u0022关于 ztunnel-pods-ips IP 集\u0022\u003e}}\n\n\u0060ztunnel-pods-ips\u0060 是由 Istio CNI 创建的 [IP 集（IP Set）](https:\/\/ipset.netfilter.org\/)，这里面保存着该节点上 Ambient Mesh 中的所有 Pod 的 IP 地址。IP 集是 Linux 内核中的一个框架，可由 [ipset](https:\/\/ipset.netfilter.org\/ipset.man.html) 实用程序管理。IP 集可以存储不同类型的数据，例如 IP 地址、网络、（TCP\/UDP）端口号、MAC 地址、接口名称或它们的组合，从而确保在条目与集合匹配时具有闪电般的速度。\n\n{{\u003c\/callout\u003e}}\n\n{{\u003cdetail \u0022用 \u0060iptables -t nat -L\u0060 按顺序查看 iptables 规则，将可以更明显的看到路由路径。\u0022\u003e}}\n\n\u0060\u0060\u0060bash\n$ iptables -t nat -L\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n# 数据包首先进入 ztunnel-PREROUTING 链处理\nztunnel-PREROUTING  all  --  anywhere             anywhere\n# 然后进入 KUBE-SERVICES 链处理\nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nztunnel-POSTROUTING  all  --  anywhere             anywhere            \nKUBE-POSTROUTING  all  --  anywhere             anywhere             \/* kubernetes postrouting rules *\/\nIP-MASQ    all  --  anywhere             anywhere             \/* ip-masq: ensure nat POSTROUTING directs all non-LOCAL destination traffic to our custom IP-MASQ chain *\/ ADDRTYPE match dst-type !LOCAL\n\n\/* Omit KUBE-SVC chains *\/\n\nChain ztunnel-POSTROUTING (1 references)\ntarget     prot opt source               destination         \nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\nChain ztunnel-PREROUTING (1 references)\ntarget     prot opt source               destination   \n# 通过所有被打上 0x100\/0x100 标记的数据包\nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\u0060\u0060\u0060\n\n{{\u003c\/detail\u003e}}\n\n我们再查看一下该节点的路由规则：\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n路由表将按顺序执行，第一列表示的是路由表的优先级，第二列表示要查找或跳转的路由表。你会看到所有带有 \u00600x100\/0x100\u0060 标记的数据包将查找 101 路由表。我们再查看一下该路由表：\n\n\u0060\u0060\u0060bash\n$ ip route show table 101\ndefault via 192.168.127.2 dev istioout \n10.4.4.18 dev veth52b75946 scope link \n\u0060\u0060\u0060\n\n你会看到 \u0060101\u0060 路由表中带有关键字 \u0060via\u0060 ，这表示数据包将通过网关传输，查看 [ip route 命令的用法](http:\/\/linux-ip.net\/html\/tools-ip-route.html#tools-ip-route-show)。所有数据包被通过 \u0060istioout\u0060 网卡发送到网关（IP 是 \u0060192.168.127.2\u0060）。另一行表示是当前节点上 ztunnel pod 的路由链路。\n\n{{\u003ccallout note  \u0022关于 101 路由表\u0022\u003e}}\n所谓路由表（Routing Table），指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。为了完成这项工作，在路由器中保存着各种传输路径的相关数据，供路由选择时使用，表中包含的信息决定了数据转发的策略。路由表根据其建立的方法，可以分为**动态路由表**和**静态路由表**。\n\n101 路由表是由 Istio CNI 创建的，它的作用是将带有 \u00600x100\/0x00\u0060 fwmark 的数据包转发到 ztunnel 中。\n\n在 Linux 系统中，用户可以自定义编号 1 到 252 的路由表，Linux 系统维护了 4 个路由表：\n\n- 0：系统保留表\n- 253：defulte 表，没特别指定的默认路由都放在改表\n- 254：main 表，没指明路由表的所有路由放在该表，默认表，我们使用 \u0060ip route list\u0060 或 \u0060route -n\u0060 或 \u0060netstat -rn\u0060 查看的路由记录即为 main 表中的记录\n- 255：locale 表，保存本地接口地址，广播地址、NAT 地址 由系统维护，用户不得更改\n\n{{\u003c\/callout\u003e}}\n\n我们再查看一下 \u0060istioout\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioout\n24: istioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 62:59:1b:ad:79:01 brd ff:ff:ff:ff:ff:ff\n    geneve id 1001 remote 10.4.4.18 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535\n    inet 192.168.127.1\/30 brd 192.168.127.3 scope global istioout\n       valid_lft forever preferred_lft forever\n    inet6 fe80::6059:1bff:fead:7901\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\nPod A 中的 \u0060istioout\u0060 网卡通过 Geneve tunnel 与 ztunnel A 中的 \u0060pstioout\u0060 网卡连通。\n\n{{\u003ccallout note \u0022关于 istioout 网卡\u0022\u003e}}\n\n\u0060istioout\u0060 是一个 [Geneve（Generic Network Virtualization Encapsulation）](https:\/\/datatracker.ietf.org\/doc\/html\/draft-gross-geneve-00)类型的虚拟网卡，它的 IP 是 \u0060192.168.127.1\u0060，远端是 \u006010.4.2.19\u0060（节点 A 上的 ztunnel Pod 的 IP），网关是 \u0060192.168.127.2\u0060（节点 A 上 ztunnel Pod 中 \u0060pistioout\u0060 网卡的 IP，在下文会看到）。\n\n{{\u003c\/callout\u003e}}\n\n### 检查 Ztunnel A 上的路由规则 {#ztunnel-a-rules}\n\n进入 Ztunnel A Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11-20\u0022\u003e}}\n$ ip -d a\n1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 minmtu 0 maxmtu 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 127.0.0.1\/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0@if16: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1460 qdisc noqueue state UP group default \n    link\/ether 06:3e:d1:5d:95:16 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 minmtu 68 maxmtu 65535 \n    veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 10.4.2.1\/24 brd 10.4.4.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: pistioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether 06:18:ee:29:7e:e4 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.2\/30 scope global pistioin\n       valid_lft forever preferred_lft forever\n4: pistioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether aa:40:40:7c:07:b2 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1001 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.127.2\/30 scope global pistioout\n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n你将发现其中有两个网卡：\n\n- \u0060pistioin\u0060 ：IP 为 \u0060192.168.126.2\u0060\n- \u0060pistioout\u0060：IP 为 \u0060192.168.127.2\u0060\n\n{{\u003ccallout note \u0022关于 pistioin 和 pistioout 网卡\u0022\u003e}}\n\n这两个网卡都是由 ztunnel 中的 init 容器创建的 Geneve 类型的虚拟网卡，其 IP 地址也是固定的，如果你查看 ztunnel 的 YAML 配置将发现其中的网卡创建命令，在此我们按下不表，因为 Ambient 模式还在开发初期，这些启动命令未来可能有很大变化，感兴趣的读者可以自行查阅。\n\n{{\u003c\/callout\u003e}}\n\n自 Pod A 的流量进入 ztunnel 之后，如何对流量进行处理呢？答案是 iptables，查看 ztunnel A 中的 iptables 规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n*mangle\n:PREROUTING ACCEPT [185880:96984381]\n:INPUT ACCEPT [185886:96984813]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [167491:24099839]\n:POSTROUTING ACCEPT [167491:24099839]\n-A PREROUTING -j LOG --log-prefix \u0022mangle pre [ ztunnel-rts54] \u0022\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioout -p tcp -j TPROXY --on-port 15001 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\/* 省略 *\/\n{{\u003c\/highlight\u003e}}\n\n可以看到 ztunnel A 中的所有发往 \u0060pistioin\u0060 网卡的 TCP 流量透明转发到 \u006015001\u0060 端口（Envoy 的 outbound 端口），并打上了 \u00600x400\/0xfff\u0060 的标记。这个标记可以保证数据包发往正确的网卡。\n\n{{\u003ccallout note \u0022关于 tproxy\u0022\u003e}}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt)。\n\n{{\u003c\/callout\u003e}}\n\n查看 Ztunnel A 中的路由表。\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n20000:  from all fwmark 0x400\/0xfff lookup 100\n20001:  from all fwmark 0x401\/0xfff lookup 101\n20002:  from all fwmark 0x402\/0xfff lookup 102\n20003:  from all fwmark 0x4d3\/0xfff lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n你会看到所有标记 \u00600x400\/0xfff\u0060 的数据包应用 101 路由表，我们查看该路由表详情：\n\n\u0060\u0060\u0060bash\n$ ip route show table 100\nlocal default dev lo scope host \n\u0060\u0060\u0060\n\n你会看到这是一条本地路由，数据包发送到本地的回环网卡，即 \u0060127.0.0.1\u0060。\n\n以上就是 Pod 中出站流量的透明劫持过程。\n\n## Ztunnel A 上的出站流量路由 {#ztunnel-a-outbound}\n\n出站流量在被劫持到 Ztunnel 上，进入 Envoy 的 15001 端口处理。下面我们来查看 Ztunnel 如何路由出站流量。\n\n注意：Ztunnel 中的 Envoy 过滤器规则与 Sidecar 模式中的 Envoy 过滤器规则完全不同，我们不使用 \u0060istioctl proxy-config\u0060 命令来检视 Listener、Cluster、Endpoint 等配置，而是直接导出 ztunnel 中的 Envoy 完整配置。 \n\n我们直接在自己的本地机器上远程获取 ztunnel A 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system ztunnel-hptxk -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-a-all-include-eds.json\n\u0060\u0060\u0060\n\n注意：不要使用 \u0060istioctl proxy-config all ztunnel-rts54 -n istio-system\u0060 命令来获取 Envoy 配置，因为这样获取的配置中不包含 EDS 部分。导出的 Json 文件将有上万行，为了便于阅读，建议使用 [fx](https:\/\/github.com\/antonmedv\/fx) 或其他工具来解析该文件。\n\n### ztunnel_outbound 监听器 {#ztunnel_outbound-listener}\n\n在这个 Envoy 配置中包含了该节点上的所有 Pod 访问的流量规则配置，查看 \u0060ztunnel_outbound\u0060 Listener 部分配置（因配置太多，省略部分内容）：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 14 43 59 62 64 69 76 82 85 88-123\u0022\u003e}}\n{\n \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15001\n    }\n   },\n   \u0022filter_chains\u0022: [{...},...],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_dst\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_dst.v3.OriginalDst\u0022\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_src\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_src.v3.OriginalSrc\u0022,\n      \u0022mark\u0022: 1234\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.workload_metadata\u0022,\n     \u0022config_discovery\u0022: {\n      \u0022config_source\u0022: {\n       \u0022ads\u0022: {},\n       \u0022initial_fetch_timeout\u0022: \u002230s\u0022\n      },\n      \u0022type_urls\u0022: [\n       \u0022type.googleapis.com\/istio.telemetry.workloadmetadata.v1.WorkloadMetadataResources\u0022\n      ]\n     }\n    }\n   ],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [\n    {\n     \u0022description\u0022: \u0022Set socket mark to packets coming back from outbound listener\u0022,\n     \u0022level\u0022: \u00221\u0022,\n     \u0022name\u0022: \u002236\u0022,\n     \u0022int_value\u0022: \u00221025\u0022\n    }\n   ],\n   \u0022access_log\u0022: [{...}],\n   \u0022default_filter_chain\u0022: {\u0022filters\u0022: [...], ...},\n   \u0022filter_chain_matcher\u0022: {\n    \u0022matcher_tree\u0022: {\n     \u0022input\u0022: {\n      \u0022name\u0022: \u0022port\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n      }\n     },\n     \u0022exact_match_map\u0022: {\n      \u0022map\u0022: {\n       \u002215001\u0022: {\n        \u0022action\u0022: {\n         \u0022name\u0022: \u0022BlackHoleCluster\u0022,\n         \u0022typed_config\u0022: {\n          \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n          \u0022value\u0022: \u0022BlackHoleCluster\u0022\n         }\n        }\n       }\n      }\n     }\n    },\n    \u0022on_no_match\u0022: {\n     \u0022matcher\u0022: {\n      \u0022matcher_tree\u0022: {\n       \u0022input\u0022: {\n        \u0022name\u0022: \u0022source-ip\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.SourceIPInput\u0022\n        }\n       },\n       \u0022exact_match_map\u0022: {\n        \u0022map\u0022: {\n         \u002210.168.15.222\u0022: {...},\n         \u002210.4.4.19\u0022: {\n          \u0022matcher\u0022: {\n           \u0022matcher_tree\u0022: {\n            \u0022input\u0022: {\n             \u0022name\u0022: \u0022ip\u0022,\n             \u0022typed_config\u0022: {\n              \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput\u0022\n             }\n            },\n            \u0022exact_match_map\u0022: {\n             \u0022map\u0022: {\n              \u002210.8.4.226\u0022: {\n               \u0022matcher\u0022: {\n                \u0022matcher_tree\u0022: {\n                 \u0022input\u0022: {\n                  \u0022name\u0022: \u0022port\u0022,\n                  \u0022typed_config\u0022: {\n                   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n                  }\n                 },\n                 \u0022exact_match_map\u0022: {\n                  \u0022map\u0022: {\n                   \u00229080\u0022: {\n                    \u0022action\u0022: {\n                     \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n                     \u0022typed_config\u0022: {\n                      \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n                      \u0022value\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022\n                     }\n                    }\n                   }\n                  }\n                 }\n                }\n               }\n              },\n              {...}\n             }\n            }\n           }\n          }\n         },\n         \u002210.4.4.7\u0022: {...},\n         \u002210.4.4.11\u0022: {...},\n        }\n       }\n      },\n      \u0022on_no_match\u0022: {\n       \u0022action\u0022: {\n        \u0022name\u0022: \u0022PassthroughFilterChain\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n         \u0022value\u0022: \u0022PassthroughFilterChain\u0022\n        }\n       }\n      }\n     }\n    }\n   }\n  },\n  \u0022last_updated\u0022: \u00222022-11-11T07:33:10.485Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n- 第 10、11、59、62、64、69、76、82、85 行：Envoy 监听 15001 端口，处理内核中使用 tproxy 转发的流量；对于目的地是 15001 端口的数据包直接抛弃，对于目的地是其他端口的流量再根据源 IP 地址匹配决定数据包去向；\n- 第 43 行：使用 \u0060IP_TRANSPARENT\u0060 套接字选项，开启 tproxy 透明代理，转发目的地非 ztunnel IP 的流量包；\n-  第 88 到 123 行：根据源 IP（\u006010.4.4.19\u0060 是 Pod A 的 IP）、目的 IP（\u006010.8.14.226\u0060 是服务 B 的 Cluster IP）和端口（9080）规则匹配，数据包将被发往 \u0060spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0060 集群。\n\n### Sleep 集群\n\n我们再查看一下该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=5 6 18 23-37\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   }\n  },\n  \u0022transport_socket_matches\u0022: [\n   {\n    \u0022name\u0022: \u0022internal_upstream\u0022,\n    \u0022match\u0022: {\n     \u0022tunnel\u0022: \u0022h2\u0022\n    },\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n      \u0022passthrough_metadata\u0022: [\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022tunnel\u0022\n       },\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022istio\u0022\n       }\n      ],\n      \u0022transport_socket\u0022: {\n       \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n       }\n      }\n     }\n    }\n   },\n   {\n    \u0022name\u0022: \u0022tlsMode-disabled\u0022,\n    \u0022match\u0022: {},\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  ]\n },\n \u0022last_updated\u0022: \u00222022-11-08T06:40:06.619Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该 Cluster 配置使用 EDS 获取端点\n- 第 18 行：对所有具有 \u0060tunnel: h2\u0060 元数据的字节流应用 [\u0060InternalUpstreamTransport\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/internal_upstream\/v3\/internal_upstream.proto#envoy-v3-api-msg-extensions-transport-sockets-internal-upstream-v3-internalupstreamtransport)，用于内部地址，定义位于同一代理实例中的环回用户空间 socket。除了常规字节流之外，该扩展还允许跨用户空间 socket 传递额外的结构化状态（\u0060passthrough_metadata\u0060）。目的是促进下游过滤器和上游内部连接之间的通信。与上游连接共享的所有过滤器状态对象也通过此传输 socket 与下游内部连接共享。\n- 第 23 到 37 行：向上游传递的结构化数据；\n\n### Sleep 集群的端点 {#sleep-endpoints}\n\n我们再检查下 EDS，你会发现在众多的 \u0060endpoint_config\u0060 中有这样一条：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=4 13 20-30\u0022\u003e}}\n{\n \u0022endpoint_config\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n  \u0022cluster_name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022endpoints\u0022: [\n   {\n    \u0022locality\u0022: {},\n    \u0022lb_endpoints\u0022: [\n     {\n      \u0022endpoint\u0022: {\n       \u0022address\u0022: {\n        \u0022envoy_internal_address\u0022: {\n         \u0022server_listener_name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n         \u0022endpoint_id\u0022: \u002210.4.3.20:9080\u0022\n        }\n       },\n       \u0022health_check_config\u0022: {}\n      },\n      \u0022health_status\u0022: \u0022HEALTHY\u0022,\n      \u0022metadata\u0022: {\n       \u0022filter_metadata\u0022: {\n        \u0022envoy.transport_socket_match\u0022: {\n         \u0022tunnel\u0022: \u0022h2\u0022\n        },\n        \u0022tunnel\u0022: {\n         \u0022address\u0022: \u002210.4.3.20:15008\u0022,\n         \u0022destination\u0022: \u002210.4.3.20:9080\u0022\n        }\n       }\n      },\n      \u0022load_balancing_weight\u0022: 1\n     }\n    ]\n   }\n  ],\n  \u0022policy\u0022: {\n   \u0022overprovisioning_factor\u0022: 140\n  }\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 4 行：截止 2022 年 11 月 14 日，实际在导出 Envoy 配置的时候并没有该字段，但是理应有这个字段，否则无法判断 Endpoint 属于哪个 Cluster；\n- 第 13 行：该端点的地址是一个 \u0060envoy_internal_address\u0060，Envoy 内部监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060；\n- 第 20 - 30 行：定义过滤器元数据，使用 HBONE 隧道传递给 Envoy 内部监听器；\n\n{{\u003ccallout warning \u0022关于 endpoint_config 中未显示 cluster_name 字段的问题\u0022\u003e}}\n\n这里的 [\u0060endpoint_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/endpoint\/v3\/endpoint.proto) 中缺少了必选的 \u0060cluster_name\u0060 字段，这可能是 Ambient 模式的一个 bug 导致了在导出 Envoy 的配置时缺少了该字段。我在 GItHub 上创建了一个 Issue 来追踪这个问题，详见 [Istio Issue-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)。\n\n{{\u003c\/callout\u003e}}\n\n### 通过 Envoy 内部监听器建立 HBONE 隧道 {#sleep-internal-upstream}\n\n我们再看下这个监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=16 18-28 40\u0022\u003e}}\n{\n \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.tcp_proxy\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\u0022,\n        \u0022stat_prefix\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022cluster\u0022: \u0022outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022access_log\u0022: [{...}, ...],\n        \u0022tunneling_config\u0022: {\n         \u0022hostname\u0022: \u0022%DYNAMIC_METADATA(tunnel:destination)%\u0022,\n         \u0022headers_to_add\u0022: [\n          {\n           \u0022header\u0022: {\n            \u0022key\u0022: \u0022x-envoy-original-dst-host\u0022,\n            \u0022value\u0022: \u0022%DYNAMIC_METADATA([\\\u0022tunnel\\\u0022, \\\u0022destination\\\u0022])%\u0022\n           }\n          }\n         ]\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \u0022use_original_dst\u0022: false,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    }\n   ],\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-08T06:40:06.750Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 14 行：数据包将被转发到 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群；\n- 第 18 - 28 行： [\u0060tunneling_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/network\/tcp_proxy\/v3\/tcp_proxy.proto#envoy-v3-api-msg-extensions-filters-network-tcp-proxy-v3-tcpproxy-tunnelingconfig) ，用来配置上游 HTTP CONNECT 隧道。另外该监听器中的 \u0060TcpProxy\u0060 过滤器将流量传给上游 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群。TCP 过滤器上设置了 HTTP CONNECT 隧道（承载发送到 \u006010.4.3.20:9080\u0060 的流量），供 \u0060productpage\u0060 所在节点的 ztunnel 使用。有多少个端点，就会创建多少条隧道。HTTP 隧道是 Ambient 组件之间安全通信的承载协议。同时在隧道中的数据包添加了 \u0060x-envoy-original-dst-host\u0060 header，根据上一步 EDS 中选择的端点的 \u0060metadata\u0060 里的参数设置目的地址。前面 EDS  选择的端点是 \u006010.4.3.20:9080\u0060 ，那么这里的 tunnel 监听器就会 header 的值设置为 \u006010.4.3.20:9080\u0060，请留意这个 header，它会在隧道的另一端被用到；\n- 第 40 行：监听器中首先执行监听器过滤器，\u0060set_dst_address\u0060 过滤器将上游地址设置为下游的目的地址。\n\n{{\u003ccallout note \u0022关于 HBONE 隧道\u0022\u003e}}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n{{\u003c\/callout\u003e}}\n\n### Sleep 集群的 HBONE 隧道端点 {#sleep-tunnel-cluster}\n\n我们再查看一下 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 22-41 45-47\u0022\u003e}}\n {\n \u0022version_info\u0022: \u00222022-11-11T07:30:10Z\/37\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022outbound_pod_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022connect_timeout\u0022: \u00222s\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022cleanup_interval\u0022: \u002260s\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\u0022,\n    \u0022common_tls_context\u0022: {\n     \u0022tls_params\u0022: {\n      \u0022tls_minimum_protocol_version\u0022: \u0022TLSv1_3\u0022,\n      \u0022tls_maximum_protocol_version\u0022: \u0022TLSv1_3\u0022\n     },\n     \u0022alpn_protocols\u0022: [\n      \u0022h2\u0022\n     ],\n     \u0022tls_certificate_sds_secret_configs\u0022: [\n      {\n       \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep~sleep-5644bdc767-2dfg7~85c8c34e-7ae3-4d29-9582-0819e2b10c69\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     ]\n    }\n   }\n  },\n  \u0022original_dst_lb_config\u0022: {\n   \u0022upstream_port_override\u0022: 15008\n  },\n  \u0022typed_extension_protocol_options\u0022: {\n   \u0022envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022,\n    \u0022explicit_http_config\u0022: {\n     \u0022http2_protocol_options\u0022: {\n      \u0022allow_connect\u0022: true\n     }\n    }\n   }\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:30:10.754Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，即前文中 EDS 获取到的地址 \u006010.4.3.20:9080\u0060；\n- 第 22 - 41 行：配置了上游的 TLS 证书；\n- 第 45 - 48 行：将上游端口修改为 15008；\n\n以上就是使用 tproxy 和 HBONE 隧道实现的出站流量透明劫持的全过程。\n\n## Inbound 流量劫持 {#inbound}\n\n节点 B 接收节点 A 对 \u006010.4.3.20:15008\u0060 的请求。Ambient 模式的入站流量劫持与出站流量类似，同样使用 tproxy 和 HBONE 实现透明流量劫持。\n\nAmbient mesh 的 pod 入站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioin\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 IP 集，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioin\u0060 虚拟机网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioin\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15008 端口；\n3. Envoy 对数据包进行处理后转发给 Pod B。\n\n因为操作步骤与上文中的检查出站流量时相同，因此下文将省略部分输出。\n\n### 检查节点 B 上的路由规则 {#node-b-rules}\n\n登录到服务 B 所在的节点 B，查看节点上的 iptables：\n\n\u0060\u0060\u0060bash\n$ iptables-save\n\/* 省略 *\/\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n\/* 省略 *\/\n\u0060\u0060\u0060\n\n你将看到在前文中提到的给所有 \u0060ztunnel-pods-ips\u0060 IP 集中 Pod 发送的数据包打上 \u00600x100\/0x100\u0060 标记的上一条命令：给所有数据包打上 \u00600x200\/0x200\u0060 标记，然后继续执行 iptables。\n\n查看节点 B 上的路由表：\n\n\u0060\u0060\u0060bash\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n所有 Ambient Mesh 节点中的路由表数量和规则是一样的，路由表规则将按顺序执行，首先查找 \u0060local\u0060 表，然后所有带有 \u00600x200\/0x200\u0060 标记的数据包将首先跳转到 \u0060main\u0060 表（其中定义了 veth 路由），然后查找 \u0060100\u0060 表，在 \u0060100\u0060 表中有以下规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=8\u0022\u003e}}\n$ ip route show table 100\n10.4.3.14 dev veth28865c45 scope link \n10.4.3.15 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.16 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.17 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.18 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.19 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.20 via 192.168.126.2 dev istioin src 10.4.3.1\n{{\u003c\/highlight\u003e}}\n\n你会看到发往 \u006010.4.3.20\u0060 的数据包将被路由到 \u0060istioin\u0060 网卡上的 \u0060192.168.126.2\u0060 网关。\n\n查看 \u0060istioin\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioin \n17: istioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 36:2a:2f:f1:5c:97 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.3.14 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.1\/30 brd 192.168.126.3 scope global istioin\n       valid_lft forever preferred_lft forever\n    inet6 fe80::342a:2fff:fef1:5c97\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n从输出中可以看到，\u0060istioin\u0060 是一个 Geneve 类型虚拟网卡，它创建了一个 Geneve 隧道，远端的 IP 是 \u006010.4.3.14 \u0060，这是 Ztunnel B 的 Pod IP。\n\n### 检查 Ztunnel B Pod 上的路由规则 {#ztunnel-b-rules}\n\n进入 Ztunnel B Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息，你会看到有一个 \u0060pistioout\u0060 网卡，它的 IP 为 \u0060192.168.127.2\u0060，这正是与 \u0060istioout\u0060 虚拟网卡建立的 Geneve 隧道的远端。\n\n使用 \u0060iptables-save\u0060 查看 Pod 内的 iptables 规则，你会看到：\n\n\u0060\u0060\u0060bash\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\u0060\u0060\u0060\n\n所有发往 \u006010.4.3.20:15008\u0060 的流量将使用 tproxy 被路由到 15008 端口。\n\n{{\u003ccallout note \u0022关于 15006 和 15008 端口\u0022\u003e}}\n\n- 15006 端口用于处理非加密的（plain）TCP 数据包。\n- 15008 端口用于处理加密的（TLS）TCP 数据包。\n\n{{\u003c\/callout\u003e}}\n\n以上就是 Pod 中入站流量的透明劫持过程。\n\n## Ztunnel B 上的入站流量路由 {#ztunnel-b-inbound}\n\n出站的 TLS 加密流量在被劫持到 Ztunnel 上，进入 Envoy 的 15008 端口处理。下面我们来查看 Ztunnel 如何路由入站流量。\n\n我们直接在自己的本地机器上远程获取 ztunnel B 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system \tztunnel-z4qmh -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-b-all-include-eds.json\n\u0060\u0060\u0060\n\n### ztunnel_inbound 监听器 {#ztunnel_inbound-listener}\n\n查看 \u0060ztunnel_inbound\u0060 监听器的详细信息：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 17-22 39-65 78-82\u0022\u003e}}\n\n{\n \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:12:01Z\/16\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15008\n    }\n   },\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filter_chain_match\u0022: {\n      \u0022prefix_ranges\u0022: [\n       {\n        \u0022address_prefix\u0022: \u002210.4.3.20\u0022,\n        \u0022prefix_len\u0022: 32\n       }\n      ]\n     },\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.rbac\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.rbac.v3.RBAC\u0022,\n        \u0022rules\u0022: {...},\n        \u0022stat_prefix\u0022: \u0022tcp.\u0022,\n        \u0022shadow_rules_stat_prefix\u0022: \u0022istio_dry_run_allow_\u0022\n       }\n      },\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_hcm\u0022,\n        \u0022route_config\u0022: {\n         \u0022name\u0022: \u0022local_route\u0022,\n         \u0022virtual_hosts\u0022: [\n          {\n           \u0022name\u0022: \u0022local_service\u0022,\n           \u0022domains\u0022: [\n            \u0022*\u0022\n           ],\n           \u0022routes\u0022: [\n            {\n             \u0022match\u0022: {\n              \u0022connect_matcher\u0022: {}\n             },\n             \u0022route\u0022: {\n              \u0022cluster\u0022: \u0022virtual_inbound\u0022,\n              \u0022upgrade_configs\u0022: [\n               {\n                \u0022upgrade_type\u0022: \u0022CONNECT\u0022,\n                \u0022connect_config\u0022: {}\n               }\n              ]\n             }\n            }\n           ]\n          }\n         ]\n        },\n        \u0022http_filters\u0022: [\n         {\n          \u0022name\u0022: \u0022envoy.filters.http.router\u0022,\n          \u0022typed_config\u0022: {\n           \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.http.router.v3.Router\u0022\n          }\n         }\n        ],\n        \u0022http2_protocol_options\u0022: {\n         \u0022allow_connect\u0022: true\n        },\n        \u0022access_log\u0022: [{...}],\n        \u0022upgrade_configs\u0022: [\n         {\n          \u0022upgrade_type\u0022: \u0022CONNECT\u0022\n         }\n        ]\n       }\n      }\n     ],\n     \u0022transport_socket\u0022: {\n      \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n      \u0022typed_config\u0022: {...} \n     },\n     \u0022name\u0022: \u0022inbound_10.4.3.20\u0022\n    },\n    {...}\n   ],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [{},...],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [{...}}],\n   \u0022access_log\u0022: [{...} ]\n  },\n  \u0022last_updated\u0022: \u00222022-11-14T03:54:07.040Z\u0022\n }\n}\n\n{{\u003c\/highlight\u003e}}\n\n从上面的配置中可以看出：\n\n- 发往 \u006010.4.3.20\u0060 的流量将被路由到 \u0060virtual_inbound\u0060 集群；\n- 第 78 - 82 行：[\u0060upgrade_type: \u0022CONNECT\u0022\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/route\/v3\/route_components.proto#config-route-v3-routeaction-upgradeconfig) 为 Envoy 的 HCM 启用 HTTP Connect 隧道，将该隧道中的 TCP 数据发送到上游；\n\n### virtual_inbound 集群 {#virtual_inbound-cluster}\n\n查看 \u0060virtual_inbound\u0060 集群的信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=6 9\u0022\u003e}}\n\n{\n \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022virtual_inbound\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022original_dst_lb_config\u0022: {\n   \u0022use_http_header\u0022: true\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:10:42.111Z\u0022\n}\n\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 7 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，表示使用下游的原始目的地作为路由目的地，即 \u006010.4.3.20:15008\u0060，显然这个地址中的端口不正确；\n- 第 9 行：[\u0060use_http_header\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/cluster\/v3\/cluster.proto#config-cluster-v3-cluster-originaldstlbconfig) 为 \u0060true\u0060 时将使用 HTTP header [\u0060x-envoy-original-dst-host\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#config-http-conn-man-headers-x-envoy-original-dst-host) 作为目的地址，而这个 header [在出站的 Ztunnel 中已设置](\/#sleep-internal-upstream)为 \u006010.4.3.20:9080\u0060，它将覆盖之前设置的目的地址；\n\n至此，入站流量被 ztunnel 准确地路由到了目的地。以上就是 Ambient 模式中不同节点间 L4 流量劫持和路由流程。\n\n## 总结 {#summary}\n\n为了方便演示，本文中展示的是不同节点上的服务 L4 网络访问数据包的路径，即使两个服务在同一个节点上路径也是类似的。根据本文中提供的操作说明，读者可以在自己的环境中尝试。Istio 的 Ambient 模式还在初级阶段，在笔者测试过程中，也发现导出的 Envoy 配置中 EDS 缺少 \u0060cluster_name\u0060 字段的问题（[Issue Istio-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)）。另外 Ambient 模式使用 Istio CNI 在节点中注入 iptables 规则，通过设置 \u0060nfmark\u0060 的方式拦截 Pod 的流量到 Ztunnel 中，这种方式可能造成对其他 CNI 的兼容性问题，[Merbridge](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/) 项目正在寻求使用 eBPF 来绕过 IPtables，从而无需安装 Istio CNI，这样也就不会存在 CNI 兼容性问题。\n\n在了解了 L4 流量路径之后，今后笔者会再分享 Ambient 模式中的 L7 流量路径，欢迎关注。\n\n## 参考{#reference}\n\n- [安装 Ambient Mesh - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/get-started-ambient\/)\n- [深入 Ambient Mesh - 流量路径 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/PpP0pmxdJR8PknHeR-pVHQ)\n- [一文读懂 Ambient Mesh 七层服务治理 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/TXMyxbzBSfuYNquOZJmZTg)\n- [深度剖析！Istio 共享代理新模式 Ambient Mesh - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/B0q73ACAvmY4SjW42A2GVw)\n- [Istio Ambient 模式流量管理实现机制详解（一）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n- [Istio Ambient 模式流量管理实现机制详解（二） - zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-2\/)\n- [Istio Ambient 模式流量管理实现机制详解（三）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-10-17-ambient-deep-dive-3\/)\n- [Merbridge 支持 Ambient Mesh，无惧 CNI 兼容性！- merbridge.io](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/)\n', '\/blog\/ambient-mesh-l4-traffic-path\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
