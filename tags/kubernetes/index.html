<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Kubernetes - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/kubernetes/" />
  <meta property="og:title" content="Kubernetes | Jimmy Song" />
  <meta property="twitter:title" content="Kubernetes | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/kubernetes/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Kubernetes
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/book/kubernetes-handbook/">Kubernetes 基础教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c"> 
             教程手册
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 基础教程', '本书起始于 2017 年 3 月，记录了本人从零开始学习和使用 Kubernetes 的心路历程，着重于经验分享和总结。', '\n{{\u003ccallout note 关于本教程\u003e}}\n本教程迁移自[《Kubernetes 中文指南——云原生应用架构实战手册》](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)，原手册使用 Gitbook 发布，内容涵盖 容器、Kubernetes、服务网格、Serverless 等云元生的多个领域，因内容过于宽泛，且 Gitbook 项目已停止维护，现将其中的 Kubernetes 教程部分独立成书，并使用 Hugo 重新构建。\n{{\u003c\/callout\u003e}}\n\n云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，Serverless 的兴起，使得云原生从基础设施层不断向应用架构层挺进，我们正处于一个云原生的新时代。\n\n[Kubernetes](http:\/\/kubernetes.io) 是 Google 于 2014 年 6 月基于其内部使用的 [Borg](https:\/\/research.google.com\/pubs\/pub43438.html) 系统开源出来的容器编排调度引擎，Google 将其作为初始和核心项目贡献给 [CNCF](https:\/\/cncf.io)（云原生计算基金会），近年来逐渐发展出了云原生生态。\n\nKubernetes 的目标不仅仅是一个编排系统，而是提供一个规范用以描述集群的架构，定义服务的最终状态，使系统自动地达到和维持该状态。Kubernetes 作为云原生应用的基石，相当于一个云原生操作系统，其重要性不言而喻。\n\n云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括 **容器**、**服务网格**、**微服务**、**不可变基础设施** 和 **声明式 API**。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。——CNCF（云原生计算基金会）。\n\n## 关于本书\n\nKubernetes Handbook 项目始于 2016 年底，开源于 2017 年 3 月，作为第一本系统介绍 Kubernetes 的中文电子书，其后经过不断完善。写作本书的过程中，笔者记录了从零开始学习和使用 Kubernetes 的历程，着重于经验总结和资料分享，亦有 Kubernetes 核心概念解析，希望能够帮助大家少走弯路，为大家介绍 Kubernetes 周边生态，如微服务、DevOps、大数据应用、服务网格、云原生应用、Serverless 等领域。\n\n## 本书大纲\n\n{{\u003c list_children show_summary=\u0022false\u0022\u003e}}\n\n## 许可证\n\n您可以使用[署名 - 非商业性使用 - 相同方式共享 4.0 (CC BY-NC-SA 4.0)](https:\/\/creativecommons.org\/licenses\/by-nc-sa\/4.0\/deed.zh)  协议共享。\n\n## 交流群\n\n欢迎加入[云原生社区](https:\/\/cloudnative.to\/)微信讨论群，加入前请先填写[入群申请问卷](https:\/\/wj.qq.com\/s2\/5479026\/bf82)后联系 [Jimmy Song](https:\/\/jimmysong.io\/contact\/) 入群。\n\n{{\u003c cta cta_text=\u0022开始阅读\u0022 cta_link=\u0022architecture\u0022 \u003e}}\n', '\/book\/kubernetes-handbook\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本书起始于 2017 年 3 月，记录了本人从零开始学习和使用 Kubernetes 的心路历程，着重于经验分享和总结。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/podless-kubernetes-istio/">[译] 如何实现无 Pod 的 Kubernetes 和 Istio 部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/podless-kubernetes/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何实现无 Pod 的 Kubernetes 和 Istio 部署', '探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。', '\nKubernetes 经常被批评（有些不公平）操作起来过于复杂，促使大多数人依赖托管服务。然而，[\u0060k3s\u0060](https:\/\/k3s.io\/) 某种程度上颠覆了这一点，将完整的 Kubernetes 发行版打包成一个二进制文件。这非常方便，特别是在物联网等小型环境中运行时；虽然隔离组件对非常大规模、先进的部署有好处，但对较小的环境来说，操作微服务可能只是一种负担——这正是 [Istio 多年前选择重构为更单体架构的原因](https:\/\/blog.christianposta.com\/microservices\/istio-as-an-example-of-when-not-to-do-microservices\/)。\n\n然而，它还是没有那么“精简”。在一个空集群中运行 \u0060k3d cluster create test\u0060 后，我们会在集群中看到各种 pod：\n\n\u0060\u0060\u0060bash\n$ kubectl get pods --all-namespaces\nNAMESPACE     NAME                                      READY   STATUS     RESTARTS  AGE\nkube-system   local-path-provisioner-6c86858495-gc9jq   1\/1     Running    0         2m18s\nkube-system   coredns-6799fbcd5-pdf4b                   1\/1     Running    0         2m18s\nkube-system   helm-install-traefik-crd-cp9s2            0\/1     Completed  0         2m18s\nkube-system   helm-install-traefik-pch7c                0\/1     Completed  1         2m18s\nkube-system   traefik-f4564c4f4-q4lkj                   1\/1     Running    0         2m8s\nkube-system   metrics-server-54fd9b65b-d69w6            1\/1     Running    0         2m18s\nkube-system   svclb-traefik-58c5bb65-sq54b              2\/2     Running    0         2m8s\n\u0060\u0060\u0060\n\n\u003e [\u0060k3d\u0060](https:\/\/github.com\/k3d-io\/k3d\/) 是一个方便的工具，可以在 Docker 内部部署 \u0060k3s\u0060，便于测试。\n\n这是怎么回事？我们的“单二进制 Kubernetes”怎么变成了 6 个不同的容器？\n\n虽然 k3s 将许多组件（\u0060kube-proxy\u0060、\u0060flannel\u0060、\u0060containerd\u0060、\u0060kubelet\u0060 等）嵌入到一个二进制文件中，但其他组件则作为标准 pod 在集群中运行。\n\n此外，一旦我们部署了我们最喜欢的 [服务网格](https:\/\/istio.io\/)，我们将会有更多的 pod，使我们离没有 pod 的目标更远。\n\n## 没有 pod 的 Kubernetes？\n\n那么问题是——我们能否通过进一步推进 \u0060k3s\u0060 的理念，将完整的集群功能嵌入到一个二进制文件中，来获得一个功能齐全的 Kubernetes 和 Istio 部署？\n\n\u003e **警告**：这些是实验性概念；绝不要在生产环境中尝试！\n\n首先，我们可以直接去除一些不必要的组件，如 \u0060servicelb\u0060（负载均衡服务需要）、\u0060traefik\u0060（Ingress 需要）、\u0060local-storage\u0060（PVC 需要）和 \u0060metrics-server\u0060（\u0060kubectl top\u0060 需要）。\n\n这就剩下 \u0060coredns\u0060 和 Istio。\n\n如果我们追求极简，我们肯定会希望使用 Istio 的 [ambient mode](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/getting-started\/)，它完全不需要 sidecar。幸运的是，它开箱即用并且有完整的 [DNS 支持](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)。这让我们可以去掉 \u0060coredns\u0060。\n\n这样一来，如果我们能运行 Istio ambient，就可以去掉 \u0060kube-system\u0060 中的所有内容。这相对简单；难点在于不为 Istio 添加更多的 pod。\n\n## 嵌入 Istio\n\n通过 \u0060k3s\u0060 的一个分支，我修改了它，使 Istio 本身嵌入到 \u0060k3s\u0060 中。\u0060k3s\u0060 可以作为服务器和\/或代理运行。通常你会有 1 个服务器，每个其他节点作为代理运行。\n\n在 \u0060server\u0060 上，我们希望运行 \u0060Istiod\u0060（Istio 的控制平面）。在代理上，我们希望运行 \u0060istio-cni\u0060（每个节点的控制平面）和 \u0060ztunnel\u0060（每个节点的数据平面）。\n\n这三个组件都可以直接嵌入到 \u0060k3s\u0060 中，只需一些工作！\n\n使用这个自定义构建，我们可以通过一些自定义配置启动一个新的 \u0060k3d\u0060 集群，禁用我们不再需要的组件：\n\n\u0060\u0060\u0060yaml\napiVersion: k3d.io\/v1alpha5\nkind: Simple\nmetadata:\n  name: podless\nservers: 1\nagents: 1\noptions:\n  k3d:\n    wait: true\n    timeout: \u002260s\u0022\n    disableLoadbalancer: true\n    disableRollback: true\n  k3s:\n    extraArgs:\n      - arg: --disable-cloud-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable-kube-proxy\n        nodeFilters:\n          - server:*\n      - arg: --disable-network-policy\n        nodeFilters:\n          - server:*\n      - arg: --disable-helm-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable=coredns,servicelb,traefik,local-storage,metrics-server\n        nodeFilters:\n          - server:*\n\u0060\u0060\u0060\n\n这里我们禁用了上面看到的所有 pod，包括一些额外的。\n\n一个显著的例子是 \u0060kube-proxy\u0060。像其他一些项目一样（如 [Cilium](https:\/\/docs.cilium.io\/en\/stable\/network\/kubernetes\/kubeproxy-free\/)），Istio 的 \u0060ztunnel\u0060 可以有效地替代大多数用例中的 \u0060kube-proxy\u0060。\n\n## 无 pod 的服务网格\n\n所有配置就绪后，我们的集群是什么样子？\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNo resources found\n\u0060\u0060\u0060\n\n到目前为止一切顺利....当然，什么都不运行很容易；真正的挑战是保持集群的功能。\n\n让我们部署一些应用程序 pod。再次强调，这些是集群中的唯一 pod：\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNAMESPACE   NAME                     READY   STATUS    RESTARTS   AGE\ndefault     shell-5fff89ccf5-98kgg   1\/1     Running   0          19s\ndefault     echo-66d88ff694-9qprp    1\/1     Running   0          14s\n\u0060\u0060\u0060\n\n然后我们可以发送流量：\n\n\u0060\u0060\u0060\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n\u0060\u0060\u0060\n\n流量完全正常，包括服务流量（以前由 \u0060kube-proxy\u0060 处理）和 DNS（以前由 \u0060coredns\u0060 处理）。现在这些全部由 \u0060ztunnel\u0060 处理，并且所有内容都通过安全的 mTLS 传输。\n\n除了 mTLS 加密，我们还可以基于 mTLS 身份应用策略。同样，这些都由 \u0060ztunnel\u0060 执行。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: allow-default\nspec:\n  action: ALLOW\n  selector:\n    matchLabels:\n      app: echo\n  rules:\n  - from:\n    - source:\n        namespace: [\u0022cluster.local\/ns\/default\/sa\/shell\u0022]\n\u0060\u0060\u0060\n\n现在 \u0060default\u0060 命名空间的流量被允许，但其他流量不被允许。我们可以通过从 \u0060shell\u0060 发送流量以及我在 \u0060other\u0060 命名空间中部署的新测试工作负载来验证这一点：\n\n\u0060\u0060\u0060bash\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n$ kubectl exec deploy\/shell -n other -- curl -s echo\ncommand terminated with exit code 56\n\u0060\u0060\u0060\n\n正如预期的那样，我们的其他应用程序被拒绝了！\n\n此外，如果我们愿意，我们可以将流量升级通过完整的 HTTP 代理（[\u0022waypoint\u0022](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/architecture\/)）：\n\n\u0060\u0060\u0060\n$ istioctl x waypoint apply --enroll-namespace\nwaypoint default\/waypoint applied\n\n$ kubectl get pods\nNAME                        READY   STATUS    RESTARTS   AGE\necho-66d88ff694-czd65       1\/1     Running  \n\n 0          93m\nshell-56bd5dbdbf-f4gh9      1\/1     Running   0          93m\nwaypoint-7cd4dc789f-2s7z2   1\/1     Running   0          41s\n\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nRequestHeader=X-Request-Id:18d72190-9caa-4162-8bc5-4c11518d7568\nHostname=echo-66d88ff694-czd65\n\u0060\u0060\u0060\n\n现在我们的 waypoint 已经部署，所有到命名空间的流量会自动转发到它，在那里可以执行完整的 HTTP 策略。这里，我们可以看到 \u0060X-Request-Id\u0060 被添加到我们的请求中，但我们还可以获得 [自动配置的其他功能](https:\/\/istio.io\/latest\/blog\/2021\/zero-config-istio\/)，以及更多 [我们可以配置的内容](https:\/\/istio.io\/latest\/docs\/tasks\/)。\n\n## 总结\n\n最终，我们能够部署一个完整的 Kubernetes 集群和服务网格，所有基础设施组件嵌入到一个隐藏的节点二进制文件中——集群功能不需要 pod。\n\n这实际操作起来是否实用？不太实用。然而，这确实表明 Kubernetes\/Istio 被认为过于臃肿和复杂的看法并不完全准确。\n\n它真的比典型的集群更简单吗？某种程度上是的……我们确实替换了两个组件（\u0060kube-proxy\u0060 和 \u0060coredns\u0060），但其余的我们基本上只是隐藏和打包。这显然不如完全替换有意义，但也不错。话虽如此，隐藏东西对 [社交媒体参与度](https:\/\/twitter.com\/wm\/status\/1577081662848241664) 有好处，而 \u0060k3s\u0060 通过有效地隐藏和打包取得了巨大成功，因此显然提供了一些实实在在的好处。\n', '\/trans\/podless-kubernetes-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ztunnel-testing/">[译] 无需 Kubernetes 测试 Kubernetes 网络实现</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/ztunnel-testing/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('无需 Kubernetes 测试 Kubernetes 网络实现', '探讨如何在没有 Kubernetes 环境的情况下测试 Ztunnel 网络代理，该代理为 Istio 的新 Ambient 模式编写。', '\n由于在开发过程中我[真的不喜欢等待](https:\/\/blog.howardjohn.info\/posts\/ideal-ci\/)，所以在构建 Ztunnel（一个为 Istio 的新 [Ambient 模式](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)设计的底层网络代理）时，我的首要任务之一便是确保测试的快速进行（包括运行和编写测试），并且易于调试。\n\n这一任务颇为棘手，因为在大多数真实场景中，Ztunnel 高度依赖 Kubernetes。虽然它能够完全独立于 Kubernetes 运行，但许多关键代码路径的行为完全不同，使得仅通过这种方式进行测试变得不可行。\n\n下图为典型的 Ztunnel 部署架构：\n\n![Ztunnel 架构概览](ztunnel-architecture.svg)\n\n在此架构中，用户将运行一个包含多个节点的 Kubernetes 集群。每个节点上都运行着一个 Ztunnel，配置了宿主机和每个 pod 的网络栈。\n\n此外，Ztunnel 实际上进入了每个 pod 的网络命名空间，并代表其发送\/接收流量。这一点非常奇特且酷炫，但也大大增加了测试的难度！（[详细信息](https:\/\/www.youtube.com\/watch?v=cuMeEhpyH5s)）\n\n## 加速测试\n\n启动完整的 Kubernetes 环境、重建镜像、部署到每个节点的过程非常缓慢且难以调试。\n\n黄金标准应该是将所有操作运行在一个简单的单一二进制文件中——仅需执行 \u0060cargo test\u0060。这种方式避开了复杂的设置和缓慢的重建，并使调试变得轻而易举（当然，你可以将调试器连接到正在运行的 pod，但这很麻烦）。\n\n## 设置网络\n\n如果我们去除无尽的抽象层，Kubernetes pod 实际上只是几个 Linux 命名空间和挂载的组合。Docker 在这方面管理得很好，[bash](https:\/\/github.com\/p8952\/bocker) 也可以。\n\n我们特别关注的是[网络命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/network_namespaces.7.html)，它可以实现网络栈的隔离。每个 pod 都有自己的网络命名空间，通过各种机制连接，允许与同一节点上的其他 pod、其他节点以及外部目的地通信。\n\n好消息是创建网络命名空间非常简单。\n\n\u0060\u0060\u0060shell\n$ sudo ip netns add testing\n\u0060\u0060\u0060\n\n我们的最终目标是设置一系列的网络命名空间，外观与我们在 Kubernetes 上的真实架构类似：\n\n![所需的网络命名空间设置](ztunnel-network-namespaces.svg)\n\n在网络命名空间之间建立连接稍微复杂一些。像  [\u0060cnitool\u0060](https:\/\/www.cni.dev\/docs\/cnitool\/) 这样的工具可以帮助我们完成（它实际上执行了一些 Kubernetes 环境中用于设置网络的相同逻辑，但作为 CLI 工具），但你也可以完全手动操作。我们选择了后者。\n\n最终，我们的设置如下：\n\n- 每个测试都拥有自己的网络命名空间，通过一个桥接设备（\u0060br0\u0060）来促进节点之间的流量。\n- 每个节点配置了一个 \u0060veth\u0060 设备。一端成为节点上的 \u0060eth0\u0060，另一端连接到根命名空间中的 \u0060br0\u0060。\n- 每个 pod 都配置了一个 \u0060veth\u0060 设备。一端成为 pod 上的 \u0060eth0\u0060，另一端位于节点网络命名空间中。\n- 为每个 pod 设置路由以将流量发送到节点。\n- 为每对节点设置路由，以实现跨节点流量。\n\n![所需的网络连接设置](ztunnel-network-devices.svg)\n\n除了根命名空间\/桥接设备外，这与许多现实世界中的 Kubernetes 集群的运行方式相同（在现实世界中，根命名空间是两台机器之间的物理网络）。\n\n你可以在[这里](https:\/\/github.com\/istio\/ztunnel\/blob\/34fce85a6a2b2a85eb170a04096731e2ea4e0e9f\/src\/test_helpers\/netns.rs#L194)找到所有细节。\n\n## 运行测试\n\n一旦我们有了这些命名空间，我们仍然需要一种实际使用它们的方法。幸运的是，Linux 允许在运行时更改当前命名空间线程（这是接下来重要的内容）。这让我们建立了一个基本的帮助函数（真实的代码稍微更复杂）：\n\n\u0060\u0060\u0060rust\nfn run_in_namespace(namespace: Namespace, f: Fn()) { let original_namespace = get_current_namespace(); namespace.enter(); f(); original_namespace.enter(); }\n\u0060\u0060\u0060\n\n有了这个，我们可以轻松地从任意的“pods”或“nodes”执行代码。\n\n然而，我们仍然面临一个问题。我们的所有代码都运行在 [tokio](https:\/\/tokio.rs\/) 异步运行时中，它会根据需要将我们的各种任务安排到物理操作系统线程上（类似于 Go 运行时的工作方式）。由于网络命名空间是线程相关的，所以当我们的任务在线程之间跳转时，这一切都会崩溃。\n\n幸运的是，Rust 给了我们比 Go 更多的关于异步运行时的灵活性——我们可以同时拥有多个！借此，我们能够构建一个能够异步执行 \u0060run_in_namespace\u0060。对于我们想要执行的每个函数，我们启动一个新线程并构建一个专用的单线程异步运行时来处理它：\n\n\u0060\u0060\u0060rust\nasync fn async_run_in_namespace(namespace: Namespace, f: async Fn()) { thread::spawn(move || { run_in_namespace(namespace, || { let rt = tokio::runtime::Builder::new_current_thread().enable_all().build(); rt.block_on(f()) }) }); }\n\u0060\u0060\u0060\n\n我们为每个命名空间运行一次这个函数，因此这里的开销是最小的。如果我们想要运行许多小函数，可以在顶层构建一个抽象来发送工作到线程以执行。\n\n我们需要的最后一件事是一种合理的方法来识别如何调用每个目的地。虽然它们都会被分配一个 IP（基于我们代码中的简单 IPAM 策略），但我们不希望每个测试都必须猜测 IP。为了处理这个问题，我们构建了一个简单的名称解析器。这就像 DNS，但简单得多：对于我们创建的每个“pod”，我们记录一个\u0060name -\u003e IP\u0060的映射，并允许查找 IP。\n\n将所有这些放在一起，一个简单的测试启动了 3 个 pods（客户端、服务器和 ztunnel）在一个单一节点上看起来像这样：\n\n\u0060\u0060\u0060rust\n#[tokio::test] async fn simple_test(){ let ztunnel = manager.deploy_ztunnel(DEFAULT_NODE).await?; let server = manager .workload_builder(\u0022server\u0022, DEFAULT_NODE) .register() .await?; run_tcp_server(server)?; let client = manager .workload_builder(\u0022client\u0022, DEFAULT_NODE) .register() .await?; run_tcp_client(client, manager.resolve(\u0022server\u0022))?; \/\/ ... some assertions here }\n\u0060\u0060\u0060\n\n## 放弃权限\n\n上述设置效果很好，但也带来了一些问题。\n\n基本上设置的每一步都需要提升的 root 权限；这让简单的 \u0060cargo test\u0060 案例的开箱即用变得乏味，通常也不可取。\n\n此外，这会在主机环境中污染大量的命名空间。虽然我们有一些清理过程，但这些并不是 100% 可靠，可能会导致悬挂的命名空间阻碍未来的执行。\n\n解决拥有太多命名空间的问题的方法？更多的命名空间！为此，我们需要的不仅仅是网络命名空间。\n\n[用户命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/user_namespaces.7.html) 允许我们实质上假装是 UID 0 (root)，同时实际上将其映射回我们原始的 UID。这里的力量在于，在该命名空间中，我们可以做一些本来需要 root 权限的事情——特别是创建新的网络命名空间。\n\n然而，我们不能做的一件事是修改主机-root 拥有的文件（这将是明显的权限违规）。尽管我们可能可以绕过它们，但我们在测试中使用的很多工具喜欢触摸 root 文件。这再次可以通过 [mount 命名空间](https:\/\/man7.org\/linux\/man-pages\/man7\/mount_namespaces.7.html) 解决，它允许我们将我们拥有的文件绑定挂载到主机-root 拥有的文件上，而不会影响命名空间外的事物。\n\n将所有这些放在一起，我们有这样的东西：\n\n\u0060\u0060\u0060rust\nlet original_uid = get_uid(); \/\/ 首先，进入一个新的用户命名空间。unshare(CloneFlags::CLONE_NEWUSER).unwrap(); \/\/ 将用户命名空间中的 root 映射到我们原始的 UID File::create(\u0022\/proc\/self\/uid_map\u0022).write(format!(\u00220 {original_uid} 1\u0022)); \/\/ 设置一个新的网络命名空间 unshare(CloneFlags::CLONE_NEWNET).unwrap(); \/\/ 设置一个新的挂载命名空间 unshare(CloneFlags::CLONE_NEWNS).unwrap(); \/\/ 将一个文件夹在我们的每个测试目录中挂载到 \/var\/run\/netns mount(tmp_dir.join(\u0022netns\u0022), \u0022\/var\/run\/netns\u0022, MS_BIND); \/\/ 一个方便手动调试的好帮手信息，如果需要的话。let pid = get_pid(); eprintln!(\u0022Starting test in {tmp_dir}. Debug with \u0060sudo nsenter --mount --net -t {pid}\u0060\u0022);\n\u0060\u0060\u0060\n\n如上所述，一个技巧是，进入命名空间是按线程进行的。我们需要在生成任何额外线程之前设置这一点。\n\nRust 实际上为我们提供了这样做的能力，但这意味着我们失去了 \u0060#[tokio::test]\u0060 宏帮助。我们可以写自己的宏，但这有点痛苦。幸运的是，通过 [链接器的花招](https:\/\/crates.io\/crates\/ctor) 我们可以迫使我们的代码在进程执行的非常早期运行。\n\nGo 中的类似方法也有效（请参见 [我写的帮助库](https:\/\/github.com\/howardjohn\/unshare-go)），实际上在那里是必需的，因为设置必须在 Go 运行时启动之前完成（这通常在任何用户代码运行之前很久）。\n\n## 总结\n\n有了所有这些设备，一个完整的测试只需要大约 200 毫秒。一切都在一个单一进程中运行，使调试变得轻而易举。所有的测试也都是完全隔离的，因此可以完全并行运行测试（包括相同的测试，用于压力测试以消除测试缺陷）。\n', '\/trans\/ztunnel-testing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探讨如何在没有 Kubernetes 环境的情况下测试 Ztunnel 网络代理，该代理为 Istio 的新 Ambient 模式编写。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/gateway-api-istio-ingress-evolution/">探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('探索 Kubernetes Ingress、Gateway API 与 Istio 的演进和转型', '本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。', '\n随着 Istio 1.22 版本的发布，Istio API 已正式升级至 v1 版本，同期，Kubernetes Gateway API 也更新至 v1.1 版本。本篇文章旨在深入探索 Ingress API、Istio API 与 Kubernetes Gateway API 之间的联系与区别，并详述它们在现实应用中的选择及迁移策略。\n\n## 前言\n\n之前，我曾撰写一篇文章，讨论了 [为何 Gateway API 是 Kubernetes 与服务网格入口中的未来方向](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/)。文章中指出，作为 Kubernetes 的初始入口网关，Ingress 的资源模型由于过于简单，难以满足当下的可编程网络需求。作为其接班人，Gateway API 近年来发展迅速，获得了广泛支持，包括众多新兴的开源网关项目如 [Envoy Gateway](https:\/\/gateway.envoyproxy.io) 也选择基于 Gateway API 开发。此外，一些传统网关项目也开始适配 Gateway API，或通过 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) 这样的工具进行迁移。\n\nGateway API，作为 Kubernetes 入口网关的最新成果，通过角色划分来分离关注点，并支持跨 namespace，更适合多云环境。它整合了入口网关（南北向）与服务网格（东西向，集群内路由）的重叠功能，为云原生时代的统一流量管理提供了新的参考模型。\n\nIngress API、Gateway API 与 Istio API 都能实现网关功能，它们之间具体有何联系与区别？本文将为你揭晓这一迷题，并提供 Kubernetes 环境中网关的选择和迁移策略。\n\n## Kubernetes 中的流量管理\n\n随着微服务架构的广泛应用和日益增长的复杂性，Kubernetes 的流量管理工具也在不断演进以适应各种技术需求。Ingress API、Istio API 与 Kubernetes Gateway API 分别标志着这一演变的不同阶段。\n\n**Ingress API** 提供了 Kubernetes 的基本流量管理功能，允许用户通过定义简单的路由规则（例如 HTTP 和 HTTPS）来管理外部访问集群内服务的流量。其设计虽简洁，但功能有限，主要适用于规模较小、结构较简单的应用场景。\n\n相比之下，**Istio API** 作为服务网格的一部分，提供了一系列高级流量管理功能，如流量镜像、金丝雀发布和断路器，适合于需要复杂流量管理的大规模微服务架构。\n\n为了克服 Ingress API 的局限性并集成类似 Istio 的高级功能，**Kubernetes Gateway API** 因应而生。它不仅在设计上提供了更高的灵活性和扩展性，还通过社区的广泛支持，成为连接传统 Ingress 实现和现代服务网格技术如 Istio 的桥梁，目前主流的开源网关都是基于 Gateway API 或已进行适配。\n\n以下表格概述了这三者的核心特点和推荐使用场景：\n\n| API 名称    | 对象类型                    | 状态                    | 推荐使用场景                                                 |\n| ----------- | --------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API | \u0060Ingress\u0060                   | 稳定 (Kubernetes v1.19) | 适用于小规模和简单的应用场景，主要用于基本的路由配置         |\n| Istio API   | \u0060VirtualService\u0060、\u0060Gateway\u0060 | 稳定 (Istio 1.22)       | 适用于高度复杂的微服务架构，需细粒度控制和高级流量管理特性的场景 |\n| Gateway API | \u0060HTTPRoute\u0060、\u0060Gateway\u0060      | 稳定 (Gateway API v1.1) | 适用于新部署或现有部署，需提高灵活性和可扩展性的场景，特别是结合 Istio 使用 |\n\n[Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/) 的推出，特别是其在提升与现有 Ingress 配置兼容性方面的改进，为用户提供了一个平稳的迁移途径，使从传统的 Ingress 解决方案向更现代的、功能更全面的 Gateway API 的过渡变得更为顺畅。\n\n## 从 Ingress 迁移到 Kubernetes Gateway API\n\n若想从 Ingress 迁移到 Gateway API，请按以下步骤操作：\n\n1. **理解关键差异**：与 Ingress 相比，Gateway API 引入了多种新的概念和资源类型，如 \u0060Gateway\u0060、\u0060HTTPRoute\u0060 和 \u0060TLSRoute\u0060。这些资源提供了更多的配置选项和灵活性，请参阅 [Gateway API 文档](https:\/\/gateway-api.sigs.k8s.io\/guides\/)以了解其配置。\n2. **配置入口点**：创建 \u0060Gateway\u0060 资源配置，明确定义如何接收外部流量，包括配置协议、端口和 TLS 终端。\n3. **映射旧资源**：将现有的 Ingress 资源映射到对应的 Gateway API 资源。例如，Ingress 中的 host 和 path 规则需要转换为 HTTPRoute 中的路由规则。\n4. **测试与部署**：在正式迁移之前，在测试环境中验证新的 Gateway API 配置，确保所有流量路由正常，无安全漏洞。\n\n为了简化迁移过程，你可以使用工具如 [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway)，该工具能自动将 Ingress 配置转换为 Gateway API 格式。\n\n## 实际迁移示例\n\n以下是一个简单的 HTTP 网关配置示例，展示了如何将 Ingress 迁移到 Gateway API。\n\n假设现有一个 Ingress 配置如下：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\n要将其迁移到 Gateway API，首先需要创建一个 Gateway 对象：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\n请确保 \u0060gatewayClassName\u0060 指向你集群中配置的有效 GatewayClass。GatewayClass 通常由集群管理员设置，是一个为 Gateway 提供配置的资源。\n\n接下来，创建 HTTPRoute 资源来定义路由规则，将流量路由到后端服务：\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\n在此示例中，我们看到：\n\n- \u0060Ingress\u0060 对象中的规则被直接映射到 \u0060HTTPRoute\u0060 对象中。\n- 路由规则中的主机名匹配、路径匹配以及后端服务配置保持不变，只是对象和字段名称有所不同。\n\n## 考虑的挑战\n\n虽然可以将 Ingress 迁移到 Gateway API，并可能同时运行它们，但需要考虑以下挑战和迁移的必要性：\n\n- **功能差异**：某些 Ingress 控制器的特定功能可能在 Gateway API 中没有直接对应，可能需要通过额外的配置或自定义资源来实现。\n- **多资源管理**：Gateway API 的使用可能涉及比 Ingress 更多的资源类型和更复杂的配置，这可能增加管理的复杂性。\n\n对于现有的 Ingress 和 Istio API 用户，是否需要迁移到 Gateway API 取决于具体情况。以下是一些迁移建议：\n\n- **新部署**：建议直接采用 Gateway API，以便利用其先进特性和预见未来的发展。\n- **现有部署**：如果现有系统运行稳定且无需高级特性，可以继续使用现有 API；如果希望利用 Gateway API 的新特性或计划未来长期发展，逐步迁移则是一个理智的选择。\n\n对于不同网关对 Gateway API 的支持情况，可以参考 [Gateway API 实现项目的一致性报告](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/)了解详细信息。\n\n## 总结\n\nIngress API、Istio API 和 Kubernetes Gateway API 各具特色，适应不同的应用场景和需求。选择合适的 API，进行合理的规划和管理，可以显著提高系统的灵活性和稳定性。随着 Gateway API 的持续发展和成熟，它将越来越成为未来流量管理的主流选择。\n\n选择合适的网关技术，结合你的具体需求和现有架构，可以更好地管理和优化流量，确保应用的高效和稳定运行。随着技术的进步和社区的发展，Gateway API 提供了一个强大且灵活的框架，使得从传统的 Ingress 迁移到更现代的解决方案变得更为简单和高效。\n\n## 参考\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)', '\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文深入分析了 Kubernetes Gateway API、Istio 与 Ingress 的联系、差异及迁移策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ebook-cilium-for-network-engineer/">电子书：Kubernetes 网络和 Cilium 网络工程师指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/04/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e9%9a%8f%e7%ac%94"> 
             随笔
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('电子书：Kubernetes 网络和 Cilium 网络工程师指南', '我很高兴向大家推荐 Isovalent 最新推出的电子书《Kubernetes 网络和 Cilium 网络工程师指南》。', '\n亲爱的云原生社区的朋友们，我很高兴向大家推荐 Isovalent 最新推出的电子书《[Kubernetes 网络和 Cilium 网络工程师指南（英文原版）](https:\/\/isovalent.com\/blog\/post\/introducing-the-new-kubernetes-networking-and-cilium-for-the-network-engineer-ebook\/)》。\n\n![《Kubernetes 网络和 Cilium 网络工程师指南》电子书封面](https:\/\/jimmysong.io\/img\/blog\/ebook-cilium-for-network-engineer\/cover.webp)\n\n作为一名资深的云原生倡导者，我深知 Kubernetes 网络对于网络工程师来说是一个巨大的挑战。但是，随着 Kubernetes 在企业中的广泛应用，学习 Kubernetes 网络知识已经变得非常重要和紧迫。这本电子书正是为了帮助网络工程师们克服这些挑战而诞生的。\n\n这本 56 页的电子书由 *Isovalent 的 Senior Staff Technical Marketing Engineer* Nico Vibert 撰写，内容涵盖了 Kubernetes 网络的方方面面，包括 Cilium 这个事实上的 Kubernetes 网络层。即使你不是网络工程师，相信你也能轻松理解和学习这本书的内容。\n\n这本电子书就像一本使用说明手册，为网络工程师们提供了一个循序渐进的学习路径。从 Kubernetes 网络的基础知识，到 Cilium 的高级功能，再到实际的部署和运维，应有尽有。相信这本书一定会成为网络工程师学习 Kubernetes 网络的必备资料。\n\n根据这本由 Isovalent 推出的电子书《Kubernetes Networking and Cilium: An Instruction Manual for the Network Engineer》的内容，我为大家总结了以下几点。\n\n## 本书亮点\n\n1. 全面介绍了 Kubernetes 网络的基础知识，包括容器网络接口 (CNI)、网络模型等，为网络工程师打下坚实的基础。\n2. 深入探讨了 Cilium 这个事实上的 Kubernetes 网络层，详细讲解了它提供的各种功能，如路由、交换、负载均衡、防火墙、监控等。\n3. 系统介绍了如何在 Kubernetes 中配置和管理网络，包括使用 kubectl 命令行工具、应用 YAML 配置文件等。\n4. 重点阐述了 Cilium 的身份感知安全机制，以及如何使用网络策略进行精细化的网络访问控制。\n5. 讲解了 Kubernetes 中的负载均衡机制，包括 ClusterIP、NodePort 和 Ingress 等服务类型。\n6. 探讨了 Kubernetes 集群跨多个集群的联通方案，以及如何实现跨集群的负载均衡和安全策略。\n\n## 适读人群\n\n这本电子书主要面向 Kubernetes 网络工程师，帮助他们全面掌握 Kubernetes 网络的方方面面知识。即使不是网络工程师，对云原生技术感兴趣的读者也能从中受益，学习 Kubernetes 网络的基础知识。\n\n## 中文版\n\n如果你想阅读该书的中文版，请访问[这里](https:\/\/isovalent.com\/books\/kubernetes-networking-and-cilium-zh\/)获取。中文版由 Isovalent 的黄力一翻译。\n', '\/blog\/ebook-cilium-for-network-engineer\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我很高兴向大家推荐 Isovalent 最新推出的电子书《Kubernetes 网络和 Cilium 网络工程师指南》。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cni-deep-dive/">深入解读 CNI：容器网络接口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/04/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解读 CNI：容器网络接口', '本文详细解释了 CNI（容器网络接口）的基本概念、核心组件以及其与 CRI（容器运行时接口）的关系。', '\n在容器化环境中，有效管理网络是至关重要的。容器网络接口（CNI）是一个标准，定义了容器应如何配置网络。本文将深入探讨 CNI 的基础知识，并带你了解 CNI 与 CRI 的关系。\n\n## 什么是 CNI？{#what-is-cni}\n\nCNI（容器网络接口）规范为容器运行时和网络插件之间提供了一个通用的接口，旨在实现容器网络配置的标准化。\n\nCNI 规范包含以下几个核心组成部分：\n\n- **网络配置的格式**：定义了管理员如何定义网络配置。\n- **请求协议**：描述了容器运行时如何向网络插件发出网络配置或清理请求。\n- **插件执行过程**：详细阐述了插件如何根据提供的配置执行网络设置或清理。\n- **插件委派**：允许插件将特定功能委托给其他插件执行。\n- **结果返回**：定义了插件执行完成后如何向运行时返回结果的数据格式。\n\nCNI 规范通过定义这些核心组成部分，确保了不同的容器运行时和网络插件能够以一致的方式进行交互，实现网络配置的自动化和标准化。\n\n{{\u003ccallout note \u0022CNI 规范的一些要点\u0022\u003e}}\n\n- CNI 是一个插件化的容器化网络解决方案\n- CNI 插件为可执行文件\n- 单个 CNI 插件的职责是单一的\n- CNI 插件是呈链式调用的\n- CNI 规范为一个容器定义一个 Linux 网络命名空间\n- CNI 的网络定义存储为 JSON 格式\n- 网络定义通过 STDIN 输入流传输到插件，这意味着宿主机上不会存储网络配置文件，其他的配置参数通过环境变量传递给插件\n\n{{\u003c\/callout\u003e}}\n\nCNI 插件根据操作类型，接收相应的网络配置参数，执行网络配置或清理任务，并返回执行结果。这一流程确保了容器网络的动态配置与容器生命周期的同步。\n\n下图展示了 CNI 包含了众多的网络插件。\n\n\u0060\u0060\u0060mermaid \u0022CNI 插件的种类\u0022\ngraph TB\n    CR[Container Runtime] --\u003e CNI[\u0022Container Network Interface (CNI)\u0022]\n    CNI --\u003e LP[Loopback Plugin]\n    CNI --\u003e BP[Bridge Plugin]\n    CNI --\u003e PTP[PTP Plugin]\n    CNI --\u003e MACV[MACvlan Plugin]\n    CNI --\u003e IPV[IPvlan Plugin]\n    CNI --\u003e TPP[3rd-Party Plugin]\n\u0060\u0060\u0060\n\n![CNI 插件的种类](cdc38d55a4fc4468ab20df85ab63c2c7.svg)\n\n根据 [CNI 规范](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md#section-2-execution-protocol)，一个 CNI 插件负责以某种方式配置容器的网络接口。插件可分为两大类：\n\n- \u0022接口\u0022插件，负责在容器内部创建网络接口并确保其具有连通性。\n- \u0022链式\u0022插件，调整已创建接口的配置（但可能需要创建更多接口以完成此操作）。\n\n## CNI 与 CRI 的关系 {#relationship}\n\nCNI 和 CRI（容器运行时接口）是 Kubernetes 中两个关键的接口，它们分别处理容器的网络配置和运行时管理。在 Kubernetes 集群中，CRI 调用 CNI 插件来配置或清理容器的网络，这确保了网络配置的过程与容器的创建和销毁过程紧密协调。\n\n下图直观地展示了 CNI 如何与 CRI 协同运行的：\n\n\u0060\u0060\u0060mermaid \u0022CNI 如何与 CRI 协同运行的\u0022\nsequenceDiagram\n    participant K as Kubelet\n    participant CRI as Container Runtime Interface\n    participant CNI as Container Network Interface\n    participant P as Pod\n\n    K-\u003e\u003e\u002bCRI: 创建 Pod 容器\n    CRI-\u003e\u003e\u002bP: 启动容器\n    P--\u003e\u003e-CRI: 容器运行中\n    CRI--\u003e\u003e-K: 容器准备就绪\n    K-\u003e\u003e\u002bCNI: 调用 CNI 进行网络设置\n    CNI-\u003e\u003e\u002bP: 连接网络\n    P--\u003e\u003e-CNI: 网络配置完成\n    CNI--\u003e\u003e-K: Pod 网络就绪\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\u0060\u0060\u0060\n\n![CNI 如何与 CRI 协同运行的](5451dd983a8c3858a265283d74b7536b.svg)\n\n1. **Kubelet 到 CRI**：Kubelet 指示 CRI 创建已调度的 Pod 的容器。\n2. **CRI 到 Pod**：容器运行时在 Pod 中启动容器。\n3. **Pod 到 CRI**：一旦容器运行，它会向容器运行时发出信号。\n4. **CRI 到 Kubelet**：容器运行时通知 Kubelet 容器已准备就绪。\n5. **Kubelet 到 CNI**：容器已启动，Kubelet 调用 CNI 为 Pod 设置网络。\n6. **CNI 到 Pod**：CNI 为 Pod 配置网络，将其连接到必要的网络接口。\n7. **Pod 到 CNI**：网络配置完成后，Pod 向 CNI 确认网络设置。\n8. **CNI 到 Kubelet**：CNI 通知 Kubelet Pod 的网络已准备就绪。\n9. **Kubelet 到 Pod**：现在 Pod 完全可操作，两个容器均已运行且网络已配置。\n\n下图展示了在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤：\n\n\u0060\u0060\u0060mermaid \u0022在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤\u0022\nsequenceDiagram\n    participant P as Pod\n    participant K as Kubelet\n    participant CNI as Container Network Interface\n    participant NS as Network Setup\n    participant IPAM as IP Address Management\n\n    K-\u003e\u003e\u002bP: 调度 Pod\n    P-\u003e\u003e\u002bK: 请求网络设置\n    K-\u003e\u003e\u002bCNI: 调用 CNI\n    CNI-\u003e\u003e\u002bNS: 创建网络命名空间\n    NS--\u003e\u003e-CNI: 命名空间已创建\n    CNI-\u003e\u003e\u002bIPAM: 分配 IP 地址\n    IPAM--\u003e\u003e-CNI: IP 地址已分配\n    CNI-\u003e\u003eP: 设置网络接口\n    P--\u003e\u003e-K: 网络设置完成\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\n    Note over P,K: Pod 调度触发网络设置\n    Note over CNI,IPAM: CNI 处理网络命名空间创建和 IP 地址分配\n\u0060\u0060\u0060\n\n![在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤](4f3017abf23385a5007302ea17241bdf.svg)\n\n1. **Pod 调度**：Kubelet 在节点上调度一个 Pod 运行。\n2. **请求网络设置**：已调度的 Pod 请求 Kubelet 进行网络设置。\n3. **调用 CNI**：Kubelet 调用 CNI 处理 Pod 的网络设置。\n4. **创建网络命名空间**：CNI 为 Pod 创建一个网络命名空间，隔离其网络环境。\n5. **分配 IP 地址**：CNI 通过其 IP 地址管理（IPAM）插件为 Pod 分配一个 IP 地址。\n6. **设置网络接口**：CNI 在 Pod 的网络命名空间内设置必要的网络接口，将其连接到网络。\n7. **网络设置完成**：Pod 通知 Kubelet 其网络设置已完成。\n8. **带有网络运行的 Pod**：Pod 现在已经运行，并且其网络已配置，可以与 Kubernetes 集群中的其他 Pod 和服务通信。\n\n## CNI 工作流程 {#cni-process}\n\n容器网络接口（CNI）规范定义了容器如何配置网络，其中包括 \u0060ADD\u0060、\u0060CHECK\u0060、\u0060DELETE\u0060、\u0060GC\u0060 和 \u0060VERSION\u0060 五种操作。容器运行时通过调用各种 CNI 插件来执行这些操作，从而实现容器网络的动态管理和更新。\n\n\u0060\u0060\u0060mermaid \u0022CNI 工作流程\u0022\nsequenceDiagram\n    participant K as Kubelet\n    participant P as Pod\n    participant CNI as CNI Plugins\n    participant CNII as Interface CNI Plugin\n    participant CNIC as Chained CNI Plugin\n    participant NS as Network Setup\n    participant IPAM as IP Address Management\n\n    K-\u003e\u003e\u002bP: 调度 Pod\n    P-\u003e\u003eK: 请求网络设置\n    K-\u003e\u003eCNI: 调用 CNI 插件\n    CNI-\u003e\u003eCNII: 调用接口插件\n    CNII-\u003e\u003eNS: 设置网络接口\n    CNII-\u003e\u003eCNIC: 调用链式插件\n    CNIC-\u003e\u003eIPAM: 分配 IP 地址\n    IPAM-\u003e\u003eCNIC: IP 地址已分配\n    CNIC-\u003e\u003eNS: 应用网络策略\n    CNIC--\u003e\u003eCNI: 链式配置完成\n    CNI--\u003e\u003eK: 网络设置完成\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\n    Note over CNI,CNIC: CNI插件可以是接口类型或链式类型\n\u0060\u0060\u0060\n\n![CNI 工作流程](893d64215a1ed2a7e409925b258f32ee.svg)\n\n为了详细说明序列图中描述的每个步骤，涉及 Kubelet、Pod、CNI 插件（包括接口和链式 CNI 插件）、网络设置和 IP 地址管理（IPAM）之间的交互，让我们深入了解这个过程：\n\n1. **调度 Pod**：Kubelet 安排一个 Pod 在节点上运行。这一步启动了 Kubernetes 集群中 Pod 的生命周期。\n2. **请求网络设置**：Pod 向 Kubelet 发出网络设置请求。这个请求触发了为 Pod 配置网络的过程，确保它可以在 Kubernetes 集群内进行通信。\n3. **调用 CNI 插件**：Kubelet 调用配置的容器网络接口（CNI）插件。CNI 定义了一个标准化的方式，用于容器管理系统在 Linux 容器中配置网络接口。Kubelet 将必要的信息传递给 CNI 插件，以启动网络设置。\n4. **调用接口插件**：CNI 框架调用一个接口 CNI 插件，负责为 Pod 设置主要的网络接口。这个插件可能会创建一个新的网络命名空间、连接一对 veth 或执行其他操作，以确保 Pod 具有所需的网络接口。\n5. **设置网络接口**：接口 CNI 插件为 Pod 配置网络接口。这个设置包括分配 IP 地址、设置路由和确保接口准备好通信。\n6. **调用链式插件**：在设置网络接口之后，接口 CNI 插件或 CNI 框架调用链式 CNI 插件。这些插件执行额外的网络配置任务，比如设置 IP 伪装、配置入口\/出口规则或应用网络策略。\n7. **分配 IP 地址**：作为链式过程的一部分，链式 CNI 插件中的一个可能涉及 IP 地址管理（IPAM）。IPAM 插件负责为 Pod 分配一个 IP 地址，确保每个 Pod 在集群或命名空间内具有唯一的 IP。\n8. **IP 地址已分配**：IPAM 插件分配了一个 IP 地址，并将分配信息返回给调用插件。这些信息通常包括 IP 地址本身、子网掩码和可能的网关。\n9. **应用网络策略**：链式 CNI 插件将任何指定的网络策略应用于 Pod 的网络接口。这些策略可以规定允许的入口和出口流量，确保根据集群的配置要求进行网络安全和隔离。\n10. **链式配置完成**：一旦所有链式插件完成了它们的任务，Pod 的整体网络配置被认为已完成。CNI 框架或链中的最后一个插件向 Kubelet 发送信号，表明网络设置已完成。\n11. **网络设置完成**：Kubelet 收到了 Pod 的网络设置完成的确认。此时，Pod 具有完全配置的网络接口，具有 IP 地址、路由规则和应用的网络策略。\n12. **带有网络运行的 Pod**：Pod 现在已经运行，并配置了网络。它可以与 Kubernetes 集群中的其他 Pod 通信，根据网络策略访问外部资源，并执行其指定的功能。\n\n以下是针对 [CNI 官方示例](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md#appendix-examples)中的 \u0060ADD\u0060 操作、\u0060CHECK\u0060 操作和 \u0060DELETE\u0060 操作的示例序列图以及详细说明。通过这些操作，容器运行时与 CNI 插件之间进行交互，实现容器网络配置的动态管理和更新。\n\n### ADD 操作示例 {#add}\n\n以下是 ADD 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022ADD 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant PP as Portmap Plugin\n    participant TP as Tuning Plugin\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n\n    CR-\u003e\u003ePP: CNI_COMMAND=ADD\n    PP--\u003e\u003eCR: Portmap 配置完成\n    CR-\u003e\u003eTP: CNI_COMMAND=ADD\n    TP--\u003e\u003eCR: Tuning 配置完成\n    CR-\u003e\u003eBP: CNI_COMMAND=ADD\n    BP-\u003e\u003eHLP: CNI_COMMAND=ADD\n    HLP--\u003e\u003eBP: IPAM 配置完成\n    BP--\u003e\u003eCR: Bridge 配置完成\n\u0060\u0060\u0060\n\n![ADD 操作流程](4c05303a04984692bbba9bac12928387.svg)\n\n1. **容器运行时调用 Portmap 插件**：容器运行时通过调用 Portmap 插件执行 ADD 操作，配置容器的端口映射。\n2. **Portmap 配置完成**：Portmap 插件完成端口映射配置，并将结果返回给容器运行时。\n3. **容器运行时调用 Tuning 插件**：容器运行时调用 Tuning 插件执行 ADD 操作，配置容器的网络调优参数。\n4. **Tuning 配置完成**：Tuning 插件完成网络调优参数配置，并将结果返回给容器运行时。\n5. **容器运行时调用 Bridge 插件**：容器运行时调用 Bridge 插件执行 ADD 操作，配置容器的网络接口和 IP 地址。\n6. **Bridge 插件调用 Host-local 插件**：在完成自身配置之前，Bridge 插件调用 Host-local 插件执行 ADD 操作，配置容器的 IP 地址。\n7. **IPAM 配置完成**：Host-local 插件作为 IP 地址管理（IPAM）的授权方，完成 IP 地址分配，并将结果返回给 Bridge 插件。\n8. **Bridge 配置完成**：Bridge 插件完成网络接口和 IP 地址配置，并将结果返回给容器运行时。\n\n这些操作确保了在容器启动时，其所需的网络配置能够按照预期进行设置，包括端口映射、网络调优和 IP 地址分配等。\n\n### CHECK 操作示例 {#check}\n\n以下是 CHECK 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022CHECK 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n    participant TP as Tuning Plugin\n\n    CR-\u003e\u003eBP: CNI_COMMAND=CHECK with prevResult\n    BP-\u003e\u003eHLP: CNI_COMMAND=CHECK\n    HLP--\u003e\u003eBP: 返回无错误\n    BP--\u003e\u003eCR: 返回 0 返回码\n    CR-\u003e\u003eTP: CNI_COMMAND=CHECK with prevResult\n    TP--\u003e\u003eCR: 操作成功\n\u0060\u0060\u0060\n\n![CHECK 操作流程](eaf27d3bee18f3fe637b78d765c66d3c.svg)\n\n1. **容器运行时调用 Bridge 插件进行检查**：容器运行时通过调用 Bridge 插件执行 CHECK 操作，检查容器的网络配置是否符合预期。\n2. **Bridge 插件调用 Host-local 插件**：Bridge 插件调用 Host-local 插件执行 CHECK 操作，检查 IP 地址分配是否正常。\n3. **返回无错误**：Host-local 插件检查 IP 地址分配无异常，并返回无错误给 Bridge 插件。\n4. **返回 0 返回码**：Bridge 插件检查网络配置无异常，并返回 0 返回码给容器运行时。\n5. **容器运行时调用 Tuning 插件进行检查**：容器运行时调用 Tuning 插件执行 CHECK 操作，检查网络调优参数是否符合预期。\n6. **操作成功**：Tuning 插件检查网络调优参数无异常，返回操作成功给容器运行时。\n\n这些操作确保了在容器运行期间，其网络配置和网络调优参数能够按照预期进行检查和验证，以确保网络配置的一致性和正确性。\n\n### DELETE 操作示例 {#delete}\n\n以下是 DELETE 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022DELETE 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant PP as Portmap Plugin\n    participant TP as Tuning Plugin\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n\n    CR-\u003e\u003ePP: CNI_COMMAND=DEL\n    PP--\u003e\u003eCR: Portmap 删除完成\n    CR-\u003e\u003eTP: CNI_COMMAND=DEL\n    TP--\u003e\u003eCR: Tuning 删除完成\n    CR-\u003e\u003eBP: CNI_COMMAND=DEL\n    BP-\u003e\u003eHLP: CNI_COMMAND=DEL\n    HLP--\u003e\u003eBP: IPAM 删除完成\n    BP--\u003e\u003eCR: Bridge 删除完成\n\u0060\u0060\u0060\n\n![DELETE 操作流程](f7506b2840f92ecda6ad52e98a92e79c.svg)\n\n1. **容器运行时调用 Portmap 插件**：容器运行时通过调用 Portmap 插件执行 DELETE 操作，删除容器的端口映射配置。\n2. **Portmap 删除完成**：Portmap 插件完成端口映射的删除，并将结果返回给容器运行时。\n3. **容器运行时调用 Tuning 插件**：容器运行时调用 Tuning 插件执行 DELETE 操作，删除容器的网络调优参数配置。\n4. **Tuning 删除完成**：Tuning 插件完成网络调优参数的删除，并将结果返回给容器运行时。\n5. **容器运行时调用 Bridge 插件**：容器运行时调用 Bridge 插件执行 DELETE 操作，删除容器的网络接口和 IP 地址配置。\n6. **Bridge 插件调用 Host-local 插件**：在完成自身删除之前，Bridge 插件调用 Host-local 插件执行 DELETE 操作，删除容器的 IP 地址分配。\n7. **IPAM 删除完成**：Host-local 插件完成 IP 地址分配的删除，并将结果返回给 Bridge 插件。\n8. **Bridge 删除完成**：Bridge 插件完成网络接口和 IP 地址的删除，并将结果返回给容器运行时。\n\n这些操作确保了在容器停止运行时，其所需的网络配置能够被正确清理和移除，以确保网络资源的有效释放和管理。\n\n通过对 ADD、CHECK 和 DELETE 操作的示例序列图及详细说明，可以清晰地了解容器运行时与 CNI 插件之间的交互过程，以及如何实现容器网络配置的动态管理和更新。\n\n## 总结 {#summary}\n\nCNI 为容器化环境中的网络管理提供了一种标准化的接口，通过与 CRI 的配合，确保了 Kubernetes 集群中容器的网络配置高效且一致。通过深入理解 CNI，开发者和系统管理员可以更好地管理和优化其容器网络。\n\n## 参考 {#references}\n\n- [CNI 规范](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md)\n', '\/blog\/cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细解释了 CNI（容器网络接口）的基本概念、核心组件以及其与 CRI（容器运行时接口）的关系。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/kubernetes-networking-by-using-cilium-beginner-level/">[译] 解密 Kubernetes 网络：跟随数据包的奇妙旅程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.dbi-services.com/blog/kubernetes-networking-by-using-cilium-beginner-level/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('解密 Kubernetes 网络：跟随数据包的奇妙旅程', '本文介绍了传统网络和 Kubernetes 网络的基本概念。通过比喻和图示，解释了 IP 地址、子网、MAC 地址等概念，并以“跟随数据包”的方式讲解了网络通信的过程。同时，也对 Kubernetes 中的网络通信进行了类比，解释了 Pod、CNI 和 eBPF 的概念。整体而言，文章从简单到复杂地讲解了网络通信的原理，便于读者理解。', '\n最近对于理解 Kubernetes 中的网络有很大的兴趣。本文是我对这个话题的贡献。我会尽力用直观的方式解释，并将技术部分翻译成易懂的语言，以便任何人都能理解。\n\n最好的学习网络的方式是通过“追踪数据包”或“数据包的生命周期”。基本上，你要跟随数据包从发送者到接收者的旅程，并在每一步停下来。我以前就用 [Calico 实现的 Pod 到另一个 Pod 的通信](https:\/\/www.dbi-services.com\/blog\/exploration-of-calico-in-minikube\/) 进行了这样的操作。这次我将使用另一个容器网络接口 (CNI) 叫做 [Cilium](https:\/\/cilium.io\/)，它基于 eBPF（了解快速和灵活的路由），并带有许多强大的功能和工具。让我们开始吧！\n\n## Kubernetes 中的传统网络\n\n我们将从头开始。我会假设你对网络一无所知。也许你已经知道 IP 地址是什么？IP 地址是计算机网络接口的数字地址。这就是你的计算机可以连接到你的 Wi-Fi 网络并让你访问互联网的方式。如果你使用的是笔记本电脑，你的 Wi-Fi 网络接口有一个 IP 地址。这个网络接口还有另一个由硬件提供商烧录的唯一地址。这个地址称为介质访问控制 (MAC) 地址。\n\nIP 地址属于一个组（IP 子网）。为了知道它属于哪个组，它使用一种称为子网掩码的东西。当子网掩码应用到 IP 地址时，会得到一个结果，对于属于同一组的每个 IP 地址来说，这个结果都是相同的。这就像你所在的社区一样。\n\n让我们用下面的图来做类比：\n\n![传统网络](f1.png)\n\n房子是一台计算机、服务器或虚拟机。它的大小可以不同，根据它的 CPU 和内存，但为了简单起见，我们使用相同的大小。一栋房子有一扇门，这就是你的网络接口。门上的序列号是你的 MAC 地址，房子上的数字（通常是钉在门上的）是你的 IP 地址。只有在你换门时，你的序列号才会改变。然而，你的房子号码是由你的社区的建筑师分配的，如果有重新分配或设计更改，它可能会改变。\n\n蓝色的第 10 个社区（使用从 10 到 19 的数字）属于同一组（同一 IP 子网），而绿色的第 20 个社区是另一组。在每个社区中，有五栋房子，所以有空间让社区成长。在每个社区里，门直接连接到一个喷泉，代表一个交换机。在喷泉处，有一个指示每条路径的标志，指示你可以到达哪扇门。是的，喷泉不知道房子号码，只知道门的序列号。对于人类来说，这不是很方便，所以我们使用一张地图（称为 ARP 表），它提供了房子号码与门的序列号之间的转换。\n\n如果你住在 14 号房子，想拜访 15 号房子，你会使用这条路（只有一条，而且是你的，所以不会有交通堵塞！）先到达喷泉，然后看看标志。你从地图上知道哪个序列号对应哪个房子，所以你可以沿着通往 15 号房子的路线前往。在这种星形拓扑中，你总是先去喷泉，而不是直接去你想要拜访的房子，因为没有直接的路径。社区内的路径代表了第 2 层链接。你无法通过这些路径到达另一个社区。\n\n### 在社区之间旅行\n\n现在，如果从你的 14 号房子，你想要去拜访 24 号房子怎么办？这是另一个社区，这意味着 14 号的 IP 地址\/子网掩码与 24 号不同。实际上，第 10 和第 20 社区是不同的。所以你知道目的地是另一个社区，这种情况下，你必须首先去找你的门卫（但总是通过喷泉，正如我们所见）。他是你社区的默认网关，他住在 11 号房子。规则是去找他，对于任何目的地在你社区之外的地方。\n\n只有他有地图（路由表）能够到达第 20 号社区，并且知道应该走哪条路（这被称为第 3 层路由，因为你正在离开你的社区）。这张地图显示了到达 20 号社区的正确门。等一下，如果一扇门是一个网络接口，那么门卫房子是不是还有另一扇门？完全正确！11 号房子有另一扇门，门上有另一个号码（101），当然这扇门上有另一个序列号（MAC 地址）。\n\n通过这扇门出去，你现在可以沿着路径到达第 20 号社区，这个社区有自己的门卫在 21 号房子。这个门卫的地图（路由表）指导你到达目的地的正确门。这扇门让你进入了第 20 号社区，因为你的目的地 24 属于它。门卫还给了你地图（ARP 表），所以你可以在喷泉上找到方向。现在，你可以沿着通往绿色喷泉的路径走了。从那里，你只需跟着标志和路径到达 24 号房子。当你想回家时，你沿着相反的方向走同样的路径回去。\n\n## Kubernetes 中的网络\n\n现在你了解了网络的基础知识，让我们来看看在 Kubernetes 中它是如何工作的。是的，它稍微复杂一些，但让我们一步一步来，使用下面的图片来更好地理解：\n\n![使用 Cilium 的 Kubernetes 网络](f2.png)\n\n我们现在没有房子，而是建筑。建筑之间的网络与传统网络仍然相同，中间有一个交换机\/喷泉。建筑的入口有一扇门，上面有建筑的号码（它的 IP 地址），它是 1000 个社区的一份子。一个建筑将代表我们 Kubernetes 集群的一个节点。\n\n你知道 Kubernetes 是一个容器编排器。一个容器包装成一个 pod。为了简单起见，让我们假设一个 pod 只有一个容器，因此这两个术语在这里是等价的。这个 pod 就像我们建筑中的一个私人部分。公寓的大小可以不同，因为它可能有 2、3 或 4 个卧室，这将是你的容器在节点上需要的 CPU 和内存容量。有些公寓是空的，所以建筑仍然有一些容量。然而，在 Kubernetes 中，pod 是根据需要创建和删除的。所以在我们的建筑中，这意味着有时会创建一个 2 卧室的公寓，当不再使用时，它可能会被从建筑物中移除。然后，如果建筑有足够的空间，可能会创建一个 5 卧室的公寓。然后想象一下，这是一座乐高建筑，里面你可以根据需要建造和拆除不同大小的公寓！这不是很棒吗？\n\n在每个建筑物中，容器\/pod 有自己的社区（IP 子网）。在 Kubernetes 中，CNI 的功能基本上是为 pod 分配号码（IP 地址），以便它们可以彼此通信。默认情况下，Cilium 为每个建筑使用不同的社区。当创建一个公寓时，Cilium 会为其分配一个号码。当删除并重新创建一个公寓时，它将获得另一个号码，因此它是临时的。这里蓝色的社区使用 10 号范围，绿色的社区使用 20 号。你可以注意到蓝色和绿色社区的数字范围与建筑物的范围不同。只是为了让你知道，这种设计被称为叠加网络。还有其他可能的，但这是常用的一种。这是一个在节点网络之上的 pod 网络。\n\n### 在同一建筑中的公寓之间旅行\n\n现在，你住在 12 号公寓，你要怎么去拜访 14 号公寓？就像我们在传统网络示例中所做的那样，你是我们要追踪的数据包！当然，你通过它的门（它的网络接口）离开公寓。与我们之前的示例不同之处在于，你现在不是离开房子，而是离开了你的公寓，但仍然在建筑物内部。然后你走过一个私人走廊，到达另一扇门（这是 LXC 接口）。\n\n这扇门给了你进入建筑的公共空间的访问，这里进行了路由和派发。我们称之为 Cilium 大厅（蓝色矩形）。当选择 Cilium 为这个 Kubernetes 集群提供通信时，每个建筑物都安装了这个大厅的 Cilium 代理。大厅里有一个门卫，他不住在公寓里，而是在大厅的一个甲板上等待。他有一个服务人员团队，在建筑物的不同门处等候提供指导。这是因为 Cilium 使用一个叫做 eBPF 的魔法路由地图，有效地帮助旅行者。\n\n当你到达走廊尽头的门时，你向等在这里的服务人员表示你要去 14 号。他在他的魔法 eBPF 地图中找到了一个与 14 号相匹配的项目，并直接向你展示了右上角的走廊门。你不必去大厅，他向你展示了一条秘密通道，直接到达那里。然后你打开那扇门，跟着走廊，到达了 14 号公寓。你回去到 12 号公寓，沿着相同的路径和过程，但是方向相反。\n\n因此，这种调度与传统的交换方式不同，并且非常快速，这要归功于魔法 eBPF 地图！\n\n### 在不同建筑物的公寓之间旅行\n\n现在，从 12 号公寓，你想去拜访另一个建筑物里的 22 号公寓。你的旅行开始和以前一样，你离开你的公寓，沿着走廊，询问等待在这里的服务人员的方向。由于目的地是另一个社区的 22 号，这次他把你引导到了大厅。在这里，与传统网络一样，你需要大厅中的门卫的帮助。门卫查看他的地图（路由表），指引你去 22 号的方向，并向你展示要使用的门号码 11（cilium_host）。\n\n当你打开那扇门时，你会看到后面有另一扇门：那就是蓝色的三角形，称为 VXLAN 接口。这扇门通向一个漂亮的透明隧道，穿过建筑物的主门。你受到雨水的保护，可以欣赏到另一个建筑物的景色。你甚至可以看到室外的喷泉！当你到达绿色建筑物时，你离开隧道，去见在绿色三角形（VXLAN 接口）处等待你的服务人员。你告诉他你的目的地，他在他的魔法 eBPF 地图中找到了与 22 号相匹配的项目，并向你展示了一条通往左上角走廊门的秘密通道。然后你跟着走廊，到达了你的目的地。和以前一样，你回去的路线将沿着相同的路径，但方向相反。\n\n这就是第 3 层路由，因为目的社区与你的不同。你可以看到在 Kubernetes 中比传统路由稍微复杂一些。\n\n## 总结\n\n希望这有助于你理解传统网络和 Kubernetes 网络之间的区别，也希望后者现在对你来说更清晰了。如果这就是你所需要的，那么我很高兴你阅读了这篇博文，希望你喜欢它。如果你现在想了解更多关于 Kubernetes 网络的内容，请保持关注，因为我将写一篇 [中级篇](https:\/\/www.dbi-services.com\/blog\/kubernetes-networking-by-using-cilium-intermediate-level-part-1\/)，你将在其中看到一个真实集群上建筑物的样子！\n', '\/trans\/kubernetes-networking-by-using-cilium-beginner-level\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了传统网络和 Kubernetes 网络的基本概念。通过比喻和图示，解释了 IP 地址、子网、MAC 地址等概念，并以“跟随数据包”的方式讲解了网络通信的过程。同时，也对 Kubernetes 中的网络通信进行了类比，解释了 Pod、CNI 和 eBPF 的概念。整体而言，文章从简单到复杂地讲解了网络通信的原理，便于读者理解。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/scaling-cilium-to-new-heights-with-xds/">[译] Cilium 的控制平面升级之路：xDS API 的引入与应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.solo.io/blog/scaling-cilium-to-new-heights-with-xds/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cilium 的控制平面升级之路：xDS API 的引入与应用', '本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。', '\n在这篇博客中，我们将探讨当前的 Cilium 控制平面设计，[大规模部署可能出现的限制的位置和原因](https:\/\/github.com\/cilium\/cilium\/issues\/30283)，以及社区如何使用 CNCF 的 [通用数据平面 (xDS) API](https:\/\/github.com\/cncf\/xds) 推进这个架构。\n\n## 了解 Cilium 的控制平面架构\n\nCilium 遵循基于“数据平面”和“控制平面”的常见网络架构。在 Cilium 中，数据平面部署在每个主机（或 Kubernetes 节点）上，包括用于处理 L3\/L4 连接和策略的 eBPF 程序。为了简化起见，对于完整性，Cilium 还在其数据平面中使用 Envoy 代理处理 L7 策略，但我们将省略这部分。\n\n![](f1.jpg)\n\nCilium 控制平面以 cilium-agent 守护程序的形式实现，部署在每个 Kubernetes 节点上。每个 cilium-agent 都是控制平面的单独、独立的实例。\n\ncilium-agent 连接到 Kubernetes API 服务器，监视配置更改，然后使用它来配置数据平面。cilium-agent 还将配置写入 Kubernetes API，表示正在其各自节点上创建的端点或标识。\n\n例如，当在 Kubernetes 节点上启动一个 Pod 时，cilium-agent 负责编写一个 CiliumEndpoint 自定义资源（CR），并可能是一个表示 Pod 网络标识的 CiliumIdentity CR。cilium-agent 还会更新与标识和端点映射相关的节点上的 eBPF 映射。其他 Kubernetes 节点上的 cilium-agent 也会监视这些新的 CiliumEndpoint 和 CiliumIdentity CR 的创建，并更新其本地的 eBPF 数据平面以执行策略。这种机制能够协调每个节点上的全局策略执行配置，以便所有节点看到相同的执行行为。\n\n![](f2.jpg)\n\n## 构建控制平面的最佳实践\n\n我们以前 [曾多次在博客中](https:\/\/www.solo.io\/blog\/building-a-control-plane-for-envoy\/) [讨论过构建](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) [可扩展、安全、高效的控制平面的最佳实践](https:\/\/www.solo.io\/blog\/why-the-control-plane-matters\/)。在深入研究如何扩展 Cilium 的控制平面之前，我们应该回顾一些这些最佳实践。\n\n网络架构中的数据平面应该尽可能简单，性能高，以及高效完成它需要做的事情：在本例中，来回传输字节，实施策略，并执行安全性。控制平面的作用是保护数据平面免受复杂性的干扰，以及任何分散数据平面核心任务的事物。\n\n另一方面，用户需要能够以最适合他们用户体验的形式指定配置和策略。很多时候，通过某种 [特定领域的配置格式](https:\/\/www.solo.io\/blog\/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration\/) 来实现。然后需要将这种更高级别的用户配置与基础设施状态相结合，并将其转化为较低级别的数据平面格式。转译是一半的战斗。还需要将较低级别的配置分发到数据平面，并高效地执行。这就是控制平面出现在画面中的地方。\n\n![](f3.jpg)\n\n控制平面允许配置解耦并与平台的其他部分集成，这些部分随后可以通知数据平面。在许多方面，这个图表与我们构建应用程序时使用的 [三层架构](https:\/\/learn.microsoft.com\/en-us\/azure\/architecture\/guide\/architecture-styles\/n-tier) 类似：表示层，解耦的业务逻辑层和数据存储。\n\n![](f4.jpg)\n\n在网络架构的情况下，控制平面层将处理读取\/写入 Kubernetes API 和创建网络标识等敏感数据。由于它是一个单独的层，我们可以对其进行安全和硬化处理，并消除数据平面需要执行这些任务的权限。在许多情况下，虽然开始时更简单，但合并一些层会导致效率低下、安全问题和扩展\/耦合问题。\n\n## Cilium 控制平面架构的扩展考虑\n\n集群中的每个 cilium-agent 负责将全局集群配置更新到其本地数据平面配置。每个 cilium-agent 可能会监视多达 15 种 CRD 类型。\n\n随着集群在节点、Pod、命名空间和网络策略方面的规模增长，每个 cilium-agent 需要执行的工作量也会增加。为了服务和更新所有这些状态，会对 Kubernetes apiserver 造成压力，可能导致 [问题](https:\/\/github.com\/cilium\/cilium\/issues\/29127)。\n\n![](f5.jpg)\n\n在大规模部署中，这种对 Kubernetes API 服务器的压力可能最终会减慢 *甚至导致* 集群中的所有操作。\n\n在查看集群中的常见操作以及 cilium-agent 处理它的方式时，全局配置状态对每个节点的影响确实开始放大：工作负载和命名空间被标记、重新标记或取消标记。\n\ncilium-agent 负责为调度到其节点上的 Pod 编写 CiliumEndpoint 和 CiliumIdentity 资源。由于这些资源依赖于 Pod 和命名空间标签的组合，标签的更改将导致所有依赖资源的更新。这会导致大量的写操作和相应的读取操作，因为此状态随后会传播到所有 cilium-agent，它们必须做出反应并重新配置其本地数据平面。\n\n\u0060\u0060\u0060yaml\napiVersion: cilium.io\/v2\nkind: CiliumIdentity\nname: \u002250568\u0022\nmetadata:\n  labels:\n    app: sleep\n    io.cilium.k8s.policy.cluster: default\n    io.cilium.k8s.policy.serviceaccount: sleep-v1\n    io.kubernetes.pod.namespace: default\n    version: v1\nsecurity-labels:\n  k8s:app: sleep\n  k8s:io.cilium.k8s.namespace.labels.team: loyalty\n  k8s:io.cilium.k8s.namespace.labels.version: v10.45\nk8s:io.cilium.k8s.namespace.labels.kubernetes.io\/metadata.name: default\n  k8s:io.cilium.k8s.policy.cluster: default\n  k8s:io.cilium.k8s.policy.serviceaccount: sleep-v1\n  k8s:io.kubernetes.pod.namespace: default\n  k8s:version: v1\n\u0060\u0060\u0060\n\n**代码清单 1：\u0060CiliumIdentity\u0060 资源结合了 *Pod* 和 *命名空间* 标签。对任一者的更改都会强制重新计算并生成新的 \u0060CiliumIdentity\u0060。**\n\n对集群中的命名空间进行标记等操作对于 Cilium 可能非常昂贵，并且有可能导致 API 服务器操作减慢到爬行的程度（[请参阅用于标识目的包括\/排除标签的建议](https:\/\/docs.cilium.io\/en\/stable\/operations\/performance\/scalability\/identity-relevant-labels\/)）。例如，在中等规模集群中更改命名空间的标签可能会导致足够多的 cilium-agent 导致 Kubernetes API 服务器响应延迟约 **4 分钟**。这将有效地使集群上的所有操作停滞不前。\n\n考虑以下环境：\n\n- 200 个节点的 Kubernetes 集群\n- 5 个命名空间\n- 每个命名空间有 50 个部署\n- 每个部署有 80 个副本（总共 20,000 个 Pod）\n\n在一次更新跨命名空间的标签的测试中，我们看到 CPU 利用率急剧上升，约为 150%，并且内存在整个集群的所有节点上升到约 1 GB。\n\n![图 1：所有节点上的 CPU 和内存峰值](g1.jpg)\n\n在整个集群的所有节点上同时提高 CPU 和内存是不希望看到的行为，然而更严重的是 cilium-agent 事件的读写如何影响 Kubernetes API 服务器的延迟。在下图中，我们看到延迟增长到 3 到 4 *分钟*。这肯定会导致各种类型的停机！不幸的是，由于这种控制平面架构，通过增加容量来处理扩展问题的典型方法不起作用；实际上，添加更多节点和\/或更多工作负载会放大这种行为。\n\n![图 2：Kubernetes API 服务器延迟增加到 3 - 4 分钟](g2.jpg)\n\n## 减轻 Kubernetes API 服务器的压力\n\n对于较大的 Cilium 集群，您可以通过使用[专用的键值存储](https:\/\/docs.cilium.io\/en\/latest\/kvstore\/) 来减轻 Kubernetes API 服务器上的压力。键值存储用于存储工作负载标识、端点和 IP 到标识映射等内容。Cilium 不再将此信息存储在 Kubernetes 自定义资源（CRD）中，而是在其自己的数据库中直接监视、操作和写入对象。Cilium Helm 图表支持将 etcd 作为专用键值存储来进行安装，以满足此目的。\n\n随着集群的增长，使用 kv-store 来卸载 Cilium 对象的读\/写操作可能是一个好主意，而不是给 Kubernetes API 服务器施加压力。\n\n注意：Cilium 还进行了其他优化，以减轻 Kubernetes API 服务器的压力，例如策略状态更新。有关更多信息，请参阅[k8s-events-handover 文档](https:\/\/docs.cilium.io\/en\/stable\/internals\/cilium_operator\/#policy-status-update)。\n\n如果我们在存在 kv-store 的情况下重新运行先前的测试，我们会看到对 Kubernetes API 服务器的压力减轻，尽管 CPU 可能没有减轻。\n\n![图 3：所有节点上的 CPU 峰值，内存保持在 300-400 MB 范围内](g3.jpg)\n\n与先前情况下的 150% CPU 消耗不同，CPU 在大约 100% 左右波动，而内存保持在大约 300 到 400 MB 的范围内。这是因为对每个 Pod 和每个标识（Cilium 在更改标签时创建所有新标识，并且必须更新引用旧标识的所有 eBPF 映射的 CiliumEndpoint 和 CiliumIdentity 对象的重新计算和生成需要 CPU 计算资源来完成，无论使用何种后备存储（CRD、kv-store 等）。\n\n如果我们观察 kv-store，我们会看到在此命名空间标签事件期间，事件操作\/秒和延迟会急剧上升：\n\n![图 4：kv-store 上的事件操作和延迟在此命名空间标签事件期间急剧上升](g4.jpg)\n\n在这种特殊情况下，我们看到 kv-store 承受了相当大的负载，通过事件 IO，我们看到 kv-store 调用的延迟降低到约 15 秒左右。总之，这对于整个集群操作而言要好得多，而不是用请求使 Kubernetes API 服务器饱和。事实上，在图 5 中，我们可以看到 Kubernetes API 服务器的延迟保持在 10 到 40 毫秒的可接受范围内，而在先前的示例中，延迟升高到 4 分钟。\n\n![图 5：Kubernetes API Server 延迟在 10 到 40ms 之间](g5.jpg)\n\n使用 kv-store 后端来存储 Cilium 对象是一种缓解 Kubernetes API 服务器压力的好方法，但它也有其缺点。现在有两个持久存储需要维护，而且随着规模的增加，运维负担也增加。在生产环境中运行数据库或持久存储（总体来说）以支持规模化并非易事。如果失去一致性，恢复过程是必需的，因为现在有两个“真相源”。许多平台完全管理 Kubernetes API 服务器及其存储，但 kv-store 并不是如此。由于绝大多数负载是读取操作，缓存将在减少运维复杂性的同时产生相同的改进。\n\n## 使用 xDS 改进 Cilium 的控制平面扩展、安全性和效率\n\n如果我们可以兼顾两全呢？既减轻 Kubernetes API 服务器的压力，又消除维护单独数据存储的昂贵生产操作的需要？甚至可能解决一些其他尚未解决的 Cilium 扩展和安全性问题？\n\n在 Solo.io，我们很高兴为 Cilium 社区中更广泛的 xDS 工作作出贡献，并帮助推动该项目朝着可扩展、安全和高效的控制平面迈进。使用[xDS 协议](https:\/\/github.com\/cncf\/xds)使我们能够在集群中扩展到数千甚至数万个节点。这种方法解决了上面讨论的许多问题，以及其他问题，如单节点妥协影响范围和规模上的 CiliumIdentity 重复。让我们看看它是如何工作的。\n\n[xDS 协议](https:\/\/github.com\/cncf\/xds)最初是一种动态配置[Envoy 代理](https:\/\/www.envoyproxy.io\/)的方式，但是它建立的理念是可以用来支持“通用数据平面”。该协议已成为在多个节点之间同步状态的有效方式，[现在由 CNCF 工作组管理](https:\/\/github.com\/cncf\/xds)。\n\n最终，我们希望消除每个 cilium-agent 所做的冗余工作，将诸如标识创建之类的复杂且权限敏感的操作集中在一起，并以高效的方式为代理提供状态，同时不损害 Kubernetes 作为整体的可靠性。\n\n为了做到这一点，我们将不再让每个 cilium-agent 充当独立的控制平面，而是考虑让 cilium-agent 充当智能集中控制平面的简单只读客户端。控制平面将保护代理免受复杂和权限敏感的操作。\n\ncilium-agent（现在属于数据平面的一部分）与控制平面之间的通信将采用[xDS 协议](https:\/\/github.com\/cncf\/xds)。数据平面不允许从数据平面到控制平面的写操作，因此 cilium-agent 不需要对后端存储（CRD\/kv-store）具有写入访问权限。xDS 控制平面服务可以得到安全加固，是唯一需要支持对 Kubernetes API 服务器进行读\/写操作的组件。\n\n![](f6.jpg)\n\n这种架构减轻了 Kubernetes API 服务器的负载，并且不需要任何外部管理的数据存储。它看起来也更接近之前讨论的三层控制平面架构。\n\n![图 6：xDS 实现的初始测试显示 CPU 和内存使用的预期行为](g6.jpg)\n\n在这种架构中，我们确实看到了 xDS 控制平面 pods 中的 CPU 和内存开销，正如预期的那样，每个节点仍然需要处理 eBPF 数据平面的一些 CPU\/内存处理开销。\n\n这种模型带来的其他好处包括在节点受损时更小的影响范围，以及消除了 cilium-agent 创建的重复标识。在原始架构（CRD 或 kv-store）中，每个节点都有一个完整的控制平面，需要特殊权限来读取和写入\u0060\u0060CiliumEndpoints\u0060\u0060和\u0060\u0060CiliumIdentity\u0060\u0060。如果某个节点上的 cilium-agent 受到妥协，那么整个控制平面将受到威胁，并使攻击者能够影响其他节点。这可能导致整个集群妥协。在 xDS 模型中，cilium-agent 被允许从控制平面读取数据（不允许写入），单个 cilium-agent 的妥协不会给予对整个控制平面或集群的访问权限。正如前面提到的，xDS 控制平面被视为特权组件，可以进行锁定和安全设置，甚至可以完全在集群之外运行。\n\nxDS 方法的另一个好处是通过集中标识创建来消除 Cilium 中重复标识的生成。在现有模型中，每个 cilium-agent 都独立充当控制平面，与其他节点隔离，正如在现有模型中，它试图做出可能是重复的决策。例如，当 Pod 分配到节点时，CNI 负责设置网络端点，当 cilium-agent 识别到一个新的端点，它没有现有的\u0060\u0060CiliumIdentity\u0060\u0060时，它将尝试创建它。如果命名空间标签发生更改并且需要重新计算所有标识，那么也会发生相同的情况。由于标识创建在多个节点上独立进行，因此有很大机会为相同标识创建多个\u0060\u0060CiliumIdentity\u0060\u0060（在极端情况下，[如此描述的易于重现](https:\/\/docs.google.com\/document\/d\/1Hcc_2mB9OOUxrqQgZ-gSYDPnLYE_If_TCzVbUGDOdGM\/edit?pli=1#heading=h.yzvq0akbw7z9)）。在 xDS 方法中，\u0060\u0060CiliumIdentity\u0060\u0060在集中创建，从而消除了这种情况。\n\n## 结论\n\nCilium 在 eBPF 基础上构建了强大的数据平面，但要使 Cilium 在规模上有效运行，我们可以利用 xDS 协议来改进控制平面架构。xDS 是一种高效的协议，允许我们利用多年来学到的构建控制平面的最佳实践。事实上，如果我们将 xDS 控制平面 [直接构建到 cilium-operator 中](https:\/\/docs.google.com\/document\/d\/1U4pO_dTaHERKOtrneNA8njW19HSVbq3sBM3x8an4878\/edit#heading=h.ghzkbpzc9oea)，那么从这个实施中不会增加新的复杂性。\n', '\/trans\/scaling-cilium-to-new-heights-with-xds\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文探讨了 Cilium 的控制平面设计，分析了其在大规模部署中的局限性，以及如何使用 xDS API 来改进其架构和性能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes/">[译] KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.kedify.io/blog-posts/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？', '本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。', '\n### 1. 引言：自动伸缩的重要性\n\n在今天的云原生生态系统中，波动的工作负载和动态的流量模式是常态。适应这种不可预测的行为需要能够实时调整的系统。自动伸缩是必需的，可以确保资源的最佳分配，遏制过度成本，并促进资源的高效使用。\n\n自动伸缩不仅关乎成本。它在维护应用性能和吞吐量方面发挥着关键作用。通过避免欠配置（导致用户体验不佳）和过度配置（导致不必要的成本），自动伸缩可以实现合理的平衡。\n\n### 2. 竞争者：了解基础知识\n\n### 水平 Pod 自动伸缩器（HPA）\n\n[HPA](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/)，作为 Kubernetes 的本地解决方案，根据观察到的指标（主要是 CPU 和内存）来扩展 Pod 的数量。虽然对于统一的工作负载来说非常直接和有益，但当考虑到其无法扩展到零并且完全依赖 CPU 和内存指标时，它的局限性就变得明显了。\n\n![HPA 改变 Pod 的数量](1.jpg)\n\n### 垂直 Pod 自动伸缩器（VPA）\n\n[VPA](https:\/\/github.com\/kubernetes\/autoscaler\/tree\/master\/vertical-pod-autoscaler#intro)更多地涉及资源的调整而不是扩展它们。它评估需求并动态调整资源，确保工作负载的合适适配。但这里有一个问题：增强型的 Pod 并不一定更好。有时，拥有更多的工作进程来处理数据比拥有一个大而强大的工作进程更高效。\n\n![VPA 调整 Pod 的大小](2.jpg)\n\n## 3. 限制：当原生 Kubernetes 自动伸缩器不足以应对时\n\n尽管内置的 Kubernetes 自动伸缩器如 HPA 和 VPA 提供了基本的扩展能力，但它们在范围上天然有限。它们主要关注 CPU 和内存指标可能对于现代应用来说是一个重大限制，因为这些应用可能需要对各种指标做出反应，其中一些甚至可能不是来自应用程序本身的指标。\n\n现代应用面临的引人注目的挑战之一是根据外部系统的事件来进行扩展。例如：\n\n- **消息队列：** 应用程序可能需要根据队列中的消息数量（如 RabbitMQ 或 Kafka）来进行扩展。如果有大量未处理的消息涌入，这可能是一个扩展的指标。\n- **数据库触发器：** 数据库中的更改或更新（如某个表的行突然增加）可能需要将应用程序进行扩\n\n展以处理或分析数据的涌入。\n- **外部 Webhook：** 来自第三方服务的传入 Webhook（例如 GitHub 推送或电子商务交易事件）可能需要更多的资源来处理额外的负载。\n- ‍**IoT 信号：** 对于连接到物联网设备的应用程序，来自这些设备的信号可能是需要扩展的指标。\n\n此外，还存在将扩展到零的必要来有效管理资源的情况，或者存在不同指标的组合决定扩展逻辑的情况，例如 CPU 利用率与数据库读\/写速率。这些微妙的需求突显了内置 Kubernetes 自动伸缩器的不足之处。‍\n\n### HPA 的自定义指标扩展\n\nKubernetes 引入了一个[自定义指标](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/#scaling-on-custom-metrics)的接口，旨在为水平 Pod 自动伸缩器（HPA）提供更多超越 CPU 和内存指标的适应性。然而，实际实现中出现了挑战。\n\n尽管强大，但自定义指标 API 并不直观易用。它要求对 Kubernetes 内部有详细的了解，使设置和调整变得繁琐。‍\n\n### 插曲：Prometheus 适配器\n\n[Prometheus 适配器](https:\/\/github.com\/kubernetes-sigs\/prometheus-adapter)试图通过利用自定义指标 API 来弥合这一差距，引入了 Prometheus 的广泛指标。但它也有一些缺点：复杂、不直观的配置以及仅与 Prometheus 指标相关联。实施和维护配置需要不断的警觉性。基础架构或应用程序的更改可能会触发重新配置的需求。\n\n### 4. 登场 KEDA：对决中的英雄\n\n[Kubernetes 事件驱动自动伸缩（KEDA）](https:\/\/keda.sh\/)不仅与 Kubernetes 的自定义指标 API 集成，还使其变得更加可访问。这是用户友好界面如何改变体验的证明，使自动伸缩真正具有可定制性和多功能性。\n\n### KEDA 的好处\n\nKEDA 提供了多个技术优势：\n\n- **事件驱动自动伸缩：** KEDA 能够响应特定事件，甚至扩展到零，确保资源得到明智地使用。\n- **易于使用：** 其直观的配置使实施变得轻松，允许开发人员专注于应用逻辑而不是配置语法。\n- **广泛应用：** 除了仅扩展 Pod 外，KEDA 还可以基于事件安排 Kubernetes 作业，适用于不需要持续运行但可能需要定期大量资源的任务。\n- **多功能集成：** 支持多种身份验证提供程序，集成 KEDA 既简单又安全。‍\n\n### KEDA 在实践中的应用\n\n![KEDA 扩展 Kafka Consumer 应用程序](3.jpg)\n\n虽然传统的指标如 CPU 和内存提供了一些见解，但现实世界的应用程序通常需要更精细和多样化的指标来进行有效的自动伸缩。以下是一些要考虑的情景：\n\n- **事件驱动应用程序：** 考虑一个基于 Kafka 的设置。虽然 CPU 使用率可能保持稳定，但传入 Kafka 事件的激增是确定负载的真正指标。在这种情况下，自动伸缩应该理想地对入站事件的速率或消息积压做出响应。\n- **电子商务交易：** 在电子商务框架中，特殊销售活动可能会导致订单结帐激增。CPU 可能不受影响，但真正的负载可能是数据库队列中积累的未处理订单。\n- **流数据管道：** 从平台（如 Apache Kafka 或 AWS Kinesis）处理数据流的应用程序会经历可变的数据流入率。在这里，相关的指标可能是处理的积压或滞后，而不是 CPU 或内存消耗。\n- **Selenium 测试工作者：** 在持续集成（CI）流水线中，当提交新代码时，可能会触发一系列 Selenium 测试。这里真正的度量标准可能是等待测试的队列。如果有大量等待测试的测试存在瓶颈，基于这个队列来自动伸缩 Selenium 工作者比仅仅观察 CPU 或内存指标更有效。\n- **API 速率限制：** 对于大量依赖第三方 API 且具有速率限制的应用程序，接近速率限制可能是需要进行伸缩的信号。与对速率限制错误的被动反应不同，基于 API 调用频率进行主动伸缩可以确保操作顺利进行。\n\n这样多样化的现实场景强调了需要一种多功能的自动伸缩解决方案，能够理解并响应多种度量标准。KEDA 凭借其灵活性和适应性有效地应对了这些挑战。\n\n### 5. 结论：KEDA 自动伸缩的未来\n\n尽管 Kubernetes 拥有原生的自动伸缩工具如 HPA 和 VPA，以及像 Prometheus 适配器这样的扩展，但它们通常伴随着复杂性。而 KEDA 提供了一个简单的平台，适用于各种各样的自动伸缩需求。它处理事件驱动的扩展，包括缩减到零，这是一个重大优势。此外，设置 KEDA 更加简单，减少了用户在处理 Kubernetes 自定义指标时通常会遇到的典型障碍。\n\nKEDA 的活跃社区证明了它的实用性。对该项目的定期贡献、像 Kedify 或 Microsoft 这样的供应商以及不断增加的[企业采用](https:\/\/keda.sh\/community\/#end-users)显示出它在 Kubernetes 生态系统中日益重要。\n', '\/trans\/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/">[译] 如何使用 Calico 构建和管理 Kubernetes Cluster Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tigera.io/blog/deep-dive/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Calico 构建和管理 Kubernetes Cluster Mesh', '这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。', '\nKubernetes 是构建灵活可扩展基础设施以运行动态工作负载的优秀解决方案。然而，随着我们的集群扩展，我们可能会面临同时扩展和管理多个集群的不可避免情况。这个概念可能会给我们的日常工作负载维护带来很多复杂性，并增加在所有环境中保持所有策略和服务的最新性的难度。在这种情况下，[集群网格](https:\/\/www.tigera.io\/blog\/using-calico-to-create-a-kubernetes-cluster-mesh-for-multi-cluster-environments\/) 可以在这些集群之间建立无缝的连接，并将工作负载集成到统一的网络环境中。\n\n集群网格是连接独立 Kubernetes 集群并在不同集群中的资源之间提供连接性的绝佳方式，以提供超出单个集群情况下可能的容错性和高可用性。\n\n在本博客文章中，我们将引导你完成构建多集群环境并建立集群网格所需的步骤，利用 Calico Open Source 的多功能能力。我们将探讨不同的方法，如顶级机架 (TOR) 和 overlay，以建立集群网格，解决不同环境提出的独特网络挑战。这是可能的，因为 Calico 提供了建立多集群环境的多种方法，灵活适应你的网络基础设施和特定要求。此外，我们还将介绍如何加入 DNS 连通性以增强集群间通信。\n\n随着你的集群网格环境扩展，我们将讨论涉及[联邦](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-federation\/)和使用 Calico Enterprise 进行多集群管理的下一步，以及涉及联邦集群。我们将展示 Calico 如何提供多集群管理平面，允许在集群间无缝实施安全性和可观测性。\n\n最后，我们将涉及到 Calico Enterprise 联邦身份如何在[多集群](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-multi-cluster\/)环境中弥合差距，提供一种统一的方式来定制网络策略，可以引用来自不同集群的资源并构建跨集群边界负载平衡请求的服务。\n\n## 什么是集群网格？\n\n集群网格连接了两个或多个独立集群内部资源。通常，每个 Kubernetes 集群将为内部资源分配私有 IP 地址，除非将**节点端口**或**负载均衡器**服务与它们关联，否则这些资源对任何外部实体都不可见。然而，将资源暴露给所有人可能会带来安全风险，并破坏你应该保持的[零信任安全](https:\/\/www.tigera.io\/learn\/guides\/zero-trust\/zero-trust-security\/)姿态，以保护你的环境。此外，它可以通过允许恶意用户利用漏洞并在关键服务中占据立足点来危及整个环境。\n\n在多集群环境中建立集群网格提供了一种安全机制，用于促进集群之间的直接通信。这种通信可以通过指定的集群服务或私有 IP 地址进行，确保强大而受控制的交互，同时减轻了将内部资源暴露给更广泛网络的风险。\n\n### 如何构建多集群环境并建立集群网格\n\n以下图片说明了 Calico 如何在你的集群之间建立集群网格连接。\n\n![](1.png)\n\nCalico 提供了不同的方式，你可以使用这些方式来构建多集群环境，从而提供了与你的网络基础设施和需求相匹配的灵活性。Calico 最好的部分是，在将两个集群连接在一起后，它将自动提供集群网格，你可以通过使用它们的内部集群服务和 IP 地址开始在不同的集群中使用资源。\n\n### 在扁平网络环境中的集群网格\n\n集群网格的配置可以根据底层基础设施的不同而变化，但其基本目的保持不变，实质上是用于建立独立集群之间的连接。\n\n例如，在我们的集群的参与节点通过广播域直接连接的环境中，我们可以通过传播内部路由到外部实体的路由协议来快速建立一个网格。这将允许我们广告内部路由，而无需通过**节点端口**服务将它们暴露给我们的目标服务。\n\n以下图片说明了扁平网络的常见设计：\n\n![](2.png)\n\n考虑观看我们的视频，[使用 Calico 开源进行 Kubernetes 的 BGP](https:\/\/www.youtube.com\/watch?v=PefluN8YM9o\u0026ab_channel=ProjectCalico)，以了解使用全网格方法部署集群网格的全面教程。\n\n### 在企业或云网络环境中的集群网格\n\n在复杂的网络环境中，例如云或企业网络，形成集群的基础设施资源通常分为单独的广播域。这是因为这些域中的每个实体都被要求通过网关来到达其目的地。但是，默认情况下，这个额外的跳跃（网关）需要了解我们在 Kubernetes 集群中创建的内部集群资源。因此，网关会丢弃前往这些内部资源的数据包，使简单的路由方法无法满足要求。\n\n以下图片说明了复杂网络环境的常见设计：\n\n![](3.png)\n\n既然我们知道了问题，让我们看看如何利用 Calico 来解决这个问题。\n\n为了在这样的环境中建立集群网格，我们可以使用两种方法：\n\n- 顶层机架（TOR）\n- overlay\n\n#### TOR 方法（推荐）\n\n在企业或云环境中，资源通常通过中间网关互连。通常，我们建议我们的客户使用 TOR，因为通过与云提供商自动建立路由传播机制来使你的集群了解你监管下的所有云资源，从而使你的集群具备高可用性。这也在云提供商的底层网络基础设施上发挥了作用，从而使你的集群在网络基础设施的支持下具备高可用性。\n\n假设你可以配置云网关并将其与像 Calico 这样的强大的[容器网络接口（CNI）](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-cni\/)配对，那么你可以利用 BGP 路由来建立集群网格。Calico BGP 集成提供了动态路由，允许你将内部 Pod 和集群 IP 路由传播到网络基础设施中的其他资源。\n\n以下图片说明了支持 BGP 的云环境的常见设计：\n\n![](4.png)\n\n在许多情况下，TOR（顶层机架）提高了高可用性和容错性。这种方法优化了网络流量分布，减轻了单点故障，并进一步增强了你的基础设施的可靠性和弹性。\n\n注意：要了解使用 TOR 方法部署集群网格的详细指南，请查看[此处](https:\/\/docs.tigera.io\/calico\/latest\/networking\/configuring\/bgp#top-of-rack-tor)的教程。\n\n#### IPIP overlay\n\n在某些情况下，你可能无法访问网关以修改其设置，或者它可能不支持 BGP 对等连接。在这种情况下，你可以使用 IPIP overlay 来封装流向目标集群的流量。overlay 网络允许网络设备在底层网络（称为底层）上相互通信，而底层网络不需要了解连接到 overlay 网络的设备。\n\n注意：如果你想了解更多关于 overlay 网络的信息，请单击[此处](https:\/\/docs.tigera.io\/calico\/latest\/about\/kubernetes-training\/about-networking#overlay-networks)。\n\n#### VXLAN overlay (Calico Enterprise)\n\n即将发布的 Calico Enterprise（3.18\u002b）版本将在多集群环境下启用 VXLAN 网络。这种方法的一个显著优势之一是能够使用身份感知策略来保护跨集群的流量（你将在接下来的联邦部分了解有关此功能的信息）。通过其多集群网络功能，Calico Enterprise 自动扩展 overlay 网络，以在集群之间建立 Pod IP 路由。\n\n在使用 VXLAN 的 Calico Enterprise 集群网格设置中，每个集群都充当本地集群和远程集群，本地集群配置为从远程集群的加密通道中检索端点和路由数据。VXLAN 集群网格提供了一种安全、可扩展和高效的解决方案，用于管理多集群网络，实现了跨集群的无缝通信和身份感知策略强制执行。\n\n注意：如果你想了解有关 VXLAN overlay 的更多信息，请单击[此处](https:\/\/www.tigera.io\/news\/tigera-introduces-powerful-enhancements-to-calico-open-source-and-calico-cloud-to-elevate-security-scalability-and-performance\/)。\n\n以下图片说明了没有 BGP 能力的云环境的常见设计：\n\n![](5.png)\n\n注意：要了解使用 TOR 方法部署集群网格的全面指南，请查看[此教程](https:\/\/youtu.be\/rv-DnExi6SM?t=2287)。\n\n### DNS 连接\n\n在建立多集群之后，各个集群可以在 IP 级别进行通信。然而，根据你的网络规模以及 Kubernetes IP 地址的性质，这些地址可以随时动态更改，因此你需要实现一种更容易建立这些集群之间连接的方式。域名解析可以成为你的集群网格的重要补充，允许更容易进行集群间通信。\n\n在大多数 Kubernetes 部署中，CoreDNS 作为负责解析集群域名的主要工作负载。要将 DNS 与集群网格无缝集成，只需对 CoreDNS 配置映射进行简单的修改即可。具体来说，你需要将其他集群的 CoreDNS 内部服务 IP 添加为转发器到你的配置中。\n\n这个简单的调整使你的集群能够通过向其他集群发送查询来解析名称，并检索所需资源的相应 IP 地址。这种集成大大简化了集群网格内的通信，增强了整体连通性，并提高了管理效率。\n\n注意：考虑观看[此视频](https:\/\/youtu.be\/rv-DnExi6SM?t=2574)以了解有关 DNS 连接的全面教程。\n\n## 联邦和多集群管理（下一步）\n\n随着你的环境扩展，你可能会遇到多个团队必须同时在所有集群上工作的情况。多集群管理（MCM）通常解决的一个常见问题是以集中的方式处理来自不同集群的对象，包括网络策略、Pod、[合规性](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-compliance\/)报告、可观测性和安全日志。\n\n虽然从技术上讲，可以通过 kubectl 为每个集群手动创建策略、网络集和其他资源，但这种方法会在你的日常维护任务中引入相当复杂性，并可能为意外的凭据泄漏开辟一条途径。此外，与我们在前一节中探讨的类似，它反映了没有良好结构的多集群环境所面临的挑战，特别是在集群管理、网络、故障排除和可观测性方面。\n\n### 使用 Calico Enterprise 进行多集群管理\n\nCalico Enterprise 提供了一个 MCM 平面，通过在这些集群之间建立安全连接，实现了多集群的安全和可观测性。该架构还支持跨集群联邦[网络策略](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-network-policy\/)资源，并为真正的集中式管理、可观测性和集群维护奠定了基础。\n\n以下图像是列出所有已连接集群的 MCM 页面的示例。\n\n![](6.png)\n\nMCM 的安全功能不仅限于集群的网络方面。由于 MCM 完全集成了 Kubernetes 基于角色的访问控制（RBAC），你可以制定授权，允许用户仅查看他们需要查看的信息。\n\n注意：使用[这个](https:\/\/www.tigera.io\/tutorials\/?_sft_tutorial_product=calico-enterprise)实际操作的工作坊来了解更多关于多集群管理的信息。\n\n### 利用 Calico Enterprise 的联邦身份和统一策略执行\n\nCalico Enterprise 联邦将工作负载和服务端点与在集群之间共享的唯一身份关联起来。\n\n联邦身份可以与网络安全策略关联，以创建引用位于不同集群中的端点的唯一资源，从而实现对集群间安全的无缝控制。\n\n此外，通过联邦服务，你可以发现并与位于不同集群中的远程 Pod 互动。这两个关键功能使得可以创建精确、细粒度的安全控制，加强了跨多个集群的整体安全姿态。\n\n![](7.png)\n\n通过实施联邦层和策略，你可以灵活地定义网络安全策略，这些策略可以普遍适用于所有集群，也可以专门针对一组定义的集群。这种方法提供了一种有效的手段，以在扩展部署以包括多个集群的同时扩展安全措施。通过将这些安全控制扩展到现有和新的集群，你有效地减少了策略的重复和简化了从创建到维护的整个过程。\n\n## 结论\n\n总结一下，集群网格连接不同 Kubernetes 集群中的内部资源。Calico 的灵活集群网格设置为在任何环境中连接到多个集群提供了构建块。\n\nCalico Enterprise MCM、联邦和联邦策略强制执行成为多集群架构的缺失环节，允许无缝通信，同时优先考虑安全性。Calico 在这个领域的能力使你能够无缝提供多集群管理、可观测性、联邦服务和身份，从而使你的组织能够自信而高效地应对现代网络的复杂性。随着组织的继续扩展和扩大规模，整合这些策略将在塑造多集群环境的未来中发挥关键作用。\n', '\/trans\/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/kubernetes/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/kubernetes/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/kubernetes/page/4/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(70)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(40)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
