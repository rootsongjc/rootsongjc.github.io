<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song&#39;s Blog – Kubernetes</title>
    <link>https://jimmysong.io/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 15 Apr 2024 13:54:49 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Kubernetes 基础教程</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/</guid>
      <description>
        
        
        &lt;div class=&#34;alert&#34;&gt;

&lt;div class=&#34;alert-note-title py-1 px-2&#34;&gt;
  关于本教程
&lt;/div&gt;

&lt;div class=&#34;alert-note py-1 px-2&#34;&gt;
  本教程迁移自&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; title=&#34;《Kubernetes 中文指南——云原生应用架构实战手册》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Kubernetes 中文指南——云原生应用架构实战手册》&lt;/a&gt;
，原手册使用 Gitbook 发布，内容涵盖 容器、Kubernetes、服务网格、Serverless 等云元生的多个领域，因内容过于宽泛，且 Gitbook 项目已停止维护，现将其中的 Kubernetes 教程部分独立成书，并使用 Hugo 重新构建。
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，Serverless 的兴起，使得云原生从基础设施层不断向应用架构层挺进，我们正处于一个云原生的新时代。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;cover.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;《Kubernetes 基础教程》封面&#34; width=&#34;50%&#34;data-img=&#34;cover.jpg&#34;
         data-caption=&#34;《Kubernetes 基础教程》封面&#34;
         
         
         data-width=&#34;1200&#34;
         data-height=&#34;1573&#34;
         
         
    /&gt;&lt;figcaption&gt;
            《Kubernetes 基础教程》封面
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://kubernetes.io&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;
 是 Google 于 &lt;a href=&#34;https://jimmysong.io/cloud-native/note/open-source/&#34; title=&#34;2014 年 6 月&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2014 年 6 月&lt;/a&gt;
基于其内部使用的 &lt;a href=&#34;https://research.google.com/pubs/pub43438.html&#34; title=&#34;Borg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg&lt;/a&gt;
 系统开源出来的容器编排调度引擎，Google 将其作为初始和核心项目贡献给 &lt;a href=&#34;https://cncf.io&#34; title=&#34;CNCF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt;
（云原生计算基金会），近年来逐渐发展出了云原生生态。&lt;/p&gt;
&lt;p&gt;Kubernetes 的目标不仅仅是一个编排系统，而是提供一个规范用以描述集群的架构，定义服务的最终状态，使系统自动地达到和维持该状态。Kubernetes 作为云原生应用的基石，相当于一个云原生操作系统，其重要性不言而喻。&lt;/p&gt;
&lt;p&gt;云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括 &lt;strong&gt;容器&lt;/strong&gt;、&lt;strong&gt;服务网格&lt;/strong&gt;、&lt;strong&gt;微服务&lt;/strong&gt;、&lt;strong&gt;不可变基础设施&lt;/strong&gt; 和 &lt;strong&gt;声明式 API&lt;/strong&gt;。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。——CNCF（云原生计算基金会）。&lt;/p&gt;
&lt;h2 id=&#34;关于本书&#34;&gt;关于本书&lt;/h2&gt;
&lt;p&gt;Kubernetes Handbook 项目始于 2016 年底，开源于 2017 年 3 月，作为第一本系统介绍 Kubernetes 的中文电子书，其后经过不断完善。写作本书的过程中，笔者记录了从零开始学习和使用 Kubernetes 的历程，着重于经验总结和资料分享，亦有 Kubernetes 核心概念解析，希望能够帮助大家少走弯路，为大家介绍 Kubernetes 周边生态，如微服务、DevOps、大数据应用、服务网格、云原生应用、Serverless 等领域。&lt;/p&gt;
&lt;h2 id=&#34;本书大纲&#34;&gt;本书大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/&#34;&gt;Kubernetes 架构&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/&#34;&gt;资源对象&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/&#34;&gt;集群资源管理&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/controllers/&#34;&gt;控制器&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/service-discovery/&#34;&gt;服务发现与路由&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/auth/&#34;&gt;身份与权限认证&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/networking/&#34;&gt;网络&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/storage/&#34;&gt;存储&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/extend/&#34;&gt;扩展集群&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/multi-cluster/&#34;&gt;多集群管理&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/config/&#34;&gt;资源对象配置&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cli/&#34;&gt;命令使用&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/security/&#34;&gt;集群安全性管理&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/access/&#34;&gt;访问集群&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/devops/&#34;&gt;部署应用&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/develop/&#34;&gt;开发指南&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;


&lt;h2 id=&#34;许可证&#34;&gt;许可证&lt;/h2&gt;
&lt;p&gt;您可以使用&lt;a href=&#34;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&#34; title=&#34;署名 - 非商业性使用 - 相同方式共享 4.0 (CC BY-NC-SA 4.0)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;署名 - 非商业性使用 - 相同方式共享 4.0 (CC BY-NC-SA 4.0)&lt;/a&gt;
  协议共享。&lt;/p&gt;
&lt;h2 id=&#34;交流群&#34;&gt;交流群&lt;/h2&gt;
&lt;p&gt;欢迎加入&lt;a href=&#34;https://cloudnative.to/&#34; title=&#34;云原生社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;
微信讨论群，加入前请先填写&lt;a href=&#34;https://wj.qq.com/s2/5479026/bf82&#34; title=&#34;入群申请问卷&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入群申请问卷&lt;/a&gt;
后联系 &lt;a href=&#34;https://jimmysong.io/contact/&#34; title=&#34;Jimmy Song&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;
 入群。&lt;/p&gt;
&lt;ul class=&#34;cta-group&#34;&gt;
  
  &lt;li&gt;
    &lt;a href=&#34;architecture&#34;  class=&#34;btn btn-primary px-3 py-3&#34;&gt;开始阅读&lt;/a&gt;
  &lt;/li&gt;
  
  
&lt;/ul&gt;


      </description>
    </item>
    
    <item>
      <title>Kubernetes 加固指南</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;Kubernetes Hardening Guidance&lt;/em&gt;（&lt;a href=&#34;https://media.defense.gov/2021/Aug/03/2002820425/-1/-1/1/CTR_KUBERNETES%20HARDENING%20GUIDANCE.PDF&#34; title=&#34;查看英文原版 PDF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看英文原版 PDF&lt;/a&gt;
）是由美国国家安全局（NSA）于 2021 年 8 月发布的，其中文版《Kubernetes 加固指南》（或译作《Kubernetes 强化指南》），译者 &lt;a href=&#34;https://jimmysong.io&#34; title=&#34;Jimmy Song&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;
。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;cover.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;《Kubernetes 加固指南》封面&#34; width=&#34;50%&#34;data-img=&#34;cover.jpg&#34;
         data-caption=&#34;《Kubernetes 加固指南》封面&#34;
         
         
         data-width=&#34;1200&#34;
         data-height=&#34;1573&#34;
         
         
    /&gt;&lt;figcaption&gt;
            《Kubernetes 加固指南》封面
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;许可证&#34;&gt;许可证&lt;/h2&gt;
&lt;p&gt;您可以使用&lt;a href=&#34;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&#34; title=&#34;署名 - 非商业性使用 - 相同方式共享 4.0 (CC BY-NC-SA 4.0)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;署名 - 非商业性使用 - 相同方式共享 4.0 (CC BY-NC-SA 4.0)&lt;/a&gt;
  协议共享。&lt;/p&gt;
&lt;h2 id=&#34;交流群&#34;&gt;交流群&lt;/h2&gt;
&lt;p&gt;欢迎加入&lt;a href=&#34;https://cloudnative.to/&#34; title=&#34;云原生社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;
可观测性讨论组（微信群）参与讨论交流，加入前请先填写&lt;a href=&#34;https://wj.qq.com/s2/5479026/bf82&#34; title=&#34;入群申请问卷&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入群申请问卷&lt;/a&gt;
后联系 &lt;a href=&#34;https://jimmysong.io/contact/&#34; title=&#34;Jimmy Song&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;
 入群。&lt;/p&gt;
&lt;ul class=&#34;cta-group&#34;&gt;
  
  &lt;li&gt;
    &lt;a href=&#34;notices-and-hitory&#34;  class=&#34;btn btn-primary px-3 py-3&#34;&gt;开始阅读&lt;/a&gt;
  &lt;/li&gt;
  
  
&lt;/ul&gt;


      </description>
    </item>
    
    <item>
      <title>通知和历史</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/notices-and-hitory/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/notices-and-hitory/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;文件变更历史&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;英文版&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2021 年 8 月&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;首次发布&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;中文版&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2021 年 8 月 8 日&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;首次发布&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;担保和认可的免责声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文件中的信息和意见是 &amp;ldquo;按原样&amp;rdquo; 提供的，没有任何保证或担保。本文件以商品名称、商标、制造商或其他方式提及任何具体的商业产品、程序或服务，并不一定构成或暗示美国政府对其的认可、推荐或青睐，而且本指南不得用于广告或产品代言的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于中文版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中文版为 &lt;a href=&#34;https://jimmysong.io&#34; title=&#34;Jimmy Song&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;
 个人翻译，翻译过程中完全遵照原版，未做任何删减。其本人与本书的原作者没有任何组织或利益上的联系，翻译本书仅为交流学习之用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商标认可&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 是 Linux 基金会的注册商标。&lt;/li&gt;
&lt;li&gt;SELinux 是美国国家安全局的注册商标。&lt;/li&gt;
&lt;li&gt;AppArmor 是 SUSE LLC 的注册商标。&lt;/li&gt;
&lt;li&gt;Windows 和 Hyper-V 是微软公司的注册商标。&lt;/li&gt;
&lt;li&gt;ETCD 是 CoreOS, Inc. 的注册商标。&lt;/li&gt;
&lt;li&gt;Syslog-ng 是 One Identity Software International Designated Activity 公司的注册商标。&lt;/li&gt;
&lt;li&gt;Prometheus 是 Linux 基金会的注册商标。&lt;/li&gt;
&lt;li&gt;Grafana 是 Raintank, Inc.dba Grafana Labs 的注册商标。&lt;/li&gt;
&lt;li&gt;Elasticsearch 和 ELK Stack 是 Elasticsearch B.V 的注册商标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;版权确认&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文件中的信息、例子和数字基于 Kubernetes 作者的 &lt;a href=&#34;https://kubernetes.io/docs/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;
 &lt;a href=&#34;https://kubernetes.io/docs/&#34; title=&#34;文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;
，以&lt;a href=&#34;https://git.k8s.io/website/LICENSE&#34; title=&#34;知识共享&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;知识共享&lt;/a&gt;
&lt;a href=&#34;https://git.k8s.io/website/LICENSE&#34; title=&#34;署名 4.0 许可方式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;署名 4.0 许可方式&lt;/a&gt;
发布。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>出版信息</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/publication-information/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/publication-information/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cybersecurity and Infrastructure Security Agency (CISA)&lt;/p&gt;
&lt;p&gt;National Security Agency (NSA) Cybersecurity Directorate Endpoint Security&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联系信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户要求 / 一般网络安全问题。&lt;/p&gt;
&lt;p&gt;网络安全需求中心，410-854-4200，&lt;a href=&#34;mailto:Cybersecurity_Requests@nsa.gov&#34; title=&#34;Cybersecurity_Requests@nsa.gov&#34;&gt;Cybersecurity_Requests@nsa.gov&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;媒体咨询&lt;/strong&gt; / &lt;strong&gt;新闻台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;媒体关系，443-634-0721，&lt;a href=&#34;mailto:MediaRelations@nsa.gov&#34; title=&#34;MediaRelations@nsa.gov&#34;&gt;MediaRelations@nsa.gov&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;关于事件响应资源，请联系 CISA：&lt;a href=&#34;mailto:CISAServiceDesk@cisa.dhs.gov&#34; title=&#34;CISAServiceDesk@cisa.dhs.gov&#34;&gt;CISAServiceDesk@cisa.dhs.gov&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于本书中文版的信息请联系 Jimmy Song：&lt;a href=&#34;mailto:jimmysong@jimmysong.io&#34; title=&#34;jimmysong@jimmysong.io&#34;&gt;jimmysong@jimmysong.io&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宗旨&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国家安全局和 CISA 制定本文件是为了促进其各自的网络安全，包括其制定和发布网络安全规范和缓解措施的责任。这一信息可以被广泛分享，以触达所有适当的利益相关者。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes 架构</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 / 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。&lt;/p&gt;
&lt;p&gt;Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。&lt;/p&gt;
&lt;h2 id=&#34;borg-简介&#34;&gt;Borg 简介&lt;/h2&gt;
&lt;p&gt;Borg 是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg 的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。&lt;/p&gt;
&lt;p&gt;Borg 主要由 BorgMaster、Borglet、borgcfg 和 Scheduler 组成，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/borg.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/borg.png&#34; data-width=&#34;572&#34; data-height=&#34;549&#34; alt=&#34;image&#34; data-caption=&#34;Borg 架构&#34;&gt;
    
  
  &lt;figcaption&gt;Borg 架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BorgMaster 是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中；&lt;/li&gt;
&lt;li&gt;Scheduer 负责任务的调度，根据应用的特点将其调度到具体的机器上去；&lt;/li&gt;
&lt;li&gt;Borglet 负责真正运行任务（在容器中）；&lt;/li&gt;
&lt;li&gt;borgcfg 是 Borg 的命令行工具，用于跟 Borg 系统交互，一般通过一个配置文件来提交任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-架构&#34;&gt;Kubernetes 架构&lt;/h2&gt;
&lt;p&gt;Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Label 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/architecture.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/architecture.png&#34; data-width=&#34;2409&#34; data-height=&#34;1984&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 架构&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes 架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 主要由以下几个核心组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etcd 保存了整个集群的状态；&lt;/li&gt;
&lt;li&gt;apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；&lt;/li&gt;
&lt;li&gt;controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；&lt;/li&gt;
&lt;li&gt;scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；&lt;/li&gt;
&lt;li&gt;kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理；&lt;/li&gt;
&lt;li&gt;Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；&lt;/li&gt;
&lt;li&gt;kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了核心组件，还有一些推荐的插件，其中有的已经成为 CNCF 中的托管项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CoreDNS 负责为整个集群提供 DNS 服务&lt;/li&gt;
&lt;li&gt;Ingress Controller 为服务提供外网入口&lt;/li&gt;
&lt;li&gt;Prometheus 提供资源监控&lt;/li&gt;
&lt;li&gt;Dashboard 提供 GUI&lt;/li&gt;
&lt;li&gt;Federation 提供跨可用区的集群&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-架构示意图&#34;&gt;Kubernetes 架构示意图&lt;/h2&gt;
&lt;h3 id=&#34;整体架构&#34;&gt;整体架构&lt;/h3&gt;
&lt;p&gt;下图清晰表明了 Kubernetes 的架构设计以及组件之间的通信协议。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/kubernetes-high-level-component-archtecture.jpg&#34; data-img=&#34;/book/kubernetes-handbook/architecture/kubernetes-high-level-component-archtecture.jpg&#34; data-width=&#34;1858&#34; data-height=&#34;1126&#34; alt=&#34;image&#34; data-caption=&#34;Kuberentes 架构（图片来自于网络）&#34;&gt;
    
  
  &lt;figcaption&gt;Kuberentes 架构（图片来自于网络）&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下面是更抽象的一个视图：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/kubernetes-whole-arch.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/kubernetes-whole-arch.png&#34; data-width=&#34;1600&#34; data-height=&#34;1067&#34; alt=&#34;image&#34; data-caption=&#34;kubernetes 整体架构示意图&#34;&gt;
    
  
  &lt;figcaption&gt;kubernetes 整体架构示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;master-架构&#34;&gt;Master 架构&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/kubernetes-master-arch.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/kubernetes-master-arch.png&#34; data-width=&#34;1600&#34; data-height=&#34;1067&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes master 架构示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes master 架构示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;node-架构&#34;&gt;Node 架构&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/kubernetes-node-arch.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/kubernetes-node-arch.png&#34; data-width=&#34;1600&#34; data-height=&#34;1067&#34; alt=&#34;image&#34; data-caption=&#34;kubernetes node 架构示意图&#34;&gt;
    
  
  &lt;figcaption&gt;kubernetes node 架构示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;分层架构&#34;&gt;分层架构&lt;/h3&gt;
&lt;p&gt;Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/kubernetes-layers-arch.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/kubernetes-layers-arch.png&#34; data-width=&#34;1898&#34; data-height=&#34;1008&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 分层架构示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes 分层架构示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境&lt;/li&gt;
&lt;li&gt;应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层）&lt;/li&gt;
&lt;li&gt;管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层）&lt;/li&gt;
&lt;li&gt;接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦&lt;/li&gt;
&lt;li&gt;生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴
&lt;ul&gt;
&lt;li&gt;Kubernetes 外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS 应用、ChatOps、GitOps、SecOps 等&lt;/li&gt;
&lt;li&gt;Kubernetes 内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert&#34;&gt;

&lt;div class=&#34;alert-note-title py-1 px-2&#34;&gt;
  备注
&lt;/div&gt;

&lt;div class=&#34;alert-note py-1 px-2&#34;&gt;
  关于分层架构，可以关注下 &lt;a href=&#34;https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o&#34; title=&#34;Kubernetes architectual roadmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes architectual roadmap&lt;/a&gt;
 和 &lt;a href=&#34;https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit&#34; title=&#34;幻灯片&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;幻灯片&lt;/a&gt;
。
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;本节大纲&#34;&gt;本节大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/perspective/&#34;&gt;Kubernetes 的设计理念&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/etcd/&#34;&gt;Etcd 解析&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/&#34;&gt;开放接口&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/pod-state-and-lifecycle/&#34;&gt;Pod 状态与生命周期管理&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;


&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2898444&#34; title=&#34;Borg, Omega, and Kubernetes - Lessons learned from three container-management systems over a decade&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg, Omega, and Kubernetes - Lessons learned from three container-management systems over a decade&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43438.pdf&#34; title=&#34;Paper - Large-scale cluster management at Google with Borg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Paper - Large-scale cluster management at Google with Borg&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/kubernetes-an-overview&#34; title=&#34;KUBERNETES: AN OVERVIEW&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KUBERNETES: AN OVERVIEW&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o&#34; title=&#34;Kubernetes architectual roadmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes architectual roadmap&lt;/a&gt;
 和 &lt;a href=&#34;https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit&#34; title=&#34;slide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;slide&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>执行摘要</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/executive-summary/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/executive-summary/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes® 是一个开源系统，可以自动部署、扩展和管理在容器中运行的应用程序，并且通常托管在云环境中。与传统的单体软件平台相比，使用这种类型的虚拟化基础设施可以提供一些灵活性和安全性的好处。然而，安全地管理从微服务到底层基础设施的所有方面，会引入其他的复杂性。本报告中详述的加固指导旨在帮助企业处理相关风险并享受使用这种技术的好处。&lt;/p&gt;
&lt;p&gt;Kubernetes 中三个常见的破坏源是供应链风险、恶意威胁者和内部威胁。&lt;/p&gt;
&lt;p&gt;供应链风险往往是具有挑战性的，可以在容器构建周期或基础设施收购中出现。恶意威胁者可以利用 Kubernetes 架构的组件中的漏洞和错误配置，如控制平面、工作节点或容器化应用程序。内部威胁可以是管理员、用户或云服务提供商。对组织的 Kubernetes 基础设施有特殊访问权的内部人员可能会滥用这些特权。&lt;/p&gt;
&lt;p&gt;本指南描述了与设置和保护 Kubernetes 集群有关的安全挑战。包括避免常见错误配置的加固策略，并指导国家安全系统的系统管理员和开发人员如何部署 Kubernetes，并提供了建议的加固措施和缓解措施的配置示例。本指南详细介绍了以下缓解措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扫描容器和 Pod 的漏洞或错误配置。&lt;/li&gt;
&lt;li&gt;以尽可能少的权限运行容器和 Pod。&lt;/li&gt;
&lt;li&gt;使用网络隔离来控制漏洞可能造成的损害程度。&lt;/li&gt;
&lt;li&gt;使用防火墙来限制不需要的网络连接，并使用加密技术来保护机密。&lt;/li&gt;
&lt;li&gt;使用强大的认证和授权来限制用户和管理员的访问，以及限制攻击面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用日志审计，以便管理员可以监控活动，并对潜在的恶意活动发出警告。&lt;/p&gt;
&lt;p&gt;定期审查所有 Kubernetes 设置，并使用漏洞扫描，以帮助确保风险得到适当考虑并应用安全补丁。&lt;/p&gt;
&lt;p&gt;有关其他安全加固指导，请参见互联网安全中心 Kubernetes 基准、Docker 和 Kubernetes 安全技术实施指南、网络安全和基础设施安全局（CISA）分析报告以及 Kubernetes 文档。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes 的设计理念</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/perspective/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/perspective/</guid>
      <description>
        
        
        &lt;p&gt;这一章将介绍 Kubernetes 的设计理念及基本概念。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-设计理念与分布式系统&#34;&gt;Kubernetes 设计理念与分布式系统&lt;/h2&gt;
&lt;p&gt;分析和理解 Kubernetes 的设计理念可以使我们更深入地了解 Kubernetes 系统，更好地利用它管理分布式部署的云原生应用，另一方面也可以让我们借鉴其在分布式系统设计方面的经验。&lt;/p&gt;
&lt;h2 id=&#34;分层架构&#34;&gt;分层架构&lt;/h2&gt;
&lt;p&gt;Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/perspective/006tNc79ly1fzniqvmi51j31gq0s0q5u.jpg&#34; data-img=&#34;/book/kubernetes-handbook/architecture/perspective/006tNc79ly1fzniqvmi51j31gq0s0q5u.jpg&#34; data-width=&#34;1898&#34; data-height=&#34;1008&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 分层架构示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes 分层架构示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境&lt;/li&gt;
&lt;li&gt;应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）&lt;/li&gt;
&lt;li&gt;管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）&lt;/li&gt;
&lt;li&gt;接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦&lt;/li&gt;
&lt;li&gt;生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴
&lt;ul&gt;
&lt;li&gt;Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等&lt;/li&gt;
&lt;li&gt;Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api-设计原则&#34;&gt;API 设计原则&lt;/h2&gt;
&lt;p&gt;对于云计算系统，系统 API 实际上处于系统设计的统领地位，正如本文前面所说，Kubernetes 集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的 API 对象，支持对该功能的管理操作，理解掌握的 API，就好比抓住了 Kubernetes 系统的牛鼻子。Kubernetes 系统 API 的设计有以下几条原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;所有 API 应该是声明式的&lt;/strong&gt;。正如前文所说，声明式的操作，相对于命令式操作，对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。另外，声明式操作更容易被用户使用，可以使系统向用户隐藏实现的细节，隐藏实现的细节的同时，也就保留了系统未来持续优化的可能性。此外，声明式的 API，同时隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标分布式对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 对象是彼此互补而且可组合的&lt;/strong&gt;。这里面实际是鼓励 API 对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。事实上，Kubernetes 这种分布式系统管理平台，也是一种业务系统，只不过它的业务就是调度和管理容器服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高层 API 以操作意图为基础设计&lt;/strong&gt;。如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低层 API 根据高层 API 的控制需要设计&lt;/strong&gt;。设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提高重用性的目的，低层 API 的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制&lt;/strong&gt;。简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性。内部隐藏的机制也是非常不利于系统维护的设计方式，例如 StatefulSet 和 ReplicaSet，本来就是两种 Pod 集合，那么 Kubernetes 就用不同 API 对象来定义它们，而不会说只用同一个 ReplicaSet，内部通过特殊的算法再来区分这个 ReplicaSet 是有状态的还是无状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 操作复杂度与对象数量成正比&lt;/strong&gt;。这一条主要是从系统性能角度考虑，要保证整个系统随着系统规模的扩大，性能不会迅速变慢到无法使用，那么最低的限定就是 API 的操作复杂度不能超过 O(N)，N 是对象的数量，否则系统就不具备水平伸缩性了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 对象状态不能依赖于网络连接状态&lt;/strong&gt;。由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽量避免让操作机制依赖于全局状态，因为在分布式系统中要保证全局状态的同步是非常困难的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;控制机制设计原则&#34;&gt;控制机制设计原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制逻辑应该只依赖于当前状态&lt;/strong&gt;。这是为了保证分布式系统的稳定可靠，对于经常出现局部错误的分布式系统，如果控制逻辑只依赖当前状态，那么就非常容易将一个暂时出现故障的系统恢复到正常状态，因为你只要将该系统重置到某个稳定状态，就可以自信的知道系统的所有控制逻辑会开始按照正常方式运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假设任何错误的可能，并做容错处理&lt;/strong&gt;。在一个分布式系统中出现局部和临时错误是大概率事件。错误可能来自于物理系统故障，外部系统故障也可能来自于系统自身的代码错误，依靠自己实现的代码不会出错来保证系统稳定其实也是难以实现的，因此要设计对任何可能错误的容错处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽量避免复杂状态机，控制逻辑不要依赖无法监控的内部状态&lt;/strong&gt;。因为分布式系统各个子系统都是不能严格通过程序内部保持同步的，所以如果两个子系统的控制逻辑如果互相有影响，那么子系统就一定要能互相访问到影响控制逻辑的状态，否则，就等同于系统里存在不确定的控制逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假设任何操作都可能被任何操作对象拒绝，甚至被错误解析&lt;/strong&gt;。由于分布式系统的复杂性以及各子系统的相对独立性，不同子系统经常来自不同的开发团队，所以不能奢望任何操作被另一个子系统以正确的方式处理，要保证出现错误的时候，操作级别的错误不会影响到系统稳定性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个模块都可以在出错后自动恢复&lt;/strong&gt;。由于分布式系统中无法保证系统各个模块是始终连接的，因此每个模块要有自我修复的能力，保证不会因为连接不到其他模块而自我崩溃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每个模块都可以在必要时优雅地降级服务&lt;/strong&gt;。所谓优雅地降级服务，是对系统鲁棒性的要求，即要求在设计实现模块时划分清楚基本功能和高级功能，保证基本功能不会依赖高级功能，这样同时就保证了不会因为高级功能出现故障而导致整个模块崩溃。根据这种理念实现的系统，也更容易快速地增加新的高级功能，因为不必担心引入高级功能影响原有的基本功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-的核心技术概念和-api-对象&#34;&gt;Kubernetes 的核心技术概念和 API 对象&lt;/h2&gt;
&lt;p&gt;API 对象是 Kubernetes 集群中的管理操作单元。Kubernetes 集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的 API 对象，支持对该功能的管理操作。例如副本集 Replica Set 对应的 API 对象是 RS。&lt;/p&gt;
&lt;p&gt;每个 API 对象都有 3 大类属性：元数据 metadata、规范 spec 和状态 status。元数据是用来标识 API 对象的，每个对象都至少有 3 个元数据：namespace，name 和 uid；除此以外还有各种各样的标签 labels 用来标识和匹配不同的对象，例如用户可以用标签 env 来标识区分不同的服务部署环境，分别用 env=dev、env=testing、env=production 来标识开发、测试、生产的不同服务。规范描述了用户期望 Kubernetes 集群中的分布式系统达到的理想状态（Desired State），例如用户可以通过复制控制器 Replication Controller 设置期望的 Pod 副本数为 3；status 描述了系统实际当前达到的状态（Status），例如系统当前实际的 Pod 副本数为 2；那么复制控制器当前的程序逻辑就是自动启动新的 Pod，争取达到副本数为 3。&lt;/p&gt;
&lt;p&gt;Kubernetes 中所有的配置都是通过 API 对象的 spec 去设置的，也就是用户通过配置系统的理想状态来改变系统，这是 Kubernetes 重要设计理念之一，即所有的操作都是声明式（Declarative）的而不是命令式（Imperative）的。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为 3 的操作运行多次也还是一个结果，而给副本数加 1 的操作就不是声明式的，运行多次结果就错了。&lt;/p&gt;
&lt;h3 id=&#34;pod&#34;&gt;Pod&lt;/h3&gt;
&lt;p&gt;Kubernetes 有很多技术概念，同时对应很多 API 对象，最重要的也是最基础的是 Pod。Pod 是在 Kubernetes 集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod 对多容器的支持是 K8 最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个 Nginx 容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。&lt;/p&gt;
&lt;p&gt;Pod 是 Kubernetes 集群中所有业务类型的基础，可以看作运行在 Kubernetes 集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前 Kubernetes 中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为 Deployment、Job、DaemonSet 和 StatefulSet，本文后面会一一介绍。&lt;/p&gt;
&lt;h3 id=&#34;副本控制器replication-controllerrc&#34;&gt;副本控制器（Replication Controller，RC）&lt;/h3&gt;
&lt;p&gt;RC 是 Kubernetes 集群中最早的保证 Pod 高可用的 API 对象。通过监控运行中的 Pod 来保证集群中运行指定数目的 Pod 副本。指定的数目可以是多个也可以是 1 个；少于指定数目，RC 就会启动运行新的 Pod 副本；多于指定数目，RC 就会杀死多余的 Pod 副本。即使在指定数目为 1 的情况下，通过 RC 运行 Pod 也比直接运行 Pod 更明智，因为 RC 也可以发挥它高可用的能力，保证永远有 1 个 Pod 在运行。RC 是 Kubernetes 较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的 Web 服务。&lt;/p&gt;
&lt;h3 id=&#34;副本集replica-setrs&#34;&gt;副本集（Replica Set，RS）&lt;/h3&gt;
&lt;p&gt;RS 是新一代 RC，提供同样的高可用能力，区别主要在于 RS 后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。&lt;/p&gt;
&lt;h3 id=&#34;部署deployment&#34;&gt;部署（Deployment）&lt;/h3&gt;
&lt;p&gt;部署表示用户对 Kubernetes 集群的一次更新操作。部署是一个比 RS 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。以 Kubernetes 的发展方向，未来对所有长期伺服型的的业务的管理，都会通过 Deployment 来管理。&lt;/p&gt;
&lt;h3 id=&#34;服务service&#34;&gt;服务（Service）&lt;/h3&gt;
&lt;p&gt;RC、RS 和 Deployment 只是保证了支撑服务的微服务 Pod 的数量，但是没有解决如何访问这些服务的问题。一个 Pod 只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的 IP 启动一个新的 Pod，因此不能以确定的 IP 和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在 K8 集群中，客户端需要访问的服务就是 Service 对象。每个 Service 会对应一个集群内部有效的虚拟 IP，集群内部通过虚拟 IP 访问一个服务。在 Kubernetes 集群中微服务的负载均衡是由 Kube-proxy 实现的。Kube-proxy 是 Kubernetes 集群内部的负载均衡器。它是一个分布式代理服务器，在 Kubernetes 的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的 Kube-proxy 就越多，高可用节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解决反向代理的负载均衡和高可用问题。&lt;/p&gt;
&lt;h3 id=&#34;任务job&#34;&gt;任务（Job）&lt;/h3&gt;
&lt;p&gt;Job 是 Kubernetes 用来控制批处理型任务的 API 对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job 管理的 Pod 根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的 spec.completions 策略而不同：单 Pod 型任务有一个 Pod 成功就标志完成；定数成功型任务保证有 N 个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。&lt;/p&gt;
&lt;h3 id=&#34;后台支撑服务集daemonset&#34;&gt;后台支撑服务集（DaemonSet）&lt;/h3&gt;
&lt;p&gt;长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的 Pod，有些节点上又没有这类 Pod 运行；而后台支撑型服务的核心关注点在 Kubernetes 集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类 Pod 运行。节点可能是所有集群节点也可能是通过 nodeSelector 选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持 Kubernetes 集群运行的服务。&lt;/p&gt;
&lt;h3 id=&#34;有状态服务集statefulset&#34;&gt;有状态服务集（StatefulSet）&lt;/h3&gt;
&lt;p&gt;Kubernetes 在 1.3 版本里发布了 Alpha 版的 PetSet 功能，在 1.5 版本里将 PetSet 功能升级到了 Beta 版本，并重新命名为 StatefulSet，最终在 1.9 版本里成为正式 GA 版本。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC 和 RS 主要是控制提供无状态服务的，其所控制的 Pod 的名字是随机设置的，一个 Pod 出故障了就被丢弃掉，在另一个地方重启一个新的 Pod，名字变了。名字和启动在哪儿都不重要，重要的只是 Pod 总数；而 StatefulSet 是用来控制有状态服务，StatefulSet 中的每个 Pod 的名字都是事先确定的，不能更改。StatefulSet 中 Pod 的名字的作用，并不是《千与千寻》的人性原因，而是关联与该 Pod 对应的状态。&lt;/p&gt;
&lt;p&gt;对于 RC 和 RS 中的 Pod，一般不挂载存储或者挂载共享存储，保存的是所有 Pod 共享的状态，Pod 像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于 StatefulSet 中的 Pod，每个 Pod 挂载自己独立的存储，如果一个 Pod 出现故障，从其他节点启动一个同样名字的 Pod，要挂载上原来 Pod 的存储继续以它的状态提供服务。&lt;/p&gt;
&lt;p&gt;适合于 StatefulSet 的业务包括数据库服务 MySQL 和 PostgreSQL，集群化管理服务 ZooKeeper、etcd 等有状态服务。StatefulSet 的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用 StatefulSet，Pod 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet 做的只是将确定的 Pod 与确定的存储关联起来保证状态的连续性。&lt;/p&gt;
&lt;h3 id=&#34;集群联邦federation&#34;&gt;集群联邦（Federation）&lt;/h3&gt;
&lt;p&gt;Kubernetes 在 1.3 版本里发布了 beta 版的 Federation 功能。在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。Kubernetes 的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足 Kubernetes 的调度和计算存储连接要求。而联合集群服务就是为提供跨 Region 跨服务商 Kubernetes 集群服务而设计的。&lt;/p&gt;
&lt;p&gt;每个 Kubernetes Federation 有自己的分布式存储、API Server 和 Controller Manager。用户可以通过 Federation 的 API Server 注册该 Federation 的成员 Kubernetes Cluster。当用户通过 Federation 的 API Server 创建、更改 API 对象时，Federation API Server 会在自己所有注册的子 Kubernetes Cluster 都创建一份对应的 API 对象。在提供业务请求服务时，Kubernetes Federation 会先在自己的各个子 Cluster 之间做负载均衡，而对于发送到某个具体 Kubernetes Cluster 的业务请求，会依照这个 Kubernetes Cluster 独立提供服务时一样的调度模式去做 Kubernetes Cluster 内部的负载均衡。而 Cluster 之间的负载均衡是通过域名服务的负载均衡来实现的。&lt;/p&gt;
&lt;p&gt;Federation V1 的设计是尽量不影响 Kubernetes Cluster 现有的工作机制，这样对于每个子 Kubernetes 集群来说，并不需要更外层的有一个 Kubernetes Federation，也就是意味着所有现有的 Kubernetes 代码和机制不需要因为 Federation 功能有任何变化。&lt;/p&gt;
&lt;p&gt;目前正在开发的 Federation V2，在保留现有 Kubernetes API 的同时，会开发新的 Federation 专用的 API 接口，详细内容可以在 &lt;a href=&#34;https://github.com/kubernetes/community/tree/master/sig-multicluster&#34; title=&#34;这里&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;
 找到。&lt;/p&gt;
&lt;h3 id=&#34;存储卷volume&#34;&gt;存储卷（Volume）&lt;/h3&gt;
&lt;p&gt;Kubernetes 集群中的存储卷跟 Docker 的存储卷有些类似，只不过 Docker 的存储卷作用范围为一个容器，而 Kubernetes 的存储卷的生命周期和作用范围是一个 Pod。每个 Pod 中声明的存储卷由 Pod 中的所有容器共享。Kubernetes 支持非常多的存储卷类型，特别的，支持多种公有云平台的存储，包括 AWS，Google 和 Azure 云；支持多种分布式存储包括 GlusterFS 和 Ceph；也支持较容易使用的主机本地目录 emptyDir, hostPath 和 NFS。Kubernetes 还支持使用 Persistent Volume Claim 即 PVC 这种逻辑存储，使用这种存储，使得存储的使用者可以忽略后台的实际存储技术（例如 AWS，Google 或 GlusterFS 和 Ceph），而将有关存储实际技术的配置交给存储管理员通过 Persistent Volume 来配置。&lt;/p&gt;
&lt;h3 id=&#34;持久存储卷persistent-volumepv和持久存储卷声明persistent-volume-claimpvc&#34;&gt;持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）&lt;/h3&gt;
&lt;p&gt;PV 和 PVC 使得 Kubernetes 集群具备了存储的逻辑抽象能力，使得在配置 Pod 的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给 PV 的配置者，即集群的管理者。存储的 PV 和 PVC 的这种关系，跟计算的 Node 和 Pod 的关系是非常类似的；PV 和 Node 是资源的提供者，根据集群的基础设施变化而变化，由 Kubernetes 集群管理员配置；而 PVC 和 Pod 是资源的使用者，根据业务服务的需求变化而变化，有 Kubernetes 集群的使用者即服务的管理员来配置。&lt;/p&gt;
&lt;h3 id=&#34;节点node&#34;&gt;节点（Node）&lt;/h3&gt;
&lt;p&gt;Kubernetes 集群中的计算能力由 Node 提供，最初 Node 称为服务节点 Minion，后来改名为 Node。Kubernetes 集群中的 Node 也就等同于 Mesos 集群中的 Slave 节点，是所有 Pod 运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行 kubelet 管理节点上运行的容器。&lt;/p&gt;
&lt;h3 id=&#34;密钥对象secret&#34;&gt;密钥对象（Secret）&lt;/h3&gt;
&lt;p&gt;Secret 是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用 Secret 的好处是可以避免把敏感信息明文写在配置文件里。在 Kubernetes 集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问 AWS 存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个 Secret 对象，而在配置文件中通过 Secret 对象引用这些敏感信息。这种方式的好处包括：意图明确，避免重复，减少暴漏机会。&lt;/p&gt;
&lt;h3 id=&#34;用户帐户user-account和服务帐户service-account&#34;&gt;用户帐户（User Account）和服务帐户（Service Account）&lt;/h3&gt;
&lt;p&gt;顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 Pod 提供账户标识。用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身份，人的身份与服务的 namespace 无关，所以用户账户是跨 namespace 的；而服务帐户对应的是一个运行中程序的身份，与特定 namespace 是相关的。&lt;/p&gt;
&lt;h3 id=&#34;命名空间namespace&#34;&gt;命名空间（Namespace）&lt;/h3&gt;
&lt;p&gt;命名空间为 Kubernetes 集群提供虚拟的隔离作用，Kubernetes 集群初始有两个命名空间，分别是默认命名空间 default 和系统命名空间 kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。&lt;/p&gt;
&lt;h3 id=&#34;rbac-访问授权&#34;&gt;RBAC 访问授权&lt;/h3&gt;
&lt;p&gt;Kubernetes 在 1.3 版本中发布了 alpha 版的基于角色的访问控制（Role-based Access Control，RBAC）的授权模式。相对于基于属性的访问控制（Attribute-based Access Control，ABAC），RBAC 主要是引入了角色（Role）和角色绑定（RoleBinding）的抽象概念。在 ABAC 中，Kubernetes 集群中的访问策略只能跟用户直接关联；而在 RBAC 中，访问策略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC 像其他新功能一样，每次引入新功能，都会引入新的 API 对象，从而引入新的概念抽象，而这一新的概念抽象一定会使集群服务管理和使用更容易扩展和重用。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;从 Kubernetes 的系统架构、技术概念和设计理念，我们可以看到 Kubernetes 系统最核心的两个设计理念：一个是 &lt;strong&gt;容错性&lt;/strong&gt;，一个是 &lt;strong&gt;易扩展性&lt;/strong&gt;。容错性实际是保证 Kubernetes 系统稳定性和安全性的基础，易扩展性是保证 Kubernetes 对变更友好，可以快速迭代增加新功能的基础。&lt;/p&gt;
&lt;p&gt;按照分布式系统一致性算法 Paxos 发明人计算机科学家 &lt;a href=&#34;http://research.microsoft.com/users/lamport/pubs/pubs.html&#34; title=&#34;Leslie Lamport&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leslie Lamport&lt;/a&gt;
 的理念，一个分布式系统有两类特性：安全性 Safety 和活性 Liveness。安全性保证系统的稳定，保证系统不会崩溃，不会出现业务错误，不会做坏事，是严格约束的；活性使得系统可以提供功能，提高性能，增加易用性，让系统可以在用户“看到的时间内”做些好事，是尽力而为的。Kubernetes 系统的设计理念正好与 Lamport 安全性与活性的理念不谋而合，也正是因为 Kubernetes 在引入功能和技术的时候，非常好地划分了安全性和活性，才可以让 Kubernetes 能有这么快版本迭代，快速引入像 RBAC、Federation 和 PetSet 这种新功能。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/kubernetes-and-cloud-native-applications-part01/&#34; title=&#34;《Kubernetes 与云原生应用》系列之 Kubernetes 的系统架构与设计理念&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Kubernetes 与云原生应用》系列之 Kubernetes 的系统架构与设计理念&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>勘误</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/corrigendum/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/corrigendum/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;勘误 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PDF 原文第 4 页，kubelet 端口，默认应为 10250，而不是 10251。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Etcd 解析</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/etcd/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/etcd/</guid>
      <description>
        
        
        &lt;p&gt;Etcd 是 Kubernetes 集群中的一个十分重要的组件，用于保存集群所有的网络配置和对象的状态信息。在后面具体的安装环境中，我们安装的 etcd 的版本是 v3.1.5，整个 Kubernetes 系统中一共有两个服务需要用到 etcd 用来协同和存储配置，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络插件 flannel、对于其它网络插件也需要用到 etcd 存储网络的配置信息&lt;/li&gt;
&lt;li&gt;Kubernetes 本身，包括各种对象的状态和元信息配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：flannel 操作 etcd 使用的是 v2 的 API，而 Kubernetes 操作 etcd 使用的 v3 的 API，所以在下面我们执行 &lt;code&gt;etcdctl&lt;/code&gt; 的时候需要设置 &lt;code&gt;ETCDCTL_API&lt;/code&gt; 环境变量，该变量默认值为 2。&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;Etcd 使用的是 raft 一致性算法来实现的，是一款分布式的一致性 KV 存储，主要用于共享配置和服务发现。关于 raft 一致性算法请参考 &lt;a href=&#34;http://thesecretlivesofdata.com/raft/&#34; title=&#34;该动画演示&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;该动画演示&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;关于 Etcd 的原理解析请参考 &lt;a href=&#34;http://jolestar.com/etcd-architecture/&#34; title=&#34;Etcd 架构与实现解析&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Etcd 架构与实现解析&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;使用-etcd-存储-flannel-网络信息&#34;&gt;使用 Etcd 存储 Flannel 网络信息&lt;/h2&gt;
&lt;p&gt;我们在安装 Flannel 的时候配置了 &lt;code&gt;FLANNEL_ETCD_PREFIX=&amp;quot;/kube-centos/network&amp;quot;&lt;/code&gt; 参数，这是 Flannel 查询 etcd 的目录地址。&lt;/p&gt;
&lt;p&gt;查看 Etcd 中存储的 flannel 网络信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;$ etcdctl --ca-file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;/etc/kubernetes/ssl/ca.pem --cert-file=/etc/kubernetes/ssl/kubernetes.pem --key-file=/etc/kubernetes/ssl/kubernetes-key.pem ls /kube-centos/network -r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;2018-01-19 18:38:22.768145 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;/kube-centos/network/config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;/kube-centos/network/subnets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;/kube-centos/network/subnets/172.30.31.0-24&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;/kube-centos/network/subnets/172.30.20.0-24&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;/kube-centos/network/subnets/172.30.23.0-24&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;```查看 flannel 的配置：```bash&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;$ etcdctl --ca-file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;/etc/kubernetes/ssl/ca.pem --cert-file=/etc/kubernetes/ssl/kubernetes.pem --key-file=/etc/kubernetes/ssl/kubernetes-key.pem get /kube-centos/network/config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;2018-01-19 18:38:22.768145 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;{&amp;#34;Network&amp;#34;: &amp;#34;172.30.0.0/16&amp;#34;, &amp;#34;SubnetLen&amp;#34;: 24, &amp;#34;Backend&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;host-gw&amp;#34;} }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;使用-etcd-存储-kubernetes-对象信息&#34;&gt;使用 Etcd 存储 Kubernetes 对象信息&lt;/h2&gt;
&lt;p&gt;Kubernetes 使用 etcd v3 的 API 操作 etcd 中的数据。所有的资源对象都保存在 &lt;code&gt;/registry&lt;/code&gt; 路径下，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;ThirdPartyResourceData&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;apiextensions.k8s.io&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;apiregistration.k8s.io&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;certificatesigningrequests&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;clusterrolebindings&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;clusterroles&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;configmaps&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;controllerrevisions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;controllers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;daemonsets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;deployments&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;events&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;horizontalpodautoscalers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;ingress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;limitranges&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;minions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;monitoring.coreos.com&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;namespaces&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;persistentvolumeclaims&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;persistentvolumes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;poddisruptionbudgets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;pods&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;ranges&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;replicasets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;resourcequotas&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;rolebindings&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;roles&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;secrets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;serviceaccounts&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;services&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;statefulsets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;storageclasses&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;thirdpartyresources&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你还创建了 CRD（自定义资源定义），则在此会出现 CRD 的 API。&lt;/p&gt;
&lt;h3 id=&#34;查看集群中所有的-pod-信息&#34;&gt;查看集群中所有的 Pod 信息&lt;/h3&gt;
&lt;p&gt;例如我们直接从 etcd 中查看 kubernetes 集群中所有的 pod 的信息，可以使用下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ETCDCTL_API&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; etcdctl get /registry/pods --prefix -w json&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;python -m json.tool
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时将看到 json 格式输出的结果，其中的&lt;code&gt;key&lt;/code&gt;使用了&lt;code&gt;base64&lt;/code&gt; 编码，关于 etcdctl 命令的详细用法请参考 &lt;a href=&#34;../../guide/using-etcdctl-to-access-kubernetes-data/&#34; title=&#34;使用 etcdctl 访问 kubernetes 数据&#34;&gt;使用 etcdctl 访问 kubernetes 数据&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;etcd-v2-与-v3-版本-api-的区别&#34;&gt;Etcd V2 与 V3 版本 API 的区别&lt;/h2&gt;
&lt;p&gt;Etcd V2 和 V3 之间的数据结构完全不同，互不兼容，也就是说使用 V2 版本的 API 创建的数据只能使用 V2 的 API 访问，V3 的版本的 API 创建的数据只能使用 V3 的 API 访问。这就造成我们访问 etcd 中保存的 flannel 的数据需要使用 &lt;code&gt;etcdctl&lt;/code&gt; 的 V2 版本的客户端，而访问 kubernetes 的数据需要设置 &lt;code&gt;ETCDCTL_API=3&lt;/code&gt; 环境变量来指定 V3 版本的 API。&lt;/p&gt;
&lt;h2 id=&#34;etcd-数据备份&#34;&gt;Etcd 数据备份&lt;/h2&gt;
&lt;p&gt;我们安装的时候指定的 Etcd 数据的存储路径是 &lt;code&gt;/var/lib/etcd&lt;/code&gt;，一定要对该目录做好备份。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://etcd.io/&#34; title=&#34;etcd 官方文档 - etcd.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;etcd 官方文档 - etcd.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/u010278923/article/details/71727682&#34; title=&#34;etcd v3 命令和 API - blog.csdn.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;etcd v3 命令和 API - blog.csdn.net&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jolestar.com/etcd-architecture/&#34; title=&#34;Etcd 架构与实现解析 - jolestar.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Etcd 架构与实现解析 - jolestar.com&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes，经常被缩写为 &amp;ldquo;K8s&amp;rdquo;，是一个开源的容器或编排系统，用于自动部署、扩展和管理容器化应用程序。它管理着构成集群的所有元素，从应用中的每个微服务到整个集群。与单体软件平台相比，将容器化应用作为微服务使用可以提供更多的灵活性和安全优势，但也可能引入其他复杂因素。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f1.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/introduction/f1.jpg&#34; data-width=&#34;1721&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;图 1：Kubernetes 集群组件的高层视图&#34;&gt;
    
  
  &lt;figcaption&gt;图 1：Kubernetes 集群组件的高层视图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本指南重点关注安全挑战，并尽可能提出适用于国家安全系统和关键基础设施管理员的加固策略。尽管本指南是针对国家安全系统和关键基础设施组织的，但也鼓励联邦和州、地方、部落和领土（SLTT）政府网络的管理员实施所提供的建议。Kubernetes 集群的安全问题可能很复杂，而且经常在利用其错误配置的潜在威胁中被滥用。以下指南提供了具体的安全配置，可以帮助建立更安全的 Kubernetes 集群。&lt;/p&gt;
&lt;h2 id=&#34;建议&#34;&gt;建议&lt;/h2&gt;
&lt;p&gt;每个部分的主要建议摘要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes Pod 安全
&lt;ul&gt;
&lt;li&gt;使用构建的容器，以非 root 用户身份运行应用程序&lt;/li&gt;
&lt;li&gt;在可能的情况下，用不可变的文件系统运行容器&lt;/li&gt;
&lt;li&gt;扫描容器镜像，以发现可能存在的漏洞或错误配置&lt;/li&gt;
&lt;li&gt;使用 Pod 安全政策来执行最低水平的安全，包括：
&lt;ul&gt;
&lt;li&gt;防止有特权的容器&lt;/li&gt;
&lt;li&gt;拒绝经常被利用来突破的容器功能，如 &lt;code&gt;hostPID&lt;/code&gt;、&lt;code&gt;hostIPC&lt;/code&gt;、&lt;code&gt;hostNetwork&lt;/code&gt;、&lt;code&gt;allowedHostPath&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;拒绝以 root 用户身份执行或允许提升为根用户的容器&lt;/li&gt;
&lt;li&gt;使用安全服务，如 SELinux®、AppArmor® 和 seccomp，加固应用程序，防止被利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络隔离和加固
&lt;ul&gt;
&lt;li&gt;使用防火墙和基于角色的访问控制（RBAC）锁定对控制平面节点的访问&lt;/li&gt;
&lt;li&gt;进一步限制对 Kubernetes etcd 服务器的访问&lt;/li&gt;
&lt;li&gt;配置控制平面组件，使用传输层安全（TLS）证书进行认证、加密通信&lt;/li&gt;
&lt;li&gt;设置网络策略来隔离资源。不同命名空间的 Pod 和服务仍然可以相互通信，除非执行额外的隔离，如网络策略&lt;/li&gt;
&lt;li&gt;将所有凭证和敏感信息放在 Kubernetes Secret 中，而不是配置文件中。使用强大的加密方法对 Secret 进行加密&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;认证和授权
&lt;ul&gt;
&lt;li&gt;禁用匿名登录（默认启用）&lt;/li&gt;
&lt;li&gt;使用强大的用户认证&lt;/li&gt;
&lt;li&gt;创建 RBAC 策略以限制管理员、用户和服务账户活动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志审计
&lt;ul&gt;
&lt;li&gt;启用审计记录（默认为禁用）&lt;/li&gt;
&lt;li&gt;在节点、Pod 或容器级故障的情况下，持续保存日志以确保可用性&lt;/li&gt;
&lt;li&gt;配置一个 metric logger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;升级和应用安全实践
&lt;ul&gt;
&lt;li&gt;立即应用安全补丁和更新&lt;/li&gt;
&lt;li&gt;定期进行漏洞扫描和渗透测试&lt;/li&gt;
&lt;li&gt;当组件不再需要时，将其从环境中移除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;架构概述&#34;&gt;架构概述&lt;/h2&gt;
&lt;p&gt;Kubernetes 使用集群架构。一个 Kubernetes 集群是由一些控制平面和一个或多个物理或虚拟机组成的，称为工作节点。工作者节点承载 Pod，其中包含一个或多个容器。容器是包含软件包及其所有依赖关系的可执行镜像。见图 2：Kubernetes 架构。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f2.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/introduction/f2.jpg&#34; data-width=&#34;1752&#34; data-height=&#34;852&#34; alt=&#34;image&#34; data-caption=&#34;图 2：Kubernetes 架构&#34;&gt;
    
  
  &lt;figcaption&gt;图 2：Kubernetes 架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;控制平面对集群进行决策。这包括调度容器的运行，检测 / 应对故障，并在部署文件中指定的副本数量没有得到满足时启动新的 Pod。以下逻辑组件都是控制平面的一部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controller manager（默认端口：10252）&lt;/strong&gt; - 监视 Kubernetes 集群，以检测和维护 Kubernetes 环境的几个方面，包括将 Pod 加入到服务中，保持一组 Pod 的正确数量，并对节点的丢失做出反应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud controller manager（默认端口：10258）&lt;/strong&gt; - 一个用于基于云的部署的可选组件。云控制器与云服务提供商接口，以管理集群的负载均衡器和虚拟网络。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes API Server（默认端口：6443 或 8080）&lt;/strong&gt; - 管理员操作 Kubernetes 的接口。因此，API 服务器通常暴露在控制平面之外。API 服务器被设计成可扩展的，可能存在于多个控制平面节点上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Etcd（默认端口范围：2379-2380）&lt;/strong&gt; - 持久化的备份存储，关于集群状态的所有信息都保存在这里。Etcd 不应该被直接操作，而应该通过 API 服务器来管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scheduler（默认端口：10251）&lt;/strong&gt; - 跟踪工作节点的状态并决定在哪里运行 Pod。Kube-scheduler 只可以由控制平面内的节点访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 工作节点是专门为集群运行容器化应用的物理或虚拟机。除了运行容器引擎外，工作节点还承载以下两个服务，允许从控制平面进行协调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kubelet（默认端口：10250）&lt;/strong&gt; - 在每个工作节点上运行，以协调和验证 Pod 的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kube-proxy&lt;/strong&gt; - 一个网络代理，使用主机的数据包过滤能力，确保 Kubernetes 集群中数据包的正确路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群通常使用云服务提供商（CSP）的 Kubernetes 服务或在企业内部托管。在设计 Kubernetes 环境时，组织应了解他们在安全维护集群方面的责任。CSP 管理大部分的 Kubernetes 服务，但组织可能需要处理某些方面，如认证和授权。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>开放接口</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 作为云原生应用的基础调度平台，相当于云原生的操作系统，为了便于系统的扩展，Kubernetes 中开放的以下接口，可以分别对接不同的后端，来实现自己的业务逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;cri&#34; title=&#34;容器运行时接口（CRI）&#34;&gt;容器运行时接口（CRI）&lt;/a&gt;
：提供计算资源&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;cni&#34; title=&#34;容器网络接口（CNI）&#34;&gt;容器网络接口（CNI）&lt;/a&gt;
：提供网络资源&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;csi&#34; title=&#34;容器存储接口（CSI）&#34;&gt;容器存储接口（CSI）&lt;/a&gt;
，提供存储资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上三种资源相当于一个分布式操作系统的最基础的几种资源类型，而 Kuberentes 是将他们粘合在一起的纽带。&lt;/p&gt;
&lt;h2 id=&#34;本节大纲&#34;&gt;本节大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cri/&#34;&gt;容器运行时接口（CRI）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cni/&#34;&gt;容器网络接口（CNI）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/csi/&#34;&gt;容器存储接口（CSI）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
    
    <item>
      <title>威胁建模</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/threat-model/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/threat-model/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 可以成为数据和 / 或计算能力盗窃的重要目标。虽然数据盗窃是传统上的主要动机，但寻求计算能力（通常用于加密货币挖掘）的网络行为者也被吸引到 Kubernetes 来利用其底层基础设施。除了资源盗窃，网络行为者还可能针对 Kubernetes 造成拒绝服务。下面的威胁代表了 Kubernetes 集群最可能的破坏源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;供应链风险&lt;/strong&gt; - 对供应链的攻击载体是多种多样的，并且在减轻风险方面具有挑战性。供应链风险是指对手可能颠覆构成系统的任何元素的风险，包括帮助提供最终产品的产品组件、服务或人员。这可能包括用于创建和管理 Kubernetes 集群的第三方软件和供应商。供应链的潜在威胁会在多个层面上影响 Kubernetes，包括：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器 / 应用层面&lt;/strong&gt; - 在 Kubernetes 中运行的应用及其第三方依赖的安全性，它们依赖于开发者的可信度和开发基础设施的防御能力。来自第三方的恶意容器或应用程序可以为网络行为者在集群中提供一个立足点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施&lt;/strong&gt; - 托管 Kubernetes 的底层系统有其自身的软件和硬件依赖性。系统作为工作节点或控制平面一部分的，任何潜在威胁都可能为网络行为者在集群中提供一个立足点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恶意威胁行为者&lt;/strong&gt; - 恶意行为者经常利用漏洞从远程位置获得访问权。Kubernetes 架构暴露了几个 API，网络行为者有可能利用这些 API 进行远程利用。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制平面&lt;/strong&gt; - Kubernetes 控制平面有各种组件，通过通信来跟踪和管理集群。网络行为者经常利用缺乏适当访问控制的暴露的控制平面组件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作节点&lt;/strong&gt; - 除了运行容器引擎外，工作者节点还承载着 &lt;code&gt;kubelet&lt;/code&gt; 和 &lt;code&gt;kube-proxy&lt;/code&gt; 服务，这些都有可能被网络行为者利用。此外，工作节点存在于被锁定的控制平面之外，可能更容易被网络行为者利用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器化的应用程序&lt;/strong&gt; - 在集群内运行的应用程序是常见的目标。应用程序经常可以在集群之外访问，使它们可以被远程网络行为者接触到。然后，网络行为者可以从已经被破坏的应用出发，或者利用暴露的应用程序的内部可访问资源在集群中提升权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部威胁&lt;/strong&gt; - 威胁者可以利用漏洞或使用个人在组织内工作时获得的特权。来自组织内部的个人被赋予特殊的知识和特权，可以用来威胁 Kubernetes 集群。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管理员&lt;/strong&gt; - Kubernetes 管理员对运行中的容器有控制权，包括在容器化环境中执行任意命令的能力。Kubernetes 强制的 RBAC 授权可以通过限制对敏感能力的访问来帮助降低风险。然而，由于 Kubernetes 缺乏双人制的完整性控制，即必须有至少一个管理账户才能够获得集群的控制权。管理员通常有对系统或管理程序的物理访问权，这也可能被用来破坏 Kubernetes 环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt; - 容器化应用程序的用户可能有知识和凭证来访问 Kubernetes 集群中的容器化服务。这种程度的访问可以提供足够的手段来利用应用程序本身或其他集群组件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云服务或基础设施供应商&lt;/strong&gt; - 对管理 Kubernetes 节点的物理系统或管理程序的访问可被用来破坏 Kubernetes 环境。云服务提供商通常有多层技术和管理控制，以保护系统免受特权管理员的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>容器运行时接口（CRI）</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cri/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cri/</guid>
      <description>
        
        
        &lt;p&gt;容器运行时接口（Container Runtime Interface），简称 CRI。CRI 中定义了 &lt;strong&gt;容器&lt;/strong&gt; 和 &lt;strong&gt;镜像&lt;/strong&gt; 的服务的接口，因为容器运行时与镜像的生命周期是彼此隔离的，因此需要定义两个服务。该接口使用 &lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34; title=&#34;Protocol Buffer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol Buffer&lt;/a&gt;
，基于 &lt;a href=&#34;https://grpc.io/&#34; title=&#34;gRPC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC&lt;/a&gt;
，在 Kubernetes v1.10 + 版本中是在 &lt;code&gt;pkg/kubelet/apis/cri/runtime/v1alpha2&lt;/code&gt; 的 &lt;code&gt;api.proto&lt;/code&gt; 中定义的。&lt;/p&gt;
&lt;h2 id=&#34;cri-架构&#34;&gt;CRI 架构&lt;/h2&gt;
&lt;p&gt;Container Runtime 实现了 CRI gRPC Server，包括 &lt;code&gt;RuntimeService&lt;/code&gt; 和 &lt;code&gt;ImageService&lt;/code&gt;。该 gRPC Server 需要监听本地的 Unix socket，而 kubelet 则作为 gRPC Client 运行。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cri/cri-architecture.png&#34; data-img=&#34;/book/kubernetes-handbook/architecture/open-interfaces/cri/cri-architecture.png&#34; data-width=&#34;572&#34; data-height=&#34;136&#34; alt=&#34;image&#34; data-caption=&#34;CRI 架构 - 图片来自 kubernetes blog&#34;&gt;
    
  
  &lt;figcaption&gt;CRI 架构 - 图片来自 kubernetes blog&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;启用-cri&#34;&gt;启用 CRI&lt;/h2&gt;
&lt;p&gt;除非集成了 rktnetes，否则 CRI 都是被默认启用了，从 Kubernetes 1.7 版本开始，旧的预集成的 docker CRI 已经被移除。&lt;/p&gt;
&lt;p&gt;要想启用 CRI 只需要在 kubelet 的启动参数重传入此参数：&lt;code&gt;--container-runtime-endpoint&lt;/code&gt; 远程运行时服务的端点。当前 Linux 上支持 unix socket，windows 上支持 tcp。例如：&lt;code&gt;unix:///var/run/dockershim.sock&lt;/code&gt;、 &lt;code&gt;tcp://localhost:373&lt;/code&gt;，默认是 &lt;code&gt;unix:///var/run/dockershim.sock&lt;/code&gt;，即默认使用本地的 docker 作为容器运行时。&lt;/p&gt;
&lt;h2 id=&#34;cri-接口&#34;&gt;CRI 接口&lt;/h2&gt;
&lt;p&gt;Kubernetes 1.9 中的 CRI 接口在 &lt;code&gt;api.proto&lt;/code&gt; 中的定义，其中包含了两个 gRPC 服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RuntimeService&lt;/strong&gt;：容器和 Sandbox 运行时管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImageService&lt;/strong&gt;：提供了从镜像仓库拉取、查看、和移除镜像的 RPC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;当前支持的-cri-后端&#34;&gt;当前支持的 CRI 后端&lt;/h2&gt;
&lt;p&gt;我们最初在使用 Kubernetes 时通常会默认使用 Docker 作为容器运行时，其实从 Kubernetes 1.5 开始已经支持 CRI，通过 CRI 接口可以指定使用其它容器运行时作为 Pod 的后端，目前支持 CRI 的后端有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-incubator/cri-o&#34; title=&#34;cri-o&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cri-o&lt;/a&gt;
：cri-o 是 Kubernetes 的 CRI 标准的实现，并且允许 Kubernetes 间接使用 OCI 兼容的容器运行时，可以把 cri-o 看成 Kubernetes 使用 OCI 兼容的容器运行时的中间层。主要由 Red Hat 公司贡献开源。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containerd/containerd&#34; title=&#34;containerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd&lt;/a&gt;
：Kubernetes CRI 默认实现，由 Docker 公司贡献开源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，还有两个容器运行时值得一提——katacontainers 和 gvisor 都没有直接实现 CRI 接口。它们都是通过在容器运行时和宿主机之间添加一个虚拟化层来增强安全性能的。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://katacontainers.io/&#34; title=&#34;Kata Containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kata Containers&lt;/a&gt;
：katacontainers 是一种轻量级的虚拟化技术，曾合并了 Clear Containers。它通过在容器和操作系统之间添加一个轻量级的虚拟化层来提供额外的安全性和隔离性。它可以与 Kubernetes 集成，但需要通过一些额外的工具来实现与 CRI 的交互。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/gvisor&#34; title=&#34;gVisor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gVisor&lt;/a&gt;
：gvisor 是一种轻量级的沙箱技术，由 Google 公司开源。它通过在容器运行时和操作系统之间添加一个沙箱层来提供额外的安全性和隔离性。gvisor 可以与 Docker 和 Kubernetes 集成，但是也需要通过一些额外的工具来实现与 CRI 的交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，虽然 katacontainers 和 gvisor 都不能直接实现 CRI 接口，但它们都是为容器提供增强安全性和隔离性的重要技术，并且可以与 Kubernetes 集成来实现容器管理和调度。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sreeninet.wordpress.com/2017/02/11/kubernetes-cri-and-minikube/&#34; title=&#34;Kubernetes CRI and Minikube - sreeninet.wordpress.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes CRI and Minikube - sreeninet.wordpress.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projectatomic.io/blog/2017/02/crio-runtimes/&#34; title=&#34;CRI-O and Alternative Runtimes in Kubernetes - projectatomic.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CRI-O and Alternative Runtimes in Kubernetes - projectatomic.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/2017/02/Docker-Containerd-RunC/&#34; title=&#34;Docker、Containerd、RunC&amp;amp;hellip;：你应该知道的所有&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker、Containerd、RunC&amp;hellip;：你应该知道的所有&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/&#34; title=&#34;Introducing Container Runtime Interface (CRI) in Kubernetes - blog.kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Container Runtime Interface (CRI) in Kubernetes - blog.kubernetes.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cri-o.io/&#34; title=&#34;cri-o 官网 - cri-o.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cri-o 官网 - cri-o.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kata-containers/documentation/blob/master/design/architecture.md#kubernetes-support&#34; title=&#34;Kata Containers Architecture - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kata Containers Architecture - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes Pod 安全</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/kubernetes-pod-security/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/kubernetes-pod-security/</guid>
      <description>
        
        
        &lt;p&gt;Pod 是 Kubernetes 中最小的可部署单元，由一个或多个容器组成。Pod 通常是网络行为者在利用容器时的初始执行环境。出于这个原因，Pod 应该被加固，以使利用更加困难，并限制成功入侵的影响。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/kubernetes-pod-security/f3.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/kubernetes-pod-security/f3.jpg&#34; data-width=&#34;1744&#34; data-height=&#34;1044&#34; alt=&#34;image&#34; data-caption=&#34;图3：有 sidecar 代理作为日志容器的 Pod 组件&#34;&gt;
    
  
  &lt;figcaption&gt;图3：有 sidecar 代理作为日志容器的 Pod 组件&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;非-root容器和无-root容器引擎&#34;&gt;“非 root”容器和“无 root”容器引擎&lt;/h2&gt;
&lt;p&gt;默认情况下，许多容器服务以有特权的 root 用户身份运行，应用程序在容器内以 root 用户身份执行，尽管不需要有特权的执行。&lt;/p&gt;
&lt;p&gt;通过使用非 root 容器或无 root 容器引擎来防止 root 执行，可以限制容器受损的影响。这两种方法都会对运行时环境产生重大影响，因此应该对应用程序进行全面测试，以确保兼容性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非 root 容器&lt;/strong&gt;：容器引擎允许容器以非 root 用户和非 root 组成员身份运行应用程序。通常情况下，这种非默认设置是在构建容器镜像的时候配置的。&lt;strong&gt;&lt;a href=&#34;../appendix/a/&#34; title=&#34;附录 A：非 root 应用的 Dockerfile 示例&#34;&gt;附录 A：非 root 应用的 Dockerfile 示例&lt;/a&gt;
&lt;/strong&gt; 显示了一个 Dockerfile 示例，它以非 root 用户身份运行一个应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非 root 用户&lt;/strong&gt;。另外，Kubernetes 可以在 &lt;code&gt;SecurityContext:runAsUser&lt;/code&gt; 指定一个非零用户的情况下，将容器加载到 Pod。虽然 &lt;code&gt;runAsUser&lt;/code&gt; 指令在部署时有效地强制非 root 执行，但 NSA 和 CISA 鼓励开发者构建的容器应用程序，以非 root 用户身份执行。在构建时集成非 root 用户执行，可以更好地保证应用程序在没有 root 权限的情况下正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无 root 的容器引擎&lt;/strong&gt;：一些容器引擎可以在无特权的上下文中运行，而不是使用以 root 身份运行的守护程序。在这种情况下，从容器化应用程序的角度来看，执行似乎是使用 root 用户，但执行被重新映射到主机上的引擎用户上下文。虽然无 root 容器引擎增加了一个有效的安全层，但许多引擎目前是作为实验性发布的，不应该在生产环境中使用。管理员应该了解这一新兴技术，并在供应商发布与 Kubernetes 兼容的稳定版本时寻求采用无 root 容器引擎。&lt;/p&gt;
&lt;h2 id=&#34;不可变的容器文件系统&#34;&gt;不可变的容器文件系统&lt;/h2&gt;
&lt;p&gt;默认情况下，容器在自己的上下文中被允许不受限制地执行。在容器中获得执行权限的网络行为者可以在容器中创建文件、下载脚本和修改应用程序。Kubernetes 可以锁定一个容器的文件系统，从而防止许多暴露后的活动。&lt;/p&gt;
&lt;p&gt;然而，这些限制也会影响合法的容器应用程序，并可能导致崩溃或异常行为。为了防止损害合法的应用程序，Kubernetes 管理员可以为应用程序需要写访问的特定目录挂载二级读 / 写文件系统。&lt;strong&gt;&lt;a href=&#34;../appendix/b/&#34; title=&#34;附录 B：只读文件系统的部署模板示例&#34;&gt;附录 B：只读文件系统的部署模板示例&lt;/a&gt;
&lt;/strong&gt; 显示了一个具有可写目录的不可变容器的例子。&lt;/p&gt;
&lt;h2 id=&#34;构建安全的容器镜像&#34;&gt;构建安全的容器镜像&lt;/h2&gt;
&lt;p&gt;容器镜像通常是通过从头开始构建容器或在从存储库中提取的现有镜像基础上创建的。除了使用可信的存储库来构建容器外，镜像扫描是确保部署的容器安全的关键。在整个容器构建工作流程中，应该对镜像进行扫描，以识别过时的库、已知的漏洞或错误配置，如不安全的端口或权限。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/kubernetes-pod-security/f4.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/kubernetes-pod-security/f4.jpg&#34; data-width=&#34;1160&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;图4：容器的构建工作流程，用 webhook 和准入控制器进行优化&#34;&gt;
    
  
  &lt;figcaption&gt;图4：容器的构建工作流程，用 webhook 和准入控制器进行优化&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;实现镜像扫描的一种方法是使用准入控制器。准入控制器是 Kubernetes 的原生功能，可以在对象的持久化之前，但在请求被验证和授权之后，拦截和处理对 Kubernetes API 的请求。可以实现一个自定义或专有的 webhook，以便在集群中部署任何镜像之前执行扫描。如果镜像符合 webhook 配置中定义的组织的安全策略，这个准入控制器可以阻止部署。&lt;/p&gt;
&lt;h2 id=&#34;pod-安全策略&#34;&gt;Pod 安全策略&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Pod 的创建应遵守最小授权原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pod 安全策略（PSP）&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;是一个集群范围内的策略，它规定了 Pod 在集群内执行的安全要求 / 默认值。虽然安全机制通常是在 Pod/Deployment 配置中指定的，但 PSP 建立了一个所有 Pod 必须遵守的最低安全门槛。一些 PSP 字段提供默认值，当 Pod 的配置省略某个字段时使用。其他 PSP 字段被用来拒绝创建不符合要求的 Pod。PSP 是通过 Kubernetes 准入控制器执行的，所以 PSP 只能在 Pod 创建期间执行要求。PSP 并不影响已经在集群中运行的 Pod。&lt;/p&gt;
&lt;p&gt;PSP 很有用，可以在集群中强制执行安全措施。PSP 对于由具有分层角色的管理员管理的集群特别有效。在这些情况下，顶级管理员可以施加默认值，对低层级的管理员强制执行要求。NSA 和 CISA 鼓励企业根据自己的需要调整 &lt;strong&gt;&lt;a href=&#34;../appendix/c/&#34; title=&#34;附录 C：Pod 安全策略示例&#34;&gt;附录 C：Pod 安全策略示例&lt;/a&gt;
&lt;/strong&gt; 中的 Kubernetes 加固 PSP 模板。下表描述了一些广泛适用的 PSP 组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 1: Pod 安全策略组件&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段名称&lt;/th&gt;
&lt;th&gt;使用方法&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;privileged&lt;/td&gt;
&lt;td&gt;控制 Pod 是否可以运行有特权的容器。&lt;/td&gt;
&lt;td&gt;设置为 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hostPID、hostIPC&lt;/td&gt;
&lt;td&gt;控制容器是否可以共享主机进程命名空间。&lt;/td&gt;
&lt;td&gt;设置为 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hostNetwork&lt;/td&gt;
&lt;td&gt;控制容器是否可以使用主机网络。&lt;/td&gt;
&lt;td&gt;设置为 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allowedHostPaths&lt;/td&gt;
&lt;td&gt;将容器限制在主机文件系统的特定路径上。&lt;/td&gt;
&lt;td&gt;使用一个 &amp;ldquo;假的&amp;rdquo; 路径名称（比如 &lt;code&gt;/foo&lt;/code&gt; 标记为只读）。省略这个字段的结果是不对容器进行准入限制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;readOnlyRootFilesystem&lt;/td&gt;
&lt;td&gt;需要使用一个只读的根文件系统。&lt;/td&gt;
&lt;td&gt;可能时设置为 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runAsUser, runAsGroup, supplementalGroups, fsGroup&lt;/td&gt;
&lt;td&gt;控制容器应用程序是否能以 root 权限或 root 组成员身份运行。&lt;/td&gt;
&lt;td&gt;- 设置 &lt;code&gt;runAsUser&lt;/code&gt; 为 &lt;code&gt;MustRunAsNonRoot&lt;/code&gt;。- 将 &lt;code&gt;runAsGroup&lt;/code&gt; 设置为非零（参见&lt;a href=&#34;../appendix/c/&#34; title=&#34;附录 C&#34;&gt;附录 C&lt;/a&gt;
 中的例子：Pod 安全策略示例）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;supplementalGroups&lt;/code&gt; 设置为非零（见附录 C 的例子）。将 &lt;code&gt;fsGroup&lt;/code&gt; 设置为非零（参见&lt;a href=&#34;../appendix/c/&#34; title=&#34;附录 C&#34;&gt;附录 C&lt;/a&gt;
 中的例子：Pod 安全策略示例）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;allowPrivilegeEscalation&lt;/td&gt;
&lt;td&gt;限制升级到 root 权限。&lt;/td&gt;
&lt;td&gt;设置为 false。为了有效地执行 &lt;code&gt;runAsUser: MustRunAsNonRoot&lt;/code&gt; 设置，需要采取这一措施。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seLinux&lt;/td&gt;
&lt;td&gt;设置容器的 SELinux 上下文。&lt;/td&gt;
&lt;td&gt;如果环境支持 SELinux，可以考虑添加 SELinux 标签以进一步加固容器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AppArmor 注解&lt;/td&gt;
&lt;td&gt;设置容器所使用的 AppArmor 配置文件。&lt;/td&gt;
&lt;td&gt;在可能的情况下，通过采用 AppArmor 来限制开发，以加固容器化的应用程序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seccomp 注解&lt;/td&gt;
&lt;td&gt;设置用于沙盒容器的 seccomp 配置文件。&lt;/td&gt;
&lt;td&gt;在可能的情况下，使用 seccomp 审计配置文件来识别运行中的应用程序所需的系统调用；然后启用 seccomp 配置文件来阻止所有其他系统调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于以下原因，PSP 不会自动适用于整个集群：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在应用 PSP 之前，必须为 Kubernetes 准入控制器启用 &lt;code&gt;PodSecurityPolicy&lt;/code&gt; 插件，这是 &lt;code&gt;kube-apiserver&lt;/code&gt; 的一部分。&lt;/li&gt;
&lt;li&gt;第二，策略必须通过 RBAC 授权。管理员应从其集群组织内的每个角色中验证已实施的 PSP 的正确功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在有多个 PSP 的环境中，管理员应该谨慎行事，因为 Pod 的创建会遵守&lt;strong&gt;最小限制性&lt;/strong&gt;授权策略。以下命令描述了给定命名空间的所有 Pod 安全策略，这可以帮助识别有问题的重叠策略。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get psp -n &amp;lt;namespace&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;保护-pod-服务账户令牌&#34;&gt;保护 Pod 服务账户令牌&lt;/h2&gt;
&lt;p&gt;默认情况下，Kubernetes 在创建 Pod 时自动提供一个服务账户（Service Account），并在运行时在 Pod 中挂载该账户的秘密令牌（token）。许多容器化的应用程序不需要直接访问服务账户，因为 Kubernetes 的协调工作是在后台透明进行的。如果一个应用程序被破坏了。Pod 中的账户令牌可以被网络行为者收集并用于进一步破坏集群。当应用程序不需要直接访问服务账户时，Kubernetes 管理员应确保 Pod 规范禁用正在加载的秘密令牌。这可以通过 Pod 的 YAML 规范中的 &lt;code&gt;automountServiceAccountToken: false&lt;/code&gt; 指令来完成。&lt;/p&gt;
&lt;h2 id=&#34;加固容器引擎&#34;&gt;加固容器引擎&lt;/h2&gt;
&lt;p&gt;一些平台和容器引擎提供了额外的选项来加固容器化环境。一个强有力的例子是使用管理程序来提供容器隔离。管理程序依靠硬件来执行虚拟化边界，而不是操作系统。管理程序隔离比传统的容器隔离更安全。在 Windows® 操作系统上运行的容器引擎可以被配置为使用内置的 Windows 管理程序 Hyper-V®，以增强安全性。&lt;/p&gt;
&lt;p&gt;此外，一些注重安全的容器引擎将每个容器部署在一个轻量级的管理程序中，以实现深度防御。由管理程序支持的容器可以减少容器的突破。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;译者注：Pod Security Policy 已在 1.21 版本中宣布弃用，作为替代，1.22 引入了内置的 Pod Security Admission 控制器以及新的 Pod Security Standards 标准。&lt;a href=&#34;https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/&#34; title=&#34;来源&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;来源&lt;/a&gt;
&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>容器网络接口（CNI）</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cni/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/cni/</guid>
      <description>
        
        
        &lt;p&gt;容器网络接口（Container Network Interface），简称 CNI，是 CNCF 旗下的一个项目，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件。CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。有关详情请查看 &lt;a href=&#34;https://github.com/containernetworking/cni&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;Kubernetes 源码的 &lt;code&gt;vendor/github.com/containernetworking/cni/libcni&lt;/code&gt; 目录中已经包含了 CNI 的代码，也就是说 Kubernetes 中已经内置了 CNI。&lt;/p&gt;
&lt;h2 id=&#34;接口定义&#34;&gt;接口定义&lt;/h2&gt;
&lt;p&gt;CNI 的接口中包括以下几个方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CNI&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;AddNetworkList&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NetworkConfigList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RuntimeConf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;DelNetworkList&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NetworkConfigList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RuntimeConf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;AddNetwork&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NetworkConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RuntimeConf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;DelNetwork&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NetworkConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RuntimeConf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该接口只有四个方法，添加网络、删除网络、添加网络列表、删除网络列表。&lt;/p&gt;
&lt;h2 id=&#34;设计考量&#34;&gt;设计考量&lt;/h2&gt;
&lt;p&gt;CNI 设计的时候考虑了以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器运行时必须在调用任何插件之前为容器创建一个新的网络命名空间。&lt;/li&gt;
&lt;li&gt;然后，运行时必须确定这个容器应属于哪个网络，并为每个网络确定哪些插件必须被执行。&lt;/li&gt;
&lt;li&gt;网络配置采用 JSON 格式，可以很容易地存储在文件中。网络配置包括必填字段，如 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 以及插件（类型）。网络配置允许字段在调用之间改变值。为此，有一个可选的字段 &lt;code&gt;args&lt;/code&gt;，必须包含不同的信息。&lt;/li&gt;
&lt;li&gt;容器运行时必须按顺序为每个网络执行相应的插件，将容器添加到每个网络中。&lt;/li&gt;
&lt;li&gt;在完成容器生命周期后，运行时必须以相反的顺序执行插件（相对于执行添加容器的顺序）以将容器与网络断开连接。&lt;/li&gt;
&lt;li&gt;容器运行时不能为同一容器调用并行操作，但可以为不同的容器调用并行操作。&lt;/li&gt;
&lt;li&gt;容器运行时必须为容器订阅 ADD 和 DEL 操作，这样 ADD 后面总是跟着相应的 DEL。DEL 可能跟着额外的 DEL，但是，插件应该允许处理多个 DEL（即插件 DEL 应该是幂等的）。&lt;/li&gt;
&lt;li&gt;容器必须由 ContainerID 唯一标识。存储状态的插件应该使用（网络名称，容器 ID）的主键来完成。&lt;/li&gt;
&lt;li&gt;运行时不能调用同一个网络名称或容器 ID 执行两次 ADD（没有相应的 DEL）。换句话说，给定的容器 ID 必须只能添加到特定的网络一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cni-插件&#34;&gt;CNI 插件&lt;/h2&gt;
&lt;p&gt;CNI 插件必须实现一个可执行文件，这个文件可以被容器管理系统（例如 rkt 或 Kubernetes）调用。&lt;/p&gt;
&lt;p&gt;CNI 插件负责将网络接口插入容器网络命名空间（例如，veth 对的一端），并在主机上进行任何必要的改变（例如将 veth 的另一端连接到网桥）。然后将 IP 分配给接口，并通过调用适当的 IPAM 插件来设置与“IP 地址管理”部分一致的路由。&lt;/p&gt;
&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;
&lt;p&gt;CNI 插件必须支持以下操作：&lt;/p&gt;
&lt;h4 id=&#34;将容器添加到网络&#34;&gt;将容器添加到网络&lt;/h4&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本&lt;/strong&gt;调用者正在使用的 CNI 规范（容器管理系统或调用插件）的版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器 ID&lt;/strong&gt;由运行时分配的容器的唯一明文标识符。一定不能是空的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络命名空间路径&lt;/strong&gt;要添加的网络名称空间的路径，即 &lt;code&gt;/proc/[pid]/ns/net&lt;/code&gt; 或绑定挂载 / 链接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络配置&lt;/strong&gt;描述容器可以加入的网络的 JSON 文档。架构如下所述。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;额外的参数&lt;/strong&gt;这提供了一个替代机制，允许在每个容器上简单配置 CNI 插件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器内接口的名称&lt;/strong&gt;这是应该分配给容器（网络命名空间）内创建的接口的名称；因此它必须符合 Linux 接口名称上的标准限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接口列表&lt;/strong&gt;根据插件的不同，这可以包括沙箱（例如容器或管理程序）接口名称和 / 或主机接口名称，每个接口的硬件地址以及接口所在的沙箱（如果有的话）的详细信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分配给每个接口的 IP 配置&lt;/strong&gt;分配给沙箱和 / 或主机接口的 IPv4 和 / 或 IPv6 地址，网关和路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DNS 信息&lt;/strong&gt;包含 nameserver、domain、search domain 和 option 的 DNS 信息的字典。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;从网络中删除容器&#34;&gt;从网络中删除容器&lt;/h4&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;调用者正在使用的 CNI 规范（容器管理系统或调用插件）的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容器 ID&lt;/strong&gt;，如上所述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络命名空间路径&lt;/strong&gt;，如上定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络配置&lt;/strong&gt;，如上所述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;额外的参数&lt;/strong&gt;，如上所述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上面定义的容器&lt;/strong&gt;内的接口的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有参数应与传递给相应的添加操作的参数相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除操作应释放配置的网络中提供的 containerid 拥有的所有资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;报告版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数：无。&lt;/li&gt;
&lt;li&gt;结果：插件支持的 CNI 规范版本信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;cniVersio&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.3.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 此输出使用的 CNI 规范的版本
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;supportedVersions&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.1.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.3.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.3.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 此插件支持的 CNI 规范版本列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CNI 插件的详细说明请参考：&lt;a href=&#34;https://github.com/containernetworking/cni/blob/master/SPEC.md&#34; title=&#34;CNI 规范&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI 规范&lt;/a&gt;
。&lt;/p&gt;
&lt;h3 id=&#34;ip-分配&#34;&gt;IP 分配&lt;/h3&gt;
&lt;p&gt;作为容器网络管理的一部分，CNI 插件需要为接口分配（并维护）IP 地址，并安装与该接口相关的所有必要路由。这给了 CNI 插件很大的灵活性，但也给它带来了很大的负担。众多的 CNI 插件需要编写相同的代码来支持用户需要的多种 IP 管理方案（例如 dhcp、host-local）。&lt;/p&gt;
&lt;p&gt;为了减轻负担，使 IP 管理策略与 CNI 插件类型解耦，我们定义了 IP 地址管理插件（IPAM 插件）。CNI 插件的职责是在执行时恰当地调用 IPAM 插件。IPAM 插件必须确定接口 IP/subnet，网关和路由，并将此信息返回到“主”插件来应用配置。IPAM 插件可以通过协议（例如 dhcp）、存储在本地文件系统上的数据、网络配置文件的“ipam” 部分或上述的组合来获得信息。&lt;/p&gt;
&lt;h4 id=&#34;ipam-插件&#34;&gt;IPAM 插件&lt;/h4&gt;
&lt;p&gt;像 CNI 插件一样，调用 IPAM 插件的可执行文件。可执行文件位于预定义的路径列表中，通过 &lt;code&gt;CNI_PATH&lt;/code&gt; 指示给 CNI 插件。IPAM 插件必须接收所有传入 CNI 插件的相同环境变量。就像 CNI 插件一样，IPAM 插件通过 stdin 接收网络配置。&lt;/p&gt;
&lt;h2 id=&#34;可用插件&#34;&gt;可用插件&lt;/h2&gt;
&lt;h3 id=&#34;main接口创建&#34;&gt;Main：接口创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bridge&lt;/strong&gt;：创建网桥，并添加主机和容器到该网桥&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ipvlan&lt;/strong&gt;：在容器中添加一个 &lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/ipvlan.txt&#34; title=&#34;ipvlan&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ipvlan&lt;/a&gt;
 接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;loopback&lt;/strong&gt;：创建一个回环接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;macvlan&lt;/strong&gt;：创建一个新的 MAC 地址，将所有的流量转发到容器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ptp&lt;/strong&gt;：创建 veth 对&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vlan&lt;/strong&gt;：分配一个 vlan 设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipamip-地址分配&#34;&gt;IPAM：IP 地址分配&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dhcp&lt;/strong&gt;：在主机上运行守护程序，代表容器发出 DHCP 请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;host-local&lt;/strong&gt;：维护分配 IP 的本地数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;meta其它插件&#34;&gt;Meta：其它插件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;flannel&lt;/strong&gt;：根据 flannel 的配置文件创建接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tuning&lt;/strong&gt;：调整现有接口的 sysctl 参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;portmap&lt;/strong&gt;：一个基于 iptables 的 portmapping 插件。将端口从主机的地址空间映射到容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containernetworking/cni&#34; title=&#34;containernetworking/cni - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containernetworking/cni - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containernetworking/plugins&#34; title=&#34;containernetworking/plugins - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containernetworking/plugins - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containernetworking/cni/blob/master/SPEC.md&#34; title=&#34;Container Networking Interface Specification - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Networking Interface Specification - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containernetworking/cni/blob/main/CONVENTIONS.md&#34; title=&#34;CNI Extension conventions - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI Extension conventions - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>网络隔离和加固</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/network-separation-and-hardening/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/network-separation-and-hardening/</guid>
      <description>
        
        
        &lt;p&gt;集群网络是 Kubernetes 的一个核心概念。容器、Pod、服务和外部服务之间的通信必须被考虑在内。默认情况下，很少有网络策略来隔离资源，防止集群被破坏时的横向移动或升级。资源隔离和加密是限制网络行为者在集群内转移和升级的有效方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用网络策略和防火墙来隔离资源。&lt;/li&gt;
&lt;li&gt;确保控制平面的安全。&lt;/li&gt;
&lt;li&gt;对流量和敏感数据（例如 Secret）进行静态加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;Kubernetes 命名空间是在同一集群内的多个个人、团队或应用程序之间划分集群资源的一种方式。&lt;strong&gt;默认情况下，命名空间不会被自动隔离&lt;/strong&gt;。然而，命名空间确实为一个范围分配了一个标签，这可以用来通过 RBAC 和网络策略指定授权规则。除了网络隔离之外，策略可以限制存储和计算资源，以便在命名空间层面上对 Pod 进行更好的控制。&lt;/p&gt;
&lt;p&gt;默认有三个命名空间，它们不能被删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kube-system&lt;/code&gt;（用于 Kubernetes 组件）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-public&lt;/code&gt;（用于公共资源）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;（针对用户资源）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户 Pod 不应该放在 &lt;code&gt;kube-system&lt;/code&gt; 或 &lt;code&gt;kube-public&lt;/code&gt; 中，因为这些都是为集群服务保留的。可以用 YAML 文件，如 &lt;strong&gt;&lt;a href=&#34;../appendix/d/&#34; title=&#34;附录 D：命名空间示例&#34;&gt;附录 D：命名空间示例&lt;/a&gt;
&lt;/strong&gt; ，可以用来创建新的命名空间。不同命名空间中的 Pod 和服务仍然可以相互通信，除非有额外的隔离措施，如网络策略。&lt;/p&gt;
&lt;h2 id=&#34;网络策略&#34;&gt;网络策略&lt;/h2&gt;
&lt;p&gt;网络策略控制 Pod、命名空间和外部 IP 地址之间的流量。默认情况下，没有网络策略应用于 Pod 或命名空间，导致 Pod 网络内的入口和出口流量不受限制。通过适用于 Pod 或 Pod 命名空间的网络策略，Pod 将被隔离。一旦一个 Pod 在网络策略中被选中，它就会拒绝任何适用的策略对象所不允许的任何连接。&lt;/p&gt;
&lt;p&gt;要创建网络策略，需要一个支持 &lt;code&gt;NetworkPolicy&lt;/code&gt; API 的网络插件。使用 &lt;code&gt;podSelector&lt;/code&gt; 和 / 或 &lt;code&gt;namespaceSelector&lt;/code&gt; 选项来选择 Pod。&lt;a href=&#34;../appendix/e/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 E&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 E&lt;/strong&gt;&lt;/a&gt;
 中展示了一个网络策略的例子。网络策略的格式可能有所不同，这取决于集群使用的容器网络接口（CNI）插件。管理员应该使用选择所有 Pod 的默认策略来拒绝所有入口和出口流量，并确保任何未选择的 Pod 被隔离。然后，额外的策略可以放松这些允许连接的限制。&lt;/p&gt;
&lt;p&gt;外部 IP 地址可以使用 &lt;code&gt;ipBlock&lt;/code&gt; 在入口和出口策略中使用，但不同的 CNI 插件、云提供商或服务实现可能会影响 &lt;code&gt;NetworkPolicy&lt;/code&gt; 处理的顺序和集群内地址的重写。&lt;/p&gt;
&lt;h2 id=&#34;资源政策&#34;&gt;资源政策&lt;/h2&gt;
&lt;p&gt;除了网络策略，&lt;code&gt;LimitRange&lt;/code&gt; 和 &lt;code&gt;ResourceQuota&lt;/code&gt; 是两个可以限制命名空间或节点的资源使用的策略。&lt;code&gt;LimitRange&lt;/code&gt; 策略限制了特定命名空间内每个 Pod 或容器的单个资源，例如，通过强制执行最大计算和存储资源。每个命名空间只能创建一个 &lt;code&gt;LimitRange&lt;/code&gt; 约束，如 &lt;strong&gt;&lt;a href=&#34;../appendix/f/&#34; title=&#34;附录 F&#34;&gt;附录 F&lt;/a&gt;
&lt;/strong&gt; 的 &lt;code&gt;LimitRange&lt;/code&gt; 示例中所示。Kubernetes 1.10 和更新版本默认支持 &lt;code&gt;LimitRange&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;与 &lt;code&gt;LimitRange&lt;/code&gt; 策略不同的是，&lt;code&gt;ResourceQuotas&lt;/code&gt; 是对整个命名空间的资源使用总量的限制，例如对 CPU 和内存使用总量的限制。如果用户试图创建一个违反 &lt;code&gt;LimitRange&lt;/code&gt; 或 &lt;code&gt;ResourceQuota&lt;/code&gt; 策略的 Pod，则 Pod 创建失败。&lt;a href=&#34;../appendix/g/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 G&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 G&lt;/strong&gt;&lt;/a&gt;
 中显示了一个 &lt;code&gt;ResourceQuota&lt;/code&gt; 策略的示例。&lt;/p&gt;
&lt;h2 id=&#34;控制平面加固&#34;&gt;控制平面加固&lt;/h2&gt;
&lt;p&gt;控制平面是 Kubernetes 的核心，使用户能够查看容器，安排新的 Pod，读取 Secret，在集群中执行命令。由于这些敏感的功能，控制平面应受到高度保护。除了 TLS 加密、RBAC 和强大的认证方法等安全配置外，网络隔离可以帮助防止未经授权的用户访问控制平面。Kubernetes API 服务器运行在 6443 和 8080 端口上，这些端口应该受到防火墙的保护，只接受预期的流量。8080 端口，默认情况下，可以在没有 TLS 加密的情况下从本地机器访问，请求绕过认证和授权模块。不安全的端口可以使用 API 服务器标志 &lt;code&gt;--insecure-port=0&lt;/code&gt; 来禁用。Kubernetes API 服务器不应该暴露在互联网或不信任的网络中。网络策略可以应用于 &lt;code&gt;kube-system&lt;/code&gt; 命名空间，以限制互联网对 &lt;code&gt;kube-system&lt;/code&gt; 的访问。如果对所有命名空间实施默认的拒绝策略，&lt;code&gt;kube-system&lt;/code&gt; 命名空间仍然必须能够与其他控制平面和工作节点进行通信。&lt;/p&gt;
&lt;p&gt;下表列出了控制平面的端口和服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 2：控制平面端口&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;端口&lt;/th&gt;
&lt;th&gt;方向&lt;/th&gt;
&lt;th&gt;端口范围&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;6443 or 8080 if not disabled&lt;/td&gt;
&lt;td&gt;Kubernetes API server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;2379-2380&lt;/td&gt;
&lt;td&gt;etcd server client API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;10250&lt;/td&gt;
&lt;td&gt;kubelet API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;10251&lt;/td&gt;
&lt;td&gt;kube-scheduler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;10252&lt;/td&gt;
&lt;td&gt;kube-controller-manager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;10258&lt;/td&gt;
&lt;td&gt;cloud-controller-manager（可选）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;etcd&#34;&gt;Etcd&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;etcd 后端数据库是一个关键的控制平面组件，也是集群中最重要的安全部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;etcd 后端数据库存储状态信息和集群 Secret。它是一个关键的控制平面组件，获得对 etcd 的写入权限可以使网络行为者获得对整个集群的 root 权限。Etcd 只能通过 API 服务器访问，集群的认证方法和 RBAC 策略可以限制用户。etcd 数据存储可以在一个单独的控制平面节点上运行，允许防火墙限制对 API 服务器的访问。管理员应该设置 TLS 证书以强制执行 etcd 服务器和 API 服务器之间的 HTTPS 通信。etcd 服务器应被配置为只信任分配给 API 服务器的证书。&lt;/p&gt;
&lt;h3 id=&#34;kubeconfig-文件&#34;&gt;Kubeconfig 文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kubeconfig&lt;/code&gt; 文件包含关于集群、用户、命名空间和认证机制的敏感信息。Kubectl 使用存储在工作节点的 &lt;code&gt;$HOME/.kube&lt;/code&gt; 目录下的配置文件，并控制平面本地机器。网络行为者可以利用对该配置目录的访问，获得并修改配置或凭证，从而进一步破坏集群。配置文件应该被保护起来，以防止非故意的改变，未经认证的非 root 用户应该被阻止访问这些文件。&lt;/p&gt;
&lt;h2 id=&#34;工作节点划分&#34;&gt;工作节点划分&lt;/h2&gt;
&lt;p&gt;工作节点可以是一个虚拟机或物理机，这取决于集群的实现。由于节点运行微服务并承载集群的网络应用，它们往往是被攻击的目标。如果一个节点被破坏，管理员应主动限制攻击面，将工作节点与其他不需要与工作节点或 Kubernetes 服务通信的网段分开。防火墙可用于将内部网段与面向外部的工作节点或整个 Kubernetes 服务分开，这取决于网络的情况。机密数据库或不需要互联网访问的内部服务，这可能需要与工作节点的可能攻击面分离。&lt;/p&gt;
&lt;p&gt;下表列出了工作节点的端口和服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 3：工作节点端口&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;端口&lt;/th&gt;
&lt;th&gt;方向&lt;/th&gt;
&lt;th&gt;端口范围&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;10250&lt;/td&gt;
&lt;td&gt;kubelet API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;Inbound&lt;/td&gt;
&lt;td&gt;30000-32767&lt;/td&gt;
&lt;td&gt;NodePort Services&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;加密&#34;&gt;加密&lt;/h2&gt;
&lt;p&gt;管理员应配置 Kubernetes 集群中的所有流量 —— 包括组件、节点和控制计划之间的流量（使用 TLS 1.2 或 1.3 加密）。&lt;/p&gt;
&lt;p&gt;加密可以在安装过程中设置，也可以在安装后使用 TLS 引导（详见 &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/&#34; title=&#34;Kubernetes 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档&lt;/a&gt;
）来创建并向节点分发证书。对于所有的方法，必须在节点之间分发证书，以便安全地进行通信。&lt;/p&gt;
&lt;h2 id=&#34;secret&#34;&gt;Secret&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况下，Secret 被存储为未加密的 base64 编码的字符串，并且可以被任何有 API 权限的人检索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kubernetes Secret 维护敏感信息，如密码、OAuth 令牌和 SSH 密钥。与在 YAML 文件、容器镜像或环境变量中存储密码或令牌相比，将敏感信息存储在 Secret 中提供了更大的访问控制。默认情况下，Kubernetes 将 Secret 存储为未加密的 base64 编码字符串，任何有 API 权限的人都可以检索到。可以通过对 &lt;strong&gt;secret&lt;/strong&gt; 资源应用 RBAC 策略来限制访问。&lt;/p&gt;
&lt;p&gt;可以通过在 API 服务器上配置静态数据加密或使用外部密钥管理服务（KMS）来对秘密进行加密，该服务可以通过云提供商提供。要启用使用 API 服务器的 Secret 数据静态加密，管理员应修改 &lt;code&gt;kube-apiserver&lt;/code&gt; 清单文件，以执行使用 &lt;code&gt;--encryption-provider-config&lt;/code&gt; 参数执行。&lt;a href=&#34;../appendix/h/&#34; title=&#34;附录 H&#34;&gt;附录 H&lt;/a&gt;
 中显示了一个 &lt;code&gt;encryption-provider-config&lt;/code&gt; 的例子：加密实例。使用 KMS 提供者可以防止原始加密密钥被存储在本地磁盘上。要用 KMS 提供者加密 Secret，&lt;code&gt;encryption-provider-config&lt;/code&gt; 文件中应指定 KMS 提供者，如&lt;a href=&#34;../appendix/i/&#34; title=&#34;附录 I&#34;&gt;附录 I&lt;/a&gt;
 的 KMS 配置示例所示。&lt;/p&gt;
&lt;p&gt;在应用了 &lt;code&gt;encryption-provider-config&lt;/code&gt; 文件后，管理员应该运行以下命令来读取和加密所有的 Secret。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get secrets --all-namespaces -o json &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; kubectl replace -f -
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;保护敏感的云基础设施&#34;&gt;保护敏感的云基础设施&lt;/h2&gt;
&lt;p&gt;Kubernetes 通常被部署在云环境中的虚拟机上。因此，管理员应该仔细考虑 Kubernetes 工作节点所运行的虚拟机的攻击面。在许多情况下，在这些虚拟机上运行的 Pod 可以在不可路由的地址上访问敏感的云元数据服务。这些元数据服务为网络行为者提供了关于云基础设施的信息，甚至可能是云资源的短期凭证。网络行为者滥用这些元数据服务进行特权升级。Kubernetes 管理员应通过使用网络策略或通过云配置策略防止 Pod 访问云元数据服务。由于这些服务根据云供应商的不同而不同，管理员应遵循供应商的指导来加固这些访问载体。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>容器存储接口（CSI）</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/csi/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/open-interfaces/csi/</guid>
      <description>
        
        
        &lt;p&gt;容器存储接口（Container Storage Interface），简称 CSI，CSI 试图建立一个行业标准接口的规范，借助 CSI 容器编排系统（CO）可以将任意存储系统暴露给自己的容器工作负载。有关详细信息，请查看设计方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csi&lt;/code&gt; 卷类型是一种 out-tree（即跟其它存储插件在同一个代码路径下，随 Kubernetes 的代码同时编译的）的 CSI 卷插件，用于 Pod 与在同一节点上运行的外部 CSI 卷驱动程序交互。部署 CSI 兼容卷驱动后，用户可以使用 &lt;code&gt;csi&lt;/code&gt; 作为卷类型来挂载驱动提供的存储。&lt;/p&gt;
&lt;p&gt;CSI 持久化卷支持是在 Kubernetes v1.9 中引入的，作为一个 alpha 特性，必须由集群管理员明确启用。换句话说，集群管理员需要在 apiserver、controller-manager 和 kubelet 组件的“&lt;code&gt;--feature-gates =&lt;/code&gt;”标志中加上“&lt;code&gt;CSIPersistentVolume = true&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;CSI 持久化卷具有以下字段可供用户指定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;driver&lt;/code&gt;：一个字符串值，指定要使用的卷驱动程序的名称。必须少于 63 个字符，并以一个字符开头。驱动程序名称可以包含“。”、“ - ”、“_”或数字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volumeHandle&lt;/code&gt;：一个字符串值，唯一标识从 CSI 卷插件的 &lt;code&gt;CreateVolume&lt;/code&gt; 调用返回的卷名。随后在卷驱动程序的所有后续调用中使用卷句柄来引用该卷。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readOnly&lt;/code&gt;：一个可选的布尔值，指示卷是否被发布为只读。默认是 false。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用说明&#34;&gt;使用说明&lt;/h2&gt;
&lt;p&gt;下面将介绍如何使用 CSI。&lt;/p&gt;
&lt;h3 id=&#34;动态配置&#34;&gt;动态配置&lt;/h3&gt;
&lt;p&gt;可以通过为 CSI 创建插件 &lt;code&gt;StorageClass&lt;/code&gt; 来支持动态配置的 CSI Storage 插件启用自动创建/删除。&lt;/p&gt;
&lt;p&gt;例如，以下 &lt;code&gt;StorageClass&lt;/code&gt; 允许通过名为 &lt;code&gt;com.example.team/csi-driver&lt;/code&gt; 的 CSI Volume Plugin 动态创建“fast-storage”Volume。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;StorageClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;storage.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fast-storage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;provisioner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;com.example.team/csi-driver&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;pd-ssd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要触发动态配置，请创建一个 &lt;code&gt;PersistentVolumeClaim&lt;/code&gt; 对象。例如，下面的 PersistentVolumeClaim 可以使用上面的 StorageClass 触发动态配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PersistentVolumeClaim&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-request-for-storage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessModes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ReadWriteOnce&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storageClassName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fast-storage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当动态创建 Volume 时，通过 CreateVolume 调用，将参数 &lt;code&gt;type：pd-ssd&lt;/code&gt; 传递给 CSI 插件 &lt;code&gt;com.example.team/csi-driver&lt;/code&gt; 。作为响应，外部 Volume 插件会创建一个新 Volume，然后自动创建一个 &lt;code&gt;PersistentVolume&lt;/code&gt; 对象来对应前面的 PVC。然后，Kubernetes 会将新的 &lt;code&gt;PersistentVolume&lt;/code&gt; 对象绑定到 &lt;code&gt;PersistentVolumeClaim&lt;/code&gt;，使其可以使用。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;fast-storage&lt;/code&gt; StorageClass 被标记为默认值，则不需要在 &lt;code&gt;PersistentVolumeClaim&lt;/code&gt; 中包含 StorageClassName，它将被默认使用。&lt;/p&gt;
&lt;h3 id=&#34;预配置-volume&#34;&gt;预配置 Volume&lt;/h3&gt;
&lt;p&gt;您可以通过手动创建一个 &lt;code&gt;PersistentVolume&lt;/code&gt; 对象来展示现有 Volumes，从而在 Kubernetes 中暴露预先存在的 Volume。例如，暴露属于 &lt;code&gt;com.example.team/csi-driver&lt;/code&gt; 这个 CSI 插件的 &lt;code&gt;existingVolumeName Volume&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PersistentVolume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-manually-created-pv&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessModes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ReadWriteOnce&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;persistentVolumeReclaimPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Retain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;csi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;driver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;com.example.team/csi-driver&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;existingVolumeName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;附着和挂载&#34;&gt;附着和挂载&lt;/h3&gt;
&lt;p&gt;您可以在任何的 pod 或者 pod 的 template 中引用绑定到 CSI volume 上的 &lt;code&gt;PersistentVolumeClaim&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-frontend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;dockerfile/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/www/html&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-csi-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-csi-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;persistentVolumeClaim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;claimName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-request-for-storage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当一个引用了 CSI Volume 的 pod 被调度时，Kubernetes 将针对外部 CSI 插件进行相应的操作，以确保特定的 Volume 被 attached、mounted，并且能被 pod 中的容器使用。&lt;/p&gt;
&lt;p&gt;关于 CSI 实现的详细信息请参考设计文档。&lt;/p&gt;
&lt;h2 id=&#34;创建-csi-驱动&#34;&gt;创建 CSI 驱动&lt;/h2&gt;
&lt;p&gt;Kubernetes 尽可能少地指定 CSI Volume 驱动程序的打包和部署规范。&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#third-party-csi-volume-drivers&#34; title=&#34;这里&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;
记录了在 Kubernetes 上部署 CSI Volume 驱动程序的最低要求。&lt;/p&gt;
&lt;p&gt;最低要求文件还包含&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes&#34; title=&#34;概述部分&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;概述部分&lt;/a&gt;
，提供了在 Kubernetes 上部署任意容器化 CSI 驱动程序的建议机制。存储提供商可以运用这个机制来简化 Kubernetes 上容器式 CSI 兼容 Volume 驱动程序的部署。&lt;/p&gt;
&lt;p&gt;作为推荐部署的一部分，Kubernetes 团队提供以下 sidecar（辅助）容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-csi/external-attacher&#34; title=&#34;External-attacher&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;External-attacher&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;可监听 Kubernetes VolumeAttachment 对象并触发 ControllerPublish 和 ControllerUnPublish 操作的 sidecar 容器，通过 CSI endpoint 触发；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-csi/external-provisioner&#34; title=&#34;External-provisioner&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;External-provisioner&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;监听 Kubernetes PersistentVolumeClaim 对象的 sidecar 容器，并触发对 CSI 端点的 CreateVolume 和 DeleteVolume 操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-csi/driver-registrar&#34; title=&#34;Driver-registrar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Driver-registrar&lt;/a&gt;
(DEPRECATED)&lt;/p&gt;
&lt;p&gt;使用 Kubelet（将来）注册 CSI 驱动程序的 sidecar 容器，并将 &lt;code&gt;NodeId&lt;/code&gt; （通过 &lt;code&gt;GetNodeID&lt;/code&gt; 调用检索到 CSI endpoint）添加到 Kubernetes Node API 对象的 annotation 里面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-csi/cluster-driver-registrar&#34; title=&#34;Cluster Driver Registrar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cluster Driver Registrar&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;创建 CSIDriver 这个集群范围的 CRD 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-csi/node-driver-registrar&#34; title=&#34;Node Driver Registrar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Node Driver Registrar&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;替代 Driver-registrar。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储供应商完全可以使用这些组件来为其插件构建 Kubernetes Deployment，同时让它们的 CSI 驱动程序完全意识不到 Kubernetes 的存在。&lt;/p&gt;
&lt;p&gt;另外 CSI 驱动完全是由第三方存储供应商自己维护的，在 kubernetes 1.9 版本中 CSI 还处于 alpha 版本。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/container-storage-interface/spec/blob/master/spec.md&#34; title=&#34;Container Storage Interface (CSI) - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Storage Interface (CSI) - github.com&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>认证和授权</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/authentication-and-authorization/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/authentication-and-authorization/</guid>
      <description>
        
        
        &lt;p&gt;认证和授权是限制访问集群资源的主要机制。如果集群配置错误，网络行为者可以扫描知名的 Kubernetes 端口，访问集群的数据库或进行 API 调用，而不需要经过认证。用户认证不是 Kubernetes 的一个内置功能。然而，有几种方法可以让管理员在集群中添加认证。&lt;/p&gt;
&lt;h2 id=&#34;认证&#34;&gt;认证&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;管理员必须向集群添加一个认证方法，以实现认证和授权机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kubernetes 集群有两种类型的用户：服务账户和普通用户账户。服务账户代表 Pod 处理 API 请求。认证通常由 Kubernetes 通过 ServiceAccount Admission Controller 使用承载令牌自动管理。不记名令牌被安装到 Pod 中约定俗成的位置，如果令牌不安全，可能会在集群外使用。正因为如此，对 Pod Secret 的访问应该限制在那些需要使用 Kubernetes RBAC 查看的人身上。对于普通用户和管理员账户，没有自动的用户认证方法。管理员必须在集群中添加一个认证方法，以实现认证和授权机制。&lt;/p&gt;
&lt;p&gt;Kubernetes 假设由一个独立于集群的服务来管理用户认证。&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication&#34; title=&#34;Kubernetes 文档中&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档中&lt;/a&gt;
列出了几种实现用户认证的方法，包括客户端证书、承载令牌、认证插件和其他认证协议。至少应该实现一种用户认证方法。当实施多种认证方法时，第一个成功认证请求的模块会缩短评估的时间。管理员不应使用静态密码文件等弱方法。薄弱的认证方法可能允许网络行为者冒充合法用户进行认证。&lt;/p&gt;
&lt;p&gt;匿名请求是被其他配置的认证方法拒绝的请求，并且不与任何个人用户或 Pod 相联系。在一个设置了令牌认证并启用了匿名请求的服务器中，没有令牌的请求将作为匿名请求执行。在 Kubernetes 1.6 和更新的版本中，匿名请求是默认启用的。当启用 RBAC 时，匿名请求需要 &lt;code&gt; system:anonymous&lt;/code&gt; 用户或 &lt;code&gt;system:unauthenticated&lt;/code&gt; 组的明确授权。匿名请求应该通过向 API 服务器传递 &lt;code&gt;--anonymous-auth=false&lt;/code&gt; 选项来禁用。启用匿名请求可能会允许网络行为者在没有认证的情况下访问集群资源。&lt;/p&gt;
&lt;h2 id=&#34;基于角色的访问控制&#34;&gt;基于角色的访问控制&lt;/h2&gt;
&lt;p&gt;RBAC 是根据组织内个人的角色来控制集群资源访问的一种方法。在 Kubernetes 1.6 和更新的版本中，RBAC 是默认启用的。要使用 kubectl 检查集群中是否启用了 RBAC，执行 &lt;code&gt;kubectl api-version&lt;/code&gt;。如果启用，应该列出&lt;code&gt;rbac.authorization.k8s.io/v1&lt;/code&gt; 的 API 版本。云 Kubernetes 服务可能有不同的方式来检查集群是否启用了 RBAC。如果没有启用 RBAC，在下面的命令中用 &lt;code&gt;--authorization-mode&lt;/code&gt; 标志启动 API 服务器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kube-apiserver --authorization-mode&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;RBAC
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;留下授权模式标志，如 &lt;code&gt;AlwaysAllow&lt;/code&gt;，允许所有的授权请求，有效地禁用所有的授权，限制了执行最小权限的访问能力。&lt;/p&gt;
&lt;p&gt;可以设置两种类型的权限：&lt;code&gt;Roles&lt;/code&gt; 和 &lt;code&gt;ClusterRoles&lt;/code&gt;。&lt;code&gt;Roles&lt;/code&gt; 为特定命名空间设置权限，而 &lt;code&gt;ClusterRoles&lt;/code&gt; 则为所有集群资源设置权限，而不考虑命名空间。&lt;code&gt;Roles&lt;/code&gt; 和 &lt;code&gt;ClusterRoles&lt;/code&gt; 只能用于添加权限。没有拒绝规则。如果一个集群被配置为使用 RBAC，并且匿名访问被禁用，Kubernetes API 服务器将拒绝没有明确允许的权限。&lt;a href=&#34;../appendix/j/&#34; title=&#34;&amp;lt;strong&amp;gt;附录&amp;lt;/strong&amp;gt; J&#34;&gt;&lt;strong&gt;附录&lt;/strong&gt; J&lt;/a&gt;
 中显示了一个 RBAC 角色的例子：&lt;code&gt;pod-reader&lt;/code&gt; RBAC 角色。&lt;/p&gt;
&lt;p&gt;一个 &lt;code&gt;Role&lt;/code&gt; 或 &lt;code&gt;ClusterRole&lt;/code&gt; 定义了一个权限，但并没有将该权限与一个用户绑定。&lt;code&gt;RoleBindings&lt;/code&gt; 和 &lt;code&gt;ClusterRoleBindings&lt;/code&gt; 用于将一个 &lt;code&gt;Roles&lt;/code&gt; 或 &lt;code&gt;ClusterRoles&lt;/code&gt; 与一个用户、组或服务账户联系起来。角色绑定将角色或集群角色的权限授予定义的命名空间中的用户、组或服务账户。&lt;code&gt;ClusterRoles&lt;/code&gt; 是独立于命名空间而创建的，然后可以使用 &lt;code&gt;RoleBinding&lt;/code&gt; 来限制命名空间的范围授予个人。&lt;code&gt;ClusterRoleBindings&lt;/code&gt; 授予用户、群组或服务账户跨所有集群资源的 &lt;code&gt;ClusterRoles&lt;/code&gt;。RBAC &lt;code&gt;RoleBinding&lt;/code&gt; 和 &lt;code&gt;ClusterRoleBinding&lt;/code&gt; 的例子在&lt;a href=&#34;../appendix/k/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 K：RBAC &amp;lt;code&amp;gt;RoleBinding&amp;lt;/code&amp;gt; 和 &amp;lt;code&amp;gt;ClusterRoleBinding&amp;lt;/code&amp;gt; 示例&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 K：RBAC &lt;code&gt;RoleBinding&lt;/code&gt; 和 &lt;code&gt;ClusterRoleBinding&lt;/code&gt; 示例&lt;/strong&gt;&lt;/a&gt;
中。&lt;/p&gt;
&lt;p&gt;要创建或更新 &lt;code&gt;Roles&lt;/code&gt; 和 &lt;code&gt;ClusterRoles&lt;/code&gt;，用户必须在同一范围内拥有新角色所包含的权限，或者拥有对 &lt;code&gt;rbac.authorization.k8s.io&lt;/code&gt; API 组中的 &lt;code&gt;Roles&lt;/code&gt; 或 &lt;code&gt;ClusterRoles&lt;/code&gt; 资源执行升级动词的明确权限。创建绑定后，&lt;code&gt;Roles&lt;/code&gt; 或 &lt;code&gt;ClusterRoles&lt;/code&gt; 是不可改变的。要改变一个角色，必须删除该绑定。&lt;/p&gt;
&lt;p&gt;分配给用户、组和服务账户的权限应该遵循最小权限原则，只给资源以必要的权限。用户或用户组可以被限制在所需资源所在的特定命名空间。默认情况下，为每个命名空间创建一个服务账户，以便 Pod 访问 Kubernetes API。可以使用 RBAC 策略来指定每个命名空间的服务账户的允许操作。对 Kubernetes API 的访问是通过创建 RBAC 角色或 &lt;code&gt;ClusterRoles&lt;/code&gt; 来限制的，该角色具有适当的 API 请求动词和所需的资源，该行动可以应用于此。有一些工具可以通过打印用户、组和服务账户及其相关分配的 &lt;code&gt;Roles&lt;/code&gt; 和 &lt;code&gt;ClusterRoles&lt;/code&gt; 来帮助审计 RBAC 策略。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes 中的资源对象</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/</guid>
      <description>
        
        
        &lt;p&gt;以下列举的内容都是 Kubernetes 中的对象（Object），这些对象都可以在 YAML 文件中作为一种 API 类型来配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod&lt;/li&gt;
&lt;li&gt;Node&lt;/li&gt;
&lt;li&gt;Namespace&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Volume&lt;/li&gt;
&lt;li&gt;PersistentVolume&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;Secret&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;li&gt;DaemonSet&lt;/li&gt;
&lt;li&gt;ServiceAccount&lt;/li&gt;
&lt;li&gt;ReplicationController&lt;/li&gt;
&lt;li&gt;ReplicaSet&lt;/li&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;li&gt;CronJob&lt;/li&gt;
&lt;li&gt;SecurityContext&lt;/li&gt;
&lt;li&gt;ResourceQuota&lt;/li&gt;
&lt;li&gt;LimitRange&lt;/li&gt;
&lt;li&gt;HorizontalPodAutoscaling&lt;/li&gt;
&lt;li&gt;Ingress&lt;/li&gt;
&lt;li&gt;ConfigMap&lt;/li&gt;
&lt;li&gt;Label&lt;/li&gt;
&lt;li&gt;CustomResourceDefinition&lt;/li&gt;
&lt;li&gt;Role&lt;/li&gt;
&lt;li&gt;ClusterRole&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我将它们简单的分类为以下几种资源对象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类别&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源对象&lt;/td&gt;
&lt;td&gt;Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存储对象&lt;/td&gt;
&lt;td&gt;Volume、PersistentVolume、Secret、ConfigMap&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;策略对象&lt;/td&gt;
&lt;td&gt;SecurityContext、ResourceQuota、LimitRange&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;身份对象&lt;/td&gt;
&lt;td&gt;ServiceAccount、Role、ClusterRole&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;理解-kubernetes-中的对象&#34;&gt;理解 Kubernetes 中的对象&lt;/h2&gt;
&lt;p&gt;在 Kubernetes 系统中，&lt;em&gt;Kubernetes 对象&lt;/em&gt; 是持久化的条目。Kubernetes 使用这些条目去表示整个集群的状态。特别地，它们描述了如下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么容器化应用在运行（以及在哪个 Node 上）&lt;/li&gt;
&lt;li&gt;可以被应用使用的资源&lt;/li&gt;
&lt;li&gt;关于应用如何表现的策略，比如重启策略、升级策略，以及容错策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 对象是“目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，可以有效地告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 &lt;strong&gt;期望状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与 Kubernetes 对象工作 —— 是否创建、修改，或者删除 —— 需要使用 Kubernetes API。当使用 &lt;code&gt;kubectl&lt;/code&gt; 命令行接口时，比如，CLI 会使用必要的 Kubernetes API 调用，也可以在程序中直接使用 Kubernetes API。为了实现该目标，Kubernetes 当前提供了一个 &lt;code&gt;golang&lt;/code&gt; &lt;a href=&#34;https://github.com/kubernetes/client-go&#34; title=&#34;客户端库&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;客户端库&lt;/a&gt;
 ，其它语言库（例如&lt;a href=&#34;https://github.com/kubernetes-incubator/client-python&#34; title=&#34;Python&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python&lt;/a&gt;
）也正在开发中。&lt;/p&gt;
&lt;h3 id=&#34;对象-spec-与状态&#34;&gt;对象 Spec 与状态&lt;/h3&gt;
&lt;p&gt;每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 &lt;em&gt;spec&lt;/em&gt; 和 对象 &lt;em&gt;status&lt;/em&gt;。&lt;em&gt;spec&lt;/em&gt; 必须提供，它描述了对象的 &lt;em&gt;期望状态&lt;/em&gt;—— 希望对象所具有的特征。&lt;em&gt;status&lt;/em&gt; 描述了对象的 &lt;em&gt;实际状态&lt;/em&gt;，它是由 Kubernetes 系统提供和更新。在任何时刻，Kubernetes 控制平面一直处于活跃状态，管理着对象的实际状态以与我们所期望的状态相匹配。&lt;/p&gt;
&lt;p&gt;例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。当创建 Deployment 时，可能需要设置 Deployment 的 spec，以指定该应用需要有 3 个副本在运行。Kubernetes 系统读取 Deployment spec，启动我们所期望的该应用的 3 个实例 —— 更新状态以与 spec 相匹配。如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应 spec 和状态之间的不一致 —— 这种情况，启动一个新的实例来替换。&lt;/p&gt;
&lt;p&gt;关于对象 spec、status 和 metadata 更多信息，查看 &lt;a href=&#34;https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md&#34; title=&#34;Kubernetes API Conventions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API Conventions&lt;/a&gt;
。&lt;/p&gt;
&lt;h3 id=&#34;描述-kubernetes-对象&#34;&gt;描述 Kubernetes 对象&lt;/h3&gt;
&lt;p&gt;当创建 Kubernetes 对象时，必须提供对象的 spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如，名称）。当使用 Kubernetes API 创建对象时（或者直接创建，或者基于&lt;code&gt;kubectl&lt;/code&gt;），API 请求必须在请求体中包含 JSON 格式的信息。&lt;strong&gt;更常用的是，需要在 .yaml 文件中为 kubectl 提供这些信息&lt;/strong&gt;。 &lt;code&gt;kubectl&lt;/code&gt; 在执行 API 请求时，将这些信息转换成 JSON 格式。&lt;/p&gt;
&lt;p&gt;这里有一个 &lt;code&gt;.yaml&lt;/code&gt; 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx-deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:1.7.9&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一种创建 Deployment 的方式，类似上面使用 &lt;code&gt;.yaml&lt;/code&gt; 文件，是使用 &lt;code&gt;kubectl&lt;/code&gt; 命令行接口（CLI）中的 &lt;code&gt;kubectl create&lt;/code&gt; 命令，传递 &lt;code&gt;.yaml&lt;/code&gt; 作为参数。下面是一个示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create -f docs/user-guide/nginx-deployment.yaml --record
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出类似如下这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment &lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx-deployment&amp;#34;&lt;/span&gt; created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;必需字段&#34;&gt;必需字段&lt;/h3&gt;
&lt;p&gt;在想要创建的 Kubernetes 对象对应的 &lt;code&gt;.yaml&lt;/code&gt; 文件中，需要配置如下的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apiVersion&lt;/code&gt; - 创建该对象所使用的 Kubernetes API 的版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kind&lt;/code&gt; - 想要创建的对象的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;metadata&lt;/code&gt; - 帮助识别对象唯一性的数据，包括一个 &lt;code&gt;name&lt;/code&gt; 字符串、UID 和可选的 &lt;code&gt;namespace&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也需要提供对象的 &lt;code&gt;spec&lt;/code&gt; 字段。对象 &lt;code&gt;spec&lt;/code&gt; 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。&lt;a href=&#34;https://kubernetes.io/docs/api/&#34; title=&#34;Kubernetes API 参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API 参考&lt;/a&gt;
能够帮助我们找到任何我们想创建的对象的 spec 格式。&lt;/p&gt;
&lt;h2 id=&#34;本节大纲&#34;&gt;本节大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-overview/&#34;&gt;Pod 概览&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod/&#34;&gt;Pod 解析&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/init-containers/&#34;&gt;Init 容器&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pause-container/&#34;&gt;Pause 容器&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-security-policy/&#34;&gt;Pod 安全策略&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-lifecycle/&#34;&gt;Pod 的生命周期&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-hook/&#34;&gt;Pod Hook&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-preset/&#34;&gt;Pod Preset&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-disruption-budget/&#34;&gt;Pod 中断与 PDB（Pod 中断预算）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
    
    <item>
      <title>日志审计</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/logging/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/logging/</guid>
      <description>
        
        
        &lt;p&gt;日志记录了集群中的活动。审计日志是必要的，这不仅是为了确保服务按预期运行和配置，也是为了确保系统的安全。系统性的审计要求对安全设置进行一致和彻底的检查，以帮助识别潜在威胁。Kubernetes 能够捕获集群操作的审计日志，并监控基本的 CPU 和内存使用信息；然而，它并没有提供深入的监控或警报服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在创建时建立 Pod 基线，以便能够识别异常活动。&lt;/li&gt;
&lt;li&gt;在主机层面、应用层面和云端（如果适用）进行日志记录。&lt;/li&gt;
&lt;li&gt;整合现有的网络安全工具，进行综合扫描、监控、警报和分析。&lt;/li&gt;
&lt;li&gt;设置本地日志存储，以防止在通信失败的情况下丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;在 Kubernetes 中运行应用程序的系统管理员应该为其环境建立一个有效的日志、监控和警报系统。仅仅记录 Kubernetes 事件还不足以了解系统上发生的行动的全貌。还应在主机级、应用级和云上（如果适用）进行日志记录。而且，这些日志可以与任何外部认证和系统日志相关联，以提供整个环境所采取的行动的完整视图，供安全审计员和事件响应者使用。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 环境中，管理员应监控 / 记录以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 请求历史&lt;/li&gt;
&lt;li&gt;性能指标&lt;/li&gt;
&lt;li&gt;部署情况&lt;/li&gt;
&lt;li&gt;资源消耗&lt;/li&gt;
&lt;li&gt;操作系统调用&lt;/li&gt;
&lt;li&gt;协议、权限变化&lt;/li&gt;
&lt;li&gt;网络流量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个 Pod 被创建或更新时，管理员应该捕获网络通信、响应时间、请求、资源消耗和任何其他相关指标的详细日志以建立一个基线。正如上一节所详述的，匿名账户应被禁用，但日志策略仍应记录匿名账户采取的行动，以确定异常活动。&lt;/p&gt;
&lt;p&gt;应定期审计 RBAC 策略配置，并在组织的系统管理员发生变化时进行审计。这样做可以确保访问控制的调整符合基于角色的访问控制部分中概述的 RBAC 策略加固指导。&lt;/p&gt;
&lt;p&gt;审计应包括将当前日志与正常活动的基线测量进行比较，以确定任何日志指标和事件的重大变化。系统管理员应调查重大变动——例如，应用程序使用的变化或恶意程序的安装，如密码器，以确定根本原因。应该对内部和外部流量日志进行审计，以确保对连接的所有预期的安全限制已被正确配置，并按预期运行。管理员还可以在系统发展过程中使用这些审计，以确定何时不再需要外部访问并可以限制。&lt;/p&gt;
&lt;p&gt;日志可以导向外部日志服务，以确保集群外的安全专业人员的可用使用它们，尽可能接近实时地识别异常情况，并在发生损害时保护日志不被删除。如果使用这种方法，日志应该在传输过程中用 TLS 1.2 或 1.3 进行加密，以确保网络行为者无法在传输过程中访问日志并获得关于环境的宝贵信息。在利用外部日志服务器时，要采取的另一项预防措施是在 Kubernetes 内配置日志转发器，只对外部存储进行追加访问。这有助于保护外部存储的日志不被删除或被集群内日志覆盖。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-原生审计日志配置&#34;&gt;Kubernetes 原生审计日志配置&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes 的审计功能默认是禁用的，所以如果没有写审计策略，就不会有任何记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 驻留在 Kubernetes 控制平面上，作为前端，处理集群的内部和外部请求。每个请求，无论是由用户、应用程序还是控制平面产生的，在其执行的每个阶段都会产生一个审计事件。当审计事件注册时，&lt;code&gt;kube-apiserver&lt;/code&gt; 检查审计策略文件和适用规则。如果存在这样的规则，服务器会在第一个匹配的规则所定义的级别上记录该事件。Kubernetes 的内置审计功能默认是不启用的，所以如果没有写审计策略，就不会有任何记录。&lt;/p&gt;
&lt;p&gt;集群管理员必须写一个审计策略 YAML 文件，以建立规则，并指定所需的审计级别，以记录每种类型的审计事件。然后，这个审计策略文件被传递给 &lt;code&gt;kube-apiserver&lt;/code&gt;，并加上适当的标志。一个规则要被认为是有效的，必须指定四个审计级别中的一个：&lt;code&gt;none&lt;/code&gt;、&lt;code&gt;Meatadataa&lt;/code&gt;、&lt;code&gt;Request&lt;/code&gt; 或 &lt;code&gt;RequestResponse&lt;/code&gt;。&lt;a href=&#34;../appendix/l/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 L：审计策略&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 L：审计策略&lt;/strong&gt;&lt;/a&gt;
展示了一个审计策略文件的内容，该文件记录了 &lt;code&gt;RequestResponse&lt;/code&gt; 级别的所有事件。&lt;a href=&#34;../appendix/m/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 M&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 M&lt;/strong&gt;&lt;/a&gt;
 向 &lt;code&gt;kube-apiserver&lt;/code&gt; 提交审计策略文件的标志示例显示了 &lt;code&gt;kube-apiserver&lt;/code&gt; 配置文件的位置，并提供了审计策略文件可以被传递给 &lt;code&gt;kube-apiserver&lt;/code&gt; 的标志示例。附录 M 还提供了如何挂载卷和在必要时配置主机路径的指导。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 包括可配置的日志和 webhook 后端，用于审计日志。日志后端将指定的审计事件写入日志文件，webhook 后端可以被配置为将文件发送到外部 HTTP API。附录 M 中的例子中设置的 &lt;code&gt;--audit-log-path&lt;/code&gt; 和 &lt;code&gt;--audit-log-maxage&lt;/code&gt; 标志是可以用来配置日志后端的两个例子，它将审计事件写到一个文件中。&lt;code&gt;log-path&lt;/code&gt; 标志是启用日志的最小配置，也是日志后端唯一需要的配置。这些日志文件的默认格式是 JSON，尽管必要时也可以改变。日志后端的其他配置选项可以在 Kubernetes 文档中找到。&lt;/p&gt;
&lt;p&gt;为了将审计日志推送给组织的 SIEM 平台，可以通过提交给 &lt;code&gt;kube-apiserver&lt;/code&gt; 的 YAML 文件手动配置 webhook 后端。webhook 配置文件以及如何将该文件传递给 &lt;code&gt;kube-apiserver&lt;/code&gt; 可以在&lt;a href=&#34;../appendix/n/&#34; title=&#34;&amp;lt;strong&amp;gt;附录 N：webhook 配置&amp;lt;/strong&amp;gt;&#34;&gt;&lt;strong&gt;附录 N：webhook 配置&lt;/strong&gt;&lt;/a&gt;
的示例中查看。关于如何在 &lt;code&gt;kube-apiserver&lt;/code&gt; 中为 webhook 后端设置的配置选项的详尽列表，可以在 Kubernetes 文档中找到。&lt;/p&gt;
&lt;h3 id=&#34;工作节点和容器的日志记录&#34;&gt;工作节点和容器的日志记录&lt;/h3&gt;
&lt;p&gt;在 Kubernetes 架构中，有很多方法可以配置日志功能。在日志管理的内置方法中，每个节点上的 kubelet 负责管理日志。它根据其对单个文件长度、存储时间和存储容量的策略，在本地存储和轮转日志文件。这些日志是由 kubelet 控制的，可以从命令行访问。下面的命令打印了一个 Pod 中的容器的日志。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl logs &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-f&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-p&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; POD &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-c CONTAINER&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果要对日志进行流式处理，可以使用 &lt;code&gt;-f&lt;/code&gt; 标志；如果存在并需要来自容器先前实例的日志，可以使用 &lt;code&gt;-p&lt;/code&gt; 标志；如果 Pod 中有多个容器，可以使用 &lt;code&gt;-c&lt;/code&gt; 标志来指定一个容器。如果发生错误导致容器、Pod 或节点死亡，Kubernetes 中的本地日志解决方案并没有提供一种方法来保存存储在失败对象中的日志。NSA 和 CISA 建议配置一个远程日志解决方案，以便在一个节点失败时保存日志。&lt;/p&gt;
&lt;p&gt;远程记录的选项包括：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;远程日志选项&lt;/th&gt;
&lt;th&gt;使用的理由&lt;/th&gt;
&lt;th&gt;配置实施&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在每个节点上运行一个日志代理，将日志推送到后端&lt;/td&gt;
&lt;td&gt;赋予节点暴露日志或将日志推送到后端的能力，在发生故障的情况下将其保存在节点之外。&lt;/td&gt;
&lt;td&gt;配置一个 Pod 中的独立容器作为日志代理运行，让它访问节点的应用日志文件，并配置它将日志转发到组织的 SIEM。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每个 Pod 中使用一个 sidecar 容器，将日志推送到一个输出流中&lt;/td&gt;
&lt;td&gt;用于将日志推送到独立的输出流。当应用程序容器写入不同格式的多个日志文件时，这可能是一个有用的选项。&lt;/td&gt;
&lt;td&gt;为每种日志类型配置 sidecar 容器，并用于将这些日志文件重定向到它们各自的输出流，在那里它们可以被 kubelet 处理。然后，节点级的日志代理可以将这些日志转发给 SIEM 或其他后端。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在每个 Pod 中使用一个日志代理 sidecar，将日志推送到后端&lt;/td&gt;
&lt;td&gt;当需要比节点级日志代理所能提供的更多灵活性时。&lt;/td&gt;
&lt;td&gt;为每个 Pod 配置，将日志直接推送到后端。这是连接第三方日志代理和后端的常用方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从应用程序中直接向后端推送日志&lt;/td&gt;
&lt;td&gt;捕获应用程序的日志。Kubernetes 没有内置的机制直接来暴露或推送日志到后端。&lt;/td&gt;
&lt;td&gt;各组织将需要在其应用程序中建立这一功能，或附加一个有信誉的第三方工具来实现这一功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Sidecar 容器与其他容器一起在 Pod 中运行，可以被配置为将日志流向日志文件或日志后端。Sidecar 容器也可以被配置为作为另一个标准功能容器的流量代理，它被打包和部署。&lt;/p&gt;
&lt;p&gt;为了确保这些日志代理在工作节点之间的连续性，通常将它们作为 DaemonSet 运行。为这种方法配置 DaemonSet，可以确保每个节点上都有一份日志代理的副本，而且对日志代理所做的任何改变在集群中都是一致的。&lt;/p&gt;
&lt;h3 id=&#34;seccomp-审计模式&#34;&gt;Seccomp: 审计模式&lt;/h3&gt;
&lt;p&gt;除了上述的节点和容器日志外，记录系统调用也是非常有益的。在 Kubernetes 中审计容器系统调用的一种方法是使用安全计算模式（seccomp）工具。这个工具默认是禁用的，但可以用来限制容器的系统调用能力，从而降低内核的攻击面。Seccomp 还可以通过使用审计配置文件记录正在进行的调用。&lt;/p&gt;
&lt;p&gt;自定义 seccomp 配置文件用于定义哪些系统调用是允许的，以及未指定调用的默认动作。为了在 Pod 中启用自定义 seccomp 配置文件，Kubernetes 管理员可以将他们的 seccomp 配置文件 JSON 文件写入到 &lt;code&gt;/var/lib/kubelet/seccomp/&lt;/code&gt; 目录，并将 &lt;code&gt;seccompProfile&lt;/code&gt; 添加到 Pod 的 &lt;code&gt;securityContext&lt;/code&gt;。自定义的 &lt;code&gt;seccompProfile&lt;/code&gt; 还应该包括两个字段。&lt;code&gt;Type: Localhost&lt;/code&gt; 和 &lt;code&gt;localhostProfile: myseccomppolicy.json&lt;/code&gt;。记录所有的系统调用可以帮助管理员了解标准操作需要哪些系统调用，使他们能够进一步限制 seccomp 配置文件而不失去系统功能。&lt;/p&gt;
&lt;h3 id=&#34;syslog&#34;&gt;SYSLOG&lt;/h3&gt;
&lt;p&gt;Kubernetes 默认将 kubelet 日志和容器运行时日志写入 journald，如果该服务可用的话。如果组织希望对默认情况下不使用的系统使用 syslog 工具，或者从整个集群收集日志并将其转发到 syslog 服务器或其他日志存储和聚合平台，他们可以手动配置该功能。Syslog 协议定义了一个日志信息格式化标准。Syslog 消息包括一个头——由时间戳、主机名、应用程序名称和进程 ID（PID）组成，以及一个以明文书写的消息。Syslog 服务，如 syslog-ng® 和 rsyslog，能够以统一的格式收集和汇总整个系统的日志。许多 Linux 操作系统默认使用 rsyslog 或 journald——一个事件日志守护程序，它优化了日志存储并通过 journalctl 输出 syslog 格式的日志。在运行某些 Linux 发行版的节点上，syslog 工具默认在操作系统层面记录事件。运行这些 Linux 发行版的容器，默认也会使用 syslog 收集日志。由 syslog 工具收集的日志存储在每个适用的节点或容器的本地文件系统中，除非配置了一个日志聚合平台来收集它们。&lt;/p&gt;
&lt;h2 id=&#34;siem-平台&#34;&gt;SIEM 平台&lt;/h2&gt;
&lt;p&gt;安全信息和事件管理（SIEM）软件从整个组织的网络中收集日志。SIEM 软件将防火墙日志、应用程序日志等汇集在一起；将它们解析出来，提供一个集中的平台，分析人员可以从这个平台上监控系统安全。SIEM 工具在功能上有差异。一般来说，这些平台提供日志收集、威胁检测和警报功能。有些包括机器学习功能，可以更好地预测系统行为并帮助减少错误警报。在其环境中使用这些平台的组织可以将它们与 Kubernetes 集成，以更好地监测和保护集群。用于管理 Kubernetes 环境中的日志的开源平台是作为 SIEM 平台的替代品存在的。&lt;/p&gt;
&lt;p&gt;容器化环境在节点、Pod、容器和服务之间有许多相互依赖的关系。在这些环境中，Pod 和容器不断地在不同的节点上被关闭和重启。这给传统的 SIEM 带来了额外的挑战，它们通常使用 IP 地址来关联日志。即使是下一代的 SIEM 平台也不一定适合复杂的 Kubernetes 环境。然而，随着 Kubernetes 成为最广泛使用的容器编排平台，许多开发 SIEM 工具的组织已经开发了专门用于 Kubernetes 环境的产品变化，为这些容器化环境提供全面的监控解决方案。管理员应该了解他们平台的能力，并确保他们的日志充分捕捉到环境，以支持未来的事件响应。&lt;/p&gt;
&lt;h2 id=&#34;警报&#34;&gt;警报&lt;/h2&gt;
&lt;p&gt;Kubernetes 本身并不支持警报功能；然而，一些具有警报功能的监控工具与 Kubernetes 兼容。如果 Kubernetes 管理员选择配置一个警报工具在 Kubernetes 环境中工作，有几个指标是管理员应该监控和配置警报的。&lt;/p&gt;
&lt;p&gt;可能触发警报的案例包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境中的任何机器上的磁盘空间都很低。&lt;/li&gt;
&lt;li&gt;记录卷上的可用存储空间正在减少。&lt;/li&gt;
&lt;li&gt;外部日志服务脱机。&lt;/li&gt;
&lt;li&gt;一个以 root 权限运行的 Pod 或应用程序。&lt;/li&gt;
&lt;li&gt;一个账户对他们没有权限的资源提出的请求。&lt;/li&gt;
&lt;li&gt;一个正在使用或获得特权的匿名账户。&lt;/li&gt;
&lt;li&gt;Pod 或工作节点的 IP 地址被列为 Pod 创建请求的源 ID。&lt;/li&gt;
&lt;li&gt;异常的系统调用或失败的 API 调用。&lt;/li&gt;
&lt;li&gt;用户 / 管理员的行为不正常（即在不寻常的时间或从不寻常的地点），以及&lt;/li&gt;
&lt;li&gt;显著偏离标准操作指标基线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当存储不足时发出警报，可以帮助避免因资源有限而导致的性能问题和日志丢失，并帮助识别恶意的加密劫持企图。可以调查有特权的 Pod 执行案例，以确定管理员是否犯了一个错误，一个真实的用例需要升级特权，或者一个恶意行为者部署了一个有特权的 Pod。可疑的 Pod 创建源 IP 地址可能表明，恶意的网络行为者已经突破了容器并试图创建一个恶意的 Pod。&lt;/p&gt;
&lt;p&gt;将 Kubernetes 与企业现有的 SIEM 平台整合，特别是那些具有机器学习 / 大数据功能的平台，可以帮助识别审计日志中的违规行为并减少错误警报。如果配置这样的工具与 Kubernetes 一起工作，它应该被配置为这些情况和任何其他适用于用例的情况被配置为触发警报。&lt;/p&gt;
&lt;p&gt;当疑似入侵发生时，能够自动采取行动的系统有可能被配置为在管理员对警报作出反应时采取步骤以减轻损害。在 Pod IP 被列为 Pod 创建请求的源 ID 的情况下，一个可以实施的缓解措施是自动驱逐 Pod，以保持应用程序的可用性，但暂时停止对集群的任何损害。这样做将允许一个干净的 Pod 版本被重新安排到一个节点上。然后，调查人员可以检查日志，以确定是否发生了漏洞，如果是的话，调查恶意行为者是如何执行潜在威胁的，以便可以部署一个补丁。&lt;/p&gt;
&lt;h2 id=&#34;服务网格&#34;&gt;服务网格&lt;/h2&gt;
&lt;p&gt;服务网格是一个平台，通过允许将这些通信逻辑编码到服务网格中，而不是在每个微服务中，来简化应用程序中的微服务通信。将这种通信逻辑编码到各个微服务中是很难扩展的，当故障发生时很难调试，而且很难保证安全。使用服务网格可以简化开发人员的工作。服务网格可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个服务中断时，重新定向流量。&lt;/li&gt;
&lt;li&gt;收集性能指标以优化通信。&lt;/li&gt;
&lt;li&gt;允许管理服务与服务之间的通信加密。&lt;/li&gt;
&lt;li&gt;收集服务间通信的日志。&lt;/li&gt;
&lt;li&gt;从每个服务中收集日志。&lt;/li&gt;
&lt;li&gt;帮助开发者诊断微服务或通信机制的问题和故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务网格还可以帮助将服务迁移到混合或多云环境。虽然服务网格不是必须的，但它们是一种高度适合 Kubernetes 环境的选择。托管的 Kubernetes 服务通常包括他们自己的服务网格。然而，其他几个平台也是可用的，如果需要的话，是可以高度定制的。其中一些包括一个生成和轮换证书的证书颁发机构，允许服务之间进行安全的 TLS 认证。管理员应该考虑使用服务网格来加强 Kubernetes 集群的安全性。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/logging/f5.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/logging/f5.jpg&#34; data-width=&#34;1129&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;图5：集群利用服务网格，将日志与网络安全结合起来&#34;&gt;
    
  
  &lt;figcaption&gt;图5：集群利用服务网格，将日志与网络安全结合起来&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;容错性&#34;&gt;容错性&lt;/h2&gt;
&lt;p&gt;应制定容错策略，以确保日志服务的可用性。这些策略可以根据具体的 Kubernetes 用例而有所不同。一个可以实施的策略是，如果在存储容量超标的情况下，绝对有必要允许新的日志覆盖最旧的日志文件。&lt;/p&gt;
&lt;p&gt;如果日志被发送到外部服务，应该建立一种机制，以便在发生通信中断或外部服务故障时将日志存储在本地。一旦与外部服务的通信恢复，应制定策略，将本地存储的日志推送到外部服务器上。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 不包括广泛的审计功能。然而，该系统的构建是可扩展的，允许用户自由开发自己的定制解决方案，或选择适合自己需求的现有附加组件。最常见的解决方案之一是添加额外的审计后端服务，它可以使用 Kubernetes 记录的信息，并为用户执行额外的功能，如扩展搜索参数、数据映射功能和警报功能。已经使用 SIEM 平台的企业可以将 Kubernetes 与这些现有的功能进行整合。&lt;/p&gt;
&lt;p&gt;开源监控工具，如 Cloud Native Computing Foundation 的 Prometheus®、Grafana Labs 的 Grafana® 和 Elasticsearch 的 Elastic Stack (ELK)®—— 可用于进行事件监控、运行威胁分析、管理警报，以及收集资源隔离参数、历史使用情况和运行容器的网络统计数据。在审计访问控制和权限配置时，扫描工具可以通过协助识别 RBAC 中的风险权限配置而发挥作用。NSA 和 CISA 鼓励在现有环境中使用入侵检测系统（IDS）的组织考虑将该服务也整合到他们的 Kubernetes 环境中。这种整合将使企业能够监测并有可能杀死有异常行为迹象的容器，从而使容器能够从最初的干净镜像中重新启动。许多云服务提供商也为那些希望得到更多管理和可扩展解决方案的人提供容器监控服务。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pod 状态与生命周期管理</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/architecture/pod-state-and-lifecycle/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/architecture/pod-state-and-lifecycle/</guid>
      <description>
        
        
        &lt;p&gt;该节将带领大家了解 Kubernetes 中的基本概念，尤其是作为 Kubernetes 中调度的最基本单位 Pod。&lt;/p&gt;
&lt;p&gt;本节中包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解 Pod 的构成&lt;/li&gt;
&lt;li&gt;Pod 的生命周期&lt;/li&gt;
&lt;li&gt;Pod 中容器的启动顺序模板定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 中的基本组件 &lt;code&gt;kube-controller-manager&lt;/code&gt; 就是用来控制 Pod 的状态和生命周期的，在了解各种 controller 之前我们有必要先了解下 Pod 本身和其生命周期。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>升级和应用安全实践</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/upgrading-and-application-security-practices/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/upgrading-and-application-security-practices/</guid>
      <description>
        
        
        &lt;p&gt;遵循本文件中概述的加固指南是确保在 Kubernetes 协调容器上运行的应用程序安全的一个步骤。然而，安全是一个持续的过程，跟上补丁、更新和升级是至关重要的。具体的软件组件因个人配置的不同而不同，但整个系统的每一块都应尽可能保持安全。这包括更新：Kubernetes、管理程序、虚拟化软件、插件、环境运行的操作系统、服务器上运行的应用程序，以及 Kubernetes 环境中托管的任何其他软件。&lt;/p&gt;
&lt;p&gt;互联网安全中心（CIS）发布了保护软件安全的基准。管理员应遵守 Kubernetes 和任何其他相关系统组件的 CIS 基准。管理员应定期检查，以确保其系统的安全性符合当前安全专家对最佳实践的共识。应定期对各种系统组件进行漏洞扫描和渗透测试，主动寻找不安全的配置和零日漏洞。任何发现都应在潜在的网络行为者发现和利用它们之前及时补救。&lt;/p&gt;
&lt;p&gt;随着更新的部署，管理员也应该跟上从环境中删除任何不再需要的旧组件。使用托管的 Kubernetes 服务可以帮助自动升级和修补 Kubernetes、操作系统和网络协议。然而，管理员仍然必须为他们的容器化应用程序打补丁和升级。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/a/&#34;&gt;附录 A：非 root 应用的 Dockerfile 示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/b/&#34;&gt;附录 B：只读文件系统的部署模板示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/c/&#34;&gt;附录 C：Pod 安全策略示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/d/&#34;&gt;附录 D：命名空间示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/e/&#34;&gt;附录 E：网络策略示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/f/&#34;&gt;附录 F：LimitRange 示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/g/&#34;&gt;附录 G：ResourceQuota 示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/h/&#34;&gt;附录 H：加密示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/i/&#34;&gt;附录 I：KMS 配置实例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/j/&#34;&gt;附录 J：pod-reader RBAC 角色&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/k/&#34;&gt;附录 K：RBAC RoleBinding 和 ClusterRoleBinding 示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/l/&#34;&gt;附录 L：审计策略&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/m/&#34;&gt;附录 M：向 kube-apiserver 提交审计策略文件的标志示例&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/n/&#34;&gt;附录 N：webhook 配置&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
    
    <item>
      <title>附录 A：非 root 应用的 Dockerfile 示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/a/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/a/</guid>
      <description>
        
        
        &lt;p&gt;下面的例子是一个 Dockerfile，它以非 root 用户和非 group 成员身份运行一个应用程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-docker&#34; data-lang=&#34;docker&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; ubuntu:latest&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 升级和安装 make 工具&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; apt update &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt install -y make&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 从一个名为 code 的文件夹中复制源代码，并使用 make 工具构建应用程序。&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; ./code&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; make /code&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 创建一个新的用户（user1）和新的组（group1）；然后切换到该用户的上下文中。&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; useradd user1 &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; groupadd group1&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;USER&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; user1:group1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 设置容器的默认入口&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; /code/app&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Pod 概览</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-overview/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-overview/</guid>
      <description>
        
        
        &lt;p&gt;本文将为您讲解 Pod 的基础概念。&lt;/p&gt;
&lt;h2 id=&#34;理解-pod&#34;&gt;理解 Pod&lt;/h2&gt;
&lt;p&gt;Pod 是 kubernetes 中你可以创建和部署的最小也是最简的单位。Pod 代表着集群中运行的进程。&lt;/p&gt;
&lt;p&gt;Pod 中封装着应用的容器（有的情况下是好几个容器），存储、独立的网络 IP，管理容器如何运行的策略选项。Pod 代表着部署的一个单位：kubernetes 中应用的一个实例，可能由一个或者多个容器组合在一起共享资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.docker.com&#34; title=&#34;Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt;
 是 kubernetes 中最常用的容器运行时，但是 Pod 也支持其他容器运行时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Kubernetes 集群中 Pod 有如下两种使用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个 Pod 中运行一个容器&lt;/strong&gt;。“每个 Pod 中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把 Pod 想象成是单个容器的封装，kuberentes 管理的是 Pod 而不是直接管理容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在一个 Pod 中同时运行多个容器&lt;/strong&gt;。一个 Pod 中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service 单位 —— 一个容器共享文件，另一个“sidecar”容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/blog&#34; title=&#34;Kubernetes Blog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Blog&lt;/a&gt;
 有关于 Pod 用例的详细信息，查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/&#34; title=&#34;The Distributed System Toolkit: Patterns for Composite Containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Distributed System Toolkit: Patterns for Composite Containers&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/blog/2016/06/container-design-patterns/&#34; title=&#34;Container Design Patterns&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Design Patterns&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 Pod 都是应用的一个实例。如果你想平行扩展应用的话（运行多个实例），你应该运行多个 Pod，每个 Pod 都是一个应用实例。在 Kubernetes 中，这通常被称为 replication。&lt;/p&gt;
&lt;h3 id=&#34;pod-中如何管理多个容器&#34;&gt;Pod 中如何管理多个容器&lt;/h3&gt;
&lt;p&gt;Pod 中可以同时运行多个进程（作为容器运行）协同工作。同一个 Pod 中的容器会自动的分配到同一个 node 上。同一个 Pod 中的容器共享资源、网络环境和依赖，它们总是被同时调度。&lt;/p&gt;
&lt;p&gt;注意在一个 Pod 中同时运行多个容器是一种比较高级的用法。只有当你的容器需要紧密配合协作的时候才考虑用这种模式。例如，你有一个容器作为 web 服务器运行，需要用到共享的 volume，有另一个“sidecar”容器来从远端获取资源更新这些文件，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
  &lt;figcaption&gt;Pod 示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Pod 中可以共享两种资源：网络和存储。&lt;/p&gt;
&lt;h4 id=&#34;网络&#34;&gt;网络&lt;/h4&gt;
&lt;p&gt;每个 Pod 都会被分配一个唯一的 IP 地址。Pod 中的所有容器共享网络空间，包括 IP 地址和端口。Pod 内部的容器可以使用 &lt;code&gt;localhost&lt;/code&gt; 互相通信。Pod 中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。&lt;/p&gt;
&lt;h4 id=&#34;存储&#34;&gt;存储&lt;/h4&gt;
&lt;p&gt;可以为一个 Pod 指定多个共享的 Volume。Pod 中的所有容器都可以访问共享的 volume。Volume 也可以用来持久化 Pod 中的存储资源，以防容器重启后文件丢失。&lt;/p&gt;
&lt;h2 id=&#34;使用-pod&#34;&gt;使用 Pod&lt;/h2&gt;
&lt;p&gt;你很少会直接在 kubernetes 中创建单个 Pod。因为 Pod 的生命周期是短暂的，用后即焚的实体。当 Pod 被创建后（不论是由你直接创建还是被其他 Controller），都会被 Kubernetes 调度到集群的 Node 上。直到 Pod 的进程终止、被删掉、因为缺少资源而被驱逐、或者 Node 故障之前这个 Pod 都会一直保持在那个 Node 上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：重启 Pod 中的容器跟重启 Pod 不是一回事。Pod 只提供容器的运行环境并保持容器的运行状态，重启容器不会造成 Pod 重启。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pod 不会自愈。如果 Pod 运行的 Node 故障，或者是调度器本身故障，这个 Pod 就会被删除。同样的，如果 Pod 所在 Node 缺少资源或者 Pod 处于维护状态，Pod 也会被驱逐。Kubernetes 使用更高级的称为 Controller 的抽象层，来管理 Pod 实例。虽然可以直接使用 Pod，但是在 Kubernetes 中通常是使用 Controller 来管理 Pod 的。&lt;/p&gt;
&lt;h3 id=&#34;pod-和-controller&#34;&gt;Pod 和 Controller&lt;/h3&gt;
&lt;p&gt;Controller 可以创建和管理多个 Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个 Node 故障，Controller 就能自动将该节点上的 Pod 调度到其他健康的 Node 上。&lt;/p&gt;
&lt;p&gt;包含一个或者多个 Pod 的 Controller 示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../controllers/deployment&#34; title=&#34;Deployment&#34;&gt;Deployment&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../controllers/statefulset&#34; title=&#34;StatefulSet&#34;&gt;StatefulSet&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../../controllers/daemonset&#34; title=&#34;DaemonSet&#34;&gt;DaemonSet&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，Controller 会用你提供的 Pod Template 来创建相应的 Pod。&lt;/p&gt;
&lt;h2 id=&#34;pod-templates&#34;&gt;Pod Templates&lt;/h2&gt;
&lt;p&gt;Pod 模版是包含了其他 object 的 Pod 定义，例如 &lt;a href=&#34;../replicaset&#34; title=&#34;Replication Controllers&#34;&gt;Replication Controllers&lt;/a&gt;
，&lt;a href=&#34;../job&#34; title=&#34;Jobs&#34;&gt;Jobs&lt;/a&gt;
 和 &lt;a href=&#34;../daemonset&#34; title=&#34;DaemonSets&#34;&gt;DaemonSets&lt;/a&gt;
。Controller 根据 Pod 模板来创建实际的 Pod。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pod 解析</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod/</guid>
      <description>
        
        
        &lt;p&gt;Pod 是 Kubernetes 中可以创建的最小部署单元，也是 Kubernetes REST API 中的顶级资源类型。&lt;/p&gt;
&lt;p&gt;在 Kuberentes V1 core API 版本中的 Pod 的数据结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod/kubernetes-pod-cheatsheet.png&#34; data-img=&#34;/book/kubernetes-handbook/objects/pod/kubernetes-pod-cheatsheet.png&#34; data-width=&#34;3695&#34; data-height=&#34;5188&#34; alt=&#34;image&#34; data-caption=&#34;Pod Cheatsheet&#34;&gt;
    
  
  &lt;figcaption&gt;Pod Cheatsheet&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;什么是-pod&#34;&gt;什么是 Pod？&lt;/h2&gt;
&lt;p&gt;Pod 就像是豌豆荚一样，它由一个或者多个容器组成（例如 Docker 容器），它们共享容器存储、网络和容器运行配置项。Pod 中的容器总是被同时调度，有共同的运行环境。你可以把单个 Pod 想象成是运行独立应用的“逻辑主机”—— 其中运行着一个或者多个紧密耦合的应用容器 —— 在有容器之前，这些应用都是运行在几个相同的物理机或者虚拟机上。&lt;/p&gt;
&lt;p&gt;尽管 kubernetes 支持多种容器运行时，但是 Docker 依然是最常用的运行时环境，我们可以使用 Docker 的术语和规则来定义 Pod。&lt;/p&gt;
&lt;p&gt;Pod 中共享的环境包括 Linux 的 namespace、cgroup 和其他可能的隔绝环境，这一点跟 Docker 容器一致。在 Pod 的环境中，每个容器中可能还有更小的子隔离环境。&lt;/p&gt;
&lt;p&gt;Pod 中的容器共享 IP 地址和端口号，它们之间可以通过 &lt;code&gt;localhost&lt;/code&gt; 互相发现。它们之间可以通过进程间通信，例如 &lt;a href=&#34;https://en.wikipedia.org/wiki/UNIX_System_V&#34; title=&#34;SystemV&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SystemV&lt;/a&gt;
 信号或者 POSIX 共享内存。不同 Pod 之间的容器具有不同的 IP 地址，不能直接通过 IPC 通信。&lt;/p&gt;
&lt;p&gt;Pod 中的容器也有访问共享 volume 的权限，这些 volume 会被定义成 pod 的一部分并挂载到应用容器的文件系统中。&lt;/p&gt;
&lt;p&gt;根据 Docker 的结构，Pod 中的容器共享 namespace 和 volume，不支持共享 PID 的 namespace。&lt;/p&gt;
&lt;p&gt;就像每个应用容器，pod 被认为是临时（非持久的）实体。在 Pod 的生命周期中讨论过，pod 被创建后，被分配一个唯一的 ID（UID），调度到节点上，并一致维持期望的状态直到被终结（根据重启策略）或者被删除。如果 node 死掉了，分配到了这个 node 上的 pod，在经过一个超时时间后会被重新调度到其他 node 节点上。一个给定的 pod（如 UID 定义的）不会被“重新调度”到新的节点上，而是被一个同样的 pod 取代，如果期望的话甚至可以是相同的名字，但是会有一个新的 UID。&lt;/p&gt;
&lt;p&gt;临时卷的生命周期跟 pod 相同，当 Pod 因为某种原因被删除或者被新创建的相同的 pod 取代时，pod 的附属物（例如 volume）也会被销毁和重新创建。Kubernetes 中提供了众多的卷类型，关于卷（Volume）的详细介绍请参考 &lt;a href=&#34;https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/&#34; title=&#34;Kubernetes 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod/pod-overview.png&#34; data-img=&#34;/book/kubernetes-handbook/objects/pod/pod-overview.png&#34; data-width=&#34;600&#34; data-height=&#34;400&#34; alt=&#34;image&#34; data-caption=&#34;Pod 示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Pod 示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;说明：一个多容器 Pod，包含文件提取程序和 Web 服务器，该服务器使用持久卷在容器之间共享存储。&lt;/p&gt;
&lt;h2 id=&#34;pod-的动机&#34;&gt;Pod 的动机&lt;/h2&gt;
&lt;h3 id=&#34;管理&#34;&gt;管理&lt;/h3&gt;
&lt;p&gt;Pod 是一个服务的多个进程的聚合单位，pod 提供这种模型能够简化应用部署管理，通过提供一个更高级别的抽象的方式。Pod 作为一个独立的部署单位，支持横向扩展和复制。共生（协同调度），命运共同体（例如被终结），协同复制，资源共享，依赖管理，pod 都会自动的为容器处理这些问题。&lt;/p&gt;
&lt;h3 id=&#34;资源共享和通信&#34;&gt;资源共享和通信&lt;/h3&gt;
&lt;p&gt;Pod 中的应用可以共享网络空间（IP 地址和端口），因此可以通过 &lt;code&gt;localhost&lt;/code&gt; 互相发现。因此，pod 中的应用必须协调端口占用。每个 pod 都有一个唯一的 IP 地址，跟物理机和其他 pod 都处于一个扁平的网络空间中，它们之间可以直接连通。&lt;/p&gt;
&lt;p&gt;Pod 中应用容器的 hostname 被设置成 Pod 的名字。&lt;/p&gt;
&lt;p&gt;Pod 中的应用容器可以共享卷。持久化卷能够保证 pod 重启时使用的数据不丢失。&lt;/p&gt;
&lt;h2 id=&#34;pod-的使用&#34;&gt;Pod 的使用&lt;/h2&gt;
&lt;p&gt;Pod 也可以用于垂直应用栈（例如 LAMP），这样使用的主要动机是为了支持共同调度和协调管理应用程序，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容管理系统、文件和数据加载器、本地换群管理器等。&lt;/li&gt;
&lt;li&gt;日志和检查点备份、压缩、旋转、快照等。&lt;/li&gt;
&lt;li&gt;数据变更观察者、日志和监控适配器、活动发布者等。&lt;/li&gt;
&lt;li&gt;代理、桥接和适配器等。&lt;/li&gt;
&lt;li&gt;控制器、管理器、配置器、更新器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常单个 pod 中不会同时运行一个应用的多个实例。&lt;/p&gt;
&lt;p&gt;详细说明请看： &lt;a href=&#34;https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/&#34; title=&#34;The Distributed System ToolKit: Patterns for Composite Containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Distributed System ToolKit: Patterns for Composite Containers&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;其他替代选择&#34;&gt;其他替代选择&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接在一个容器中运行多个应用程序呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透明。让 pod 中的容器对基础设施可见，以便基础设施能够为这些容器提供服务，例如进程管理和资源监控。这可以为用户带来极大的便利。&lt;/li&gt;
&lt;li&gt;解耦软件依赖。每个容器都可以进行版本管理，独立的编译和发布。未来 kubernetes 甚至可能支持单个容器的在线升级。&lt;/li&gt;
&lt;li&gt;使用方便。用户不必运行自己的进程管理器，还要担心错误信号传播等。&lt;/li&gt;
&lt;li&gt;效率。因为由基础架构提供更多的职责，所以容器可以变得更加轻量级。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;为什么不支持容器的亲和性的协同调度？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法可以提供容器的协同定位，能够根据容器的亲和性进行调度，但是无法实现使用 pod 带来的大部分好处，例如资源共享，IPC，保持状态一致性和简化管理等。&lt;/p&gt;
&lt;h2 id=&#34;pod-的持久性或者说缺乏持久性&#34;&gt;Pod 的持久性（或者说缺乏持久性）&lt;/h2&gt;
&lt;p&gt;Pod 在设计支持就不是作为持久化实体的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会死掉会被驱逐。&lt;/p&gt;
&lt;p&gt;通常，用户不需要手动直接创建 Pod，而是应该使用 controller（例如 &lt;a href=&#34;../deployment&#34; title=&#34;Deployments&#34;&gt;Deployments&lt;/a&gt;
），即使是在创建单个 Pod 的情况下。Controller 可以提供集群级别的自愈功能、复制和升级管理。&lt;/p&gt;
&lt;p&gt;使用集合 API 作为主要的面向用户的原语在集群调度系统中相对常见，包括 &lt;a href=&#34;https://research.google.com/pubs/pub43438.html&#34; title=&#34;Borg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg&lt;/a&gt;
、&lt;a href=&#34;https://mesosphere.github.io/marathon/docs/rest-api.html&#34; title=&#34;Marathon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Marathon&lt;/a&gt;
、&lt;a href=&#34;https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema&#34; title=&#34;Aurora&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aurora&lt;/a&gt;
 和 &lt;a href=&#34;https://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997&#34; title=&#34;Tupperware&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tupperware&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;Pod 原语有利于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度程序和控制器可插拔性&lt;/li&gt;
&lt;li&gt;支持 pod 级操作，无需通过控制器 API“代理”它们&lt;/li&gt;
&lt;li&gt;将 pod 生命周期与控制器生命周期分离，例如用于自举（bootstrap）&lt;/li&gt;
&lt;li&gt;控制器和服务的分离 —— 端点控制器只是监视 pod&lt;/li&gt;
&lt;li&gt;将集群级功能与 Kubelet 级功能的清晰组合 ——Kubelet 实际上是“pod 控制器”&lt;/li&gt;
&lt;li&gt;高可用性应用程序，它们可以在终止之前及在删除之前更换 pod，例如在计划驱逐、镜像预拉取或实时 pod 迁移的情况下，详见&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/3949&#34; title=&#34;Issue #3949&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue #3949&lt;/a&gt;
。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;../statefulset&#34; title=&#34;StatefulSet&#34;&gt;StatefulSet&lt;/a&gt;
 控制器支持有状态的 Pod。在 1.4 版本中被称为 PetSet。在 kubernetes 之前的版本中创建有状态 pod 的最佳方式是创建一个 replica 为 1 的 replication controller。&lt;/p&gt;
&lt;h2 id=&#34;pod-的终止&#34;&gt;Pod 的终止&lt;/h2&gt;
&lt;p&gt;因为 pod 作为在集群的节点上运行的进程，所以在不再需要的时候能够优雅的终止掉是十分必要的（比起使用发送 KILL 信号这种暴力的方式）。用户需要能够发起一个删除 Pod 的请求，并且知道它们何时会被终止，是否被正确的删除。用户想终止程序时发送删除 pod 的请求，在 pod 可以被强制删除前会有一个宽限期，会发送一个 TERM 请求到每个容器的主进程。一旦超时，将向主进程发送 KILL 信号并从 API server 中删除。如果 kubelet 或者 container manager 在等待进程终止的过程中重启，在重启后仍然会重试完整的宽限期。&lt;/p&gt;
&lt;p&gt;示例流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户发送删除 pod 的命令，默认宽限期是 30 秒；&lt;/li&gt;
&lt;li&gt;在 Pod 超过该宽限期后 API server 就会更新 Pod 的状态为“dead”；&lt;/li&gt;
&lt;li&gt;在客户端命令行上显示的 Pod 状态为“terminating”；&lt;/li&gt;
&lt;li&gt;跟第三步同时，当 kubelet 发现 pod 被标记为“terminating”状态时，开始停止 pod 进程：
&lt;ol&gt;
&lt;li&gt;如果在 pod 中定义了 preStop hook，在停止 pod 前会被调用。如果在宽限期过后，preStop hook 依然在运行，第二步会再增加 2 秒的宽限期；&lt;/li&gt;
&lt;li&gt;向 Pod 中的进程发送 TERM 信号；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;跟第三步同时，该 Pod 将从该 service 的端点列表中删除，不再是 replication controller 的一部分。关闭的慢的 pod 将继续处理 load balancer 转发的流量；&lt;/li&gt;
&lt;li&gt;过了宽限期后，将向 Pod 中依然运行的进程发送 SIGKILL 信号而杀掉进程。&lt;/li&gt;
&lt;li&gt;Kubelet 会在 API server 中完成 Pod 的的删除，通过将优雅周期设置为 0（立即删除）。Pod 在 API 中消失，并且在客户端也不可见。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;删除宽限期默认是 30 秒。 &lt;code&gt;kubectl delete&lt;/code&gt; 命令支持 &lt;code&gt;—grace-period=&amp;lt;seconds&amp;gt;&lt;/code&gt; 选项，允许用户设置自己的宽限期。如果设置为 0 将强制删除 pod。在 kubectl&amp;gt;=1.5 版本的命令中，你必须同时使用 &lt;code&gt;--force&lt;/code&gt; 和 &lt;code&gt;--grace-period=0&lt;/code&gt; 来强制删除 pod。在 yaml 文件中可以通过 &lt;code&gt;{{ .spec.spec.terminationGracePeriodSeconds }}&lt;/code&gt; 来修改此值。&lt;/p&gt;
&lt;h3 id=&#34;强制删除-pod&#34;&gt;强制删除 Pod&lt;/h3&gt;
&lt;p&gt;Pod 的强制删除是通过在集群和 etcd 中将其定义为删除状态。当执行强制删除命令时，API server 不会等待该 pod 所运行在节点上的 kubelet 确认，就会立即将该 pod 从 API server 中移除，这时就可以创建跟原 pod 同名的 pod 了。这时，在节点上的 pod 会被立即设置为 terminating 状态，不过在被强制删除之前依然有一小段优雅删除周期。&lt;/p&gt;
&lt;p&gt;强制删除对于某些 pod 具有潜在危险性，请谨慎使用。使用 StatefulSet pod 的情况下，请参考删除 StatefulSet 中的 pod 文章。&lt;/p&gt;
&lt;h2 id=&#34;pod-中容器的特权模式&#34;&gt;Pod 中容器的特权模式&lt;/h2&gt;
&lt;p&gt;从 Kubernetes1.1 版本开始，pod 中的容器就可以开启 privileged 模式，在容器定义文件的 &lt;code&gt;SecurityContext&lt;/code&gt; 下使用 &lt;code&gt;privileged&lt;/code&gt; flag。这在使用 Linux 的网络操作和访问设备的能力时是很有用的。容器内进程可获得近乎等同于容器外进程的权限。在不需要修改和重新编译 kubelet 的情况下就可以使用 pod 来开发节点的网络和存储插件。&lt;/p&gt;
&lt;p&gt;如果 master 节点运行的是 kuberentes1.1 或更高版本，而 node 节点的版本低于 1.1 版本，则 API server 将也可以接受新的特权模式的 pod，但是无法启动，pod 将处于 pending 状态。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;kubectl describe pod FooPodName&lt;/code&gt;，可以看到为什么 pod 处于 pending 状态。输出的 event 列表中将显示： &lt;code&gt;Error validating pod &amp;quot;FooPodName&amp;quot;.&amp;quot;FooPodNamespace&amp;quot; from api, ignoring: spec.containers[0].securityContext.privileged: forbidden &#39;&amp;lt;*&amp;gt;(0xc2089d3248)true&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 master 节点的版本低于 1.1，无法创建特权模式的 pod。如果你仍然试图去创建的话，你得到如下错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;The Pod &amp;#34;FooPodName&amp;#34; is invalid. spec.containers[0].securityContext.privileged: forbidden &amp;#39;&amp;lt;*&amp;gt;(0xc20b222db0)true&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>附录 B：只读文件系统的部署模板示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/b/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/b/</guid>
      <description>
        
        
        &lt;p&gt;下面是一个使用只读根文件系统的 Kubernetes 部署模板的例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sleep&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;999&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;securityContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnlyRootFilesystem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#使容器的文件系统成为只读&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/writeable/location/here&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#创建一个可写卷&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;volName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;emptyDir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;volName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Init 容器</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/init-containers/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/init-containers/</guid>
      <description>
        
        
        &lt;p&gt;该特性在自 Kubernetes 1.6 版本推出 beta 版本。Init 容器可以在 PodSpec 中同应用程序的 &lt;code&gt;containers&lt;/code&gt; 数组一起来指定。此前 beta 注解的值仍将保留，并覆盖 PodSpec 字段值。&lt;/p&gt;
&lt;p&gt;本文讲解 Init 容器的基本概念，这是一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。&lt;/p&gt;
&lt;h2 id=&#34;理解-init-容器&#34;&gt;理解 Init 容器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/abstractions/pod/&#34; title=&#34;Pod&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pod&lt;/a&gt;
 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的 Init 容器。&lt;/p&gt;
&lt;p&gt;Init 容器与普通的容器非常像，除了如下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Init 容器总是运行到成功完成为止。&lt;/li&gt;
&lt;li&gt;每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 &lt;code&gt;restartPolicy&lt;/code&gt; 为 Never，它不会重新启动。&lt;/p&gt;
&lt;p&gt;指定容器为 Init 容器，在 PodSpec 中添加 &lt;code&gt;initContainers&lt;/code&gt; 字段，以 v1.Container 类型对象的 JSON 数组的形式，还有 app 的 &lt;code&gt;containers&lt;/code&gt; 数组。Init 容器的状态在 &lt;code&gt;status.initContainerStatuses&lt;/code&gt; 字段中以容器状态数组的格式返回（类似 &lt;code&gt;status.containerStatuses&lt;/code&gt; 字段）。&lt;/p&gt;
&lt;h3 id=&#34;与普通容器的不同之处&#34;&gt;与普通容器的不同之处&lt;/h3&gt;
&lt;p&gt;Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。然而，Init 容器对资源请求和限制的处理稍有不同，在下面 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources&#34; title=&#34;资源&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源&lt;/a&gt;
 处有说明。而且 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。&lt;/p&gt;
&lt;p&gt;如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。&lt;/p&gt;
&lt;h2 id=&#34;init-容器能做什么&#34;&gt;Init 容器能做什么？&lt;/h2&gt;
&lt;p&gt;因为 Init 容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们可以包含并运行实用工具，但是出于安全考虑，是不建议在应用程序容器镜像中包含这些实用工具的。&lt;/li&gt;
&lt;li&gt;它们可以包含使用工具和定制化代码来安装，但是不能出现在应用程序镜像中。例如，创建镜像没必要 &lt;code&gt;FROM&lt;/code&gt; 另一个镜像，只需要在安装过程中使用类似 &lt;code&gt;sed&lt;/code&gt;、 &lt;code&gt;awk&lt;/code&gt;、 &lt;code&gt;python&lt;/code&gt; 或 &lt;code&gt;dig&lt;/code&gt; 这样的工具。&lt;/li&gt;
&lt;li&gt;应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。&lt;/li&gt;
&lt;li&gt;Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。&lt;/li&gt;
&lt;li&gt;它们必须在应用程序容器启动之前运行完成，而应用程序容器是并行运行的，所以 Init 容器能够提供了一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;下面列举了 Init 容器的一些用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;等待一个 Service 创建完成，通过类似如下 shell 命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; i in &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;1..100&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; sleep 1&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; dig myservice&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; 0&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Pod 注册到远程服务器，通过在命令中调用 API，类似如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -X POST http://&lt;span class=&#34;nv&#34;&gt;$MANAGEMENT_SERVICE_HOST&lt;/span&gt;:&lt;span class=&#34;nv&#34;&gt;$MANAGEMENT_SERVICE_PORT&lt;/span&gt;/register -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;instance=$(&amp;lt;POD_NAME&amp;gt;)&amp;amp;ip=$(&amp;lt;POD_IP&amp;gt;)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在启动应用容器之前等一段时间，使用类似 &lt;code&gt;sleep 60&lt;/code&gt; 的命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;克隆 Git 仓库到数据卷。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。例如，在配置文件中存放 POD_IP 值，并使用 Jinja 生成主应用配置文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多详细用法示例，可以在 &lt;a href=&#34;https://kubernetes.io/docs/concepts/abstractions/controllers/statefulsets/&#34; title=&#34;StatefulSet 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StatefulSet 文档&lt;/a&gt;
 和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/&#34; title=&#34;生产环境 Pod 指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生产环境 Pod 指南&lt;/a&gt;
 中找到。&lt;/p&gt;
&lt;h3 id=&#34;使用-init-容器&#34;&gt;使用 Init 容器&lt;/h3&gt;
&lt;p&gt;下面是 Kubernetes 1.5 版本 yaml 文件，展示了一个具有 2 个 Init 容器的简单 Pod。第一个等待 &lt;code&gt;myservice&lt;/code&gt; 启动，第二个等待 &lt;code&gt;mydb&lt;/code&gt; 启动。一旦这两个 Service 都启动完成，Pod 将开始启动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pod.beta.kubernetes.io/init-containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;name&amp;#34;: &amp;#34;init-myservice&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;image&amp;#34;: &amp;#34;busybox&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;command&amp;#34;: [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        },
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;name&amp;#34;: &amp;#34;init-mydb&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;image&amp;#34;: &amp;#34;busybox&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;            &amp;#34;command&amp;#34;: [&amp;#34;sh&amp;#34;, &amp;#34;-c&amp;#34;, &amp;#34;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    ]&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sh&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;echo The app is running! &amp;amp;&amp;amp; sleep 3600&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是 Kubernetes 1.6 版本的新语法，尽管老的 annotation 语法仍然可以使用。我们已经把 Init 容器的声明移到 &lt;code&gt;spec&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sh&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;echo The app is running! &amp;amp;&amp;amp; sleep 3600&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initContainers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-myservice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sh&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-mydb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sh&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：版本兼容性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.5 版本的语法在 1.6 和 1.7 版本中仍然可以使用，但是我们推荐使用 1.6 版本的新语法。Kubernetes 1.8 以后的版本只支持新语法。在 Kubernetes 1.6 版本中，Init 容器在 API 中新建了一个字段。虽然期望使用 beta 版本的 annotation，但在未来发行版将会被废弃掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的 YAML 文件展示了 &lt;code&gt;mydb&lt;/code&gt; 和 &lt;code&gt;myservice&lt;/code&gt; 两个 Service：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myservice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9376&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mydb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9377&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 Pod 可以使用下面的命令进行启动和调试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create -f myapp.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pod &lt;span class=&#34;s2&#34;&gt;&amp;#34;myapp-pod&amp;#34;&lt;/span&gt; created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get -f myapp.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME        READY     STATUS     RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;myapp-pod   0/1       Init:0/2   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          6m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl describe -f myapp.yaml 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Name:          myapp-pod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Namespace:     default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Labels:        &lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;myapp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Status:        Pending
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Init Containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  init-myservice:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    State:         Running
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  init-mydb:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    State:         Waiting
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      Reason:      PodInitializing
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Ready:         False
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  myapp-container:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    State:         Waiting
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      Reason:      PodInitializing
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Ready:         False
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Events:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ---------    --------    -----    ----                      -------------                           --------      ------        -------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  16s          16s         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;default-scheduler &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  16s          16s         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;kubelet 172.17.4.201&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;    spec.initContainers&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;init-myservice&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     Normal        Pulling       pulling image &lt;span class=&#34;s2&#34;&gt;&amp;#34;busybox&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  13s          13s         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;kubelet 172.17.4.201&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;    spec.initContainers&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;init-myservice&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     Normal        Pulled        Successfully pulled image &lt;span class=&#34;s2&#34;&gt;&amp;#34;busybox&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  13s          13s         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;kubelet 172.17.4.201&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;    spec.initContainers&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;init-myservice&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     Normal        Created       Created container with docker id 5ced34a04634&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; Security:&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;seccomp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;unconfined&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  13s          13s         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;kubelet 172.17.4.201&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;    spec.initContainers&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;init-myservice&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     Normal        Started       Started container with docker id 5ced34a04634
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl logs myapp-pod -c init-myservice &lt;span class=&#34;c1&#34;&gt;# Inspect the first init container&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl logs myapp-pod -c init-mydb      &lt;span class=&#34;c1&#34;&gt;# Inspect the second init container&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦我们启动了 &lt;code&gt;mydb&lt;/code&gt; 和 &lt;code&gt;myservice&lt;/code&gt; 这两个 Service，我们能够看到 Init 容器完成，并且 &lt;code&gt;myapp-pod&lt;/code&gt; 被创建：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create -f services.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service &lt;span class=&#34;s2&#34;&gt;&amp;#34;myservice&amp;#34;&lt;/span&gt; created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service &lt;span class=&#34;s2&#34;&gt;&amp;#34;mydb&amp;#34;&lt;/span&gt; created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get -f myapp.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME        READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;myapp-pod   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          9m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子非常简单，但是应该能够为我们创建自己的 Init 容器提供一些启发。&lt;/p&gt;
&lt;h2 id=&#34;具体行为&#34;&gt;具体行为&lt;/h2&gt;
&lt;p&gt;在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 &lt;code&gt;restartPolicy&lt;/code&gt; 指定的策略进行重试。然而，如果 Pod 的 &lt;code&gt;restartPolicy&lt;/code&gt; 设置为 Always，Init 容器失败时会使用 &lt;code&gt;RestartPolicy&lt;/code&gt; 策略。&lt;/p&gt;
&lt;p&gt;在所有的 Init 容器没有成功之前，Pod 将不会变成 &lt;code&gt;Ready&lt;/code&gt; 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 &lt;code&gt;Pending&lt;/code&gt; 状态，但应该会将 &lt;code&gt;Initializing&lt;/code&gt; 状态设置为 true。&lt;/p&gt;
&lt;p&gt;如果 Pod &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons&#34; title=&#34;重启&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重启&lt;/a&gt;
，所有 Init 容器必须重新执行。&lt;/p&gt;
&lt;p&gt;对 Init 容器 spec 的修改被限制在容器 image 字段，修改其他字段都不会生效。更改 Init 容器的 image 字段，等价于重启该 Pod。&lt;/p&gt;
&lt;p&gt;因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。特别地当写到 &lt;code&gt;EmptyDirs&lt;/code&gt; 文件中的代码，应该对输出文件可能已经存在做好准备。&lt;/p&gt;
&lt;p&gt;Init 容器具有应用容器的所有字段。除了 &lt;code&gt;readinessProbe&lt;/code&gt;，因为 Init 容器无法定义不同于完成（completion）的就绪（readiness）之外的其他状态。这会在验证过程中强制执行。&lt;/p&gt;
&lt;p&gt;在 Pod 上使用 &lt;code&gt;activeDeadlineSeconds&lt;/code&gt;，在容器上使用 &lt;code&gt;livenessProbe&lt;/code&gt;，这样能够避免 Init 容器一直失败。这就为 Init 容器活跃设置了一个期限。&lt;/p&gt;
&lt;p&gt;在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。&lt;/p&gt;
&lt;h3 id=&#34;资源&#34;&gt;资源&lt;/h3&gt;
&lt;p&gt;为 Init 容器指定顺序和执行逻辑，下面对资源使用的规则将被应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在所有 Init 容器上定义的，任何特殊资源请求或限制的最大值，是 &lt;em&gt;有效初始请求/限制&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pod 对资源的有效请求/限制要高于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有应用容器对某个资源的请求/限制之和&lt;/li&gt;
&lt;li&gt;对某个资源的有效初始请求/限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于有效请求/限制完成调度，这意味着 Init 容器能够为初始化预留资源，这些资源在 Pod 生命周期过程中并没有被使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pod 的 &lt;em&gt;有效 QoS 层&lt;/em&gt;，是 Init 容器和应用容器相同的 QoS 层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于有效 Pod 请求和限制来应用配额和限制。Pod 级别的 cgroups 是基于有效 Pod 请求和限制，和调度器相同。&lt;/p&gt;
&lt;h3 id=&#34;pod-重启的原因&#34;&gt;Pod 重启的原因&lt;/h3&gt;
&lt;p&gt;Pod 重启，会导致 Init 容器重新执行，主要有如下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户更新 PodSpec 导致 Init 容器镜像发生改变。应用容器镜像的变更只会重启应用容器。&lt;/li&gt;
&lt;li&gt;Pod 基础设施容器被重启。这不多见，但某些具有 root 权限可访问 Node 的人可能会这样做。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;restartPolicy&lt;/code&gt; 设置为 Always，Pod 中所有容器会终止，强制重启，由于垃圾收集导致 Init 容器完整的记录丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;支持与兼容性&#34;&gt;支持与兼容性&lt;/h2&gt;
&lt;p&gt;API Server 版本为 1.6 或更高版本的集群，通过使用 &lt;code&gt;spec.initContainers&lt;/code&gt; 字段来支持 Init 容器。之前的版本可以使用 alpha 和 beta 注解支持 Init 容器。&lt;code&gt;spec.initContainers&lt;/code&gt; 字段也被加入到 alpha 和 beta 注解中，所以 Kubernetes 1.3.0 版本或更高版本可以执行 Init 容器，并且 1.6 版本的 API Server 能够安全地回退到 1.5.x 版本，而不会使已创建的 Pod 失去 Init 容器的功能。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 C：Pod 安全策略示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/c/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/c/</guid>
      <description>
        
        
        &lt;p&gt;下面是一个 Kubernetes Pod 安全策略的例子，它为集群中运行的容器执行了强大的安全要求。这个例子是基于&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&#34; title=&#34;官方的 Kubernetes 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方的 Kubernetes 文档&lt;/a&gt;
。我们鼓励管理员对该策略进行修改，以满足他们组织的要求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;policy/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PodSecurityPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;restricted&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seccomp.security.alpha.kubernetes.io/allowedProfileNames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;docker/default,runtime/default&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apparmor.security.beta.kubernetes.io/allowedProfileNames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;runtime/default&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seccomp.security.alpha.kubernetes.io/defaultProfileName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;runtime/default&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apparmor.security.beta.kubernetes.io/defaultProfileName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;runtime/default&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;privileged&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 需要防止升级到 root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowPrivilegeEscalation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requiredDropCapabilities&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ALL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;configMap&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;emptyDir&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;projected&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;secret&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;downwardAPI&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;persistentVolumeClaim&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 假设管理员设置的 persistentVolumes 是安全的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostNetwork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostIPC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostPID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;MustRunAsNonRoot&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 要求容器在没有 root 的情况下运行 seLinux&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;RunAsAny&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 假设节点使用的是 AppArmor 而不是 SELinux&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;supplementalGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;MustRunAs&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ranges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 禁止添加到 root 组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;65535&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;MustRunAs&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ranges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 禁止添加到 root 组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;65535&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;MustRunAs&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ranges&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 禁止添加到 root 组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;65535&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnlyRootFilesystem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Pause 容器</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pause-container/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pause-container/</guid>
      <description>
        
        
        &lt;p&gt;Pause 容器，又叫 Infra 容器，本文将探究该容器的作用与原理。&lt;/p&gt;
&lt;p&gt;我们知道在 kubelet 的配置中有这样一个参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;KUBELET_POD_INFRA_CONTAINER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;--pod-infra-container-image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;registry.access.redhat.com/rhel7/pod-infrastructure:latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面是 openshift 中的配置参数，kubernetes 中默认的配置参数是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;KUBELET_POD_INFRA_CONTAINER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;--pod-infra-container-image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;gcr.io/google_containers/pause-amd64:3.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pause 容器，是可以自己来定义，官方使用的 &lt;code&gt;gcr.io/google_containers/pause-amd64:3.0&lt;/code&gt; 容器的代码见 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/master/build/pause&#34; title=&#34;Github&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;
，使用 C 语言编写。&lt;/p&gt;
&lt;h2 id=&#34;pause-容器特点&#34;&gt;Pause 容器特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;镜像非常小，目前在 700KB 左右&lt;/li&gt;
&lt;li&gt;永远处于 Pause (暂停) 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pause-容器背景&#34;&gt;Pause 容器背景&lt;/h2&gt;
&lt;p&gt;像 Pod 这样一个东西，本身是一个逻辑概念。那在机器上，它究竟是怎么实现的呢？这就是我们要解释的一个问题。&lt;/p&gt;
&lt;p&gt;既然说 Pod 要解决这个问题，核心就在于如何让一个 Pod 里的多个容器之间最高效的共享某些资源和数据。&lt;/p&gt;
&lt;p&gt;因为容器之间原本是被 Linux Namespace 和 cgroups 隔开的，所以现在实际要解决的是怎么去打破这个隔离，然后共享某些事情和某些信息。这就是 Pod 的设计要解决的核心问题所在。&lt;/p&gt;
&lt;p&gt;所以说具体的解法分为两个部分：网络和存储。&lt;/p&gt;
&lt;p&gt;Pause 容器就是为解决 Pod 中的网络问题而生的。&lt;/p&gt;
&lt;h2 id=&#34;pause-容器实现&#34;&gt;Pause 容器实现&lt;/h2&gt;
&lt;p&gt;Pod 里的多个容器怎么去共享网络？下面是个例子：&lt;/p&gt;
&lt;p&gt;比如说现在有一个 Pod，其中包含了一个容器 A 和一个容器 B，它们两个就要共享 Network Namespace。在 Kubernetes 里的解法是这样的：它会在每个 Pod 里，额外起一个 Infra container 小容器来共享整个 Pod 的 Network Namespace。&lt;/p&gt;
&lt;p&gt;Infra container 是一个非常小的镜像，大概 700KB 左右，是一个 C 语言写的、永远处于“暂停”状态的容器。由于有了这样一个 Infra container 之后，其他所有容器都会通过 Join Namespace 的方式加入到 Infra container 的 Network Namespace 中。&lt;/p&gt;
&lt;p&gt;所以说一个 Pod 里面的所有容器，它们看到的网络视图是完全一样的。即：它们看到的网络设备、IP 地址、Mac 地址等等，跟网络相关的信息，其实全是一份，这一份都来自于 Pod 第一次创建的这个 Infra container。这就是 Pod 解决网络共享的一个解法。&lt;/p&gt;
&lt;p&gt;在 Pod 里面，一定有一个 IP 地址，是这个 Pod 的 Network Namespace 对应的地址，也是这个 Infra container 的 IP 地址。所以大家看到的都是一份，而其他所有网络资源，都是一个 Pod 一份，并且被 Pod 中的所有容器共享。这就是 Pod 的网络实现方式。&lt;/p&gt;
&lt;p&gt;由于需要有一个相当于说中间的容器存在，所以整个 Pod 里面，必然是 Infra container 第一个启动。并且整个 Pod 的生命周期是等同于 Infra container 的生命周期的，与容器 A 和 B 是无关的。这也是为什么在 Kubernetes 里面，它是允许去单独更新 Pod 里的某一个镜像的，即：做这个操作，整个 Pod 不会重建，也不会重启，这是非常重要的一个设计。&lt;/p&gt;
&lt;h2 id=&#34;pause-容器的作用&#34;&gt;Pause 容器的作用&lt;/h2&gt;
&lt;p&gt;我们检查 node 节点的时候会发现每个 node 上都运行了很多的 pause 容器，例如如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker ps
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CONTAINER ID        IMAGE                                                                                                                    COMMAND                  CREATED             STATUS              PORTS               NAMES
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2c7d50f1a7be        docker.io/jimmysong/heapster-grafana-amd64@sha256:d663759b3de86cf62e64a43b021f133c383e8f7b0dc2bdd78115bc95db371c9a       &lt;span class=&#34;s2&#34;&gt;&amp;#34;/run.sh&amp;#34;&lt;/span&gt;                &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours ago         Up &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours                              k8s_grafana_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5df93dea877a        docker.io/jimmysong/heapster-influxdb-amd64@sha256:a217008b68cb49e8f038c4eeb6029261f02adca81d8eae8c5c01d030361274b8      &lt;span class=&#34;s2&#34;&gt;&amp;#34;influxd --config ...&amp;#34;&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours ago         Up &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours                              k8s_influxdb_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9cec6c0ef583        jimmysong/pause-amd64:3.0                                                                                                &lt;span class=&#34;s2&#34;&gt;&amp;#34;/pause&amp;#34;&lt;/span&gt;                 &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours ago         Up &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours                              k8s_POD_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;54d06e30a4c7        docker.io/jimmysong/kubernetes-dashboard-amd64@sha256:668710d034c4209f8fa9a342db6d8be72b6cb5f1f3f696cee2379b8512330be4   &lt;span class=&#34;s2&#34;&gt;&amp;#34;/dashboard --inse...&amp;#34;&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours ago         Up &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours                              k8s_kubernetes-dashboard_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5a5ef33b0d58        jimmysong/pause-amd64:3.0                                                                                                &lt;span class=&#34;s2&#34;&gt;&amp;#34;/pause&amp;#34;&lt;/span&gt;                 &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours ago         Up &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; hours                              k8s_POD_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;kubernetes 中的 pause 容器主要为每个业务容器提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 pod 中担任 Linux 命名空间共享的基础；&lt;/li&gt;
&lt;li&gt;启用 pid 命名空间，开启 init 进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ianlewis.org/en/almighty-pause-container&#34; title=&#34;这篇文章&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文章&lt;/a&gt;
做出了详细的说明，pause 容器的作用可以从这个例子中看出，首先见下图：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pause-container/pause-container.png&#34; data-img=&#34;/book/kubernetes-handbook/objects/pause-container/pause-container.png&#34; data-width=&#34;1598&#34; data-height=&#34;948&#34; alt=&#34;image&#34; data-caption=&#34;Pause 容器示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Pause 容器示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们首先在节点上运行一个 pause 容器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -d --name pause -p 8880:80 --ipc&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;shareable jimmysong/pause-amd64:3.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再运行一个 nginx 容器，nginx 将为 &lt;code&gt;localhost:2368&lt;/code&gt; 创建一个代理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; nginx.conf
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;error_log stderr;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;events { worker_connections  1024; }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;http {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    access_log /dev/stdout combined;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    server {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        listen 80 default_server;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        server_name example.com www.example.com;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        location / {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;            proxy_pass http://127.0.0.1:2368;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker run -d --name nginx -v &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;/nginx.conf:/etc/nginx/nginx.conf --net&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause --ipc&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause --pid&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause nginx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再为 &lt;a href=&#34;https://github.com/TryGhost/Ghost&#34; title=&#34;ghost&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ghost&lt;/a&gt;
 创建一个应用容器，这是一款博客软件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker run -d --name ghost --net&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause --ipc&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause --pid&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;container:pause ghost
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在访问 http://localhost:8880/ 就可以看到 ghost 博客的界面了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pause 容器将内部的 80 端口映射到宿主机的 8880 端口，pause 容器在宿主机上设置好了网络 namespace 后，nginx 容器加入到该网络 namespace 中，我们看到 nginx 容器启动的时候指定了 &lt;code&gt;--net=container:pause&lt;/code&gt;，ghost 容器同样加入到了该网络 namespace 中，这样三个容器就共享了网络，互相之间就可以使用 &lt;code&gt;localhost&lt;/code&gt; 直接通信，&lt;code&gt;--ipc=contianer:pause --pid=container:pause&lt;/code&gt; 就是三个容器处于同一个 namespace 中，init 进程为 &lt;code&gt;pause&lt;/code&gt;，这时我们进入到 ghost 容器中查看进程情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ps aux&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;  0.0  0.0   &lt;span class=&#34;m&#34;&gt;1024&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; ?        Ss   13:49   0:00 /pause
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root         &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;  0.0  0.1  &lt;span class=&#34;m&#34;&gt;32432&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;5736&lt;/span&gt; ?        Ss   13:51   0:00 nginx: master p
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemd+     &lt;span class=&#34;m&#34;&gt;9&lt;/span&gt;  0.0  0.0  &lt;span class=&#34;m&#34;&gt;32980&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;3304&lt;/span&gt; ?        S    13:51   0:00 nginx: worker p
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;node        &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;  0.3  2.0 &lt;span class=&#34;m&#34;&gt;1254200&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;83788&lt;/span&gt; ?       Ssl  13:53   0:03 node current/in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root        &lt;span class=&#34;m&#34;&gt;79&lt;/span&gt;  0.1  0.0   &lt;span class=&#34;m&#34;&gt;4336&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;812&lt;/span&gt; pts/0    Ss   14:09   0:00 sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root        &lt;span class=&#34;m&#34;&gt;87&lt;/span&gt;  0.0  0.0  &lt;span class=&#34;m&#34;&gt;17500&lt;/span&gt;  &lt;span class=&#34;m&#34;&gt;2080&lt;/span&gt; pts/0    R+   14:10   0:00 ps aux
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 ghost 容器中同时可以看到 pause 和 nginx 容器的进程，并且 pause 容器的 PID 是 1。而在 Kubernetes 中容器的 PID=1 的进程即为容器本身的业务进程。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ianlewis.org/en/almighty-pause-container&#34; title=&#34;The Almighty Pause Container - ianlewis.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Almighty Pause Container - ianlewis.org&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://o-my-chenjian.com/2017/10/17/The-Pause-Container-Of-Kubernetes/&#34; title=&#34;Kubernetes 之 Pause 容器 - o-my-chenjian.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 之 Pause 容器 - o-my-chenjian.com&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>附录 D：命名空间示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/d/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/d/</guid>
      <description>
        
        
        &lt;p&gt;下面的例子是为每个团队或用户组，可以使用 kubectl 命令或 YAML 文件创建一个 Kubernetes 命名空间。应避免使用任何带有 &lt;code&gt;kube&lt;/code&gt; 前缀的名称，因为它可能与 Kubernetes 系统保留的命名空间相冲突。&lt;/p&gt;
&lt;p&gt;Kubectl 命令来创建一个命名空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create namespace &amp;lt;insert-namespace-name-here&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要使用 YAML 文件创建命名空间，创建一个名为 my-namespace.yaml 的新文件，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;insert-namespace-name-here&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用命名空间，使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create –f ./my-namespace.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要在现有的命名空间创建新的 Pod，请切换到所需的命名空间：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl config use-context &amp;lt;insert-namespace-here&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用新的 Deployment，使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f deployment.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，也可以用以下方法将命名空间添加到 kubectl 命令中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f deployment.yaml --namespace&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;lt;insert-namespace-here&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或在 YAML 声明中的元数据下指定 &lt;code&gt;namespace：&amp;lt;insert-namespace-here&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一旦创建，资源不能在命名空间之间移动。必须删除该资源，然后在新的命名空间中创建。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pod 安全策略</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-security-policy/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-security-policy/</guid>
      <description>
        
        
        &lt;p&gt;&lt;code&gt;PodSecurityPolicy&lt;/code&gt; 类型的对象能够控制，是否可以向 Pod 发送请求，该 Pod 能够影响被应用到 Pod 和容器的 &lt;code&gt;SecurityContext&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什么是-pod-安全策略&#34;&gt;什么是 Pod 安全策略？&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Pod 安全策略&lt;/em&gt; 是集群级别的资源，它能够控制 Pod 运行的行为，以及它具有访问什么的能力。 &lt;code&gt;PodSecurityPolicy&lt;/code&gt;对象定义了一组条件，指示 Pod 必须按系统所能接受的顺序运行。它们允许管理员控制如下方面：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;控制面&lt;/th&gt;
&lt;th&gt;字段名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;已授权容器的运行&lt;/td&gt;
&lt;td&gt;&lt;code&gt;privileged&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;为容器添加默认的一组能力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;defaultAddCapabilities&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;为容器去掉某些能力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;requiredDropCapabilities&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器能够请求添加某些能力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;allowedCapabilities&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制卷类型的使用&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#controlling-volumes&#34; title=&#34;&amp;lt;code&amp;gt;volumes&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;volumes&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机网络的使用&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-network&#34; title=&#34;&amp;lt;code&amp;gt;hostNetwork&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;hostNetwork&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机端口的使用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hostPorts&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机 PID namespace 的使用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hostPID&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机 IPC namespace 的使用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hostIPC&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机路径的使用&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowed-host-paths&#34; title=&#34;&amp;lt;code&amp;gt;allowedHostPaths&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;allowedHostPaths&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器的 SELinux 上下文&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux&#34; title=&#34;&amp;lt;code&amp;gt;seLinux&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;seLinux&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户 ID&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#runasuser&#34; title=&#34;&amp;lt;code&amp;gt;runAsUser&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;runAsUser&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置允许的补充组&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#supplementalgroups&#34; title=&#34;&amp;lt;code&amp;gt;supplementalGroups&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;supplementalGroups&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分配拥有 Pod 数据卷的 FSGroup&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#fsgroup&#34; title=&#34;&amp;lt;code&amp;gt;fsGroup&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;fsGroup&lt;/code&gt;&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;必须使用一个只读的 root 文件系统&lt;/td&gt;
&lt;td&gt;&lt;code&gt;readOnlyRootFilesystem&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;Pod 安全策略&lt;/em&gt; 由设置和策略组成，它们能够控制 Pod 访问的安全特征。这些设置分为如下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;基于布尔值控制&lt;/em&gt;：这种类型的字段默认为最严格限制的值。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;基于被允许的值集合控制&lt;/em&gt;：这种类型的字段会与这组值进行对比，以确认值被允许。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;基于策略控制&lt;/em&gt;：设置项通过一种策略提供的机制来生成该值，这种机制能够确保指定的值落在被允许的这组值中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;runasuser&#34;&gt;RunAsUser&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;MustRunAs&lt;/em&gt; - 必须配置一个 &lt;code&gt;range&lt;/code&gt;。使用该范围内的第一个值作为默认值。验证是否不在配置的该范围内。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;MustRunAsNonRoot&lt;/em&gt; - 要求提交的 Pod 具有非零 &lt;code&gt;runAsUser&lt;/code&gt; 值，或在镜像中定义了 &lt;code&gt;USER&lt;/code&gt; 环境变量。不提供默认值。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RunAsAny&lt;/em&gt; - 没有提供默认值。允许指定任何 &lt;code&gt;runAsUser&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;selinux&#34;&gt;SELinux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;MustRunAs&lt;/em&gt; - 如果没有使用预分配的值，必须配置 &lt;code&gt;seLinuxOptions&lt;/code&gt;。默认使用 &lt;code&gt;seLinuxOptions&lt;/code&gt;。验证 &lt;code&gt;seLinuxOptions&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RunAsAny&lt;/em&gt; - 没有提供默认值。允许任意指定的 &lt;code&gt;seLinuxOptions&lt;/code&gt; ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;supplementalgroups&#34;&gt;SupplementalGroups&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;MustRunAs&lt;/em&gt; - 至少需要指定一个范围。默认使用第一个范围的最小值。验证所有范围的值。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RunAsAny&lt;/em&gt; - 没有提供默认值。允许任意指定的 &lt;code&gt;supplementalGroups&lt;/code&gt; ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fsgroup&#34;&gt;FSGroup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;MustRunAs&lt;/em&gt; - 至少需要指定一个范围。默认使用第一个范围的最小值。验证在第一个范围内的第一个 ID。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RunAsAny&lt;/em&gt; - 没有提供默认值。允许任意指定的 &lt;code&gt;fsGroup&lt;/code&gt; ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;控制卷&#34;&gt;控制卷&lt;/h3&gt;
&lt;p&gt;通过设置 PSP 卷字段，能够控制具体卷类型的使用。当创建一个卷的时候，与该字段相关的已定义卷可以允许设置如下值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;azureFile&lt;/li&gt;
&lt;li&gt;azureDisk&lt;/li&gt;
&lt;li&gt;flocker&lt;/li&gt;
&lt;li&gt;flexVolume&lt;/li&gt;
&lt;li&gt;hostPath&lt;/li&gt;
&lt;li&gt;emptyDir&lt;/li&gt;
&lt;li&gt;gcePersistentDisk&lt;/li&gt;
&lt;li&gt;awsElasticBlockStore&lt;/li&gt;
&lt;li&gt;gitRepo&lt;/li&gt;
&lt;li&gt;secret&lt;/li&gt;
&lt;li&gt;nfs&lt;/li&gt;
&lt;li&gt;iscsi&lt;/li&gt;
&lt;li&gt;glusterfs&lt;/li&gt;
&lt;li&gt;persistentVolumeClaim&lt;/li&gt;
&lt;li&gt;rbd&lt;/li&gt;
&lt;li&gt;cinder&lt;/li&gt;
&lt;li&gt;cephFS&lt;/li&gt;
&lt;li&gt;downwardAPI&lt;/li&gt;
&lt;li&gt;fc&lt;/li&gt;
&lt;li&gt;configMap&lt;/li&gt;
&lt;li&gt;vsphereVolume&lt;/li&gt;
&lt;li&gt;quobyte&lt;/li&gt;
&lt;li&gt;photonPersistentDisk&lt;/li&gt;
&lt;li&gt;projected&lt;/li&gt;
&lt;li&gt;portworxVolume&lt;/li&gt;
&lt;li&gt;scaleIO&lt;/li&gt;
&lt;li&gt;storageos&lt;/li&gt;
&lt;li&gt;* (allow all volumes)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对新的 PSP，推荐允许的卷的最小集合包括：configMap、downwardAPI、emptyDir、persistentVolumeClaim、secret 和 projected。&lt;/p&gt;
&lt;h3 id=&#34;主机网络&#34;&gt;主机网络&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;HostPorts&lt;/em&gt;，默认为 &lt;code&gt;empty&lt;/code&gt;。&lt;code&gt;HostPortRange&lt;/code&gt; 列表通过 &lt;code&gt;min&lt;/code&gt;(包含) and &lt;code&gt;max&lt;/code&gt;(包含) 来定义，指定了被允许的主机端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;允许的主机路径&#34;&gt;允许的主机路径&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;AllowedHostPaths&lt;/em&gt; 是一个被允许的主机路径前缀的白名单。空值表示所有的主机路径都可以使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;包含 &lt;code&gt;PodSecurityPolicy&lt;/code&gt; 的 &lt;em&gt;许可控制&lt;/em&gt;，允许控制集群资源的创建和修改，基于这些资源在集群范围内被许可的能力。&lt;/p&gt;
&lt;p&gt;许可使用如下的方式为 Pod 创建最终的安全上下文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检索所有可用的 PSP。&lt;/li&gt;
&lt;li&gt;生成在请求中没有指定的安全上下文设置的字段值。&lt;/li&gt;
&lt;li&gt;基于可用的策略，验证最终的设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果某个策略能够匹配上，该 Pod 就被接受。如果请求与 PSP 不匹配，则 Pod 被拒绝。&lt;/p&gt;
&lt;p&gt;Pod 必须基于 PSP 验证每个字段。&lt;/p&gt;
&lt;h2 id=&#34;创建-pod-安全策略&#34;&gt;创建 Pod 安全策略&lt;/h2&gt;
&lt;p&gt;下面是一个 Pod 安全策略的例子，所有字段的设置都被允许：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;extensions/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PodSecurityPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;permissive&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seLinux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;supplementalGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostPorts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下载示例文件可以创建该策略，然后执行如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create -f ./psp.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;podsecuritypolicy &lt;span class=&#34;s2&#34;&gt;&amp;#34;permissive&amp;#34;&lt;/span&gt; created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;获取-pod-安全策略列表&#34;&gt;获取 Pod 安全策略列表&lt;/h2&gt;
&lt;p&gt;获取已存在策略列表，使用 &lt;code&gt;kubectl get&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get psp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME        PRIV   CAPS  SELINUX   RUNASUSER         FSGROUP   SUPGROUP  READONLYROOTFS  VOLUMES
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;permissive  &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;    RunAsAny  RunAsAny          RunAsAny  RunAsAny  &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;*&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;privileged  &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;    RunAsAny  RunAsAny          RunAsAny  RunAsAny  &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;*&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;restricted  &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;    RunAsAny  MustRunAsNonRoot  RunAsAny  RunAsAny  &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;emptyDir secret downwardAPI configMap persistentVolumeClaim projected&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;修改-pod-安全策略&#34;&gt;修改 Pod 安全策略&lt;/h2&gt;
&lt;p&gt;通过交互方式修改策略，使用 &lt;code&gt;kubectl edit&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl edit psp permissive
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该命令将打开一个默认文本编辑器，在这里能够修改策略。&lt;/p&gt;
&lt;h2 id=&#34;删除-pod-安全策略&#34;&gt;删除 Pod 安全策略&lt;/h2&gt;
&lt;p&gt;一旦不再需要一个策略，很容易通过 &lt;code&gt;kubectl&lt;/code&gt; 删除它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl delete psp permissive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;podsecuritypolicy &lt;span class=&#34;s2&#34;&gt;&amp;#34;permissive&amp;#34;&lt;/span&gt; deleted
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;启用-pod-安全策略&#34;&gt;启用 Pod 安全策略&lt;/h2&gt;
&lt;p&gt;为了能够在集群中使用 Pod 安全策略，必须确保如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用 API 类型 &lt;code&gt;extensions/v1beta1/podsecuritypolicy&lt;/code&gt;（仅对 1.6 之前的版本）&lt;/li&gt;
&lt;li&gt;启用许可控制器 &lt;code&gt;PodSecurityPolicy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义自己的策略&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用-rbac&#34;&gt;使用 RBAC&lt;/h2&gt;
&lt;p&gt;在 Kubernetes 1.5 或更新版本，可以使用 PodSecurityPolicy 来控制，对基于用户角色和组的已授权容器的访问。访问不同的 PodSecurityPolicy 对象，可以基于认证来控制。基于 Deployment、ReplicaSet 等创建的 Pod，限制访问 PodSecurityPolicy 对象，&lt;a href=&#34;https://kubernetes.io/docs/admin/kube-controller-manager/&#34; title=&#34;Controller Manager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Controller Manager&lt;/a&gt;
 必须基于安全 API 端口运行，并且不能够具有超级用户权限。&lt;/p&gt;
&lt;p&gt;PodSecurityPolicy 认证使用所有可用的策略，包括创建 Pod 的用户，Pod 上指定的服务账户（service acount）。当 Pod 基于 Deployment、ReplicaSet 创建时，它是创建 Pod 的 Controller Manager，所以如果基于非安全 API 端口运行，允许所有的 PodSecurityPolicy 对象，并且不能够有效地实现细分权限。用户访问给定的 PSP 策略有效，仅当是直接部署 Pod 的情况。当直接部署 Pod 时，应用 PodSecurityPolicy 控制基于角色和组的已授权容器的访问。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 E：网络策略示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/e/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/e/</guid>
      <description>
        
        
        &lt;p&gt;网络策略根据使用的网络插件而不同。下面是一个网络策略的例子，参考 &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/&#34; title=&#34;Kubernetes 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档&lt;/a&gt;
将 nginx 服务的访问限制在带有标签访问的 Pod 上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NetworkPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-access-nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;prod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#这可以是任何一个命名空间，或者在不使用命名空间的情况下省略。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;access&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新的 &lt;code&gt;NetworkPolicy&lt;/code&gt; 可以通过以下方式应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f policy.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认的拒绝所有入口的策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NetworkPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deny-all-ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;policyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;Ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个默认的拒绝所有出口的策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NetworkPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deny-all-egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;policyType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;Egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Pod 的生命周期</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-lifecycle/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-lifecycle/</guid>
      <description>
        
        
        &lt;p&gt;本文讲解的是 Kubernetes  中 Pod 的生命周期，包括生命周期的不同阶段、存活和就绪探针、重启策略等。&lt;/p&gt;
&lt;h2 id=&#34;pod-phase&#34;&gt;Pod phase&lt;/h2&gt;
&lt;p&gt;Pod 的 &lt;code&gt;status&lt;/code&gt; 字段是一个 PodStatus 对象，PodStatus 中有一个 &lt;code&gt;phase&lt;/code&gt; 字段。&lt;/p&gt;
&lt;p&gt;Pod 的相位（phase）是 Pod 在其生命周期中的简单宏观概述。该字段并不是对容器或 Pod 的综合汇总，也不是为了做为综合状态机。&lt;/p&gt;
&lt;p&gt;Pod 相位的数量和含义是严格指定的。除了本文档中列举的状态外，不应该再假定 Pod 有其他的 &lt;code&gt;phase&lt;/code&gt; 值。&lt;/p&gt;
&lt;p&gt;下面是 &lt;code&gt;phase&lt;/code&gt; 可能的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。&lt;/li&gt;
&lt;li&gt;运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。&lt;/li&gt;
&lt;li&gt;成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。&lt;/li&gt;
&lt;li&gt;失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。&lt;/li&gt;
&lt;li&gt;未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是 Pod 的生命周期示意图，从图中可以看到 Pod 状态的变化。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/objects/pod-lifecycle/kubernetes-pod-life-cycle.jpg&#34; data-img=&#34;/book/kubernetes-handbook/objects/pod-lifecycle/kubernetes-pod-life-cycle.jpg&#34; data-width=&#34;1886&#34; data-height=&#34;638&#34; alt=&#34;image&#34; data-caption=&#34;Pod 的生命周期示意图（图片来自网络）&#34;&gt;
    
  
  &lt;figcaption&gt;Pod 的生命周期示意图（图片来自网络）&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;pod-状态&#34;&gt;Pod 状态&lt;/h2&gt;
&lt;p&gt;Pod 有一个 PodStatus 对象，其中包含一个 PodCondition 数组。PodCondition 数组的每个元素都有一个 &lt;code&gt;type&lt;/code&gt; 字段和一个 &lt;code&gt;status&lt;/code&gt; 字段。&lt;code&gt;type&lt;/code&gt; 字段是字符串，可能的值有 PodScheduled、Ready、Initialized、Unschedulable 和 ContainersReady。&lt;code&gt;status&lt;/code&gt; 字段是一个字符串，可能的值有 True、False 和 Unknown。&lt;/p&gt;
&lt;h2 id=&#34;容器探针&#34;&gt;容器探针&lt;/h2&gt;
&lt;p&gt;探针是由 &lt;a href=&#34;https://kubernetes.io/docs/admin/kubelet/&#34; title=&#34;kubelet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubelet&lt;/a&gt;
 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 &lt;a href=&#34;https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler&#34; title=&#34;Handler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Handler&lt;/a&gt;
。有三种类型的处理程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。&lt;/li&gt;
&lt;li&gt;TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。&lt;/li&gt;
&lt;li&gt;HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次探测都将获得以下三种结果之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成功：容器通过了诊断。&lt;/li&gt;
&lt;li&gt;失败：容器未通过诊断。&lt;/li&gt;
&lt;li&gt;未知：诊断失败，因此不会采取任何行动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;livenessProbe&lt;/code&gt;：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy&#34; title=&#34;重启策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重启策略&lt;/a&gt;
 的影响。如果容器不提供存活探针，则默认状态为 &lt;code&gt;Success&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readinessProbe&lt;/code&gt;：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 &lt;code&gt;Failure&lt;/code&gt;。如果容器不提供就绪探针，则默认状态为 &lt;code&gt;Success&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;该什么时候使用存活liveness和就绪readiness探针&#34;&gt;该什么时候使用存活（liveness）和就绪（readiness）探针？&lt;/h3&gt;
&lt;p&gt;如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针; kubelet 将根据 Pod 的&lt;code&gt;restartPolicy&lt;/code&gt; 自动执行正确的操作。&lt;/p&gt;
&lt;p&gt;如果您希望容器在探测失败时被杀死并重新启动，那么请指定一个存活探针，并指定&lt;code&gt;restartPolicy&lt;/code&gt; 为 Always 或 OnFailure。&lt;/p&gt;
&lt;p&gt;如果要仅在探测成功时才开始向 Pod 发送流量，请指定就绪探针。在这种情况下，就绪探针可能与存活探针相同，但是 spec 中的就绪探针的存在意味着 Pod 将在没有接收到任何流量的情况下启动，并且只有在探针探测成功后才开始接收流量。&lt;/p&gt;
&lt;p&gt;如果您希望容器能够自行维护，您可以指定一个就绪探针，该探针检查与存活探针不同的端点。&lt;/p&gt;
&lt;p&gt;请注意，如果您只想在 Pod 被删除时能够排除请求，则不一定需要使用就绪探针；在删除 Pod 时，Pod 会自动将自身置于未完成状态，无论就绪探针是否存在。当等待 Pod 中的容器停止时，Pod 仍处于未完成状态。&lt;/p&gt;
&lt;h3 id=&#34;readinessgates&#34;&gt;readinessGates&lt;/h3&gt;
&lt;p&gt;自 Kubernetes 1.14（该版本 &lt;code&gt;readinessGates&lt;/code&gt; GA，在 1.11 版本是为 alpha）起默认支持 Pod 就绪检测机制扩展。&lt;/p&gt;
&lt;p&gt;应用程序可以向 PodStatus 注入额外的反馈或信号：Pod readiness。要使用这个功能，请在 PodSpec 中设置 &lt;code&gt;readinessGates&lt;/code&gt; 来指定 kubelet 评估 Pod readiness 的附加条件列表。&lt;/p&gt;
&lt;p&gt;Readiness gates 由 Pod 的 &lt;code&gt;status.condition&lt;/code&gt; 字段的当前状态决定。如果 Kubernetes 在 Pod 的 &lt;code&gt;status.conditions&lt;/code&gt; 字段中找不到这样的条件，则该条件的状态默认为 &amp;ldquo;False&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;下面是一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readinessGates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;conditionType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;www.example.com/feature-1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;conditions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ready                             &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 内置的 Pod 状态&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;False&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lastProbeTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2018-01-01T00:00:00Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;www.example.com/feature-1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 附加的额外的 Pod 状态&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;False&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lastProbeTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2018-01-01T00:00:00Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerStatuses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker://abcd...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您添加的 Pod 条件的名称必须符合 Kubernetes 的 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set&#34; title=&#34;label key 格式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;label key 格式&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;只有到 Pod 中的所有容器状态都是 Ready，且 Pod 附加的额外状态检测的 &lt;code&gt;readinessGates&lt;/code&gt; 条件也是 Ready 的时候，Pod 的状态才是 Ready。&lt;/p&gt;
&lt;h2 id=&#34;pod-和容器状态&#34;&gt;Pod 和容器状态&lt;/h2&gt;
&lt;p&gt;有关 Pod 容器状态的详细信息，请参阅 PodStatus 和 ContainerStatus。请注意，报告的 Pod 状态信息取决于当前的 ContainerState。&lt;/p&gt;
&lt;h2 id=&#34;重启策略&#34;&gt;重启策略&lt;/h2&gt;
&lt;p&gt;PodSpec 中有一个 &lt;code&gt;restartPolicy&lt;/code&gt; 字段，可能的值为 Always、OnFailure 和 Never。默认为 Always。 &lt;code&gt;restartPolicy&lt;/code&gt; 适用于 Pod 中的所有容器。&lt;code&gt;restartPolicy&lt;/code&gt; 仅指通过同一节点上的 kubelet 重新启动容器。失败的容器由 kubelet 以五分钟为上限的指数退避延迟（10 秒，20 秒，40 秒&amp;hellip;）重新启动，并在成功执行十分钟后重置。如 &lt;a href=&#34;https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof&#34; title=&#34;Pod 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pod 文档&lt;/a&gt;
 中所述，一旦绑定到一个节点，Pod 将永远不会重新绑定到另一个节点。&lt;/p&gt;
&lt;h2 id=&#34;pod-的生命&#34;&gt;Pod 的生命&lt;/h2&gt;
&lt;p&gt;一般来说，Pod 不会消失，直到人为销毁他们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 &lt;code&gt;phase&lt;/code&gt; 超过一段时间（由 master 确定）的 Pod 将过期并被自动销毁。&lt;/p&gt;
&lt;p&gt;有三种可用的控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/&#34; title=&#34;Job&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Job&lt;/a&gt;
 运行预期会终止的 Pod，例如批量计算。Job 仅适用于重启策略为 &lt;code&gt;OnFailure&lt;/code&gt; 或 &lt;code&gt;Never&lt;/code&gt; 的 Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对预期不会终止的 Pod 使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/&#34; title=&#34;ReplicationController&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ReplicationController&lt;/a&gt;
、&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/&#34; title=&#34;ReplicaSet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ReplicaSet&lt;/a&gt;
 和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34; title=&#34;Deployment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Deployment&lt;/a&gt;
 ，例如 Web 服务器。ReplicationController 仅适用于具有 &lt;code&gt;restartPolicy&lt;/code&gt; 为 Always 的 Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供特定于机器的系统服务，使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/&#34; title=&#34;DaemonSet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DaemonSet&lt;/a&gt;
 为每台机器运行一个 Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这三种类型的控制器都包含一个 PodTemplate。建议创建适当的控制器，让它们来创建 Pod，而不是直接自己创建 Pod。这是因为单独的 Pod 在机器故障的情况下没有办法自动复原，而控制器却可以。&lt;/p&gt;
&lt;p&gt;如果节点死亡或与集群的其余部分断开连接，则 Kubernetes 将应用一个策略将丢失节点上的所有 Pod 的 &lt;code&gt;phase&lt;/code&gt; 设置为 Failed。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;h3 id=&#34;高级-liveness-探针示例&#34;&gt;高级 liveness 探针示例&lt;/h3&gt;
&lt;p&gt;存活探针由 kubelet 来执行，因此所有的请求都在 kubelet 的网络命名空间中进行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;liveness&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;liveness-http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;k8s.gcr.io/liveness&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;livenessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# when &amp;#34;host&amp;#34; is not defined, &amp;#34;PodIP&amp;#34; will be used&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# host: my-host&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# when &amp;#34;scheme&amp;#34; is not defined, &amp;#34;HTTP&amp;#34; scheme will be used. Only &amp;#34;HTTP&amp;#34; and &amp;#34;HTTPS&amp;#34; are allowed&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# scheme: HTTPS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/healthz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;X-Custom-Header&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Awesome&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;liveness&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态示例&#34;&gt;状态示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pod 中只有一个容器并且正在运行。容器成功退出。
&lt;ul&gt;
&lt;li&gt;记录完成事件。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;restartPolicy&lt;/code&gt; 为：
&lt;ul&gt;
&lt;li&gt;Always：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;OnFailure：Pod &lt;code&gt;phase&lt;/code&gt; 变成 Succeeded。&lt;/li&gt;
&lt;li&gt;Never：Pod &lt;code&gt;phase&lt;/code&gt; 变成 Succeeded。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod 中只有一个容器并且正在运行。容器退出失败。
&lt;ul&gt;
&lt;li&gt;记录失败事件。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;restartPolicy&lt;/code&gt; 为：
&lt;ul&gt;
&lt;li&gt;Always：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;OnFailure：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;Never：Pod &lt;code&gt;phase&lt;/code&gt; 变成 Failed。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod 中有两个容器并且正在运行。容器 1 退出失败。
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录失败事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 restartPolicy 为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Always：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;OnFailure：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;Never：不重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有容器 1 没有处于运行状态，并且容器 2 退出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录失败事件。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;restartPolicy&lt;/code&gt; 为：
&lt;ul&gt;
&lt;li&gt;Always：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;OnFailure：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;Never：Pod &lt;code&gt;phase&lt;/code&gt; 变成 Failed。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod 中只有一个容器并处于运行状态。容器运行时内存超出限制：
&lt;ul&gt;
&lt;li&gt;容器以失败状态终止。&lt;/li&gt;
&lt;li&gt;记录 OOM 事件。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;restartPolicy&lt;/code&gt; 为：
&lt;ul&gt;
&lt;li&gt;Always：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;OnFailure：重启容器；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Running。&lt;/li&gt;
&lt;li&gt;Never: 记录失败事件；Pod &lt;code&gt;phase&lt;/code&gt; 仍为 Failed。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod 正在运行，磁盘故障：
&lt;ul&gt;
&lt;li&gt;杀掉所有容器。&lt;/li&gt;
&lt;li&gt;记录适当事件。&lt;/li&gt;
&lt;li&gt;Pod &lt;code&gt;phase&lt;/code&gt; 变成 Failed。&lt;/li&gt;
&lt;li&gt;如果使用控制器来运行，Pod 将在别处重建。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod 正在运行，其节点被分段。
&lt;ul&gt;
&lt;li&gt;节点控制器等待直到超时。&lt;/li&gt;
&lt;li&gt;节点控制器将 Pod &lt;code&gt;phase&lt;/code&gt; 设置为 Failed。&lt;/li&gt;
&lt;li&gt;如果是用控制器来运行，Pod 将在别处重建。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/&#34; title=&#34;Pod lifecycle - kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pod lifecycle - kubernetes.io&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>附录 F：LimitRange 示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/f/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/f/</guid>
      <description>
        
        
        &lt;p&gt;在 Kubernetes 1.10 和更新版本中，&lt;code&gt;LimitRange&lt;/code&gt; 支持被默认启用。下面的 YAML 文件为每个容器指定了一个 &lt;code&gt;LimitRange&lt;/code&gt;，其中有一个默认的请求和限制，以及最小和最大的请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;LimitRange&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cpu-min-max-demo-lr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;limits&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;defaultRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cpu 0.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;LimitRange&lt;/code&gt; 可以应用于命名空间，使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f &amp;lt;example-LimitRange&amp;gt;.yaml --namespace&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;lt;Enter-Namespace&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在应用了这个 &lt;code&gt;LimitRange&lt;/code&gt; 配置的例子后，如果没有指定，命名空间中创建的所有容器都会被分配到默认的 CPU 请求和限制。命名空间中的所有容器的 CPU 请求必须大于或等于最小值，小于或等于最大 CPU 值，否则容器将不会被实例化。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pod Hook</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-hook/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-hook/</guid>
      <description>
        
        
        &lt;p&gt;Pod Hook（钩子）是由 Kubernetes 管理的 kubelet 发起的，当容器中的进程启动前或者容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为 Pod 中的所有容器都配置 hook。&lt;/p&gt;
&lt;p&gt;Hook 的类型包括两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exec：执行一段命令&lt;/li&gt;
&lt;li&gt;HTTP：发送 HTTP 请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考下面的配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;lifecycle-demo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;lifecycle-demo-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lifecycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;postStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/bin/sh&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;echo Hello from the postStart handler&amp;gt; /usr/share/message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;preStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/usr/sbin/nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;quit&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Kubernetes 在容器创建后立即发送 postStart 事件。但是，不能保证在调用容器的入口点之前调用 postStart 处理程序。postStart 处理程序相对于容器的代码异步运行，但 Kubernetes 对容器的管理将被阻止，直到 postStart 处理程序完成。在 postStart 处理程序完成之前，容器的状态不会设置为 RUNNING。&lt;/p&gt;
&lt;p&gt;PreStop 在容器终止之前被同步阻塞调用，常用于在容器结束前优雅的释放资源。&lt;/p&gt;
&lt;p&gt;如果 postStart 或者 preStop hook 失败，将会终止容器。&lt;/p&gt;
&lt;h2 id=&#34;调试-hook&#34;&gt;调试 hook&lt;/h2&gt;
&lt;p&gt;Hook 调用的日志没有暴露给 Pod 的 event，所以只能通过 &lt;code&gt;describe&lt;/code&gt; 命令来获取，如果有错误将可以看到 &lt;code&gt;FailedPostStartHook&lt;/code&gt; 或 &lt;code&gt;FailedPreStopHook&lt;/code&gt; 这样的 event。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/&#34; title=&#34;Attach Handlers to Container Lifecycle Events - kuberentes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Attach Handlers to Container Lifecycle Events - kuberentes.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/&#34; title=&#34;Container Lifecycle Hooks - kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Lifecycle Hooks - kubernetes.io&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>附录 G：ResourceQuota 示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/g/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/g/</guid>
      <description>
        
        
        &lt;p&gt;通过将 YAML 文件应用于命名空间或在 Pod 的配置文件中指定要求来创建 &lt;code&gt;ResourceQuota&lt;/code&gt; 对象，以限制命名空间内的总体资源使用。下面的例子是基于 &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/&#34; title=&#34;Kubernetes 官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官方文档&lt;/a&gt;
的一个命名空间的配置文件示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ResourceQuota&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-cpu-mem-resourcequota&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests.cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests.memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;1Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits.cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits.memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;2Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以这样应用这个 &lt;code&gt;ResourceQuota&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f example-cpu-mem-resourcequota.yaml -- &lt;span class=&#34;nv&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;lt;insert-namespace-here&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 &lt;code&gt;ResourceQuota&lt;/code&gt; 对所选择的命名空间施加了以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个容器都必须有一个内存请求、内存限制、CPU 请求和 CPU 限制。&lt;/li&gt;
&lt;li&gt;所有容器的总内存请求不应超过 1 GiB&lt;/li&gt;
&lt;li&gt;所有容器的总内存限制不应超过 2 GiB&lt;/li&gt;
&lt;li&gt;所有容器的 CPU 请求总量不应超过 1 个 CPU&lt;/li&gt;
&lt;li&gt;所有容器的总 CPU 限制不应超过 2 个 CPU&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Pod Preset</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-preset/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-preset/</guid>
      <description>
        
        
        &lt;p&gt;Preset 就是预设，有时候想要让一批容器在启动的时候就注入一些信息，比如 secret、volume、volume mount 和环境变量，而又不想一个一个的改这些 Pod 的 template，这时候就可以用到 PodPreset 这个资源对象了。&lt;/p&gt;
&lt;p&gt;本页是关于 PodPreset 的概述，该对象用来在 Pod 创建的时候向 Pod 中注入某些特定信息。该信息可以包括 secret、volume、volume mount 和环境变量。&lt;/p&gt;
&lt;h2 id=&#34;理解-pod-preset&#34;&gt;理解 Pod Preset&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pod Preset&lt;/code&gt; 是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。&lt;/p&gt;
&lt;p&gt;您可以使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors&#34; title=&#34;label selector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;label selector&lt;/a&gt;
 来指定为哪些 Pod 应用 Pod Preset。&lt;/p&gt;
&lt;p&gt;使用 Pod Preset 使得 pod 模板的作者可以不必为每个 Pod 明确提供所有信息。这样一来，pod 模板的作者就不需要知道关于该服务的所有细节。&lt;/p&gt;
&lt;p&gt;关于该背景的更多信息，请参阅 PodPreset 的设计方案。&lt;/p&gt;
&lt;h2 id=&#34;如何工作&#34;&gt;如何工作&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了一个准入控制器（&lt;code&gt;PodPreset&lt;/code&gt;），当其启用时，Pod Preset 会将应用创建请求传入到该控制器上。当有 Pod 创建请求发生时，系统将执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检索所有可用的 &lt;code&gt;PodPresets&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;检查 PodPreset 标签选择器上的标签，看看其是否能够匹配正在创建的 Pod 上的标签。&lt;/li&gt;
&lt;li&gt;尝试将由 &lt;code&gt;PodPreset&lt;/code&gt; 定义的各种资源合并到正在创建的 Pod 中。&lt;/li&gt;
&lt;li&gt;出现错误时，在该 Pod 上引发记录合并错误的事件，PodPreset &lt;em&gt;不会&lt;/em&gt;注入任何资源到创建的 Pod 中。&lt;/li&gt;
&lt;li&gt;注释刚生成的修改过的 Pod spec，以表明它已被 PodPreset 修改过。注释的格式为 &lt;code&gt;podpreset.admission.kubernetes.io/podpreset-&amp;lt;pod-preset name&amp;gt;&amp;quot;: &amp;quot;&amp;lt;resource version&amp;gt;&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个 Pod 可以匹配零个或多个 Pod Prestet；并且每个 &lt;code&gt;PodPreset&lt;/code&gt; 可以应用于零个或多个 Pod。 &lt;code&gt;PodPreset&lt;/code&gt; 应用于一个或多个 Pod 时，Kubernetes 会修改 Pod Spec。对于 &lt;code&gt;Env&lt;/code&gt;、&lt;code&gt;EnvFrom&lt;/code&gt; 和 &lt;code&gt;VolumeMounts&lt;/code&gt; 的更改，Kubernetes 修改 Pod 中所有容器的容器 spec；对于 &lt;code&gt;Volume&lt;/code&gt; 的更改，Kubernetes 修改 Pod Spec。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Pod Preset 可以在适当的时候修改 Pod spec 中的 &lt;code&gt;spec.containers&lt;/code&gt; 字段。Pod Preset 中的资源定义将&lt;em&gt;不会&lt;/em&gt;应用于 &lt;code&gt;initContainers&lt;/code&gt; 字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;禁用特定-pod-的-pod-preset&#34;&gt;禁用特定 Pod 的 Pod Preset&lt;/h3&gt;
&lt;p&gt;在某些情况下，您可能不希望 Pod 被任何 Pod Preset 所改变。在这些情况下，您可以在 Pod 的 Pod Spec 中添加注释：&lt;code&gt;podpreset.admission.kubernetes.io/exclude：&amp;quot;true&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;启用-pod-preset&#34;&gt;启用 Pod Preset&lt;/h2&gt;
&lt;p&gt;为了在群集中使用 Pod Preset，您必须确保以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;您已启用 &lt;code&gt;settings.k8s.io/v1alpha1/podpreset&lt;/code&gt; API 类型。例如，可以通过在 API server 的 &lt;code&gt;--runtime-config&lt;/code&gt; 选项中包含 &lt;code&gt;settings.k8s.io/v1alpha1=true&lt;/code&gt; 来完成此操作。&lt;/li&gt;
&lt;li&gt;您已启用 &lt;code&gt;PodPreset&lt;/code&gt; 准入控制器。一种方法是将 &lt;code&gt;PodPreset&lt;/code&gt; 包含在为 API server 指定的 &lt;code&gt;--admission-control&lt;/code&gt; 选项值中。&lt;/li&gt;
&lt;li&gt;您已经在要使用的命名空间中通过创建 &lt;code&gt;PodPreset&lt;/code&gt; 对象来定义 &lt;code&gt;PodPreset&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>附录 H：加密示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/h/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/h/</guid>
      <description>
        
        
        &lt;p&gt;要对秘密数据进行静态加密，下面的加密配置文件提供了一个例子，以指定所需的加密类型和加密密钥。将加密密钥存储在加密文件中只能稍微提高安全性。Secret 将被加密，但密钥将在 &lt;code&gt;EncryptionConfiguration&lt;/code&gt; 文件中被访问。这个例子是基于 &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&#34; title=&#34;Kubernetes 的官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 的官方文档&lt;/a&gt;
。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apiserver.config.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;EncryptionConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;secrets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;providers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;aescbc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;key1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;base 64 encoded secret&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;identity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要使用该加密文件进行静态加密，请在重启 API 服务器时设置 &lt;code&gt;--encryption-provider-config&lt;/code&gt; 标志，并注明配置文件的位置。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pod 中断与 PDB（Pod 中断预算）</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/objects/pod-disruption-budget/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/objects/pod-disruption-budget/</guid>
      <description>
        
        
        &lt;p&gt;这篇文档适用于要构建高可用应用程序的所有者，因此他们需要了解 Pod 可能发生什么类型的中断。也适用于要执行自动集群操作的集群管理员，如升级和集群自动扩容。&lt;/p&gt;
&lt;h2 id=&#34;自愿中断和非自愿中断&#34;&gt;自愿中断和非自愿中断&lt;/h2&gt;
&lt;p&gt;Pod 不会消失，直到有人（人类或控制器）将其销毁，或者当出现不可避免的硬件或系统软件错误。&lt;/p&gt;
&lt;p&gt;我们把这些不可避免的情况称为应用的非自愿性中断。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后端节点物理机的硬件故障&lt;/li&gt;
&lt;li&gt;集群管理员错误地删除虚拟机（实例）&lt;/li&gt;
&lt;li&gt;云提供商或管理程序故障使虚拟机消失&lt;/li&gt;
&lt;li&gt;内核恐慌（kernel panic）&lt;/li&gt;
&lt;li&gt;节点由于集群网络分区而从集群中消失&lt;/li&gt;
&lt;li&gt;由于节点&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource&#34; title=&#34;资源不足&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源不足&lt;/a&gt;
而将容器逐出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除资源不足的情况外，大多数用户应该都熟悉以下这些情况；它们不是特定于 Kubernetes 的。&lt;/p&gt;
&lt;p&gt;我们称这些情况为”自愿中断“。包括由应用程序所有者发起的操作和由集群管理员发起的操作。典型的应用程序所有者操作包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除管理该 pod 的 Deployment 或其他控制器&lt;/li&gt;
&lt;li&gt;更新了 Deployment 的 pod 模板导致 pod 重启&lt;/li&gt;
&lt;li&gt;直接删除 pod（意外删除）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群管理员操作包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs//tasks/administer-cluster/safely-drain-node&#34; title=&#34;排空（drain）节点&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;排空（drain）节点&lt;/a&gt;
进行修复或升级。&lt;/li&gt;
&lt;li&gt;从集群中排空节点以缩小集群。&lt;/li&gt;
&lt;li&gt;从节点中移除一个 pod，以允许其他 pod 使用该节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些操作可能由集群管理员直接执行，也可能由集群管理员或集群托管提供商自动执行。&lt;/p&gt;
&lt;p&gt;询问您的集群管理员或咨询您的云提供商或发行文档，以确定是否为您的集群启用了任何自动中断源。如果没有启用，您可以跳过创建 Pod Disruption Budget（Pod 中断预算）。&lt;/p&gt;
&lt;h2 id=&#34;处理中断&#34;&gt;处理中断&lt;/h2&gt;
&lt;p&gt;以下是一些减轻非自愿性中断的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保您的 pod &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-ram-container&#34; title=&#34;请求所需的资源&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;请求所需的资源&lt;/a&gt;
。&lt;/li&gt;
&lt;li&gt;如果您需要更高的可用性，请复制您的应用程序。 （了解有关运行复制的&lt;a href=&#34;https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment&#34; title=&#34;无状态&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无状态&lt;/a&gt;
和&lt;a href=&#34;https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application&#34; title=&#34;有状态&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有状态&lt;/a&gt;
应用程序的信息。）&lt;/li&gt;
&lt;li&gt;为了在运行复制应用程序时获得更高的可用性，请跨机架（使用&lt;a href=&#34;https://kubernetes.io/docs/user-guide/node-selection/#inter-pod-affinity-and-anti-affinity-beta-feature&#34; title=&#34;反亲和性&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;反亲和性&lt;/a&gt;
）或跨区域（如果使用多区域集群）分布应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自愿中断的频率各不相同。在 Kubernetes 集群上，根本没有自愿的中断。但是，您的集群管理员或托管提供商可能会运行一些导致自愿中断的附加服务。例如，节点软件更新可能导致自愿更新。另外，集群（节点）自动缩放的某些实现可能会导致碎片整理和紧缩节点的自愿中断。您的集群管理员或主机提供商应该已经记录了期望的自愿中断级别（如果有的话）。&lt;/p&gt;
&lt;p&gt;Kubernetes 提供的功能可以满足在频繁地自动中断的同时运行高可用的应用程序。我们称之为“中断预算”。&lt;/p&gt;
&lt;h2 id=&#34;中断预算的工作原理&#34;&gt;中断预算的工作原理&lt;/h2&gt;
&lt;p&gt;应用程序所有者可以为每个应用程序创建一个 &lt;code&gt;PodDisruptionBudget&lt;/code&gt; 对象（PDB）。PDB 将限制在同一时间自愿中断的复制应用程序中宕机的 Pod 的数量。例如，基于定额的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web 前端可能希望确保提供负载的副本的数量永远不会低于总数的某个百分比。&lt;/p&gt;
&lt;p&gt;集群管理器和托管提供商应使用遵循 &lt;code&gt;Pod Disruption Budgets&lt;/code&gt; 的工具，方法是调用&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api&#34; title=&#34;Eviction API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eviction API&lt;/a&gt;
而不是直接删除 Pod。例如 &lt;code&gt;kubectl drain&lt;/code&gt; 命令和 Kubernetes-on-GCE 集群升级脚本（&lt;code&gt;cluster/gce/upgrade.sh&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;当集群管理员想要排空节点时，可以使用 &lt;code&gt;kubectl drain&lt;/code&gt; 命令。该命令会试图驱逐机器上的所有 pod。驱逐请求可能会暂时被拒绝，并且该工具会定期重试所有失败的请求，直到所有的 pod 都被终止，或者直到达到配置的超时时间。&lt;/p&gt;
&lt;p&gt;PDB 指定应用程序可以容忍的副本的数量，相对于应该有多少副本。例如，具有 &lt;code&gt;spec.replicas：5&lt;/code&gt; 的 Deployment 在任何给定的时间都应该有 5 个 Pod。如果其 PDB 允许在某一时刻有 4 个副本，那么驱逐 API 将只允许仅有一个而不是两个 Pod 自愿中断。&lt;/p&gt;
&lt;p&gt;使用标签选择器来指定应用程序的一组 pod，这与应用程序的控制器（Deployment、StatefulSet 等）使用的相同。&lt;/p&gt;
&lt;p&gt;Pod 控制器的 &lt;code&gt;.spec.replicas&lt;/code&gt; 计算“预期的”pod 数量。使用对象的 &lt;code&gt;.metadata.ownerReferences&lt;/code&gt; 值从控制器获取。&lt;/p&gt;
&lt;p&gt;PDB 不能阻止&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions&#34; title=&#34;非自愿中断&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;非自愿中断&lt;/a&gt;
的发生，但是它们确实会影响预算。&lt;/p&gt;
&lt;p&gt;由于应用程序的滚动升级而被删除或不可用的 Pod 确实会计入中断预算，但控制器（如 Deployment 和 StatefulSet）在进行滚动升级时不受 PDB 的限制——在应用程序更新期间的故障处理是在控制器的规格（spec）中配置（了解&lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#updating-your-application-without-a-service-outage&#34; title=&#34;更新 Deployment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更新 Deployment&lt;/a&gt;
）。&lt;/p&gt;
&lt;p&gt;使用驱逐 API 驱逐 pod 时，pod 会被优雅地终止（请参阅 PodSpec 中的 &lt;code&gt;terminationGracePeriodSeconds&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;pdb-示例&#34;&gt;PDB 示例&lt;/h2&gt;
&lt;p&gt;假设集群有 3 个节点，&lt;code&gt;node-1&lt;/code&gt; 到 &lt;code&gt;node-3&lt;/code&gt;。集群中运行了一些应用，其中一个应用有 3 个副本，分别是 &lt;code&gt;pod-a&lt;/code&gt;、&lt;code&gt;pod-b&lt;/code&gt; 和 &lt;code&gt;pod-c&lt;/code&gt;。另外，还有一个与它相关的不具有 PDB 的 pod，我们称为之为 &lt;code&gt;pod-x&lt;/code&gt;。最初，所有 Pod 的分布如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-a  &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-b &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-x  &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所有的 3 个 pod 都是 Deployment 中的一部分，并且它们共同拥有一个 PDB，要求至少有 3 个 pod 中的 2 个始终处于可用状态。&lt;/p&gt;
&lt;p&gt;例如，假设集群管理员想要重启系统，升级内核版本来修复内核中的错误。集群管理员首先使用 &lt;code&gt;kubectl drain&lt;/code&gt; 命令尝试排除 &lt;code&gt;node-1&lt;/code&gt;。该工具试图驱逐 &lt;code&gt;pod-a&lt;/code&gt; 和 &lt;code&gt;pod-x&lt;/code&gt;。这立即成功。两个 Pod 同时进入终止状态。这时的集群处于这种状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1 &lt;em&gt;draining&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-a  &lt;em&gt;terminating&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-b &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-x  &lt;em&gt;terminating&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Deployment 注意到其中有一个 pod 处于正在终止，因此会创建了一个 &lt;code&gt;pod-d&lt;/code&gt; 来替换。由于 &lt;code&gt;node-1&lt;/code&gt; 被封锁（cordon），它落在另一个节点上。同时其它控制器也创建了 &lt;code&gt;pod-y&lt;/code&gt; 作为 &lt;code&gt;pod-x&lt;/code&gt; 的替代品。&lt;/p&gt;
&lt;p&gt;（注意：对于 &lt;code&gt;StatefulSet&lt;/code&gt;，&lt;code&gt;pod-a&lt;/code&gt; 将被称为 &lt;code&gt;pod-1&lt;/code&gt;，需要在替换之前完全终止，替代它的也称为 &lt;code&gt;pod-1&lt;/code&gt;，但是具有不同的 UID，可以创建。否则，示例也适用于 StatefulSet。）&lt;/p&gt;
&lt;p&gt;当前集群的状态如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1 &lt;em&gt;draining&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-a  &lt;em&gt;terminating&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-b &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-x  &lt;em&gt;terminating&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-d &lt;em&gt;starting&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在某一时刻，pod 被终止，集群看起来像下面这样子：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1 &lt;em&gt;drained&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-b &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-d &lt;em&gt;starting&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此时，如果一个急躁的集群管理员试图排空（drain）&lt;code&gt;node-2&lt;/code&gt; 或 &lt;code&gt;node-3&lt;/code&gt;，drain 命令将被阻塞，因为对于 Deployment 只有 2 个可用的 pod，并且其 PDB 至少需要 2 个。经过一段时间，&lt;code&gt;pod-d&lt;/code&gt; 变得可用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1 &lt;em&gt;drained&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-b &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-d &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;现在，集群管理员尝试排空 &lt;code&gt;node-2&lt;/code&gt;。drain 命令将尝试按照某种顺序驱逐两个 pod，假设先是 &lt;code&gt;pod-b&lt;/code&gt;，然后再 &lt;code&gt;pod-d&lt;/code&gt;。它将成功驱逐 &lt;code&gt;pod-b&lt;/code&gt;。但是，当它试图驱逐 &lt;code&gt;pod-d&lt;/code&gt; 时，将被拒绝，因为这样对 Deployment 来说将只剩下一个可用的 pod。&lt;/p&gt;
&lt;p&gt;Deployment 将创建一个名为 &lt;code&gt;pod-e&lt;/code&gt; 的 &lt;code&gt;pod-b&lt;/code&gt; 的替代品。但是，集群中没有足够的资源来安排 &lt;code&gt;pod-e&lt;/code&gt;。那么，drain 命令就会被阻塞。集群最终可能是这种状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-1 &lt;em&gt;drained&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-2 &lt;em&gt;drained&lt;/em&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;node-3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;em&gt;no node&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-c &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-e &lt;em&gt;pending&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-d &lt;em&gt;available&lt;/em&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pod-y&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此时，集群管理员需要向集群中添加回一个节点以继续升级操作。&lt;/p&gt;
&lt;p&gt;您可以看到 Kubernetes 如何改变中断发生的速率，根据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序需要多少副本&lt;/li&gt;
&lt;li&gt;正常关闭实例需要多长时间&lt;/li&gt;
&lt;li&gt;启动新实例需要多长时间&lt;/li&gt;
&lt;li&gt;控制器的类型&lt;/li&gt;
&lt;li&gt;集群的资源能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分离集群所有者和应用程序所有者角色&#34;&gt;分离集群所有者和应用程序所有者角色&lt;/h2&gt;
&lt;p&gt;将集群管理者和应用程序所有者视为彼此知识有限的独立角色通常是很有用的。这种责任分离在这些情况下可能是有意义的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当有许多应用程序团队共享一个 Kubernetes 集群，并且有自然的专业角色&lt;/li&gt;
&lt;li&gt;使用第三方工具或服务来自动化集群管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pod Disruption Budget（Pod 中断预算）通过在角色之间提供接口来支持这种角色分离。&lt;/p&gt;
&lt;p&gt;如果您的组织中没有这样的职责分离，则可能不需要使用 Pod 中断预算。&lt;/p&gt;
&lt;h2 id=&#34;如何在集群上执行中断操作&#34;&gt;如何在集群上执行中断操作&lt;/h2&gt;
&lt;p&gt;如果您是集群管理员，要对集群的所有节点执行中断操作，例如节点或系统软件升级，则可以使用以下选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在升级期间接受停机时间。&lt;/li&gt;
&lt;li&gt;故障转移到另一个完整的副本集群。
&lt;ul&gt;
&lt;li&gt;没有停机时间，但是对于重复的节点和人工协调成本可能是昂贵的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编写可容忍中断的应用程序和使用 PDB。
&lt;ul&gt;
&lt;li&gt;没有停机时间。&lt;/li&gt;
&lt;li&gt;最小的资源重复。&lt;/li&gt;
&lt;li&gt;允许更多的集群管理自动化。&lt;/li&gt;
&lt;li&gt;编写可容忍中断的应用程序是很棘手的，但对于可容忍自愿中断，和支持自动调整以容忍非自愿中断，两者在工作上有大量的重叠。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/disruptions/&#34; title=&#34;Disruptions - kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Disruptions - kubernetes.io&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过配置&lt;a href=&#34;https://kubernetes.io/docs/tasks/run-application//configure-pdb&#34; title=&#34;Pod Disruption Budget（Pod 中断预算）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pod Disruption Budget（Pod 中断预算）&lt;/a&gt;
来执行保护应用程序的步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解更多关于&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster//safely-drain-node&#34; title=&#34;排空节点&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;排空节点&lt;/a&gt;
的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>附录 I：KMS 配置实例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/i/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/i/</guid>
      <description>
        
        
        &lt;p&gt;要用密钥管理服务（KMS）提供商插件来加密 Secret，可以使用以下加密配置 YAML 文件的例子来为提供商设置属性。这个例子是基于 &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/&#34; title=&#34;Kubernetes 的官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 的官方文档&lt;/a&gt;
。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apiserver.config.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;EncryptionConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;secrets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;providers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myKMSPlugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;unix://tmp/socketfile.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cachesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;3s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;identity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要配置 API 服务器使用 KMS 提供商，请将 &lt;code&gt;--encryption-provider-config&lt;/code&gt; 标志与配置文件的位置一起设置，并重新启动 API 服务器。&lt;/p&gt;
&lt;p&gt;要从本地加密提供者切换到 KMS，请将 &lt;code&gt;EncryptionConfiguration&lt;/code&gt; 文件中的 KMS 提供者部分添加到当前加密方法之上，如下所示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apiserver.config.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;EncryptionConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;secrets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;providers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myKMSPlugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;unix://tmp/socketfile.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cachesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;3s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;aescbc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;key1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;base64 encoded secret&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重新启动 API 服务器并运行下面的命令来重新加密所有与 KMS 供应商的 Secret。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get secrets --all-namespaces -o json &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; kubectl replace -f -
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>集群资源管理</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/cluster/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/cluster/</guid>
      <description>
        
        
        &lt;p&gt;为了管理异构和不同配置的主机，为了便于 Pod 的运维管理，Kubernetes 中提供了很多集群管理的配置和管理功能，通过 namespace 划分的空间，通过为 node 节点创建 label 和 taint 用于 pod 的调度等。&lt;/p&gt;
&lt;h2 id=&#34;本节大纲&#34;&gt;本节大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/node/&#34;&gt;Node&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/namespace/&#34;&gt;Namespace&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/label/&#34;&gt;Label&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/annotation/&#34;&gt;Annotation&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/taint-and-toleration/&#34;&gt;Taint 和 Toleration（污点和容忍）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/garbage-collection/&#34;&gt;垃圾收集&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/scheduling/&#34;&gt;资源调度&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/qos/&#34;&gt;服务质量等级（QoS）&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
    
    <item>
      <title>附录 J：pod-reader RBAC 角色</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/j/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/j/</guid>
      <description>
        
        
        &lt;p&gt;要创建一个 pod-reader 角色，创建一个 YAML 文件，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Role&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;your-namespace-name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;pod-reader&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;&amp;#34; 表示核心 API 组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;verbs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;watch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;list&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用角色：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply --f role.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要创建一个全局性的 pod-reader &lt;code&gt;ClusterRole&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;namespace&amp;#34; 被省略了，因为 ClusterRoles 没有被绑定到一个命名空间上&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;global-pod-reader&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;&amp;#34; 表示核心 API 组&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;verbs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;watch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;list&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用角色：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply --f clusterrole.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Node</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/cluster/node/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/cluster/node/</guid>
      <description>
        
        
        &lt;p&gt;Node 是 Kubernetes 集群的工作节点，可以是物理机也可以是虚拟机。&lt;/p&gt;
&lt;h2 id=&#34;node-的状态&#34;&gt;Node 的状态&lt;/h2&gt;
&lt;p&gt;Node 包括如下状态信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Address
&lt;ul&gt;
&lt;li&gt;HostName：可以被 kubelet 中的 &lt;code&gt;--hostname-override&lt;/code&gt; 参数替代。&lt;/li&gt;
&lt;li&gt;ExternalIP：可以被集群外部路由到的 IP 地址。&lt;/li&gt;
&lt;li&gt;InternalIP：集群内部使用的 IP，集群外部无法访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Condition
&lt;ul&gt;
&lt;li&gt;OutOfDisk：磁盘空间不足时为 &lt;code&gt;True&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ready：Node controller 40 秒内没有收到 node 的状态报告为 &lt;code&gt;Unknown&lt;/code&gt;，健康为 &lt;code&gt;True&lt;/code&gt;，否则为 &lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;MemoryPressure：当 node 有内存压力时为 &lt;code&gt;True&lt;/code&gt;，否则为 &lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;DiskPressure：当 node 有磁盘压力时为 &lt;code&gt;True&lt;/code&gt;，否则为 &lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capacity
&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;li&gt;可运行的最大 Pod 个数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Info：节点的一些版本信息，如 OS、kubernetes、docker 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;node-管理&#34;&gt;Node 管理&lt;/h2&gt;
&lt;p&gt;禁止 Pod 调度到该节点上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl cordon &amp;lt;node&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;驱逐该节点上的所有 Pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl drain &amp;lt;node&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该命令会删除该节点上的所有 Pod（DaemonSet 除外），在其他 node 上重新启动它们，通常该节点需要维护时使用该命令。直接使用该命令会自动调用&lt;code&gt;kubectl cordon &amp;lt;node&amp;gt;&lt;/code&gt;命令。当该节点维护完成，启动了 kubelet 后，再使用&lt;code&gt;kubectl uncordon &amp;lt;node&amp;gt;&lt;/code&gt; 即可将该节点添加到 kubernetes 集群中。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 K：RBAC RoleBinding 和 ClusterRoleBinding 示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/k/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/k/</guid>
      <description>
        
        
        &lt;p&gt;要创建一个 &lt;code&gt;RoleBinding&lt;/code&gt;，需创建一个 YAML 文件，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这个角色绑定允许 &amp;#34;jane&amp;#34; 读取 &amp;#34;your-namespace-name&amp;#34; 的 Pod 命名空间&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 你需要在该命名空间中已经有一个名为 &amp;#34;pod-reader&amp;#34;的角色。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RoleBinding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;read-pods&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;your-namespace-name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 你可以指定一个以上的 &amp;#34;subject&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;jane&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;name&amp;#34; 是大小写敏感的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;roleRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;roleRef&amp;#34; 指定绑定到一个 Role/ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Role&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 必须是 Role 或 ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;pod-reader&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这必须与你想绑定的 Role 或 ClusterRole 的名字相匹配&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 &lt;code&gt;RoleBinding&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply --f rolebinding.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要创建一个&lt;code&gt;ClusterRoleBinding&lt;/code&gt;，请创建一个 YAML 文件，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这个集群角色绑定允许 &amp;#34;manager&amp;#34; 组中的任何人在任何命名空间中读取 Pod 信息。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRoleBinding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;global-pod-reader&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 你可以指定一个以上的 &amp;#34;subject&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Group&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Name 是大小写敏感的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;roleRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#34;roleRef&amp;#34; 指定绑定到一个 Role/ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 必须是 Role 或 ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;global-pod-reader&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这必须与你想绑定的 Role 或 ClusterRole 的名字相匹配&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 &lt;code&gt;RoleBinding&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply --f clusterrolebinding.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Namespace</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/cluster/namespace/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/cluster/namespace/</guid>
      <description>
        
        
        &lt;p&gt;在一个 Kubernetes 集群中可以使用 namespace 创建多个“虚拟集群”，这些 namespace 之间可以完全隔离，也可以通过某种方式，让一个 namespace 中的 service 可以访问到其他的 namespace 中的服务。&lt;/p&gt;
&lt;h2 id=&#34;哪些情况下适合使用多个-namespace&#34;&gt;哪些情况下适合使用多个 namespace&lt;/h2&gt;
&lt;p&gt;因为 namespace 可以提供独立的命名空间，因此可以实现部分的环境隔离。当你的项目和人员众多的时候可以考虑根据项目属性，例如生产、测试、开发划分不同的 namespace。&lt;/p&gt;
&lt;h2 id=&#34;namespace-使用&#34;&gt;Namespace 使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;获取集群中有哪些 namespace&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl get ns&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;集群中默认会有 &lt;code&gt;default&lt;/code&gt; 和 &lt;code&gt;kube-system&lt;/code&gt; 这两个 namespace。&lt;/p&gt;
&lt;p&gt;在执行 &lt;code&gt;kubectl&lt;/code&gt; 命令时可以使用 &lt;code&gt;-n&lt;/code&gt; 指定操作的 namespace。&lt;/p&gt;
&lt;p&gt;用户的普通应用默认是在 &lt;code&gt;default&lt;/code&gt; 下，与集群管理相关的为整个集群提供服务的应用一般部署在 &lt;code&gt;kube-system&lt;/code&gt; 的 namespace 下，例如我们在安装 kubernetes 集群时部署的 &lt;code&gt;kubedns&lt;/code&gt;、&lt;code&gt;heapseter&lt;/code&gt;、&lt;code&gt;EFK&lt;/code&gt; 等都是在这个 namespace 下面。&lt;/p&gt;
&lt;p&gt;另外，并不是所有的资源对象都会对应 namespace，&lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;persistentVolume&lt;/code&gt; 就不属于任何 namespace。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 L：审计策略</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/l/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/l/</guid>
      <description>
        
        
        &lt;p&gt;下面是一个审计策略，它以最高级别记录所有审计事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;audit.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RequestResponse&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这个审计策略记录了 RequestResponse 级别的所有审计事件&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种审计策略在最高级别上记录所有事件。如果一个组织有可用的资源来存储、解析和检查大量的日志，那么在最高级别上记录所有事件是一个很好的方法，可以确保当事件发生时，所有必要的背景信息都出现在日志中。如果资源消耗和可用性是一个问题，那么可以建立更多的日志规则来降低非关键组件和常规非特权操作的日志级别，只要满足系统的审计要求。如何建立这些规则的例子可以在 &lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/audit/&#34; title=&#34;Kubernetes 官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官方文档&lt;/a&gt;
中找到。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Label</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/cluster/label/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/cluster/label/</guid>
      <description>
        
        
        &lt;p&gt;Label 是附着到 object 上（例如 Pod）的键值对。可以在创建 object 的时候指定，也可以在 object 创建后随时指定。Labels 的值对系统本身并没有什么含义，只是对用户才有意义。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;labels&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;key1&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;key2&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Kubernetes 最终将对 labels 最终索引和反向索引用来优化查询和 watch，在 UI 和命令行中会对它们排序。不要在 label 中使用大型、非标识的结构化数据，记录这样的数据应该用 annotation。&lt;/p&gt;
&lt;h2 id=&#34;动机&#34;&gt;动机&lt;/h2&gt;
&lt;p&gt;Label 能够将组织架构映射到系统架构上（就像是康威定律），这样能够更便于微服务的管理，你可以给 object 打上如下类型的 label：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;release&amp;quot; : &amp;quot;stable&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;release&amp;quot; : &amp;quot;canary&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;dev&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;qa&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;environment&amp;quot; : &amp;quot;production&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;frontend&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;backend&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;tier&amp;quot; : &amp;quot;cache&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;partition&amp;quot; : &amp;quot;customerA&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;partition&amp;quot; : &amp;quot;customerB&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;track&amp;quot; : &amp;quot;daily&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;track&amp;quot; : &amp;quot;weekly&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;team&amp;quot; : &amp;quot;teamA&amp;quot;&lt;/code&gt;,&lt;code&gt;&amp;quot;team:&amp;quot; : &amp;quot;teamB&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;语法和字符集&#34;&gt;语法和字符集&lt;/h2&gt;
&lt;p&gt;Label key 的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不得超过 63 个字符&lt;/li&gt;
&lt;li&gt;可以使用前缀，使用 / 分隔，前缀必须是 DNS 子域，不得超过 253 个字符，系统中的自动化组件创建的 label 必须指定前缀，&lt;code&gt;kubernetes.io/&lt;/code&gt; 由 kubernetes 保留&lt;/li&gt;
&lt;li&gt;起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Label value 的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不得超过 63 个字符&lt;/li&gt;
&lt;li&gt;起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;label-selector&#34;&gt;Label selector&lt;/h2&gt;
&lt;p&gt;Label 不是唯一的，很多 object 可能有相同的 label。&lt;/p&gt;
&lt;p&gt;通过 label selector，客户端／用户可以指定一个 object 集合，通过 label selector 对 object 的集合进行操作。&lt;/p&gt;
&lt;p&gt;Label selector 有两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;equality-based&lt;/em&gt; ：可以使用 &lt;code&gt;=&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt; 操作符，可以使用逗号分隔多个表达式&lt;/li&gt;
&lt;li&gt;&lt;em&gt;set-based&lt;/em&gt; ：可以使用 &lt;code&gt;in&lt;/code&gt;、&lt;code&gt;notin&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt; 操作符，另外还可以没有操作符，直接写出某个 label 的 key，表示过滤有某个 key 的 object 而不管该 key 的 value 是何值，&lt;code&gt;!&lt;/code&gt; 表示没有该 label 的 object&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -l &lt;span class=&#34;nv&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;production,tier&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;frontend
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -l &lt;span class=&#34;s1&#34;&gt;&amp;#39;environment in (production),tier in (frontend)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -l &lt;span class=&#34;s1&#34;&gt;&amp;#39;environment in (production, qa)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -l &lt;span class=&#34;s1&#34;&gt;&amp;#39;environment,environment notin (frontend)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;在-api-object-中设置-label-selector&#34;&gt;在 API object 中设置 label selector&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;service&lt;/code&gt;、&lt;code&gt;replicationcontroller&lt;/code&gt; 等 object 中有对 pod 的 label selector，使用方法只能使用等于操作，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;component&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;Job&lt;/code&gt;、&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;ReplicaSet&lt;/code&gt; 和 &lt;code&gt;DaemonSet&lt;/code&gt; 这些 object 中，支持 &lt;em&gt;set-based&lt;/em&gt; 的过滤，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;component&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchExpressions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- {&lt;span class=&#34;nt&#34;&gt;key: tier, operator: In, values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cache]}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- {&lt;span class=&#34;nt&#34;&gt;key: environment, operator: NotIn, values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;dev]}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如 Service 通过 label selector 将同一类型的 pod 作为一个服务 expose 出来。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/kubernetes-handbook/cluster/label/labels.png&#34; data-img=&#34;/book/kubernetes-handbook/cluster/label/labels.png&#34; data-width=&#34;803&#34; data-height=&#34;588&#34; alt=&#34;image&#34; data-caption=&#34;Label 示意图&#34;&gt;
    
  
  &lt;figcaption&gt;Label 示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另外在 node affinity 和 pod affinity 中的 label selector 的语法又有些许不同，示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;affinity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;nodeAffinity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;nodeSelectorTerms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matchExpressions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubernetes.io/e2e-az-name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;In&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;e2e-az1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;e2e-az2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;preference&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchExpressions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;another-node-label-key&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;In&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;another-node-label-value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>附录 M：向 kube-apiserver 提交审计策略文件的标志示例</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/m/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/appendix/m/</guid>
      <description>
        
        
        &lt;p&gt;在控制平面，用文本编辑器打开 &lt;code&gt;kube-apiserver.yaml&lt;/code&gt; 文件。编辑 &lt;code&gt;kube-apiserver&lt;/code&gt; 配置需要管理员权限。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo vi /etc/kubernetes/manifests/kube-apiserver.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;kube-apiserver.yaml&lt;/code&gt; 文件中添加以下文字：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--audit-policy-file=/etc/kubernetes/policy/audit-policy.yaml --audit-log-path=/var/log/audit.log --audit-log-maxage=1825
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;audit-policy-file&lt;/code&gt; 标志应该设置为审计策略的路径，而 &lt;code&gt;audit-log-path&lt;/code&gt; 标志应该设置为所需的审计日志写入的安全位置。还有一些其他的标志，比如这里显示的 &lt;code&gt;audit-log-maxage&lt;/code&gt; 标志，它规定了日志应该被保存的最大天数，还有一些标志用于指定要保留的最大审计日志文件的数量，最大的日志文件大小（兆字节）等等。启用日志记录的唯一必要标志是 &lt;code&gt;audit-policy-file&lt;/code&gt; 和 &lt;code&gt;audit-log-path&lt;/code&gt; 标志。其他标志可以用来配置日志，以符合组织的政策。&lt;/p&gt;
&lt;p&gt;如果用户的 &lt;code&gt;kube-apiserver&lt;/code&gt; 是作为 Pod 运行的，那么就有必要挂载卷，并配置策略和日志文件位置的 &lt;code&gt;hostPath&lt;/code&gt; 以保留审计记录。这可以通过在 &lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/audit/&#34; title=&#34;Kubernetes 文档中&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档中&lt;/a&gt;
指出的 &lt;code&gt;kube-apiserver.yaml&lt;/code&gt; 文件中添加以下部分来完成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/etc/kubernetes/audit-policy.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;audit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log/audit.log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;audit-log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hostPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/etc/kubernetes/audit-policy.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;File&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;audit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hostPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log/audit.log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;FileOrCreate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;audit-log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Annotation</title>
      <link>https://jimmysong.io/book/kubernetes-handbook/cluster/annotation/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/kubernetes-handbook/cluster/annotation/</guid>
      <description>
        
        
        &lt;p&gt;Annotation，顾名思义，就是注解。Annotation 可以将 Kubernetes 资源对象关联到任意的非标识性元数据。使用客户端（如工具和库）可以检索到这些元数据。&lt;/p&gt;
&lt;h2 id=&#34;关联元数据到对象&#34;&gt;关联元数据到对象&lt;/h2&gt;
&lt;p&gt;Label 和 Annotation 都可以将元数据关联到 Kubernetes 资源对象。Label 主要用于选择对象，可以挑选出满足特定条件的对象。相比之下，annotation 不能用于标识及选择对象。annotation 中的元数据可多可少，可以是结构化的或非结构化的，也可以包含 label 中不允许出现的字符。&lt;/p&gt;
&lt;p&gt;Annotation 和 label 一样都是 key/value 键值对映射结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;annotations&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;key1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;key2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下列出了一些可以记录在 annotation 中的对象信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明配置层管理的字段。使用 annotation 关联这类字段可以用于区分以下几种配置来源：客户端或服务器设置的默认值，自动生成的字段或自动生成的 auto-scaling 和 auto-sizing 系统配置的字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建信息、版本信息或镜像信息。例如时间戳、版本号、git 分支、PR 序号、镜像哈希值以及仓库地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录日志、监控、分析或审计存储仓库的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用于 debug 的客户端（库或工具）信息，例如名称、版本和创建信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户信息，以及工具或系统来源信息、例如来自非 Kubernetes 生态的相关对象的 URL 信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轻量级部署工具元数据，例如配置或检查点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负责人的电话或联系方式，或能找到相关信息的目录条目信息，例如团队网站。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不使用 annotation，您也可以将以上类型的信息存放在外部数据库或目录中，但这样做不利于创建用于部署、管理、内部检查的共享工具和客户端库。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;如 Istio 的 Deployment 配置中就使用到了 annotation：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;extensions/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alpha.istio.io/sidecar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ignore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccountName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-manager-service-account&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;discovery&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;harbor-001.jimmysong.io/library/manager:0.1.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;discovery&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;POD_NAMESPACE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;valueFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metadata.namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apiserver&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;harbor-001.jimmysong.io/library/manager:0.1.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;apiserver&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8081&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;POD_NAMESPACE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;valueFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metadata.namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;alpha.istio.io/sidecar&lt;/code&gt; 注解就是用来控制是否自动向 pod 中注入 sidecar 的。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
