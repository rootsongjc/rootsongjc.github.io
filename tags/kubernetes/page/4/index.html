<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Kubernetes - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/kubernetes/" />
  <meta property="og:title" content="Kubernetes | Jimmy Song" />
  <meta property="twitter:title" content="Kubernetes | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu">
                
                <a class="dropdown-item" href="/book">书籍</a>
                
                <a class="dropdown-item" href="/slide">幻灯片</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/kubernetes/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Kubernetes
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/why-rbac-is-not-enough-for-kubernetes-api-security/">[译] 为什么 RBAC 不足以保障 Kubernetes 的安全？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么 RBAC 不足以保障 Kubernetes 的安全？', '所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。', '\nKubernetes 不再是（只是）好玩的游戏了。它正在被用于生产；它是关键任务；所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。 \n\n## 概述\n\n- **Kubernetes API 的设计与大多数现代 API 不同。** 它是基于意图的，这意味着使用 API 的人考虑的是他们想要 Kubernetes 做什么，而不是如何实现。其结果是一个令人难以置信的可扩展性、弹性，和一个强大而流行的系统。\n- **同时，其基于意图的 API 给安全带来了挑战。** 标准的访问控制解决方案（基于角色的访问控制、基于属性的访问控制、访问控制列表或 IAM 策略）都不够强大，无法强制执行基本的策略，比如谁可以更改 pod 上的标签，或者哪些镜像存储库是安全的。\n- **Kubernetes Admission Control 就是为了解决这个问题而设计的。** Kubernetes Admission Controller 并不能解决开箱即用的访问控制问题，但它们允许你使用 Webhook 来解决授权挑战与解耦策略。\n\n## Kubernetes 基于意图的 API\n\nKubernetes API 接受了一个与我们大家习惯的 API 范式截然不同的 API。今天的大多数 API 都是所谓的 *基于行动的（action-based）*，这意味着当你想到一个 API 调用时，你正在考虑你想要执行的行动，以改变软件的运行方式。例如，如果你想让一个应用程序暴露在互联网上，你可能会运行 API openport (443)，改变应用程序上的网络设置，使端口 443 打开。\n\n相比之下，Kubernetes 有所谓的 *基于意图的（intent-based）* API（最近在网络领域流行，例如 [SDXCentral](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.sdxcentral.com%2Fsdn%2Fdefinitions%2Fwhat-is-intent-based-networking%2F)），这意味着当你想要进行一个 API 调用时，你要考虑的是你希望该系统处于何种状态。你并不关心用什么操作来实现这种希望的状态。你只需告诉系统你想要什么（你的意图），系统就会想出如何实现它 —— 采取哪些动作将系统过渡到期望的状态。例如，你可以说你的应用程序应该运行 1.7 版本的二进制文件，应该使用带加密的持久存储，并且应该连接到互联网。系统会计算出如何升级或降级二进制文件，如何开启加密，以及如何重新配置网络以允许互联网连接。\n\n架构上的关键区别在于，*基于意图的* 系统既能理解系统当前所处的状态（有时称为 *实际状态* ），也能理解你对系统应该处于何种状态的意图（*期望状态*）。系统不断地计算两者之间的差距，并采取任何必要的行动使实际状态变成期望状态。用户可以直接通过 API 调用来改变期望状态，而依靠系统本身来改变实际状态。\n\n![](0081Kckwly1glqzp7lpo7j30l20ept9z.jpg)\n\nKubernetes 的 API 是基于意图的。每个 API 调用都允许你指定 Kubernetes 众多对象中的一个对象的期望状态：pod、service、ingress、configmap 等。例如，下面是你为一个 nginx 工作负载定义的期望状态。\n\n\u0060\u0060\u0060yaml\n# nginx-pod.yaml\nkind: Pod\napiVersion: v1\nmetadata:\n name: nginx\n labels:\n app: nginx\nspec:\n containers:\n - image: nginx\n name: nginx\t\n\u0060\u0060\u0060\n\n然后要把这个想要的状态发送到 Kubernetes，用 kubectl，把上面的 YAML 文件交给它就行了。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n假设你想改变 nginx 的版本，挂载一个外部卷，或者提供额外的配置，你更新 nginx-pod.yaml 文件到任何你想要的状态，然后再使用 kubectl apply。更新 nginx-pod.yaml 文件到任何需要的状态，然后再使用 kubectl apply。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n这里的关键要点是，你不是在运行像 updateVersion 或 mountVolume 这样的 API，而是在改变一些描述系统应该处于什么状态的 YAML，并通过运行 apply 来说\u0022 使之如此 \u0022。\n\nKubernetes 的 API 模型有几个优势：\n\n- **减少学习曲线**。你要学习每个对象的 YAML 格式和一系列动作，如创建、应用、获取、描述、删除。无论如何，你都需要学习每个对象的 YAML 配置格式（这样你才能读懂它）。相比之下，*基于动作的* API 还需要你学习可能是 1,000 个动作。\n- **可扩展性**。Kubernetes 支持自定义资源定义（CRD）。因此，除了所有常见的 pod、service、ingress 等，你还可以定义自己的资源。这是可能的，因为 API 表面不需要扩展来处理新的资源类型。你只需要写一些描述资源的 YAML，然后调用同样的十几个动作，例如：创建、应用、获取、描述、删除。\n- **分布式系统**。在使用商用硬件构建的云上运行大规模系统，要求在面对故障时具有难以置信的弹性。Kubernetes 基于意图的架构让它知道自己应该做什么，所以当比如说发生硬件故障时，它可以尝试进行补偿。Brian Grant（Google Kubernetes 的联合技术负责人）曾就 [声明式应用管理](https:\/\/docs.google.com\/document\/d\/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU\/edit) 和 [Kubernetes 资源管理](https:\/\/docs.google.com\/document\/d\/1RmHXdLhNbyOWPW_AtnnowaRfGejw-qlKQIuLKQWlwzs\/edit) 写过大量文章，并指出 Kubernetes API 是解决许多分布式系统问题的关键：故障、分布、自动伸缩、多所有者、可用性、性能、可逆性。\n\n## 为什么 RBAC 不足以保证 Kubernetes 的 API 安全？\n\n基于 Kubernetes 意图的 API 的挑战来自于你想要保护和保障 API 的安全时 —— 当你想要控制哪些人可以使用该 API 做什么时。想象一下，你是 Kubernetes 管理员，负责集群的运维、安全和合规性。新手 Kubernetes 开发人员需要护栏；安全团队需要控制和可见性；合规团队需要帮助将古老的规定映射到这个全新的系统；你从自己的经验中知道你需要采用哪些 Kubernetes 最佳实践。\n\n理想情况下，你会在 Kubernetes 本身内部通过设置访问控制来执行这些规则、法规和最佳实践。基于角色的访问控制（RBAC）是几十年来的解决方案，使你能够控制哪些用户可以在哪些资源上运行哪些 API。Kubernetes RBAC（自 [2017 年末](https:\/\/kubernetes.io\/blog\/2017\/10\/using-rbac-generally-available-18\/) 开始提供）是你的第一道防线。它可以让你为特定的用户组提供对资源的只读访问。它让你通过给不同的用户组分配 Kubernetes 的不同部分（也就是 *namespace*）来隔离不同的用户组（虽然不是完全隔离）。它可以让你限制 service account\n的权限。所有这些都是有价值的。\n\n但与基于动作的系统相比，RBAC 处理了绝大部分的访问控制需求，Kubernetes 中的 RBAC 由于其基于意图的 API，提供的控制 *要少得多*。从 API 的角度来看，只有十几个动作，这意味着如果 alice 可以更新一个资源，她就可以更新这个资源的任何部分。\n\n例如，SRE 需要读取集群中的大部分资源，以便在出现问题时能够诊断出问题。但当 SRE 发现某个节点上出现问题时，例如邻居有噪音，她可能需要对该节点进行排空（drain），以便将工作负载转移到不同的节点上，缓解问题。不幸的是，API 没有 drain 动作 —— 那些是 CLI 提供的宏，只是更新节点上的注释。使用 RBAC 试图达到这个级别的粒度是繁琐而复杂的，以至于不切实际。\n\n下面的基于意图的 K8s RBAC 图从概念上显示了你必须使用 RBAC 的工作内容 —— 你可以选择哪些用户 \/ 操作 \/ 资源组合是允许的。\n\n![](0081Kckwly1glr08337z4j30b908s75g.jpg)\n\n相反，想象一下，如果 Kubernetes 是基于动作的（例如，它包括 cordon、drain、setImage、mountVolume、openPort 等 API）。那么我们就可以使用 RBAC 来授予读以及 cordon 和 drain，但没有其他的功能。基于动作的 API 只是有更多的名字，你可以在编写 RBAC 策略时使用。\n\n![](0081Kckwly1glr0978kbej30bc0d5wgf.jpg)\n\n简而言之，Kubernetes API 提供了一个强大的、可扩展的、统一的资源模型，但也正是这个资源模型使得 RBAC 对于很多用例来说过于粗粒度。RBAC 所能提供的控制是非常宝贵的，但比起其他系统，RBAC 还远不能满足 Kubernetes 的需要。\n\n### 我们需要什么来保证 K8s 的 API 安全？\n\n那么如果 RBAC 不能提供足够的控制，我们该怎么做呢？我们来看一个例子。\u0022所有的 pod 必须只使用来自受信任的存储库的镜像\u0022（比如说，hooli.com）任何时候有人运行，比如说，kubectl apply，访问控制系统需要根据用户、动作 apply 和描述 pod 的 YAML 做出决定。\n\n\u0060\u0060\u0060yaml\nkind: Pod\nmetadata:\n  labels:\n    app: nginx\n  name: nginx-1493591563-bvl8q\n  namespace: production\nspec:\n  containers:\n  - image: nginx\n    name: nginx\n    securityContext:\n      privileged: true\n  - image: hooli.com\/frontend\n    name: frontend\n    securityContext:\n      privileged: true \n dnsPolicy: ClusterFirst\n restartPolicy: Always\n\u0060\u0060\u0060\n\n为了做出正确的决策，访问控制系统需要提取镜像名称列表（如\u0060nginx\u0060和\u0060hooli.com\/frontend\u0060），并进行字符串操作以提取仓库的名称（如默认的 repo 和 hooli.com）。\n\n一种方案是将一堆关于 Kubernetes 资源的知识构建到访问控制系统本身。然后管理员可以写一个策略，比如谁可以 \u0060update-labels\u0060，\u0060permitted-image-registries\u0060 是什么，等等。这就是大多数系统的做法 —— 发明一堆权限，然后在上面建立一个自定义的访问控制系统。\n\n但是构建一个自定义的访问控制系统对于 Kubernetes 来说是行不通的，因为它允许用户和厂商发明自己的 YAML 格式（自定义资源定义），并安装实现这些格式的代码。所以 Kubernetes 的资源可扩展性要求任何定制的 Kubernetes 访问控制系统本身都是可扩展的。\n\n所以，不管我们做什么，我们都需要一个访问控制系统，让管理员编写策略：\n\n- 通过 YAML 文件的层次结构进行递减。\n- 对数组中的元素进行迭代。\n- 操作字符串、IP、数字等。\n\n标准的访问控制范式都不能满足这些要求。这包括基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）、访问控制列表（ACL），甚至是 IAM 风格的策略。\n\n### 使用准许控制来应急\n\n幸运的是，Kubernetes 团队预见到了这个问题，并创建了一个 [Admission Control](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fkubernetes.io%2Fdocs%2Freference%2Faccess-authn-authz%2Fadmission-controllers%2F) 机制，在这里你可以把控制的范围远远超过 RBAC 和标准的访问控制机制。Kubernetes API 服务器提供了一条访问控制的管道，分为 Authorization（如 RBAC），和 Admission。\n\n![](0081Kckwly1glr2h345xpj30rg06rq42.jpg) \n\n授权（Authorization）发生在每次 API 调用上，而准许（Addmission）只发生在更新（创建、更新和删除）上。通过授权，你将获得以下信息以做出决定：\n\n- **用户**：用户、组、认证提供的额外属性。\n- **动作**：路径、API 动词、HTTP 动词。\n- **资源**：资源、子资源、命名空间、API 组。\n\n通过 Admission，你会得到一个 YAML 中的 AdmissionReview 对象。它包括所有关于资源被修改的信息，以做出任何你想要的决定（见下面的 \u0060request.object\u0060）。\n\n\u0060\u0060\u0060yaml\napiVersion: admission.k8s.io\/v1beta1\nkind: AdmissionReview\nrequest:\n  kind:\n    group: \u0027\u0027\n    kind: Pod\n    version: v1\n  namespace: frontend\n  object:\n    metadata:\n      creationTimestamp: \u00272018-10-27T02:12:20Z\u0027\n      labels:\n        app: nginx\n      name: nginx\n      namespace: frontend\n      uid: bbfee96d-d98d-11e8-b280-080027868e77\n    spec:\n      containers:\n      - image: nginx\n        imagePullPolicy: Always\n        name: nginx\n        resources: {}\n        terminationMessagePath: \u0022\/dev\/termination-log\u0022\n        terminationMessagePolicy: File\n        volumeMounts:\n        - mountPath: \u0022\/var\/run\/secrets\/kubernetes.io\/serviceaccount\u0022\n        name: default-token-tm9v8\n        readOnly: true\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      schedulerName: default-scheduler\n      securityContext: {}\n      serviceAccount: default\n      serviceAccountName: default\n      terminationGracePeriodSeconds: 30\n      tolerations:\n      - effect: NoExecute\n        key: node.kubernetes.io\/not-ready\n        operator: Exists\n        tolerationSeconds: 300\n      - effect: NoExecute\n        key: node.kubernetes.io\/unreachable\n        operator: Exists\n        tolerationSeconds: 300\n      volumes:\n      - name: default-token-tm9v8\n        secret:\n          secretName: default-token-tm9v8\n    status:\n      phase: Pending\n      qosClass: BestEffort\n    oldObject: \n    operation: CREATE\n    resource:\n      group: \u0027\u0027\n      resource: pods\n      version: v1\n    uid: bbfeef88-d98d-11e8-b280-080027868e77\n    userInfo:\n      groups:\n      - system:masters\n      - system:authenticated\n      username: minikube-user \n\u0060\u0060\u0060\n\n当然，你可以通过编写、部署和维护实现准入控制 webhook 协议（一个简单的 HTTP\/json API）的自定义代码，编写任何你喜欢的逻辑来保护你的 API。现在，如果你不想支持和维护自定义代码，你可以使用 [Open Policy Agent](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.openpolicyagent.org) 作为 Kubernetes [准入控制器](https:\/\/www.openpolicyagent.org\/docs\/latest\/kubernetes-tutorial\/)，并利用其声明式策略语言。该语言包括上述所需的表达能力：迭代、点注和 50 多个内置的可用于字符串操纵等。更多信息，请参见 [\u0022 利用 Open Policy Agent 确保 Kubernetes API 安全 \u0022 一文](https:\/\/blog.openpolicyagent.org\/securing-the-kubernetes-api-with-open-policy-agent-ce93af0552c3)。\n\n## 总结\n\n在这篇文章中，我们深入研究了 Kubernetes 所面临的 API 安全挑战，并重点介绍了以下几个关键要点：\n\n- Kubernetes 基于意图的 API 让用户专注于他们希望 Kubernetes 处于什么状态，而不是如何实现它。\n- 基于意图的方法的核心好处之一是，它使 Kubernetes 在面对故障时具有弹性。因为系统知道自己应该做什么，所以当故障发生时，Kubernetes 知道如何恢复。\n- Kubernetes 的 API 还提供了巨大的可扩展性。用户可以创建自己的自定义资源，而无需扩展 API。\n- Kubernetes 的 API 所面临的挑战是，一个访问控制决策可能需要分析一个任意的 YAML 文档，例如使用点符号、迭代和字符串操纵。标准的访问控制系统，如 RBAC、ABAC、ACLs 和 IAM，根本没有足够的表达能力。\n- Kubernetes 团队引入了准入控制（Admission Control），以赋予用户控制 API 的额外权力。你可以使用声明式授权解决方案（如 Open Policy Agent）作为 Kubernetes Admission Controller，为你提供所需的表达能力，以克服这些新的访问挑战，并提供真正有效的粒度。\n', '\/trans\/why-rbac-is-not-enough-for-kubernetes-api-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-amazon-eks-distro/">[译] 亚马逊 EKS 发行版（EKS-D）介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('亚马逊 EKS 发行版（EKS-D）介绍', '本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。', '\n今天，我们发布了 [Amazon EKS Distro](https:\/\/distro.eks.amazonaws.com\/)（EKS-D），这是一个基于 [Amazon Elastic Kubernetes Service](https:\/\/amazonaws-china.com\/eks\/)（Amazon EKS）的 Kubernetes 发行版，并由 Amazon EKS 用于创建可靠和安全的 Kubernetes 集群。通过 EKS-D，你可以依赖 EKS 部署的相同版本的 Kubernetes 及其依赖项。这包括最新的上游更新以及扩展的安全补丁支持。EKS-D 遵循与亚马逊 EKS 相同的 Kubernetes 版本发布周期，我们以 [GitHub 上的开源项目的方式](https:\/\/github.com\/aws\/eks-distro) 提供。\n\n在这篇文章中，我们将介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。\n\n## 什么是 EKS-D？\n\n通过 EKS Distro，你现在可以在通过 EKS 提供的相同 Kubernetes 发行版上实现标准化。这意味着你现在可以手动部署可靠和安全的集群，而无需持续测试和跟踪 Kubernetes 更新、依赖性和安全补丁。每个 EKS Distro 版本都遵循 [EKS](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar) 验证新 Kubernetes 版本兼容性的 [流程](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar)。你还可以选择使用提供的构建环境设置、工具和我们发布的镜像的哈希值重现 EKS Distro 的构建，以确认你的下载在传输过程中没有被篡改。通过 EKS-D，我们为社区支持到期后的 Kubernetes 版本提供了扩展支持，更新了以前版本的构建，现在有了最新的安全补丁。\n\n在过去两年大规模运营 Amazon EKS 之后（我们说的是全球数百万个各种规模的集群），我们现在能够确定哪些工作、[哪些组件要运行以及如何运行](https:\/\/kccncna19.sched.com\/event\/Uaav\/living-with-the-pathology-of-the-cloud-how-aws-runs-lots-of-clusters-micah-hausler-amazon)。我们已经了解到，客户希望在企业内部和云端获得一致的体验，以便进行迁移或实现混合云设置。例如，客户有一个用例，由于数据主权的原因，部分工作负载驻留在内部的 Kubernetes 集群中，而其他部分则运行在 EKS 上。现在你手头就有了基于 EKS 的解决方案参考系。\n\n![](0081Kckwgy1glhwzwpf3fj30rs0fst9y.jpg)\n\n对于 EC2 上的 EKS，你可以 [自己](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/worker.html) 管理节点，也可以使用 [托管节点组](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/managed-node-groups.html)。\n\n为了解决一致性的要求，我们想到了 EKS Distro，我们基于 EKS 的 Kubernetes 发行版，你可以在任何环境下运行，无论是裸机还是虚拟机。EKS-D 将上游的（未修改的）Kubernetes 和包，按照一定的、特意的方式进行配置，称为 [Kubernetes 发行版](https:\/\/github.com\/cncf\/k8s-conformance\/blob\/master\/faq.md)，并将这些 [作为开源](https:\/\/github.com\/aws\/eks-distro) 提供。fork 和 distribution 之间的区别很重要：fork 是一个替代上游的代码库。另一方面，发行版是一个特定的下游代码库，比如 Linux 发行版有 Ubuntu 和 Amazon Linux 2，比如 Hadoop 发行版，EMR 中有由 Cloudera 提供的并发行版。\n\n从高层的角度来看，EKS Distro 的情况如下（考虑到一些上游的开源项目，包括 Kubernetes 和 etcd）。\n\n![](0081Kckwgy1glhwzx24n5j30sg0p1q45.jpg)\n\n通过 EKS Distro，你可以通过单一供应商安全地访问可安装、可复制的 Kubernetes 构建，以创建集群，并在社区支持到期后提供 Kubernetes 版本的扩展安全补丁支持。我们将根据 Amazon EKS 版本生命周期政策提供长达 14 个月的 Kubernetes 扩展维护支持，为你提供必要的时间窗口来更新你的基础设施，使其与你的软件生命周期保持一致。\n\n## 开始使用 EKS-D\n\n我们与一些 [合作伙伴合作](https:\/\/amazonaws-china.com\/eks\/eks-distro)，提供安装方法以及与 EKS Distro 的集成。下面，我们将重点介绍几家合作伙伴，以及他们为帮助你开始使用 EKS-D 所做的工作。\n\n### Weaveworks\n\nWeave Kubernetes Platform（WKP）为 Amazon EKS Distro（EKS-D）带来了 GitOps，并为内部安装、创建和管理 EKS-D 集群提供支持。与任何 Kubernetes 发行版一样，EKS-D 需要配置、升级以及额外的组件和附加组件，如日志、跟踪和指标。WKP 通过将 GitOps 添加到你的 Kubernetes 环境的每一层，为 EKS-D 或任何其他云端和企业内部的发行版解决了这些问题。通过利用 Cluster API 项目，GitOps 工作流可以管理整个集群生命周期，包括维护、升级和补丁，以及 Prometheus 和 Grafana 等平台组件的集群配置。通过 WKP 交付和管理 EKS-D 集群，应用开发团队可以获得最新的 GitOps 功能，从而实现更频繁的部署，缩短价值实现时间，提高可靠性和可重复性。平台团队还可以获得对内部部署 EKS-D 的全面洞察和观察能力。Weaveworks [发布的博客文章](https:\/\/weave.works\/blog\/on-prem-kubernetes-gitops-eks-distro) 进一步详细描述了 EKS-D 和 WKP 之间的关系。另外一篇文章则是 [在 EKS-D 和 EKS-D 混合场景下的 WKP 演示](https:\/\/weave.works\/blog\/multicluster-gitops-eks-d-wkp)。\n\n### Kubestack\n\nKubestack 就是要为 Terraform 和 Kubernetes 提供最佳的 GitOps 开发者体验，从本地开发，一直到生产。通过他们 [发布博文](https:\/\/dev.to\/kubestack\/localhost-eks-development-environments-with-eks-d-and-kubestack-4p6) 了解如何使用 Kubestack 管理 EKS-D 集群，你也可以找到一个 [视频 demo](https:\/\/www.youtube.com\/watch?v=TcVwtfFww4w)。\n\n### Kubermatic\n\n你可以使用 Kubermatic 的 [KubeOne](https:\/\/www.kubermatic.com\/products\/kubeone\/) 安装 EKS-D。KubeOne 是一个基础设施对等的开源 Kubernetes 集群生命周期管理工具，可以自动部署和 Day 2 操作单个 Kubernetes 集群。了解如何使用 Kubermatic 的开源集群生命周期管理工具 KubeOne 在 AWS 和 Amazon Linux 2 上 [安装 EKS-D](https:\/\/www.kubermatic.com\/blog\/run-amazon-eks-distro-with-kubeone)。\n\n### Aqua Security\n\n为了保护 EKS-D 的安全，你需要一个整体的方法来征服 Kubernetes 的复杂性。Aqua 提供 KSPM（Kubernetes 安全态势管理）来提高可观测性和补救错误配置，以及先进的、无代理的 Kubernetes 运行时保护。你还可以使用 Kubernetes 原生功能，为你的 Kubernetes 应用实现策略驱动的全生命周期保护和合规性。了解更多关于 [Aqua 的 EKS-D 集成的信息](https:\/\/blog.aquasec.com\/aws-security-eks-distro)。\n\n### Sysdig\n\nSysdig 提供安全和可视性，以检测和响应运行时威胁，验证合规性，并监控和排除 EKS-D 上的容器。查看他们的 [发布博客文章](https:\/\/sysdig.com\/blog\/security-compliance-visibility-amazon-eks-d)，了解更多关于使用 CNCF Falco 和 Sysdig Secure 管理 EKS-D 工作负载中的运行时安全的信息。\n\n### Tetrate\n\nTetrate Service Bridge（TSB）[可在 EKS 和 EKS-D 上实现跨工作负载的统一应用连接和安全](https:\/\/www.tetrate.io\/blog\/tetrate-expands-aws-partnership-to-bring-enterprise-grade-istio-for-eks-and-eks-distro\/)。TSB 为企业级（上游或符合 FIPS 标准）Istio 和 Envoy Proxy 提供了便捷的访问和操作性。多租户、流量管理、网状和应用级可观测性、端到端 mTLS（相互传输层安全）、细粒度授权和应用安全是 TSB 的关键要素。\n\n一系列合作伙伴一直在开展更多与 EKS-D 有关的活动，包括：\n\n### 供应和管理\n\n- 了解如何 使用 Rancher 的 RKE2 部署 EKS-D\n-  [看看使用 Canonical 的 MicroK8s 安装 EKS-D](https:\/\/snapcraft.io\/eks) 有多简单 [，一目了](https:\/\/snapcraft.io\/eks) 然\n- 探索如何使用 [Rafay 的托管 Kubernetes 平台（MKP）来管理 EKS-D 集群](https:\/\/rafay.co\/the-kubernetes-current\/how-to-provision-and-manage-amazons-eks-distribution-using-rafay)\n- 查看如何 [使用 Pulumi 配置 EKS-D 集群](https:\/\/pulumi.com\/blog\/amazon-eks-distro)\n- [Upbound Cloud 使 EKS-D 用户可以轻松地将集群的配置整合](https:\/\/blog.upbound.io\/eks-d-and-upbound\/) 到一个与环境无关的 Crossplane 配置库中。利用这些配置，集群就可以通过一个统一的 API 接口在企业内部、云端或边缘进行配置。\n\n### 观察性\n\n- 通过 Instana，你可以 [自动监控和可视化](https:\/\/instana.com\/blog\/instana-brings-best-in-class-observability-with-the-new-amazon-kubernetes-distribution\/) EKS-D 的工作负载\n- Sumo Logic 展示了他们如何 [与 EKS-D 一起工作](https:\/\/www.sumologic.com\/blog\/monitor-aws-kubernetes-service\/)\n- Epsagon 使你能够 [监控 EKS-D 工作负载](https:\/\/epsagon.com\/announcements\/amazon-eks-distro\/)，包括控制平面指标\n- Datadog 提供了跨内部、混合和云计算基础设施的虚拟机、容器和无服务器环境的健康状况的可视性。了解有关 [EKS-D 支持](https:\/\/www.datadoghq.com\/blog\/amazon-eks-distro-monitoring\/) 的更多信息。\n- Splunk 基础设施监控为所有 Kubernetes 环境 —— 云原生 Amazon EKS、与 Amazon Outposts 的混合 [环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 以及内部 [自我管理的 EKS-D 环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 提供了企业级监控解决方案。\n\n### 安全\n\n- 了解 [Nirmata 的 EKS 管理器与 EKS-D 的集成](https:\/\/nirmata.com\/2020\/11\/20\/nirmata-delivers-consistent-hybrid-cloud-kubernetes-with-aws\/)，以及如何使用它来加强你的安全态势\n- Alcide 为跨越 EKS、Outposts 和 [新增加的 EKS-D 的](https:\/\/blog.alcide.io\/alcide-and-amazon-eks-distro) 混合部署提供集中统一的安全覆盖\n- 查看 Tigera 围绕 Calico 和 Calico Enterprise 支持所 做的工作 ，以实现运行 EKS-D 的集群的强大安全性和合规性。\n\n你可以想象，这只是旅程的开始。你可能会问，下一步是什么？\n\n## 下一步\n\n要开始使用 EKS Distro，请访问 [https:\/\/distro.eks.amazonaws.com](https:\/\/distro.eks.amazonaws.com\/)，并使用 kops 或 kubeadm 或上述任何一个合作伙伴提供的解决方案亲自尝试。\n\n你可以通过 GitHub 提供反馈和 PR，成为 EKS-D 社区的一员。如果你喜欢更多的互动交流，可以在 Kubernetes Slack 社区通过 #eks 频道或 AWS 开发者 Slack 频道加入我们，我们在那里设置了 #eks-d 频道。\n\n我们很高兴了解你使用 EKS Distro 的情况，并听取你的反馈和建议。\n', '\/trans\/introducing-amazon-eks-distro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/must-read-for-cloud-native-beginner/">云原生初学者入门必读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/10/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生初学者入门必读', '这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。', '\n## 为什么写这篇文章\n\n看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。\n\n因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。\n\n## 引言\n\n[Kubernetes](https:\/\/kubernetes.io\/) 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。\n\nKubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。\n\n这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。\n\n简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 [Docker](https:\/\/docker.com\/) 容器。让我们深入了解一下这些概念。\n\n## 容器和容器化\n\n那么什么是容器呢？\n\n要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。\n\n接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。\n\n现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。\n\n虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。\n\n解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。\n\n但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！\n\n更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。\n\n与容器相关的一个重要概念是**微服务**。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。\n\n## 从 Docker 开始\n\n现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。\n\nDocker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。\n\n还有其他的容器化工具，如 [CoreOS rkt](https:\/\/coreos.com\/rkt\/)、[Mesos Containerizer](http:\/\/mesos.apache.org\/documentation\/latest\/mesos-containerizer\/) 和 [LXC](https:\/\/linuxcontainers.org\/)。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。\n\n## 再到 Kubernetes\n\n首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。\n\n那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。\n\n现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。\n\n这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。\n\n我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。\n\n接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。\n\n## Kubernetes 架构和组件\n\n首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。\n\n例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。\n\n现在我们来定义一些 Kubernetes 的重要组件。\n\n当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。\n\nKubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。\n\n主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。\n\nMaster 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。\n\nWoker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。\n\nKubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。\n\nKubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。\n\nReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。\n\n## 什么是 Kubectl？\n\nkubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。\n\n## Kubernetes 中的自动扩展\n\n请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。\n\n自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。\n\n无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。\n\n我们再继续说一些概念，这次是和网络有关的。\n\n## 什么是 kubernetes Ingress 和 Egress？\n\n外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。\n\n进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 \/ 流量的地方。\n\n## 什么是 Ingress Controller？\n\n但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。\n\n## 什么是 Replica 和 ReplicaSet？\n\n为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。\n\n所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。\n\n因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。\n\n## 什么是服务网格？\n\n[服务网格 (Service Mesh)](\/blog\/what-is-a-service-mesh\/) 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 [Kubernetes 次世代的云原生应用](\/blog\/post-kubernetes-era\/) 的重要组成部分。\n\n服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。\n\n所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。\n\n如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。\n\n在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。\n\n在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。\n\n## 如何学习 Kubernetes？\n\n自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。\n\n### 一、从零开始学习和安装 Kubernetes\n\n要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -\u003e 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 [Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。\n\n### 二、Kubernetes 自托管解决方案\n\n这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 [Minikube](https:\/\/github.com\/kubernetes\/minikube)、[MicroK8s](https:\/\/github.com\/ubuntu\/microk8s)、[Docker Desktop](https:\/\/docs.docker.com\/docker-for-windows\/kubernetes\/) 和 [Kind](https:\/\/github.com\/kubernetes-sigs\/kind)。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。\n\n### 三、云托管的解决方案\n\n如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 [Katacoda](https:\/\/katacoda.com\/) 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。\n\n## 本地测试和调试 Kubernetes\n\n作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。\n\n用于在本地开发和调试 Kubernetes 服务的工具有：[Microsoft Bridge to Kubernetes](https:\/\/github.com\/microsoft\/mindaro) 和 [telepresence](https:\/\/github.com\/telepresenceio\/telepresence)。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。\n\nKubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。\n\n## Kubernetes 监控工具\n\nKubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。\n\n毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。\n\nKubernetes 包含两个内置度量收集工具用于监控：[资源管道和全度量管道](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/resource-usage-monitoring\/)。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。\n\n还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。\n\n### Prometheus 监控\n\nPrometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。\n\n### Grafana 仪表盘\n\nGrafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。\n\n### 高级警报\n\n对于高级警报，你可以添加 [Nagios](https:\/\/www.nagios.org\/) 或 [Prometheus Alertmanager](https:\/\/github.com\/prometheus\/alertmanager) 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。\n\n现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。\n\n调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？\n\n请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。\n\n## 更多\n\n云原生领域的开源项目众多（见 [Awesome Cloud Native\/云原生开源项目大全](\/awesome-cloud-native)），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读[官方文档](https:\/\/kubernetes.io)和实践来学习，也可以参考我编写的[Kubernetes Handbook——Kubernetes 中文指南 \/ 云原生架构实践手册](\/book\/kubernetes-handbook)。\n\n推荐大家加入我发起创办的[云原生社区](https:\/\/cloudnativecn.com)，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的[云原生学院](https:\/\/github.com\/cloudnativeto\/academy)定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。\n', '\/blog\/must-read-for-cloud-native-beginner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/post-kubernetes-era/">Kubernetes 次世代的云原生应用</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/06/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f"> 
             云原生
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 次世代的云原生应用', 'Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。', '\nKubernetes 自开源至今已经走过六个年头了，[云原生时代](https:\/\/cloudnativecn.com\/blog\/cloud-native-era\/)也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为[《云原生应用白皮书》](https:\/\/jimmysong.io\/guide-to-cloud-native-app)的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。\n## 重点\n\n- 云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。\n- Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。\n- Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。\n- OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。\n- “Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生**应用**架构的时代即将到来。\n\nKubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。\n\n## 云原生的不同发展阶段\n\nKubernetes 从开源至今已经走过快[六个年头](https:\/\/jimmysong.io\/cloud-native\/memo\/open-source\/)（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。\n\n![云原生的发展阶段](cloud-native-stages.png)\n\n**第一阶段：孵化期（2014 年）**\n\n2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。\n\n**第二阶段：高速发展期（2015 年 - 2016 年）**\n\n这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。\n\n**第三阶段：野蛮生长期（2017 年 - 2018 年）**\n\n2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是[后 Kubernetes 时代的微服务](https:\/\/jimmysong.io\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/)，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF [毕业](https:\/\/www.cncf.io\/blog\/2018\/03\/06\/kubernetes-first-cncf-project-graduate\/)，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 [2017 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html)和 [2018 年](https:\/\/jimmysong.io\/kubernetes-handbook\/appendix\/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html)的预测和总结。\n\n**第四阶段：普及推广期（2019 年至今）**\n\n经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。\n\n## Kubernetes 开辟了云原生时代\n\nKubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。\n\n下图是 Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。\n\n![Kubernetes 概念](kubernetes-concepts.png)\n\n图片来自图书 [Kubernetes Patterns（O’Reilly）](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n\nKubernetes 作为云原生基础设施设计之初遵循了以下原则：\n\n1. 基础设施即代码（声明式 API）\n1. 不可变基础设施\n1. 幂等性\n1. 调节器模式（Operator 的原理）\n\n其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他[云部署形式](https:\/\/jimmysong.io\/cloud-native-infra\/evolution-of-cloud-native-developments.html)的主要区别之一，这也为后来的 [Operator 框架的诞生](https:\/\/zhuanlan.zhihu.com\/p\/54633203)打下了基础。\n\n### 声明式 API\n\n根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？\n\n我们在创建 \u0060Deployment\u0060 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用[动态准入控制](https:\/\/kubernetes.io\/zh\/docs\/reference\/access-authn-authz\/extensible-admission-controllers\/#monitoring-admission-webhooks)来达到这一点。\n\n### Kubernetes 原生应用\n\n我们都知道要想运行一个应用至少需要以下几点：\n\n- 应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。\n- 应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。\n- 应用的生命周期管理（各种 Controller 登场）。\n- 可观测性、可运维、网络和资源及环境依赖、隔离性等。\n\n下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。\n\n![Kubernetes 原生应用](kubernetes-native-application-motion.gif)\n\n我们都知道 Kubernetes 提供了大量的[原语](https:\/\/kubernetes.io\/docs\/concepts\/)，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 [OpenKruise](https:\/\/github.com\/openkruise\/kruise)、Istio），实际上 [Operator](https:\/\/operatorhub.io\/) 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。\n\nKubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。\n\n我将 Kubernetes 原生应用所需要的定义和资源进行了分层：\n\n- **核心层**：应用逻辑、服务定义、生命周期控制；\n- **隔离与服务访问层**：资源限制与隔离、配置、身份、路由规则等；\n- **调度层**：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；\n- **资源层**：提供网络、存储和其他平台资源；\n\n而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。\n\n云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。\n\n同一个资源对象又有多种实现方式，比如 Ingress 就有 [10 多种实现](https:\/\/docs.google.com\/spreadsheets\/d\/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k\/edit#gid=0)，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。\n\n![资源交集动画](resources-motion.gif)\n\n上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。\n\n为了管理这些应用诞生出了众多的 [Operator](https:\/\/github.com\/operator-framework\/awesome-operators)。Kubernetes 1.7 版本以来就引入了[自定义控制器](https:\/\/kubernetes.io\/docs\/concepts\/api-extension\/custom-resources\/)的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API 进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods\/Services、对正在运行的应用进行扩缩容。\n\nOperator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。\n\n调节器模式的四个原则：\n\n1. 所有的输入和输出都使用数据结构。\n1. 确保数据结构是不可变的。\n1. 保持资源映射简单。\n1. 使实际状态符合预期状态。\n\n## 云原生应用走向碎片化\n\n利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。\n\n**云原生应用碎片化的体现**\n\n- Operator 模式将运维人员的反应式经验转化成基于 \u0060Reconcile\u0060 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。\n- 开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。\n- Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。\n\n\n### 有状态应用管理难题\n\nKubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。\n\n例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 \u0060ConfigMap\u0060、复杂的启动脚本才能[在 Kubernetes 上定义 Hadoop YARN](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/migrating-hadoop-yarn-to-kubernetes.html) 和[运行 Spark](https:\/\/jimmysong.io\/kubernetes-handbook\/usecases\/running-spark-with-kubernetes-native-scheduler.html)。虽然 [\u0060StatefulSet\u0060](https:\/\/kubernetes.io\/docs\/concepts\/workloads\/controllers\/statefulset\/) 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master\/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 \u0060ConfigMap\u0060 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。\n\n### Operator 统一了 Kubernetes 应用运维框架\n\nOperator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过[构建自己的 Operator](https:\/\/zhuanlan.zhihu.com\/p\/54633203) 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 [Istio](https:\/\/istio.io)、[Knative](https:\/\/knative.dev)），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。\n\nOperator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：\n\n- **独立**：互不干涉，比如 Controller 与服务发现之间就不存在冲突。\n- **可组合**：例如 \u0060Service\u0060、\u0060VirtualService\u0060、\u0060DestinationRule\u0060 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。\n- **有冲突**：例如图中的 \u0060CronHorizontalPodAutoscaler\u0060（CRD）、\u0060HorizontalPodAutoscaler\u0060（Kubernetes 内置），同时使用可能导致无法意料的情况发生。\n\n正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的系列开源项目。\n\n## 云原生应用管理工具 Helm\n\nKubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：\n\n- 应用程序启动时加载的配置文件；\n- 应用程序的运维配置，如资源申请限额；\n- 应用程序的服务发现配置；\n- 应用程序的工作负载、发布策略、依赖等；\n\n这些配置可以存在于 \u0060ConfigMap\u0060、\u0060Deployment\u0060、\u0060Service\u0060、\u0060Ingress\u0060 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。\n\n云原生应用打包和发布管理\n\n- Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；\n- Chart 仓库提供了云原生应用程序的统一管控视图；\n- \u0060Release\u0060 概念的引入，使得云原生应用版本化管理进一步加强；\n\nHelm 主要关注的是 [12 因素应用](https:\/\/12factor.net\/zh_cn\/)法则[构建、发布、运行](https:\/\/12factor.net\/zh_cn\/build-release-run)这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。\n\n![Helm3 架构](helm-chart.png)\n\nHelm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 \u0060helm upgrade\u0060，release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。\n\n### 打包、配置和发布\n\nHelm 和 chart 的主要作用是：\n\n- 应用程序封装\n- 版本管理\n- 依赖检查\n- 便于应用程序分发\n\n**打包**\n\nHelm 采用 [Chart](https:\/\/helm.sh\/docs\/topics\/charts\/) 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。\n\n**配置**\n\n应用配置参数，在 Chart 中由 \u0060values.yaml\u0060 和命令行参数组成。Chart 采用 Go Template 的特性和 \u0060values.yaml\u0060 对部署的模板文件进行参数渲染，也可以通过 \u0060helm\u0060 命令 \u0060--set key=value\u0060 的方式进行参数赋值。\n\n**发布**\n\nRelease 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。\n\n## 云原生应用\n\n以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：\n\n- 运行时：ECS、Docker、KataContainer、gVisor 等；\n- 资源隔离性：多租户、VPC、Namespace、防火墙；\n- 资源调度：各种类型的 controller；\n- 网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；\n- 可观测性：日志、分布式追踪、指标；\n- 安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；\n- 平台资源申请：数据库、存储等；\n- 运行与隔离：ECS、Docker、KataContainer 等；\n- 资源分配和调度：各种控制器；\n- 环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；\n- 可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；\n- 状态管理：Operator；\n- 可观测性：日志、监控、指标；\n- 安全性：SecurityPolicy、ServiceAccount；\n\n### 云原生应用分层模型\n\n那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在[应用交付领域](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。\n\n![云原生应用的分层模型](cloud-native-app.png)\n\n- **应用定义和包装**：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；\n- **负载定义**：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。[Istio](https:\/\/istio.io) 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观测性。\n- **应用发布和上线**：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；\n- **Kubernetes 原语**：Kubernetes 本身提供的原语，Operator 基于此构建；\n\n以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：[The Dictionary of Cloud-Native App Delivery](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)。\n\nPlatform\/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。\n\n### OAM（开放应用模型）\n\n那么以上这么多应用有哪些共性，能不能再进一步抽象呢？\n\n- 所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；\n- 在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；\n- 要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 \u0060VirtualService\u0060、\u0060DestinationRule\u0060，二者同时使用；\n\n一个 \u0060ApplicationConfiguration\u0060 的 Runtime 的正常流程应该是：\n\n- 应用开发者创建自己的 \u0060Component\u0060，在 \u0060Component\u0060 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；\n- 运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 \u0060Component\u0060 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 \u0060ApplicationConfiguration\u0060的下发，生成 \u0060Component\u0060 对应的 \u0060Workload\u0060 和 \u0060Trait\u0060，\u0060Trait\u0060 controller 将本次的 \u0060Trait\u0060 策略应用到本次要管理的 \u0060Workload\u0060 当中，最终到达终态，完成一次发布。\n\nOAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：\n\n- Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；\n- Trait：各种运维规则，比如扩缩容、流量控制、安全性；\n\n### 生态\n\n以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，[CNCF 宣布成立 SIG App Delivery](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj) 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。[应用交付 SIG](https:\/\/github.com\/cncf\/sig-app-delivery) 的使命是：\n\n- 在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。\n- 发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。\n- 识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。\n\n目前 OAM 定义的云原生应用模型已有以下项目支持。\n\n- [Crossplane](https:\/\/crossplane.io\/)：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 \u0060kubectl\u0060 配置和管理基础架构、服务和应用。对于 OAM 的支持详见运行应用程序。\n- KPT：Kpt（发音为 \u0022keep\u0022）是一个在资源配置之上构建声明性工作流的开源工具。它的 git \u002b YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序。\n\n应用交付领域相关的开源项目还有很多，详见 [Awesome Cloud Native](https:\/\/jimmysong.io\/awesome-cloud-native\/#application-delivery)。\n\n## 总结\n\n基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 [OAM 社区](https:\/\/oam.dev\/)，一起参与进来，把国人参与指定的标准推向世界。\n\n## 参考\n\n- [Do you know what’s in Helm 3? - developer.ibm.com](https:\/\/developer.ibm.com\/technologies\/containers\/blogs\/kubernetes-helm-3\/)\n- [O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com](https:\/\/www.redhat.com\/cms\/managed-files\/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf)\n- [The Dictionary of Cloud-Native App Delivery - docs.google.com](https:\/\/docs.google.com\/document\/d\/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo\/edit#heading=h.h9so53gv5zen)\n- [CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn](https:\/\/www.infoq.cn\/article\/Cdw7ISlEqKilGyN9V3Pj)\n- [OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/c7A8lOdAKkW25GoqmwOgWg)\n- [Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com](https:\/\/zhuanlan.zhihu.com\/p\/54633203)\n- [云原生时代——投资人视角下的云原生趋势思考 - cloudnativecn.com](https:\/\/cloudnativecn.com\/blog\/cloud-native-era\/)\n', '\/blog\/post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kubernetes 的次世代在于解决 Kubernetes 生态的碎片化问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-in-action-by-yangzhangxian-review/">《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感', '顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。', '\n最近在回顾 Service Mesh 技术在 2018 年的发展，想再看看 Linkerd，正好**杨彰显**的这本《Service Mesh 实战——基于 Linkerd 和 Kubernetes 的微服务实践》上市发售了，**机械工业出版社**的编辑送了我一本，🙏**杨福川**编辑，我看了下抽空写了点读后感，我看了下抽空写了点读后感，其实也说不上是读后感，就当是自己的一点感悟吧，就当拿此书借题发挥吧，这个知识爆炸的年代，技术发展如此迅速，可以说是 IT 人员的幸运，也是不幸！有多少写开源软件的书推出一版后能撑过三年的？如果软件红得发紫，持续迭代 N 个版本，例如 Kubernetes，最近两年以每三个月一个版本的速度迭代，之前的书早就跟不上节奏，要么就要不断推出新版，直到软件稳定后不再有大的改动。还有种可能就是软件推广和发展的不理想，无人问津，写这样软件的书就不会有再版了。\n\n拿到本书后我的第一反应就是看看这本书定稿的时候 Istio 是什么版本，Linkerd 又是什么版本。因为在这一年内两款开源软件都有较大的版本变动，如果书籍定稿的时候基于的软件版本太低，软件架构可能会有较大的变化，影响书中示例和部分章节的时效性。这也是大多技术书籍名短的症结所在，技术发展是在太快，传统的书籍出版流程往往过于繁琐和冗长，等到书籍出版后所介绍的软件都出了好几个版本。例如 Kubernetes 这种的软件，每三个月一个版本，而写一般书从策划到发行少说半年，一般也要一年的时间。\n\n## 关于书籍定稿时的软件版本\n\n**Istio 0.8**\n\n本书第一章「Service Mesh 简介」对 Service Mesh 相关开源产品介绍时提到本书定稿时 Istio 是 0.8 版本，而 Istio 在 2018 年 7 月 31 日发布了 1.0 版本。\n\n这本书定稿时，Istio 的最新版本是 0.8。\n\n**Linkerd 1.3.6**\n\n本书从序言开始一直到第二章结束也没有提及写作时基于的 Linkerd 版本，我在第二章的安装步骤中看到了说明。\n\n可以看到本书写作时是基于 Linkerd 1.3.6 版本，而 Linkerd 在同年的 9 月 18 日发布了 [2.0 GA](https:\/\/cloudnativecn.com\/blog\/linkerd-2-0-in-general-availability\/)，这一版本跟 1.x 版本相比有重大变化——它还将项目从集群范围的 service mesh 转换为可组合的 *service sidecar* ，旨在为开发人员和服务所有者提供在云原生环境中成功所需的关键工具。\n\n## Linkerd vs Envoy\n\nLinkerd 2.0 的 service sidecar 设计使开发人员和服务所有者能够在他们的服务上运行 Linkerd，提供自动可观测性、可靠性和运行时诊断，而无需更改配置或代码。通过提供轻量级的增量路径来获得平台范围的遥测、安全性和可靠性的传统 service mesh 功能，service sidecar 方法还降低了平台所有者和系统架构师的风险。该版本还用 Rust 重写了代理部分，在延迟，吞吐量和资源消耗方面产生了数量级的改进。\n\n而 Linkerd 1.x 继承自 Twitter 开源的 Finagle 高性能 RPC，所有想要深度学习 Linkerd 1.x 还需要了解 Finagle，这就跟 Istio 将 Envoy 作为默认的数据平面一样，要想深度学习 Istio 必须了解 Envoy。\n\n二者几乎使用了完全不同的术语，假如你已经了解了 [Envoy](https:\/\/envoyproxy.io) 想要再切换到 Linkerd 上，那么就要再费很多心力来学习它的概念和原理，例如如下这些术语或配置（Linkerd 中独有的配置）：\n\n- **dtab（委托表）**：由一系列路由组成，由一系列路由规则组成，以逻辑路径为输入，然后经过路由规则做一系列转换生成具体名字。这是 Linkerd 路由机制的根本，就像 Envoy 中的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)一样，本书的第四章「深入 Linkerd 数据访问流」专门讲解了 dtab 的实现机制。\n- **dentry（委托表记录）**：委托表的每条路由规则称为 dentry，如 \/consul =\u003e \/#\/io.l5d.consul\/dc1。\n- **namer**：配置 Linkerd 支持的服务发现工具。\n- **namerd**：Linkerd 的控制平面，相当于 Istio 中的 Pilot，对接各种服务发现。当然 Linkerd 也可以直接与某个服务发现平台对接如 consul，而不使用 namerd 这个集中路由和配置管理组件。\n- **interpreter**：interpreter 决定如何解析服务名字和客户端名字。\n\n虽然 Linkerd 也是 [CNCF 中的项目](https:\/\/www.cncf.io\/projects\/)，但它目前还处于孵化阶段，而 Envoy 的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)已经被众多开源项目所支持，如 [Istio](https:\/\/istio.io\/zh)、[SOFAMesh](https:\/\/github.com\/alipay\/sofa-mesh)、[NginxMesh](https:\/\/github.com\/nginxinc\/nginmesh) 等，且 Envoy 已经从 CNCF 中毕业，以后可能成为 Service Mesh 领域的标准协议，Linkerd 的生存状况堪忧。\n\n## 关于本书\n\n本书中所有示例都提供了虚拟机的快速上手环境，只要使用 Vagrant 即可创建虚拟机和应用，所以在本书的[示例代码](https:\/\/github.com\/yangzhares\/linkerd-in-action)有大量的 Vagrantfile。\n\n本书第三部分「实战篇」花了大量篇幅（本书一半的页数）来讲解如何使用 Linkerd 和 Kubernetes 来管理微服务，可以参考我 2017 年 8 月 1 日写的这篇[微服务管理框架 service mesh——Linkerd 安装试用笔记](https:\/\/jimmysong.io\/posts\/linkerd-user-guide\/)，那时候还是基于 Linkerd 1.1.2，还有 [Linkerd 官方示例](https:\/\/github.com\/linkerd\/linkerd-examples\/)，这些示例基本都不怎么更新了。\n\n因为该书定稿时所基于的 Linkerd 版本距离本书发售时的 Linkerd 已经落后一个大版本（最新版本是 [Linkerd 2.1](https:\/\/blog.linkerd.io\/2018\/12\/06\/announcing-linkerd-2-1\/)），所以读者一定要注意这一点，老实说我只花了两个夜晚快速过了一下本书，无法对本书内容给出具体评论，所以本书是否是你所需要的就要你自己去思考了。\n\n', '\/blog\/service-mesh-in-action-by-yangzhangxian-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/configuring-kubernetes-kube-dns/">配置 Kubernetes DNS 服务 kube-dns</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('配置 Kubernetes DNS 服务 kube-dns', '配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。', '\n在我们安装 Kubernetes 集群的时候就已经安装了 kube-dns 插件，这个插件也是官方推荐安装的。通过将 Service 注册到 DNS 中，Kuberentes 可以为我们提供一种简单的服务注册发现与负载均衡方式。\n\n[CoreDNS](https:\/\/coredns.io)作为 CNCF 中的托管的一个项目，在 Kuberentes1.9 版本中，使用 kubeadm 方式安装的集群可以通过以下命令直接安装 CoreDNS。\n\n\u0060\u0060\u0060bash\nkubeadm init --feature-gates=CoreDNS=true\n\u0060\u0060\u0060\n\n您也可以使用 CoreDNS 替换 Kubernetes 插件 kube-dns，可以使用 Pod 部署也可以独立部署，请参考[Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)，下文将介绍如何配置 kube-dns。\n\n本文已归档到[kubernetes-handbook](\/book\/kubernetes-handbook)中。\n\n## kube-dns\n\nkube-dns 是 Kubernetes 中的一个内置插件，目前作为一个独立的开源项目维护，见 https:\/\/github.com\/kubernetes\/dns。\n\n下文中给出了配置 DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。\n\n## 前提要求\n\n- Kubernetes 1.6 及以上版本。\n- 集群必须使用 \u0060kube-dns\u0060 插件进行配置。\n\n## kube-dns 介绍\n\n从 Kubernetes v1.3 版本开始，使用 [cluster add-on 插件管理器回自动启动内置的 DNS。\n\nKubernetes DNS pod 中包括 3 个容器：\n\n- \u0060kubedns\u0060：\u0060kubedns\u0060 进程监视 Kubernetes master 中的 Service 和 Endpoint 的变化，并维护内存查找结构来服务 DNS 请求。\n- \u0060dnsmasq\u0060：\u0060dnsmasq\u0060 容器添加 DNS 缓存以提高性能。\n- \u0060sidecar\u0060：\u0060sidecar\u0060 容器在执行双重健康检查（针对 \u0060dnsmasq\u0060 和 \u0060kubedns\u0060）时提供单个健康检查端点（监听在 10054 端口）。\n\nDNS  pod 具有静态 IP 并作为 Kubernetes 服务暴露出来。该静态 IP 分配后，kubelet 会将使用 \u0060--cluster-dns = \u003cdns-service-ip\u003e\u0060 标志配置的 DNS 传递给每个容器。\n\nDNS 名称也需要域名。本地域可以使用标志 \u0060--cluster-domain = \u003cdefault-local-domain\u003e\u0060 在 kubelet 中配置。\n\nKubernetes 集群 DNS 服务器基于 [SkyDNS](https:\/\/github.com\/skynetservices\/skydns) 库。它支持正向查找（A 记录），服务查找（SRV 记录）和反向 IP 地址查找（PTR 记录）\n\n## kube-dns 支持的 DNS 格式\n\nkube-dns 将分别为 service 和 pod 生成不同格式的 DNS 记录。\n\n**Service**\n\n- A 记录：生成\u0060my-svc.my-namespace.svc.cluster.local\u0060域名，解析成 IP 地址，分为两种情况：\n  - 普通 Service：解析成 ClusterIP\n  - Headless Service：解析为指定 Pod 的 IP 列表\n- SRV 记录：为命名的端口（普通 Service 或 Headless Service）生成 \u0060_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local\u0060 的域名\n\n**Pod**\n\n- A 记录：生成域名 \u0060pod-ip.my-namespace.pod.cluster.local\u0060\n\n## kube-dns 存根域名\n\n可以在 Pod 中指定 hostname 和 subdomain：\u0060hostname.custom-subdomain.default.svc.cluster.local\u0060，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  labels:\n    name: busybox\nspec:\n  hostname: busybox-1\n  subdomain: busybox-subdomain\n  containers:\n  name: busybox\n  - image: busybox\n    command:\n    - sleep\n    - \u00223600\u0022\n\u0060\u0060\u0060\n\n该 Pod 的域名是 \u0060busybox-1.busybox-subdomain.default.svc.cluster.local\u0060。\n\n## 继承节点的 DNS\n\n运行 Pod 时，kubelet 将预先配置集群 DNS 服务器到 Pod 中，并搜索节点自己的 DNS 设置路径。如果节点能够解析特定于较大环境的 DNS 名称，那么 Pod 应该也能够解析。请参阅下面的[已知问题](#known-issues)以了解警告。\n\n如果您不想要这个，或者您想要为 Pod 设置不同的 DNS 配置，您可以给 kubelet 指定 \u0060--resolv-conf\u0060 标志。将该值设置为 \u0022\u0022 意味着 Pod 不继承 DNS。将其设置为有效的文件路径意味着 kubelet 将使用此文件而不是 \u0060\/etc\/resolv.conf\u0060 用于 DNS 继承。\n\n## 配置存根域和上游 DNS 服务器\n\n通过为 kube-dns（\u0060kube-system:kube-dns\u0060）提供一个 ConfigMap，集群管理员能够指定自定义存根域和上游 nameserver。\n\n例如，下面的 ConfigMap 建立了一个 DNS 配置，它具有一个单独的存根域和两个上游 nameserver：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“acme.local”: [“1.2.3.4”]}\n  upstreamNameservers: |\n    [“8.8.8.8”, “8.8.4.4”]\n\u0060\u0060\u0060\n\n如上面指定的那样，带有“.acme.local”后缀的 DNS 请求被转发到 1.2.3.4 处监听的 DNS。Google Public DNS 为上游查询提供服务。\n\n下表描述了如何将具有特定域名的查询映射到其目标 DNS 服务器：\n\n| 域名                                   | 响应查询的服务器                   |\n| ------------------------------------ | -------------------------- |\n| kubernetes.default.svc.cluster.local | kube-dns                   |\n| foo.acme.local                       | 自定义 DNS (1.2.3.4)          |\n| widget.com                           | 上游 DNS (8.8.8.8 或 8.8.4.4) |\n\n查看 [ConfigMap 选项](#configmap-options) 获取更多关于配置选项格式的详细信息。\n\n### 对 Pod 的影响\n\n自定义的上游名称服务器和存根域不会影响那些将自己的 \u0060dnsPolicy\u0060 设置为 \u0060Default\u0060 或者 \u0060None\u0060 的 Pod。\n\n如果 Pod 的 \u0060dnsPolicy\u0060 设置为“\u0060ClusterFirst\u0060”，则其名称解析将按其他方式处理，具体取决于存根域和上游 DNS 服务器的配置。\n\n**未进行自定义配置**：没有匹配上配置的集群域名后缀的任何请求，例如“www.kubernetes.io”，将会被转发到继承自节点的上游 nameserver。\n\n**进行自定义配置**：如果配置了存根域和上游 DNS 服务器（和在 [前面例子](#configuring-stub-domain-and-upstream-dns-servers) 配置的一样），DNS 查询将根据下面的流程进行路由：\n\n1. 查询首先被发送到 kube-dns 中的 DNS 缓存层。\n\n2. 从缓存层，检查请求的后缀，并转发到合适的 DNS 上，基于如下的示例：\n\n   -  *具有集群后缀的名字* （例如“.cluster.local”）：请求被发送到 kube-dns。\n   -  *具有存根域后缀的名字* （例如“.acme.local”）：请求被发送到配置的自定义 DNS 解析器（例如：监听在 1.2.3.4）。\n   -  *不具有能匹配上后缀的名字* （例如“widget.com”）：请求被转发到上游 DNS（例如：Google 公共 DNS 服务器，8.8.8.8 和 8.8.4.4）。\n\n   ![DNS lookup flow](https:\/\/d33wubrfki0l68.cloudfront.net\/340889cb80e81dcd19a16bc34697a7907e2b229a\/24ad0\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/dns.png)\n\n## ConfigMap 选项\n\nkube-dns \u0060kube-system:kube-dns\u0060 ConfigMap 的选项如下所示：\n\n| 字段                        | 格式                                       | 描述                                       |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| \u0060stubDomains\u0060（可选）         | 使用 DNS 后缀 key 的 JSON map（例如“acme.local”），以及 DNS IP 的 JSON 数组作为 value。 | 目标 nameserver 可能是一个 Kubernetes Service。例如，可以运行自己的 dnsmasq 副本，将 DNS 名字暴露到 ClusterDNS namespace 中。 |\n| \u0060upstreamNameservers\u0060（可选） | DNS IP 的 JSON 数组。                        | 注意：如果指定，则指定的值会替换掉被默认从节点的 \u0060\/etc\/resolv.conf\u0060 中获取到的 nameserver。限制：最多可以指定三个上游 nameserver。 |\n\n### 示例\n\n#### 示例：存根域\n\n在这个例子中，用户有一个 Consul DNS 服务发现系统，他们希望能够与 kube-dns 集成起来。Consul 域名服务器地址为 10.150.0.1，所有的 Consul 名字具有后缀“.consul.local”。要配置 Kubernetes，集群管理员只需要简单地创建一个 ConfigMap 对象，如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“consul.local”: [“10.150.0.1”]}\n\u0060\u0060\u0060\n\n注意，集群管理员不希望覆盖节点的上游 nameserver，所以他们不会指定可选的 \u0060upstreamNameservers\u0060 字段。\n\n#### 示例：上游 nameserver\n\n在这个示例中，集群管理员不希望显式地强制所有非集群 DNS 查询进入到他们自己的 nameserver 172.16.0.1。而且这很容易实现：他们只需要创建一个 ConfigMap，\u0060upstreamNameservers\u0060 字段指定期望的 nameserver 即可。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  upstreamNameservers: |\n    [“172.16.0.1”]\n\u0060\u0060\u0060\n\n## 调试 DNS 解析\n\n### 创建一个简单的 Pod 用作测试环境\n\n创建一个名为 busybox.yaml 的文件，其中包括以下内容：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  namespace: default\nspec:\n  containers:\n  - name: busybox\n    image: busybox\n    command:\n      - sleep\n      - \u00223600\u0022\n    imagePullPolicy: IfNotPresent\n  restartPolicy: Always\n\u0060\u0060\u0060\n\n使用该文件创建 Pod 并验证其状态：\n\n\u0060\u0060\u0060shell\n$ kubectl create -f busybox.yaml\npod \u0022busybox\u0022 created\n\n$ kubectl get pods busybox\nNAME      READY     STATUS    RESTARTS   AGE\nbusybox   1\/1       Running   0          \u003csome-time\u003e\n\u0060\u0060\u0060\n\n该 Pod 运行后，您可以在它的环境中执行 \u0060nslookup\u0060。如果您看到类似如下的输出，表示 DNS 正在正确工作。\n\n\u0060\u0060\u0060shell\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nName:      kubernetes.default\nAddress 1: 10.0.0.1\n\u0060\u0060\u0060\n\n如果 \u0060nslookup\u0060 命令失败，检查如下内容：\n\n### 首先检查本地 DNS 配置\n\n查看下 resolv.conf 文件。（参考[集成节点的 DNS](#inheriting-dns-from-the-node)和 下面的[已知问题](#known-issues)获取更多信息）\n\n\u0060\u0060\u0060shell\n$ kubectl exec busybox cat \/etc\/resolv.conf\n\u0060\u0060\u0060\n\n验证搜索路径和名称服务器设置如下（请注意，搜索路径可能因不同的云提供商而异）：\n\n\u0060\u0060\u0060bash\nsearch default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal\nnameserver 10.0.0.10\noptions ndots:5\n\u0060\u0060\u0060\n\n如果看到如下错误表明错误来自 kube-dns 或相关服务：\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n或者\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n### 检查 DNS pod 是否在运行\n\n使用 \u0060kubectl get pods\u0060 命令验证 DNS pod 是否正在运行。\n\n\u0060\u0060\u0060shell\n$ kubectl get pods --namespace=kube-system -l k8s-app=kube-dns\nNAME                    READY     STATUS    RESTARTS   AGE\n...\nkube-dns-v19-ezo1y      3\/3       Running   0           1h\n...\n\u0060\u0060\u0060\n\n如果您看到没有 Pod 运行或者 Pod 处于 失败\/完成 状态，DNS 插件可能没有部署到您的当前环境中，您需要手动部署。\n\n### 检查 DNS pod 中的错误\n\n使用 \u0060kubectl logs\u0060 命令查看 DNS 守护进程的日志。\n\n\u0060\u0060\u0060shell\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c kubedns\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c dnsmasq\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c sidecar\n\u0060\u0060\u0060\n\n看看有没有可疑的日志。以字母“\u0060W\u0060”，“\u0060E\u0060”，“\u0060F\u0060”开头的代表警告、错误和失败。请搜索具有这些日志级别的条目，并使用 [kubernetes issues](https:\/\/github.com\/kubernetes\/kubernetes\/issues)来报告意外错误。\n\n### DNS 服务启动了吗？\n\n使用 \u0060kubectl get service\u0060 命令验证 DNS 服务是否启动。\n\n\u0060\u0060\u0060shell\n$ kubectl get svc --namespace=kube-system\nNAME          CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE\n...\nkube-dns      10.0.0.10      \u003cnone\u003e        53\/UDP,53\/TCP        1h\n...\n\u0060\u0060\u0060\n\n如果您已经创建了该服务或它本应该默认创建但没有出现，参考[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)获取更多信息。\n\n### DNS 端点暴露出来了吗？\n\n您可以使用\u0060kubectl get endpoints\u0060命令验证 DNS 端点是否被暴露。\n\n\u0060\u0060\u0060shell\n$ kubectl get ep kube-dns --namespace=kube-system\nNAME       ENDPOINTS                       AGE\nkube-dns   10.180.3.17:53,10.180.3.17:53    1h\n\u0060\u0060\u0060\n\n如果您没有看到端点，查看[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)文档中的端点部分。\n\n获取更多的 Kubernetes DNS 示例，请参考 Kubernetes GitHub 仓库中的[cluster-dns 示例](https:\/\/github.com\/kubernetes\/examples\/tree\/master\/staging\/cluster-dns)。\n\n## 已知问题\n\nKubernetes 安装时不会将节点的 resolv.conf 文件配置为默认使用集群 DNS，因为该过程本身是特定于发行版的。这一步应该放到最后实现。\n\nLinux 的 libc 不可思议的卡住（[查看该 2005 年起暴出来的 bug](https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=168253)）限制只能有 3 个 DNS \u0060nameserver\u0060 记录和 6 个 DNS \u0060search\u0060 记录。Kubernetes 需要消耗 1 个 \u0060nameserver\u0060 记录和 3 个 \u0060search\u0060 记录。这意味着如果本地安装已经使用 3 个 \u0060nameserver\u0060 或使用 3 个以上的 \u0060search\u0060 记录，那么其中一些设置将会丢失。有个部分解决该问题的方法，就是节点可以运行 \u0060dnsmasq\u0060，它将提供更多的 \u0060nameserver\u0060 条目，但不会有更多的 \u0060search\u0060 条目。您也可以使用 kubelet 的 \u0060--resolv-conf\u0060 标志。\n\n如果您使用的是 Alpine 3.3 或更低版本作为基础映像，由于已知的 Alpine 问题，DNS 可能无法正常工作。点击[这里](https:\/\/github.com\/kubernetes\/kubernetes\/issues\/30215)查看更多信息。\n\n## Kubernetes 集群联邦（多可用区支持）\n\nKubernetes 1.3 版本起引入了支持多站点 Kubernetes 安装的集群联邦支持。这需要对 Kubernetes 集群 DNS 服务器处理 DNS 查询的方式进行一些小的（向后兼容的）更改，以便于查找联邦服务（跨多个 Kubernetes 集群）。有关集群联邦和多站点支持的更多详细信息，请参阅集群联邦管理员指南。\n\n## 参考\n\n- [Configure DNS Service](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/)\n- [Service 和 Pod 的 DNS](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/dns-pod-service\/)\n- [自动扩容集群中的 DNS 服务](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-horizontal-autoscaling\/)\n- [Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)\n\n', '\/blog\/configuring-kubernetes-kube-dns\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/accessing-kubernetes-pods-from-outside-of-the-cluster/">从外部访问 Kubernetes 中的 Pod</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/11/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('从外部访问 Kubernetes 中的 Pod', '关于在 Kubernetes 中暴露 Pod 及服务的五种方式。', '\n本文主要讲解访问 Kubernetes 中的 Pod 和 Service 的几种方式，包括如下几种：\n\n- hostNetwork\n- hostPort\n- NodePort\n- LoadBalancer\n- Ingress\n\n说是暴露 Pod 其实跟暴露 Service 是一回事，因为 Pod 就是 Service 的 backend。\n\n## hostNetwork: true\n\n这是一种直接定义 Pod 网络的方式。\n\n如果在 Pod 中使用 \u0060hostNetwork:true\u0060 配置的话，在这种 pod 中运行的应用程序可以直接看到 pod 启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的 pod 的示例定义：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\nspec:\n  hostNetwork: true\n  containers:\n    - name: influxdb\n      image: influxdb\n\u0060\u0060\u0060\n\n部署该 Pod：\n\n\u0060\u0060\u0060bash\n$ kubectl create -f influxdb-hostnetwork.yml\n\u0060\u0060\u0060\n\n访问该 pod 所在主机的 8086 端口：\n\n\u0060\u0060\u0060bash\ncurl -v http:\/\/$POD_IP:8086\/ping\n\u0060\u0060\u0060\n\n将看到 204 No Content 的 204 返回码，说明可以正常访问。\n\n注意每次启动这个 Pod 的时候都可能被调度到不同的节点上，所有外部访问 Pod 的 IP 也是变化的，而且调度 Pod 的时候还需要考虑是否与宿主机上的端口冲突，因此一般情况下除非您知道需要某个特定应用占用特定宿主机上的特定端口时才使用 \u0060hostNetwork: true\u0060 的方式。\n\n这种 Pod 的网络模式有一个用处就是可以将网络插件包装在 Pod 中然后部署在每个宿主机上，这样该 Pod 就可以控制该宿主机上的所有网络。\n\n## hostPort\n\n这是一种直接定义 Pod 网络的方式。\n\n\u0060hostPort\u0060 是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的 IP 加上来访问 Pod 了，如:。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\nspec:\n  containers:\n    - name: influxdb\n      image: influxdb\n      ports:\n        - containerPort: 8086\n          hostPort: 8086\n\u0060\u0060\u0060\n\n这样做有个缺点，因为 Pod 重新调度的时候该 Pod 被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个 Pod 与所在宿主机的对应关系。\n\n这种网络方式可以用来做 nginx [Ingress controller](https:\/\/github.com\/kubernetes\/ingress\/tree\/master\/controllers\/nginx) 。外部流量都需要通过 Kubernetes node 节点的 80 和 443 端口。\n\n## NodePort\n\nNodePort 在 Kubernetes 里是一个广泛应用的服务暴露方式。Kubernetes 中的 service 默认情况下都是使用的 \u0060ClusterIP\u0060 这种类型，这样的 service 会产生一个 ClusterIP，这个 IP 只能在集群内部访问，要想让外部能够直接访问 service，需要将 service type 修改为 \u0060nodePort\u0060。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\n  labels:\n    name: influxdb\nspec:\n  containers:\n    - name: influxdb\n      image: influxdb\n      ports:\n        - containerPort: 8086\n\u0060\u0060\u0060\n\n同时还可以给 service 指定一个 \u0060nodePort\u0060 值，范围是 30000-32767，这个值在 API server 的配置文件中，用 \u0060--service-node-port-range\u0060 定义。\n\n\u0060\u0060\u0060yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: influxdb\nspec:\n  type: NodePort\n  ports:\n    - port: 8086\n      nodePort: 30000\n  selector:\n    name: influxdb\n\u0060\u0060\u0060\n\n集群外就可以使用 kubernetes 任意一个节点的 IP 加上 30000 端口访问该服务了。kube-proxy 会自动将流量以 round-robin 的方式转发给该 service 的每一个 pod。\n\n这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。\n\n## LoadBalancer\n\n\u0060LoadBalancer\u0060 只能在 service 上定义。这是公有云提供的负载均衡器，如 AWS、Azure、CloudStack、GCE 等。\n\n\u0060\u0060\u0060yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: influxdb\nspec:\n  type: LoadBalancer\n  ports:\n    - port: 8086\n  selector:\n    name: influxdb\n\u0060\u0060\u0060\n\n查看服务：\n\n\u0060\u0060\u0060bash\n$ kubectl get svc influxdb\nNAME       CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\ninfluxdb   10.97.121.42   10.13.242.236   8086:30051\/TCP   39s\n\u0060\u0060\u0060\n\n内部可以使用 ClusterIP 加端口来访问服务，如 19.97.121.42:8086。\n\n外部可以用以下两种方式访问该服务：\n\n- 使用任一节点的 IP 加 30051 端口访问该服务\n- 使用 \u0060EXTERNAL-IP\u0060 来访问，这是一个 VIP，是云供应商提供的负载均衡器 IP，如 10.13.242.236:8086。\n\n## Ingress\n\n\u0060Ingress\u0060 是自 kubernetes1.1 版本后引入的资源类型。必须要部署 [Ingress controller](https:\/\/github.com\/kubernetes\/ingress\/tree\/master\/controllers\/nginx) 才能创建 Ingress 资源，Ingress controller 是以一种插件的形式提供。Ingress controller 是部署在 Kubernetes 之上的 Docker 容器。它的 Docker 镜像包含一个像 nginx 或 HAProxy 的负载均衡器和一个控制器守护进程。控制器守护程序从 Kubernetes 接收所需的 Ingress 配置。它会生成一个 nginx 或 HAProxy 配置文件，并重新启动负载平衡器进程以使更改生效。换句话说，Ingress controller 是由 Kubernetes 管理的负载均衡器。\n\nKubernetes Ingress 提供了负载平衡器的典型特性：HTTP 路由，粘性会话，SSL 终止，SSL 直通，TCP 和 UDP 负载平衡等。目前并不是所有的 Ingress controller 都实现了这些功能，需要查看具体的 Ingress controller 文档。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Ingress\nmetadata:\n  name: influxdb\nspec:\n  rules:\n    - host: influxdb.kube.example.com\n      http:\n        paths:\n          - backend:\n              serviceName: influxdb\n              servicePort: 8086\n\u0060\u0060\u0060\n\n外部访问 URL \u0060http:\/\/influxdb.kube.example.com\/ping\u0060 访问该服务，入口就是 80 端口，然后 Ingress controller 直接将流量转发给后端 Pod，不需再经过 kube-proxy 的转发，比 LoadBalancer 方式更高效。\n\n## 总结\n\n总的来说 Ingress 是一个非常灵活和越来越得到厂商支持的服务暴露方式，包括 Nginx、HAProxy、Traefik，还有各种 Service Mesh，而其它服务暴露方式可以更适用于服务调试、特殊应用的部署。\n', '\/blog\/accessing-kubernetes-pods-from-outside-of-the-cluster\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">关于在 Kubernetes 中暴露 Pod 及服务的五种方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/deploy-applications-in-kubernetes/">适用于 Kubernetes 的应用开发与部署流程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/07/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('适用于 Kubernetes 的应用开发与部署流程详解', '本文以在 Kubernetes 中部署两个应用来说明。', '\n本文已归档在[kubernetes-handbook](https:\/\/github.com\/rootsongjc\/kubernetes-handbook)中的第 3 章【用户指南】中，一切更新以 kubernetes-handbook 中为准。\n\n为了详细说明，我特意写了两个示例程序放在 GitHub 中，模拟应用开发流程：\n\n- [k8s-app-monitor-test](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-test)：生成模拟的监控数据，发送 http 请求，获取 json 返回值\n- [K8s-app-monitor-agent](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-agent)：获取监控数据并绘图，访问浏览器获取图表\n\nAPI 文档见[k8s-app-monitor-test](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-test)中的\u0060api.html\u0060文件，该文档在 API blueprint 中定义，使用[aglio](https:\/\/github.com\/danielgtaylor\/aglio)生成，打开后如图所示：\n\n![API 文档](k8s-app-monitor-test-api-doc.jpg)\n\n**关于服务发现**\n\n\u0060K8s-app-monitor-agent\u0060服务需要访问\u0060k8s-app-monitor-test\u0060服务，这就涉及到服务发现的问题，我们在代码中直接写死了要访问的服务的内网 DNS 地址（kubedns 中的地址，即\u0060k8s-app-monitor-test.default.svc.cluster.local\u0060）。\n\n我们知道 Kubernetes 在启动 Pod 的时候为容器注入环境变量，这些环境变量在所有的 namespace 中共享（环境变量是不断追加的，新启动的 Pod 中将拥有老的 Pod 中所有的环境变量，而老的 Pod 中的环境变量不变）。但是既然使用这些环境变量就已经可以访问到对应的 service，那么获取应用的地址信息，究竟是使用变量呢？还是直接使用 DNS 解析来发现？\n\n答案是使用 DNS，详细说明见[Kubernetes 中的服务发现与 Docker 容器间的环境变量传递源码探究](\/blog\/exploring-kubernetes-env-with-docker\/)。\n\n**打包镜像**\n\n因为我使用 wercker 自动构建，构建完成后自动打包成 docker 镜像并上传到 docker hub 中（需要提前在 docker hub 中创建 repo），如何使用 wercker 做持续构建与发布，并集成 docker hub 插件请参考[使用 Wercker 进行持续构建与发布](\/blog\/continuous-integration-with-wercker\/)。\n\n[查看详细构建流程](https:\/\/app.wercker.com\/jimmysong\/k8s-app-monitor-agent\/)\n\n![wercker](k8s-app-monitor-agent-wercker.jpg)\n\n生成了如下两个 docker 镜像：\n\n- jimmysong\/k8s-app-monitor-test:latest\n- jimmysong\/k8s-app-monitor-agent:latest\n\n**启动服务**\n\n所有的 kubernetes 应用启动所用的 yaml 配置文件都保存在那两个 GitHub 仓库的\u0060manifest.yaml\u0060文件中。\n\n分别在两个 GitHub 目录下执行\u0060kubectl create -f manifest.yaml\u0060即可启动服务。\n\n**外部访问**\n\n服务启动后需要更新 ingress 配置，在[ingress.yaml](https:\/\/github.com\/rootsongjc\/kubernetes-handbook\/blob\/master\/manifests\/traefik-ingress\/ingress.yaml)文件中增加以下几行：\n\n\u0060\u0060\u0060Yaml\n  - host: k8s-app-monitor-agent.jimmysong.io\n    http:\n      paths:\n      - path: \/\n        backend:\n          serviceName: k8s-app-monitor-agent\n          servicePort: 8080\n\u0060\u0060\u0060\n\n保存后，然后执行\u0060kubectl replace -f ingress.yaml\u0060即可刷新 ingress。\n\n修改本机的\u0060\/etc\/hosts\u0060文件，在其中加入以下一行：\n\n\u0060\u0060\u0060ini\n172.20.0.119 k8s-app-monitor-agent.jimmysong.io\n\u0060\u0060\u0060\n\n当然你也可以加入到 DNS 中，为了简单起见我使用 hosts。\n\n详见[边缘节点配置](https:\/\/github.com\/rootsongjc\/kubernetes-handbook\/blob\/master\/practice\/edge-node-configuration.md)。\n\n在浏览器中访问 http:\/\/k8s-app-monitor-agent.jimmysong.io\n\n![图表](k8s-app-monitor-agent.jpg)\n\n刷新页面将获得新的图表。\n\n## 参考\n\n- [使用 Wercker 进行持续构建与发布](\/blog\/continuous-integration-with-wercker\/)\n- [示例的项目代码服务器端](https:\/\/app.wercker.com\/jimmysong\/k8s-app-monitor-agent\/)\n- [示例项目代码前端](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-agent)\n- [kubernetes-handbok](\/book\/kubernetes-handbook\/)\n- [边缘节点配置](https:\/\/github.com\/rootsongjc\/kubernetes-handbook\/blob\/master\/practice\/edge-node-configuration.md)\n', '\/blog\/deploy-applications-in-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以在 Kubernetes 中部署两个应用来说明。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/book-kubernetes-management-design-patterns/">记一本关于 kubernetes management design patterns 的书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/07/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('记一本关于 kubernetes management design patterns 的书', '本书有两个优点，一个是每个章节都给出了问题的起因和 kubernetes 的解决方案，二是几乎所有的命令和操作都附有截图，说明很详细。', '\n下面是这本书的基本信息。\n\n- 书名：Kubernetes Management Design Patterns: With Docker, CoreOS Linux, and Other Platforms\n- Amazon 购买链接：[链接](https:\/\/www.amazon.com\/Kubernetes-Management-Design-Patterns-Platforms-ebook\/dp\/B01MZDO0BD\/ref=pd_sbs_351_4?_encoding=UTF8\u0026psc=1\u0026refRID=79F47CR67EEESD35S2VF)\n- 作者：Deepak Vohra\n- 发行日期：2017 年 1 月 20 日\n- 出版社：Apress\n- 页数：399\n\n### 简介\n\nKubernetes 引领容器集群管理进入一个全新的阶段；学习如何在 CoreOS 上配置和管理 kubernetes 集群；使用适当的管理模式，如 ConfigMaps、Autoscaling、弹性资源使用和高可用性配置。讨论了 kubernetes 的一些其他特性，如日志、调度、滚动升级、volume、服务类型和跨多个云供应商 zone。\n\nKubernetes 中的最小模块化单位是 Pod，它是拥有共同的文件系统和网络的系列容器的集合。Pod 的抽象层可以对容器使用设计模式，就像面向对象设计模式一样。容器能够提供与软件对象（如模块化或包装，抽象和重用）相同的优势。\n\n在大多数章节中使用的都是 CoreOS Linux，其他讨论的平台有 CentOS，OpenShift，Debian 8（jessie），AWS 和 Debian 7 for Google Container Engine。\n\n使用 CoreOS 主要是因为 Docker 已经在 CoreOS 上开箱即用。CoreOS：\n\n- 支持大多数云提供商（包括 Amazon AWS EC2 和 Google Cloud Platform）和虚拟化平台（如 VMWare 和 VirtualBox）\n- 提供 Cloud-Config，用于声明式配置 OS，如网络配置（flannel），存储（etcd）和用户帐户\n- 为容器化应用提供生产级基础架构，包括自动化，安全性和可扩展性\n- 引领容器行业标准，并建立了应用程序标准\n- 提供最先进的容器仓库，Quay\n\nDocker 于 2013 年 3 月开源，现已称为最流行的容器平台。kubernetes 于 2014 年 6 月开源，现在已经成为最流行的容器集群管理平台。第一个稳定版 CoreOS Linux 于 2014 年 7 月发行，现已成为最流行的容器操作系统之一。\n\n### 你将学到什么\n\n- 使用 docker 和 kubernetes\n- 在 AWS 和 CoreOS 上创建 kubernetes 集群\n- 应用集群管理设计模式\n- 使用多个云供应商 zone\n- 使用 Ansible 管理 kubernetes\n- 基于 kubernetes 的 PAAS 平台 OpenShift\n- 创建高可用网站\n- 构建高可用用的 kubernetes master 集群\n- 使用 volume、configmap、Service、autoscaling 和 rolling update\n- 管理计算资源\n- 配置日志和调度\n\n### 谁适合读这本书\n\nLinux 管理员、CoreOS 管理员、应用程序开发者、容器即服务（CAAS）开发者。阅读这本书需要 Linux 和 Docker 的前置知识。介绍 Kubernetes 的知识，例如创建集群，创建 Pod，创建 service 以及创建和缩放 replication controller。还需要一些关于使用 Amazon Web Services（AWS）EC2，CloudFormation 和 VPC 的必备知识。\n\n### 关于作者\n\n**Deepak Vohra** is an Oracle Certified Associate and a Sun Certified Java Programmer. Deepak has published in Oracle Magazine, OTN, IBM developerWorks, ONJava, DevSource,  WebLogic Developer’s Journal, XML Journal, Java Developer’s Journal, FTPOnline, and devx.\n\n### 目录\n\n- 第一部分：平台\n  - 第 1 章：Kuberentes on AWS\n  - 第 2 章：kubernetes on CoreOS on AWS\n  - 第 3 章：kubernetes on Google Cloud Platform\n- 第二部分：管理和配置\n  - 第 4 章：使用多个可用区\n  - 第 5 章：使用 Tectonic Console\n  - 第 6 章：使用 volume\n  - 第 7 章：使用 service\n  - 第 8 章：使用 Rolling updte\n  - 第 9 章：在 node 上调度 pod\n  - 第 10 章：配置计算资源\n  - 第 11 章：使用 ConfigMap\n  - 第 12 章：使用资源配额\n  - 第 13 章：使用 Autoscaling\n  - 第 14 章：配置 logging\n- 第三部分：高可用\n  - 第 15 章：在 OpenShift 中使用 HA master\n  - 第 16 章：开发高可用网站\n\n### 个人评价\n\n本书更像是一本参考手册，对于想在公有云中（如 AWS、Google Cloud Platform）中尝试 Kubernetes 的人会有所帮助，而对于想使用 kubernetes 进行自己的私有云建设，或想了解 kubernetes 的实现原理和技术细节的人来说，就不适合了。对我来说，本书中有个别几个章节可以参考，如高可用，但还是使用 OpenShift 实现的。总之，如果你使用 AWS 这样的公有云，对操作系统没有特别要求，可以接受 CoreOS 的话，那么可以看看这本书。本来本书会对 kubernetes 中的各种应用模式能够有个详解，但是从书中我并没有找到。\n\n本书有两个优点，一个是每个章节都给出了问题的起因和 kubernetes 的解决方案，二是几乎所有的命令和操作都附有截图，说明很详细。\n\n', '\/blog\/book-kubernetes-management-design-patterns\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本书有两个优点，一个是每个章节都给出了问题的起因和 kubernetes 的解决方案，二是几乎所有的命令和操作都附有截图，说明很详细。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/exploring-kubernetes-env-with-docker/">Kubernetes 中的服务发现与 docker 容器间的环境变量传递源码探究</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/07/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 中的服务发现与 docker 容器间的环境变量传递源码探究', '基于实际应用研究。', '\n## 前言\n\n今天创建了两个 kubernetes 示例应用：\n\n- [k8s-app-monitor-test](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-test)：启动 server 用来产生 metrics\n- [k8s-app-monitor-agent](https:\/\/github.com\/rootsongjc\/k8s-app-monitor-agent)：获取 metrics 并绘图，显示在 web 上\n\n*注：相关的 kubernetes 应用\u0060manifest.yaml\u0060文件分别见以上两个应用的 GitHub。*\n\n当我查看 Pod 中的环境变量信息时，例如 kubernetes 中的 service \u0060k8s-app-monitor-test\u0060注入的环境变量时，包括了以下变量：\n\n\u0060\u0060\u0060ini\nK8S_APP_MONITOR_TEST_PORT_3000_TCP_ADDR=10.254.56.68\nK8S_APP_MONITOR_TEST_PORT=tcp:\/\/10.254.56.68:3000\nK8S_APP_MONITOR_TEST_PORT_3000_TCP_PROTO=tcp\nK8S_APP_MONITOR_TEST_SERVICE_PORT_HTTP=3000\nK8S_APP_MONITOR_TEST_PORT_3000_TCP_PORT=3000\nK8S_APP_MONITOR_TEST_PORT_3000_TCP=tcp:\/\/10.254.56.68:3000\nK8S_APP_MONITOR_TEST_SERVICE_HOST=10.254.56.68\nK8S_APP_MONITOR_TEST_SERVICE_PORT=3000\n\u0060\u0060\u0060\n\n我们知道 Kubernetes 在启动 Pod 的时候为容器注入环境变量，这些环境变量将在该 Pod 所在的 namespace 中共享。但是既然使用这些环境变量就已经可以访问到对应的 service，那么获取应用的地址信息，究竟是使用变量呢？还是直接使用 DNS 解析来发现？下面我们从代码中来寻求答案。\n\n如果不想看下面的文字，可以直接看图。\n\n![kubernetes 中传递 ENV 的探索过程](kubernetes-service-discovery-with-dns-or-env.png)\n\n## 探索\n\ndocker 的\u0060docker\/engine-api\/types\/container\/config.go\u0060中的\u0060Config\u0060结构体中有对环境变量的定义：\n\n\u0060\u0060\u0060Go\n\/\/ Config contains the configuration data about a container.\n\/\/ It should hold only portable information about the container.\n\/\/ Here, \u0022portable\u0022 means \u0022independent from the host we are running on\u0022.\n\/\/ Non-portable information *should* appear in HostConfig.\n\/\/ All fields added to this struct must be marked \u0060omitempty\u0060 to keep getting\n\/\/ predictable hashes from the old \u0060v1Compatibility\u0060 configuration.\ntype Config struct {\n\tHostname        string                \/\/ Hostname\n\tDomainname      string                \/\/ Domainname\n\tUser            string                \/\/ User that will run the command(s) inside the container\n...\n\tEnv             []string              \/\/ List of environment variable to set in the container\n\tCmd             strslice.StrSlice     \/\/ Command to run when starting the container\n\t...\n}\n\u0060\u0060\u0060\n\nKubernetes 中在\u0060pkg\/kubelet\/container\/runtime.go\u0060中的\u0060RunContainerOptions\u0060结构体中定义：\n\n\u0060\u0060\u0060go\n\/\/ RunContainerOptions specify the options which are necessary for running containers\ntype RunContainerOptions struct {\n\t\/\/ The environment variables list.\n\tEnvs []EnvVar\n  \t\/\/ The mounts for the containers.\n\tMounts []Mount\n\t\/\/ The host devices mapped into the containers.\n...\n}\n\u0060\u0060\u0060\n\nKubelet 向容器中注入环境变量的配置是在下面的方法中定义：\n\n\u0060\u0060\u0060ini\npkg\/kubelet\/kuberuntime\/kuberuntime_container.go\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060Go\n\/\/ generateContainerConfig generates container config for kubelet runtime v1.\nfunc (m *kubeGenericRuntimeManager) generateContainerConfig(container *v1.Container, pod *v1.Pod, restartCount int, podIP, imageRef string) (*runtimeapi.ContainerConfig, error) {\n    opts, _, err := m.runtimeHelper.GenerateRunContainerOptions(pod, container, podIP)\n    ...\n\t\/\/ set environment variables\n\tenvs := make([]*runtimeapi.KeyValue, len(opts.Envs))\n\tfor idx := range opts.Envs {\n\t\te := opts.Envs[idx]\n\t\tenvs[idx] = \u0026runtimeapi.KeyValue{\n\t\t\tKey:   e.Name,\n\t\t\tValue: e.Value,\n\t\t}\n\t}\n\tconfig.Envs = envs\n\n\treturn config, nil\n}\n\u0060\u0060\u0060\n\nkubelet 的\u0060pkg\/kubelet\/kubelet_pods.go\u0060的如下方法中生成了\u0060RunContainerOptions\u0060：\n\n\u0060\u0060\u0060Go\n\/\/ GenerateRunContainerOptions generates the RunContainerOptions, which can be used by\n\/\/ the container runtime to set parameters for launching a container.\nfunc (kl *Kubelet) GenerateRunContainerOptions(pod *v1.Pod, container *v1.Container, podIP string) (*kubecontainer.RunContainerOptions, bool, error) {\n\t...\n\topts := \u0026kubecontainer.RunContainerOptions{CgroupParent: cgroupParent}\n\t...\n\topts.Envs, err = kl.makeEnvironmentVariables(pod, container, podIP)\n    return opts, useClusterFirstPolicy, nil\n}\n\u0060\u0060\u0060\n\n我们再看下\u0060makeEnvironmentVariables(pod, container, podIP)\u0060方法中又做了什么（该方法也在\u0060pkg\/kubelet\/kubelet_pods.go\u0060文件中）。\n\n\u0060\u0060\u0060Go\n\/\/ Make the environment variables for a pod in the given namespace.\nfunc (kl *Kubelet) makeEnvironmentVariables(pod *v1.Pod, container *v1.Container, podIP string) ([]kubecontainer.EnvVar, error) {\n\tvar result []kubecontainer.EnvVar\n\t\/\/ Note:  These are added to the docker Config, but are not included in the checksum computed\n\t\/\/ by dockertools.BuildDockerName(...).  That way, we can still determine whether an\n\t\/\/ v1.Container is already running by its hash. (We don\u0027t want to restart a container just\n\t\/\/ because some service changed.)\n\t\/\/\n\t\/\/ Note that there is a race between Kubelet seeing the pod and kubelet seeing the service.\n\t\/\/ To avoid this users can: (1) wait between starting a service and starting; or (2) detect\n\t\/\/ missing service env var and exit and be restarted; or (3) use DNS instead of env vars\n\t\/\/ and keep trying to resolve the DNS name of the service (recommended).\n\t...\n}\n\u0060\u0060\u0060\n\n该代码段比较长，kubernetes 究竟如何将环境变量注入到 docker 容器中的奥秘就在这里，按图索骥到了这里，从代码注释中已经可以得出结论，使用 DNS 解析而不要使用环境变量来做服务发现，究竟为何这样做，改天我们再详细解读。\n', '\/blog\/exploring-kubernetes-env-with-docker\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">基于实际应用研究。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/kubernetes/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/kubernetes/page/3/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/kubernetes/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/kubernetes/page/5/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/kubernetes/page/5/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/leveraging-envoypatchpolicy-to-extend-the-capabilities-of-envoy-gateway/">利用 EnvoyPatchPolicy 拓展 Envoy Gateway 的能力</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-eu-2025-london-recap/">KubeCon EU 2025 参会报告：塑造云原生格局的洞察与趋势</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
