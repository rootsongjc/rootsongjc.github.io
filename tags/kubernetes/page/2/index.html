<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Kubernetes - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/tags/kubernetes/" />
  <meta property="og:title" content="Kubernetes | Jimmy Song" />
  <meta property="twitter:title" content="Kubernetes | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/tags/kubernetes/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Kubernetes
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/">[译] 如何使用 Calico 构建和管理 Kubernetes Cluster Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tigera.io/blog/deep-dive/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Calico 构建和管理 Kubernetes Cluster Mesh', '这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。', '\nKubernetes 是构建灵活可扩展基础设施以运行动态工作负载的优秀解决方案。然而，随着我们的集群扩展，我们可能会面临同时扩展和管理多个集群的不可避免情况。这个概念可能会给我们的日常工作负载维护带来很多复杂性，并增加在所有环境中保持所有策略和服务的最新性的难度。在这种情况下，[集群网格](https:\/\/www.tigera.io\/blog\/using-calico-to-create-a-kubernetes-cluster-mesh-for-multi-cluster-environments\/) 可以在这些集群之间建立无缝的连接，并将工作负载集成到统一的网络环境中。\n\n集群网格是连接独立 Kubernetes 集群并在不同集群中的资源之间提供连接性的绝佳方式，以提供超出单个集群情况下可能的容错性和高可用性。\n\n在本博客文章中，我们将引导你完成构建多集群环境并建立集群网格所需的步骤，利用 Calico Open Source 的多功能能力。我们将探讨不同的方法，如顶级机架 (TOR) 和 overlay，以建立集群网格，解决不同环境提出的独特网络挑战。这是可能的，因为 Calico 提供了建立多集群环境的多种方法，灵活适应你的网络基础设施和特定要求。此外，我们还将介绍如何加入 DNS 连通性以增强集群间通信。\n\n随着你的集群网格环境扩展，我们将讨论涉及[联邦](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-federation\/)和使用 Calico Enterprise 进行多集群管理的下一步，以及涉及联邦集群。我们将展示 Calico 如何提供多集群管理平面，允许在集群间无缝实施安全性和可观测性。\n\n最后，我们将涉及到 Calico Enterprise 联邦身份如何在[多集群](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-multi-cluster\/)环境中弥合差距，提供一种统一的方式来定制网络策略，可以引用来自不同集群的资源并构建跨集群边界负载平衡请求的服务。\n\n## 什么是集群网格？\n\n集群网格连接了两个或多个独立集群内部资源。通常，每个 Kubernetes 集群将为内部资源分配私有 IP 地址，除非将**节点端口**或**负载均衡器**服务与它们关联，否则这些资源对任何外部实体都不可见。然而，将资源暴露给所有人可能会带来安全风险，并破坏你应该保持的[零信任安全](https:\/\/www.tigera.io\/learn\/guides\/zero-trust\/zero-trust-security\/)姿态，以保护你的环境。此外，它可以通过允许恶意用户利用漏洞并在关键服务中占据立足点来危及整个环境。\n\n在多集群环境中建立集群网格提供了一种安全机制，用于促进集群之间的直接通信。这种通信可以通过指定的集群服务或私有 IP 地址进行，确保强大而受控制的交互，同时减轻了将内部资源暴露给更广泛网络的风险。\n\n### 如何构建多集群环境并建立集群网格\n\n以下图片说明了 Calico 如何在你的集群之间建立集群网格连接。\n\n![](1.png)\n\nCalico 提供了不同的方式，你可以使用这些方式来构建多集群环境，从而提供了与你的网络基础设施和需求相匹配的灵活性。Calico 最好的部分是，在将两个集群连接在一起后，它将自动提供集群网格，你可以通过使用它们的内部集群服务和 IP 地址开始在不同的集群中使用资源。\n\n### 在扁平网络环境中的集群网格\n\n集群网格的配置可以根据底层基础设施的不同而变化，但其基本目的保持不变，实质上是用于建立独立集群之间的连接。\n\n例如，在我们的集群的参与节点通过广播域直接连接的环境中，我们可以通过传播内部路由到外部实体的路由协议来快速建立一个网格。这将允许我们广告内部路由，而无需通过**节点端口**服务将它们暴露给我们的目标服务。\n\n以下图片说明了扁平网络的常见设计：\n\n![](2.png)\n\n考虑观看我们的视频，[使用 Calico 开源进行 Kubernetes 的 BGP](https:\/\/www.youtube.com\/watch?v=PefluN8YM9o\u0026ab_channel=ProjectCalico)，以了解使用全网格方法部署集群网格的全面教程。\n\n### 在企业或云网络环境中的集群网格\n\n在复杂的网络环境中，例如云或企业网络，形成集群的基础设施资源通常分为单独的广播域。这是因为这些域中的每个实体都被要求通过网关来到达其目的地。但是，默认情况下，这个额外的跳跃（网关）需要了解我们在 Kubernetes 集群中创建的内部集群资源。因此，网关会丢弃前往这些内部资源的数据包，使简单的路由方法无法满足要求。\n\n以下图片说明了复杂网络环境的常见设计：\n\n![](3.png)\n\n既然我们知道了问题，让我们看看如何利用 Calico 来解决这个问题。\n\n为了在这样的环境中建立集群网格，我们可以使用两种方法：\n\n- 顶层机架（TOR）\n- overlay\n\n#### TOR 方法（推荐）\n\n在企业或云环境中，资源通常通过中间网关互连。通常，我们建议我们的客户使用 TOR，因为通过与云提供商自动建立路由传播机制来使你的集群了解你监管下的所有云资源，从而使你的集群具备高可用性。这也在云提供商的底层网络基础设施上发挥了作用，从而使你的集群在网络基础设施的支持下具备高可用性。\n\n假设你可以配置云网关并将其与像 Calico 这样的强大的[容器网络接口（CNI）](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-cni\/)配对，那么你可以利用 BGP 路由来建立集群网格。Calico BGP 集成提供了动态路由，允许你将内部 Pod 和集群 IP 路由传播到网络基础设施中的其他资源。\n\n以下图片说明了支持 BGP 的云环境的常见设计：\n\n![](4.png)\n\n在许多情况下，TOR（顶层机架）提高了高可用性和容错性。这种方法优化了网络流量分布，减轻了单点故障，并进一步增强了你的基础设施的可靠性和弹性。\n\n注意：要了解使用 TOR 方法部署集群网格的详细指南，请查看[此处](https:\/\/docs.tigera.io\/calico\/latest\/networking\/configuring\/bgp#top-of-rack-tor)的教程。\n\n#### IPIP overlay\n\n在某些情况下，你可能无法访问网关以修改其设置，或者它可能不支持 BGP 对等连接。在这种情况下，你可以使用 IPIP overlay 来封装流向目标集群的流量。overlay 网络允许网络设备在底层网络（称为底层）上相互通信，而底层网络不需要了解连接到 overlay 网络的设备。\n\n注意：如果你想了解更多关于 overlay 网络的信息，请单击[此处](https:\/\/docs.tigera.io\/calico\/latest\/about\/kubernetes-training\/about-networking#overlay-networks)。\n\n#### VXLAN overlay (Calico Enterprise)\n\n即将发布的 Calico Enterprise（3.18\u002b）版本将在多集群环境下启用 VXLAN 网络。这种方法的一个显著优势之一是能够使用身份感知策略来保护跨集群的流量（你将在接下来的联邦部分了解有关此功能的信息）。通过其多集群网络功能，Calico Enterprise 自动扩展 overlay 网络，以在集群之间建立 Pod IP 路由。\n\n在使用 VXLAN 的 Calico Enterprise 集群网格设置中，每个集群都充当本地集群和远程集群，本地集群配置为从远程集群的加密通道中检索端点和路由数据。VXLAN 集群网格提供了一种安全、可扩展和高效的解决方案，用于管理多集群网络，实现了跨集群的无缝通信和身份感知策略强制执行。\n\n注意：如果你想了解有关 VXLAN overlay 的更多信息，请单击[此处](https:\/\/www.tigera.io\/news\/tigera-introduces-powerful-enhancements-to-calico-open-source-and-calico-cloud-to-elevate-security-scalability-and-performance\/)。\n\n以下图片说明了没有 BGP 能力的云环境的常见设计：\n\n![](5.png)\n\n注意：要了解使用 TOR 方法部署集群网格的全面指南，请查看[此教程](https:\/\/youtu.be\/rv-DnExi6SM?t=2287)。\n\n### DNS 连接\n\n在建立多集群之后，各个集群可以在 IP 级别进行通信。然而，根据你的网络规模以及 Kubernetes IP 地址的性质，这些地址可以随时动态更改，因此你需要实现一种更容易建立这些集群之间连接的方式。域名解析可以成为你的集群网格的重要补充，允许更容易进行集群间通信。\n\n在大多数 Kubernetes 部署中，CoreDNS 作为负责解析集群域名的主要工作负载。要将 DNS 与集群网格无缝集成，只需对 CoreDNS 配置映射进行简单的修改即可。具体来说，你需要将其他集群的 CoreDNS 内部服务 IP 添加为转发器到你的配置中。\n\n这个简单的调整使你的集群能够通过向其他集群发送查询来解析名称，并检索所需资源的相应 IP 地址。这种集成大大简化了集群网格内的通信，增强了整体连通性，并提高了管理效率。\n\n注意：考虑观看[此视频](https:\/\/youtu.be\/rv-DnExi6SM?t=2574)以了解有关 DNS 连接的全面教程。\n\n## 联邦和多集群管理（下一步）\n\n随着你的环境扩展，你可能会遇到多个团队必须同时在所有集群上工作的情况。多集群管理（MCM）通常解决的一个常见问题是以集中的方式处理来自不同集群的对象，包括网络策略、Pod、[合规性](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-compliance\/)报告、可观测性和安全日志。\n\n虽然从技术上讲，可以通过 kubectl 为每个集群手动创建策略、网络集和其他资源，但这种方法会在你的日常维护任务中引入相当复杂性，并可能为意外的凭据泄漏开辟一条途径。此外，与我们在前一节中探讨的类似，它反映了没有良好结构的多集群环境所面临的挑战，特别是在集群管理、网络、故障排除和可观测性方面。\n\n### 使用 Calico Enterprise 进行多集群管理\n\nCalico Enterprise 提供了一个 MCM 平面，通过在这些集群之间建立安全连接，实现了多集群的安全和可观测性。该架构还支持跨集群联邦[网络策略](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-network-policy\/)资源，并为真正的集中式管理、可观测性和集群维护奠定了基础。\n\n以下图像是列出所有已连接集群的 MCM 页面的示例。\n\n![](6.png)\n\nMCM 的安全功能不仅限于集群的网络方面。由于 MCM 完全集成了 Kubernetes 基于角色的访问控制（RBAC），你可以制定授权，允许用户仅查看他们需要查看的信息。\n\n注意：使用[这个](https:\/\/www.tigera.io\/tutorials\/?_sft_tutorial_product=calico-enterprise)实际操作的工作坊来了解更多关于多集群管理的信息。\n\n### 利用 Calico Enterprise 的联邦身份和统一策略执行\n\nCalico Enterprise 联邦将工作负载和服务端点与在集群之间共享的唯一身份关联起来。\n\n联邦身份可以与网络安全策略关联，以创建引用位于不同集群中的端点的唯一资源，从而实现对集群间安全的无缝控制。\n\n此外，通过联邦服务，你可以发现并与位于不同集群中的远程 Pod 互动。这两个关键功能使得可以创建精确、细粒度的安全控制，加强了跨多个集群的整体安全姿态。\n\n![](7.png)\n\n通过实施联邦层和策略，你可以灵活地定义网络安全策略，这些策略可以普遍适用于所有集群，也可以专门针对一组定义的集群。这种方法提供了一种有效的手段，以在扩展部署以包括多个集群的同时扩展安全措施。通过将这些安全控制扩展到现有和新的集群，你有效地减少了策略的重复和简化了从创建到维护的整个过程。\n\n## 结论\n\n总结一下，集群网格连接不同 Kubernetes 集群中的内部资源。Calico 的灵活集群网格设置为在任何环境中连接到多个集群提供了构建块。\n\nCalico Enterprise MCM、联邦和联邦策略强制执行成为多集群架构的缺失环节，允许无缝通信，同时优先考虑安全性。Calico 在这个领域的能力使你能够无缝提供多集群管理、可观测性、联邦服务和身份，从而使你的组织能够自信而高效地应对现代网络的复杂性。随着组织的继续扩展和扩大规模，整合这些策略将在塑造多集群环境的未来中发挥关键作用。\n', '\/trans\/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/does-kubernetes-really-perform-better-on-bare-metal-vs-vms/">[译] Kubernetes 在裸机上比虚拟机表现更好吗：Kubernetes 性能对比实验</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/12/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/does-kubernetes-really-perform-better-on-bare-metal-vs-vms/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 在裸机上比虚拟机表现更好吗：Kubernetes 性能对比实验', '本文对比了虚拟机和裸机上 Kubernetes 集群的 CPU、RAM、存储和网络性能的详细比较。', '\n许多人认为部署在裸机上的 Kubernetes 集群比部署在虚拟机上的性能更好，但直到现在都没有关于这一假设的证据。在 Gcore，我们只提供基于充分证据的信息给客户，因此我们决定自行测试 Kubernetes 是否在[裸机上](https:\/\/thenewstack.io\/bare-metal-in-a-cloud-native-world\/)比在虚拟机上表现更好，如果是的话，差距有多大。我将分享我们内部测试的结果。\n\n我故意不讨论虚拟节点与裸机节点竞争的其他方面，如[成本效益或基础设施控制级别](https:\/\/gcore.com\/blog\/kubernetes-on-bare-metal\/)。这超出了本文的范围，本文只关注性能比较。\n\n## VM 和裸机 Kubernetes 之间的区别\n\n当您在虚拟机上部署 Kubernetes 集群时，与裸机（BM）相比，您会得到额外的基础设施层，即虚拟机监视器和客户操作系统。\n\n![显示裸机和虚拟机架构差异的图表](39ff19bc-image1a-e1700581613781.png)\n\n图 1：裸机和虚拟机架构的差异。\n\n这些层占用物理 CPU 和 RAM 来运行，从工作负载中拿走一些计算能力。虚拟化还会影响网络和存储性能：虚拟网络和存储比物理网络和存储慢。\n\n相比之下，当您在[裸机服务器上部署 Kubernetes 集群](https:\/\/thenewstack.io\/provision-bare-metal-kubernetes-with-the-cluster-api\/)时，您没有任何额外的基础设施层和虚拟化。服务器的物理资源完全专用于您的工作负载，容器化应用程序可以直接访问这些资源。\n\n## 我们如何比较虚拟机和裸机 K8s 性能\n\n为了全面了解虚拟机和裸机集群性能的比较，我们测量了以下内容：\n\n- **CPU：** 速度和利用率\n- **RAM：** 延迟\n- **存储：** 每秒事务（TPS）和延迟\n- **网络：** 带宽和延迟\n\n为了保持工作负载的一致性，所有测试应用程序都以容器化方式部署在比较的工作节点上。\n\n### 我们的测试条件\n\n在测试中，我们使用了运行在[Gcore 托管的 Kubernetes](https:\/\/gcore.com\/cloud\/managed-kubernetes)上的 K8s 集群。然而，由于托管的 Kubernetes 不会增加工作节点性能的任何开销，因此这些结果也与标准 Kubernetes 相关。\n\n为了保持工作负载的相同条件，我们选择了相似的虚拟机和裸机工作节点的配置。以下是这种比较配置的示例：\n\n- **裸机工作节点：** 1x Intel Xeon E-2388 8C\/16T 3.2 GHz \/ 64 GB \/ Ubuntu 22.04\n- **虚拟机工作节点：** 16 vCPU \/ 64 GiB 内存 \/ Ubuntu 22.04\n\n## 测试结果摘要\n\n在测试中，我们比较了两个 Kubernetes 集群，一个部署在虚拟机（VMs）上，另一个部署在裸机上。它们的配置相似。作为测试工作负载，我们运行了以下内容：\n\n- 用于 CPU 测试的 CPU 基准测试\n- 用于 RAM 测试的 Sysbench\n- 用于存储测试的 Pgbench\n- 用于网络测试的 Netperf\n\n下面是总结最重要的测试结果的表格：\n\n![测试结果表格](417a03ef-summary1.jpg)\n\n显然，裸机集群在所有情况下效率更高。\n\n让我们详细查看结果，并确定裸机性能对您的工作负载意味着什么。\n\n## 详细测试结果\n\n现在，让我们详细查看每个评估标准下裸机和 VM 集群的性能。\n\n## CPU 速度和利用率\n\n对于 CPU 速度比较，我们使用了 Alex Dedyura 的 [CPU 基准测试](https:\/\/github.com\/alexdedyura\/cpu-benchmark)。这是一个计算到 10,000 位小数的 pi 的脚本。以秒为单位的计算时间，平均值在 10 次测试中被视为测试结果。计算 pi 是一个 CPU 密集型任务，因此该基准测试清晰地显示了被测试 CPU 的性能。\n\n以下是 CPU 速度比较的结果：\n\n![图表显示，裸机集群的 CPU 速度比虚拟机集群的 CPU 快了两倍多](f35507b7-image3a.png)\n\n图 3：裸机集群的 CPU 速度比虚拟机集群的 CPU 快了两倍多。\n\n虚拟机集群的 10 次重试的平均时间为 47.07 秒；而裸机集群为 21.46 秒。因此，裸机集群快了两倍多。\n\n以下是虚拟机集群的 CPU 利用率测试结果：\n\n![平均利用率为 86.81%](12670f56-image4a.png)\n\n图 4：虚拟机集群的 CPU 平均利用率为 86.81%。\n\n![图 5：虚拟机集群 CPU 的每个核心使用信息](ef618156-image5a.png)\n\n图 5：虚拟机集群 CPU 的每个核心使用信息。\n\n在上图 4 中，红色点表示最大的 CPU 核心负载*，绿色表示所有核心的总 CPU 负载。在执行脚本期间，大部分时间内核心都以 100% 的利用率运行；平均值为 86.81%。还有一个小的窃取时间峰值，大约在 15:16（参见图 4），这是一个常见情况，当一个虚拟机由于等待物理 CPU 共享计算资源而没有运行时会发生。\n\n***最大 CPU 核心负载：** 这个指标通常是指在虚拟机内或主机上所有虚拟机中观察到的单个 CPU 核心的最高利用率百分比。它表示在给定时刻一个特定的 CPU 核心有多重地被利用。\n\n**总 CPU 核心负载：** 此指标表示主机机器上所有可用 CPU 核心的整体 CPU 利用率。它考虑了所有 CPU 核心的综合使用情况，提供了运行在主机上的所有虚拟机使用了多少 CPU 容量的综合视图。\n\n以下是裸机集群的 CPU 利用率测试结果：\n\n![图表显示，裸机集群的 CPU 平均利用率为 43.75%](d79f8453-image6a.png)\n\n图 6：裸机集群的 CPU 平均利用率为 43.75%。\n\n平均 CPU 负载约为 43.75%，最大负载为 62.57%，没有窃取时间。因此，就 CPU 性能而言，测试显示裸机集群约为虚拟机集群的两倍有效。\n\n## RAM 延迟\n\n对于 RAM 测试，[我们使用了 sysbench](https:\/\/github.com\/akopytov\/sysbench) 并通过 RAM 传输了 6400 GB 的数据。以下是执行的写入和读取操作的关键结果：\n\n![图 7：裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍](684e605e-7a.png)\n\n图 7：裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍。\n\n虚拟机集群执行写入操作的平均时间为 174.53 毫秒，而裸机集群相同操作仅需 62.02 毫秒。读取操作分别在 173.75 和 47.33 毫秒内完成。\n\n这意味着裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍。\n\n## 存储 TPS 和延迟\n\n为了测试存储性能，我们运行了一个 PostgreSQL 集群，并使用了 [pgbench 基准测试](https:\/\/www.postgresql.org\/docs\/current\/pgbench.html)。我们测量了 TPS（每秒事务数）和延迟。我们还变化了工作负载，测试了相同集群配置下的 8 GB 和 75 GB 数据库。\n\n以下是这些实例的配置：\n\n![图 8：存储测试的裸机和虚拟机集群配置](87869729-image8a.png)\n\n图 8：存储测试的裸机和虚拟机集群配置。\n\n### 存储 TPS 结果\n\n以下是 TPS 比较的平均结果：\n\n![图 9：裸机集群的存储 TPS 值大约是虚拟机集群的两倍](7bda97df-image9a.png)\n\n图 9：裸机集群的存储 TPS 值大约是虚拟机集群的两倍。\n\n在运行 8 GB 数据库时，虚拟机集群显示了 7,359 TPS，而裸机集群为 14,087 TPS。75 GB 数据库的性能结果分别为 4,636 和 12,029 TPS。\n\n### 存储延迟结果\n\n以下是延迟测试的平均结果：\n\n![图表显示，8 GB 测试中裸机集群的存储延迟约为虚拟机集群的一半，在 75 GB 测试中几乎是其三倍](311dd007-image10.png)\n\n图 10：裸机在存储延迟方面优于虚拟机。\n\n在运行 8 GB 数据库时，虚拟机集群的延迟为 34.78 毫秒，而裸机集群的延迟为 18.17 毫秒。对于 75 GB 数据库，延迟分别为 55.21 毫秒和 21.28 毫秒。\n\n对于 8 GB 数据库，裸机集群的存储性能约为虚拟机集群的两倍。对于 75 GB 数据库，裸机集群相对于虚拟机集群的优势更加明显。\n\n## 网络带宽和延迟\n\n为了测试网络性能，我们使用了 [netperf 基准测试](https:\/\/github.com\/kubernetes\/perf-tests\/tree\/master\/network\/benchmarks\/netperf)，其中 MSS（最大段大小）从 1 到 65,536 不等。MSS 中的“段”元素是在网络上传输的一种 IP 数据包捆绑。因此，MSS 越大，传输的流量就越多。\n\n我们在两个物理节点上部署了三个工作节点：Worker 1 和 Worker 2 位于第一个节点上，而 Worker 3 位于第二个节点上。然后，我们测试了所有三个工作节点之间的网络性能。在所有情况下，结果趋势都相似 — 裸机优于虚拟机。\n\n最有趣的测试是物理距离最远的测试之一，即 Worker 1\/Worker 2（位于第一个节点上）与 Worker 3（位于第二个节点上）之间的距离，当流量在第一个和第二个物理节点之间传输时。我们可以将这看作是所有测试中最具挑战性的条件。图 10 和图 11 显示了此测试的结果。图 10 显示了 MSS 值为 1、2、4 和 8 时的网络带宽比较：\n\n![图 11：裸机集群的网络带宽比虚拟机集群的网络带宽大五倍](4d53bfd2-image11.png)\n\n图 11：裸机集群的网络带宽比虚拟机集群的网络带宽大五倍。\n\n虚拟机集群的带宽范围从 MSS=1 时的 862 KB\/秒到 MSS=8 时的 6.52 MB\/秒，而裸机集群的带宽在相同的 MSS 值范围内从 4.17 MB\/秒到 31 MB\/秒不等。平均而言，裸机集群的带宽比虚拟机集群的带宽大五倍。\n\n图 12 显示了使用相同 MSS 值的网络延迟比较：\n\n![图 12：裸机集群的网络延迟比虚拟机集群的网络延迟低了多达六倍](5f29719e-image12.png)\n\n图 12：裸机集群的网络延迟比虚拟机集群的网络延迟低了多达六倍。\n\n正如我们所见，当使用 MSS=8 时，虚拟机集群的延迟约为 145 微秒（us），而裸机的延迟为 24.5 微秒。此外，在裸机集群的情况下，随着 MSS 的增加，延迟增长较慢。\n\n对于所有测试，请注意我们报告的是*内部*集群网络的网络性能比较。我们在一个网络中的节点之间测量了带宽和延迟，位于一个位置。如果我们使用不同位置的节点，这将增加互联网延迟，这是不稳定的，并且可能因提供商而异。我们保持了合成纯净的条件；这可能无法在实际环境中复制。但是，一般趋势可以预期会被重现。\n\n## 裸机性能优势意味着什么\n\n更好的裸机性能相对于虚拟机提供了两个简单但关键的优势：\n\n- [部署在裸机工作节点上的应用程序](https:\/\/thenewstack.io\/how-do-applications-run-on-kubernetes\/)运行和响应速度比部署在虚拟机上的应用程序更快。\n- 因此，当选择裸机时，客户在使用您的产品时将有更好的体验。\n\n我们的测试结果证实了一个普遍的期望，即裸机对于需要高性能和低延迟的计算密集型工作负载（例如数据库、AI\/ML 模型和其他类型的实时应用程序）更为适用。虚拟机则更适合不需要高计算和低延迟敏感性的工作负载，如 Web 服务器、网站和开发环境。如果高性能和低延迟对于您的用户至关重要，并直接影响您的业务，您应该考虑在 Kubernetes 集群中使用裸机。\n\n## 结论\n\n我们的测试证实了裸机工作节点优于虚拟机工作节点的假设。即裸机比起虚拟机：\n\n- 在 CPU 速度和利用率方面高三倍\n- RAM 延迟是虚拟机的 1\/3\n- 存储性能高两倍多\n- 网络延迟是虚拟机的 1\/5\n', '\/trans\/does-kubernetes-really-perform-better-on-bare-metal-vs-vms\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文对比了虚拟机和裸机上 Kubernetes 集群的 CPU、RAM、存储和网络性能的详细比较。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/externalname-and-serviceentry/">外部服务别名：ExternalName 与 ServiceEntry 对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('外部服务别名：ExternalName 与 ServiceEntry 对比', '了解 ExternalName 和 ServiceEntry 的优劣，根据需求选用。ExternalName 简单，适用于基本服务发现；ServiceEntry 复杂，适合复杂流量管理和服务发现。', '\n随着 Kubernetes 不断演进，Istio 功能逐渐在 Kubernetes 中找到对应实现，如 [Sidecar 容器](https:\/\/kubernetes.io\/blog\/2023\/08\/25\/native-sidecar-containers\/)、[Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 以及本文的主题 [ExternalName](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/service\/#externalname)。ExternalName 和 ServiceEntry 都能起到引入 Kubernetes 集群外部服务的作用，但是它们的功能和使用场景也有所区别，本文将为你详细解析。\n\n## ExternalName vs ServiceEntry\n\n下表从多个方面对比了 \u0060ExternalName\u0060 和 \u0060ServiceEntry\u0060 ：\n\n| 特性\/用例      | ExternalName                   | ServiceEntry                                                 |\n| -------------- | ------------------------------ | ------------------------------------------------------------ |\n| **流量控制**   | 有限，仅支持 TCP 和 UDP           | 更灵活，支持 TCP、UDP、HTTP 等多种协议，可以指定端口、TLS 等选项 |\n| **服务发现**   | 适用于外部服务的简单别名       | 适用于描述网格内外服务，包括外部和内部服务的详细配置         |\n| **配置复杂性** | 简单，适用于基本的服务发现需求 | 较复杂，适用于需要高级流量控制和详细配置的场景               |\n| **TLS 支持**    | 有限，较简单                   | 更丰富的 TLS 支持，可以指定证书等详细选项                      |\n| **安全性**     | 较基本，适用于简单的用例       | 更强大的安全性支持，可以定义 \u0060subjectAltNames\u0060 等选项        |\n| **用途**       | 适用于简单的外部服务别名       | 适用于复杂的流量管理和服务发现需求，尤其是在多协议和复杂网络拓扑中 |\n\n## 使用场景\n\n**ExternalName 的使用情况：**\n\n1. **简单的服务别名：** 外部服务只需一个简单别名，无需复杂流量控制，可选用 \u0060ExternalName\u0060。\n2. **无详细流量控制需求：** 不需要对服务流量进行详细控制，只需简单的服务别名访问，选用 \u0060ExternalName\u0060。\n\n**ServiceEntry 的使用情况：**\n\n1. **复杂流量控制需求：** 需要更复杂的流量控制，如指定协议、端口、TLS 选项等，选择 \u0060ServiceEntry\u0060。\n2. **描述网格内外服务：** 需要描述网格内外服务，包括外部和内部服务的详细配置，\u0060ServiceEntry\u0060 更适合。\n3. **对服务详细属性有要求：** 需要为服务定义特殊属性，如 \u0060subjectAltNames\u0060 等，需使用 \u0060ServiceEntry\u0060。\n\n### 在 Istio 中使用 ExternalName 可能遇到的问题\n\n在 Istio 1.20 以前，网格内存在 ExternalName 类型的 Service 时，若该 Service 的端口与其他外部服务的端口重叠，流量可能错误路由到该 ExternalName Service。该问题已在 Istio 1.20 版本中解决，详见 [Better support ExternalName #37331](https:\/\/github.com\/istio\/istio\/issues\/37331)。\n\n## 总结\n\n在服务网格的选择中，ExternalName 和 ServiceEntry 分别提供了简单的服务别名和更复杂的流量管理与服务发现选项。ExternalName 适用于简单的外部服务别名，而 ServiceEntry 在处理复杂流量控制和网格内外服务时更具优势。在实际应用中，根据具体需求和配置的复杂性权衡，灵活选择合适的机制。随着 Istio 和 Kubernetes 的不断演进，这些功能的使用方式可能会受到影响，因此保持关注相关社区的更新和最佳实践是保持系统健康和高效运行的关键。选择合适的服务网格组件将有助于构建可靠、安全且高度可扩展的微服务架构。\n', '\/blog\/externalname-and-serviceentry\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">了解 ExternalName 和 ServiceEntry 的优劣，根据需求选用。ExternalName 简单，适用于基本服务发现；ServiceEntry 复杂，适合复杂流量管理和服务发现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/kubernetes-gateway-api-enhancement-cloud-native-network/">Kubernetes Gateway API 如何增强云原生网络</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes Gateway API 如何增强云原生网络', 'Kubernetes Gateway API 和 Backstage 的结合标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。', '\n上周 Kubernetes Gateway API 的[正式发布公告](https:\/\/kubernetes.io\/blog\/2023\/10\/31\/gateway-api-ga\/)标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。与此同时，Kubernetes 社区一致认同[Backstage](https:\/\/backstage.io\/docs\/features\/kubernetes\/)是内部开发平台和门户的领先解决方案。Kubernetes Gateway API 和 Backstage 都从一开始就鼓励社区的可扩展性。可以说 API Gateway 的出现为增强 Kubernetes 网络提供了巨大的机会。\n\n## Gateway API vs Istio 服务网格\n\n不过也有人对 Gateway API 与 Istio 服务网格的关系存在疑问。对于 Gateway API 和 Istio 服务网格，两者都是为了解决 Kubernetes 网络中的问题。然而，Gateway API 着重于提供一种标准化和简化的方式来配置和部署 Ingress 和 Egress，是一个更加通用的 API。另一方面，Istio 服务网格更关注于服务到服务的通信，提供丰富的流量管理，安全，策略和遥测功能。\n\n## Kubernetes Gateway API 的未来\n\nKubernetes Gateway API 代表了 API Gateway 的关键基础，引入了一种标准，基于角色的，高度适应性的方法来配置和部署 Gateway。Kubernetes Gateway API 相比现有的 Kubernetes Ingress 的显著改进之一是其基于角色的 API 结构。这使得基础设施，平台和应用程序领域的各种角色能够拥有直接与他们的用例相关的 API 的各个方面。Gateway API 的另一个关键特性是其针对可扩展性的设计 - API 专注于核心 Gateway 和路由用例，具有扩展附加能力的可能性，例如安全性，速率限制和转换。\n\n## 什么是 Backstage？\n\nBackstage 是一个开源的开发者平台，它集成了所有开发者需要的服务，提供了一个统一的视图。这包括版本控制系统、持续集成\/持续部署（CI\/CD）系统、监控、日志、警报和文档。它旨在让开发者更高效地进行日常任务，而无需在多个工具之间切换，它也可以帮助开发者更好地理解和管理他们的软件。\n\n![Backstage UI](backstage-ui.png)\n\nBackstage 可以应用在多种使用场景中：\n\n- **作为服务目录**：Backstage 的软件目录功能可以帮助开发者找到并了解公司内部的所有服务和应用。\n- **作为自动化工具**：Backstage 的软件模板可以自动化 API 上线流程，使得开发者能够更快速、更安全地部署他们的 API。\n- **提供中心化的 API 文档**：Backstage 的 Tech Docs 功能可以提供中心化的 API 文档，使得开发者能够在一个地方查找所有的 API 文档，而无需在多个工具间切换。\n- **作为开发者门户**：Backstage 可以集成多种开发工具，提供一站式的开发者服务，简化开发者的工作流程。\n\nBackstage 通过其[软件目录](https:\/\/backstage.io\/docs\/features\/software-catalog\/)用于发现 API，[软件模板](https:\/\/backstage.io\/docs\/features\/software-templates\/)用于提供带有防护栏的自动 API 上线流程，以及[Tech Docs](https:\/\/backstage.io\/docs\/features\/techdocs\/)用于提供 API 文档的中心用例，用于围绕 API Gateway 的协作。\n\nBackstage 的目标是简化开发者工作流程，提供一站式的解决方案，它使开发者能够在一个平台上查找他们需要的所有信息，而不是在多个工具间切换。此外，Backstage 可以让开发团队专注于编码，而不是管理工具。它还支持多种插件，可以根据团队的需求进行定制。\n\n## 关于未来\n\nBackstage 和 Kubernetes Gateway API 已经牢固地将自己建立为云原生 API Gateway 的基础支柱，两个项目都在各自的路线图中充满创新。其中最有趣的领域是 Kubernetes Gateway API 超越其传统的南北入口能力，包括东西服务至服务通信，通过引入[GAMMA API](https:\/\/developer.gamma.co.uk\/guides\/overview.html)。在真实的流量在每个方向上流动的情况下，为南北和东西流量提供单一基础将有助于提高任何容器化应用的安全性，弹性和可观测性。\n', '\/blog\/kubernetes-gateway-api-enhancement-cloud-native-network\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kubernetes Gateway API 和 Backstage 的结合标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/wasm-vs-kubernetes/">[译] WebAssembly 能够取代 Kubernetes 吗？探索其优势和限制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/webassembly/yes-webassembly-can-replace-kubernetes/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('WebAssembly 能够取代 Kubernetes 吗？探索其优势和限制', 'WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。', '\n摘要：WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。与 Kubernetes 相比，WebAssembly 的优点在于简易性和安全性。但是，Kubernetes 始终有其用途，它将始终用于编排微服务和容器。因此，对于某些用例来说，WebAssembly 可以替代 Docker 和容器，但是在高度分布式的云原生环境中，使用 WebAssembly 来编排容器和微服务程度上与 Kubernetes 相同的程度是不可能的。\n\n------\n\n是的，WebAssembly 可以解决 Kubernetes 的一些问题。\n\nWebAssembly 或 Wasm 被证明是一种在 Web 浏览器上运行代码的非常实用的方式，它可以作为编译器。它已经作为一种语言运行得非常好，以至于世界万维网联盟（W3C）在 2019 年将其命名为 Web 标准，成为第四个 Web 标准，与 HTML、CSS 和 JavaScript 一起。\n\n主要的 Web 浏览器，包括 Mozilla、Chrome、Internet Explorer 等，都兼容 Wasm，用于编写代码和创建 Web 浏览器应用程序的使用越来越普遍。除了 Web 工作马车 JavaScript 外，Wasm 还可以容纳其他语言，包括 Go、.NET、C\u002b\u002b、Java、PHP、Rust 和 Python。\n\nAdobe 依赖于 Wasm\/WASI 平台在浏览器上直接运行 C\u002b\u002b 代码，这是其中一个更有趣的用例。这使得用户可以在浏览器上直接运行 Adobe 的 Photoshop 和 Acrobat，从而无需在用户的计算机上下载这些软件工具进行工作。\n\n最终，开发人员意识到 Wasm 也可以在服务器操作系统上运行，现在它的使用范围扩展到硬件平台。它在许多不同的硬件环境中表现出色，从服务器端到边缘部署和物联网设备，或者任何可以直接在 CPU 上运行代码的地方。代码打包在整洁的 Wasm 可执行文件中，可以将其与容器或甚至可以与较少配置的代码和目标运行的迷你操作系统进行比较。无论在哪里部署代码，应用程序都比仅限于 Web 浏览器环境更加广泛。\n\n在许多方面，Wasm 的功能可以与一个“大杂烩”多语言编译器相比。然而，与编译器相比，同一二进制可执行文件的 Wasm 可以针对多个平台进行目标和运行，而无需在 Wasm 代码和目标设备上进行配置。\n\n因此，与编译器相比，Wasm 在完美针对多个目标运行二进制可执行文件时显然比较优越。而在这种情况下，单个二进制可执行文件可以针对多个目标运行，而无需重新配置：这就是 Wasm 的优美之处。\n\n“Wasm 终于让我们在不涉及开发人员的情况下在服务器、云和边缘设备之间移动代码。这将最终结束开发人员花费大量时间担心调整他们的代码以及为不同的目标平台提供支持的时代，”Enterprise Management Associates（EMA）的分析师 Torsten Volk 告诉 The New Stack。“Wasm 的工作是在所有这些平台上提供一致的运行时。”\n\n因此，Wasm 可以在某些情况下为 Kubernetes 提供很好的替代方案。与 Kubernetes 相比的主要优点是：\n\n**简易性**。在部署应用程序时，即使将应用程序分发到不同的终端，也会有许多明显缺少的步骤。Cosmonic 的 PaaS 版本可以用几个命令行在图形界面中部署应用程序。当使用 Fermyon 和 Fastly 的 Compute@Edge 时，情况也是如此。\n\n**安全性**。在 Kubernetes 这种高度分布式的环境中，安全性是一个真正的问题，并且问题点的详尽列表太长，这里不再赘述。微服务之间的互连性意味着，在一个 Pod 中有数百个入口点中获得访问权限的攻击者可能会对组织的整个基础架构造成严重破坏。[秘密管理](https:\/\/thenewstack.io\/kubernetes-secrets-management-3-approaches-9-best-practices\/)是另一个问题，并且与名称一样，在容器中指定谁可以访问它们也存在困难。\n\nWasm 的可移植性和一致性可以使安全性和合规性更易于管理（再次强调，它在 CPU 级别的二进制格式中运行）。此外，Wasm 结构的简单性意味着代码在几乎直接到达端点的封闭沙箱环境中发布。Wasm 并非没有漏洞可以利用。只是相对于 Kubernetes，它的漏洞利用可能性更少。\n\n## 但它们并不是同一件事情\n\nWasm 提供了巨大的机会，并且可能会作为一种部署应用程序的方式，在未来几个月和几年中，我们将看到供应商变得更加有创造力，以便用户可以利用它。相比之下，那些预测 Wasm 最终将吃掉 Kubernetes 的午餐并完全取代它的人，可以说是错过了重点。不可能说会发生什么，以及其他用于在云环境中部署和管理高度分布式应用程序的技术可能最终取代 Kubernetes。但是，它高度不可能是 Wasm。\n\n这是因为 Kubernetes 始终有其用途。它将始终用于编排微服务，以及当然还有容器。它也可以被认为实际上就是 Wasm 将在其中运行的东西，并且其支持者已经说过 Wasm 非常适合在 Kubernetes 环境中运行。\n\n“[Wasm 是为开发人员提供无需编写和维护大量基础设施 YAML 的无服务器运行时](https:\/\/thenewstack.io\/webassembly\/serverless-webassembly-for-browser-developers\/)。Wasm 为应用程序代码提供了一组标准 API，以便访问关键的运行时服务，例如 SQL 或 NoSQL、Kafka 消息传递或代码调试，”Volk 说。“但是，然后 Wasm 依赖于资源编排层，可以由 Kubernetes 或任何其他调度器提供，以提供这些服务所需的基础设施资源。这些资源可以以容器、虚拟机、裸机或一些未曾想到的花哨未来技术的形式交付。”\n\n然而，并非所有人都认为 Kubernetes 作为容器编排的能力将无限期地保持其首选。许多 Wasm 领域的人都倾向于 HashiCorp 的 Nomad 调度器。的确，Fermyon 已经放弃了 Krustlet（Wasm-on-Kubernetes），并将重点转向 HashiCorp Nomad 作为其调度器。Butcher 说：“Nomad 在调度容器方面与 Kubernetes 相当，但具有一个至关重要的附加功能：它可以调度非容器工作负载。在 Fermyon 中，我们能够使 Nomad 调度和执行 WebAssembly 应用程序，而无需编写任何自定义代码。”\n\n与此同时，Kubernetes 开发人员需要在低级别上[接受 WebAssembly](https:\/\/thenewstack.io\/webassembly\/what-is-webassembly-and-why-do-you-need-it\/)，并更改内置的、容器特定的假设，Butcher 说。微软是第一家真正拥抱这个概念的公司，它的[runwasi](https:\/\/github.com\/containerd\/runwasi)项目是 WebAssembly 如何在 Kubernetes 内部执行的示例，Butcher 说。\n\n“runwasi 项目仅仅是 Kubernetes 需要经历的一系列转型中的第一步，如果它不想被 Nomad 和 Wasm 超越，它的开发人员和维护人员需要快速采取行动。”Butcher 说。“Kubernetes 的游戏要输，但如果它不想被 Nomad 和 Wasm 取代，它们需要迅速采取行动。”\n\n## 存在的威胁\n\nWebAssembly 对于 Docker 以及容器构成了一种存在的威胁，尽管在超越 Kubernetes 方面，WebAssembly 的简单性、可移植性和安全性等优势使其成为弥补 Docker 缺陷的良好选择，特别是对于边缘和分布式应用。然而，Butcher 指出，Docker 在以下两种应用程序提供环境时表现出色：\n\n- 长时间运行的过程，如数据库和消息队列，这些过程需要强大的 I\/O 和内存管理能力。\n- 遗留（传统）代码，该代码在应用程序中保留状态并大量使用线程。\n\n“Butcher 说：“我对 Docker 的看法是，它在市场上有一个强大且不可撼动的地位，WebAssembly 不太可能取代它。但是，当涉及到微服务和 Web 应用程序后端时，我认为 WebAssembly 有望削减 Docker 的使用。”\n\n因此，对于某些用例来说，Wasm 可以替代 Docker 和容器，但是在高度分布式的云原生环境中，使用 Wasm 来编排容器和微服务程度上与 Kubernetes 相同的程度是不可能的。\n', '\/trans\/wasm-vs-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/7-steps-to-highly-effective-kubernetes-policies/">[译] 创建高效 Kubernetes 策略的 7 个步骤</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/7-steps-to-highly-effective-kubernetes-policies/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('创建高效 Kubernetes 策略的 7 个步骤', '本文介绍了 Kubernetes 策略的七个步骤，包括基线、修复标签和注释、迁移到受限制的 Pod Security 标准、压制误报、加入常见加固指南、插入并播放、添加自定义规则以应对未预料的特殊情况。通过实施这些步骤，可以逐步减少配置错误和漏洞的数量，实现认证、合规和长期安全目标。', '你刚刚开始了一份新工作，在这个工作中，你第一次有责任操作和管理 Kubernetes 基础设施。你对更深入地了解云原生充满了热情，但同时也非常担心。\n\n是的，你关注的是编写符合命名和资源使用控制最佳实践的安全应用程序的最佳方法，但是关于已经部署到生产环境中的所有其他内容呢？你打开一个新的工具来查看正在发生的情况，发现有 100 个高或严重的 CVE 和 YAML 配置问题。你关闭标签页告诉自己，你以后会处理所有这些问题的。\n\n你会吗？\n\n也许最有雄心壮志和无所畏惧的人会，但问题在于云原生社区喜欢谈论安全、标准化和“左移”，但这些对话都无法减轻因安全、资源、语法和工具问题而产生的不安全感。没有一个开发范式或工具似乎发现了在不压垮人的情况下让错误配置可见的正确方式。\n\n就像我们可能面对的所有待办事项列表一样，无论是工作还是家务，我们的大脑只能有效地处理有限数量的问题。太多问题了，我们就会迷失在上下文切换和优先处理不完整的临时解决方案之间。我们需要更好的方法来限制范围（即分类），设置里程碑，最终使安全工作可管理。\n\n是时候忽略问题的数量，专注于交互地塑造，然后强制执行你的组织使用已建立策略的方式，以产生影响——无需产生不安全感。\n\n## 云原生策略的历史\n\n从 Kubernetes 的第一天开始，YAML 配置就是构建完整集群和运行应用程序的基石。作为开发人员应用程序代码和运维工程师维护集群之间的必要桥梁，它们不仅难以正确获取，而且还是 Kubernetes 中大多数部署\/服务级别问题的根源。更有甚者，没有人——既不是开发人员，也不是运维工程师——想独自对此负责。\n\n策略作为一种自动化的方式进入了云原生空间，用于编写和审批为生产环境编写的 YAML 配置。如果没有一个人或团队想要根据内部样式指南手动检查每个配置，那么策略可以慢慢塑造团队解决安全、资源使用和云原生最佳实践中的常见配置错误的方式。更不用说任何唯一应用程序的规则或习语了。\n\nKubernetes 中策略的挑战在于它对如何、何时和为什么执行它们是不可知的。你可以用多种方式编写规则，在软件开发生命周期（SDLC）的不同点执行它们，并出于不同的原因使用它们。\n\n在此混乱中，没有比 Pod 安全策略（PSP）更好的例子了，它在 2016 年 v1.3 中进入 Kubernetes 生态系统。PSP 的设计目的是控制 pod 的操作方式并拒绝任何不符合要求的配置。例如，它允许 K8s 管理员防止开发人员在任何地方运行特权 pod，从而实质上将低级别的 Linux 安全决策与开发生命周期分离开来。\n\nPSP 从未离开 beta 阶段，有几个很好的理由。这些政策仅在人或进程请求创建 pod 时应用，这意味着没有办法对 PSP 进行改进或默认启用。Kubernetes 团队承认 PSP 使意外授予过于广泛的权限变得太容易了，除了[其他困难](https:\/\/youtu.be\/SFtHRmPuhEw?feature=shared\u0026t=970)。\n\nKubernetes 安全领域的 PSP 时代充满了风险，这启发了一个新的发布周期管理规则：任何 Kubernetes 项目不能超过两个发布周期处于 beta 状态，必须成为稳定的或者标记为[弃用](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/migrate-from-psp\/#disable-psp https:\/\/kubernetes.io\/blog\/2021\/04\/06\/podsecuritypolicy-deprecation-past-present-and-future\/)和删除。\n\n另一方面，PSP 使 Kubernetes 安全领域朝着积极的方向发展：通过将 Kubernetes 安全策略的创建和实例化分离，PSP 开辟了一个新的外部接入控制器和策略执行工具生态系统，例如[Kyverno](https:\/\/kyverno.io\/)、[Gatekeeper](https:\/\/open-policy-agent.github.io\/gatekeeper\/website\/)和[Monokle](https:\/\/monokle.io\/)。\n\n我们用这些工具摆脱了 PSP 的束缚，并用 Pod Security Standard（PSS）替换了它。一会我们再来谈这个巨大的区别。\n\n## 基于阶段的 Kubernetes 策略方法\n\n在确定了策略创建和实例化之间的解耦后，您现在可以在不管您选择哪些工具的情况下，在您的集群、环境和团队之间应用一致的策略语言。您也可以随时更改您用于创建和实例化的工具，并在您的集群中获得可靠的结果。\n\n创建通常发生在集成开发环境（IDE）中，这意味着您可以继续使用您当前最喜欢的语言来使用规则特定的语言，如[Open Policy Agent (OPA)](https:\/\/monokle.io\/learn\/what-is-opa-for-the-kubernetes-connoisseur-its-as-essential-as-salt)、Kyverno 的声明性语法或 Go 或 TypeScript 等编程语言。\n\n实例化和强制执行可以在软件开发生命周期的不同部分进行。正如我们在我们之前的[101 级帖子](https:\/\/medium.com\/kubeshop-i\/kubernetes-yaml-policies-101-649a23780371)中看到的那样，您可以在配置生命周期的一个或多个点应用验证：\n\n1. 通过开发人员的命令行界面（CLI）或 IDE 直接预提交\n2. 通过您的CI\/CD流水线进行预部署\n3. 通过像 Kyverno 或 Gatekeeper 这样的[接入控制器](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/)进行后部署，或者\n4. 在集群中检查部署状态是否仍符合您的策略标准。\n\n策略的实例化、验证和强制执行越晚，危险的错误配置就越容易滑入生产环境，发现和修复任何发现的错误配置的原始来源所需的工作也越多。您可以在几个阶段实例化和强制执行策略，但越早越好——这正是 Monokle 擅长的，具有强大的预提交和预部署验证支持。\n\n有了这个场景，以及对 Kubernetes 策略景观的理解，您可以开始消除您面前的误配置。\n\n### 步骤 1：实施 Pod Security 标准\n\n让我们从前面提到的 PSS 开始。Kubernetes 现在描述了[三个包容性策略](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/)，您可以快速在整个集群中实施和执行。 “特权”策略完全不受限制，应该仅保留给由管理员管理的系统和基础设施工作负载。\n\n您应该从实例化“基线”策略开始，它允许最小规格的 Pod，这是大多数新接触 Kubernetes 的开发人员开始的地方：\n\n从基线开始的好处是，您无需修改所有现有的 Dockerfile 和 Kubernetes 配置即可防止已知的权限升级。会有一些例外情况，稍后我会谈到。\n\n在命名空间级别上创建和实例化这个策略级别是相对简单的：\n\n您肯定会有一些特殊的服务需要比基线允许的访问权限更多，例如用于收集日志和可观测性的[Promtail 代理](https:\/\/grafana.com\/docs\/loki\/latest\/clients\/promtail\/)。在这些情况下，您需要在特权策略下运行那些命名空间。您需要跟进该供应商的安全改进，以限制您的风险。\n\n通过强制执行 Pod Security 标准的基线水平来处理大多数配置，并允许一些特权配置，然后修复违反这些策略的任何误配置，您就完成了下一个策略里程碑。\n\n### 步骤 2：修复标签和注释\n\n标签用于标识资源进行分组或过滤，而注释则用于重要但不用于识别的上下文。如果您的头脑仍在旋转，来自 Ambassador Labs 的 Richard Li 的[一个方便的定义](https:\/\/blog.getambassador.io\/kubernetes-labels-vs-annotations-95fc47196b6d)可能会帮助：“标签是为 Kubernetes 而设计的，而注释是为人类而设计的。”\n\n标签应仅用于其预定目的，即使在这种情况下，您在何处以及如何应用它们时也要小心。过去，[攻击者已使用标签](https:\/\/sysdig.com\/blog\/exposed-prometheus-exploit-kubernetes-kubeconeu\/)深入探索 Kubernetes 集群的架构，包括哪些节点运行单个 Pod，而不留下运行的查询的日志。\n\n同样的想法也适用于注释：虽然它们是为人类而设计的，但它们经常被用于[获取凭证](https:\/\/github.com\/kubernetes\/ingress-nginx\/issues\/8503)，进而获得访问更多秘密的权限。如果您使用注释来描述应在出现问题的情况下联系的人员，请知道您正在为社交工程攻击创建额外的软目标。\n\n### 步骤 3：迁移到受限制的 PSS\n\n虽然基线是可允许但相对安全的，但“受限制”Pod Security 标准采用了目前加固 Pod 的最佳实践。正如 Red Hat 的 Mo Khan[曾经描述](https:\/\/youtu.be\/SFtHRmPuhEw?t=1951)的那样，受限制的标准确保“您能做的最糟糕的事情是毁掉自己”，而不是您的集群。\n\n使用受限制的标准，开发人员必须编写在只读模式下运行的应用程序，仅启用 Pod 运行所需的 Linux 功能，不能在任何时候升级特权等。\n\n我建议从基线开始并稍后迁移到受限制，作为单独的里程碑，因为后者几乎总是需要对现有的 Dockerfile 和 Kubernetes 配置进行主动更改。一旦您实例化并强制执行了受限制策略，您的配置将需要遵守这些策略，否则它们将被您的验证器或接入控制器拒绝。\n\n### 步骤 3a：压制而不是忽略不可避免的误报\n\n在完成基线和受限制的里程碑时，您正在接近策略管理的更成熟（和复杂）水平。为了确保每个人都在当前策略里程碑方面保持一致，您应该开始处理虚假阳性或必须显式允许的配置，尽管违反了受限制的 PSS。\n\n在忽略规则或抑制规则之间进行选择时，始终选择抑制规则。这需要一个可审计的操作，具有日志或配置更改，以将例外情况编码为已建立的策略框架。您可以在源中添加抑制规则，直接添加到您的 K8s 配置中或在外部添加，其中开发人员请求其运维同行重新配置其验证器或接入控制器，以允许“误配置”通过。\n\n在 Monokle 中，您可以将抑制直接添加到您的配置中作为注释，使用[静态分析结果交换格式（SARIF）规范](https:\/\/docs.oasis-open.org\/sarif\/sarif\/v2.1.0\/sarif-v2.1.0.html)所称的[理由](https:\/\/docs.oasis-open.org\/sarif\/sarif\/v2.1.0\/os\/sarif-v2.1.0-os.html#_Toc34317739)：\n\n### 第 4 步：加入常见加固指南\n\n在这一步中，您已经超越了已有的 Kubernetes 安全框架，这意味着您需要更多地积极构建和努力实现自己的里程碑。\n\n美国国家安全局（NSA）和网络安全和基础设施安全局（CISA）有一份受欢迎的[Kubernetes 加固指南](https:\/\/media.defense.gov\/2022\/Aug\/29\/2003066362\/-1\/-1\/0\/CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.PDF)，其中详细介绍了不仅是 Pod 级别的改进措施，如有效地使用不可变容器文件系统，还包括网络分离、审计日志和威胁检测。\n\n### 第 5 步：插入并播放\n\n在实施了一些或所有已有的加固指南之后，每个新的策略都涉及选择、信任和权衡。花些时间在谷歌或 StackOverflow 上，你就会发现很多推荐的插入和播放策略。\n\n你可以从众包策略中受益，其中许多来自于那些有着更独特经验的人，但请记住，虽然规则可能是出于良好意图的，但你并不了解推荐者的优先事项或操作上下文。他们知道如何实现某些“高挂水果”政策，因为他们不得不这样做，而不是因为这些政策普遍有价值。\n\n目前正在进行的辩论是是否以及如何严格限制容器的资源需求。对于请求限制也是如此。不配置限制可能会引入安全风险，但如果严重限制 Pod，它们可能无法正常运行。\n\n### 第 6 步：添加自定义规则以应对未预料的特殊情况\n\n现在，你已经到了 Kubernetes 策略的远端，远离了导致生产负面影响的 20％的错误配置和漏洞。但即使现在，即使已经实施了所有的最佳实践和集体云原生知识，你仍然无法免疫不会意地引发事故或停机的错误配置 - 安全和稳定的奇妙未知未知。\n\n一个好的经验法则是，如果一个奇特的（错）配置在生产中引起了两次问题，那么就该将其编码为一条自定义规则，在开发过程中强制执行，或由准入控制器强制执行。它太重要了，不能仅在内部悄悄地记录下来，希望开发人员阅读它，在彼此的拉取请求审查中注意到它并捕获它。\n\n一旦编码到您现有的策略中，自定义规则就成为了您尽可能接近开发人员执行的防护栏杆。如果你可以在开发人员提交工作之前就用验证到达开发人员，Monokle Cloud 就可以无缝地执行这一点，使用自定义插件和您本地运行的开发服务器，那么您可以节省整个组织大量的重复工作和调整他们的拇指等待 CI\/CD 管道无可避免地失败时他们可以构建新功能或修复错误。\n\n## 总结\n\n如果您实施了以上所述的所有框架和里程碑，并对您的 Dockerfile 和 Kubernetes 配置进行了所有必要的更改以满足这些新策略，那么您可能会发现您的 90 个主要漏洞清单已经减少到了一个更易管理的数量。\n\n您正在看到我们逐步塑造和执行 Kubernetes 策略的方法的价值。您与新策略和规则的影响互动得越多，就像 Monokle 在提交之前唯一做到的那样，就越容易在不压垮自己或其他人的情况下逐步迈出步伐。\n\n您甚至可能会自豪地宣称，您的 Kubernetes 环境完全没有配置错误。这是一种胜利，毫无疑问，但这不是保证 - 总会有新的 Kubernetes 版本、新的应用程序和新的最佳实践融入到您已经完成的工作中。利用框架和加固指南的优势在于，您有更好的共同基础来谈论您在认证、合规和长期安全目标方面的影响。\n\n对于非专家来说，哪种听起来更有说服力：\n\n- 您将 CVE 数量从 90 个降至 X 个，\n- 还是您完全符合美国国家安全局的 Kubernetes 加固指南？\n\n我们越早不再担心数字，而是更多地关注共同里程碑，在应用程序生命周期的早期（理想情况下是 pre-commit！）尽早执行，我们就能找到每个云原生策略的可持续甜蜜点。\n', '\/trans\/7-steps-to-highly-effective-kubernetes-policies\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Kubernetes 策略的七个步骤，包括基线、修复标签和注释、迁移到受限制的 Pod Security 标准、压制误报、加入常见加固指南、插入并播放、添加自定义规则以应对未预料的特殊情况。通过实施这些步骤，可以逐步减少配置错误和漏洞的数量，实现认证、合规和长期安全目标。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/can-chatgpt-save-collective-kubernetes-troubleshooting/">[译] Kubernetes 故障排除智慧的演变</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/can-chatgpt-save-collective-kubernetes-troubleshooting/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 故障排除智慧的演变', '本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI\/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。', '摘要：本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI\/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。\n\n---\n\n本文译自：https:\/\/thenewstack.io\/can-chatgpt-save-collective-kubernetes-troubleshooting\/\n\n数十年前，系统管理员们开始在互联网上分享他们每天面临的技术问题。他们进行了长时间、充满活力且富有价值的讨论，探讨如何调查和解决问题的根本原因，然后详细说明最终对他们有效的解决方案。\n\n这股洪流从未停歇，只是改变了流向。如今，这些讨论仍在 Stack Overflow、Reddit 以及企业工程博客上进行。每一次讨论都是对全球 IT 系统故障排除经验的宝贵贡献。\n\n[Kubernetes](https:\/\/roadmap.sh\/kubernetes)也从根本上改变了这种流向。与几十年来困扰系统管理员和 IT 人员的虚拟机（VM）和单体应用程序相比，[微服务架构](https:\/\/thenewstack.io\/microservices\/)要复杂得多。由于 Kubernetes 缺乏数据持久性，往往无法对规模化的 K8s 错误进行本地重现。即使能够捕获，观测数据也会在多个平台上分散，而资源和依赖关系的相互关联关系也难以捕捉。\n\n现在，凭直觉并不一定足够。您需要知道如何调试集群以获得下一步的线索。\n\n这种复杂性意味着公开的故障排除讨论比以往任何时候都更为重要，但现在我们开始看到这股宝贵的洪流不是被重定向，而是完全被堵住了。你在谷歌上看到了这一点。任何与 Kubernetes 相关问题的搜索都会出现一半以上的付费广告和至少一页 SEO 驱动的文章，这些文章缺乏技术深度。[Stack Overflow](https:\/\/thenewstack.io\/stack-overflow-adds-ai-will-the-community-respond\/) 正在失去其作为技术人员首选问答资源的主导地位，Reddit 在过去几年中也陷入了争议。\n\n现在，每个 Kubernetes 的 DevOps 平台都在建立最后一个堤坝：将您的故障排除知识集中在其平台上，并用[人工智能（AI）和机器学习（ML）](https:\/\/thenewstack.io\/70-percent-of-developers-using-or-will-use-ai-says-stack-overflow-survey\/)取而代之，直到整个堆栈对于甚至是最有经验的云原生工程师来说都成为一个黑盒。当发生这种情况时，您失去了逐个探测、排除故障和修复系统的能力。这种趋势将曾经是众包故障排除技能洪流变成了过去所能提供的仅仅是一滴水。\n\n当我们依赖于平台时，故障排除技术的集体智慧就会消失。\n\n## 故障排除智慧的传承\n\n起初，系统管理员依靠实体书籍进行技术文档和整体最佳实践的实施。随着互联网在 80 年代和 90 年代的普及，这些人通常通过[Usenet](https:\/\/today.duke.edu\/2010\/05\/usenet.html)与同行进行交流，并在像 comp.lang.* 这样的新闻组中提出工作中的技术问题，这类新闻组类似于我们今天所知的论坛的简化版本。\n\n随着互联网的普及迅速，并几乎完全改变了故障排除智慧的洪流。工程师和管理员们不再聚集在新闻组中，而是涌向包括 Experts Exchange 在内的数千个论坛，该论坛于 1996 年上线。在积累了大量的问题和答案之后，Experts Exchange 团队将所有答案都放在了每年 250 美元的付费墙后面，这使得无数宝贵的讨论无法公开获取，最终导致了该网站的影响力下降。\n\n[Stack Overflow 随后出现](https:\/\/www.joelonsoftware.com\/2018\/04\/06\/the-stack-overflow-age\/)，再次向公众开放了这些讨论，并通过声望点数对讨论进行游戏化，这些声望点数可以通过提供见解和解决方案来获得。其他用户随后对“最佳”解决方案进行投票和验证，这有助于其他搜索者快速找到答案。Stack Overflow 的游戏化、自我管理和社区使其成为了洪流式故障排除知识的唯一渠道。\n\n但是，就像其他时代一样，没有什么好事能永远持续下去。近 10 年来，人们一直在预测[“Stack Overflow 的衰落”](https:\/\/johnslegers.medium.com\/the-decline-of-stack-overflow-7cb69faa575d)，并指出由于其具有攻击性的性质和由拥有最多声望点数的人进行管理的结构，它“讨厌新用户”。虽然 Stack Overflow 的影响力和流行度确实下降了，但 Reddit 的开发\/工程专注的 subreddit 填补了这个空白，它仍然是公开可访问的故障排除知识的最大存储库。\n\n特别是对于 Kubernetes 和云原生社区来说，这仍然是一个重要的资源，因为它们仍然在经历重大的增长阵痛。而这是一种宝贵的资源，因为如果您认为现在的 Kubernetes 已经很复杂了...\n\n## Kubernetes 的复杂性问题\n\n在一篇关于“直观调试”失败的精彩文章中，软件交付顾问 Pete Hodgson 认为，构建和交付软件的现代架构（如 Kubernetes 和微服务）比以往任何时候都更加复杂。他写道：“对于我们大多数人来说，为服务器命名为希腊神话角色，并通过 ssh 进入服务器运行\u0060tail\u0060和\u0060top\u0060的日子已经一去不复返了。”但是，“这种转变是有代价的……传统的理解和故障排除生产环境的方法在这个新世界中已经行不通了。”\n\n![Cynefin 模型](cynfin.jpg)\n\n*Cynefin 模型。来源：维基百科*\n\nHodgson 使用[Cynefin 模型](https:\/\/en.wikipedia.org\/wiki\/Cynefin_framework)来说明软件架构过去是复杂的，因为有足够的经验，人们可以理解故障排除和解决方案之间的因果关系。\n\n他认为，分布式微服务架构是复杂的，即使经验丰富的人对根本原因以及如何进行故障排除也只有“有限的直觉”。他们必须花更多时间通过可观测性数据提出问题和回答问题，最终假设可能出错的原因。\n\n如果我们同意 Hodgson 的前提 - Kubernetes 本质上是复杂的，并且在响应之前需要花费更多的时间分析问题，那么与 Kubernetes 一起工作的工程师学会了哪些问题最重要，然后用可观测性数据回答，以进行最佳的下一步行动，似乎是至关重要的。\n\n这正是新一代以 AI 驱动的故障排除平台所提供的智慧。\n\n## Kubernetes 故障排除的两种路径\n\n多年来，像 OpenAI 这样的公司一直在根据 Stack Overflow、Reddit 等公开数据进行抓取和训练模型，这意味着这些 AI 模型可以访问大量的系统和应用知识，包括 Kubernetes。还有一些人意识到组织的可观测性数据是训练 AI\/ML 模型分析新场景的宝贵资源。\n\n他们都在问同一个问题：我们如何利用关于 Kubernetes 的现有数据来简化搜索最佳解决方案的过程？他们正在构建的产品采取非常不同的路径。\n\n### 第一种：增强操作员的分析工作\n\n这些工具自动化和简化对公开在线发布的大量故障排除知识的访问。它们不会取代进行适当故障排除或[根本原因分析](https:\/\/aws.amazon.com\/opensearch-service\/resources\/root-cause-analysis\/)（RCA）所需的人类直觉和创造力，而是有条不紊地自动化操作员查找相关信息的方式。\n\n例如，如果一个刚接触 Kubernetes 的开发人员在运行\u0060kubectl get pods\u0060时发现\u0060CrashLoopBackOff\u0060状态导致他们无法部署应用程序，他们可以查询一个 AI 驱动的工具以获得建议，比如运行\u0060kubectl describe $POD\u0060或\u0060kubectl logs $POD\u0060。这些步骤可能会进一步引导开发人员使用\u0060kubectl describe $DEPLOYMENT\u0060来调查相关的部署情况。\n\n在[Botkube](https:\/\/botkube.io\/)，我们对使用 AI 在大量故障排除智慧的基础上自动化这个来回查询的概念非常感兴趣。用户应该能够直接在 Slack 中提问，如“我如何排除这个无法正常工作的服务？”并收到 ChatGPT 撰写的回答。在一次公司范围的黑客马拉松活动中，我们着手实施这一概念，为我们的协作故障排除平台构建了一个新的插件。\n\n通过[Doctor](https:\/\/botkube.io\/blog\/use-chatgpt-to-troubleshoot-kubernetes-errors-with-botkubes-doctor)，您可以利用大量的故障排除知识，通过 Botkube 作为您的 Kubernetes 集群和消息\/协作平台之间的桥梁，无需在 Stack Overflow 或 Google 搜索广告中漫游，这对于新手 Kubernetes 开发人员和操作员特别有用。\n\n该插件还通过生成一个带有**获取帮助**按钮的 Slack 消息进一步自动化，用于任何错误或异常，然后查询 ChatGPT 以获取可行的解决方案和下一步操作。您甚至可以将 Doctor 插件的结果导入其他操作或集成，以简化您主动使用现有广泛的 Kubernetes 故障排除知识来更直观地调试和感知问题的方式。\n\n### 第二种：将操作员从故障排除中排除\n\n这些工具不关心公开知识的泛滥。如果它们可以基于实际的可观测性数据训练通用的 AI\/ML 模型，然后根据您的特定架构进行微调，它们可以试图完全剔除人为操作员在根本原因分析和故障修复中的作用。\n\n[Causely](https:\/\/www.causely.io\/platform\/causely-for-kubernetes-applications\/)就是这样一家初创公司，他们并不回避使用 AI 来“消除人为故障排除”的愿景。该平台连接到您现有的可观测性数据，并处理它们以微调因果关系模型，理论上可直接进行修复步骤 - 无需探测或使用\u0060kubectl\u0060。\n\n如果说有时候有一个 Kubernetes 神灵听起来很诱人，那我可能会撒谎，但我对像 Causely 这样的工具夺走运维工作并不担心。我担心的是在 Causely 引领的未来中，我们宝贵的故障排除知识会发生什么。\n\n### 这两种路径之间的差距：数据\n\n我不是在为“人工智能将取代所有 DevOps 工作”发表言论。我们已经读过太多这样的末日场景，适用于每个小众和行业。我更关心这两种路径之间的差距：用于训练和回答问题或呈现结果的数据是什么？\n\n第一种路径通常使用现有的公开数据。尽管有关 AI 公司爬取这些站点进行训练数据的担忧-Reddit 和 Twitter，但这些数据的开放性仍然提供了一个激励循环，以保持开发人员和工程师继续在 Reddit、Stack Overflow 和其他平台上共享知识的持续泛滥。\n\n云原生社区通常也倾向于共享技术知识，认同共享技术知识和一个“涨潮（Kubernetes 故障排除技巧的涨潮）抬高所有船（压力巨大的 Kubernetes 工程师）”的想法。\n\n第二条路径看起来更为暗淡。随着以 AI 驱动的 DevOps 平台的兴起，越来越多的故障排除知识被锁定在这些仪表板和驱动平台的专有 AI 模型中。我们都同意，Kubernetes 基础架构将继续变得更加复杂，而不是更简单，这意味着随着时间的推移，我们对节点、Pod 和容器之间发生的情况的理解将变得更少。\n\n当我们停止互相分析问题和感知解决方案时，我们变得依赖于平台。这对每个人来说都是一条失败的道路，除了平台之外。\n\n### 我们如何不失去（或失去得更少）？\n\n我们能做的最好的事情是继续在线上发布关于我们在 Kubernetes 和其他领域的故障排除经验的惊人内容，比如“[关于故障排除 Kubernetes 部署的视觉指南](https:\/\/learnk8s.io\/troubleshooting-deployments)”；通过游戏化创造教育性应用程序，比如[SadServers](https:\/\/sadservers.com\/)；在故障排除系统时采取我们最喜欢的第一步，比如“[为什么在排除未知机器问题时我通常首先运行‘w’](https:\/\/rachelbythebay.com\/w\/2018\/03\/26\/w\/)”；并进行详细的事后分析，详细描述了探测、感知和应对潜在灾难性情况的压力故事，比如[2023 年 7 月的 Tarsnap 故障](https:\/\/mail.tarsnap.com\/tarsnap-announce\/msg00050.html)。\n\n我们还可以超越技术解决方案，比如讨论我们如何在紧张的故障排除场景中管理和支持同事，或者在组织范围内建立对可观测性的一致认识。\n\n尽管它们目前面临困境，但 Stack Overflow 和 Reddit 将继续是讨论故障排除和寻求答案的可靠渠道。如果它们最终与 Usenet 和 Experts Exchange 齐名，它们可能会被其他可公开获得的替代品所取代。\n\n无论何时何地以何种方式发生，我希望您能加入我们在 Botkube 和全新的 Doctor 插件中，为在 Kubernetes 中协作解决复杂问题构建新的渠道。\n\n无论 AI 驱动的 DevOps 平台是否继续基于抓取的公共 Kubernetes 数据训练新模型，只要我们不自愿地将好奇心、冒险精神和解决问题的能力全部放入这些黑匣子中，就会始终有一条新路径，让宝贵的故障排除知识源源不断地流动。\n', '\/trans\/can-chatgpt-save-collective-kubernetes-troubleshooting\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/docker-four-milestones/">Docker 发展史：四个重大举措，影响深远！</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/04/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Docker 发展史：四个重大举措，影响深远！', '在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。', '\n在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。\n\n## 当我们在谈论 Docker 时我们在谈论什么？{#what-are-we-talking-about-docker}\n\n首先我们需要先确定 Docker 这个词的含义。当人们在谈论 Docker 时可能指的是：\n\n1. Docker 公司\n2. Docker 软件栈\n3. Docker 命令行工具\n4. Docker 容器运行时\n\n为什么同一个词会有这么多不同的意思呢？这都是有历史原因的。Docker 软件于 2013 年发布，起初定位为开发者工具。作为最早发布的容器工具，它迅速走红，并成为容器技术的代名词。但它最初只是在单机上运行，有太多耦合的接口设计。后来容器集群出现，才需要用到容器编排调度工具。因为 Kubernetes 具有丰富的功能和扩展性，Docker 公司推出的 Swarm 在这场容器编排大战中败下阵来。归根结底，Docker 面向开发者，而容器运行时则面向机器，只需要对应的接口即可，不需要那么丰富的管理工具。如今，Docker 仍然是最受开发者喜爱的容器工具之一，其 Docker Hub 是全球最大的镜像仓库。\n\n## 将 Docker 项目改名为 Moby {#rename-docker-to-moby}\n\n2017 年 4 月，Docker 公司将 Docker 项目重命名为 Moby，详见 [Introducing Moby Project: a new open-source project to advance the software containerization movement](https:\/\/www.docker.com\/blog\/introducing-the-moby-project\/)：\n\n- [Moby Project](https:\/\/github.com\/moby\/moby) 是 Docker 公司为了应对容器技术在各个领域和用例中普及的趋势而发起的一个开源项目。\n- Moby Project 是 Docker 公司作为一个开放的研发实验室，与整个生态系统合作，实验，开发新的组件，并协作构建容器技术的未来。\n- Moby Project 不是 Docker 产品的替代品，而是 Docker 产品的基础。\n- Moby Project 包括三个层次：组件层，框架层和装配层。\n    - 组件层包括一些可复用的开源组件，如 runc, containerd, LinuxKit, InfraKit 等，可以用于构建各种类型的容器系统。\n    - 框架层提供了一些工具和库，用于将组件组装成系统，并管理其生命周期。\n    - 装配层是一个社区驱动的平台，用于分享和协作构建基于 Moby 框架的系统。\n\nMoby Project 是一个新的开源项目，旨在推动软件容器化运动的发展，帮助生态系统让容器技术走向主流。它提供了一个组件库，一个用于将组件组装成定制的基于容器的系统的框架，以及一个让所有容器爱好者可以实验和交流想法的地方。\n\nMoby Project 和 Docker 的区别和联系是：\n\n- Moby Project 是一个开源项目，Docker 是一个商业产品。\n- Moby Project 是 Docker 产品的基础，Docker 产品是 Moby Project 的一个实例。\n- Moby Project 是一个通用的框架，可以用于构建各种类型和用例的容器系统，Docker 是一个针对特定用例的容器系统，即构建，运行和共享应用程序。\n- Moby Project 是一个开放的研发实验室，用于实验和协作开发新的容器技术，Docker 是一个成熟的产品，用于提供稳定和可靠的容器服务。\n\n## 支持 Kubernetes 调度 {#support-kubernetes}\n\nDocker 公司在 2017 年 12 月发布的 Docker 17.12 版本中开始支持 Kubernetes。在此之前，Docker 公司一直在发展自己的容器编排和调度工具 Docker Swarm。然而，Kubernetes 在容器编排和调度方面具有更广泛的支持和社区贡献，已经成为了业界标准。因此，Docker 公司决定将 Kubernetes 集成到 Docker 平台中，以提供更广泛的选择和更好的用户体验。Docker 公司在 Docker Desktop 和 Docker Enterprise 中提供了 Kubernetes 的集成支持，使得 Kubernetes 和 Docker 容器可以更加方便地部署和管理。同时，Docker 公司也开发了一些工具，如 Kompose 和 Docker Compose，使得用户可以将 Docker Compose 配置文件转换为 Kubernetes YAML 文件，以便更加方便地将应用程序从 Docker Swarm 迁移到 Kubernetes。\n\n## Kubernetes 不再支持 Docker 运行时 {#kubernetes-not-support-docker}\n\nKubernetes 从 v1.20 起不再支持 Docker 运行时并在 2022 年 4 月发布的 v1.24 中被完全移除，如下图所示。这意味着在 Kubernetes 中只能使用 containerd 或 CRI-O 容器运行时，不过你依然可以使用 Docker 镜像，只是无需使用 docker 命令或 Docker 守护程序。\n\n![Kubernetes v1.24 正式移除 Docker 运行时](cri.svg)\n\nKubernetes v1.24 正式移除 Docker 运行时\n\n## 腾退开源组织账号 {#deprecate-open-source-organization}\n\n2023 年 3 月，据 [Alex Ellis 的博客](https:\/\/blog.alexellis.io\/docker-is-deleting-open-source-images\/) 介绍，Docker 公司决定删除一些开源组织的账户和镜像，除非他们升级到付费的团队计划，这对开源社区造成了很大的困扰和不安。很多 Docker 忠实拥护者和贡献者对 Docker 的这一举动表示了不满和失望。\n\n这一事件是这样的：\n\n- Docker 公司给所有创建过组织的 Docker Hub 用户发了一封邮件，告知他们如果不升级到付费的团队计划，他们的账户和镜像都将被删除。\n- 这一举动只影响开源社区经常使用的组织账户，个人账户没有变化。\n- 付费的团队计划每年需要 420 美元，很多开源项目没有足够的资金支持。\n- Docker 公司的开源项目计划（DSOS）要求非常苛刻，与开源项目的可持续性相悖。\n- Docker 公司的沟通方式非常脱节，引起了开源社区的反感和担忧。\n- 文章作者建议开源项目使用其他的容器镜像仓库，如 GitHub Container Registry、[Quay.io](http:\/\/quay.io\/)、各大云厂商的镜像仓库等。\n- 开源社区还提供了一些迁移镜像和重命名镜像的方法和工具。\n\n## 增加对 WebAssembly 运行时的支持 {#support-webassembly-runtime}\n\n2022 年 10 月，Docker 公司发布了 Docker\u002bWasm 技术预览，这是一个特殊的构建，可以让开发者更容易地使用 Docker 运行 Wasm 工作负载。作为这次发布的一部分，Docker 还宣布将加入 Bytecode Alliance 作为一个投票成员。\n\nWasm 是一种新技术，可让你在沙箱环境中运行 40 多种语言的应用程序代码，包括 Rust，C，C\u002b\u002b，JavaScript 和 Golang。最初，Wasm 的用例是在浏览器中运行本地代码，如 Figma，AutoCAD 和 Photoshop 等。现在，一些公司如 Vercel，Fastly，Shopify 和 Cloudflare 等支持使用 Wasm 在边缘和云端运行代码。\n\nDocker\u002bWasm 技术预览包括：\n\n- Docker 的目标是帮助开发者通过克服应用开发的复杂性来实现他们的想法。\n- Docker 将 Wasm 视为与 Linux 容器相辅相成的技术，开发者可以根据用例选择使用哪种技术（或两者都用）。\n- Docker 想要帮助开发者更容易地使用熟悉的经验和工具来开发，构建和运行 Wasm 应用。\n- 要获取技术预览，需要下载并安装适合你系统的版本，然后启用 containerd 镜像存储（设置 \u003e 开发中的功能 \u003e 使用 containerd 拉取和存储镜像）。\n- 这个预览支持使用 WasmEdge 运行时引擎运行 Wasm 容器，并可以通过容器仓库如 DockerHub 等分享。\n\n2023 年 3 月 Docker 公司又发布了 Docker\u002bWasm 技术预览 2，包括了三个新的 Wasm 运行时引擎：Fermyon 的 spin，Deislabs 的 slight，和 Bytecode Alliance 的 wasmtime。\n\n该版本的主要更新是：\n\n- Docker\u002bWasm 技术预览 2 是在 Docker Desktop 4.15 版本中发布的，旨在让开发者更容易地运行 Wasm 工作负载，并扩展运行时支持。\n- Docker\u002bWasm 技术预览 2 支持四种 Wasm 运行时引擎，包括之前已经支持的 WasmEdge，以及新增加的 spin，slight，和 wasmtime。\n- 这四种 Wasm 运行时引擎都基于 runwasi 库，这是一个 Rust 库，可以让容器管理器 containerd 运行 Wasm 工作负载，并创建一种新的容器类型。\n- runwasi 库基于 WASI 标准，这是一个为 WebAssembly 提供通用平台接口的模块化系统接口。这意味着如果一个程序编译成目标是 WASI，它就可以在任何符合 WASI 的运行时上运行。\n- Wasm 容器通常只包含一个编译好的 Wasm 字节码文件，不需要任何额外的二进制库，这使得它比 Linux 容器更小。这也意味着 Wasm 容器通常启动更快，更可移植。\n- 由于 Wasm 容器直接被 containerd 支持，在 Docker Desktop 最新版本中尝试 Docker\u002bWasm 技术预览 2 只需要启用“使用 containerd”选项。\n- 通过这种方式，Wasm 容器可以与 Linux 容器一起使用 Docker Compose 或其他编排平台如 Kubernetes 运行。\n- 此外，Docker Desktop 还能够将一个 Wasm 应用打包成一个 OCI 容器，并在其中嵌入一个 Wasm 运行时，以便通过容器仓库如 DockerHub 等分享。\n\n## 总结 {#summary}\n\n本文介绍了 Docker 发展过程中的四个重大举措：Moby Project、支持 Kubernetes、删除开源组织账号和增加对 WebAssembly 运行时的支持。其中，Moby Project 旨在推动容器技术走向主流，支持 Kubernetes 的举措提供了更广泛的选择和更好的用户体验，删除开源组织账号的举措引起了开源社区的不满和失望，增加对 WebAssembly 运行时的支持的举措则扩展了 Docker 的应用场景。\n\n## 参考 {#reference}\n\n- [Introducing Moby Project: a new open-source project to advance the software containerization movement](https:\/\/www.docker.com\/blog\/introducing-the-moby-project\/)\n- [Docker for Windows Desktop… Now With Kubernetes!](https:\/\/www.docker.com\/blog\/docker-windows-desktop-now-kubernetes\/)\n- [Introducing the Docker\u002bWasm Technical Preview](https:\/\/www.docker.com\/blog\/docker-wasm-technical-preview\/)\n- [Announcing Docker\u002bWasm Technical Preview 2](https:\/\/www.docker.com\/blog\/announcing-dockerwasm-technical-preview-2\/)\n- [Docker is deleting Open Source organisations - what you need to know](https:\/\/blog.alexellis.io\/docker-is-deleting-open-source-images\/)\n- [别慌：Kubernetes 和 Docker](https:\/\/kubernetes.io\/zh-cn\/blog\/2020\/12\/02\/dont-panic-kubernetes-and-docker\/)\n', '\/blog\/docker-four-milestones\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-top-6-zero-trust-principles-for-kubernetes-security/">[译] Kubernetes 安全的 6 大零信任原则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/top-3-mtls-best-practices-for-zero-trust-kubernetes-security/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 安全的 6 大零信任原则', '本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。', '\n传统的网络安全依赖于围绕可信内部网络的强大防御边界，以将不良行为者拒之门外，将敏感数据拒之门外。在日益复杂的网络环境中，维护强大的边界越来越困难。\n\n零信任安全正在成为企业保护其传统和现代云原生应用程序的首选方法。零信任网络架构颠覆了边界安全的假设。在零信任网络中，每个资源都在内部受到保护，就好像它暴露在开放的互联网中一样。\n\n为了为行业和美国联邦政府建立零信任安全指南，美国国家标准与技术研究院 (NIST) 在一系列出版物中建立了零信任安全指南，从 SP 800-207 开始，介绍一般的零信任架构及其配套[SP 800-204 微服务安全标准系列](https:\/\/tetr8.io\/3zi85IC)。\n\n以下是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。\n\n## 零信任网络的六项原则\n\n1. **无论网络位置如何，所有通信都应该是安全的**。网络位置和可达性并不意味着信任。企业拥有或其他专用网络内部的访问请求必须满足与来自任何其他位置的通信相同的安全要求。零信任系统的一个标准是，您可以将它暴露在开放的互联网上，并且它仍然是安全的，没有未经授权的系统、数据或通信访问。\n2. **所有通信都应加密**。线路上的加密可防止窃听，并确保消息真实且未被篡改。这意味着至少为所有通信实施 TLS，将[mTLS 和相关的安全工作负载身份作为服务间通信的最佳实践](https:\/\/tetr8.io\/3Na982k)。\n3. **对每个资源的访问都应该根据动态策略进行身份验证和授权**。在允许任何访问之前，对服务身份和最终用户凭据进行动态身份验证和授权。访问请求的动态上下文应该是访问决策的一部分。这可能包括行为属性，如与观察到的使用模式的偏差或请求资产的状态，如安装的软件版本、网络位置和请求的时间 \/ 日期。授予访问权限时，应以所需的最低权限授予它。\n4. **对资源的访问应该在空间上有界**。围绕资源的信任范围应尽可能小 —— 理想情况下为零。访问应该由每个能够检索和执行访问决策的资源前面的策略执行点 (PEP) 进行调解。这应该适用于所有入站、出站和服务到服务的访问。\n5. **应及时限制对资源的访问**。身份验证和授权绑定到一个短暂的会话，之后它们必须重新建立。这可确保频繁做出访问决策，并使用最新的可用上下文。\n6. **对资源的访问应该是可观察的**。应收集并使用尽可能多的信息来改善安全态势。这允许持续监控所有资产的完整性和安全状况，并持续确保策略执行。此外，应反馈从观察中获得的见解以改进政策。\n\n## 为什么零信任安全性更好\n\n- **网络可达性不是授权**。与边界安全性不同，对服务的访问不会仅仅因为该服务可访问而被授予。它也必须经过明确的身份验证和授权。\n- **周边突破口的有限爆炸半径可防止攻击者横向移动**。经过身份验证和授权的工作负载免受边界破坏。及时限制凭证泄露的风险。\n- **细粒度策略**。空间边界允许高粒度的策略执行。\n- **频繁的政策评估**。通过在短期会话上执行动态策略来及时绑定可确保授权基于最新的策略。\n- **安全、真实的通信**。加密和强大的工作负载身份限制了侦察并提供了通信的真实性。\n- **安全状况和合规性的实时和可审计保证**。细粒度的可观测性允许实时保证和政策实施的事后审计以及故障排除和分析所需的数据。\n\n## 如何使用 Istio 在 Kubernetes 中实现零信任安全：现代微服务应用程序的参考架构\n\n作为 NIST 的一般零信任架构标准的补充，NIST 还发布了如何将零信任原则专门应用于微服务应用程序的标准。这些标准由 Tetrate 创始工程师 Zack Butcher 共同编写，并编入[NIST 的 SP 800-204 系列](https:\/\/tetr8.io\/3zi85IC)。\n\n在该标准中，NIST 建立了一个由 Kubernetes 组成的参考平台，用于编排和资源管理，并使用 Istio 服务网格提供核心安全功能。\n\n## Kubernetes 安全漏洞\n\n由于 Kubernetes 主要专注于编排、资源管理和基本连接，因此它将零信任网络安全问题留给其他方解决。Kubernetes 中的主要网络安全漏洞是（NIST SP 800-204B，§2.1.1）：\n\n- 默认情况下不安全的通信\n- 缺少在 pod 之间强制执行 TLS 所需的内置证书管理机制\n- 缺乏身份和访问管理机制\n- 在 OSI L3 而非 L7 运行的防火墙策略，因此无法窥视数据包或做出元数据驱动的决策\n\n## 服务网格填补了 Kubernetes 的安全漏洞：微服务应用程序的安全内核\n\n为了增强 Kubernetes 的安全性，Istio 充当 NIST 参考架构中的安全内核。Istio 满足参考监视器的三个要求（NIST SP 800-204B，§5.1）。Istio 是：\n\n- 不可旁路\n- 防止修改\n- 验证和测试是正确的\n\nEnvoy 数据平面通过每个服务前面以及每个入口和出口网关的不可绕过的策略执行点 (PEP) 提供参考监视器。服务网格代码独立于应用程序，因此它的生命周期可以独立管理，并且不能在运行时修改。而且，网格是系统的一个严格控制的元素，可以通过更多的眼睛和更仔细的检查来强化（NIST SP 800-204B，§5.1）。\n\n而且，作为专用的基础架构层，Istio 提供：\n\n- 解决**横切应用程序问题的**统一方法；\n- **快速解决这些问题的标准插件**和构建自定义插件的框架；\n- **简化**操作复杂性；\n- **易于管理**第三方开发人员和集成商；\n- **降低**开发和运营成本。\n\n## 下一步\n\n\u003e 要从联邦安全标准的合著者那里了解有关**如何实施零信任架构的更多信息，**[请阅读 Zack Butcher 的零信任架构白皮书](https:\/\/tetr8.io\/zta-wp)。\n\u003e\n\u003e 有关 NIST 安全建议的深入指南以及 Tetrate 如何帮助您实施该标准，请查看[Tetrate 的微服务联邦安全要求指南](https:\/\/tetr8.io\/3Ccg6Qt)。\n\n如果您正在寻找使用 Istio 投入生产的最快方式，请查看我们的开源[Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/)。TID 是经过审查的 Istio 上游发行版 ——Istio 的强化映像，具有持续支持，更易于安装、管理和升级。对于在联邦监管环境中运营的组织，Tetrate Istio Distro 是唯一[具有可用 FIPS 验证构建](https:\/\/istio.tetratelabs.io\/fips-request\/)的 Istio 发行版。\n\n如果您需要一种统一且一致的方式来保护和管理一系列应用程序中的服务，请查看 [Tetrate Service Bridge (TSB)](https:\/\/tetrate.io\/tetrate-service-bridge\/)，这是我们基于 Istio 和 Envoy 构建的全面的边缘到工作负载应用程序连接平台。\n', '\/trans\/the-top-6-zero-trust-principles-for-kubernetes-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/top-3-mtls-best-practices-for-zero-trust-kubernetes-security/">[译] 零信任 Kubernetes 安全的三大 mTLS 最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('零信任 Kubernetes 安全的三大 mTLS 最佳实践', '我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。', '\n[Kubernetes](https:\/\/kubernetes.io\/) 是编排现代云原生工作负载的事实标准。但是，它不提供开箱即用的安全通信。这意味着每个需要实施传输中加密以对其 Kubernetes 部署[采用零信任安全态势的](https:\/\/tetr8.io\/3FCXsDn)人都需要自己解决这个问题。\n\n幸运的是，有很多易于理解的方法可以实现，在本文中，我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。\n\n## 什么是 mTLS，为什么对安全来说很重要？\n\n传输层安全性（SSL 的后继者）是部署最广泛的安全通信标准，在 HTTPS 中最为明显。TLS 非常适合在需要向客户端证明其身份的服务器之间建立既保密（防窃听）又真实（防篡改）的安全通信。但是，在双方都需要向对方证明身份的情况下（例如在 Kubernetes 应用程序中的微服务之间），TLS 是不够的。\n\n这就是双向 TLS (mTLS) 的用武之地。mTLS 是 TLS，但双方在建立安全通信通道之前向对方证明自己的身份。这是 Kubernetes 中安全通信所需的必要部分。mTLS 提供：\n\n- 在线加密以确保机密性和防篡改\n- 相互的、加密的安全身份证明以确保真实性\n\n要深入了解 mTLS 的工作原理，请参阅我们关于 [mTLS 的文章](https:\/\/tetr8.io\/3NEcL0Q)。\n\n## mTLS 的困难部分：证明身份\n\n困难的部分是为服务建立一个安全机制来向彼此证明它们的身份。\n\n对于常规 TLS，过去很难管理向其客户端证明服务器身份的证书。[随着 Let\u0027s Encrypt](https:\/\/letsencrypt.org\/) 和 [ACME 协议](https:\/\/en.wikipedia.org\/wiki\/Automatic_Certificate_Management_Environment)的出现，这变得容易多了。然而，在像 Kubernetes 这样的动态（并且主要是私有的）环境中管理服务身份和证书更加困难，因为有许多通常是短暂的服务需要强大的、可证明的身份，但实际上不能使用公共 ACME 服务。\n\n推出自己的自动化证书管理系统是不切实际且有风险的。正确管理 mTLS 证书很困难，错误的后果很严重。您需要一种可信赖的、经过验证的方法来做到这一点；这就是服务网格的用武之地。\n\n## 使用服务网格，NIST 微服务安全标准\n\n在[微服务安全标准](https:\/\/tetr8.io\/3zi85IC)中，美国国家标准与技术研究院 (NIST) 建议使用服务网格作为专用基础设施层来提供核心网络安全功能。这些核心功能之一是支持 mTLS 的强大服务身份和证书管理。而且，Istio——[使用最广泛的服务网格](https:\/\/tetr8.io\/3UsARgY)—— 为您提供开箱即用的 mTLS 支持。Istio 透明地提供基础设施 —— 包括安全命名、强大的服务身份和证书管理 —— 用于 Kubernetes 工作负载之间的安全通信以及与外界的连接。\n\n如果您想详细了解 NIST 的微服务安全标准以及 Tetrate 如何帮助满足这些标准，请查看 [Tetrate 的微服务联邦安全要求指南](https:\/\/tetr8.io\/3Ccg6Qt)。\n\n## 最佳实践一：不要使用自签名证书\n\n虽然 Istio 将为您实施 mTLS，但它默认使用自签名证书，因此您可以立即看到网格工作，只需最少的配置。这使得初始用户体验变得简单，但它并非不适合生产环境。NIST 的指南（NIST SP 800-204A，SM-DR12）是完全禁用生成自签名证书的能力。\n\n## 最佳实践二：将 Istio 的信任根植于现有 PKI\n\n如果不应该使用 Istio 的默认自签名证书，还有什么选择？简短的回答是，您应该 [将 Istio 的信任根植于您现有的公钥基础设施 (PKI) 中](https:\/\/tetr8.io\/3DDcAOJ)。这将通过确保它们都具有相同的信任根来实现跨其他集群中的 Istio 部署的通信。观看我们关于 [使用 Istio 的外部 CA 的视频，了解更多信息](https:\/\/www.youtube.com\/watch?v=4b3H7isIAnQ)。\n\n## 最佳实践三：使用中间证书\n\n确切地说，您如何让 Istio 信任您现有的 PKI？Tetrate 的创始工程师和 NIST 微服务安全标准的合著者 Zack Butcher [在此处提供了所有详细信息](https:\/\/tetr8.io\/3DDcAOJ)。但是，简而言之，我们的建议是使用您组织的根证书颁发机构颁发的中间证书。这将：\n\n- 允许细粒度的证书撤销，而无需同时在整个基础架构中强制使用新证书。\n- 启用签名证书的轻松轮换。\n\n有关如何自动化 Istio 证书颁发机构 (CA) 轮换的分步说明，请参阅我们关于 [在大规模生产中自动化 Istio CA 轮换的](https:\/\/tetrate.io\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)文章。\n\n## 下一步\n\n如果您不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供一系列免费在线课程，可以让您快速了解 Istio 和 Envoy。\n\n如果您正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为您知道您有一个值得信赖的发行版，有一个支持您的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，您可能需要更简单的方法来管理和保护您的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。您可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n\n## 更多资源\n\n观看我们的视频：\n\n- [使用 Istio 的外部 CA](https:\/\/www.youtube.com\/watch?v=4b3H7isIAnQ)\n- [Istio Ingress Gateway 中的 SSL 证书](https:\/\/www.youtube.com\/watch?v=nYJJ57WCkxE)\n- [如何将服务网格用于混合云和遗留工作负载](https:\/\/www.youtube.com\/watch?v=o8AnLk4Da7M)\n- [如何将 VM 工作负载连接到网格](https:\/\/www.youtube.com\/watch?v=mHR7rR83KjM)\n- [Tetrate 如何帮助美国国防部将 Istio 用于零信任架构](https:\/\/www.youtube.com\/watch?v=E_D4bjvX8Xw\u0026t=2s)\n', '\/trans\/top-3-mtls-best-practices-for-zero-trust-kubernetes-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/kubernetes/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/tags/kubernetes/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/tags/kubernetes/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/tags/kubernetes/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/tags/kubernetes/page/3/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/tags/kubernetes/page/5/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(74)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/shanxi-trip/">地上文物看山西：宝藏文物大省不该被埋没</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/multi-cluster-pki-istio-recipe/">多集群 PKI 与 Istio 实践：为服务网格构建可信且可扩展的 PKI</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-tracing/">Envoy 代理如何处理用户请求以实现追踪</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
