<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu">
                
                <a class="dropdown-item" href="/book">书籍</a>
                
                <a class="dropdown-item" href="/slide">幻灯片</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/03/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益', '本文将带大家了解 Ambient Mode 的出现背景、核心组件、流量路径机制以及与现有 Sidecar 模式的对比，从而帮助你快速评估并上手这项新特性。', '\n欢迎阅读我的这篇博客——“超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益”。本文内容源自我在 KCD 北京的一次演讲。主要探讨的是 Istio 全新推出的一种数据面模式 —— **Ambient Mode**。它的核心理念是去除 Sidecar，减少资源开销与运维复杂度。本文将带大家了解 Ambient Mode 的出现背景、核心组件、流量路径机制以及与现有 Sidecar 模式的对比，从而帮助你快速评估并上手这项新特性。\n\n[点击查看幻灯片](\/slide\/beyond-sidecar\/)。\n\n## 为什么关注 Ambient Mode？\n\n首先，我们来思考一个问题：为什么要关注、甚至尝试这种新模式？Sidecar 在服务网格里一直都用得好好的，为什么要“去 Sidecar”呢？\n\n让我们看看当前服务网格面临的一些问题和挑战。\n\n### 服务网格的挑战\n\n- Sidecar 代理带来的 **资源开销** 和 **运维复杂度**  \n- **升级** 或 **重启** Envoy 时，常常需要连带重启所有 Pod  \n- 越来越多对 **高性能、低成本** 的需求\n\n\u003e **思考**：有没有一种方式在保留服务网格核心能力（安全、可观测、流量控制）的同时，减少对每个 Pod 的侵入和额外资源消耗？\n\n### 服务网格的几种部署模式\n\n![代理的位置](proxy-location.svg)\n\n服务网格架构一直在探索代理部署位置的多种可能性。例如：\n\n- **Sidecar**：每个 Pod 内跑一个 Envoy。\n- **Ambient**：将代理从 Pod 中剥离到节点级（即本篇要谈的模式）。\n- **Cilium Mesh**：利用 eBPF 在内核空间做 L4，然后结合 Envoy 提供 L7 功能。\n- **gRPC**：直接将网格能力集成到 SDK 中。\n\n这些模式在功能、安全、性能和管理复杂度上都有不同的侧重。**Istio Ambient Mode** 则是针对 Sidecar 带来的高资源消耗和运维成本，而提出的新尝试。\n\n### Ambient Mode 的诞生\n\n- Istio 的新一代架构，**移除 Sidecar**，通过 **ztunnel \u002b Waypoint Proxy** 实现数据面的轻量化。\n- 节省资源、降低运维复杂度。\n- 依然支持 **mTLS、策略管控**，并为需要 L7 功能的流量提供可选的 **Waypoint Proxy**。\n\n![部署模式象限](istio-data-plane-deployment-modes.svg)\n\n以下表格是对比常见服务网格部署模式的一些简要特点：\n\n| **模式**         | **安全性**                          | **效率**         | **可管理性**             | **性能**                       |\n| ---------------- | ----------------------------------- | ---------------- | ------------------------ | ------------------------------ |\n| **Sidecar 模式** | 高安全性，隔离的代理                | 资源使用率高     | 集中化管理但较为复杂     | 增加一定延迟                   |\n| **Ambient 模式** | 通过 ztunnel 提供安全性，仍在发展中 | 更高效，共享代理 | 管理更简单但功能在完善中 | 良好；跨可用区时需注意网络开销 |\n| **Cilium mesh**  | 中等安全性，基于 eBPF               | 内核级效率       | 配置复杂                 | 可视场景不同而异               |\n| **gRPC**         | 应用集成安全，依赖应用自身          | 高效             | 更新管理复杂             | 低延迟，适用于实时场景         |\n\n## Istio Ambient Mode 核心概念\n\n接下来我们正式进入第二部分，深入看看 Ambient Mode 的具体组件，包括 ztunnel、Waypoint Proxy 以及 Istio CNI 在其中扮演的角色。\n\n### Ambient Mode 的核心组件\n\n1. **ztunnel (L4)**  \n   - 以 Node 级代理的方式运行  \n   - 负责 **透明流量拦截**、**mTLS** 加密  \n   - 适用于大部分只需 L4 转发的流量  \n2. **Waypoint Proxy (L7)**  \n   - 可选部署（根据命名空间 \/ Service \/ Pod 粒度灵活配置）  \n   - 处理 **HTTP \/ gRPC** 等高级功能（鉴权、路由、可观测等）  \n3. **Istio CNI**  \n   - 取代 \u0060istio-init\u0060 容器，负责流量劫持  \n   - 兼容 Sidecar 模式和 Ambient 模式  \n   - 允许在非特权模式下为 Pod 设置流量重定向\n\n### Ambient 模式整体架构\n\n![Istio Ambient 模式架构](istio-ambient-layers.svg)\n\n在 Ambient 模式下，Istio 数据面可分为两层：\n\n1. **安全层 (ztunnel)**：每个节点部署一个轻量级 L4 代理。  \n2. **可选的 L7 层 (Waypoint Proxy)**：需要 HTTP\/gRPC 代理时才部署。\n\nControl Plane 依然由 Istiod 提供，主要负责给 ztunnel、Waypoint 下发配置和证书。\n\n### Waypoint Proxy 部署策略\n\n- **Namespace 级**（默认）：适用于该命名空间下所有 Workload\n- **Service 级**：仅特定关键服务需要 L7\n- **Pod 级**：更精细化控制\n- **跨 Namespace**：可以使用 Gateway 资源共享\n\n### Istio CNI\n\n- **流量拦截**：取代 \u0060istio-init\u0060 容器，使安装更加清晰简洁。\n- **支持两种模式**：兼容 **Sidecar 模式** 和 **Ambient 模式**。\n- **非特权模式兼容性**：允许 Pod 运行在无特权模式下，增强安全性。\n- **CNI 链接（Chaining）**：通过添加 Istio CNI 扩展节点的 CNI 配置。\n- **Pod 内部流量重定向（Ambient 模式）**：\n  - 在 Pod 的网络命名空间内使用 \u0060iptables REDIRECT\u0060 规则。\n  - 创建 Pod 内部的 socket 以拦截和代理流量。\n\n这张图简单示意了 Istio CNI 如何与 Kubernetes 本身的网络插件（如 Calico、Cilium 等）组合在一起。它修改了本机的 CNI 配置，增加了 CNI 链，在 Kubernetes 分配完 Pod IP 后，紧接着就会执行 Istio CNI 的拦截逻辑，把网络流量规则注入到 Pod netns。并且为不同模式中 Pod 配置不同的 iptables 规则。\n这样就与原本的 CNI 配置（包括网络策略）形成一个链式流程，不会相互冲突。\n\n![Istio CNI 插件的运行步骤](istio-cni.svg)\n\n### Istio CNI 插件工作原理\n\n这张图详细描绘了当 Pod 启动时，Istio CNI 会怎么做：\n\n![Istio CNI 插件工作原理](istio-cni-diagram.svg)\n\n1. 它会进入 Pod 的网络命名空间，创建一套 iptables 规则，把流量劫持到 ztunnel 监听的 socket 上。\n2. 不再需要在每个 Pod 里注入 init 容器，也不需要特权权限，这就让整体部署更干净、也更安全。\n3. ztunnel会在pod的网络命名空间中建立一个socket，并且为节点上的每个pod都会建立一个。\n\n## 流量路径与关键机制\n\n介绍完组件之后，我们来看看最核心的“流量路径”。zTunnel 和 Waypoint 究竟是怎么拦截并转发流量的？我们会从透明流量拦截、HBONE 协议等角度进行解析。\n\n### 透明流量拦截\n\n在 Ambient 模式中，**Istio CNI** 会在 Pod 网络命名空间中注入 iptables 规则，将出站流量透明拦截到所在节点的 **ztunnel** 进程。之后由 ztunnel 决定是直接进行 L4 转发，还是将流量转发至 **Waypoint Proxy** 做进一步的 L7 处理。\n\n如图所示，Kubelet 在节点上启动了一个 Pod，这个事件被 Istio CNI Agent 监听到，Istio CNI Agent 进入 Pod 的网络空间，设置 iptables 规则将流量重定向到本地 socket，并将 Pod 的文件描述符（FD）发送为 ztunnel。ztunnel 获取到 FD 之后就可以在 Pod 的网络空间中创建 socket。\n\nPod 在发送流量时，本该直连目标地址，但是 iptables 规则会把它拦截到本节点的 ztunnel 进程里，然后 ztunnel 决定这条流量需不需要交给 Waypoint 做 L7 代理。\n如果不需要，就直接在 L4 层把它加密转发到目标 Pod；如果要 L7，例如鉴权，就再把流量隧道给 Waypoint。\n\n![透明流量拦截](transparent-traffic-interception.svg)\n\n### 数据包生命周期概览\n\n1. **Pod → ztunnel**：Pod 的流量先被 CNI 拦截到本节点 ztunnel。  \n2. **ztunnel**：解析目标地址并进行 mTLS 加密。  \n3. **（如需要 L7 策略）ztunnel → Waypoint Proxy**：HTTP 鉴权、路由等操作。  \n4. **Waypoint Proxy**：完成 L7 处理后，再发回 ztunnel。  \n5. **ztunnel**：解封装或继续转发至目标节点 ztunnel。  \n6. **到达目标 Pod**：目标节点 ztunnel 最终将流量交给目标 Pod。\n\n### HBONE 协议\n\nAmbient 模式中，zTunnel 与 Waypoint 之间使用 **HBONE (HTTP\/2 \u002b CONNECT)** 协议来建立安全隧道，实现 **mTLS 加密** 和多路复用，减少额外的连接开销，简化代理转发流程。\n\n![HBONE 协议](hbone-packet.svg)\n\n下面是一个简化的 HBONE CONNECT 请求示例，利用 \u0060x-envoy-original-dst-host\u0060、\u0060x-istio-auth-userinfo\u0060 等头信息来传递路由和身份认证所需上下文。\n\n\u0060\u0060\u0060text\n:method: CONNECT\n:scheme: https\n:authority: Pod_B_IP:9080\n:path: \/api\/v1\/users?id=123\nx-envoy-original-dst-host: Pod_B_IP:9080\nx-forwarded-proto: hbone\nx-istio-attributes: ...\n...\n\u0060\u0060\u0060\n\n在这个示例里，假设 ztunnel A 需要把流量发送给 目标节点 B，我们可以看到外层的 TCP 连接其实是从 ztunnel_A_IP:52368 连到 Node_B_IP:15008。这是 ztunnel A 和 ztunnel B 之间的隧道端口，15008 就是 HBONE 监听端口。\n\n进入到 HTTP\/2 层后，就会有一个 CONNECT 请求，里面的 \u0060:authority\u0060 显示的是 Pod_B_IP:9080，表示实际上要连到 Pod B 的 9080 端口。\u0060x-envoy-original-dst-host\u0060 里也能看出相同信息。\n\n同时我们看到了一些自定义头，比如 \u0060x-forwarded-proto\u0060、x-istio-attributes 等，用来给目标 ztunnel 或后续代理带去更多上下文和安全验证信息。\n\n可以把这个理解为：在 HTTP\/2 CONNECT 之上，流量就像加了一个“内层”隧道，把应用层的请求（例如 \u0060\/api\/v1\/users?id=123\u0060）封装在这里面，然后在 ztunnel B 端解封装并转发到真实的 Pod B。\n\n整个过程对应用来说是透明的，但对我们来说，通过查看这种 CONNECT 请求头，可以了解 Ambient 模式如何在 HTTP\/2 层做流量路由和身份认证。这就是为什么说 HBONE 比传统的 Sidecar-to-Sidecar通信更加灵活，也更便于做 mTLS 以及 L7 扩展。\n\n### 同节点上的加密流量\n\n如果源 Pod 和目标 Pod 恰好在同一个节点上，流量会走 ztunnel 的 L4 加密流程。\n这里显示，ztunnel 是使用 DaemonSet 部署在每个节点上的，并且使用了host Network，共享主机的网络。Istio CNI 将 Pod 的出站流量拦截到 ztunnel的15001端口，如果源和目的 pod 在同一个节点上，ztunnel 直接在内部完成加解密后将流量发送到目的地 pod。\n\n如果需要 L7 的流量处理，比如鉴权，ztunnel 就会与 Waypoint 代理建立 HBONE 隧道，经过 Waypoint 代理的转发到目的 Pod。\n\n![同节点上的加密流量](ambient-traffic-on-the-same-node.svg)\n\n### 跨节点的加密流量（L4）\n\n这是跨节点的情况，也就是最常见的场景：\n\n源节点的 ztunnel 把流量通过 HBONE 隧道加密后发给目标节点的 ztunnel；目标节点 ztunnel 解封装，再把明文流量递给目标 Pod。只要是纯 L4 无需 L7，就不必加一层 Waypoint，减少了代理链路。\n\n![跨节点的加密流量（L4）](ambient-traffic-on-the-different-node-l4.svg)\n\n### 跨节点的加密流量（L7）\n\n当我们需要 L7 处理时，流量就会多经过一下 Waypoint。也就是：\n\n- 源 ztunnel 先把流量隧道给 Waypoint；\n- Waypoint 在 HTTP 层做鉴权、路由等；\n- Waypoint 再用 HBONE 把流量发给目标 ztunnel；\n- 目标 ztunnel 解封装后给目标 Pod。\n\n![跨节点的加密流量（L7）](ambient-traffic-on-the-different-node-l7.svg)\n\n这个流程比 L4 多了一次代理，但好处是只有特定流量才会被 L7 代理解析，减少不必要的开销。\n\n### 兜底流量（防止流量逃逸）\n\n对于非 Istio网格内部的流量，通过 Pod IP和端口直接访问 Pod时，为了防止这些流量逃出 ztunnel的掌控，也需要拦截这些流量。如果流量是访问的应用端口，通过判断数据包上是否带有 0x539 标记，如果没有，则将其转发到 ztunnel 监听的 15006 明文端口，经 ztunnel 处理后会带上 0x539 标记，然后就可以访问应用的目标端口了；如果流量的目的端口是 15008，那么实际上就会被 ztunnel 监听和处理，判断 HBONE 协议。\n\n![来自非mesh内部的流量](non-istio-mesh-pod-taffic-go-into-the-mesh.svg)\n\n### L4 与 L7 流量差异\n\n| 流量类型 | 处理位置                 | 示例场景                                         |\n| -------- | ------------------------ | ------------------------------------------------ |\n| **L4**   | ztunnel（透明转发）      | TCP 级别流量，不需应用层策略                     |\n| **L7**   | ztunnel → Waypoint Proxy | HTTP\/gRPC 需要鉴权、熔断、路由、可观测等高级功能 |\n\n对于大部分只需 TCP 层加密和转发的流量，Ambient Mode 仅通过 ztunnel 即可；只有在需要 HTTP 层策略时才会额外经过 Waypoint。\n\n## Ambient Mode vs. Sidecar Mode\n\n有了对 Ambient 的了解后，我们还是得和原有的 Sidecar 模式做对比，来看看哪些功能还不完善，哪些场景更适合 Ambient。\n\n### Ambient 模式的限制\n\n与传统 Sidecar 模式相比，Ambient 目前仍有一些不完善之处：\n\n- 在**混合使用** Sidecar 与 Ambient 时，难以对单个 Pod 做精准代理定制（例如 EnvoyFilter）。\n- **多集群**、**多网络**、以及 **虚拟机** 工作负载的支持还不够完善，生产环境使用需谨慎。\n- 一些深度定制（例如 WASM 插件）目前无法在 Ambient 下直接一对一实现。\n\n### 功能与差异对比\n\n| 指标             | **Sidecar 模式**                                          | **Ambient 模式**                                           |\n| ---------------- | --------------------------------------------------------- | ---------------------------------------------------------- |\n| **代理位置**     | 每个 Pod 都运行 Envoy Sidecar                             | Node 级 **ztunnel** \u002b 可选的 **Waypoint Proxy**            |\n| **资源开销**     | 在大规模场景下 CPU\/内存消耗相对更高                       | 相对更低：代理共享在节点\/命名空间级                        |\n| **运维复杂度**   | 升级 Sidecar 需滚动更新所有关联 Pod，操作较繁琐           | 部署\/升级集中在少数组件（ztunnel \/ Waypoint），运维更简单  |\n| **性能**         | 每个 Pod 都有 Envoy，使得隔离性更强，但整体有额外代理开销 | L4 性能较好，L7 场景需要多经过一次 Waypoint 转发           |\n| **功能完整度**   | 成熟稳定，支持多集群、VM、混合网络                        | 尚在演进，多网络、VM 等高级场景支持仍在完善                |\n| **典型使用场景** | 注重严格隔离或依赖特定的 EnvoyFilter、WASM 插件等深度定制 | 大规模集群、需要**轻量化**管理且大部分流量以 L4 为主的场景 |\n\n### 选择建议\n\n1. 若已有 **Sidecar** 架构且依赖大量成熟特性：可先继续使用 Sidecar。\n2. 追求 **资源节省**、**运维简化** 且大部分流量仅需 L4：可尝试 **Ambient Mode**。\n3. 如果部分应用仍需保留 Sidecar，可考虑 **混合部署**，但需额外规划 Sidecar \/ Ambient 的边界和策略。\n\n## 总结\n\n好的，最后我们来总结一下 Ambient Mode 的优缺点，以及当前适合哪些场景。\n\n### 核心要点回顾\n\n1. **Ambient Mode**：通过移除 Sidecar，降低每个 Pod 的代理负担，显著降低资源和运维成本。\n2. **ztunnel \u002b Waypoint** 架构：需要 L7 功能时才启用 Waypoint，其他流量以 L4 方式快速转发。\n3. 虽然官方已宣布 Ambient Mode GA，但对于 **多集群 \/ VM \/ 多网络** 等仍需进一步观察、测试。\n4. 适用场景：**大规模集群** \u002b **主要以 L4 流量为主**，对资源和管理要求高的团队可以重点关注。\n\n你也可以通过 [jimmysong.io](https:\/\/jimmysong.io) 网站找到更多云原生相关的文章和实践分享。如果对此文或 Istio 有任何疑问，欢迎给我留言或在社区中交流。谢谢！\n', '\/blog\/beyond-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将带大家了解 Ambient Mode 的出现背景、核心组件、流量路径机制以及与现有 Sidecar 模式的对比，从而帮助你快速评估并上手这项新特性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/02/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 安装方式深度剖析——选择与实践指南', '剖析 Istio 安装方式：推荐 istioctl，Helm 备选，废弃 Operator，解读 API 与实践。', '\n随着 Istio 版本迭代，其的安装方式和工具链也在不断演进。从 \u0060istioctl\u0060 到 Helm，再到曾经的 Istio Operator，用户常常会面临选择困境：到底哪种方式最适合我的场景？在最近的交流中，我经常遇到关于 Istio 安装方式选择的问题，特别是围绕 \u0060IstioOperator API\u0060 和已废弃的 Istio Operator 组件的区别。今天，我将以技术实践者的视角，带你梳理 Istio 的安装之道，拆解关键问题，并给出生产级建议。\n\n## Istio 安装方式一览\n\nIstio 提供了多种安装路径，每种方式都有其设计初衷和适用场景。以下是当前主流选项：\n\n- **\u0060istioctl\u0060**：官方推荐的安装工具，集验证、定制和运维于一体，几乎是生产环境的标配。\n- **Helm**：Kubernetes 生态的包管理利器，适合 Helm 重度用户或 CI\/CD 集成场景。\n- **Istio Operator（已废弃）**：曾经的集群内管理方案，如今已退出历史舞台。\n\n接下来，我们逐一剖析这些方式的核心特点，以及背后的取舍逻辑。\n\n## \u0060istioctl\u0060：生产环境的不二之选\n\n在 Istio 中，\u0060istioctl\u0060 被官方定位为首选安装工具。它的优势显而易见：\n\n- **强大的配置验证**：在安装前，\u0060istioctl\u0060 会对配置进行静态检查，避免潜在问题。比如，使用 \u0060istioctl analyze\u0060 可以快速定位配置文件中的错误。\n- **灵活的定制能力**：通过 \u0060IstioOperator\u0060 API，你可以精确控制安装细节，比如只启用 Pilot 或调整网关配置。\n- **生产就绪的特性**：从健康检查（\u0060istioctl verify-install\u0060）到增量升级，\u0060istioctl\u0060 提供了全生命周期支持。\n- **安全优先**：相较于集群内控制器，\u0060istioctl\u0060 在本地运行，避免了高权限组件带来的安全隐患。\n\n实践中的一个简单例子：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=default -y\n\u0060\u0060\u0060\n\n这会快速部署默认配置。如果需要更细粒度的控制，可以搭配 YAML 文件（后文详解）。\n\n**适用场景**：生产环境、新用户、需要高度定制的场景。\n\n## Helm：生态集成下的备选方案\n\nHelm 是 Kubernetes 生态的老朋友，Istio 也提供了官方 Helm chart。它的亮点在于：\n\n- **与 Helm 生态无缝对接**：如果你的集群已经在用 Helm 管理资源，Istio 的 Helm 安装可以直接融入现有工作流。\n- **自动化友好**：Helm chart 的版本化和声明式特性，非常适合 CI\/CD 管道。\n\n但 Helm 并非没有短板：\n\n- **验证能力不足**：相比 \u0060istioctl\u0060，Helm 的配置检查较弱，错误往往在运行时暴露。\n- **组件管理复杂**：比如安装 Egress Gateway，Helm chart 的支持不够完善，社区反馈中常有人提到需要额外调整（参考 [GitHub Issue #43826](https:\/\/github.com\/istio\/istio\/issues\/43826)）。\n\n**适用场景**：已有 Helm 工作流、CI\/CD 驱动的项目。\n\n## Istio Operator 的兴衰\n\n如果你接触过早期 Istio，可能会对 Istio Operator 有所耳闻。这是一个运行在集群内的控制器，负责根据配置管理 Istio 安装。然而，从 1.23 版本起，它已被官方废弃。原因何在？\n\n- **安全考量**：集群内高权限组件容易成为攻击目标，增加了运维风险。\n- **功能冗余**：社区调查显示，其使用率不足 10%，而 \u0060istioctl\u0060 已能完全覆盖其功能（参考 [GitHub Discussion #166](https:\/\/github.com\/istio\/enhancements\/issues\/166)）。\n\n现有用户可以继续运行旧版本，但无法升级到 1.24\u002b。对于新项目，我的建议是直接跳过这一选项。\n\n## 拨云见日：IstioOperator API vs. Istio Operator\n\n讨论中常出现的一个困惑是：\u0060IstioOperator API\u0060 和 Istio Operator 有什么区别？让我们一次性讲清楚：\n\n- **\u0060IstioOperator API\u0060**：一个声明式的配置接口，用于定义 Istio 安装的期望状态。它并未废弃，而是 \u0060istioctl\u0060 的核心依赖。\n- **Istio Operator**：已废弃的集群内控制器，过去负责解析 API 并执行安装。\n\n类比一下：API 是设计图纸，Operator 是施工队。现在，\u0060istioctl\u0060 取代了施工队，效率更高，风险更低。\n\n## 实战：如何使用 \u0060IstioOperator API\u0060？\n\n\u0060IstioOperator\u0060 API 是 Istio 安装的灵魂，允许你通过 YAML 文件灵活定制配置。以下是一个典型流程：\n\n1. **编写配置文件**：\n\n   假设我们要启用 Egress Gateway：\n\n   \u0060\u0060\u0060yaml\n   apiVersion: install.istio.io\/v1alpha1\n   kind: IstioOperator\n   spec:\n     profile: default\n     components:\n       egressGateways:\n         - name: istio-egressgateway\n           enabled: true\n   \u0060\u0060\u0060\n\n1. **部署配置**：\n\n   执行：\n\n   \u0060\u0060\u0060bash\n   istioctl install -f istio-config.yaml\n   \u0060\u0060\u0060\n\n   这种方式的好处在于声明式管理，修改后重新运行即可实现增量更新。比如，要调整资源限制，只需更新 YAML 并再次应用。\n\n## 组件更新与扩展\n\n安装完成后，如何添加或更新组件（如 Egress Gateway）？\u0060istioctl\u0060 的答案简单直接：\n\n- 编辑 YAML，添加新配置。\n- 运行：\n\n    \u0060\u0060\u0060bash\n    istioctl install -f updated-config.yaml\n    \u0060\u0060\u0060\n    \n    \u0060istioctl\u0060 会自动计算差异，完成增量部署。\n\nHelm 更新则稍显繁琐，可能涉及 chart 调整或手动干预，尤其在非常规组件上。\n\n## 总结与生产建议\n\n通过这次深入剖析，我们可以得出以下结论：\n\n- **\u0060istioctl\u0060 是王道**：它兼具安全性、灵活性和生产就绪特性，适合绝大多数场景。\n- **Helm 有其一席之地**：如果你深陷 Helm 生态，不妨一试，但要做好额外配置的准备。\n- **Istio Operator 已成历史**：新项目无需考虑，现有用户应规划迁移。\n\n作为一个在开源领域摸爬滚打的实践者，我建议从 \u0060istioctl\u0060 入手，结合 \u0060IstioOperator\u0060 API，既能快速上手，又能满足复杂需求。Istio 的安装看似复杂，但掌握核心逻辑后，你会发现它其实很有条理。\n\n有任何疑问，欢迎留言交流，一起解锁服务网格的更多玩法！\n\n## 参考资料\n\n- [Istio 官方安装指南](https:\/\/istio.io\/latest\/docs\/setup\/install\/)\n- [IstioOperator API 配置参考](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.operator.v1alpha1\/)\n- [GitHub Issue #43826](https:\/\/github.com\/istio\/istio\/issues\/43826)\n- [GitHub Discussion #166](https:\/\/github.com\/istio\/enhancements\/issues\/166)\n', '\/blog\/istio-installation-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">剖析 Istio 安装方式：推荐 istioctl，Helm 备选，废弃 Operator，解读 API 与实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/02/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式：图解及概念解读', '本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。', '\nIstio 的 Ambient 模式是一种创新的、无 Sidecar 的服务网格部署方式，通过 ztunnel 和 waypoint proxy 分离数据平面功能，简化了操作并降低了资源消耗。本篇博客将通过一份详细的术语表，帮助你更好地理解 Istio Ambient 模式中的关键概念及其背后的技术实现。\n\n## Ambient 模式\n\n![Ambient 模式架构图](ambient-mode-architecture.svg)\n\n  - **定义**：Istio 的一种无 Sidecar 的数据平面模式，通过 ztunnel 和 waypoint proxy 实现服务之间的安全通信和管理。相较于 Sidecar 模式，Ambient 模式更加轻量，降低了资源消耗并简化了配置。\n  - **架构**：数据平面功能分为 L4 层的安全覆盖层（由 ztunnel 提供）和 L7 层的策略处理层（由 waypoint proxy 提供）。\n\n## 控制平面与数据平面\n\n![控制平面与数据平面](control-plane-and-data-plane.svg)\n\n  - **定义**：在 Ambient 模式中，控制平面（\u0060istiod\u0060）负责管理集群内 ztunnel 和 waypoint proxy 的配置和策略，而数据平面由 ztunnel 和 waypoint proxy 组成，负责处理实际的网络流量。\n  - **组件交互**：ztunnel 使用 xDS APIs 从 \u0060istiod\u0060 获取配置并执行策略，管理 Pod 之间的 L4 和 L7 流量。\n\n## Istio Control Plane (\u0060istiod\u0060)\n\n  - **定义**：Istio 的控制平面组件，负责与 ztunnel 和 waypoint proxy 通信，提供 xDS 接口用于动态配置。\n  - **功能**：\u0060istiod\u0060 使用 xDS APIs 进行配置推送，动态管理 Ambient 模式中的流量策略、证书分发以及与 Kubernetes 集群的交互。\n\n## 透明性与非侵入性\n\n  - **定义**：Ambient 模式的架构旨在减少对应用的侵入性，应用无需感知数据平面的存在，Pod 无需重启或注入 Sidecar 即可加入网格。\n  - **优势**：提高了服务网格的灵活性，降低了操作复杂度，使应用和基础设施的生命周期更加解耦。\n\n## Sidecar Proxy\n\n![Sidecar 模式](sidecar-mode.svg)\n\n  - **定义**：传统 Istio 中的 Envoy 代理，与应用容器共同部署在一个 Pod 中。\n  - **问题**：对应用具有侵入性，Sidecar 必须在 Pod 中注入并伴随应用运行，增加了资源开销，并且使应用与代理的生命周期耦合。\n\n## Ztunnel (Zero-Trust Tunnel)\n\n![ztunnel](ztunnel.svg)\n\n  - **定义**：Ambient 模式中的关键组件，部署为 DaemonSet，为每个节点提供 L4 层的零信任隧道。\n  - **功能**:\n    - **安全**：提供 mTLS 加密和基于 SPIFFE ID 的身份验证，确保节点和工作负载之间的安全通信。\n    - **可观测性**：收集 L4 层的 TCP 指标和日志。\n    - **连接多路复用和均衡**：在节点之间建立安全的流量隧道，以优化连接和网络性能。\n    - **多租户架构**：单个 ztunnel 可以代表同一节点上的多个工作负载进行 L4 数据平面功能处理，这与每个应用 Pod 拥有自己代理的 Sidecar 模式形成对比。\n    - **证书管理**：ztunnel 代表节点内的所有 Pod 从 Istio 控制平面 (\u0060istiod\u0060) 获取 mTLS 证书，并负责证书的管理和轮换。\n  - **接口**:\n    - **\u0060pistioin\u0060 和 \u0060pistioout\u0060**：用于与节点上的 \u0060istioin\u0060 和 \u0060istioout\u0060 接口通过 GENEVE 隧道连接。\n\n## Waypoint Proxy\n\n![Waypoint Proxy](waypoint-proxy.svg)\n\n  - **定义**：Ambient 模式中的 L7 层代理，部署在每个命名空间级别，用于处理 L7 层请求。\n  - **功能**：提供 L7 授权策略，如基于 HTTP headers 的访问控制、L7 级别的遥测等。Waypoint Proxy 只处理需要的 L7 代理流量，其他 L4 流量由 ztunnel 处理。\n\n## GENEVE 隧道 (Generic Network Virtualization Encapsulation)\n\n![GENEVE 协议组成](geneve.svg)\n\n  - **定义**：用于在 Kubernetes 节点之间建立虚拟隧道连接，将流量从节点上的 Pod 转发到 ztunnel。\n  - **在 Ambient 模式中的应用**：GENEVE 隧道用于连接节点上的虚拟网络接口（\u0060istioin\u0060 和 \u0060istioout\u0060）与 ztunnel 内的接口（\u0060pistioin\u0060 和 \u0060pistioout\u0060）。\n\n## HBONE (HTTP-Based Overlay Network Environment)\n\n![HBONE 数据包格式](hbone.svg)\n\n\u003c!--\n\u0060\u0060\u0060\n\u002b-----------------\u002b\n|    IP Header    | \u003c-- 源 IP，目标 IP，协议类型\n\u002b-----------------\u002b\n|    TCP Header   | \u003c-- 源端口，目标端口，序列号，确认号，标志位等\n\u002b-----------------\u002b\n|    TLS Header   | \u003c-- 握手消息，证书，加密应用数据\n\u002b-----------------\u002b\n| HTTP\/2 \u0026 CONNECT| \u003c-- HTTP 方法，目标地址，请求头，路径等\n\u002b-----------------\u002b\n|  Application    | \u003c-- 应用层数据，字节流，例如 HTTP 请求\n\u002b-----------------\u002b\n\u0060\u0060\u0060\n--\u003e\n\n  - **定义**：Istio 特有的安全隧道协议，用于在 Ambient 模式组件之间传输数据。HBONE 是一种基于 HTTP\/2 和 HTTP CONNECT 建立的安全 mTLS 加密通道。\n  - **实现方式**：通过 HTTP\/2 进行多路复用，通过 HTTP CONNECT 建立隧道，并使用 mTLS 确保安全性。详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## Istioin 和 Istioout 虚拟接口\n\n![Ambient 模式中两个位于两个不同节点上的 Pod 访问路径](ambient-ztunnel-routing.svg)\n\n  - **定义**：由 Istio CNI 插件在每个节点上配置的两个虚拟接口，用于处理进入和离开节点的流量。\n  - **功能**：\u0060istioin\u0060 处理进入节点的流量，\u0060istioout\u0060 处理离开节点的流量。两者通过 GENEVE 隧道连接到 ztunnel 中相应的接口。\n\n## iptables 和流量重定向\n\n  - **定义**：用于配置 Linux 内核中的流量规则，将来自 Ambient 工作负载的流量进行重定向和标记。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件通过 iptables 规则，将流量标记并重定向到 \u0060istioin\u0060 或 \u0060istioout\u0060，然后通过 GENEVE 隧道传递给 ztunnel。\n\n## 流量拦截与重定向 (Traffic Redirection)\n\n  - **定义**：Ambient 模式中，ztunnel 负责透明拦截所有进出 \u0022in-mesh\u0022 Pod 的流量并将其加密后重定向到其他节点上的目标 Pod，确保网络流量符合服务网格的安全策略。\n  - **机制**：通过 Istio CNI 插件安装的 iptables 规则或 eBPF 程序，ztunnel 能够透明地捕获工作负载的流量，并在不改变客户端应用的情况下进行安全代理。\n\n## 流量路径分类\n\n  - **Out of Mesh**：Pod 没有加入服务网格，流量不会被 Ambient 数据平面处理。\n  - **In Mesh**：Pod 被纳入 Ambient 数据平面，L4 层的流量被 ztunnel 拦截和处理，提供 L4 授权和安全加密。\n  - **In Mesh, Waypoint Enabled**：Pod 被纳入 Ambient 数据平面且启用了 waypoint proxy，L7 层的流量通过 waypoint 进行高级策略处理。\n\n## TPROXY\n\n![TPROXY 作为透明代理，客户端和服务端都对其无感知](tproxy.svg)\n\n  - **定义**：Linux 内核功能，用于透明拦截和重定向网络流量。\n  - **在 Ambient 模式中的应用**：ztunnel 使用 TPROXY 来拦截和处理流量，保留原始源 IP 和端口信息，从而实现透明代理功能。\n\n## Mutual TLS (mTLS)\n\n![Istio 中的安全身份架构（以 Sidecar 模式为例）](istio-mtls-process.svg)\n\n  - **定义**：一种双向 TLS 认证机制，确保通信双方的身份验证和数据加密。\n  - **在 Ambient 模式中的应用**：通过 ztunnel 和 waypoint proxy 确保工作负载之间的 mTLS 加密，实现零信任安全。\n\n详见 [如何理解 Istio 中的 MTLS 流量加密？](\/blog\/understanding-the-tls-encryption-in-istio\/)\n\n## SPIFFE ID\n\n![SPIFFE ID 格式](spiffe.svg)\n\nIstio 服务网格中所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式：\u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n  - **定义**：用于标识工作负载的身份标识符，在服务网格中用于身份管理。\n  - **在 Ambient 模式中的应用**：SPIFFE ID 被用于对节点和工作负载进行身份验证，以确保网络通信的安全性。\n\n详见 [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n\n## eBPF (Extended Berkeley Packet Filter)\n\n  - **定义**：eBPF 是 Linux 内核中的一种技术，用于在内核空间中运行沙盒程序，实现网络数据包处理等功能。\n  - **在 Ambient 模式中的应用**：eBPF 可以替代传统的 iptables 和 GENEVE 隧道，用于流量重定向和管理。eBPF 更高效、复杂度更低且易于管理。\n  - **eBPF 程序**:\n    - 应用入站\n    - 应用出站\n    - Ztunnel 主机入站\n    - Ztunnel 入站\n  - **作用**：Istio CNI 使用 eBPF 程序将它们挂载在特定的 TC 点，用于处理应用和 ztunnel 的网络流量。\n\n## Waypoint Proxy 的弹性扩展\n\n![Waypoing Proxy 作为 Deployment 部署在 Kubernetes 中](ambient-waypoint-proxy-scale.svg)\n\n  - **定义**：在 Ambient 模式中，waypoint proxy 可以根据流量需求动态扩展，而无需为每个工作负载实例部署独立代理。\n  - **优势**：通过动态扩展 waypoint proxy，可以降低基础设施成本并提高资源利用率。\n\n## Ztunnel 的弹性和故障恢复\n\n  - **定义**：ztunnel 部署为 DaemonSet，如果 ztunnel 容器失效，Kubernetes 会自动重新调度，以确保节点流量的继续处理。\n  - **特点**：使得故障的影响范围最小化，仅影响该节点上的工作负载。\n\n## IP Set 和 ztunnel-pods-ips\n\n  - **定义**：IP Set 是用于存储 IP 地址的工具，\u0060ztunnel-pods-ips\u0060 是每个节点上用于存储 Ambient 网格 Pod IP 的集合。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件会将每个加入 Ambient 网格的 Pod IP 添加到 \u0060ztunnel-pods-ips\u0060 中，以确保这些 Pod 的流量可以被 iptables 规则识别和处理。\n\n## 连接多路复用 (Connection Multiplexing)\n\n  - **定义**：在单个物理连接中传输多条逻辑连接的技术。\n  - **在 Ambient 模式中的应用**：ztunnel 实现了连接多路复用，使多个工作负载可以共享相同的连接，提升网络效率。\n\n## 节点网络的虚拟接口对 (veth)\n\n  - 定义：每个 Pod 在运行时会在节点上创建一个虚拟接口对，用于将 Pod 的网络连接到节点的网络。\n  - 在 Ambient 模式中的应用：veth 接口用于将 Pod 的流量连接到节点的虚拟接口（如 \u0060istioin\u0060 和 \u0060istioout\u0060），从而将流量引导至 ztunnel 进行处理。\n\n## Waypoint Proxy 的流量路径\n\n![Waypoint Proxy 的流量路径](waypoint-proxy-routing.svg)\n\n  - **定义**：Waypoint Proxy 只参与服务器端的流量路径，作为 L7 代理执行服务端的请求。\n  - **应用场景**：当部署了 Waypoint Proxy 时，来自同一服务账户的工作负载将通过 ztunnel 重定向至 Waypoint Proxy 进行处理，然后到达目标 Pod，确保 L7 级别的策略和认证得以执行。\n\n## Istio CNI (Container Network Interface)\n\n- **定义**：Istio 的容器网络接口插件，用于在 Kubernetes 集群中自动配置流量拦截规则。\n- **功能**：Istio CNI 负责为每个新创建或加入网格的 Pod 设置必要的网络重定向规则。它通过修改 iptables 规则或应用 eBPF 程序来确保所有流量能够被 ztunnel 或 waypoint proxy 拦截和处理，从而实现服务网格的透明流量管理。\n- **Istio CNI Node Agent**：Istio CNI Node Agent 负责在每个节点上安装 Istio CNI 插件，并更新节点的 CNI 配置，确保当 Pod 加入服务网格时能够正确地配置流量重定向规则。在 Sidecar 模式中，CNI 插件通过 iptables 配置 Pod 的网络。在 Ambient 模式中，CNI 插件负责将新的 Pod 事件推送到 Ambient 监控服务器，以便配置 Pod 的网络重定向规则。\n\n## 总结\n\nIstio Ambient 模式通过将数据平面功能分为 L4 和 L7 层的独立组件，为用户提供了更轻量且灵活的服务网格解决方案。这种方式不仅简化了服务的部署，还大幅降低了资源开销。通过术语表的方式，我们探讨了 Ambient 模式中的各种核心概念，从 ztunnel 到 waypoint proxy，再到 iptables 和 eBPF 的使用，帮助你全面了解 Istio Ambient 模式的架构和运行机制。如果你对服务网格感兴趣或正在考虑如何优化微服务通信，希望这篇文章对你有所帮助。\n', '\/blog\/istio-ambient-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 实现 HTTP\/2 CONNECT 隧道：原理与实践', '深入讲解如何利用 HTTP\/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。', '\n在最近对 Istio Ambient 模式的研究中，我发现 HTTP2 Connect 方法被用作创建隧道的核心技术，以实现透明流量的拦截和转发。HTTP\/2 CONNECT 隧道是一种强大的工具，可以在已有的 HTTP\/2 连接中创建高效的隧道，用于传输原始的 TCP 数据。这篇文章通过一个简单的 Demo，展示了如何使用 Envoy 来实现 HTTP\/2 CONNECT 隧道的基本功能。\n\n## 什么是 HTTP2 Connect 方法以及 HBONE 隧道？\n\nHTTP2 Connect 方法是一种标准化的方式来创建隧道，用于透明地传输数据。特别是在 Istio 的 Ambient 模式中，它为代理数据平面之间的通信提供了一种高效的手段。HBONE（HTTP-Based Overlay Network Environment）隧道则是基于这种 HTTP2 Connect 技术的实现，用于 Istio 中的透明流量拦截和转发。通过使用 HBONE，数据可以有效地通过 HTTP2 隧道安全传输，替代了传统的 Sidecar 模式。这一创新设计极大地简化了服务网格的管理和部署。\n\nHBONE 是 Istio 特有的术语，它是一种安全隧道协议，用于在 Istio 组件之间进行通信。在当前的 Istio 实现中，HBONE 协议包含了三个开放标准：\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT 用于建立隧道连接，mTLS 用于安全地加密连接，而 HTTP\/2 用于在单一安全隧道中多路复用应用连接流并传输附加的流级元数据。更多关于 HBONE 隧道的细节可以参考官方文档：[HBONE 详细介绍](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## 使用 HTTP2 Connect 建立隧道的基本原理\n\nHTTP2 Connect 方法允许我们创建一个类似于 VPN 的隧道，通过这个隧道可以安全地传递数据。建立隧道的基本步骤如下：\n\n1. 首先，客户端向代理发送一个普通的 TCP 或 HTTP 链接请求。\n2. 代理接收到请求后，代表客户端向目标服务器发送一个带有 CONNECT 方法的 HTTP2 请求。\n3. 如果服务器允许建立隧道，那么它会返回一个 HTTP2 200 OK 的响应给代理。\n5. 随后，客户端、代理和服务器之间的双向流数据就可以通过这个隧道进行传输。\n\n这种方法能够使得数据的传输过程更加透明且安全，特别适用于需要高效通信和端到端加密的场景。\n\n下图展示了 HTTP2 Connect 方法建立隧道的基本过程。\n\n\u0060\u0060\u0060mermaid \u0022HTTP2 Connect 方法建立隧道的基本过程\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: 普通 TCP 请求\n    Proxy-\u003e\u003eServer: 发送 CONNECT 请求 (HTTP2 CONNECT)\n    Server--\u003e\u003eProxy: 返回 200 OK 响应\n    Proxy--\u003e\u003eClient: 转发 200 OK 响应\n    Client-\u003e\u003eProxy: 开始传输数据\n    Proxy-\u003e\u003eServer: 转发数据\n    Server-\u003e\u003eProxy: 返回处理后的数据\n    Proxy-\u003e\u003eClient: 转发处理后的数据\n\u0060\u0060\u0060\n\n![HTTP2 Connect 方法建立隧道的基本过程](1f4003a92425618f8bf5b9c1403169a7.svg)\n\n## Demo：使用 Envoy 与上游 Server 建立 HTTP\/2 Connect 隧道\n\n本示例展示了一个基础场景：\n\n1. **客户端**：向 Envoy 代理发送文本消息。\n2. **Envoy**：接收客户端的 TCP 数据，将其封装为 HTTP\/2 CONNECT 请求，并与上游服务器建立加密隧道。\n3. **服务器**：接收来自 Envoy 的 HTTP\/2 CONNECT 流量，解封装并返回响应给客户端。\n\n架构图如下：\n\n\u0060\u0060\u0060mermaid \u0022架构图\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![架构图](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n我们将使用 Node.js 来编写客户端和服务端，并将服务端和 Envoy 代理运行在容器中，在本地通过客户端访问 Envoy 代理从而达到访问客户端的目的。\n\n完整的目录结构如下：\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### 核心功能展示\n\n#### **1. HTTP\/2 CONNECT 隧道的基本实现**\n\n- 客户端通过普通的 TCP 连接与 Envoy 通信。\n- Envoy 将 TCP 数据封装为 HTTP\/2 CONNECT 请求，发送到上游服务器。\n- 服务器接收并解封装隧道中的数据，进行处理后返回响应。\n- 隧道通信对客户端完全透明。\n\n#### **2. Envoy 的透明代理能力**\n\n- Envoy 作为中间代理，将客户端与服务器之间的通信逻辑完全封装。\n- 客户端无需支持复杂的协议（如 HTTP\/2 或 TLS），Envoy 代理完成所有协议转换。\n\n#### **3. 加密通信的实现**\n\n- Envoy 与服务器之间的通信通过 TLS 加密，确保隧道内的数据安全。\n- 服务器终止 TLS，处理解密后的数据。\n\n#### **4. 隧道的简化使用场景**\n\n- 通过该 Demo，可以快速理解 HTTP\/2 CONNECT 隧道的建立和基本数据传输流程。\n\n### 环境准备\n\n#### 1. 安装 Node.js\n\n确保你的系统已安装 **Node.js**（版本 \u003e= **10.10.0**），因为 \u0060http2\u0060 模块在该版本后稳定。\n\n- **下载链接：** [Node.js 官方网站](https:\/\/nodejs.org\/)\n\n#### 2. 安装 Docker 和 Docker Compose\n\n- **Docker 下载链接：** [Docker 官方网站](https:\/\/www.docker.com\/get-started)\n- **Docker Compose 下载链接：** [Docker Compose 官方文档](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. 创建项目目录\n\n在你的工作空间中创建一个新目录并进入：\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### 生成自签名证书\n\n由于 Envoy 和服务器之间需要加密通信，我们需要生成包含正确配置的自签名证书。\n\n#### 1. 创建证书目录和 OpenSSL 配置文件\n\n创建 \u0060certs\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\n创建 \u0060openssl.cnf\u0060，内容如下：\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. 生成密钥和证书\n\n运行以下命令生成密钥和证书：\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\n这将在 \u0060certs\u0060 目录中生成 \u0060server.key\u0060 和 \u0060server.crt\u0060 文件。\n\n### 配置 Envoy 代理\n\n我们需要配置 Envoy，使其能够接受客户端的普通 TCP 连接，将数据通过 HTTP\/2 CONNECT 隧道传递给服务器。\n\n#### 1. 创建 Envoy 配置文件\n\n在项目根目录创建 \u0060envoy.yaml\u0060，内容如下：\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. 关键点\n\n- **Envoy 监听 TCP 连接**，将流量通过 **HTTP\/2 CONNECT 隧道**转发到服务器。\n- **客户端**只需与 **Envoy** 建立 TCP 连接，发送文本消息。\n- **Envoy**负责隧道的建立和加密，**客户端**无需感知。\n\n### 实现服务器\n\n#### 1. 创建服务器目录和文件\n\n在项目根目录创建 \u0060server\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\n在 \u0060server\u0060 目录中创建 \u0060server.js\u0060 和 \u0060Dockerfile\u0060。\n\n#### 2. 编写 \u0060server.js\u0060\n\n在 \u0060server\/server.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ 响应 200，建立隧道\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ 在隧道内处理数据\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ 回应客户端\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ 对于非 CONNECT 请求，返回 404\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**注意：**\n\n- 监听 \u0060secureConnection\u0060 事件，直接处理 TLS 连接后的 socket。\n- 在 socket 上接收数据，处理来自客户端的文本消息，并回复。\n\n#### 3. 创建 \u0060Dockerfile\u0060\n\n在 \u0060server\/Dockerfile\u0060 中添加以下内容：\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### 实现客户端\n\n#### 1. 创建客户端目录和文件\n\n在项目根目录创建 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\n在 \u0060client\u0060 目录中创建 \u0060client.js\u0060。\n\n#### 2. 编写 \u0060client.js\u0060\n\n在 \u0060client\/client.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ 创建与 Envoy 的 TCP 连接\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ 发送消息给服务器\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ 关闭连接\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**说明：**\n\n- **客户端**与 **Envoy** 建立普通的 TCP 连接，发送文本消息。\n- 该客户端的存在只是为了触发 Envoy 与服务器建立隧道。\n\n### 创建 Docker Compose 文件\n\n在项目根目录创建 \u0060docker-compose.yml\u0060：\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # 挂载证书目录\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # 挂载证书目录\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\n### 运行示例\n\n#### 1. 启动 Docker Compose\n\n在项目根目录下，运行：\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**预期输出：**\n\n- **Envoy 容器：** 显示启动信息和调试日志。\n- **服务器容器：** 显示 \u0060Secure HTTP\/2 server is listening on port 8080\u0060。\n\n#### 2. 运行客户端\n\n打开新的终端窗口，进入 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\n运行客户端：\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**预期输出：**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. 检查服务器日志\n\n在 Docker Compose 的输出中，你应该能看到服务器的日志：\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. 检查 Envoy 日志\n\n在 Envoy 的日志中，你可以看到它使用 **HTTP\/2 CONNECT 隧道**与服务器建立连接的记录。\n\n### 测试通信\n\n- **客户端**通过 TCP 连接向 **Envoy 代理**发送文本消息。\n- **Envoy**将客户端的 TCP 流量通过 **HTTP\/2 CONNECT 隧道**转发给 **服务器**。\n- **服务器**接收到来自客户端的消息，处理并回复。\n- **Envoy**将服务器的回复通过隧道传回给 **客户端**。\n- **客户端**收到服务器的回复。\n\n### 注意事项\n\n- **证书管理：** 确保证书正确配置，并在 Envoy 和服务器中正确使用。\n- **Docker 网络：** 使用 Docker Compose 定义的网络，容器可以通过服务名称互相通信。\n- **端口冲突：** 确保端口 \u006010000\u0060（Envoy）和 \u00608080\u0060（服务器）未被占用。\n- **TLS 配置：** 在示例中，Envoy 与服务器之间的通信使用 TLS 和 HTTP\/2，确保了安全性。\n\n## 隧道建立过程\n\n下图展示了客户端、Envoy 代理和服务器之间的交互，反映了数据的传递和隧道连接的建立的流程。\n\n\u0060\u0060\u0060mermaid \u0022隧道建立流程\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% 客户端与 Envoy 建立 TCP 连接\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy 创建新的 TCP 代理会话\nNote over Envoy: 创建新的 TCP 代理会话 (ConnectionId: 0)\n\n%% Envoy 创建到上游服务器的连接\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: 尝试创建新的连接 (ConnectionId: 1)\n\n%% Envoy 与服务器建立 HTTP\/2 连接\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy 通过 HTTP\/2 CONNECT 建立隧道\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: 隧道建立成功\n\n%% 客户端发送数据\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% 客户端关闭连接\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: 隧道关闭\nNote over Envoy,Client: 连接关闭\n\n%% 连接关闭日志\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![隧道建立流程](f426fb19b797e505aed4758bdc372f45.svg)\n\n说明：\n\n1. **客户端与 Envoy 建立 TCP 连接**：\n    - 客户端向 Envoy 发起 TCP 连接请求。\n    - Envoy 接受连接，建立新的 TCP 代理会话（ConnectionId: 0）。\n2. **Envoy 创建到服务器的连接**：\n\n    - Envoy 尝试连接上游集群 \u0060tunnel_cluster\u0060，创建新的连接（ConnectionId: 1）。\n3. **建立 HTTP\/2 CONNECT 隧道**：\n\n    - Envoy 与服务器建立 HTTP\/2 连接。\n    - Envoy 发送 HTTP\/2 CONNECT 请求，目标主机名为 \u0060server:8080\u0060。\n    - 服务器响应 \u0060200 OK\u0060，隧道建立成功。\n4. **数据传输**：\n\n    - **消息传递循环**：\n        - 客户端发送数据（\u0060Message N\u0060）到 Envoy。\n        - Envoy 将数据通过隧道转发给服务器。\n        - 服务器处理数据并返回响应（\u0060Echo Message N\u0060）给 Envoy。\n        - Envoy 将响应转发给客户端。\n    - **日志记录**：\n        - 服务器记录收到的消息，例如 \u0060Received from client: Message N from client!\u0060。\n5. **连接关闭**：\n\n    - 客户端发送 FIN 请求，通知关闭连接。\n    - Envoy 将 FIN 转发给服务器，关闭隧道。\n    - 服务器响应 ACK 确认关闭。\n    - Envoy 向客户端发送 ACK，完成连接关闭。\n6. **日志记录**：\n\n    - Envoy 记录连接关闭日志，包括 ConnectionId 和统计信息。\n    - 服务器记录日志，显示流已由客户端结束，例如 \u0060Stream ended by client.\u0060。\n\n## 结语\n\n虽然这是一个入门示例，但它为理解和进一步探索 HTTP\/2 CONNECT 隧道功能提供了坚实的基础。在下一篇博客中讲解通过两个 Envoy 代理实现的隧道，带你进一步了解 Istio ambient 模式中的 HBONE 透明隧道。\n\n## 参考\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n - [Istio Ambient 模式流量管理实现机制详解（一）- 赵化冰的博客 | Zhaohuabing Blog](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n', '\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入讲解如何利用 HTTP/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的数据包生命周期及流量优化', '解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。', '\n本文围绕 Istio Ambient 模式下的数据包生命周期进行深入剖析，从初始数据包的流量拦截与目标解析，到后续数据包的快速转发与优化策略，帮助读者理解 Ambient 模式背后的技术逻辑和性能实践。\n\n## 数据包生命周期概览：从内核态到用户态\n\n在 Ambient 模式中，数据包的处理路径从 Pod 内核态网络栈开始，经由 \u0060iptables\u0060 规则被拦截后进入 ztunnel 的用户态处理逻辑。ztunnel 负责透明代理、策略验证、加密隧道建立等任务，最终将数据包通过内核态网络再次转发给目标服务或下一个 ztunnel。其核心思想是通过首次数据包的详细解析和标记，为后续数据包铺路，从而减少重复开销。\n\n下图展示了 Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期：\n\n\u0060\u0060\u0060mermaid \u0022Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期\u0022\nsequenceDiagram\n    participant App as 应用程序\n    participant PodKernel as Pod内核态网络栈\n    participant ipt as iptables\n    participant ztunnel as ztunnel 用户态处理\n    participant HostKernel as 主机内核态\n    participant Service as 目标服务或下一个 ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: 首个数据包路径\n    App-\u003e\u003ePodKernel: 发出首个数据包\n    PodKernel-\u003e\u003eipt: 检查iptables重定向规则\n    ipt-\u003e\u003eztunnel: 将数据包重定向至zTunnel透明代理端口\n    ztunnel-\u003e\u003eztunnel: 提取目标地址 \u0026 策略验证 \u0026 建立隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回处理后的数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: 后续数据包路径\n    App-\u003e\u003ePodKernel: 发出后续数据包\n    PodKernel-\u003e\u003ePodKernel: 利用 conntrack 匹配已有连接\n    PodKernel-\u003e\u003eztunnel: 数据包直接进入 ztunnel inbound socket（无需iptables重定向）\n    ztunnel-\u003e\u003eztunnel: 无需重复解析 \u0026 复用已有隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\u0060\u0060\u0060\n\n![Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期](4c7d5e7ac5168314a5c5de34a39a4f9c.svg)\n\n接下来，我们将详细介绍首个数据包与后续数据包的处理路径，并分析其中的技术要点与优化手段。\n\n## 首个数据包路径：从拦截到目标解析\n\n当应用程序在 Pod 内发出数据包（如 HTTP 请求），数据包首先经过 Pod 的网络命名空间和内核态网络栈进行处理。\n\n### 透明拦截与目标解析\n\n\u0060iptables\u0060 规则对出站流量进行筛选，若发现目标地址为非本地资源且数据包未携带特定标记，则将数据包重定向至 ztunnel 的透明代理端口（如 \u006015006\u0060 或 \u006015008\u0060）。借助 \u0060IP_TRANSPARENT\u0060 和 \u0060SO_ORIGINAL_DST\u0060 选项，ztunnel 可提取数据包的原始目标地址，实现无缝透明代理。\n\n### 用户态处理：策略验证与加密隧道\n\n数据包进入 ztunnel 用户态后，将经历以下处理流程：\n\n1. **策略验证**：RBAC 验证、mTLS 加密判定。\n2. **目标流量处理**：对网格内部流量，通过 HTTP\/2 CONNECT 隧道（HBONE）加密与跨节点传输；对网格外流量，直接通过本地 TCP 连接透传。\n\n完成处理后，ztunnel 基于数据包解析结果建立出站连接（如 HTTP\/2 隧道或明文 TCP），并将数据包送回内核态，最终转发至目标服务或下一个 ztunnel。\n\n## 后续数据包路径：利用 Conntrack 与隧道复用\n\n首个数据包完成解析与策略验证后，Linux 内核的连接跟踪（\u0060conntrack\u0060）记录连接状态与标记。后续数据包无需再次经历复杂的拦截与解析，直接进入 ztunnel 的 inbound socket。\n\n### 连接跟踪与快速转发\n\n后续数据包基于 \u0060conntrack\u0060 跟踪机制，快速到达 ztunnel 的 inbound socket。ztunnel 可直接识别目标地址与安全策略，避免重复的解析与验证。\n\n### 隧道与明文连接优化\n\n1. **HBONE 隧道**：支持多路复用，提高加密流量处理效率。\n2. **明文连接**：对无需加密的流量，直接复用现有 TCP 连接，进一步减少处理开销。\n\n## 技术要点与优化策略\n\n- **透明代理**：利用 \u0060IP_TRANSPARENT\u0060 实现透明流量捕获与目标解析。\n- **内核与用户态高效协作**：首个数据包通过用户态完成深度处理，后续数据包借助 \u0060conntrack\u0060 与 inbound socket 实现快速转发，降低上下文切换成本。\n- **多路复用**：借助 HTTP\/2 隧道实现高效加密与负载均衡，优化传输性能。\n\n## 实践建议\n\n1. **多平台适配**：根据平台特性调整透明代理实现。\n2. **调优与监控**：结合 ztunnel 日志与服务网格监控工具，优化流量路径与性能表现。\n\n## 总结\n\nIstio Ambient 模式通过数据包生命周期设计，在透明代理、性能优化与安全策略间实现平衡。zTunnel 通过高效的用户态处理与内核态快速转发，将应用程序的透明体验与底层网络优化有效结合，助力服务网格的实践与推广。\n', '\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-ambient-mode-ztunnel-shutdown/">[译] Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/ztunnel-shutdown/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制', '了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。', '\n关于 Istio 的 Ambient 模式，一个常见的问题是它如何在升级或重启期间处理流量。\n\n在 Sidecar 模型中，代理和应用程序是 1:1 的关系，这种情况下无需担心此类问题——代理在应用程序停止时会关闭，并在应用程序启动时加载最新版本。\n\n然而，Ambient 模式中，每个节点都有一个专用代理（“Ztunnel”），这意味着我们可能需要在应用程序运行时对其进行升级。\n\n## 停止运行的过程\n\nZtunnel 遵循标准的滚动更新流程。也就是说，当我们需要引入新版本时，会按照以下步骤进行：\n\n1. 启动新版本\n2. 当新版本准备就绪后，开始关闭旧版本\n3. 在一段时间内，两个版本会同时运行\n4. 最终，旧版本被关闭\n\n对于 Ztunnel，有两种类型的流量需要考虑：\n\n第一种是当同时运行多个实例时，*新建*连接会发生什么。在非常短的时间内，两个实例都会接受连接（利用 \u0060SO_REUSEPORT\u0060），这些连接由内核随机分配。然而，一旦新实例完全准备就绪，就会通知旧实例停止接受新连接，这样新实例可以开始处理所有新建连接。\n\n第二种是对于我们正在关闭的实例上的*现有*连接会发生什么。虽然应用协议通常具有通知对端停止使用的机制，例如 HTTP\/1.1 可以发送 \u0060Connection: close\u0060 标头，HTTP\/2 可以发送 \u0060GOAWAY\u0060，但 Ztunnel 在 L4 层工作，TCP 本身并没有这样的机制。为此，Ztunnel 使用了一种宽限期机制。只要仍有活动连接，旧实例就会继续运行并服务这些连接（但正如前面提到的，不再处理任何新连接）。最终，如果超出了可配置的宽限期，任何剩余的连接都会被发送 \u0060RST\u0060（连接复位）。\n\n结合起来，从“蓝色版本”升级到“绿色版本”的生命周期如下图所示：\n\n![Ztunnel 升级时间线](ztunnel-shutdown.png)\n\n第一条时间轴显示哪个实例正在积极接受连接。可以看到，这个状态从“蓝色”切换到“绿色”，其中有一个短暂的时间段内两个实例都在接受连接。\n\n第二和第三条时间轴分别显示旧实例和新实例的状态。旧实例在新实例准备就绪后开始其宽限期，最终强制终止所有剩余连接。\n\n## 我的应用程序会受到影响吗？\n\n对大多数人来说，重要的不是内部运作的细节，而是他们的应用程序是否会受到影响。简短的答案是：这取决于情况。\n\n如果你的应用程序存在比宽限期更长的连接，这些连接可能会被重置。具体影响取决于你的应用程序——有些能够更优雅地处理这种情况，而有些则不行。\n\n需要特别注意的是，**在任何时候，新建连接都不会失败**。因此，如果你的应用程序在连接终止后尝试重新建立新连接（这是正确的做法！），那么这个过程始终可以成功。\n\n## 如何减少连接重置的影响？\n\n如果你的应用程序无法很好地处理连接重置，有两种主要的方法可以缓解问题：\n\n第一种方法是确保 Ztunnel 的宽限期比你的最大连接时长更长。许多使用长连接的场景（例如连接池）可以配置连接的最大时长，并在达到最大时长后重新建立连接。如果需要，可以将此值设置得更短。此外，Ztunnel 的宽限期可以通过配置其 \u0060terminationGracePeriodSeconds\u0060 设置来调整——这个值可以设置得相当高，甚至是数小时。\n\n另一种更具侵入性但非常安全的选项是，确保升级过程中节点上没有运行应用程序。这可以通过[给节点打上隔离标记](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/generated\/kubectl_cordon\/)来实现。在大多数情况下，这种方法可能过于繁琐，但如果你将 TCP 连接视为“宠物”（需要精心维护），这种方式可能是值得的。\n\n\u003e 你可能会好奇，为什么节点隔离\/关闭可以 100% 避免连接终止，而 Ztunnel 升级却不能？问题在于，Ztunnel 升级时无法通知应用程序优雅地关闭或终止连接。然而，当应用程序关闭时，它会收到 \u0060SIGTERM\u0060 信号，可以利用该信号进行优雅的关闭。当然，你的应用程序必须正确处理该信号才能获得任何好处！\n', '\/trans\/istio-ambient-mode-ztunnel-shutdown\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析', '深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。', '\n在 Istio Ambient 模式下，ztunnel 是节点级安全代理，在 L4 层拦截并加密服务间流量。但不负责 L7（如 HTTP）层处理。Ambient 模式中，L7 处理由 Waypoint 代理负责。当 ztunnel 发现目标服务需 L7 处理时，通过 HBONE 协议将流量转发给 Waypoint 代理进行 HTTP 层策略应用和可观察性处理，再由 Waypoint 代理经 ztunnel 转发给目标 Pod，本文将详细阐述这条 L7 流量转发链路。\n\n## Waypoint 代理的角色与责任\n\n在 Istio Ambient 模式中：\n\n- **ztunnel** 负责透明捕获 Pod 间的 L4 流量，提供 mTLS 加密和身份认证。\n\n- **Waypoint 代理** 是一个基于 Envoy 的 L7 代理，处理 HTTP 层的高级路由、策略和可观察性。\n\n当一个请求需要 L7 层策略时（如 \u0060productpage\u0060 调用 \u0060reviews-v1\u0060 服务），**ztunnel 将流量通过 HBONE 隧道转发到 Waypoint Proxy**，由 Waypoint 执行 HTTP 路由和策略。\n\n## L7 流量在 Ambient 模式中的处理路径\n\n下图展示了 L7 流量在 Ambient 模式中的处理路径。\n\n\u0060\u0060\u0060mermaid \u0022L7 流量在 Ambient 模式中的处理路径\u0022\nsequenceDiagram\n    participant SP as 源 Pod (productpage)\n    participant ZT1 as ztunnel (源节点)\n    participant WP as Waypoint Proxy\n    participant ZT2 as ztunnel (目标节点)\n    participant DP as 目标 Pod (reviews-v1)\n\n    SP-\u003e\u003eZT1: 发出请求 (HTTP\/1.1)\n    note over SP,ZT1: 流量被源节点上的 ztunnel 拦截\n    ZT1-\u003e\u003eWP: 封装为 HBONE 请求 (mTLS)\n    note over ZT1,WP: ztunnel 执行透明拦截和加密\n    WP-\u003e\u003eZT2: 应用 L7 策略后转发流量 (mTLS)\n    note over WP,ZT2: Waypoint 应用 L7 策略后发送请求\n    ZT2-\u003e\u003eDP: 解封装并转发到 Pod 应用端口 (TCP)\n    note over ZT2,DP: ztunnel 在目标节点执行流量重定向\n    DP--\u003e\u003eZT2: 响应数据 (TCP)\n    note over DP,ZT2: Pod 返回响应\n    ZT2-\u003e\u003eWP: 封装为 HBONE 响应 (mTLS)\n    WP-\u003e\u003eZT1: 应用 L7 策略后的响应 (mTLS)\n    note over WP,ZT1: Waypoint 应用 L7 策略后的响应数据\n    ZT1-\u003e\u003eSP: 解封装并返回响应 (HTTP\/1.1)\n    note over ZT1,SP: ztunnel 在源节点解封装并返回响应\n\u0060\u0060\u0060\n\n![L7 流量在 Ambient 模式中的处理路径](022a72b18c3091c40cf01bb4fad208a2.svg)\n\n下面两张图片分别展示了源 Pod 和目标 Pod 在同节点和跨节点情况下的 L7 流量处理路径。\n\n![源 pod 和目标 pod 在同一节点上的 L7 流量路径](hbone-same-node.svg)\n\n![源 pod 和目标 pod 在不同节点上的 L7 流量路径](hbone-cross-node.svg)\n\n下面是详细的流量路径。\n\n### 1. 应用请求发出\n\n假设 productpage 应用需要访问 reviews 服务。productpage Pod 内的应用向 \u0060reviews.default.svc.cluster.local:9080\u0060 发起 HTTP 请求。\n\n### 2. ztunnel L4 透明捕获与识别\n\nproductpage Pod 的出站请求首先被所在节点上的 ztunnel 拦截。ztunnel 查看从 Istio 控制面下发的配置，根据目标服务（reviews）的身份和策略，得知该服务需要经过 Waypoint 代理进行 L7 层处理。\n\n### 3. 通过 HBONE 协议转发至 Waypoint\n\nztunnel 并非使用传统的 Envoy-to-Envoy XDS 或原生 TCP\u002bmTLS 隧道，而是通过 **HBONE 协议** 与 Waypoint 代理通信。HBONE 是 Istio Ambient 模式中专门设计的无 Sidecar L7 路由协议，基于 HTTP\/2，可在透明模式下对流量进行叠加转发，从而实现灵活的服务拓扑和策略控制。\n\n在这一阶段，ztunnel 会将 L4 流量封装到 HBONE 隧道中，发送给相应的 Waypoint 代理。\n\n### 4. Waypoint 代理的 L7 策略与遥测处理\n\nWaypoint 代理（目前仍基于 Envoy 实现）收到通过 HBONE 隧道传来的流量后，通过 TLS 配置和客户端证书校验，确保下游（ztunnel）是已被认证的受信主体。它将下游客户端的身份信息（SPIFFE ID）和其他上下文元数据提取出来，以便在 L7 层策略决策中使用。\n\n执行的操作包括：\n\n- 基于 HTTP Path\/Host 的路由和流量拆分\n- 基于 Headers 的访问控制和认证策略\n- 故障注入、熔断、限流\n- 遥测数据收集（请求时延、错误率、Tracing、Metrics、Logs）\n\n完成 L7 处理后，Waypoint 代理再通过 HBONE 将流量传回到目标节点的 ztunnel。\n\n### 5. 流量到达目标 Pod\n\n目标节点上的 ztunnel 会从 Waypoint 代理接收处理过的流量（同样通过 HBONE 隧道传递），然后解封装并将流量传递给对应的 reviews Pod 中的应用容器端口。\n\n## 洞察与关键点总结\n\n### 1. Waypoint 并不知道 ztunnel 的存在\n\n- Waypoint 代理只知道目标 Pod 的 IP 地址，但目标端口被重写为 \u006015008\u0060。\n- Kubernetes \u0060iptables\u0060 规则将流量透明重定向到 ztunnel。\n\n### 2. 流量安全性：端到端加密与身份认证\n\n- 双向 TLS（mTLS）和 SPIFFE ID 校验确保了端到端安全。\n- 无法绕过 ztunnel，确保了零信任架构的完整实施。\n\n### 3. 完全透明的流量控制\n\n- 应用开发人员无需更改任何代码。\n- 流量控制、策略和可观察性完全在数据面层面透明执行。\n\n## 如何调试？\n\n在 Ambient 模式下，调试方式也有了一些变化：\n\n- **ztunnel 调试**：\n  - Istio 引入了新的 \u0060istioctl ztunnel\u0060 子命令来协助查看和调试 ztunnel 的配置与状态。\n\n- **waypoint 调试**：\n  - 虽然 Waypoint 代理仍然是 Envoy，所以仍然可以使用 \u0060istioctl pc\u0060 和 \u0060istioctl ps\u0060 来查看其路由、集群和监听器配置。\n  - \u0060istioctl waypoint\u0060 提供了更直观的配置查看和状态检查功能。\n\n## 总结\n\nIstio Ambient 模式通过 ztunnel 来处理 L4 流量并实现零信任加密与传输，再通过 Waypoint 代理为需要 L7 策略的请求提供集中处理。两者之间通过 HBONE 协议进行高效、透明的通信，实现比传统 Sidecar 模式更轻量且易于运维的架构。\n', '\/blog\/istio-ambient-l7-flow-analysis\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/migrate-to-istio-telemetry-api/">从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性', '通过迁移到 Telemetry API 配置 SkyWalking 提供商，从而提升 Istio 网格的追踪能力和灵活性。', '\nIstio 的 Telemetry API 是替代传统 MeshConfig 遥测配置的现代化方式，提供了更灵活的工具来定义服务网格中的 **Tracing**、**Metrics** 和 **Access Logging**。相比传统的 \u0060EnvoyFilter\u0060 和 \u0060MeshConfig\u0060，Telemetry API 更具模块化、动态更新和跨层次配置能力。\n\n在本篇中，我们将详解如何使用 Telemetry API 配置 Istio 遥测功能，涵盖 Tracing、Metrics 和 Logging 的具体实现，同时展示如何迁移过时的 MeshConfig 配置。\n\n## Telemetry API 发展历程\n\nIstio 的遥测能力在早期版本中依赖于较为传统的配置方法，如 **Mixer** 和 **MeshConfig** 的 \u0060configOverride\u0060，这些方法虽然能够满足基本需求，但在复杂场景下显得力不从心。为了解决这些问题，Istio 引入了基于 CRD 的 **Telemetry API**。\n\n### 关键版本更新\n\n为了帮助读者了解 Telemetry API 的进化过程，以下是一些重要版本的更新信息：\n\n1. **Istio 1.11**：引入 Telemetry API（Alpha），提供了基本的指标和日志自定义功能。\n2. **Istio 1.13**：支持 OpenTelemetry 日志记录、自定义追踪服务名称，以及更强的日志过滤功能。\n3. **Istio 1.18**：默认不再安装 Prometheus 的 \u0060EnvoyFilter\u0060，完全依赖 Telemetry API 定义遥测行为。\n4. **Istio 1.22**：Telemetry API 升级为稳定版（v1），全面支持生产环境需求。\n\n## 为什么迁移到 Telemetry API？\n\n尽管传统的 MeshConfig 和 EnvoyFilter 提供了基础的遥测能力，但它们的配置方式在灵活性、动态性和扩展性方面存在诸多限制。为了更清晰地理解这些局限性，我们将从几个关键维度展开说明。\n\n### 使用 MeshConfig 和 EnvoyFilter 的复杂性\n\n在介绍具体问题之前，我们先了解一下 MeshConfig 和 EnvoyFilter 的定位：MeshConfig 适用于全局配置，而 EnvoyFilter 用于细粒度的自定义。但正是这种分工，导致了它们在管理上的复杂性。\n\n#### 1. 配置方式分散\n- **MeshConfig** 用于集中定义全局网格行为，例如访问日志路径、追踪采样率和指标维度。虽然适合简单场景，但无法满足命名空间级或工作负载级的需求。\n- **EnvoyFilter** 则可以覆盖或扩展 Envoy 的配置，允许更细粒度的控制。但这种方式直接操作 Envoy 内部结构（xDS 字段），配置语言复杂且容易出错。\n\n  **示例：通过 MeshConfig 配置访问日志**\n  \u0060\u0060\u0060yaml\n  apiVersion: install.istio.io\/v1alpha1\n  kind: IstioOperator\n  spec:\n    meshConfig:\n      accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  **问题**：\n  - 无法为特定服务或命名空间设置不同的日志路径。\n  - 需要重新应用整个配置，动态性不足。\n\n  **示例：通过 EnvoyFilter 自定义指标**\n  \u0060\u0060\u0060yaml\n  apiVersion: networking.istio.io\/v1alpha3\n  kind: EnvoyFilter\n  metadata:\n    name: custom-metric-filter\n    namespace: mynamespace\n  spec:\n    workloadSelector:\n      labels:\n        app: myapp  # 选择特定的工作负载\n    configPatches:\n      - applyTo: HTTP_FILTER\n        match:\n          context: SIDECAR_INBOUND  # 匹配入站流量\n        patch:\n          operation: ADD\n          filterClass: STATS  # 指定为统计过滤器\n          value:\n            name: istio.request_operation  # 自定义指标名称\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n              type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n              value:\n                config:\n                  configuration: |\n                    \u0022attributes\u0022: [\n                      {\n                        \u0022output_attribute\u0022: \u0022istio_operationId\u0022,\n                        \u0022match\u0022: [\n                          {\n                            \u0022value\u0022: \u0022GetReviews\u0022,\n                            \u0022condition\u0022: \u0022request.url_path == \u0027\/reviews\u0027 \u0026\u0026 request.method == \u0027GET\u0027\u0022\n                          }\n                        ]\n                      }\n                    ]\n                vm_config:\n                  runtime: envoy.wasm.runtime.null\n                  code:\n                    local: { inline_string: \u0022envoy.wasm.attributegen\u0022 }\n  \u0060\u0060\u0060\n  **问题**：\n  - 配置语法复杂且冗长，需深入理解 Envoy 的结构。\n  - 易于出错，调试和维护成本高。\n\n#### 2. 动态性不足\n\n虽然现代微服务环境强调动态调整配置，但 MeshConfig 和 EnvoyFilter 的动态性支持有限：\n\n- **MeshConfig**：修改配置通常需要重启代理或重新应用整个配置，导致服务中断。\n- **EnvoyFilter**：更新流程复杂，调整单个参数也需重新部署相关代理实例。\n\n#### 3. 多租户支持困难\n\n在多租户环境中，针对不同命名空间或工作负载自定义遥测配置非常重要。然而：\n\n- **MeshConfig**：无法针对命名空间或工作负载进行差异化设置。\n- **EnvoyFilter**：需要编写多个过滤器配置，增加了管理复杂性。\n\n#### 4. 难以扩展和调试\n\n- MeshConfig 和 EnvoyFilter 对新需求（如 OpenTelemetry）支持较慢。\n- EnvoyFilter 的调试难度高，需要深入分析 Envoy 日志和行为。\n\n### 弃用传统 MeshConfig 的遥测配置\n\n鉴于上述局限性，Istio 社区已经将传统的 MeshConfig 遥测配置标记为**弃用**。以下示例展示了这些配置的使用方式及其不足之处：\n\n- **Access Logging 配置**：\n  \n  \u0060\u0060\u0060yaml\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  \n- **Trace Sampling 配置**：\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    enableTracing: true\n    extensionProviders:\n    - name: zipkin\n      zipkin:\n        service: zipkin.istio-system.svc.cluster.local\n        port: 9411\n  \u0060\u0060\u0060\n  \n- **自定义 Metrics 标签**：\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    telemetry:\n      v2:\n        prometheus:\n          configOverride:\n            inboundSidecar:\n              metrics:\n                - name: requests_total\n                  dimensions:\n                    user-agent: request.headers[\u0027User-Agent\u0027]\n  \u0060\u0060\u0060\n\n通过上述例子可以看出，这些配置的灵活性和扩展性明显不足，难以应对复杂的生产环境需求。\n\n## Telemetry API 的优势\n\n在传统配置方式的基础上，Telemetry API 带来了多项改进，使其更适合现代化的服务网格管理需求：\n\n1. **模块化设计**：Tracing、Metrics 和 Access Logging 独立配置，清晰简洁。\n2. **动态更新**：支持实时更新配置，无需重启代理。\n3. **层级化支持**：允许全局、命名空间和工作负载级别的配置覆盖。\n4. **简单直观**：使用声明式语法，无需深入理解 Envoy 的内部结构。\n\n## Istio Telemetry API 配置示例\n\n### 全局配置示例\n\n为帮助理解 Telemetry API 的具体使用，我们以全局配置示例作为开始：\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  accessLogging:\n  - providers:\n    - name: envoy # better to use a built-in one\n  tracing:\n  - providers:\n    - name: \u0022skywalking\u0022\n    randomSamplingPercentage: 100.00\n  metrics:\n  - overrides:\n    - match:\n        metric: REQUEST_COUNT\n        mode: CLIENT\n      tagOverrides:\n        x_user_email:\n          value: |\n            \u0027x-user-email\u0027 in request.headers ? request.headers[\u0027x-user-email\u0027] : \u0027empty\u0027\n    providers:\n    - name: prometheus\n\u0060\u0060\u0060\n\n### 使用 Telemetry API 配置 SkyWalking\n\n我们再以配置 SkyWalking 的采样率和 span tag 为例，演示如何使用 Telemetry API。\n\n#### 检查 Istio 版本与 CRD\n\n- 如果使用 Istio 1.22 或更高版本，使用 \u0060telemetry.istio.io\/v1\u0060。\n- 对于 Istio 1.18 至 1.21 的用户，使用 \u0060telemetry.istio.io\/v1alpha1\u0060。\n\n通过以下命令检查 Telemetry API 的 CRD 是否已安装：\n\n\u0060\u0060\u0060bash\nkubectl get crds | grep telemetry\n\u0060\u0060\u0060\n\n#### 部署 SkyWalking\n\n在集群中部署 SkyWalking OAP 服务：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\n检查服务状态：\n\n\u0060\u0060\u0060bash\nkubectl get pods -n istio-system -l app=skywalking-oap\n\u0060\u0060\u0060\n\n#### 配置 MeshConfig 添加 SkyWalking 提供商\n\n在 Istio 的 \u0060MeshConfig\u0060 中定义 SkyWalking 提供商。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: istio\n  namespace: istio-system\ndata:\n  mesh: |-\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: \u0022tracing.istio-system.svc.cluster.local\u0022\n        port: 11800\n\u0060\u0060\u0060\n\n#### 使用 Telemetry API 配置采样率\n\n通过 Telemetry API，将 SkyWalking 设置为默认的 Tracing 提供商，并定义采样率。\n\n你可以从使用 Telemetry API 从多个层级配置采样率，为了节约篇幅，我们仅演示在命名空间范围配置采样率，其他层级的配置请参考 [Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/)。\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1\nkind: Telemetry\nmetadata:\n  name: namespace-override\n  namespace: default\nspec:\n  tracing:\n  - providers:\n      - name: skywalking\n    randomSamplingPercentage: 50\n    customTags:\n      env:\n        literal:\n          value: production\n\u0060\u0060\u0060\n\n说明：\n\n- \u0060providers.name\u0060：指定 SkyWalking 为默认的 Tracing 提供商。\n- \u0060randomSamplingPercentage\u0060：覆盖命名空间级别配置，设置 50% 的采样率。\n- \u0060customTags\u0060：为所有追踪数据添加 \u0060env=production\u0060 标签。\n\n### 验证配置\n\n访问网格中的服务（如 [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) 示例应用）生成流量：\n\n\u0060\u0060\u0060bash\ncurl http:\/\/$GATEWAY_URL\/productpage\n\u0060\u0060\u0060\n\n查看追踪数据：\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\n打开浏览器访问 \u0060http:\/\/localhost:8080\u0060，在追踪界面中查看生成的追踪信息。\n\n![Skywalking Tracing](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-tracing.webp)\n\n点击一个span后，你可以看到其中的追加的 \u0060env: production\u0060 tag。\n\n![Skywalking Span](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-span.webp)\n\n## 总结\n\nTelemetry API 通过其模块化设计、动态更新和多层级支持，大幅降低了服务网格中遥测配置的复杂性。相比 MeshConfig 和 EnvoyFilter，Telemetry API 是一套更灵活、高效的现代化解决方案。我们强烈推荐迁移到 Telemetry API，以充分利用其功能。\n', '\/blog\/migrate-to-istio-telemetry-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">通过迁移到 Telemetry API 配置 SkyWalking 提供商，从而提升 Istio 网格的追踪能力和灵活性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-sidecar-vs-ambient-network-cost-performance/">Istio sidecar 和 ambient 模式的网络成本对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio sidecar 和 ambient 模式的网络成本对比', '深入对比 Istio sidecar 和 ambient 模式的网络成本与性能，分析其本地性感知及排查方法。', '\n在服务网格架构不断演进的过程中，了解不同部署模式下的网络成本对于优化性能和资源效率至关重要。本文将对比 Istio 的 sidecar 模式和 ambient 模式的网络成本，分享我在[这篇文章](\/blog\/service-mesh-data-plane-deployment-modes\/)中的一些观点。\n\n## Sidecar 模式\n\nIstio 的 sidecar 模式通过在每个 pod 旁部署 sidecar 代理来拦截服务间的流量。这种架构引入了额外的网络跳转，可能会增加延迟和计算资源使用量。然而，该模式内置了重要的性能优化特性：[本地性感知](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/locality-load-balancing\/)。\n\n图 1 展示了 Application 1 在 Istio sidecar 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。\n\n![图 1：Application 1 在 Istio sidecar 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。](sidecar-mode.svg)\n\n### Sidecar 模式的本地化感知\n\n在 Sidecar 模式下，可以使用以下命令查看端点表中的本地性信息，从而更好地理解本地性管理：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoint \u003cpod-name[.namespace]\u003e -o yaml\n\u0060\u0060\u0060\n\n以下是一个示例输出片段，显示了集群 \u0060outbound|9080||reviews.default.svc.cluster.local\u0060 的端点信息：\n\n\u0060\u0060\u0060yaml\n- addedViaApi: true\n  circuitBreakers:\n    thresholds:\n    - maxConnections: 4294967295\n      maxPendingRequests: 4294967295\n      maxRequests: 4294967295\n      maxRetries: 4294967295\n    - maxConnections: 1024\n      maxPendingRequests: 1024\n      maxRequests: 1024\n      maxRetries: 3\n      priority: HIGH\n  edsServiceName: outbound|9080||reviews.default.svc.cluster.local\n  hostStatuses:\n  - address:\n      socketAddress:\n        address: 10.244.0.98\n        portValue: 9080\n    healthStatus:\n      edsHealthStatus: HEALTHY\n    locality:\n      region: us-central1\n      zone: us-central1-c\n    stats:\n    - name: cx_connect_fail\n    - name: cx_total\n    - name: rq_error\n    - name: rq_success\n    - name: rq_timeout\n    - name: rq_total\n    - name: cx_active\n      type: GAUGE\n    - name: rq_active\n      type: GAUGE\n    weight: 1\n  - address:\n    # 省略\n  - address:\n    # 省略\n  name: outbound|9080||reviews.default.svc.cluster.local\n  observabilityName: outbound|9080||reviews.default.svc.cluster.local;\n\u0060\u0060\u0060\n\n从中可以看到 sidecar 模式下对 Envoy 代理对 pod 基于负载均衡的细粒度控制，例如 \u0060maxConnections\u0060, \u0060maxRequests\u0060, \u0060maxRetries\u0060 等 circuit breaker 配置，同时包含流量指标和健康状态。这些细节帮助在 Pod 级别管理流量的健康度、稳定性和延迟。\n\n流量负载均衡考虑到 Locality，如 zone 和 region。Envoy 使用这些信息对流量执行更加精准的区域感知流量分配策略（如优先使用同一 zone 内的服务）。\n\n每个 sidecar 代理都会优先将流量路由至同一可用区（AZ）或区域内的服务。这一设计减少了不必要的跨 AZ 流量，从而降低了由数据传输产生的高延迟和高成本。通过将流量限制在本地区域，sidecar 模式能够优化网络路径，避免跨区域的瓶颈。\n\n尽管 sidecar 架构计算密集，但其本地性感知功能在维护高效流量路由方面起到了关键作用，尤其是在多区域云部署中，该功能有助于降低跨区域流量成本。\n\n## Ambient 模式\n\n下图展示的 Istio ambient 模式的架构。\n\n![图 2：Istio ambient 模式](istio-ambient-layers.svg)\n\nIstio ambient 模式包含两层：\n\n1. **Ztunnel 安全层（L3\/L4 流量处理）**：在此模式下，ambient 模式仅依赖 zTunnel 进行流量管理，主要处理三层和四层的流量，即网络和传输层。这一方式可减少开销，确保基本的连接和安全要求得到满足。\n\n2. **Waypoint 代理层（L7 流量处理）**：此模式下引入了 waypoint 代理，以扩展至应用层流量，处理高级路由、观测性和策略执行。然而，waypoint 代理的部署位置对性能至关重要。为避免跨 AZ 流量，建议将 waypoint 代理分布于各个 AZ 内，以确保最佳性能。\n\n### Ambient 模式的本地化感知\n\n相比之下，ambient 模式通过 ztunnel 和 waypoint 代理实现不同的架构。zTunnel 确保本地感知的流量路由，类似于 sidecar 模式，优先在同一 AZ 内路由流量，从而限制跨 AZ 流量并减少相应的网络成本。\n\n图 3 展示了 Application 1 在 Istio ambient 模式下访问位于不同 AZ 的 Application 2 的流量路径。\n\n![图 3：Application 1 在 Istio ambient 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。](ambient-mode.svg)\n\n**注意**：图中 Waypoint Proxy 为演示目的单独显示；在实际中，它并不绑定到特定节点，可以与 Ztunnel 同节点部署。\n\n可以通过以下命令查看 Ambient 模式中 Ztunnel 的详细配置和流量分布：\n\n\u0060\u0060\u0060bash\nistioctl ztunnel-config workload -o yaml\n\u0060\u0060\u0060\n\n以下是一个示例输出：\n\n\u0060\u0060\u0060yaml\n- applicationTunnel:\n    protocol: \u0022\u0022\n  canonicalName: productpage\n  canonicalRevision: v1\n  clusterId: Kubernetes\n  hostname: \u0022\u0022\n  locality:\n    region: us-central1\n    zone: us-central1-c\n  name: productpage-v1-d5789fdfb-gmw5r\n  namespace: default\n  node: gke-cilium-default-pool-63a77182-f699\n  protocol: HBONE\n  serviceAccount: bookinfo-productpage\n  status: Healthy\n  trustDomain: cluster.local\n  uid: Kubernetes\/\/Pod\/default\/productpage-v1-d5789fdfb-gmw5r\n  workloadIps:\n    - 10.28.2.14\n  workloadName: productpage-v1\n  workloadType: deployment\n\u0060\u0060\u0060\n\n从中可以看到 ztunnel 隧道的本地化信息，ztunnel 可以对进出该节点所有 pod 的流量进行集中式管理，比如统一执行负载均衡、健康检查和区域感知等操作。\n\n### Waypoint 代理优化\n\n然而，waypoint 代理并非自动具有 AZ 感知功能。关键问题在于它们的部署位置。为优化成本与性能，waypoint 代理需要跨所有 AZ 进行扩展，以便本地处理流量。否则，可能导致跨 AZ 流量和额外成本。此外，当流量进入 waypoint 代理时，原始本地性信息可能被隐藏，进一步增加了路由优化的难度。\n\n为优化性能和成本，建议 waypoint 代理在各个 AZ 内分布，以便能够本地处理流量。此外，ztunnel 与 waypoint 代理的通信设计为接近感知，从而确保流量被路由至最近的 waypoint 代理。这一特性进一步减少了跨 AZ 费用和延迟。\n\n## 使用 Kiali dashboard 进行可视化\n\n在对比 sidecar 和 ambient 模式时，为了更直观地理解本地性和路由行为，建议使用 Kiali dashboard。Kiali 能够直观展示不同模式下的流量路径，有助于理解 ambient 模式在复杂性上的表现。\n\n![图 4：Kiali 页面](kiali.webp)\n\n## 总结\n\n在对比 Istio 的 sidecar 和 ambient 模式的网络成本时，两种架构都提供了本地性感知的路由以减少跨 AZ 流量。然而，sidecar 模式在每个代理的本地性管理上更加完善，而 ambient 模式需要谨慎管理 waypoint 代理以避免额外成本。此外，需要考虑 ambient 模式的两种子模式（有或无 waypoint 代理）来理解它们对网络成本和性能的不同影响。\n\n如果希望深入了解四种主要的服务网格数据平面部署模式，建议阅读[深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析]\/blog\/service-mesh-data-plane-deployment-modes\/)。\n', '\/blog\/istio-sidecar-vs-ambient-network-cost-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入对比 Istio sidecar 和 ambient 模式的网络成本与性能，分析其本地性感知及排查方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/authz-policy-with-kyverno/">[译] 使用 Istio 和 Kyverno Authz Server 实现动态 Layer 7 策略管理</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/11/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2024/authz-policy-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Istio 和 Kyverno Authz Server 实现动态 Layer 7 策略管理', '使用 Kyverno 的 Authz Server 代理 Layer 7 授权决策逻辑，并基于 CEL 编写策略。', '\nIstio 支持与多个不同的项目集成。Istio 博客最近发布了一篇关于 [与 OpenPolicyAgent 的 L7 策略功能](https:\/\/chatgpt.com\/l7-policy-with-opa) 的文章。Kyverno 是一个类似的项目，本文将探讨如何将 Istio 和 Kyverno Authz Server 结合使用，在你的平台中强制执行 Layer 7 策略。\n\n我们将通过一个简单的示例，展示如何快速上手。你将看到这种组合如何成为快速、透明地将策略交付给企业中各个应用团队的可靠选择，同时提供安全团队所需的审计和合规性数据。\n\n## 实验指南\n\n将 Kyverno Authz Server 集成到 Istio 中后，可以针对微服务应用程序强制执行细粒度的访问控制策略。\n\n本指南展示了如何为一个简单的微服务应用程序实施访问控制策略。\n\n### 前置条件\n\n- 安装了 Istio 的 Kubernetes 集群。\n- 已安装 \u0060istioctl\u0060 命令行工具。\n\n首先安装 Istio 并配置 [网格选项](https:\/\/chatgpt.com\/docs\/reference\/config\/istio.mesh.v1alpha1\/) 以启用 Kyverno：\n\n\u0060\u0060\u0060bash\nistioctl install -y -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n    accessLogFormat: |\n      [KYVERNO DEMO] my-new-dynamic-metadata: \u0027%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%\u0027\n    extensionProviders:\n    - name: kyverno-authz-server\n      envoyExtAuthzGrpc:\n        service: kyverno-authz-server.kyverno.svc.cluster.local\n        port: \u00279081\u0027\nEOF\n\u0060\u0060\u0060\n\n请注意，配置中定义了一个指向 Kyverno Authz Server 的 \u0060extensionProviders\u0060 部分：\n\n\u0060\u0060\u0060yaml\n[...]\n    extensionProviders:\n    - name: kyverno-authz-server\n      envoyExtAuthzGrpc:\n        service: kyverno-authz-server.kyverno.svc.cluster.local\n        port: \u00279081\u0027\n[...]\n\u0060\u0060\u0060\n\n### 部署 Kyverno Authz Server\n\nKyverno Authz Server 是一个支持处理 Envoy 外部授权请求的 GRPC 服务。它可以通过集群内存储的 Kyverno \u0060AuthorizationPolicy\u0060 资源或外部提供的资源进行配置。\n\n\u0060\u0060\u0060bash\nkubectl create ns kyverno\nkubectl label namespace kyverno istio-injection=enabled\nhelm install kyverno-authz-server --namespace kyverno --wait --repo https:\/\/kyverno.github.io\/kyverno-envoy-plugin kyverno-authz-server\n\u0060\u0060\u0060\n\n### 部署示例应用\n\n\u0060httpbin\u0060 是一个著名的应用程序，可用于测试 HTTP 请求，帮助快速展示如何操作请求和响应属性。\n\n\u0060\u0060\u0060bash\nkubectl create ns my-app\nkubectl label namespace my-app istio-injection=enabled\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/httpbin\/httpbin.yaml -n my-app\n\u0060\u0060\u0060\n\n### 部署 Istio AuthorizationPolicy\n\n\u0060AuthorizationPolicy\u0060 定义了将由 Kyverno Authz Server 保护的服务。\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: my-kyverno-authz\n  namespace: istio-system # 将策略应用于整个网格，istio-system 为网格根命名空间\nspec:\n  selector:\n    matchLabels:\n      ext-authz: enabled\n  action: CUSTOM\n  provider:\n    name: kyverno-authz-server\n  rules: [{}] # 空规则，将应用于具有 ext-authz: enabled 标签的选择器\nEOF\n\u0060\u0060\u0060\n\n资源中定义了前面 Istio 配置中设置的 Kyverno Authz Server \u0060extensionProvider\u0060：\n\n\u0060\u0060\u0060yaml\n[...]\n  provider:\n    name: kyverno-authz-server\n[...]\n\u0060\u0060\u0060\n\n### 给应用打标签以强制执行策略\n\n为应用打标签，以便 Istio 的 \u0060AuthorizationPolicy\u0060 对示例应用的 Pods 生效：\n\n\u0060\u0060\u0060bash\nkubectl patch deploy httpbin -n my-app --type=merge -p=\u0027{\n  \u0022spec\u0022: {\n    \u0022template\u0022: {\n      \u0022metadata\u0022: {\n        \u0022labels\u0022: {\n          \u0022ext-authz\u0022: \u0022enabled\u0022\n        }\n      }\n    }\n  }\n}\u0027\n\u0060\u0060\u0060\n\n### 部署 Kyverno AuthorizationPolicy\n\nKyverno 的 \u0060AuthorizationPolicy\u0060 定义了 Kyverno Authz Server 根据给定的 Envoy [CheckRequest](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto#service-auth-v3-checkrequest) 做出决策的规则。\n\n策略使用 [CEL 语言](https:\/\/github.com\/google\/cel-spec) 分析传入的 \u0060CheckRequest\u0060，并生成相应的 [CheckResponse](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto#service-auth-v3-checkresponse)。\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  failurePolicy: Fail\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.?headers[\u0022x-force-authorized\u0022].orValue(\u0022\u0022)\n  - name: allowed\n    expression: variables.force_authorized in [\u0022enabled\u0022, \u0022true\u0022]\n  authorizations:\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\nEOF\n\u0060\u0060\u0060\n\n在此配置中，你可以使用 CEL 辅助函数如 \u0060envoy.Allowed()\u0060 和 \u0060envoy.Denied(403)\u0060 来简化响应消息的创建：\n\n\u0060\u0060\u0060yaml\n[...]\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\n[...]\n\u0060\u0060\u0060\n\n## 工作原理\n\n在应用 \u0060AuthorizationPolicy\u0060 后，Istio 控制平面（istiod）将所需配置发送到策略中选定服务的 Sidecar 代理（Envoy）。Envoy 将请求发送到 Kyverno Authz Server，以检查是否允许请求。\n\n![工作原理](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/overview.svg)\n\nEnvoy 通过配置过滤器链工作，其中一个过滤器是 \u0060ext_authz\u0060，它实现了使用特定消息的外部授权服务。任何实现正确 Protobuf 的服务器都可以连接到 Envoy 代理并提供授权决策；Kyverno Authz Server 就是其中之一。 \n\n![工作原理](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/filters-chain.svg)\n\n查看 [Envoy 授权服务文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto)，你可以看到该消息具有以下属性：\n\n- Ok 响应：\n\n  \u0060\u0060\u0060json\n  {\n    \u0022status\u0022: {...},\n    \u0022ok_response\u0022: {\n      \u0022headers\u0022: [],\n      \u0022headers_to_remove\u0022: [],\n      \u0022response_headers_to_add\u0022: [],\n      \u0022query_parameters_to_set\u0022: [],\n      \u0022query_parameters_to_remove\u0022: []\n    },\n    \u0022dynamic_metadata\u0022: {...}\n  }\n  \u0060\u0060\u0060\n\n- 拒绝的响应：\n\n  \u0060\u0060\u0060json\n  {\n    \u0022status\u0022: {...},\n    \u0022denied_response\u0022: {\n      \u0022status\u0022: {...},\n      \u0022headers\u0022: [],\n      \u0022body\u0022: \u0022...\u0022\n    },\n    \u0022dynamic_metadata\u0022: {...}\n  }\n  \u0060\u0060\u0060\n\n这意味着，根据授权服务器的响应，Envoy 可以添加或删除标头、查询参数，甚至可以更改响应主体。\n\n我们也可以这样做，如[ Kyverno 授权服务器文档](https:\/\/kyverno.github.io\/kyverno-envoy-plugin)中所记载的那样。\n\n### 测试\n\n我们将先测试简单的授权场景，然后创建一个更高级的策略，展示如何使用 Kyverno Authz Server 修改请求和响应。\n\n#### 部署一个测试应用\n\n部署一个可以向 \u0060httpbin\u0060 示例应用运行 \u0060curl\u0060 命令的应用程序：\n\n\u0060\u0060\u0060bash\nkubectl apply -n my-app -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/curl\/curl.yaml\n\u0060\u0060\u0060\n\n#### 应用策略\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  failurePolicy: Fail\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.?headers[\u0022x-force-authorized\u0022].orValue(\u0022\u0022)\n  - name: allowed\n    expression: variables.force_authorized in [\u0022enabled\u0022, \u0022true\u0022]\n  authorizations:\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\nEOF\n\u0060\u0060\u0060\n\n简单的场景是：如果请求包含标头 \u0060x-force-authorized\u0060 且其值为 \u0060enabled\u0060 或 \u0060true\u0060，则允许请求。如果标头不存在或值不匹配，则拒绝请求。\n\n在这个示例中，我们将允许和拒绝的处理逻辑结合到一个表达式中。但是，你也可以使用多个表达式，第一个返回非空响应的表达式将被 Kyverno Authz Server 使用，这种方法在某些规则不想做决策并将决策权委托给下一个规则时非常有用：\n\n\u0060\u0060\u0060yaml\n[...]\n  authorizations:\n  # 如果标头值匹配，则允许请求\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : null\n  # 否则拒绝请求\n  - expression: \u003e\n      envoy.Denied(403).Response()\n[...]\n\u0060\u0060\u0060\n\n### 简单规则\n\n以下请求将返回 \u0060403\u0060：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get\n\u0060\u0060\u0060\n\n以下请求将返回 \u0060200\u0060：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n### 高级操作\n\n接下来展示更高级的用例，应用以下策略：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.headers[?\u0022x-force-authorized\u0022].orValue(\u0022\u0022) in [\u0022enabled\u0022, \u0022true\u0022]\n  - name: force_unauthenticated\n    expression: object.attributes.request.http.headers[?\u0022x-force-unauthenticated\u0022].orValue(\u0022\u0022) in [\u0022enabled\u0022, \u0022true\u0022]\n  - name: metadata\n    expression: \u0027{\u0022my-new-metadata\u0022: \u0022my-new-value\u0022}\u0027\n  authorizations:\n    # 如果 force_unauthenticated 为真，则返回 401\n  - expression: \u003e\n      variables.force_unauthenticated\n        ? envoy\n            .Denied(401)\n            .WithBody(\u0022Authentication Failed\u0022)\n            .Response()\n        : null\n    # 如果 force_authorized 为真，则返回 200\n  - expression: \u003e\n      variables.force_authorized\n        ? envoy\n            .Allowed()\n            .WithHeader(\u0022x-validated-by\u0022, \u0022my-security-checkpoint\u0022)\n            .WithoutHeader(\u0022x-force-authorized\u0022)\n            .WithResponseHeader(\u0022x-add-custom-response-header\u0022, \u0022added\u0022)\n            .Response()\n            .WithMetadata(variables.metadata)\n        : null\n    # 否则返回 403\n  - expression: \u003e\n      envoy\n        .Denied(403)\n        .WithBody(\u0022Unauthorized Request\u0022)\n        .Response()\nEOF\n\u0060\u0060\u0060\n\n在该策略中，逻辑如下：\n\n- 如果请求包含标头 \u0060x-force-unauthenticated: true\u0060 或 \u0060x-force-unauthenticated: enabled\u0060，我们将返回 \u0060401\u0060，并包含响应正文 “Authentication Failed”。\n- 否则，如果请求包含标头 \u0060x-force-authorized: true\u0060 或 \u0060x-force-authorized: enabled\u0060，我们将返回 \u0060200\u0060，并操作请求标头、响应标头并注入动态元数据。\n- 在所有其他情况下，我们将返回 \u0060403\u0060，并包含响应正文 “Unauthorized Request”。\n\nKyverno Authz Server 将返回相应的 CheckResponse 给 Envoy 代理。Envoy 将使用这些值相应地修改请求和响应。\n\n#### 更改返回的响应正文\n\n让我们测试新功能。以下命令返回 \u0060403\u0060 并将响应正文改为 \u0022Unauthorized Request\u0022：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get\n\u0060\u0060\u0060\n\n输出如下：\n\n\u0060\u0060\u0060plaintext\nUnauthorized Request\nhttp_code=403\n\u0060\u0060\u0060\n\n#### 更改返回的响应正文和状态码\n\n使用标头 \u0060x-force-unauthenticated: true\u0060 测试请求：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-unauthenticated: true\u0022\n\u0060\u0060\u0060\n\n结果将返回 \u0022Authentication Failed\u0022 和状态码 \u0060401\u0060：\n\n\u0060\u0060\u0060plaintext\nAuthentication Failed\nhttp_code=401\n\u0060\u0060\u0060\n\n### 在请求中添加标头\n\n发送有效请求：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n响应中将包含新添加的标头 \u0060x-validated-by: my-security-checkpoint\u0060，并删除了标头 \u0060x-force-authorized\u0060：\n\n\u0060\u0060\u0060plaintext\n[...]\n    \u0022X-Validated-By\u0022: [\n      \u0022my-security-checkpoint\u0022\n    ]\n[...]\nhttp_code=200\n\u0060\u0060\u0060\n\n### 在响应中添加标头\n\n运行相同的请求，但仅显示响应标头：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -I -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n输出中将包含在 Authz 检查期间添加的响应标头 \u0060x-add-custom-response-header: added\u0060：\n\n\u0060\u0060\u0060plaintext\nHTTP\/1.1 200 OK\n[...]\nx-add-custom-response-header: added\n[...]\nhttp_code=200\n\u0060\u0060\u0060\n\n### 在过滤器之间共享数据\n\n最后，你可以通过 \u0060dynamic_metadata\u0060 将数据传递给后续的 Envoy 过滤器。这在你需要将数据传递给过滤链中的另一个 \u0060ext_authz\u0060 过滤器或希望在应用日志中打印数据时非常有用。\n\n![元数据](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/dynamic-metadata.svg)\n\n要实现这一点，请回顾之前设置的访问日志格式：\n\n\u0060\u0060\u0060plaintext\n[...]\n    accessLogFormat: |\n      [KYVERNO DEMO] my-new-dynamic-metadata: \u0022%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%\u0022\n[...]\n\u0060\u0060\u0060\n\n\u0060DYNAMIC_METADATA\u0060 是一个保留关键字，用于访问元数据对象，其余部分是你要访问的过滤器的名称。\n\n在我们的示例中，名称 \u0060envoy.filters.http.ext_authz\u0060 是由 Istio 自动生成的。你可以通过导出 Envoy 配置来验证这一点：\n\n\u0060\u0060\u0060bash\nistioctl pc all deploy\/httpbin -n my-app -oyaml | grep envoy.filters.http.ext_authz\n\u0060\u0060\u0060\n\n你将看到该过滤器的相关配置。\n\n现在测试动态元数据。在高级规则中，我们创建了一个新的元数据条目：\u0060{\u0022my-new-metadata\u0022: \u0022my-new-value\u0022}\u0060。\n\n运行请求并检查应用程序的日志：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -I httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060bash\nkubectl logs -n my-app deploy\/httpbin -c istio-proxy --tail 1\n\u0060\u0060\u0060\n\n你将在输出中看到由 Kyverno 策略配置的新属性：\n\n\u0060\u0060\u0060plaintext\n[...]\n[KYVERNO DEMO] my-new-dynamic-metadata: \u0027{\u0022my-new-metadata\u0022:\u0022my-new-value\u0022,\u0022ext_authz_duration\u0022:5}\u0027\n[...]\n\u0060\u0060\u0060\n\n## 结论\n\n在本指南中，我们展示了如何将 Istio 与 Kyverno Authz Server 集成以在简单的微服务应用程序中强制执行策略。我们还展示了如何使用策略修改请求和响应的属性。\n\n这是构建企业级策略系统的基础示例，适用于所有应用团队。通过这一系统，策略可以快速部署，并为安全团队提供所需的审计和合规数据。\n\n如需深入了解，请参考 [Kyverno Authz Server 文档](https:\/\/kyverno.github.io\/kyverno-envoy-plugin)。如果你希望更详细地了解实现过程或示例用例，可以随时联系我们！\n', '\/trans\/authz-policy-with-kyverno\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">使用 Kyverno 的 Authz Server 代理 Layer 7 授权决策逻辑，并基于 CEL 编写策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/leveraging-envoypatchpolicy-to-extend-the-capabilities-of-envoy-gateway/">利用 EnvoyPatchPolicy 拓展 Envoy Gateway 的能力</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-eu-2025-london-recap/">KubeCon EU 2025 参会报告：塑造云原生格局的洞察与趋势</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
