<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/02/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式：图解及概念解读', '本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。', '\nIstio 的 Ambient 模式是一种创新的、无 Sidecar 的服务网格部署方式，通过 ztunnel 和 waypoint proxy 分离数据平面功能，简化了操作并降低了资源消耗。本篇博客将通过一份详细的术语表，帮助你更好地理解 Istio Ambient 模式中的关键概念及其背后的技术实现。\n\n## Ambient 模式\n\n![Ambient 模式架构图](ambient-mode-architecture.svg)\n\n  - **定义**：Istio 的一种无 Sidecar 的数据平面模式，通过 ztunnel 和 waypoint proxy 实现服务之间的安全通信和管理。相较于 Sidecar 模式，Ambient 模式更加轻量，降低了资源消耗并简化了配置。\n  - **架构**：数据平面功能分为 L4 层的安全覆盖层（由 ztunnel 提供）和 L7 层的策略处理层（由 waypoint proxy 提供）。\n\n## 控制平面与数据平面\n\n![控制平面与数据平面](control-plane-and-data-plane.svg)\n\n  - **定义**：在 Ambient 模式中，控制平面（\u0060istiod\u0060）负责管理集群内 ztunnel 和 waypoint proxy 的配置和策略，而数据平面由 ztunnel 和 waypoint proxy 组成，负责处理实际的网络流量。\n  - **组件交互**：ztunnel 使用 xDS APIs 从 \u0060istiod\u0060 获取配置并执行策略，管理 Pod 之间的 L4 和 L7 流量。\n\n## Istio Control Plane (\u0060istiod\u0060)\n\n  - **定义**：Istio 的控制平面组件，负责与 ztunnel 和 waypoint proxy 通信，提供 xDS 接口用于动态配置。\n  - **功能**：\u0060istiod\u0060 使用 xDS APIs 进行配置推送，动态管理 Ambient 模式中的流量策略、证书分发以及与 Kubernetes 集群的交互。\n\n## 透明性与非侵入性\n\n  - **定义**：Ambient 模式的架构旨在减少对应用的侵入性，应用无需感知数据平面的存在，Pod 无需重启或注入 Sidecar 即可加入网格。\n  - **优势**：提高了服务网格的灵活性，降低了操作复杂度，使应用和基础设施的生命周期更加解耦。\n\n## Sidecar Proxy\n\n![Sidecar 模式](sidecar-mode.svg)\n\n  - **定义**：传统 Istio 中的 Envoy 代理，与应用容器共同部署在一个 Pod 中。\n  - **问题**：对应用具有侵入性，Sidecar 必须在 Pod 中注入并伴随应用运行，增加了资源开销，并且使应用与代理的生命周期耦合。\n\n## Ztunnel (Zero-Trust Tunnel)\n\n![ztunnel](ztunnel.svg)\n\n  - **定义**：Ambient 模式中的关键组件，部署为 DaemonSet，为每个节点提供 L4 层的零信任隧道。\n  - **功能**:\n    - **安全**：提供 mTLS 加密和基于 SPIFFE ID 的身份验证，确保节点和工作负载之间的安全通信。\n    - **可观测性**：收集 L4 层的 TCP 指标和日志。\n    - **连接多路复用和均衡**：在节点之间建立安全的流量隧道，以优化连接和网络性能。\n    - **多租户架构**：单个 ztunnel 可以代表同一节点上的多个工作负载进行 L4 数据平面功能处理，这与每个应用 Pod 拥有自己代理的 Sidecar 模式形成对比。\n    - **证书管理**：ztunnel 代表节点内的所有 Pod 从 Istio 控制平面 (\u0060istiod\u0060) 获取 mTLS 证书，并负责证书的管理和轮换。\n  - **接口**:\n    - **\u0060pistioin\u0060 和 \u0060pistioout\u0060**：用于与节点上的 \u0060istioin\u0060 和 \u0060istioout\u0060 接口通过 GENEVE 隧道连接。\n\n## Waypoint Proxy\n\n![Waypoint Proxy](waypoint-proxy.svg)\n\n  - **定义**：Ambient 模式中的 L7 层代理，部署在每个命名空间级别，用于处理 L7 层请求。\n  - **功能**：提供 L7 授权策略，如基于 HTTP headers 的访问控制、L7 级别的遥测等。Waypoint Proxy 只处理需要的 L7 代理流量，其他 L4 流量由 ztunnel 处理。\n\n## GENEVE 隧道 (Generic Network Virtualization Encapsulation)\n\n![GENEVE 协议组成](geneve.svg)\n\n  - **定义**：用于在 Kubernetes 节点之间建立虚拟隧道连接，将流量从节点上的 Pod 转发到 ztunnel。\n  - **在 Ambient 模式中的应用**：GENEVE 隧道用于连接节点上的虚拟网络接口（\u0060istioin\u0060 和 \u0060istioout\u0060）与 ztunnel 内的接口（\u0060pistioin\u0060 和 \u0060pistioout\u0060）。\n\n## HBONE (HTTP-Based Overlay Network Environment)\n\n![HBONE 数据包格式](hbone.svg)\n\n\u003c!--\n\u0060\u0060\u0060\n\u002b-----------------\u002b\n|    IP Header    | \u003c-- 源 IP，目标 IP，协议类型\n\u002b-----------------\u002b\n|    TCP Header   | \u003c-- 源端口，目标端口，序列号，确认号，标志位等\n\u002b-----------------\u002b\n|    TLS Header   | \u003c-- 握手消息，证书，加密应用数据\n\u002b-----------------\u002b\n| HTTP\/2 \u0026 CONNECT| \u003c-- HTTP 方法，目标地址，请求头，路径等\n\u002b-----------------\u002b\n|  Application    | \u003c-- 应用层数据，字节流，例如 HTTP 请求\n\u002b-----------------\u002b\n\u0060\u0060\u0060\n--\u003e\n\n  - **定义**：Istio 特有的安全隧道协议，用于在 Ambient 模式组件之间传输数据。HBONE 是一种基于 HTTP\/2 和 HTTP CONNECT 建立的安全 mTLS 加密通道。\n  - **实现方式**：通过 HTTP\/2 进行多路复用，通过 HTTP CONNECT 建立隧道，并使用 mTLS 确保安全性。详见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## Istioin 和 Istioout 虚拟接口\n\n![Ambient 模式中两个位于两个不同节点上的 Pod 访问路径](ambient-ztunnel-routing.svg)\n\n  - **定义**：由 Istio CNI 插件在每个节点上配置的两个虚拟接口，用于处理进入和离开节点的流量。\n  - **功能**：\u0060istioin\u0060 处理进入节点的流量，\u0060istioout\u0060 处理离开节点的流量。两者通过 GENEVE 隧道连接到 ztunnel 中相应的接口。\n\n## iptables 和流量重定向\n\n  - **定义**：用于配置 Linux 内核中的流量规则，将来自 Ambient 工作负载的流量进行重定向和标记。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件通过 iptables 规则，将流量标记并重定向到 \u0060istioin\u0060 或 \u0060istioout\u0060，然后通过 GENEVE 隧道传递给 ztunnel。\n\n## 流量拦截与重定向 (Traffic Redirection)\n\n  - **定义**：Ambient 模式中，ztunnel 负责透明拦截所有进出 \u0022in-mesh\u0022 Pod 的流量并将其加密后重定向到其他节点上的目标 Pod，确保网络流量符合服务网格的安全策略。\n  - **机制**：通过 Istio CNI 插件安装的 iptables 规则或 eBPF 程序，ztunnel 能够透明地捕获工作负载的流量，并在不改变客户端应用的情况下进行安全代理。\n\n## 流量路径分类\n\n  - **Out of Mesh**：Pod 没有加入服务网格，流量不会被 Ambient 数据平面处理。\n  - **In Mesh**：Pod 被纳入 Ambient 数据平面，L4 层的流量被 ztunnel 拦截和处理，提供 L4 授权和安全加密。\n  - **In Mesh, Waypoint Enabled**：Pod 被纳入 Ambient 数据平面且启用了 waypoint proxy，L7 层的流量通过 waypoint 进行高级策略处理。\n\n## TPROXY\n\n![TPROXY 作为透明代理，客户端和服务端都对其无感知](tproxy.svg)\n\n  - **定义**：Linux 内核功能，用于透明拦截和重定向网络流量。\n  - **在 Ambient 模式中的应用**：ztunnel 使用 TPROXY 来拦截和处理流量，保留原始源 IP 和端口信息，从而实现透明代理功能。\n\n## Mutual TLS (mTLS)\n\n![Istio 中的安全身份架构（以 Sidecar 模式为例）](istio-mtls-process.svg)\n\n  - **定义**：一种双向 TLS 认证机制，确保通信双方的身份验证和数据加密。\n  - **在 Ambient 模式中的应用**：通过 ztunnel 和 waypoint proxy 确保工作负载之间的 mTLS 加密，实现零信任安全。\n\n详见 [如何理解 Istio 中的 MTLS 流量加密？](\/blog\/understanding-the-tls-encryption-in-istio\/)\n\n## SPIFFE ID\n\n![SPIFFE ID 格式](spiffe.svg)\n\nIstio 服务网格中所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式：\u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n  - **定义**：用于标识工作负载的身份标识符，在服务网格中用于身份管理。\n  - **在 Ambient 模式中的应用**：SPIFFE ID 被用于对节点和工作负载进行身份验证，以确保网络通信的安全性。\n\n详见 [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n\n## eBPF (Extended Berkeley Packet Filter)\n\n  - **定义**：eBPF 是 Linux 内核中的一种技术，用于在内核空间中运行沙盒程序，实现网络数据包处理等功能。\n  - **在 Ambient 模式中的应用**：eBPF 可以替代传统的 iptables 和 GENEVE 隧道，用于流量重定向和管理。eBPF 更高效、复杂度更低且易于管理。\n  - **eBPF 程序**:\n    - 应用入站\n    - 应用出站\n    - Ztunnel 主机入站\n    - Ztunnel 入站\n  - **作用**：Istio CNI 使用 eBPF 程序将它们挂载在特定的 TC 点，用于处理应用和 ztunnel 的网络流量。\n\n## Waypoint Proxy 的弹性扩展\n\n![Waypoing Proxy 作为 Deployment 部署在 Kubernetes 中](ambient-waypoint-proxy-scale.svg)\n\n  - **定义**：在 Ambient 模式中，waypoint proxy 可以根据流量需求动态扩展，而无需为每个工作负载实例部署独立代理。\n  - **优势**：通过动态扩展 waypoint proxy，可以降低基础设施成本并提高资源利用率。\n\n## Ztunnel 的弹性和故障恢复\n\n  - **定义**：ztunnel 部署为 DaemonSet，如果 ztunnel 容器失效，Kubernetes 会自动重新调度，以确保节点流量的继续处理。\n  - **特点**：使得故障的影响范围最小化，仅影响该节点上的工作负载。\n\n## IP Set 和 ztunnel-pods-ips\n\n  - **定义**：IP Set 是用于存储 IP 地址的工具，\u0060ztunnel-pods-ips\u0060 是每个节点上用于存储 Ambient 网格 Pod IP 的集合。\n  - **在 Ambient 模式中的应用**：Istio CNI 插件会将每个加入 Ambient 网格的 Pod IP 添加到 \u0060ztunnel-pods-ips\u0060 中，以确保这些 Pod 的流量可以被 iptables 规则识别和处理。\n\n## 连接多路复用 (Connection Multiplexing)\n\n  - **定义**：在单个物理连接中传输多条逻辑连接的技术。\n  - **在 Ambient 模式中的应用**：ztunnel 实现了连接多路复用，使多个工作负载可以共享相同的连接，提升网络效率。\n\n## 节点网络的虚拟接口对 (veth)\n\n  - 定义：每个 Pod 在运行时会在节点上创建一个虚拟接口对，用于将 Pod 的网络连接到节点的网络。\n  - 在 Ambient 模式中的应用：veth 接口用于将 Pod 的流量连接到节点的虚拟接口（如 \u0060istioin\u0060 和 \u0060istioout\u0060），从而将流量引导至 ztunnel 进行处理。\n\n## Waypoint Proxy 的流量路径\n\n![Waypoint Proxy 的流量路径](waypoint-proxy-routing.svg)\n\n  - **定义**：Waypoint Proxy 只参与服务器端的流量路径，作为 L7 代理执行服务端的请求。\n  - **应用场景**：当部署了 Waypoint Proxy 时，来自同一服务账户的工作负载将通过 ztunnel 重定向至 Waypoint Proxy 进行处理，然后到达目标 Pod，确保 L7 级别的策略和认证得以执行。\n\n## Istio CNI (Container Network Interface)\n\n- **定义**：Istio 的容器网络接口插件，用于在 Kubernetes 集群中自动配置流量拦截规则。\n- **功能**：Istio CNI 负责为每个新创建或加入网格的 Pod 设置必要的网络重定向规则。它通过修改 iptables 规则或应用 eBPF 程序来确保所有流量能够被 ztunnel 或 waypoint proxy 拦截和处理，从而实现服务网格的透明流量管理。\n- **Istio CNI Node Agent**：Istio CNI Node Agent 负责在每个节点上安装 Istio CNI 插件，并更新节点的 CNI 配置，确保当 Pod 加入服务网格时能够正确地配置流量重定向规则。在 Sidecar 模式中，CNI 插件通过 iptables 配置 Pod 的网络。在 Ambient 模式中，CNI 插件负责将新的 Pod 事件推送到 Ambient 监控服务器，以便配置 Pod 的网络重定向规则。\n\n## 总结\n\nIstio Ambient 模式通过将数据平面功能分为 L4 和 L7 层的独立组件，为用户提供了更轻量且灵活的服务网格解决方案。这种方式不仅简化了服务的部署，还大幅降低了资源开销。通过术语表的方式，我们探讨了 Ambient 模式中的各种核心概念，从 ztunnel 到 waypoint proxy，再到 iptables 和 eBPF 的使用，帮助你全面了解 Istio Ambient 模式的架构和运行机制。如果你对服务网格感兴趣或正在考虑如何优化微服务通信，希望这篇文章对你有所帮助。\n', '\/blog\/istio-ambient-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文通过一份详细的 Istio Ambient 模式的术语表，帮助你更好地理解其中的关键概念及其背后的技术实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 实现 HTTP\/2 CONNECT 隧道：原理与实践', '深入讲解如何利用 HTTP\/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。', '\n在最近对 Istio Ambient 模式的研究中，我发现 HTTP2 Connect 方法被用作创建隧道的核心技术，以实现透明流量的拦截和转发。HTTP\/2 CONNECT 隧道是一种强大的工具，可以在已有的 HTTP\/2 连接中创建高效的隧道，用于传输原始的 TCP 数据。这篇文章通过一个简单的 Demo，展示了如何使用 Envoy 来实现 HTTP\/2 CONNECT 隧道的基本功能。\n\n## 什么是 HTTP2 Connect 方法以及 HBONE 隧道？\n\nHTTP2 Connect 方法是一种标准化的方式来创建隧道，用于透明地传输数据。特别是在 Istio 的 Ambient 模式中，它为代理数据平面之间的通信提供了一种高效的手段。HBONE（HTTP-Based Overlay Network Environment）隧道则是基于这种 HTTP2 Connect 技术的实现，用于 Istio 中的透明流量拦截和转发。通过使用 HBONE，数据可以有效地通过 HTTP2 隧道安全传输，替代了传统的 Sidecar 模式。这一创新设计极大地简化了服务网格的管理和部署。\n\nHBONE 是 Istio 特有的术语，它是一种安全隧道协议，用于在 Istio 组件之间进行通信。在当前的 Istio 实现中，HBONE 协议包含了三个开放标准：\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT 用于建立隧道连接，mTLS 用于安全地加密连接，而 HTTP\/2 用于在单一安全隧道中多路复用应用连接流并传输附加的流级元数据。更多关于 HBONE 隧道的细节可以参考官方文档：[HBONE 详细介绍](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)。\n\n## 使用 HTTP2 Connect 建立隧道的基本原理\n\nHTTP2 Connect 方法允许我们创建一个类似于 VPN 的隧道，通过这个隧道可以安全地传递数据。建立隧道的基本步骤如下：\n\n1. 首先，客户端向代理发送一个普通的 TCP 或 HTTP 链接请求。\n2. 代理接收到请求后，代表客户端向目标服务器发送一个带有 CONNECT 方法的 HTTP2 请求。\n3. 如果服务器允许建立隧道，那么它会返回一个 HTTP2 200 OK 的响应给代理。\n5. 随后，客户端、代理和服务器之间的双向流数据就可以通过这个隧道进行传输。\n\n这种方法能够使得数据的传输过程更加透明且安全，特别适用于需要高效通信和端到端加密的场景。\n\n下图展示了 HTTP2 Connect 方法建立隧道的基本过程。\n\n\u0060\u0060\u0060mermaid \u0022HTTP2 Connect 方法建立隧道的基本过程\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: 普通 TCP 请求\n    Proxy-\u003e\u003eServer: 发送 CONNECT 请求 (HTTP2 CONNECT)\n    Server--\u003e\u003eProxy: 返回 200 OK 响应\n    Proxy--\u003e\u003eClient: 转发 200 OK 响应\n    Client-\u003e\u003eProxy: 开始传输数据\n    Proxy-\u003e\u003eServer: 转发数据\n    Server-\u003e\u003eProxy: 返回处理后的数据\n    Proxy-\u003e\u003eClient: 转发处理后的数据\n\u0060\u0060\u0060\n\n![HTTP2 Connect 方法建立隧道的基本过程](1f4003a92425618f8bf5b9c1403169a7.svg)\n\n## Demo：使用 Envoy 与上游 Server 建立 HTTP\/2 Connect 隧道\n\n本示例展示了一个基础场景：\n\n1. **客户端**：向 Envoy 代理发送文本消息。\n2. **Envoy**：接收客户端的 TCP 数据，将其封装为 HTTP\/2 CONNECT 请求，并与上游服务器建立加密隧道。\n3. **服务器**：接收来自 Envoy 的 HTTP\/2 CONNECT 流量，解封装并返回响应给客户端。\n\n架构图如下：\n\n\u0060\u0060\u0060mermaid \u0022架构图\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![架构图](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n我们将使用 Node.js 来编写客户端和服务端，并将服务端和 Envoy 代理运行在容器中，在本地通过客户端访问 Envoy 代理从而达到访问客户端的目的。\n\n完整的目录结构如下：\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### 核心功能展示\n\n#### **1. HTTP\/2 CONNECT 隧道的基本实现**\n\n- 客户端通过普通的 TCP 连接与 Envoy 通信。\n- Envoy 将 TCP 数据封装为 HTTP\/2 CONNECT 请求，发送到上游服务器。\n- 服务器接收并解封装隧道中的数据，进行处理后返回响应。\n- 隧道通信对客户端完全透明。\n\n#### **2. Envoy 的透明代理能力**\n\n- Envoy 作为中间代理，将客户端与服务器之间的通信逻辑完全封装。\n- 客户端无需支持复杂的协议（如 HTTP\/2 或 TLS），Envoy 代理完成所有协议转换。\n\n#### **3. 加密通信的实现**\n\n- Envoy 与服务器之间的通信通过 TLS 加密，确保隧道内的数据安全。\n- 服务器终止 TLS，处理解密后的数据。\n\n#### **4. 隧道的简化使用场景**\n\n- 通过该 Demo，可以快速理解 HTTP\/2 CONNECT 隧道的建立和基本数据传输流程。\n\n### 环境准备\n\n#### 1. 安装 Node.js\n\n确保你的系统已安装 **Node.js**（版本 \u003e= **10.10.0**），因为 \u0060http2\u0060 模块在该版本后稳定。\n\n- **下载链接：** [Node.js 官方网站](https:\/\/nodejs.org\/)\n\n#### 2. 安装 Docker 和 Docker Compose\n\n- **Docker 下载链接：** [Docker 官方网站](https:\/\/www.docker.com\/get-started)\n- **Docker Compose 下载链接：** [Docker Compose 官方文档](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. 创建项目目录\n\n在你的工作空间中创建一个新目录并进入：\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### 生成自签名证书\n\n由于 Envoy 和服务器之间需要加密通信，我们需要生成包含正确配置的自签名证书。\n\n#### 1. 创建证书目录和 OpenSSL 配置文件\n\n创建 \u0060certs\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\n创建 \u0060openssl.cnf\u0060，内容如下：\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. 生成密钥和证书\n\n运行以下命令生成密钥和证书：\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\n这将在 \u0060certs\u0060 目录中生成 \u0060server.key\u0060 和 \u0060server.crt\u0060 文件。\n\n### 配置 Envoy 代理\n\n我们需要配置 Envoy，使其能够接受客户端的普通 TCP 连接，将数据通过 HTTP\/2 CONNECT 隧道传递给服务器。\n\n#### 1. 创建 Envoy 配置文件\n\n在项目根目录创建 \u0060envoy.yaml\u0060，内容如下：\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. 关键点\n\n- **Envoy 监听 TCP 连接**，将流量通过 **HTTP\/2 CONNECT 隧道**转发到服务器。\n- **客户端**只需与 **Envoy** 建立 TCP 连接，发送文本消息。\n- **Envoy**负责隧道的建立和加密，**客户端**无需感知。\n\n### 实现服务器\n\n#### 1. 创建服务器目录和文件\n\n在项目根目录创建 \u0060server\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\n在 \u0060server\u0060 目录中创建 \u0060server.js\u0060 和 \u0060Dockerfile\u0060。\n\n#### 2. 编写 \u0060server.js\u0060\n\n在 \u0060server\/server.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ 响应 200，建立隧道\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ 在隧道内处理数据\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ 回应客户端\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ 对于非 CONNECT 请求，返回 404\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**注意：**\n\n- 监听 \u0060secureConnection\u0060 事件，直接处理 TLS 连接后的 socket。\n- 在 socket 上接收数据，处理来自客户端的文本消息，并回复。\n\n#### 3. 创建 \u0060Dockerfile\u0060\n\n在 \u0060server\/Dockerfile\u0060 中添加以下内容：\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### 实现客户端\n\n#### 1. 创建客户端目录和文件\n\n在项目根目录创建 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\n在 \u0060client\u0060 目录中创建 \u0060client.js\u0060。\n\n#### 2. 编写 \u0060client.js\u0060\n\n在 \u0060client\/client.js\u0060 中添加以下代码：\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ 创建与 Envoy 的 TCP 连接\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ 发送消息给服务器\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ 关闭连接\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**说明：**\n\n- **客户端**与 **Envoy** 建立普通的 TCP 连接，发送文本消息。\n- 该客户端的存在只是为了触发 Envoy 与服务器建立隧道。\n\n### 创建 Docker Compose 文件\n\n在项目根目录创建 \u0060docker-compose.yml\u0060：\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # 挂载证书目录\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # 挂载证书目录\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\n### 运行示例\n\n#### 1. 启动 Docker Compose\n\n在项目根目录下，运行：\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**预期输出：**\n\n- **Envoy 容器：** 显示启动信息和调试日志。\n- **服务器容器：** 显示 \u0060Secure HTTP\/2 server is listening on port 8080\u0060。\n\n#### 2. 运行客户端\n\n打开新的终端窗口，进入 \u0060client\u0060 目录：\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\n运行客户端：\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**预期输出：**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. 检查服务器日志\n\n在 Docker Compose 的输出中，你应该能看到服务器的日志：\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. 检查 Envoy 日志\n\n在 Envoy 的日志中，你可以看到它使用 **HTTP\/2 CONNECT 隧道**与服务器建立连接的记录。\n\n### 测试通信\n\n- **客户端**通过 TCP 连接向 **Envoy 代理**发送文本消息。\n- **Envoy**将客户端的 TCP 流量通过 **HTTP\/2 CONNECT 隧道**转发给 **服务器**。\n- **服务器**接收到来自客户端的消息，处理并回复。\n- **Envoy**将服务器的回复通过隧道传回给 **客户端**。\n- **客户端**收到服务器的回复。\n\n### 注意事项\n\n- **证书管理：** 确保证书正确配置，并在 Envoy 和服务器中正确使用。\n- **Docker 网络：** 使用 Docker Compose 定义的网络，容器可以通过服务名称互相通信。\n- **端口冲突：** 确保端口 \u006010000\u0060（Envoy）和 \u00608080\u0060（服务器）未被占用。\n- **TLS 配置：** 在示例中，Envoy 与服务器之间的通信使用 TLS 和 HTTP\/2，确保了安全性。\n\n## 隧道建立过程\n\n下图展示了客户端、Envoy 代理和服务器之间的交互，反映了数据的传递和隧道连接的建立的流程。\n\n\u0060\u0060\u0060mermaid \u0022隧道建立流程\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% 客户端与 Envoy 建立 TCP 连接\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy 创建新的 TCP 代理会话\nNote over Envoy: 创建新的 TCP 代理会话 (ConnectionId: 0)\n\n%% Envoy 创建到上游服务器的连接\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: 尝试创建新的连接 (ConnectionId: 1)\n\n%% Envoy 与服务器建立 HTTP\/2 连接\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy 通过 HTTP\/2 CONNECT 建立隧道\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: 隧道建立成功\n\n%% 客户端发送数据\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% 客户端关闭连接\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: 隧道关闭\nNote over Envoy,Client: 连接关闭\n\n%% 连接关闭日志\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![隧道建立流程](f426fb19b797e505aed4758bdc372f45.svg)\n\n说明：\n\n1. **客户端与 Envoy 建立 TCP 连接**：\n    - 客户端向 Envoy 发起 TCP 连接请求。\n    - Envoy 接受连接，建立新的 TCP 代理会话（ConnectionId: 0）。\n2. **Envoy 创建到服务器的连接**：\n\n    - Envoy 尝试连接上游集群 \u0060tunnel_cluster\u0060，创建新的连接（ConnectionId: 1）。\n3. **建立 HTTP\/2 CONNECT 隧道**：\n\n    - Envoy 与服务器建立 HTTP\/2 连接。\n    - Envoy 发送 HTTP\/2 CONNECT 请求，目标主机名为 \u0060server:8080\u0060。\n    - 服务器响应 \u0060200 OK\u0060，隧道建立成功。\n4. **数据传输**：\n\n    - **消息传递循环**：\n        - 客户端发送数据（\u0060Message N\u0060）到 Envoy。\n        - Envoy 将数据通过隧道转发给服务器。\n        - 服务器处理数据并返回响应（\u0060Echo Message N\u0060）给 Envoy。\n        - Envoy 将响应转发给客户端。\n    - **日志记录**：\n        - 服务器记录收到的消息，例如 \u0060Received from client: Message N from client!\u0060。\n5. **连接关闭**：\n\n    - 客户端发送 FIN 请求，通知关闭连接。\n    - Envoy 将 FIN 转发给服务器，关闭隧道。\n    - 服务器响应 ACK 确认关闭。\n    - Envoy 向客户端发送 ACK，完成连接关闭。\n6. **日志记录**：\n\n    - Envoy 记录连接关闭日志，包括 ConnectionId 和统计信息。\n    - 服务器记录日志，显示流已由客户端结束，例如 \u0060Stream ended by client.\u0060。\n\n## 结语\n\n虽然这是一个入门示例，但它为理解和进一步探索 HTTP\/2 CONNECT 隧道功能提供了坚实的基础。在下一篇博客中讲解通过两个 Envoy 代理实现的隧道，带你进一步了解 Istio ambient 模式中的 HBONE 透明隧道。\n\n## 参考\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n - [Istio Ambient 模式流量管理实现机制详解（一）- 赵化冰的博客 | Zhaohuabing Blog](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n', '\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入讲解如何利用 HTTP/2 CONNECT 方法创建隧道，涵盖技术原理、实践流程与示例代码。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的数据包生命周期及流量优化', '解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。', '\n本文围绕 Istio Ambient 模式下的数据包生命周期进行深入剖析，从初始数据包的流量拦截与目标解析，到后续数据包的快速转发与优化策略，帮助读者理解 Ambient 模式背后的技术逻辑和性能实践。\n\n## 数据包生命周期概览：从内核态到用户态\n\n在 Ambient 模式中，数据包的处理路径从 Pod 内核态网络栈开始，经由 \u0060iptables\u0060 规则被拦截后进入 ztunnel 的用户态处理逻辑。ztunnel 负责透明代理、策略验证、加密隧道建立等任务，最终将数据包通过内核态网络再次转发给目标服务或下一个 ztunnel。其核心思想是通过首次数据包的详细解析和标记，为后续数据包铺路，从而减少重复开销。\n\n下图展示了 Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期：\n\n\u0060\u0060\u0060mermaid \u0022Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期\u0022\nsequenceDiagram\n    participant App as 应用程序\n    participant PodKernel as Pod内核态网络栈\n    participant ipt as iptables\n    participant ztunnel as ztunnel 用户态处理\n    participant HostKernel as 主机内核态\n    participant Service as 目标服务或下一个 ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: 首个数据包路径\n    App-\u003e\u003ePodKernel: 发出首个数据包\n    PodKernel-\u003e\u003eipt: 检查iptables重定向规则\n    ipt-\u003e\u003eztunnel: 将数据包重定向至zTunnel透明代理端口\n    ztunnel-\u003e\u003eztunnel: 提取目标地址 \u0026 策略验证 \u0026 建立隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回处理后的数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: 后续数据包路径\n    App-\u003e\u003ePodKernel: 发出后续数据包\n    PodKernel-\u003e\u003ePodKernel: 利用 conntrack 匹配已有连接\n    PodKernel-\u003e\u003eztunnel: 数据包直接进入 ztunnel inbound socket（无需iptables重定向）\n    ztunnel-\u003e\u003eztunnel: 无需重复解析 \u0026 复用已有隧道\/连接\n    ztunnel-\u003e\u003eHostKernel: 返回数据包\n    HostKernel-\u003e\u003eService: 转发至目标服务或下一个 ztunnel\n    end\n\u0060\u0060\u0060\n\n![Istio Ambient 模式中从 Pod 到 ztunnel 的数据包生命周期](4c7d5e7ac5168314a5c5de34a39a4f9c.svg)\n\n接下来，我们将详细介绍首个数据包与后续数据包的处理路径，并分析其中的技术要点与优化手段。\n\n## 首个数据包路径：从拦截到目标解析\n\n当应用程序在 Pod 内发出数据包（如 HTTP 请求），数据包首先经过 Pod 的网络命名空间和内核态网络栈进行处理。\n\n### 透明拦截与目标解析\n\n\u0060iptables\u0060 规则对出站流量进行筛选，若发现目标地址为非本地资源且数据包未携带特定标记，则将数据包重定向至 ztunnel 的透明代理端口（如 \u006015006\u0060 或 \u006015008\u0060）。借助 \u0060IP_TRANSPARENT\u0060 和 \u0060SO_ORIGINAL_DST\u0060 选项，ztunnel 可提取数据包的原始目标地址，实现无缝透明代理。\n\n### 用户态处理：策略验证与加密隧道\n\n数据包进入 ztunnel 用户态后，将经历以下处理流程：\n\n1. **策略验证**：RBAC 验证、mTLS 加密判定。\n2. **目标流量处理**：对网格内部流量，通过 HTTP\/2 CONNECT 隧道（HBONE）加密与跨节点传输；对网格外流量，直接通过本地 TCP 连接透传。\n\n完成处理后，ztunnel 基于数据包解析结果建立出站连接（如 HTTP\/2 隧道或明文 TCP），并将数据包送回内核态，最终转发至目标服务或下一个 ztunnel。\n\n## 后续数据包路径：利用 Conntrack 与隧道复用\n\n首个数据包完成解析与策略验证后，Linux 内核的连接跟踪（\u0060conntrack\u0060）记录连接状态与标记。后续数据包无需再次经历复杂的拦截与解析，直接进入 ztunnel 的 inbound socket。\n\n### 连接跟踪与快速转发\n\n后续数据包基于 \u0060conntrack\u0060 跟踪机制，快速到达 ztunnel 的 inbound socket。ztunnel 可直接识别目标地址与安全策略，避免重复的解析与验证。\n\n### 隧道与明文连接优化\n\n1. **HBONE 隧道**：支持多路复用，提高加密流量处理效率。\n2. **明文连接**：对无需加密的流量，直接复用现有 TCP 连接，进一步减少处理开销。\n\n## 技术要点与优化策略\n\n- **透明代理**：利用 \u0060IP_TRANSPARENT\u0060 实现透明流量捕获与目标解析。\n- **内核与用户态高效协作**：首个数据包通过用户态完成深度处理，后续数据包借助 \u0060conntrack\u0060 与 inbound socket 实现快速转发，降低上下文切换成本。\n- **多路复用**：借助 HTTP\/2 隧道实现高效加密与负载均衡，优化传输性能。\n\n## 实践建议\n\n1. **多平台适配**：根据平台特性调整透明代理实现。\n2. **调优与监控**：结合 ztunnel 日志与服务网格监控工具，优化流量路径与性能表现。\n\n## 总结\n\nIstio Ambient 模式通过数据包生命周期设计，在透明代理、性能优化与安全策略间实现平衡。zTunnel 通过高效的用户态处理与内核态快速转发，将应用程序的透明体验与底层网络优化有效结合，助力服务网格的实践与推广。\n', '\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">解析 Istio Ambient 模式下初始数据包的详细处理与后续数据包的快速转发及流量优化策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-ambient-mode-ztunnel-shutdown/">[译] Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2025/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/ztunnel-shutdown/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中 Ztunnel 停止运行时的流量处理机制', '了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。', '\n关于 Istio 的 Ambient 模式，一个常见的问题是它如何在升级或重启期间处理流量。\n\n在 Sidecar 模型中，代理和应用程序是 1:1 的关系，这种情况下无需担心此类问题——代理在应用程序停止时会关闭，并在应用程序启动时加载最新版本。\n\n然而，Ambient 模式中，每个节点都有一个专用代理（“Ztunnel”），这意味着我们可能需要在应用程序运行时对其进行升级。\n\n## 停止运行的过程\n\nZtunnel 遵循标准的滚动更新流程。也就是说，当我们需要引入新版本时，会按照以下步骤进行：\n\n1. 启动新版本\n2. 当新版本准备就绪后，开始关闭旧版本\n3. 在一段时间内，两个版本会同时运行\n4. 最终，旧版本被关闭\n\n对于 Ztunnel，有两种类型的流量需要考虑：\n\n第一种是当同时运行多个实例时，*新建*连接会发生什么。在非常短的时间内，两个实例都会接受连接（利用 \u0060SO_REUSEPORT\u0060），这些连接由内核随机分配。然而，一旦新实例完全准备就绪，就会通知旧实例停止接受新连接，这样新实例可以开始处理所有新建连接。\n\n第二种是对于我们正在关闭的实例上的*现有*连接会发生什么。虽然应用协议通常具有通知对端停止使用的机制，例如 HTTP\/1.1 可以发送 \u0060Connection: close\u0060 标头，HTTP\/2 可以发送 \u0060GOAWAY\u0060，但 Ztunnel 在 L4 层工作，TCP 本身并没有这样的机制。为此，Ztunnel 使用了一种宽限期机制。只要仍有活动连接，旧实例就会继续运行并服务这些连接（但正如前面提到的，不再处理任何新连接）。最终，如果超出了可配置的宽限期，任何剩余的连接都会被发送 \u0060RST\u0060（连接复位）。\n\n结合起来，从“蓝色版本”升级到“绿色版本”的生命周期如下图所示：\n\n![Ztunnel 升级时间线](ztunnel-shutdown.png)\n\n第一条时间轴显示哪个实例正在积极接受连接。可以看到，这个状态从“蓝色”切换到“绿色”，其中有一个短暂的时间段内两个实例都在接受连接。\n\n第二和第三条时间轴分别显示旧实例和新实例的状态。旧实例在新实例准备就绪后开始其宽限期，最终强制终止所有剩余连接。\n\n## 我的应用程序会受到影响吗？\n\n对大多数人来说，重要的不是内部运作的细节，而是他们的应用程序是否会受到影响。简短的答案是：这取决于情况。\n\n如果你的应用程序存在比宽限期更长的连接，这些连接可能会被重置。具体影响取决于你的应用程序——有些能够更优雅地处理这种情况，而有些则不行。\n\n需要特别注意的是，**在任何时候，新建连接都不会失败**。因此，如果你的应用程序在连接终止后尝试重新建立新连接（这是正确的做法！），那么这个过程始终可以成功。\n\n## 如何减少连接重置的影响？\n\n如果你的应用程序无法很好地处理连接重置，有两种主要的方法可以缓解问题：\n\n第一种方法是确保 Ztunnel 的宽限期比你的最大连接时长更长。许多使用长连接的场景（例如连接池）可以配置连接的最大时长，并在达到最大时长后重新建立连接。如果需要，可以将此值设置得更短。此外，Ztunnel 的宽限期可以通过配置其 \u0060terminationGracePeriodSeconds\u0060 设置来调整——这个值可以设置得相当高，甚至是数小时。\n\n另一种更具侵入性但非常安全的选项是，确保升级过程中节点上没有运行应用程序。这可以通过[给节点打上隔离标记](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/generated\/kubectl_cordon\/)来实现。在大多数情况下，这种方法可能过于繁琐，但如果你将 TCP 连接视为“宠物”（需要精心维护），这种方式可能是值得的。\n\n\u003e 你可能会好奇，为什么节点隔离\/关闭可以 100% 避免连接终止，而 Ztunnel 升级却不能？问题在于，Ztunnel 升级时无法通知应用程序优雅地关闭或终止连接。然而，当应用程序关闭时，它会收到 \u0060SIGTERM\u0060 信号，可以利用该信号进行优雅的关闭。当然，你的应用程序必须正确处理该信号才能获得任何好处！\n', '\/trans\/istio-ambient-mode-ztunnel-shutdown\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">了解 Istio Ambient 模式中 Ztunnel 停止运行的过程、流量处理机制及如何减少连接中断风险。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析', '深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。', '\n在 Istio Ambient 模式下，ztunnel 是节点级安全代理，在 L4 层拦截并加密服务间流量。但不负责 L7（如 HTTP）层处理。Ambient 模式中，L7 处理由 Waypoint 代理负责。当 ztunnel 发现目标服务需 L7 处理时，通过 HBONE 协议将流量转发给 Waypoint 代理进行 HTTP 层策略应用和可观察性处理，再由 Waypoint 代理经 ztunnel 转发给目标 Pod，本文将详细阐述这条 L7 流量转发链路。\n\n## Waypoint 代理的角色与责任\n\n在 Istio Ambient 模式中：\n\n- **ztunnel** 负责透明捕获 Pod 间的 L4 流量，提供 mTLS 加密和身份认证。\n\n- **Waypoint 代理** 是一个基于 Envoy 的 L7 代理，处理 HTTP 层的高级路由、策略和可观察性。\n\n当一个请求需要 L7 层策略时（如 \u0060productpage\u0060 调用 \u0060reviews-v1\u0060 服务），**ztunnel 将流量通过 HBONE 隧道转发到 Waypoint Proxy**，由 Waypoint 执行 HTTP 路由和策略。\n\n## L7 流量在 Ambient 模式中的处理路径\n\n下图展示了 L7 流量在 Ambient 模式中的处理路径。\n\n\u0060\u0060\u0060mermaid \u0022L7 流量在 Ambient 模式中的处理路径\u0022\nsequenceDiagram\n    participant SP as 源 Pod (productpage)\n    participant ZT1 as ztunnel (源节点)\n    participant WP as Waypoint Proxy\n    participant ZT2 as ztunnel (目标节点)\n    participant DP as 目标 Pod (reviews-v1)\n\n    SP-\u003e\u003eZT1: 发出请求 (HTTP\/1.1)\n    note over SP,ZT1: 流量被源节点上的 ztunnel 拦截\n    ZT1-\u003e\u003eWP: 封装为 HBONE 请求 (mTLS)\n    note over ZT1,WP: ztunnel 执行透明拦截和加密\n    WP-\u003e\u003eZT2: 应用 L7 策略后转发流量 (mTLS)\n    note over WP,ZT2: Waypoint 应用 L7 策略后发送请求\n    ZT2-\u003e\u003eDP: 解封装并转发到 Pod 应用端口 (TCP)\n    note over ZT2,DP: ztunnel 在目标节点执行流量重定向\n    DP--\u003e\u003eZT2: 响应数据 (TCP)\n    note over DP,ZT2: Pod 返回响应\n    ZT2-\u003e\u003eWP: 封装为 HBONE 响应 (mTLS)\n    WP-\u003e\u003eZT1: 应用 L7 策略后的响应 (mTLS)\n    note over WP,ZT1: Waypoint 应用 L7 策略后的响应数据\n    ZT1-\u003e\u003eSP: 解封装并返回响应 (HTTP\/1.1)\n    note over ZT1,SP: ztunnel 在源节点解封装并返回响应\n\u0060\u0060\u0060\n\n![L7 流量在 Ambient 模式中的处理路径](022a72b18c3091c40cf01bb4fad208a2.svg)\n\n下面两张图片分别展示了源 Pod 和目标 Pod 在同节点和跨节点情况下的 L7 流量处理路径。\n\n![源 pod 和目标 pod 在同一节点上的 L7 流量路径](hbone-same-node.svg)\n\n![源 pod 和目标 pod 在不同节点上的 L7 流量路径](hbone-cross-node.svg)\n\n下面是详细的流量路径。\n\n### 1. 应用请求发出\n\n假设 productpage 应用需要访问 reviews 服务。productpage Pod 内的应用向 \u0060reviews.default.svc.cluster.local:9080\u0060 发起 HTTP 请求。\n\n### 2. ztunnel L4 透明捕获与识别\n\nproductpage Pod 的出站请求首先被所在节点上的 ztunnel 拦截。ztunnel 查看从 Istio 控制面下发的配置，根据目标服务（reviews）的身份和策略，得知该服务需要经过 Waypoint 代理进行 L7 层处理。\n\n### 3. 通过 HBONE 协议转发至 Waypoint\n\nztunnel 并非使用传统的 Envoy-to-Envoy XDS 或原生 TCP\u002bmTLS 隧道，而是通过 **HBONE 协议** 与 Waypoint 代理通信。HBONE 是 Istio Ambient 模式中专门设计的无 Sidecar L7 路由协议，基于 HTTP\/2，可在透明模式下对流量进行叠加转发，从而实现灵活的服务拓扑和策略控制。\n\n在这一阶段，ztunnel 会将 L4 流量封装到 HBONE 隧道中，发送给相应的 Waypoint 代理。\n\n### 4. Waypoint 代理的 L7 策略与遥测处理\n\nWaypoint 代理（目前仍基于 Envoy 实现）收到通过 HBONE 隧道传来的流量后，通过 TLS 配置和客户端证书校验，确保下游（ztunnel）是已被认证的受信主体。它将下游客户端的身份信息（SPIFFE ID）和其他上下文元数据提取出来，以便在 L7 层策略决策中使用。\n\n执行的操作包括：\n\n- 基于 HTTP Path\/Host 的路由和流量拆分\n- 基于 Headers 的访问控制和认证策略\n- 故障注入、熔断、限流\n- 遥测数据收集（请求时延、错误率、Tracing、Metrics、Logs）\n\n完成 L7 处理后，Waypoint 代理再通过 HBONE 将流量传回到目标节点的 ztunnel。\n\n### 5. 流量到达目标 Pod\n\n目标节点上的 ztunnel 会从 Waypoint 代理接收处理过的流量（同样通过 HBONE 隧道传递），然后解封装并将流量传递给对应的 reviews Pod 中的应用容器端口。\n\n## 洞察与关键点总结\n\n### 1. Waypoint 并不知道 ztunnel 的存在\n\n- Waypoint 代理只知道目标 Pod 的 IP 地址，但目标端口被重写为 \u006015008\u0060。\n- Kubernetes \u0060iptables\u0060 规则将流量透明重定向到 ztunnel。\n\n### 2. 流量安全性：端到端加密与身份认证\n\n- 双向 TLS（mTLS）和 SPIFFE ID 校验确保了端到端安全。\n- 无法绕过 ztunnel，确保了零信任架构的完整实施。\n\n### 3. 完全透明的流量控制\n\n- 应用开发人员无需更改任何代码。\n- 流量控制、策略和可观察性完全在数据面层面透明执行。\n\n## 如何调试？\n\n在 Ambient 模式下，调试方式也有了一些变化：\n\n- **ztunnel 调试**：\n  - Istio 引入了新的 \u0060istioctl ztunnel\u0060 子命令来协助查看和调试 ztunnel 的配置与状态。\n\n- **waypoint 调试**：\n  - 虽然 Waypoint 代理仍然是 Envoy，所以仍然可以使用 \u0060istioctl pc\u0060 和 \u0060istioctl ps\u0060 来查看其路由、集群和监听器配置。\n  - \u0060istioctl waypoint\u0060 提供了更直观的配置查看和状态检查功能。\n\n## 总结\n\nIstio Ambient 模式通过 ztunnel 来处理 L4 流量并实现零信任加密与传输，再通过 Waypoint 代理为需要 L7 策略的请求提供集中处理。两者之间通过 HBONE 协议进行高效、透明的通信，实现比传统 Sidecar 模式更轻量且易于运维的架构。\n', '\/blog\/istio-ambient-l7-flow-analysis\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入解析 Istio Ambient 模式中的 L7 流量路径，从 ztunnel 到 Waypoint 代理的透明拦截与策略应用。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/migrate-to-istio-telemetry-api/">从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性', '通过迁移到 Telemetry API 配置 SkyWalking 提供商，从而提升 Istio 网格的追踪能力和灵活性。', '\nIstio 的 Telemetry API 是替代传统 MeshConfig 遥测配置的现代化方式，提供了更灵活的工具来定义服务网格中的 **Tracing**、**Metrics** 和 **Access Logging**。相比传统的 \u0060EnvoyFilter\u0060 和 \u0060MeshConfig\u0060，Telemetry API 更具模块化、动态更新和跨层次配置能力。\n\n在本篇中，我们将详解如何使用 Telemetry API 配置 Istio 遥测功能，涵盖 Tracing、Metrics 和 Logging 的具体实现，同时展示如何迁移过时的 MeshConfig 配置。\n\n## Telemetry API 发展历程\n\nIstio 的遥测能力在早期版本中依赖于较为传统的配置方法，如 **Mixer** 和 **MeshConfig** 的 \u0060configOverride\u0060，这些方法虽然能够满足基本需求，但在复杂场景下显得力不从心。为了解决这些问题，Istio 引入了基于 CRD 的 **Telemetry API**。\n\n### 关键版本更新\n\n为了帮助读者了解 Telemetry API 的进化过程，以下是一些重要版本的更新信息：\n\n1. **Istio 1.11**：引入 Telemetry API（Alpha），提供了基本的指标和日志自定义功能。\n2. **Istio 1.13**：支持 OpenTelemetry 日志记录、自定义追踪服务名称，以及更强的日志过滤功能。\n3. **Istio 1.18**：默认不再安装 Prometheus 的 \u0060EnvoyFilter\u0060，完全依赖 Telemetry API 定义遥测行为。\n4. **Istio 1.22**：Telemetry API 升级为稳定版（v1），全面支持生产环境需求。\n\n## 为什么迁移到 Telemetry API？\n\n尽管传统的 MeshConfig 和 EnvoyFilter 提供了基础的遥测能力，但它们的配置方式在灵活性、动态性和扩展性方面存在诸多限制。为了更清晰地理解这些局限性，我们将从几个关键维度展开说明。\n\n### 使用 MeshConfig 和 EnvoyFilter 的复杂性\n\n在介绍具体问题之前，我们先了解一下 MeshConfig 和 EnvoyFilter 的定位：MeshConfig 适用于全局配置，而 EnvoyFilter 用于细粒度的自定义。但正是这种分工，导致了它们在管理上的复杂性。\n\n#### 1. 配置方式分散\n- **MeshConfig** 用于集中定义全局网格行为，例如访问日志路径、追踪采样率和指标维度。虽然适合简单场景，但无法满足命名空间级或工作负载级的需求。\n- **EnvoyFilter** 则可以覆盖或扩展 Envoy 的配置，允许更细粒度的控制。但这种方式直接操作 Envoy 内部结构（xDS 字段），配置语言复杂且容易出错。\n\n  **示例：通过 MeshConfig 配置访问日志**\n  \u0060\u0060\u0060yaml\n  apiVersion: install.istio.io\/v1alpha1\n  kind: IstioOperator\n  spec:\n    meshConfig:\n      accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  **问题**：\n  - 无法为特定服务或命名空间设置不同的日志路径。\n  - 需要重新应用整个配置，动态性不足。\n\n  **示例：通过 EnvoyFilter 自定义指标**\n  \u0060\u0060\u0060yaml\n  apiVersion: networking.istio.io\/v1alpha3\n  kind: EnvoyFilter\n  metadata:\n    name: custom-metric-filter\n    namespace: mynamespace\n  spec:\n    workloadSelector:\n      labels:\n        app: myapp  # 选择特定的工作负载\n    configPatches:\n      - applyTo: HTTP_FILTER\n        match:\n          context: SIDECAR_INBOUND  # 匹配入站流量\n        patch:\n          operation: ADD\n          filterClass: STATS  # 指定为统计过滤器\n          value:\n            name: istio.request_operation  # 自定义指标名称\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/udpa.type.v1.TypedStruct\n              type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n              value:\n                config:\n                  configuration: |\n                    \u0022attributes\u0022: [\n                      {\n                        \u0022output_attribute\u0022: \u0022istio_operationId\u0022,\n                        \u0022match\u0022: [\n                          {\n                            \u0022value\u0022: \u0022GetReviews\u0022,\n                            \u0022condition\u0022: \u0022request.url_path == \u0027\/reviews\u0027 \u0026\u0026 request.method == \u0027GET\u0027\u0022\n                          }\n                        ]\n                      }\n                    ]\n                vm_config:\n                  runtime: envoy.wasm.runtime.null\n                  code:\n                    local: { inline_string: \u0022envoy.wasm.attributegen\u0022 }\n  \u0060\u0060\u0060\n  **问题**：\n  - 配置语法复杂且冗长，需深入理解 Envoy 的结构。\n  - 易于出错，调试和维护成本高。\n\n#### 2. 动态性不足\n\n虽然现代微服务环境强调动态调整配置，但 MeshConfig 和 EnvoyFilter 的动态性支持有限：\n\n- **MeshConfig**：修改配置通常需要重启代理或重新应用整个配置，导致服务中断。\n- **EnvoyFilter**：更新流程复杂，调整单个参数也需重新部署相关代理实例。\n\n#### 3. 多租户支持困难\n\n在多租户环境中，针对不同命名空间或工作负载自定义遥测配置非常重要。然而：\n\n- **MeshConfig**：无法针对命名空间或工作负载进行差异化设置。\n- **EnvoyFilter**：需要编写多个过滤器配置，增加了管理复杂性。\n\n#### 4. 难以扩展和调试\n\n- MeshConfig 和 EnvoyFilter 对新需求（如 OpenTelemetry）支持较慢。\n- EnvoyFilter 的调试难度高，需要深入分析 Envoy 日志和行为。\n\n### 弃用传统 MeshConfig 的遥测配置\n\n鉴于上述局限性，Istio 社区已经将传统的 MeshConfig 遥测配置标记为**弃用**。以下示例展示了这些配置的使用方式及其不足之处：\n\n- **Access Logging 配置**：\n  \n  \u0060\u0060\u0060yaml\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  \n- **Trace Sampling 配置**：\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    enableTracing: true\n    extensionProviders:\n    - name: zipkin\n      zipkin:\n        service: zipkin.istio-system.svc.cluster.local\n        port: 9411\n  \u0060\u0060\u0060\n  \n- **自定义 Metrics 标签**：\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    telemetry:\n      v2:\n        prometheus:\n          configOverride:\n            inboundSidecar:\n              metrics:\n                - name: requests_total\n                  dimensions:\n                    user-agent: request.headers[\u0027User-Agent\u0027]\n  \u0060\u0060\u0060\n\n通过上述例子可以看出，这些配置的灵活性和扩展性明显不足，难以应对复杂的生产环境需求。\n\n## Telemetry API 的优势\n\n在传统配置方式的基础上，Telemetry API 带来了多项改进，使其更适合现代化的服务网格管理需求：\n\n1. **模块化设计**：Tracing、Metrics 和 Access Logging 独立配置，清晰简洁。\n2. **动态更新**：支持实时更新配置，无需重启代理。\n3. **层级化支持**：允许全局、命名空间和工作负载级别的配置覆盖。\n4. **简单直观**：使用声明式语法，无需深入理解 Envoy 的内部结构。\n\n## Istio Telemetry API 配置示例\n\n### 全局配置示例\n\n为帮助理解 Telemetry API 的具体使用，我们以全局配置示例作为开始：\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  accessLogging:\n  - providers:\n    - name: envoy # better to use a built-in one\n  tracing:\n  - providers:\n    - name: \u0022skywalking\u0022\n    randomSamplingPercentage: 100.00\n  metrics:\n  - overrides:\n    - match:\n        metric: REQUEST_COUNT\n        mode: CLIENT\n      tagOverrides:\n        x_user_email:\n          value: |\n            \u0027x-user-email\u0027 in request.headers ? request.headers[\u0027x-user-email\u0027] : \u0027empty\u0027\n    providers:\n    - name: prometheus\n\u0060\u0060\u0060\n\n### 使用 Telemetry API 配置 SkyWalking\n\n我们再以配置 SkyWalking 的采样率和 span tag 为例，演示如何使用 Telemetry API。\n\n#### 检查 Istio 版本与 CRD\n\n- 如果使用 Istio 1.22 或更高版本，使用 \u0060telemetry.istio.io\/v1\u0060。\n- 对于 Istio 1.18 至 1.21 的用户，使用 \u0060telemetry.istio.io\/v1alpha1\u0060。\n\n通过以下命令检查 Telemetry API 的 CRD 是否已安装：\n\n\u0060\u0060\u0060bash\nkubectl get crds | grep telemetry\n\u0060\u0060\u0060\n\n#### 部署 SkyWalking\n\n在集群中部署 SkyWalking OAP 服务：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\n检查服务状态：\n\n\u0060\u0060\u0060bash\nkubectl get pods -n istio-system -l app=skywalking-oap\n\u0060\u0060\u0060\n\n#### 配置 MeshConfig 添加 SkyWalking 提供商\n\n在 Istio 的 \u0060MeshConfig\u0060 中定义 SkyWalking 提供商。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: istio\n  namespace: istio-system\ndata:\n  mesh: |-\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: \u0022tracing.istio-system.svc.cluster.local\u0022\n        port: 11800\n\u0060\u0060\u0060\n\n#### 使用 Telemetry API 配置采样率\n\n通过 Telemetry API，将 SkyWalking 设置为默认的 Tracing 提供商，并定义采样率。\n\n你可以从使用 Telemetry API 从多个层级配置采样率，为了节约篇幅，我们仅演示在命名空间范围配置采样率，其他层级的配置请参考 [Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/)。\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1\nkind: Telemetry\nmetadata:\n  name: namespace-override\n  namespace: default\nspec:\n  tracing:\n  - providers:\n      - name: skywalking\n    randomSamplingPercentage: 50\n    customTags:\n      env:\n        literal:\n          value: production\n\u0060\u0060\u0060\n\n说明：\n\n- \u0060providers.name\u0060：指定 SkyWalking 为默认的 Tracing 提供商。\n- \u0060randomSamplingPercentage\u0060：覆盖命名空间级别配置，设置 50% 的采样率。\n- \u0060customTags\u0060：为所有追踪数据添加 \u0060env=production\u0060 标签。\n\n### 验证配置\n\n访问网格中的服务（如 [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) 示例应用）生成流量：\n\n\u0060\u0060\u0060bash\ncurl http:\/\/$GATEWAY_URL\/productpage\n\u0060\u0060\u0060\n\n查看追踪数据：\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\n打开浏览器访问 \u0060http:\/\/localhost:8080\u0060，在追踪界面中查看生成的追踪信息。\n\n![Skywalking Tracing](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-tracing.webp)\n\n点击一个span后，你可以看到其中的追加的 \u0060env: production\u0060 tag。\n\n![Skywalking Span](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-span.webp)\n\n## 总结\n\nTelemetry API 通过其模块化设计、动态更新和多层级支持，大幅降低了服务网格中遥测配置的复杂性。相比 MeshConfig 和 EnvoyFilter，Telemetry API 是一套更灵活、高效的现代化解决方案。我们强烈推荐迁移到 Telemetry API，以充分利用其功能。\n', '\/blog\/migrate-to-istio-telemetry-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">通过迁移到 Telemetry API 配置 SkyWalking 提供商，从而提升 Istio 网格的追踪能力和灵活性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-sidecar-vs-ambient-network-cost-performance/">Istio sidecar 和 ambient 模式的网络成本对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/12/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio sidecar 和 ambient 模式的网络成本对比', '深入对比 Istio sidecar 和 ambient 模式的网络成本与性能，分析其本地性感知及排查方法。', '\n在服务网格架构不断演进的过程中，了解不同部署模式下的网络成本对于优化性能和资源效率至关重要。本文将对比 Istio 的 sidecar 模式和 ambient 模式的网络成本，分享我在[这篇文章](\/blog\/service-mesh-data-plane-deployment-modes\/)中的一些观点。\n\n## Sidecar 模式\n\nIstio 的 sidecar 模式通过在每个 pod 旁部署 sidecar 代理来拦截服务间的流量。这种架构引入了额外的网络跳转，可能会增加延迟和计算资源使用量。然而，该模式内置了重要的性能优化特性：[本地性感知](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/locality-load-balancing\/)。\n\n图 1 展示了 Application 1 在 Istio sidecar 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。\n\n![图 1：Application 1 在 Istio sidecar 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。](sidecar-mode.svg)\n\n### Sidecar 模式的本地化感知\n\n在 Sidecar 模式下，可以使用以下命令查看端点表中的本地性信息，从而更好地理解本地性管理：\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoint \u003cpod-name[.namespace]\u003e -o yaml\n\u0060\u0060\u0060\n\n以下是一个示例输出片段，显示了集群 \u0060outbound|9080||reviews.default.svc.cluster.local\u0060 的端点信息：\n\n\u0060\u0060\u0060yaml\n- addedViaApi: true\n  circuitBreakers:\n    thresholds:\n    - maxConnections: 4294967295\n      maxPendingRequests: 4294967295\n      maxRequests: 4294967295\n      maxRetries: 4294967295\n    - maxConnections: 1024\n      maxPendingRequests: 1024\n      maxRequests: 1024\n      maxRetries: 3\n      priority: HIGH\n  edsServiceName: outbound|9080||reviews.default.svc.cluster.local\n  hostStatuses:\n  - address:\n      socketAddress:\n        address: 10.244.0.98\n        portValue: 9080\n    healthStatus:\n      edsHealthStatus: HEALTHY\n    locality:\n      region: us-central1\n      zone: us-central1-c\n    stats:\n    - name: cx_connect_fail\n    - name: cx_total\n    - name: rq_error\n    - name: rq_success\n    - name: rq_timeout\n    - name: rq_total\n    - name: cx_active\n      type: GAUGE\n    - name: rq_active\n      type: GAUGE\n    weight: 1\n  - address:\n    # 省略\n  - address:\n    # 省略\n  name: outbound|9080||reviews.default.svc.cluster.local\n  observabilityName: outbound|9080||reviews.default.svc.cluster.local;\n\u0060\u0060\u0060\n\n从中可以看到 sidecar 模式下对 Envoy 代理对 pod 基于负载均衡的细粒度控制，例如 \u0060maxConnections\u0060, \u0060maxRequests\u0060, \u0060maxRetries\u0060 等 circuit breaker 配置，同时包含流量指标和健康状态。这些细节帮助在 Pod 级别管理流量的健康度、稳定性和延迟。\n\n流量负载均衡考虑到 Locality，如 zone 和 region。Envoy 使用这些信息对流量执行更加精准的区域感知流量分配策略（如优先使用同一 zone 内的服务）。\n\n每个 sidecar 代理都会优先将流量路由至同一可用区（AZ）或区域内的服务。这一设计减少了不必要的跨 AZ 流量，从而降低了由数据传输产生的高延迟和高成本。通过将流量限制在本地区域，sidecar 模式能够优化网络路径，避免跨区域的瓶颈。\n\n尽管 sidecar 架构计算密集，但其本地性感知功能在维护高效流量路由方面起到了关键作用，尤其是在多区域云部署中，该功能有助于降低跨区域流量成本。\n\n## Ambient 模式\n\n下图展示的 Istio ambient 模式的架构。\n\n![图 2：Istio ambient 模式](istio-ambient-layers.svg)\n\nIstio ambient 模式包含两层：\n\n1. **Ztunnel 安全层（L3\/L4 流量处理）**：在此模式下，ambient 模式仅依赖 zTunnel 进行流量管理，主要处理三层和四层的流量，即网络和传输层。这一方式可减少开销，确保基本的连接和安全要求得到满足。\n\n2. **Waypoint 代理层（L7 流量处理）**：此模式下引入了 waypoint 代理，以扩展至应用层流量，处理高级路由、观测性和策略执行。然而，waypoint 代理的部署位置对性能至关重要。为避免跨 AZ 流量，建议将 waypoint 代理分布于各个 AZ 内，以确保最佳性能。\n\n### Ambient 模式的本地化感知\n\n相比之下，ambient 模式通过 ztunnel 和 waypoint 代理实现不同的架构。zTunnel 确保本地感知的流量路由，类似于 sidecar 模式，优先在同一 AZ 内路由流量，从而限制跨 AZ 流量并减少相应的网络成本。\n\n图 3 展示了 Application 1 在 Istio ambient 模式下访问位于不同 AZ 的 Application 2 的流量路径。\n\n![图 3：Application 1 在 Istio ambient 模式下访问位于不同可用区（AZ）的 Application 2 的流量路径。](ambient-mode.svg)\n\n**注意**：图中 Waypoint Proxy 为演示目的单独显示；在实际中，它并不绑定到特定节点，可以与 Ztunnel 同节点部署。\n\n可以通过以下命令查看 Ambient 模式中 Ztunnel 的详细配置和流量分布：\n\n\u0060\u0060\u0060bash\nistioctl ztunnel-config workload -o yaml\n\u0060\u0060\u0060\n\n以下是一个示例输出：\n\n\u0060\u0060\u0060yaml\n- applicationTunnel:\n    protocol: \u0022\u0022\n  canonicalName: productpage\n  canonicalRevision: v1\n  clusterId: Kubernetes\n  hostname: \u0022\u0022\n  locality:\n    region: us-central1\n    zone: us-central1-c\n  name: productpage-v1-d5789fdfb-gmw5r\n  namespace: default\n  node: gke-cilium-default-pool-63a77182-f699\n  protocol: HBONE\n  serviceAccount: bookinfo-productpage\n  status: Healthy\n  trustDomain: cluster.local\n  uid: Kubernetes\/\/Pod\/default\/productpage-v1-d5789fdfb-gmw5r\n  workloadIps:\n    - 10.28.2.14\n  workloadName: productpage-v1\n  workloadType: deployment\n\u0060\u0060\u0060\n\n从中可以看到 ztunnel 隧道的本地化信息，ztunnel 可以对进出该节点所有 pod 的流量进行集中式管理，比如统一执行负载均衡、健康检查和区域感知等操作。\n\n### Waypoint 代理优化\n\n然而，waypoint 代理并非自动具有 AZ 感知功能。关键问题在于它们的部署位置。为优化成本与性能，waypoint 代理需要跨所有 AZ 进行扩展，以便本地处理流量。否则，可能导致跨 AZ 流量和额外成本。此外，当流量进入 waypoint 代理时，原始本地性信息可能被隐藏，进一步增加了路由优化的难度。\n\n为优化性能和成本，建议 waypoint 代理在各个 AZ 内分布，以便能够本地处理流量。此外，ztunnel 与 waypoint 代理的通信设计为接近感知，从而确保流量被路由至最近的 waypoint 代理。这一特性进一步减少了跨 AZ 费用和延迟。\n\n## 使用 Kiali dashboard 进行可视化\n\n在对比 sidecar 和 ambient 模式时，为了更直观地理解本地性和路由行为，建议使用 Kiali dashboard。Kiali 能够直观展示不同模式下的流量路径，有助于理解 ambient 模式在复杂性上的表现。\n\n![图 4：Kiali 页面](kiali.webp)\n\n## 总结\n\n在对比 Istio 的 sidecar 和 ambient 模式的网络成本时，两种架构都提供了本地性感知的路由以减少跨 AZ 流量。然而，sidecar 模式在每个代理的本地性管理上更加完善，而 ambient 模式需要谨慎管理 waypoint 代理以避免额外成本。此外，需要考虑 ambient 模式的两种子模式（有或无 waypoint 代理）来理解它们对网络成本和性能的不同影响。\n\n如果希望深入了解四种主要的服务网格数据平面部署模式，建议阅读[深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析]\/blog\/service-mesh-data-plane-deployment-modes\/)。\n', '\/blog\/istio-sidecar-vs-ambient-network-cost-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入对比 Istio sidecar 和 ambient 模式的网络成本与性能，分析其本地性感知及排查方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/authz-policy-with-kyverno/">[译] 使用 Istio 和 Kyverno Authz Server 实现动态 Layer 7 策略管理</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/11/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2024/authz-policy-with-kyverno/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Istio 和 Kyverno Authz Server 实现动态 Layer 7 策略管理', '使用 Kyverno 的 Authz Server 代理 Layer 7 授权决策逻辑，并基于 CEL 编写策略。', '\nIstio 支持与多个不同的项目集成。Istio 博客最近发布了一篇关于 [与 OpenPolicyAgent 的 L7 策略功能](https:\/\/chatgpt.com\/l7-policy-with-opa) 的文章。Kyverno 是一个类似的项目，本文将探讨如何将 Istio 和 Kyverno Authz Server 结合使用，在你的平台中强制执行 Layer 7 策略。\n\n我们将通过一个简单的示例，展示如何快速上手。你将看到这种组合如何成为快速、透明地将策略交付给企业中各个应用团队的可靠选择，同时提供安全团队所需的审计和合规性数据。\n\n## 实验指南\n\n将 Kyverno Authz Server 集成到 Istio 中后，可以针对微服务应用程序强制执行细粒度的访问控制策略。\n\n本指南展示了如何为一个简单的微服务应用程序实施访问控制策略。\n\n### 前置条件\n\n- 安装了 Istio 的 Kubernetes 集群。\n- 已安装 \u0060istioctl\u0060 命令行工具。\n\n首先安装 Istio 并配置 [网格选项](https:\/\/chatgpt.com\/docs\/reference\/config\/istio.mesh.v1alpha1\/) 以启用 Kyverno：\n\n\u0060\u0060\u0060bash\nistioctl install -y -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n    accessLogFormat: |\n      [KYVERNO DEMO] my-new-dynamic-metadata: \u0027%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%\u0027\n    extensionProviders:\n    - name: kyverno-authz-server\n      envoyExtAuthzGrpc:\n        service: kyverno-authz-server.kyverno.svc.cluster.local\n        port: \u00279081\u0027\nEOF\n\u0060\u0060\u0060\n\n请注意，配置中定义了一个指向 Kyverno Authz Server 的 \u0060extensionProviders\u0060 部分：\n\n\u0060\u0060\u0060yaml\n[...]\n    extensionProviders:\n    - name: kyverno-authz-server\n      envoyExtAuthzGrpc:\n        service: kyverno-authz-server.kyverno.svc.cluster.local\n        port: \u00279081\u0027\n[...]\n\u0060\u0060\u0060\n\n### 部署 Kyverno Authz Server\n\nKyverno Authz Server 是一个支持处理 Envoy 外部授权请求的 GRPC 服务。它可以通过集群内存储的 Kyverno \u0060AuthorizationPolicy\u0060 资源或外部提供的资源进行配置。\n\n\u0060\u0060\u0060bash\nkubectl create ns kyverno\nkubectl label namespace kyverno istio-injection=enabled\nhelm install kyverno-authz-server --namespace kyverno --wait --repo https:\/\/kyverno.github.io\/kyverno-envoy-plugin kyverno-authz-server\n\u0060\u0060\u0060\n\n### 部署示例应用\n\n\u0060httpbin\u0060 是一个著名的应用程序，可用于测试 HTTP 请求，帮助快速展示如何操作请求和响应属性。\n\n\u0060\u0060\u0060bash\nkubectl create ns my-app\nkubectl label namespace my-app istio-injection=enabled\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/httpbin\/httpbin.yaml -n my-app\n\u0060\u0060\u0060\n\n### 部署 Istio AuthorizationPolicy\n\n\u0060AuthorizationPolicy\u0060 定义了将由 Kyverno Authz Server 保护的服务。\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: my-kyverno-authz\n  namespace: istio-system # 将策略应用于整个网格，istio-system 为网格根命名空间\nspec:\n  selector:\n    matchLabels:\n      ext-authz: enabled\n  action: CUSTOM\n  provider:\n    name: kyverno-authz-server\n  rules: [{}] # 空规则，将应用于具有 ext-authz: enabled 标签的选择器\nEOF\n\u0060\u0060\u0060\n\n资源中定义了前面 Istio 配置中设置的 Kyverno Authz Server \u0060extensionProvider\u0060：\n\n\u0060\u0060\u0060yaml\n[...]\n  provider:\n    name: kyverno-authz-server\n[...]\n\u0060\u0060\u0060\n\n### 给应用打标签以强制执行策略\n\n为应用打标签，以便 Istio 的 \u0060AuthorizationPolicy\u0060 对示例应用的 Pods 生效：\n\n\u0060\u0060\u0060bash\nkubectl patch deploy httpbin -n my-app --type=merge -p=\u0027{\n  \u0022spec\u0022: {\n    \u0022template\u0022: {\n      \u0022metadata\u0022: {\n        \u0022labels\u0022: {\n          \u0022ext-authz\u0022: \u0022enabled\u0022\n        }\n      }\n    }\n  }\n}\u0027\n\u0060\u0060\u0060\n\n### 部署 Kyverno AuthorizationPolicy\n\nKyverno 的 \u0060AuthorizationPolicy\u0060 定义了 Kyverno Authz Server 根据给定的 Envoy [CheckRequest](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto#service-auth-v3-checkrequest) 做出决策的规则。\n\n策略使用 [CEL 语言](https:\/\/github.com\/google\/cel-spec) 分析传入的 \u0060CheckRequest\u0060，并生成相应的 [CheckResponse](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto#service-auth-v3-checkresponse)。\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  failurePolicy: Fail\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.?headers[\u0022x-force-authorized\u0022].orValue(\u0022\u0022)\n  - name: allowed\n    expression: variables.force_authorized in [\u0022enabled\u0022, \u0022true\u0022]\n  authorizations:\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\nEOF\n\u0060\u0060\u0060\n\n在此配置中，你可以使用 CEL 辅助函数如 \u0060envoy.Allowed()\u0060 和 \u0060envoy.Denied(403)\u0060 来简化响应消息的创建：\n\n\u0060\u0060\u0060yaml\n[...]\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\n[...]\n\u0060\u0060\u0060\n\n## 工作原理\n\n在应用 \u0060AuthorizationPolicy\u0060 后，Istio 控制平面（istiod）将所需配置发送到策略中选定服务的 Sidecar 代理（Envoy）。Envoy 将请求发送到 Kyverno Authz Server，以检查是否允许请求。\n\n![工作原理](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/overview.svg)\n\nEnvoy 通过配置过滤器链工作，其中一个过滤器是 \u0060ext_authz\u0060，它实现了使用特定消息的外部授权服务。任何实现正确 Protobuf 的服务器都可以连接到 Envoy 代理并提供授权决策；Kyverno Authz Server 就是其中之一。 \n\n![工作原理](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/filters-chain.svg)\n\n查看 [Envoy 授权服务文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/service\/auth\/v3\/external_auth.proto)，你可以看到该消息具有以下属性：\n\n- Ok 响应：\n\n  \u0060\u0060\u0060json\n  {\n    \u0022status\u0022: {...},\n    \u0022ok_response\u0022: {\n      \u0022headers\u0022: [],\n      \u0022headers_to_remove\u0022: [],\n      \u0022response_headers_to_add\u0022: [],\n      \u0022query_parameters_to_set\u0022: [],\n      \u0022query_parameters_to_remove\u0022: []\n    },\n    \u0022dynamic_metadata\u0022: {...}\n  }\n  \u0060\u0060\u0060\n\n- 拒绝的响应：\n\n  \u0060\u0060\u0060json\n  {\n    \u0022status\u0022: {...},\n    \u0022denied_response\u0022: {\n      \u0022status\u0022: {...},\n      \u0022headers\u0022: [],\n      \u0022body\u0022: \u0022...\u0022\n    },\n    \u0022dynamic_metadata\u0022: {...}\n  }\n  \u0060\u0060\u0060\n\n这意味着，根据授权服务器的响应，Envoy 可以添加或删除标头、查询参数，甚至可以更改响应主体。\n\n我们也可以这样做，如[ Kyverno 授权服务器文档](https:\/\/kyverno.github.io\/kyverno-envoy-plugin)中所记载的那样。\n\n### 测试\n\n我们将先测试简单的授权场景，然后创建一个更高级的策略，展示如何使用 Kyverno Authz Server 修改请求和响应。\n\n#### 部署一个测试应用\n\n部署一个可以向 \u0060httpbin\u0060 示例应用运行 \u0060curl\u0060 命令的应用程序：\n\n\u0060\u0060\u0060bash\nkubectl apply -n my-app -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/curl\/curl.yaml\n\u0060\u0060\u0060\n\n#### 应用策略\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  failurePolicy: Fail\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.?headers[\u0022x-force-authorized\u0022].orValue(\u0022\u0022)\n  - name: allowed\n    expression: variables.force_authorized in [\u0022enabled\u0022, \u0022true\u0022]\n  authorizations:\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : envoy.Denied(403).Response()\nEOF\n\u0060\u0060\u0060\n\n简单的场景是：如果请求包含标头 \u0060x-force-authorized\u0060 且其值为 \u0060enabled\u0060 或 \u0060true\u0060，则允许请求。如果标头不存在或值不匹配，则拒绝请求。\n\n在这个示例中，我们将允许和拒绝的处理逻辑结合到一个表达式中。但是，你也可以使用多个表达式，第一个返回非空响应的表达式将被 Kyverno Authz Server 使用，这种方法在某些规则不想做决策并将决策权委托给下一个规则时非常有用：\n\n\u0060\u0060\u0060yaml\n[...]\n  authorizations:\n  # 如果标头值匹配，则允许请求\n  - expression: \u003e\n      variables.allowed\n        ? envoy.Allowed().Response()\n        : null\n  # 否则拒绝请求\n  - expression: \u003e\n      envoy.Denied(403).Response()\n[...]\n\u0060\u0060\u0060\n\n### 简单规则\n\n以下请求将返回 \u0060403\u0060：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get\n\u0060\u0060\u0060\n\n以下请求将返回 \u0060200\u0060：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n### 高级操作\n\n接下来展示更高级的用例，应用以下策略：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: envoy.kyverno.io\/v1alpha1\nkind: AuthorizationPolicy\nmetadata:\n  name: demo-policy.example.com\nspec:\n  variables:\n  - name: force_authorized\n    expression: object.attributes.request.http.headers[?\u0022x-force-authorized\u0022].orValue(\u0022\u0022) in [\u0022enabled\u0022, \u0022true\u0022]\n  - name: force_unauthenticated\n    expression: object.attributes.request.http.headers[?\u0022x-force-unauthenticated\u0022].orValue(\u0022\u0022) in [\u0022enabled\u0022, \u0022true\u0022]\n  - name: metadata\n    expression: \u0027{\u0022my-new-metadata\u0022: \u0022my-new-value\u0022}\u0027\n  authorizations:\n    # 如果 force_unauthenticated 为真，则返回 401\n  - expression: \u003e\n      variables.force_unauthenticated\n        ? envoy\n            .Denied(401)\n            .WithBody(\u0022Authentication Failed\u0022)\n            .Response()\n        : null\n    # 如果 force_authorized 为真，则返回 200\n  - expression: \u003e\n      variables.force_authorized\n        ? envoy\n            .Allowed()\n            .WithHeader(\u0022x-validated-by\u0022, \u0022my-security-checkpoint\u0022)\n            .WithoutHeader(\u0022x-force-authorized\u0022)\n            .WithResponseHeader(\u0022x-add-custom-response-header\u0022, \u0022added\u0022)\n            .Response()\n            .WithMetadata(variables.metadata)\n        : null\n    # 否则返回 403\n  - expression: \u003e\n      envoy\n        .Denied(403)\n        .WithBody(\u0022Unauthorized Request\u0022)\n        .Response()\nEOF\n\u0060\u0060\u0060\n\n在该策略中，逻辑如下：\n\n- 如果请求包含标头 \u0060x-force-unauthenticated: true\u0060 或 \u0060x-force-unauthenticated: enabled\u0060，我们将返回 \u0060401\u0060，并包含响应正文 “Authentication Failed”。\n- 否则，如果请求包含标头 \u0060x-force-authorized: true\u0060 或 \u0060x-force-authorized: enabled\u0060，我们将返回 \u0060200\u0060，并操作请求标头、响应标头并注入动态元数据。\n- 在所有其他情况下，我们将返回 \u0060403\u0060，并包含响应正文 “Unauthorized Request”。\n\nKyverno Authz Server 将返回相应的 CheckResponse 给 Envoy 代理。Envoy 将使用这些值相应地修改请求和响应。\n\n#### 更改返回的响应正文\n\n让我们测试新功能。以下命令返回 \u0060403\u0060 并将响应正文改为 \u0022Unauthorized Request\u0022：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get\n\u0060\u0060\u0060\n\n输出如下：\n\n\u0060\u0060\u0060plaintext\nUnauthorized Request\nhttp_code=403\n\u0060\u0060\u0060\n\n#### 更改返回的响应正文和状态码\n\n使用标头 \u0060x-force-unauthenticated: true\u0060 测试请求：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-unauthenticated: true\u0022\n\u0060\u0060\u0060\n\n结果将返回 \u0022Authentication Failed\u0022 和状态码 \u0060401\u0060：\n\n\u0060\u0060\u0060plaintext\nAuthentication Failed\nhttp_code=401\n\u0060\u0060\u0060\n\n### 在请求中添加标头\n\n发送有效请求：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n响应中将包含新添加的标头 \u0060x-validated-by: my-security-checkpoint\u0060，并删除了标头 \u0060x-force-authorized\u0060：\n\n\u0060\u0060\u0060plaintext\n[...]\n    \u0022X-Validated-By\u0022: [\n      \u0022my-security-checkpoint\u0022\n    ]\n[...]\nhttp_code=200\n\u0060\u0060\u0060\n\n### 在响应中添加标头\n\n运行相同的请求，但仅显示响应标头：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -I -w \u0022\\nhttp_code=%{http_code}\u0022 httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n输出中将包含在 Authz 检查期间添加的响应标头 \u0060x-add-custom-response-header: added\u0060：\n\n\u0060\u0060\u0060plaintext\nHTTP\/1.1 200 OK\n[...]\nx-add-custom-response-header: added\n[...]\nhttp_code=200\n\u0060\u0060\u0060\n\n### 在过滤器之间共享数据\n\n最后，你可以通过 \u0060dynamic_metadata\u0060 将数据传递给后续的 Envoy 过滤器。这在你需要将数据传递给过滤链中的另一个 \u0060ext_authz\u0060 过滤器或希望在应用日志中打印数据时非常有用。\n\n![元数据](https:\/\/istio.io\/latest\/blog\/2024\/authz-policy-with-kyverno\/dynamic-metadata.svg)\n\n要实现这一点，请回顾之前设置的访问日志格式：\n\n\u0060\u0060\u0060plaintext\n[...]\n    accessLogFormat: |\n      [KYVERNO DEMO] my-new-dynamic-metadata: \u0022%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%\u0022\n[...]\n\u0060\u0060\u0060\n\n\u0060DYNAMIC_METADATA\u0060 是一个保留关键字，用于访问元数据对象，其余部分是你要访问的过滤器的名称。\n\n在我们的示例中，名称 \u0060envoy.filters.http.ext_authz\u0060 是由 Istio 自动生成的。你可以通过导出 Envoy 配置来验证这一点：\n\n\u0060\u0060\u0060bash\nistioctl pc all deploy\/httpbin -n my-app -oyaml | grep envoy.filters.http.ext_authz\n\u0060\u0060\u0060\n\n你将看到该过滤器的相关配置。\n\n现在测试动态元数据。在高级规则中，我们创建了一个新的元数据条目：\u0060{\u0022my-new-metadata\u0022: \u0022my-new-value\u0022}\u0060。\n\n运行请求并检查应用程序的日志：\n\n\u0060\u0060\u0060bash\nkubectl exec -n my-app deploy\/curl -- curl -s -I httpbin:8000\/get -H \u0022x-force-authorized: true\u0022\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060bash\nkubectl logs -n my-app deploy\/httpbin -c istio-proxy --tail 1\n\u0060\u0060\u0060\n\n你将在输出中看到由 Kyverno 策略配置的新属性：\n\n\u0060\u0060\u0060plaintext\n[...]\n[KYVERNO DEMO] my-new-dynamic-metadata: \u0027{\u0022my-new-metadata\u0022:\u0022my-new-value\u0022,\u0022ext_authz_duration\u0022:5}\u0027\n[...]\n\u0060\u0060\u0060\n\n## 结论\n\n在本指南中，我们展示了如何将 Istio 与 Kyverno Authz Server 集成以在简单的微服务应用程序中强制执行策略。我们还展示了如何使用策略修改请求和响应的属性。\n\n这是构建企业级策略系统的基础示例，适用于所有应用团队。通过这一系统，策略可以快速部署，并为安全团队提供所需的审计和合规数据。\n\n如需深入了解，请参考 [Kyverno Authz Server 文档](https:\/\/kyverno.github.io\/kyverno-envoy-plugin)。如果你希望更详细地了解实现过程或示例用例，可以随时联系我们！\n', '\/trans\/authz-policy-with-kyverno\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">使用 Kyverno 的 Authz Server 代理 Layer 7 授权决策逻辑，并基于 CEL 编写策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-traffic-interception/">Istio Ambient 模式中的透明流量拦截过程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/11/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的透明流量拦截过程详解', '本文是关于 Istio Ambient 模式的系列文章的第一篇，介绍了如何通过透明流量拦截实现无需 Sidecar 的服务网格。详细分析了 Istio CNI Node Agent、ztunnel 以及 Pod 网络命名空间的交互过程。', '\n这是我关于 Istio ambient 模式系列文章的第一篇。在接下来的几篇中，我将深入探讨 ambient 模式的关键组件及其工作原理，包括 ztunnel 如何将流量转发到 waypoint proxy，waypoint proxy 如何处理流量，以及通过 bookinfo 示例完整理解流量路径的操作。由于流量拦截是服务网格的基础功能，因此我选择从它开始，为大家提供扎实的理解基础。\n\nIstio ambient 模式是一种无需在每个 pod 中注入 sidecar 的服务网格实现方式。它通过在 pod 的网络命名空间内配置透明流量拦截和重定向，使应用程序无需修改即可享受服务网格的功能。以下内容将详细解析透明流量拦截的实现过程，涉及组件如 **Istio CNI Node Agent**、**ztunnel**、**网络命名空间** 和 **iptables 规则**，并通过流程图和示意图进行说明。\n\n## 背景知识\n\n### Linux 网络命名空间\n\n**网络命名空间（Network Namespace）** 是 Linux 内核的功能，用于隔离不同进程的网络环境。每个网络命名空间都有独立的网络设备、IP 地址、路由表和 iptables 规则。容器技术（如 Docker、Kubernetes）利用网络命名空间为每个容器（或 pod）提供独立的网络栈。\n\n### Istio CNI Node Agent\n\n**Istio CNI Node Agent** 是 ambient 模式中的核心组件之一，负责在 Kubernetes 节点上检测加入 ambient 网格的 pod，并为这些 pod 配置流量重定向规则。需要注意的是，这里使用的是 Istio CNI Node Agent，而非传统的 Istio CNI 插件。Node Agent 是一个守护进程，与 ztunnel 协同工作，而不是直接参与网络插件的工作。\n\n### ztunnel\n\n**ztunnel** 是 ambient 模式中的重要组件，以 DaemonSet 的形式运行在每个节点上，负责：\n\n- 接收并处理被重定向的流量；\n- 实现 L4 层的策略，如 mTLS 加密和访问控制；\n- 与控制平面通信以获取配置和证书。\n\n### HBONE（基于 HTTP 的隧道协议）\n\n**HBONE（HTTP-Based Overlay Network Encapsulation）** 是 Istio 引入的协议，用于在 ztunnel 和 waypoint proxy 之间传输任意 TCP 流量。HBONE 利用 HTTP\/2 和 HTTP\/3 的多路复用及加密特性，提高通信效率和安全性。\n\n## 流量拦截过程详解\n\n在 ambient 模式下，应用程序 pod 无需修改代码，也不需要注入 sidecar。流量拦截和重定向的主要过程发生在 **pod 的网络命名空间** 内部，这种方式避免了与底层 CNI 的冲突。以下是其步骤概览：\n\n\u0060\u0060\u0060mermaid \u0022Istio ambient 模式的流量拦截过程\u0022\nsequenceDiagram\n    participant Kubelet\n    participant NodeAgent as Istio CNI Node Agent\n    participant PodNetns as pod 网络命名空间\n    participant ztunnel\n    participant Pod as 应用程序 pod\n\n    Kubelet-\u003e\u003eNodeAgent: 通知新 pod 加入 ambient 网格\n    NodeAgent-\u003e\u003ePodNetns: 配置 iptables 规则\n    NodeAgent-\u003e\u003eztunnel: 传递 pod 网络命名空间 FD\n    ztunnel-\u003e\u003ePodNetns: 在 pod 网络命名空间内启动监听套接字\n    Pod-\u003e\u003ePodNetns: 应用程序发出流量\n    PodNetns-\u003e\u003eztunnel: 流量被重定向到 ztunnel\n    ztunnel-\u003e\u003e目标服务: 通过隧道转发流量\n    目标服务--\u003e\u003eztunnel: 返回响应\n    ztunnel--\u003e\u003ePod: 响应流量传递回应用程序\n\u0060\u0060\u0060\n\n![Istio ambient 模式的流量拦截过程](7b94ccedcde4f27f06d158187d7904e2.svg)\n\n### 流量拦截详细步骤\n\n1. **pod 启动与网络配置**：\n   - Kubernetes 创建 pod 时，通过 Container Runtime Interface（CRI）调用底层 CNI 插件（如 Calico、Cilium）为 pod 配置网络。\n   - 此时，pod 的网络命名空间（netns）已经建立。\n2. **Istio CNI Node Agent 配置流量重定向**：\n   - Istio CNI Node Agent 监测到新 pod 被标记为 ambient 模式（通过标签 \u0060istio.io\/dataplane-mode=ambient\u0060）。\n   - 进入 pod 的网络命名空间，设置 iptables 规则以拦截流量。\n   - 将网络命名空间的文件描述符（FD）传递给 ztunnel。\n3. **ztunnel 在 pod 网络命名空间中启动监听套接字**：\n   - ztunnel 接收到网络命名空间的 FD，在其中启动监听套接字以处理重定向的流量。\n4. **透明流量拦截与处理**：\n   - 应用程序发出的流量被 pod 内的 iptables 规则拦截，并透明地重定向到 ztunnel。\n   - ztunnel 对流量执行策略检查、加密等处理后转发到目标服务。\n   - 返回的响应流量通过 ztunnel 解密并返回给应用程序。\n\n想了解更多关于 Istio CNI 处理 iptables 的细节请见我的另一篇博客 [Istio ambient 模式中的 iptables 规则解析](\/blog\/istio-ambient-pod-iptables-injection\/)。\n\n## ztunnel 日志分析\n\n你可以通过下面的命令查看所有 ztunnel 日志中有关流量拦截的记录，可以帮助你理解 ztunnel 的运行原理：\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system logs -l app=ztunnel | grep -E \u0022inbound|outbound\u0022\n\u0060\u0060\u0060\n\n你将看到例如下面的输出，注意里面的 \u0060inbound\u0060 和 \u0060outbound\u0060 是相对于 ztunnel 而言的。\n\n**入站流量示例**\n\n\u0060\u0060\u0060text\n2024-11-16T10:33:01.410751Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.19:58000 src.workload=\u0022bookinfo-gateway-istio-64fc6d75d6-s442s\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-gateway-istio\u0022 dst.addr=10.28.2.18:15008 dst.hbone_addr=10.28.2.18:9080 dst.service=\u0022productpage.default.svc.cluster.local\u0022 dst.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 direction=\u0022inbound\u0022 bytes_sent=9603 bytes_recv=2052 duration=\u00222110ms\u0022\n\u0060\u0060\u0060\n\n该日志描述了从 \u0060bookinfo-gateway-istio\u0060 到 \u0060productpage\u0060 的入站流量。流量经过 ztunnel 的 15008 端口，使用了 HBONE 隧道加密，身份通过 SPIFFE 确认。\n\n**出站流量示例**\n\n\u0060\u0060\u0060text\n2024-11-16T10:32:59.360677Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.18:51960 src.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 dst.addr=10.28.2.14:15008 dst.hbone_addr=34.118.226.6:9080 dst.service=\u0022details.default.svc.cluster.local\u0022 dst.workload=\u0022waypoint-7594b5b786-vgjwz\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/waypoint\u0022 direction=\u0022outbound\u0022 bytes_sent=794 bytes_recv=414 duration=\u002240ms\u0022\n\u0060\u0060\u0060\n\n此日志描述了 \u0060productpage\u0060 pod 访问 \u0060details\u0060 服务时的出站流量。流量由 ztunnel 使用 HBONE 隧道转发到 waypoint pod（\u006015008\u0060 端口）。\n\n## 总结\n\nIstio ambient 模式通过 Istio CNI Node Agent 和 ztunnel 的协作，实现了无需 sidecar 的透明流量拦截。其关键特性包括：\n\n- **兼容性强**：避免与底层 CNI 冲突。\n- **简化运维**：无需修改应用程序代码，降低资源消耗。\n- **安全性高**：通过 HBONE 实现端到端的加密传输。\n\n后续文章中，我将进一步探讨 Istio ambient 模式的高级功能，包括 L7 流量路径分析和网络拓扑构建过程，敬请期待。\n\n## 参考\n\n- [Maturing Istio Ambient: Compatibility Across Various Kubernetes Providers and CNIs](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/)\n- [Istio Ambient Mesh 介绍](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)\n- [Kubernetes 官方文档：网络插件](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/compute-storage-net\/network-plugins\/)\n- [HBONE](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)\n- [ztunnel traffic redirection](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/traffic-redirection\/)\n', '\/blog\/istio-ambient-traffic-interception\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是关于 Istio Ambient 模式的系列文章的第一篇，介绍了如何通过透明流量拦截实现无需 Sidecar 的服务网格。详细分析了 Istio CNI Node Agent、ztunnel 以及 Pod 网络命名空间的交互过程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-ambient-inpod-iptables/">Istio Ambient 模式中的 Pod 内 iptables 规则注入解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/11/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的 Pod 内 iptables 规则注入解析', '深入解析 Istio ambient 模式下 pod 内部的 iptables 规则如何实现透明流量拦截和控制。', '\n在 [上一篇博客](\/blog\/istio-ambient-traffic-interception\/) 中，我概述了 Istio ambient 模式中 pod 网络命名空间内注入的 iptables 规则。本文将深入解析这些规则，探讨它们是如何在 pod 内实现透明流量拦截和重定向的。\n\n## Pod 内的 iptables 规则\n\n在 pod 的网络命名空间内，Istio CNI node agent 会设置一系列 iptables 规则，以实现流量的透明拦截与重定向。下面的规则展示了 Istio 在 mangle 和 nat 表中注入的内容，确保入站和出站流量经过适当的处理。\n\n\u0060\u0060\u0060python\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*mangle\n:PREROUTING ACCEPT [99138:22880045]  # mangle 表中的 PREROUTING 链，默认策略为 ACCEPT。\n:INPUT ACCEPT [0:0]  # mangle 表中的 INPUT 链，默认策略为 ACCEPT。\n:FORWARD ACCEPT [0:0]  # mangle 表中的 FORWARD 链，默认策略为 ACCEPT。\n:OUTPUT ACCEPT [100900:34940164]  # mangle 表中的 OUTPUT 链，默认策略为 ACCEPT。\n:POSTROUTING ACCEPT [0:0]  # mangle 表中的 POSTROUTING 链，默认策略为 ACCEPT。\n:ISTIO_OUTPUT - [0:0]  # 自定义的 ISTIO_OUTPUT 链，用于处理 Istio 的出站流量。\n:ISTIO_PRERT - [0:0]  # 自定义的 ISTIO_PRERT 链，用于处理 Istio 的预路由流量。\n-A PREROUTING -j ISTIO_PRERT  # 将所有 PREROUTING 流量跳转到 ISTIO_PRERT 链。\n-A OUTPUT -j ISTIO_OUTPUT  # 将所有 OUTPUT 流量跳转到 ISTIO_OUTPUT 链。\n-A ISTIO_OUTPUT -m connmark --mark 0x111\/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\n# 如果连接标记为 0x111\/0xfff，则恢复连接标记，用于连接追踪的一致性。\n\n-A ISTIO_PRERT -m mark --mark 0x539\/0xfff -j CONNMARK --set-xmark 0x111\/0xfff\n# 如果数据包标记为 0x539\/0xfff，在 PREROUTING 链中将其连接标记设置为 0x111\/0xfff。\n\nCOMMIT  # 应用 mangle 表规则。\n# Completed on Thu Nov 14 08:43:17 2024\n\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*nat\n:PREROUTING ACCEPT [2:120]  # nat 表中的 PREROUTING 链，默认策略为 ACCEPT。\n:INPUT ACCEPT [0:0]  # nat 表中的 INPUT 链，默认策略为 ACCEPT。\n:OUTPUT ACCEPT [119:9344]  # nat 表中的 OUTPUT 链，默认策略为 ACCEPT。\n:POSTROUTING ACCEPT [0:0]  # nat 表中的 POSTROUTING 链，默认策略为 ACCEPT。\n:ISTIO_OUTPUT - [0:0]  # 自定义的 ISTIO_OUTPUT 链，用于处理 Istio 的出站 NAT 流量。\n:ISTIO_PRERT - [0:0]  # 自定义的 ISTIO_PRERT 链，用于处理 Istio 的预路由 NAT 流量。\n-A PREROUTING -j ISTIO_PRERT  # 将所有 PREROUTING 流量跳转到 ISTIO_PRERT 链。\n-A OUTPUT -j ISTIO_OUTPUT  # 将所有 OUTPUT 流量跳转到 ISTIO_OUTPUT 链。\n-A ISTIO_OUTPUT -d 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# 如果目标地址为 169.254.7.127（可能是 Istio 内部地址），允许 TCP 流量通过。\n\n-A ISTIO_OUTPUT -p tcp -m mark --mark 0x111\/0xfff -j ACCEPT\n# 如果数据包标记为 0x111\/0xfff，允许 TCP 流量通过。\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -o lo -j ACCEPT\n# 允许发往本地回环接口（但不包括 127.0.0.1）的流量通过。\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -p tcp -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15001\n# 将发往非 127.0.0.1 的出站 TCP 流量（且标记不是 0x539\/0xfff）重定向到端口 15001（Istio 出站流量入口）。\n\n-A ISTIO_PRERT -s 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# 如果源地址为 169.254.7.127，允许 TCP 流量通过 PREROUTING 链。\n\n-A ISTIO_PRERT ! -d 127.0.0.1\/32 -p tcp -m tcp ! --dport 15008 -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15006\n# 将非 127.0.0.1 且目标端口不是 15008 的入站 TCP 流量（标记不是 0x539\/0xfff）重定向到端口 15006（Istio 入站流量入口）。\n\nCOMMIT  # 应用 nat 表规则。\n# Completed on Thu Nov 14 08:43:17 2024\n\u0060\u0060\u0060\n\n### 端口号的作用\n\n这些 iptables 规则通过特定的端口号来区分并处理不同类型的流量：\n\n- **15008 (HBONE socket)**：用于透明代理基于 HTTP 的流量，支持 HBONE 协议的透明传输。\n- **15006 (plaintext socket)**：用于处理未加密的网格内部流量，以实现 pod 之间的流量管理。\n- **15001 (outbound socket)**：用于管理出站流量，实现对外部服务访问的策略控制。\n\n这些端口使得 Istio 能够对入站、出站及内部流量进行透明的管理与控制，从而实现细粒度的安全策略与流量控制。更多关于端口号的使用请参考 [Istio 应用要求](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/application-requirements\/)。\n\n### 标记 \u00600x539\u0060 的作用\n\n\u00600x539\u0060 是用于标识 Istio 代理发出的流量的标记。这一标记在流量进入 iptables 规则时被设置，用于区分由代理（如 ztunnel）处理过的数据包，防止其被重复代理或误处理。\n\n### 标记 \u00600x111\u0060 的作用\n\n\u00600x111\u0060 用于连接级别的标记管理，在 Istio 网格中标识已由代理处理过的整个连接。通过 iptables 的 \u0060CONNMARK\u0060 模块，\u00600x111\u0060 标记能够从单个数据包扩展到整个连接的生命周期，从而加速后续数据包的匹配。\n\n## iptables 规则可视化\n\n下图展示了流量在 iptables 规则中的执行路径，帮助理解流量的匹配和重定向过程：\n\n\u0060\u0060\u0060mermaid \u0022Istio ambient pod 内 iptables 可视化\u0022\ngraph TD\nA[流量进入 Pod 网络命名空间] --\u003e B{流量方向}\nB -- 入站流量 --\u003e C[PREROUTING 链]\nC --\u003e D[跳转到 ISTIO_PRERT 链]\nD --\u003e E{源地址是 169.254.7.127\/32 吗?}\nE -- 是 --\u003e F[ACCEPT]\nE -- 否 --\u003e G{目的地址是 127.0.0.1\/32 吗?}\nG -- 是 --\u003e F[ACCEPT]\nG -- 否 --\u003e H{目的端口是 15008 吗?}\nH -- 是 --\u003e F[ACCEPT]\nH -- 否 --\u003e I{数据包是否标记为 0x539?}\nI -- 是 --\u003e F[ACCEPT]\nI -- 否 --\u003e J[REDIRECT 到 15006 端口]\nB -- 出站流量 --\u003e K[OUTPUT 链]\nK --\u003e L[跳转到 ISTIO_OUTPUT 链]\nL --\u003e M{目的地址是 169.254.7.127\/32 吗?}\nM -- 是 --\u003e N[ACCEPT]\nM -- 否 --\u003e O{数据包是否标记为 0x111?}\nO -- 是 --\u003e N[ACCEPT]\nO -- 否 --\u003e P{目的地址是 127.0.0.1\/32，且输出接口是 lo 吗?}\nP -- 是 --\u003e N[ACCEPT]\nP -- 否 --\u003e Q{数据包是否标记为 0x539?}\nQ -- 是 --\u003e N[ACCEPT]\nQ -- 否 --\u003e R[REDIRECT 到 15001 端口]\n\u0060\u0060\u0060\n\n![Istio ambient pod 内 iptables 可视化](b99dc3a72ccab48d71e6c502b1089d2d.svg)\n\n想进一步了解 Istio CNI 如何处理 iptables，请参考代码 [istio\/cni\/pkg\/iptables\/iptables.go at master · istio\/istio · GitHub](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/iptables\/iptables.go)。\n\n## 不同类型流量的路由可视化\n\n以下是同节点与跨节点的加密和明文流量路径的可视化图示：\n\n**跨节点的加密流量路径**\n\n![跨节点的加密流量路径](cross-node-hbone.svg)\n\n**跨节点的明文流量路径**\n\n![跨节点的明文流量路径](cross-node-plaintext.svg)\n\n**同节点的加密流量路径**\n\n![同节点的加密流量路径](same-node-hbone.svg)\n\n**同节点的明文流量路径**\n\n![同节点的明文流量路径](same-node-plaintext.svg)\n\n\n1. **应用程序发出请求**：流量从应用程序进程发送，进入 Pod 的网络命名空间。\n2. **iptables 规则匹配**：\n   - **出站流量**在 \u0060OUTPUT\u0060 链中被匹配，符合条件的流量被重定向到 \u0060ISTIO_OUTPUT\u0060 链。\n   - 在 \u0060ISTIO_OUTPUT\u0060 链中，流量被标记并被接受。\n3. **REDIRECT 重定向**：流量被 iptables 捕获并重定向到 ztunnel 监听端口（明文流量为 15006，加密流量为 15008）。\n4. **ztunnel 处理流量**：ztunnel 接收到流量，进行策略检查和加密等操作。\n5. **流量转发到目标服务**：ztunnel 将处理后的流量发送到目标服务。\n6. **返回路径**：目标服务的响应通过网络返回 ztunnel，ztunnel 对响应进行解密和策略检查，然后返回给应用程序。\n\n## 总结\n\n通过解析 Istio ambient 模式下的 iptables 规则，我们可以看到，Istio 通过 CNI 插件在 pod 内设置了一系列透明的流量拦截规则。这些规则确保了流量在进出 pod 时能够按预期被 ztunnel 代理处理，从而实现更细粒度的流量管理和安全策略应用。未来我们将继续探索更多关于 Istio ambient 模式下的网络细节，敬请关注。', '\/blog\/istio-ambient-inpod-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入解析 Istio ambient 模式下 pod 内部的 iptables 规则如何实现透明流量拦截和控制。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(85)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-terminology/">Istio Ambient 模式：图解及概念解读</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
