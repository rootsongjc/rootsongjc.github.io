<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song - Cloud Native | Open Source | Community – Istio</title>
    <link>https://jimmysong.io/categories/istio/</link>
    <description>Recent content in Istio on Jimmy Song - Cloud Native | Open Source | Community</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright &amp;copy; 2020 Jimmy Song 保留所有权利；&lt;/br&gt;基于 Hugo [educenter](https://github.com/themefisher/educenter-hugo)  主题构建</copyright>
    <lastBuildDate>Fri, 25 Dec 2020 14:18:40 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/istio/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Istio 对虚拟机支持史话</title>
      <link>https://jimmysong.io/blog/istio-vm-odysssey/</link>
      <pubDate>Fri, 25 Dec 2020 14:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/istio-vm-odysssey/</guid>
      <description>
        
        
        &lt;p&gt;本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 &lt;code&gt;WorkloadGroup&lt;/code&gt; 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在我&lt;a href=&#34;https://thenewstack.io/how-to-integrate-virtual-machines-into-istio-service-mesh/&#34;&gt;之前的博客&lt;/a&gt;中谈到 Istio 1.7 如何支持虚拟机，但那时虚拟机仍然无法无缝的集成到 Istio 中，因为还需要做很多手动的操作。现在，Istio 1.8 新增了 WorkloadGroup 及&lt;a href=&#34;https://istio.io/latest/blog/2020/dns-proxy/&#34;&gt;智能 DNS 代理&lt;/a&gt;，这使得如虚拟机这样的非 Kubernetes 工作负载可以在 Istio 中成为像 Pod 一样的一等公民。&lt;/p&gt;
&lt;p&gt;不论有没有为虚拟机安装 sidecar，虚拟机通常情况下无法直接访问 Kubernetes 集群中的 DNS 服务器以解析 Kubernetes  服务的 Cluster IP 的（虽然你也许可以通过一些黑客的手段做到），这是在 Istio 中集成虚拟的最后一块短板，终于在 Istio 1.8 中完成了突破。&lt;/p&gt;
&lt;h2 id=&#34;为什么要支持虚拟机&#34;&gt;为什么要支持虚拟机？&lt;/h2&gt;
&lt;p&gt;在我们将应用在迁移到云原生架构，不断容器化的过程中，将经历三个阶段，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gm0d6t775lj31s80k8go8.jpg&#34; alt=&#34;云原生应用的三个阶段&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶段一：应用全部部署在虚拟机上&lt;/li&gt;
&lt;li&gt;阶段二：应用既部署在虚拟机上也部署在容器里，正在从虚拟机向容器中迁移，并使用 Kubernetes 管理容器&lt;/li&gt;
&lt;li&gt;阶段三：所有的应用优先部署在容器里，使用 Kubernetes 管理容器，使用 Istio 管理应用间的通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上图仅是对以上三个阶段的最简化描述，实际上还会有多混合云、多机房、多集群等情况，且阶段三只是个理想化的阶段，容器和虚拟机将是长期共存的，但是容器化趋势不变。&lt;/p&gt;
&lt;p&gt;在阶段二中，人们通常会将新业务和少量应用率先实现容器化，并部署到 Kubernetes 中，在应用尚未完全实现容器化的时候，处于过度状态时会遇到很多问题，如何让应用与部署在虚拟机中的服务交互？虚拟机如何访问容器中的服务？在服务迁移的过程中如何保证稳定无缝？是否可以将容器和虚拟机纳入一个统一的控制平面来管理？Istio 从开源初期就考虑并着手解决这一问题。&lt;/p&gt;
&lt;h2 id=&#34;istio-支持虚拟机的历史&#34;&gt;Istio 支持虚拟机的历史&lt;/h2&gt;
&lt;p&gt;Istio 对于虚拟机的支持是个漫长的过程，堪称是一部奥德赛。&lt;/p&gt;
&lt;h3 id=&#34;istio-mesh-扩张&#34;&gt;Istio mesh 扩张&lt;/h3&gt;
&lt;p&gt;Istio 从 0.2 版本开始通过 &lt;a href=&#34;https://istio.io/v0.2/docs/setup/kubernetes/mesh-expansion.html&#34;&gt;Istio Mesh Expansion&lt;/a&gt; 将虚拟机加入的 Mesh 中，但是需要满足以下前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机必须可以通过 IP 地址直接访问到应用的 Pod，这就要求容器与 VM 之间通过 VPC 或者 VPN 建立扁平网络，虚拟机不需要访问 Cluster IP，直接对服务的 Endpoint 端点访问即可。&lt;/li&gt;
&lt;li&gt;虚拟机必须可以访问到 Istio 的控制平面服务（Pilot、Mixer、CA，现在已正整合为 Istiod），可以通过在 Istio Mesh 中部署负载均衡器将控制平面端点暴露给虚拟机。&lt;/li&gt;
&lt;li&gt;（可选）虚拟机可以访问到 Mesh 内部的（部署在 Kubernetes 中）的 DNS server。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集成虚拟机的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 Istio 控制平面服务及 Kubernetes 集群的 DNS 服务创建 Internal 负载均衡器；&lt;/li&gt;
&lt;li&gt;生成 Istio Service CIDR、Service Account token、安全证书、Istio 控制平面服务的 IP（通过 Internal 负载均衡器暴露出来的 IP）的配置文件并发送给虚拟机；&lt;/li&gt;
&lt;li&gt;（可选）在虚拟机中安装、配置并启动 Istio 的组件、dnsmaq（用于DNS 发现），此时虚拟机可以使用   FQDN 访问 mesh 中的服务了，这一步是为了保证虚拟机可以正确解析出 mesh 中服务的 Cluster IP；&lt;/li&gt;
&lt;li&gt;若要在虚拟机中运行服务，需要配置 sidecar，新增需要拦截的 inbound 端口，然后重启 istio，还需要运行 istioctl 为服务注册&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图展示的从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gm0d6rogojj30u00yhdil.jpg&#34; alt=&#34;图一：从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 被虚拟机中部署的 &lt;code&gt;dnsmasq&lt;/code&gt; 劫持，这使得它可以正确的获取 Istio 服务、Kubernetes 内置 DNS 的端点 IP；&lt;/li&gt;
&lt;li&gt;访问 Kubernetes 的内置 DNS 服务（该服务已通过 Internal 负载均衡器暴露到集群外，可以直接访问）；&lt;/li&gt;
&lt;li&gt;返回 &lt;code&gt;productpage.bookinfo.svc.cluster.local&lt;/code&gt; 被解析出来的 Cluster IP，注意该 IP 地址无法直接访问，但是如果无法被 DNS 解析的话将导致 VM 对该服务的请求失败；&lt;/li&gt;
&lt;li&gt;虚拟机对 mesh 中服务的访问被 sidecar proxy 劫持；&lt;/li&gt;
&lt;li&gt;因为 proxy 已连接 Istio 控制平面，可通过 xDS 查询到该服务的端点，因此流量将被转发到其中的一个端点。关于这一步的详细过程请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook/concepts/sidecar-traffic-route.html&#34;&gt;Istio Handbook 中的 sidecar 流量路由机制分析 一节&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;要想在 mesh 中访问 VM 中的服务，需要使用 &lt;code&gt;istioctl register&lt;/code&gt; 命令手动将 VM 中的服务添加到 mesh 中，这本质上是将 VM 中的服务，注册到 Kubernetes 中的 service 和 endpoint；&lt;/li&gt;
&lt;li&gt;mesh 中的服务可以使用 VM 注册的服务名称（FQDN，例如 &lt;code&gt;mysql.vm.svc.cluster.local&lt;/code&gt;）来访问；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上 Istio 对虚拟机支持的方式一直延续到 Istio 1.0，在 Istio 1.1 的时候引入了新的 API &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/service-entry/&#34;&gt;ServiceEntry&lt;/a&gt;，使用它可以在 Istio 的内部服务注册表中添加额外的条目，这样 mesh 中的服务就可以访问/路由到这些手动指定的服务了，不再需要运行 &lt;code&gt;istioctl register&lt;/code&gt; 命令，而且该命令在 Istio 1.9 中将被废弃。&lt;/p&gt;
&lt;p&gt;Istio 1.5 中增加了 &lt;code&gt;istioctl experimental add-to-mesh&lt;/code&gt; 命令，可以将虚拟机中的服务添加到 mesh 中，其功能与 &lt;code&gt;istioctl register&lt;/code&gt; 一样。&lt;/p&gt;
&lt;h3 id=&#34;新增资源抽象&#34;&gt;新增资源抽象&lt;/h3&gt;
&lt;p&gt;Istio 从 &lt;a href=&#34;https://istio.io/latest/news/releases/1.6.x/announcing-1.6/&#34;&gt;1.6 版本&lt;/a&gt;开始在&lt;a href=&#34;https://istio.io/latest/news/releases/1.6.x/announcing-1.6/change-notes/&#34;&gt;流量管理&lt;/a&gt;中引入了新的资源类型 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/workload-entry/&#34;&gt;WorkloadEntry&lt;/a&gt;，用以将虚拟机进行抽象，使得虚拟机在加入 mesh 后可以作为与 Kubernetes 中的 Pod 等同的负载，具备流量管理、安全管理、可视化等能力。通过 &lt;code&gt;WorkloadEntry&lt;/code&gt; 可以简化虚拟机的网格化配置过程。&lt;code&gt;WorkloadEntry&lt;/code&gt; 对象可以根据服务条目中指定的标签选择器选择多个工作负载条目和 Kubernetes pod。&lt;/p&gt;
&lt;p&gt;Istio 1.8 中增加了 &lt;a href=&#34;http://istio.io/latest/docs/reference/config/networking/workload-group/&#34;&gt;&lt;code&gt;WorkloadGroup&lt;/code&gt;&lt;/a&gt; 的资源对象，它提供了一个规范，可以同时包括虚拟机和 Kubernetes 工作负载，旨在模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。&lt;/p&gt;
&lt;p&gt;下面是虚拟机与 Kubernetes 中负载的资源抽象层级对比。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比项&lt;/th&gt;
&lt;th&gt;Kubernetes&lt;/th&gt;
&lt;th&gt;虚拟机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基础调度单位&lt;/td&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;WorkloadEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编排组合&lt;/td&gt;
&lt;td&gt;Deployment&lt;/td&gt;
&lt;td&gt;WorkloadGroup&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务注册与发现&lt;/td&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;ServiceEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从上面的图表中我们可以看到，对于虚拟机工作负载是可以与 Kubernetes 中的负载一一对对应的。&lt;/p&gt;
&lt;p&gt;此时看似一切都比较完美了，但是直接将 Kubernetes 集群中的 DNS server 暴露出来会带来很大的&lt;a href=&#34;https://blog.aquasec.com/dns-spoofing-kubernetes-clusters&#34;&gt;安全风险&lt;/a&gt;，因此我们一般手动将虚拟机需要访问的服务的域名和 Cluster IP 对写到本机的 &lt;code&gt;/etc/hosts&lt;/code&gt; 中，但是对于一个节点数量庞大的分布式集群来说，这种做法又有些不现实。&lt;/p&gt;
&lt;p&gt;通过配置虚拟机本地 &lt;code&gt;/etc/hosts&lt;/code&gt; 访问 mesh 内服务的流程，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg&#34; alt=&#34;图二：通过配置虚拟机本地 /etc/hosts 访问 mesh 内服务的流程&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将虚拟机中的服务注册到 mesh 中；&lt;/li&gt;
&lt;li&gt;将要访问的服务的域名、Cluster IP 对手动写入虚拟机本地的 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中；&lt;/li&gt;
&lt;li&gt;虚拟机获得访问服务的 Cluster IP；&lt;/li&gt;
&lt;li&gt;流量被 sidecar proxy 拦截并解析出要访问的服务的端点地址；&lt;/li&gt;
&lt;li&gt;访问服务的指定端点；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Kubernetes 中我们一般使用 Service 对象来实现服务的注册和发现，每个服务都有一个独立的 DNS 名称，应用程序可以使用服务名称来互相调用。我们可以使用 ServiceEntry 将虚拟机中的服务注册到 Istio 的服务注册表中，但是在 Kubernetes 集群中的 DNS server 无法对 mesh 外部暴露的情况下，虚拟机无法访问 Kubernetes 集群中的 DNS 服务以获取服务的 Cluster IP，从而导致虚拟机访问 mesh 中的服务失败。如果能在虚拟机中增加一个 sidecar 可以透明地拦截 DNS 请求，可获取 mesh 内所有服务的 ClusterIP，类似于图一中的 &lt;code&gt;dnsmasq&lt;/code&gt; 的角色，这样不就可以解决问题了吗？&lt;/p&gt;
&lt;h3 id=&#34;智能-dns-代理&#34;&gt;智能 DNS 代理&lt;/h3&gt;
&lt;p&gt;Istio 1.8 中引入了&lt;a href=&#34;https://cloudnative.to/blog/istio-dns-proxy/&#34;&gt;智能 DNS 代理&lt;/a&gt;，虚拟机访问 mesh 内服务无需再配置 &lt;code&gt;/ect/hosts&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg&#34; alt=&#34;图三：引入了智能 DNS 代理后虚拟机访问 mesh 内服务的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;DNS proxy 是用 Go 编写的 Istio sidecar 代理。Sidecar 上的 Istio agent 将附带一个由 Istiod 动态编程的缓存 DNS 代理。来自应用程序的 DNS 查询会被 pod 或 VM 中的 Istio 代理透明地拦截和服务，该代理会智能地响应 DNS 查询请求，可以实现虚拟机到服务网格的无缝多集群访问。&lt;/p&gt;
&lt;p&gt;至此，Istio 1.8 中引入的 WordloadGroup 及智能 DNS 代理，补足了 Istio 对虚拟机支持的最后一块短板，使得部署在虚拟机中的遗留应用可以跟 Kubernetes 中的 Pod 一样完全等同看待。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这部 Istio 支持虚拟机的奥德赛中，我们可以看到：从最初的将 mesh 中的 DNS server 暴露给外部，在虚拟机中安装配置 &lt;code&gt;dnsmasq&lt;/code&gt;，到最后的使用智能 DNS 代理，并使用 &lt;code&gt;WorkloadEntry&lt;/code&gt;、&lt;code&gt;WorkloadGroup&lt;/code&gt; 和 &lt;code&gt;ServiceEntry&lt;/code&gt; 等资源抽象，逐步实现了虚拟机和 pod 的统一管理。本文仅仅是针对单集群的情况，在实际的生产中使用还远远不够，我们还需要处理安全、多集群、多租户等诸多问题，欢迎关注 Tetrate 的旗舰产品 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 了解更多关于 Istio 应用在生产上的最佳实践。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>如何在 Istio Service Mesh 中集成虚拟机？</title>
      <link>https://jimmysong.io/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/</link>
      <pubDate>Mon, 02 Nov 2020 16:43:27 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;Istio 是目前最流行的服务网格，用于连接、保护、控制和观察服务。当其 2017 年开源时，Kubernetes 已赢得容器编排之战，Istio 为了满足组织转向微服务的需求。虽然 Istio 声称支持异构环境，如 Nomad、Consul、Eureka、Cloud Foundry、Mesos 等，但实际上，它一直与 Kubernetes 合作得最好–它的服务发现就是基于 Kubernetes。&lt;/p&gt;
&lt;p&gt;Istio 在发展初期就因为一些问题而饱受诟病，比如组件数量多、安装和维护复杂、调试困难、由于引入了太多的新概念和对象（多达 50 个 CRD）而导致学习曲线陡峭，以及 Mixer 组件对性能的影响。但这些问题正在被 Istio 团队逐渐克服。从 2020 年初发布的&lt;a href=&#34;https://istio.io/latest/zh/blog/2020/tradewinds-2020/&#34;&gt;路线图&lt;/a&gt;中可以看出，Istio 已经取得了长足的进步。&lt;/p&gt;
&lt;p&gt;将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 提供了无缝的多云连接、安全性和可观察性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。&lt;/p&gt;
&lt;h2 id=&#34;istio-为什么要支持虚拟机&#34;&gt;Istio 为什么要支持虚拟机？&lt;/h2&gt;
&lt;p&gt;虽然现在容器和 Kubernetes 已经被广泛使用，但仍然有很多部署在虚拟机上的服务和 Kubernetes 集群之外的 API 需要由 Istio mesh 来管理。如何将棕地环境与绿地环境统一管理，这是一个巨大的挑战。&lt;/p&gt;
&lt;h2 id=&#34;将虚拟机引入到网格中需要具备什么条件&#34;&gt;将虚拟机引入到网格中需要具备什么条件？&lt;/h2&gt;
&lt;p&gt;在介绍如何集成虚拟机之前，我先介绍一下将虚拟机添加到 Mesh 中需要什么条件。在支持虚拟机流量时，Istio 必须知道几件事：哪些虚拟机的服务要添加到 Mesh 中，以及如何访问虚拟机。每个虚拟机还需要一个身份，以便与服务网格的其他部分安全地通信。这些需求可以和 Kubernetes CRD 一起工作，也可以和 Consul 这样的完整的服务注册表一起工作。而基于服务账户的身份引导机制，为没有平台身份的虚拟机分配工作负载身份。对于有平台身份的虚拟机（如 EC2、GCP、Azure 等），Istio 正在进行这方面的工作，将平台身份与 Kubernetes 身份进行交换，方便设置 mTLS 通信。&lt;/p&gt;
&lt;h2 id=&#34;istio-如何支持虚拟机&#34;&gt;Istio 如何支持虚拟机？&lt;/h2&gt;
&lt;p&gt;Istio 对虚拟机的支持始于其服务注册表机制。Istio mesh 中的服务和实例信息来自 Istio 的服务注册表，到目前为止，Istio 的服务注册表只关注或跟踪 pod。在新的版本中，Istio 现在有资源类型来跟踪和观察虚拟机。网格内的 sidecar 无法观察和控制网格外服务的流量，因为它们没有任何信息。&lt;/p&gt;
&lt;p&gt;Istio 社区和 &lt;a href=&#34;https://www.tetrate.io/&#34;&gt;Tetrate&lt;/a&gt; 在 Istio 对虚拟机的支持上做了&lt;a href=&#34;https://www.tetrate.io/blog/istio-bringing-vms-into-the-mesh-with-cynthia-coan/&#34;&gt;很多工作&lt;/a&gt;。1.6 版本中增加了 WorkloadEntry，它允许你像描述 Kubernetes 中运行的主机一样描述虚拟机。在 1.7 版本中，该版本开始增加了通过令牌将虚拟机自动引导到 service mesh 中的基础，Istio 做了大量的工作。Istio 1.8 将首次推出另一个名为 WorkloadGroup 的抽象，它类似于 Kubernetes Deployment 对象 —— 但适用于虚拟机。&lt;/p&gt;
&lt;p&gt;下图显示了 Istio 如何在网格中对服务进行建模。最主要的信息来源来自于 Kubernetes 这样的平台服务注册表，或者 Consul 这样的系统。此外，ServiceEntry 作为用户定义的服务注册表，对虚拟机上的服务或组织外部的服务进行建模。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/0081Kckwly1gkc4ldbqzhj30p30ehwf5.jpg&#34; alt=&#34;Istio 中的服务注册发现模型&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接使用 ServiceEntry 引入虚拟机中的服务，却还要大费周折在虚拟机中安装 Istio？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 ServiceEntry，你可以让网格内部的服务发现和访问外部服务；此外，还可以管理这些外部服务的流量。结合 VirtualService，你还可以为相应的外部服务配置访问规则，比如请求超时、故障注入等，从而实现对指定外部服务的控制访问。 即便如此，它也只能控制客户端的流量，而不能控制引入的外部服务对其他服务的访问。也就是说，它不能控制作为调用发起者的服务的行为。在虚拟机中部署 sidecar，通过工作负载选择器引入虚拟机工作负载，可以像 Kubernetes 中的 pod 一样，对虚拟机进行无差别管理。&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;在下面这个 demo 中我们将使在 GKE 中部署 Istio 并运行 bookinfo 示例，其中 ratings 服务的后端使用的是部署在虚拟机上的 MySQL，该示例可以在 &lt;a href=&#34;https://istio.io/latest/docs/examples/virtual-machines/bookinfo/&#34;&gt;Istio 官方文档&lt;/a&gt;中找到，我作出了部分改动，最终的流量路由如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/0081Kckwly1gkc4lch5epj318g0avwfx.jpg&#34; alt=&#34;Bookinfo 示例中的流量示意图&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装流程&#34;&gt;安装流程&lt;/h3&gt;
&lt;p&gt;下面是示例的安装步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Google Cloud 中部署 Kubernetes 集群，Kubernetes 版本是 1.16.13；&lt;/li&gt;
&lt;li&gt;在 GKE 中安装 Istio 1.7.1；&lt;/li&gt;
&lt;li&gt;在 Google Cloud 中启动一台虚拟机并配置 Istio，将其加入到 Istio Mesh 中，这一步需要很多手动操作，生成证书、创建 token、配置 hosts 等；&lt;/li&gt;
&lt;li&gt;在 Istio Mesh 中部署 bookinfo 示例；&lt;/li&gt;
&lt;li&gt;在虚拟机中安装 MySQL；&lt;/li&gt;
&lt;li&gt;为虚拟机设置 VPC 防火箱规则；&lt;/li&gt;
&lt;li&gt;将虚拟机中的 MySQL 服务作为 ServiceEntry 引入到 Mesh 中并作为 rating 服务的后端；&lt;/li&gt;
&lt;li&gt;修改 MySQL 表中的数据，验证 bookinfo 中的 rating 相应的行为符合预期；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;点击下图&lt;a href=&#34;https://www.bilibili.com/video/bv1Wp4y167QT&#34;&gt;查看 Demo 视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/bv1Wp4y167QT&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/0081Kckwly1gkc4lcu37vj318g0p0n0c.jpg&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;未来方向&#34;&gt;未来方向&lt;/h2&gt;
&lt;p&gt;从 &lt;a href=&#34;https://istio.io/latest/docs/examples/virtual-machines/bookinfo/&#34;&gt;bookinfo&lt;/a&gt; 的演示中可以看出，在这个过程中涉及到的人工工作太多，很容易出错。在未来，Istio 会改进虚拟机测试的可操作性，根据平台身份自动引导，改进 DNS 支持和 istioctl 调试等。大家可以关注 &lt;a href=&#34;https://github.com/istio/community/blob/master/WORKING-GROUPS.md&#34;&gt;Istio 环境工作组&lt;/a&gt;，了解更多关于虚拟机支持的细节。&lt;/p&gt;
&lt;h2 id=&#34;参考阅读&#34;&gt;参考阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/setup/install/virtual-machine/&#34;&gt;Virtual Machine Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/examples/virtual-machines/single-network/&#34;&gt;Virtual Machines in Single-Network Meshes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/blog/istio-bringing-vms-into-the-mesh-with-cynthia-coan/&#34;&gt;Istio: Bringing VMs into the Mesh (with Cynthia Coan)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/blog/bridging-traditional-and-modern-workloads/&#34;&gt;Bridging Traditional and Modern Workloads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
