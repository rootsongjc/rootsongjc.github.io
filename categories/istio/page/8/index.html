<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-istio-need-spire/">为什么 Istio 要使用 SPIRE 做身份认证？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么 Istio 要使用 SPIRE 做身份认证？', '本文将带你了解 SPIRE 对于零信任架构的意义，以及 Istio 是为什么使用 SPIRE 实现身份认证。', '\n今年 6 月初，[Istio 1.14 发布](https:\/\/istio.io\/latest\/news\/releases\/1.14.x\/announcing-1.14\/)，该版本中最值得关注的特性是新增对 SPIRE 的支持。[SPIFFE](https:\/\/spiffe.io) 和 SPIRE 都是 CNCF 孵化项目，其中 SPIRE 是 SPIFFE 的实现之一。本文将带你了解 SPIRE 对于零信任架构的意义，以及 Istio 是为何使用 SPIRE 实现身份认证。\n\n## Kubernetes 中的身份认证\n\n我们都知道 Istio 最初是基于 Kubernetes 建立起来的，在谈在 Istio 中使用 SPIRE 做身份认证之前，我们先来看下 Kubernetes 中如何做身份认证。\n\n我们来看一个 pod 的 token 的例子，下面是 default 命名空间下 sleep pod 的 Service Account 的 token。\n\n\u0060\u0060\u0060bash\napiVersion: v1\ndata:\n  ca.crt: {CA_CRT}\n  namespace: ZGVmYXVsdA==\n  token: {TOKEN_STRING}\nkind: Secret\nmetadata:\n  annotations:\n    kubernetes.io\/service-account.name: sleep\n    kubernetes.io\/service-account.uid: 2c0d00e8-13a2-48d0-9ff8-f987f3325ecf\n  creationTimestamp: \u00222022-06-14T03:01:35Z\u0022\n  name: sleep-token-gwhwd\n  namespace: default\n  resourceVersion: \u0022244535398\u0022\n  uid: b8822ceb-9553-4a17-96dc-d525bbaed0e0\ntype: kubernetes.io\/service-account-token\n\u0060\u0060\u0060\n\n我们看到其中有 \u0060ca.crt\u0060 和 \u0060token\u0060 字段，如果这个 token 被窃取，会有什么后果？Kubernetes 中使用 Service Account 来管理 Pod 的身份，然后利用 RBAC 指定具有某 Service Account 的 Pod 对 Kubernetes  API 的权限。Service Account 的 token 存储在 Secret 中，token 中并不包含工作负载所运行的节点、pod 的声明，一旦 token 被窃取破坏者就获得了该账户的所有权限，伪装成该用户窃取信息或破坏。\n\n一个 token 只能在一个集群中标记负载身份，Istio 同时支持 Kubernetes 环境和虚拟机，还有多集群多网格，如何统一这些异构环境中的工作负载身份？这时，一个统一的工作负载身份标准就呼之欲出了。\n\n## SPIFFE 与 SPIRE 简介\n\nSPIFFE 的目的是基于零信任的理念，建立一个开放、统一的工作负载身份标准，这有助于建立一个零信任的全面身份化的数据中心网络。SPIFFE 的核心是通过简单 API 定义了一个短期的加密身份文件 SVID，用作工作负载认证时使用的身份文件，例如建立 TLS 连接或签署和验证 JWT 令牌等。SPIRE 可以根据管理员定义的策略自动轮换 X.509 SVID 证书和秘钥。Istio 可以通过 SPIRE 动态的消费工作负载标识，SPIRE 可以动态的提供工作负载标识。\n\n下面我将为你简单介绍一下与 SPIFFE 相关的一些术语。\n\n- **SPIFFE**（Secure Production Identity Framework For Everyone）是一套身份认证标准。\n- **SPIRE**（SPIFFE Runtime Environment）是 SPIFFE 标准的一套生产就绪实现。\n- **SVID**（SPIFFE Verifiable Identity Document）是工作负载向资源或调用者证明其身份的文件。SVID 包含一个 SPIFFE ID，代表了服务的身份。它将 SPIFFE ID 编码在一个可加密验证的文件中，目前支持两种格式：X.509 证书或 JWT 令牌。\n- **SPIFFE ID** 是一个统一资源标识符（URI），其格式如下：\u0060spiffe:\/\/trust_domain\/workload_identifier\u0060。\n\nSPIRE 包含 Server 和 Agent 两个部分，它们的作用如下。\n\n**SPIRE Server**\n\n- 身份映射\n- 节点认证\n- SVID 颁发\n\n**SPIRE Agent**\n\n- 工作负载认证\n- 提供工作负载 API\n\n## SPIFFE 与零信任安全\n\n零信任的本质是以身份为中心的动态访问控制。动态证书轮换、动态证书下发、动态权限控制。SPIFFE 解决的是标识工作负载的问题。\n\n在虚拟机时代我们可能根据一个 IP 地址和端口来标识一个工作负载，基于 IP 地址标识存在多个服务共享一个 IP 地址，IP 地址伪造和访问控制列表过大等问题。到了 Kubernetes 时代，容器的生命周期是短暂的，我们无法再用 IP 地址来标识负载，而是通过 pod 或 service 名称。但是，不同的云、软件平台对工作负载标识的方法不同，相互之间存在兼容性问题。尤其是在异构混合云的中，同时存在虚拟机和容器的工作负载。这时，建立一个细粒度、具有互操作性的标识系统，将具有重要意义。\n\n## 在 Istio 中使用 SPIRE 做身份认证\n\nIstio 会利用 SPIRE 为每个工作负载提供一个唯一标识，服务网格中的工作负载在进行对等身份认证、请求身份认证和授权策略都会使用到服务标识，用于验证访问是否被允许。SPIRE 原生支持 Envoy SDS API，SPIRE Agent 中的通过与工作负载中共享的 UNIX Domain Socket 通信，为工作负载颁发 SVID。请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)了解如何在 Istio 中使用 SPIRE 做身份认证。\n\nSDS 最重要的好处就是简化了证书管理。如果没有这个特性，在 Kubernetes deployment 中，证书就必须以 secret 的方式被创建，然后挂载进代理容器。如果证书过期了，就需要更新 secret 且代理容器需要被重新部署。如果使用 SDS，Istio 可以使用 SDS 服务器会将证书推送给所有的 Envoy 实例。如果证书过期了，服务器仅需要将新证书推送至 Envoy 实例，Envoy 将会立即使用新证书且不需要重新部署代理容器。\n\n下图展示了 Istio 中使用 SPIRE 进行身份认证的架构。\n\n![Istio 中使用 SPIRE 进行身份认证的架构图](spire-with-kubernetes.svg)\n\n在 Kubernetes 集群中的 \u0060spire\u0060 命名空间中使用 StatefulSet 部署 SPIRE Server 和 Kubernetes Workload Registrar，使用 DaemonSet 资源为每个节点部署一个 SPIRE Agent。假设你在安装 Kubernetes 时使用的是默认的 DNS 名称 \u0060cluster.local\u0060，[Kubernetes Workload Registar](https:\/\/github.com\/spiffe\/spire\/blob\/main\/support\/k8s\/k8s-workload-registrar\/README.md) 会为 Istio Mesh 中的工作负载创建如下格式的身份：\n\n- SPRRE Server:\u0060spiffe:\/\/cluster.local\/ns\/spire\/sa\/server\u0060\n- SPIRE Agent:\u0060spiffe:\/\/cluster.local\/ns\/spire\/sa\/spire-agent\u0060\n- Kubernetes Node:\u0060spiffe:\/\/cluster.local\/k8s-workload-registrar\/demo-cluster\/node\/\u0060\n- Kubernetes Worload Pod:\u0060spiffe:\/\/cluster.local\/{namespace}\/spire\/sa\/{service_acount}\u0060\n\n这样不论是节点还是每个工作负载都有它们全局唯一的身份，而且还可以根据集群（信任域）扩展。\n\nIstio 中的工作负载身份验证过程如下图所示。\n\n![Istio 服务网格中的工作负载身份认证过程示意图](workload-attestation.svg)\n\n详细过程如下：\n\n1. 工作负载的 sidecar 中的 \u0060pilot-agent\u0060 会通过共享的 UDS 调用 SPIRE Agent 来获取 SVID\n2. SPIRE Agent 询问 Kubernetes（准确的说是节点上的 kubelet）获取负载的信息\n3. Kubelet 将从 API server 查询到的信息返回给工作负载验证器\n4. 验证器将 kubelet 返回的结果与 sidecar 共享的身份信息比对，如果相同，则将正确的 SVID 缓存返回给工作负载，如果不同，则身份认证失败\n\n## 总结\n\n身份是零信任网络的基础，SPIFFE 统一了异构环境下的身份标准。在 Istio 中不论我们是否使用 SPIRE，身份验证对于工作负载来说是不会有任何感知的。通过 SPIRE 来为工作负载提供身份验证，可以有效的管理工作负载的身份，为实现零信任网络打好基础。\n', '\/blog\/why-istio-need-spire\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将带你了解 SPIRE 对于零信任架构的意义，以及 Istio 是为什么使用 SPIRE 实现身份认证。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-service-mesh-book/">云原生社区著《深入理解 Istio》正式上市开售</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/06/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生社区著《深入理解 Istio》正式上市开售', '三年磨一剑，云原生社区著《深入理解 Istio —— 云原生服务网格进阶实战》正式上市开售啦！', '\n![云原生社区最新力作 —— 《深入理解 Istio》上市开售](istio-book.jpg)\n\n2017 年 5 月，Google、IBM 和 Lyft 联合 [宣布](https:\/\/istio.io\/latest\/news\/releases\/0.x\/announcing-0.1\/) 将 [Istio](https:\/\/istio.io) 开源，不知不觉中距今已 5 年有余。在这 5 年多的时间里，Istio 项目从一颗种子长成了参天大树。尤其是在 2018 年 Istio 1.0 版本发布的接下来两年里，国内有多本关于 Istio 服务网格的图书上市。在 Istio 图书出版领域，我国走在了世界的前列。\n\n![Istio 开源时间线](istio-history.svg)\n\n## 服务网格：云原生的核心技术之一\n\n如今在国内，Istio 几乎可以作为服务网格的代名词，作为 [CNCF（云原生计算基金会）定义的云原生](https:\/\/github.com\/cncf\/toc\/blob\/main\/DEFINITION.md)关键技术之一，服务网格发展至今经历了以下几个阶段。\n\n- 探索阶段：2017 —2018 年\n- 早期采用者阶段：2019—2020 年\n- 大规模落地及生态发展阶段：2021 年至今\n\n2018 年，CNCF 对云原生的定义是：云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n\n可见，CNCF 将服务网格加入了云原生定义中，即服务网格是云原生的代表性技术之一。如今，Google 正在将 Istio 捐献给 CNCF，我们有理由相信，成为 CNCF 项目后，Istio 的社区会开放，它未来的发展之路也会更顺畅。\n\n## 服务网格与云原生应用\n\n云原生的发展方兴未艾，虽然不断有新的技术和产品出现，但作为整个云原生技术栈的一部分，服务网格在过去一年里不断夯实了它作为“云原生网络基础设施”的定位。下图展示了云原生技术栈模型，其中的每一层都有一些代表性的技术来定义标准。作为新时代的中间件，服务网格与其他云原生技术交相辉映，如 Dapr（分布式应用程序运行时）定义了云原生中间件的能力模型，OAM 定义了云原生应用程序模型等，而服务网格定义了云原生七层网络模型。\n\n![云原生应用技术栈](cloud-native-stack.svg)\n\n## 为什么需要服务网格\n\n使用服务网格并非意味着与 Kubernetes 决裂，而是自然而然的事情。Kubernetes 的本质是通过声明配置对应用进行生命周期管理，而服务网格的本质是提供应用间的流量控制和安全性管理，以及可观测性。假如已经使用 Kubernetes 构建了稳定的微服务平台，那么如何设置服务间调用的负载均衡和流量控制呢？\n\nEnvoy 创造的 xDS 协议被众多开源软件所支持，如 Istio、Linkerd、MOSN 等。Envoy 对服务网格或云原生而言最大的贡献就是定义了 xDS。Envoy 本质上是一个网络代理，是通过 API 配置的现代版代理，基于它衍生出了很多不同的使用场景，如 API 网关、服务网格中的 sidecar 代理和边缘代理。\n\n技术发展从 Kubernetes 到 Istio，概括来讲有以下原因。\n\n- Kubernetes 的本质是应用的生命周期管理，具体来说，就是应用的部署和管理（扩缩容、自 动恢复、发布）。\n- Kubernetes 为微服务提供了可扩展、高弹性的部署和管理平台。\n- 服务网格的基础是透明代理，先通过 sidecar 代理拦截微服务间的流量，再通过控制平面配置管理微服务的行为。如今，服务网格的部署模式也迎来了新的挑战，sidecar 已经不是服务网格所必须的，基于 gRPC 的无代理的服务网格也在测试中。\n- xDS 定义了服务网格配置的协议标准，目前基于 gRPC 的 xDS 也正在开发中。\n- 服务网格将流量管理从 Kubernetes 中解耦，服务网格内部的流量无须 kube-proxy 组件的支持，通过接近微服务应用层的抽象，管理服务间的流量，实现安全性和可观测性功能。\n- 服务网格是对 Kubernetes 中 service 更上层的抽象，它的下一步是 Serverless，这也是 Google 在 Istio 之后紧接着推出基于 Kubernetes 和 Istio 之上的 Knative 的原因。\n\n## 以社区之名成就开源\n\n2018 年 5 月，在蚂蚁金服的支持下，ServiceMesher 社区成立。随后，国内刮起了服务网格的旋风，由社区领导的 Istio 官方文档翻译工作也进入白热化阶段。\n\n随着时间的推移，我感受到系统介绍 Istio 的中文资料匮乏，于是在 2018 年 9 月开始构思写一本关于 Istio 的图书，并在 GitHub 上发起了 Istio Handbook 的开源电子书项目。几个月后，随着服务网格技术的推广及 ServiceMesher 社区规模的扩大，我在社区的线上线下活动中结识了很多同样热衷于 Istio 和服务网格技术的朋友。我们一致决定，一起写一本 Istio 的开源电子书，将社区积累的宝贵文章和经验集结成系统的文字，分享给广大开发者。\n\n2019 年 3 月，在社区管理委员会的组织下，几十位成员自愿参与并开始共同撰写此书。2020 年 5 月，为了更好地推广云原生技术，丰富社区分享的技术内容，我们成立了云原生社区，并将原有的 ServiceMesher 社区纳入其中，社区运营的内容也从服务网格技术扩展到更加全面的云原生技术。\n\n2020 年 10 月，这本书主要的内容贡献者组成了编委会，成员分别有我、马若飞、王佰平、王炜、罗广明、赵化冰、钟华和郭旭东。我们在出版社的指导与帮助下，对本书进行了后续的版本升级、完善、优化等工作。经过反复的迭代，这本《深入理解 Isito：云原生服务网格进阶实战》终于和大家见面了。\n\n![《深入理解 Istio —— 云原生服务网格进阶实战》封面](cover.jpg)\n\n## 关于本书\n\nIstio 在 1.5 版本后有了重大的架构变化，同时引入或改进了多项功能，例如，引入了智能 DNS 代理、新的资源对象，改进了对虚拟机的支持等。\n\n本书以 Istio 新版本为基础编写而成，在持续追踪 Istio 社区最新动向的基础上，力求为读者提 供最新、最全面的内容。另外，本书的多位作者都是一线的开发或运维工程师，具有丰富的 Istio 实战经验，为本书提供了翔实、宝贵的参考案例。\n\n![本书特色](feature.jpg)\n\n![面向读者](target-reader.jpg)\n\n目前，这本书已经在京东平台上线，要想了解更多有关 Istio 的相关知识，就来读一读这本《深入理解 Isito：云原生服务网格进阶实战》吧！\n\n京东 618，满 100 减 50，扫码即购！\n\n{{\u003cfigure src=\u0022qrcode.jpg\u0022 alt=\u0022购书二维码\u0022 title=\u0022购书二维码\u0022 width=\u002230%\u0022 link=\u0022https:\/\/item.jd.com\/13200745.html\u0022 attr=\u0022[点此购买](https:\/\/item.jd.com\/13200745.html)\u0022\u003e}}\n\n', '\/blog\/istio-service-mesh-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">三年磨一剑，云原生社区著《深入理解 Istio —— 云原生服务网格进阶实战》正式上市开售啦！</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-build-istio/">如何编译 Istio？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何编译 Istio？', '本文将指导你如何在 macOS 上编译 Istio。', '\n本文将指导你如何在 macOS 上编译 Istio 二进制文件和 Docker 镜像。\n\n## 构建前的准备\n\n在正式开始构建前，[参考这篇文档](https:\/\/github.com\/istio\/istio\/wiki\/Preparing-for-Development-Mac) ，以下是我的构建环境信息：\n\n- macOS 12.3.1 Darwin AMD64\n- Docker Desktop 4.8.1(78998)\n- Docker Engine v20.10.14\n\n## 开始构建\n\n参考[这篇文档](https:\/\/github.com\/istio\/istio\/wiki\/Using-the-Code-Base) 编译 Istio。\n\n首先在 [GitHub 上](https:\/\/github.com\/istio\/istio) 下载 Istio 代码，将代码下载到 \u0060$GOPATH\/src\/istio.io\/istio\u0060 目录下，下文中的命令都在该根目录下执行。\n\n### 编译成二进制文件\n\n执行下面的命令下载 Istio 依赖的包，这些包将下载到 \u0060vendor\u0060 目录下：\n\n\u0060\u0060\u0060bash\ngo mod vendor\n\u0060\u0060\u0060\n\n然后执行下面的命令构建 Istio：\n\n\u0060\u0060\u0060bash\nsudo make build\n\u0060\u0060\u0060\n\n如果你没有在命令前加 \u0060sudo\u0060，你可能遇到下面的错误：\n\n\u0060\u0060\u0060bash\nfatal: unsafe repository (\u0027\/work\u0027 is owned by someone else)\nTo add an exception for this directory, call:\n\n\tgit config --global --add safe.directory \/work\nfatal: unsafe repository (\u0027\/work\u0027 is owned by someone else)\nTo add an exception for this directory, call:\n\n\tgit config --global --add safe.directory \/work\nMakefile.core.mk:170: *** \u0022TAG cannot be empty\u0022.  Stop.\nmake: *** [build] Error 2\n\u0060\u0060\u0060\n\n即使你按照提示执行了 \u0060git config --global --add safe.directory \/work\u0060 在编译过程中还是会出现错误。\n\n构建完的二进制文件将保存在 \u0060out\u0060 目录下，其目录结构如下：\n\n\u0060\u0060\u0060bash\nout\n├── darwin_amd64\n│   ├── bug-report\n│   ├── client\n│   ├── envoy\n│   ├── extauthz\n│   ├── install-cni\n│   ├── istio-cni\n│   ├── istio-cni-taint\n│   ├── istio-iptables\n│   ├── istio_is_init\n│   ├── istioctl\n│   ├── logs\n│   ├── operator\n│   ├── pilot-agent\n│   ├── pilot-discovery\n│   ├── release\n│   └── server\n└── linux_amd64\n    ├── envoy\n    ├── envoy-centos\n    ├── logs\n    └── release\n\u0060\u0060\u0060\n\n同时构建出了 \u0060linux_amd64\u0060 和 \u0060darwin_amd64\u0060 架构的二进制文件。\n\n### 编译成 Docker 镜像\n\n执行下面的将 Istio 编译成 Docker 镜像：\n\n\u0060\u0060\u0060bash\nsudo make docker\n\u0060\u0060\u0060\n\n编译根据你的网络情况，大概耗时 3 到 5 分钟。编译完成后，执行下面的命令你将看到 Istio 的 Docker 镜像。\n\n\u0060\u0060\u0060bash\n$ docker images\nREPOSITORY                                         TAG                          IMAGE ID       CREATED              SIZE\nlocalhost:5000\/app_sidecar_centos_7                latest                       2044037df94b   51 seconds ago       524MB\nlocalhost:5000\/app_sidecar_ubuntu_jammy            latest                       5d8ae5ed55b7   About a minute ago   362MB\nlocalhost:5000\/proxyv2                             latest                       d4679412385f   About a minute ago   243MB\nlocalhost:5000\/install-cni                         latest                       78f46d5771d2   About a minute ago   270MB\nlocalhost:5000\/istioctl                            latest                       c38130a5adc8   About a minute ago   190MB\nlocalhost:5000\/pilot                               latest                       2aa9185ec202   About a minute ago   190MB\nlocalhost:5000\/app                                 latest                       473adafaeb8d   About a minute ago   188MB\nlocalhost:5000\/operator                            latest                       9ac1fedcdd12   About a minute ago   191MB\nlocalhost:5000\/ext-authz                           latest                       1fb5aaf20791   About a minute ago   117MB\nlocalhost:5000\/app_sidecar_debian_11               latest                       61376a02b95d   2 minutes ago        407MB\nlocalhost:5000\/app_sidecar_ubuntu_xenial           latest                       7e8efe666611   2 minutes ago        418MB\n\u0060\u0060\u0060\n\n编译出镜像以后，你就可以修改镜像名字并推送到自己的镜像仓库里了。\n\n## 总结\n\n以上就是在 macOS 上构建 Istio 的过程，如果你已经下载好了构建所需要的的 Docker 镜像，那么构建时间将不超过一分钟，构建 Docker 镜像也只需要几分钟时间。\n\n## 参考\n\n- [Using the Code Base - github.com](https:\/\/github.com\/istio\/istio\/wiki\/Using-the-Code-Base)\n', '\/blog\/how-to-build-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你如何在 macOS 上编译 Istio。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/sidecar-injection-iptables-and-traffic-routing/">Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解', '本文基于 Istio 1.13 版本，介绍了 sidecar 模式及其优势 sidecar 如何注入到数据平面，Envoy 如何做流量劫持和路由转发的，包括 Inbound 流量和 Outbound 流量。', '\n本文最早是基于 Istio 1.11 撰写，之后随着 Istio 的版本陆续更新，最新更新时间为 2022 年 5 月 12 日，关于本文历史版本的更新说明请见文章最后。本文记录了详细的实践过程，力图能够让读者复现，因此事无巨细，想要理解某个部分过程的读者可以使用目录跳转到对应的小节阅读。\n\n为了使读者能够更加直观的了解本文中执行的操作，在阅读本文前你也可以先观看下 [Istio Workshop 第八讲视频](https:\/\/bilibili.com\/video\/BV1cF411T72o\/)。\n\n{{\u003cfigure title=\u0022观看视频\u0022 alt=\u0022图片\u0022 attr=\u0022[点击观看](https:\/\/bilibili.com\/video\/BV1cF411T72o\/)\u0022 src=\u0022bilibili.jpg\u0022 link=\u0022https:\/\/bilibili.com\/video\/BV1cF411T72o\/\u0022\u003e}}\n\n为了理解本文希望你先阅读以下内容：\n\n- [理解 iptables](\/blog\/understanding-iptables\/)\n- [Istio 数据平面 Pod 启动过程详解](\/blog\/istio-pod-process-lifecycle\/)\n\n## 内容介绍\n\n本文基于 Istio 1.13 版本，将为大家介绍以下内容：\n\n- 什么是 sidecar 模式和它的优势在哪里。\n- Istio 中是如何做 sidecar 注入的。\n- Sidecar 代理是如何做透明流量劫持的。\n- iptables 的路由规则。\n- Envoy 代理是如何路由流量到上游的。\n\n请大家结合下图理解本文中的内容，本图基于 Istio 官方提供的 Bookinfo 示例绘制，展示的是 \u0060reviews\u0060 Pod 的内部结构，包括 Linux Kernel 空间中的 iptables 规则、Sidecar 容器、应用容器。\n\n![Istio 流量劫持示意图](istio-iptables.svg)\n\n\u0060productpage\u0060 访问 \u0060reviews\u0060 Pod，入站流量处理过程对应于图示上的步骤：1、2、3、4、Envoy Inbound Handler、5、6、7、8、应用容器。\n\n\u0060reviews\u0060 Pod 访问 \u0060rating\u0060 服务的出站流量处理过程对应于图示上的步骤是：9、10、11、12、Envoy Outbound Handler、13、14、15。\n\n注意：图中的路径 16 近用于路由规则说明，它不不出现在当前示例中。实际上仅当 Pod 内发出的对当前 Pod 内的服务访问的时候才会途径它。\n\n上图中关于流量路由部分，包含：\n\n-  \u0060productpage\u0060 服务请求访问 \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060，当流量进入 \u0060reviews\u0060 Pod 内部时，流量是如何被 iptables 劫持到 Envoy 代理被 Inbound Handler 处理的；\n- \u0060reviews\u0060 请求访问 \u0060ratings\u0060 服务的 Pod，应用程序发出的出站流量被 iptables 劫持到 Envoy 代理的 Outbound Handler 的处理。\n\n在阅读下文时，请大家确立以下已知点：\n\n- 首先，\u0060productpage\u0060 发出的对 \u0060reivews\u0060 的访问流量，是在 Envoy 已经通过 EDS 选择出了要请求的 \u0060reviews\u0060 服务的某个 Pod，知晓了其 IP 地址，直接向该 IP 发送的 TCP 连接请求。\n- \u0060reviews\u0060 服务有三个版本，每个版本有一个实例，三个版本中的 sidecar 工作步骤类似，下文只以其中一个 Pod 中的 sidecar 流量转发步骤来说明。\n- 所有进入 \u0060reviews\u0060 Pod 的 TCP 流量都根据 Pod 中的 iptables 规则转发到了 Envoy 代理的 15006 端口，然后经过 Envoy 的处理确定转发给 Pod 内的应用容器还是透传。\n\n## Sidecar 模式\n\n将应用程序的功能划分为单独的进程运行在同一个最小调度单元中（例如 Kubernetes 中的 Pod）可以被视为 **sidecar 模式**。如下图所示，sidecar 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。\n\n![Sidecar 模式示意图](sidecar-pattern.svg)\n\n就像连接了 Sidecar 的三轮摩托车一样，在软件架构中，Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观测性、监控、日志记录、配置、断路器等功能。\n\n### 使用 Sidecar 模式的优势\n\n使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器（如 Envoy 或 MOSN），这个容器称之为 sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。\n\n因其独特的部署结构，使得 sidecar 模式具有以下优势：\n\n- 将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。\n- 因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。\n- Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。\n\n## Sidecar 注入示例分析\n\n以 Istio 官方提供的 \u0060bookinfo\u0060 中 \u0060productpage\u0060 的 YAML 为例，关于 \u0060bookinfo\u0060 应用的详细 YAML 配置请参考 [bookinfo.yaml](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml)。\n\n下文将从以下几个方面讲解：\n\n- Sidecar 容器的注入\n- iptables 规则的创建\n- 路由的详细过程\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: productpage-v1\n  labels:\n    app: productpage\n    version: v1\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: productpage\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: productpage\n        version: v1\n    spec:\n      serviceAccountName: bookinfo-productpage\n      containers:\n      - name: productpage\n        image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n        volumeMounts:\n        - name: tmp\n          mountPath: \/tmp\n      volumes:\n      - name: tmp\n        emptyDir: {}\n\u0060\u0060\u0060\n\n再查看下 \u0060productpage\u0060 容器的 [Dockerfile](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/src\/productpage\/Dockerfile)。\n\n\u0060\u0060\u0060docker\nFROM python:3.7.4-slim\n\nCOPY requirements.txt .\/\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY test-requirements.txt .\/\nRUN pip install --no-cache-dir -r test-requirements.txt\n\nCOPY productpage.py \/opt\/microservices\/\nCOPY tests\/unit\/* \/opt\/microservices\/\nCOPY templates \/opt\/microservices\/templates\nCOPY static \/opt\/microservices\/static\nCOPY requirements.txt \/opt\/microservices\/\n\nARG flood_factor\nENV FLOOD_FACTOR ${flood_factor:-0}\n\nEXPOSE 9080\nWORKDIR \/opt\/microservices\nRUN python -m unittest discover\n\nUSER 1\n\nCMD [\u0022python\u0022, \u0022productpage.py\u0022, \u00229080\u0022]\n\u0060\u0060\u0060\n\n我们看到 \u0060Dockerfile\u0060 中没有配置 \u0060ENTRYPOINT\u0060，所以 \u0060CMD\u0060 的配置 \u0060python productpage.py 9080\u0060 将作为默认的 \u0060ENTRYPOINT\u0060，记住这一点，再看下注入 sidecar 之后的配置。\n\n\u0060\u0060\u0060bash\n$ istioctl kube-inject -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n\u0060\u0060\u0060\n\n我们只截取其中与 \u0060productpage\u0060 相关的 \u0060Deployment\u0060 配置中的部分 YAML 配置。\n\n\u0060\u0060\u0060yaml\n      containers:\n      - image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0 # 应用镜像\n        name: productpage\n        ports:\n        - containerPort: 9080\n      - args:\n        - proxy\n        - sidecar\n        - --domain\n        - $(POD_NAMESPACE).svc.cluster.local\n        - --configPath\n        - \/etc\/istio\/proxy\n        - --binaryPath\n        - \/usr\/local\/bin\/envoy\n        - --serviceCluster\n        - productpage.$(POD_NAMESPACE)\n        - --drainDuration\n        - 45s\n        - --parentShutdownDuration\n        - 1m0s\n        - --discoveryAddress\n        - istiod.istio-system.svc:15012\n        - --zipkinAddress\n        - zipkin.istio-system:9411\n        - --proxyLogLevel=warning\n        - --proxyComponentLogLevel=misc:error\n        - --connectTimeout\n        - 10s\n        - --proxyAdminPort\n        - \u002215000\u0022\n        - --concurrency\n        - \u00222\u0022\n        - --controlPlaneAuthPolicy\n        - NONE\n        - --dnsRefreshRate\n        - 300s\n        - --statusPort\n        - \u002215020\u0022\n        - --trust-domain=cluster.local\n        - --controlPlaneBootstrap=false\n        image: docker.io\/istio\/proxyv2:1.5.1 # sidecar proxy\n        name: istio-proxy\n        ports:\n        - containerPort: 15090\n          name: http-envoy-prom\n          protocol: TCP\n      initContainers:\n      - command:\n        - istio-iptables\n        - -p\n        - \u002215001\u0022\n        - -z\n        - \u002215006\u0022\n        - -u\n        - \u00221337\u0022\n        - -m\n        - REDIRECT\n        - -i\n        - \u0027*\u0027\n        - -x\n        - \u0022\u0022\n        - -b\n        - \u0027*\u0027\n        - -d\n        - 15090,15020\n        image: docker.io\/istio\/proxyv2:1.5.1 # init 容器\n        name: istio-init\n\u0060\u0060\u0060\n\nIstio 给应用 Pod 注入的配置主要包括：\n\n- Init 容器 \u0060istio-init\u0060：用于 pod 中设置 iptables 端口转发\n- Sidecar 容器 \u0060istio-proxy\u0060：运行 sidecar 代理，如 Envoy 或 MOSN。\n\n## iptables 规则注入解析\n\n为了查看 iptables 配置，我们需要登陆到 sidecar 容器中使用 root 用户来查看，因为 \u0060kubectl\u0060 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 \u0060productpage\u0060 pod 所在的主机上使用 \u0060docker\u0060 命令登陆容器中查看。\n\n如果您使用 minikube 部署的 Kubernetes，可以直接登录到 minikube 的虚拟机中并切换为 root 用户。查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给 \u0060istio-iptables\u0060 传递的参数中指定将入站流量重定向到 sidecar 的模式为 \u0060REDIRECT\u0060，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 \u0060TPROXY\u0060 还会有 \u0060mangle\u0060 表配置。\u0060iptables\u0060 命令的详细用法请参考 [iptables](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html) 命令。\n\n我们仅查看与 \u0060productpage\u0060 有关的 iptables 规则如下，因为这些规则是运行在该容器特定的网络空间下，因此需要使用 \u0060nsenter\u0060 命令进入其网络空间。进入的时候需要指定进程 ID（PID），因此首先我们需要找到 \u0060productpage\u0060 容器的 PID。对于在不同平台上安装的 Kubernetes，查找容器的方式会略有不同，例如在 GKE 上，执行 \u0060docker ps -a\u0060 命令是查看不到任何容器进程的。下面已 minikube 和 GKE 两个典型的平台为例，指导你如何进入容器的网络空间。\n\n### 在 minikube 中查看容器中的 iptabes 规则\n\n对于 minikube，因为所有的进程都运行在单个节点上，因此你只需要登录到 minikube 虚拟机，切换为 root 用户然后查找 \u0060productpage\u0060 进程即可，参考下面的步骤。\n\n\u0060\u0060\u0060bash\n# 进入 minikube 并切换为 root 用户，minikube 默认用户为 docker\n$ minikube ssh\n$ sudo -i\n\n# 查看 productpage pod 的 istio-proxy 容器中的进程\n$ docker top \u0060docker ps|grep \u0022istio-proxy_productpage\u0022|cut -d \u0022 \u0022 -f1\u0060\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\n1337                10576               10517               0                   08:09               ?                   00:00:07            \/usr\/local\/bin\/pilot-agent proxy sidecar --domain default.svc.cluster.local --configPath \/etc\/istio\/proxy --binaryPath \/usr\/local\/bin\/envoy --serviceCluster productpage.default --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istiod.istio-system.svc:15012 --zipkinAddress zipkin.istio-system:9411 --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --dnsRefreshRate 300s --statusPort 15020 --trust-domain=cluster.local --controlPlaneBootstrap=false\n1337                10660               10576               0                   08:09               ?                   00:00:33            \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster productpage.default --service-node sidecar~172.17.0.16~productpage-v1-7f44c4d57c-ksf9b.default~default.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 0)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2\n\n# 使用 nsenter 进入 sidecar 容器的命名空间（以上任何一个都可以）\n$ nsenter -n --target 10660\n\n# 查看 NAT 表中规则配置的详细信息。\n$ iptables -t nat -L\n\u0060\u0060\u0060\n\n### 在 GKE 中查看容器的 iptables 规则\n\n如果你在 GKE 中安装的多节点的 Kubernetes 集群，首先你需要确定这个 Pod 运行在哪个节点上，然后登陆到那台主机，使用下面的命令查找进程的 PID，你会得到类似下面的输出。\n\n\u0060\u0060\u0060bash\n$ ps aux|grep \u0022productpage\u0022\nchronos     4268  0.0  0.6  43796 24856 ?        Ss   Apr22   0:00 python productpage.py 9080\nchronos     4329  0.9  0.6 117524 24616 ?        Sl   Apr22  13:43 \/usr\/local\/bin\/python \/opt\/microservices\/productpage.py 9080\nroot      361903  0.0  0.0   4536   812 pts\/0    S\u002b   01:54   0:00 grep --colour=auto productpage\n\u0060\u0060\u0060\n\n在本示例中，productpage 进程的 PID 是 \u00604329\u0060，使用 \u0060nsenter -n --target 4329\u0060 进入该进程的命名空间，然后在终端中输入 \u0060iptables -t nat -L\u0060 即可查看 iptables 规则。\n\n## iptables 流量劫持过程详解\n\n经过上面的步骤，你已经可以查看到 init 容器向 Pod 中注入的 iptables 规则，如下所示。\n\n\u0060\u0060\u0060bash\n# PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上。\nChain PREROUTING (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n 2701  162K ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链。\nChain INPUT (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上。\nChain OUTPUT (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n   15   900 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING 链：所有数据包流出网卡时都要先进入 POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理。\nChain POSTROUTING (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND 链：将所有入站流量重定向到 ISTIO_IN_REDIRECT 链上。目的地为 15090（Prometheus 使用）和 15020（Ingress gateway 使用，用于 Pilot 健康检查）端口的流量除外，发送到以上两个端口的流量将返回 iptables 规则链的调用点，即 PREROUTING 链的后继 INPUT 后直接调用原始目的地。\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh\n    2   120 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090\n 2699  162K RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020\n    0     0 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere\n\n# ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 sidecar 代理的 Inbound Handler 中。\nChain ISTIO_IN_REDIRECT (3 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT 链：规则比较复杂，将在下文解释\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     all  --  any    lo      127.0.0.6            anywhere #规则1\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337 #规则2\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337 #规则3\n   15   900 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337 #规则4\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337 #规则5\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337 #规则6\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337 #规则7\n    0     0 RETURN     all  --  any    any     anywhere             localhost #规则8\n    0     0 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere #规则9\n\n# ISTIO_REDIRECT 链：将所有流量重定向到 Envoy 代理的 15001 端口。\nChain ISTIO_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\n这里着重需要解释的是 \u0060ISTIO_OUTPUT\u0060 链中的 9 条规则，为了便于阅读，我将以上规则中的部分内容使用表格的形式来展示如下：\n\n{{\u003ctable \u0022ISTIO_OUTPUT 链中的路由规则\u0022\u003e}}\n| **规则** | **target**        | **in** | **out** | **source** | **destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n{{\u003c\/table\u003e}}\n\n下图展示了 \u0060ISTIO_ROUTE\u0060 规则的详细流程。\n\n![Istio_ROUTE iptalbes 规则判断流程图](istio-route-iptables.svg)\n\n我将按照规则的出现顺序来解释每条规则的目的、对应文章开头图示中的步骤及详情。其中规则 5、6、7 是分别对规则 2、3、4 的应用范围扩大（从 UID 扩大为 GID），作用是类似的，将合并解释。注意，其中的规则是按顺序执行的，也就是说排序越靠后的规则将作为默认值。出站网卡（out）为 \u0060lo\u0060 （本地回环地址，loopback 接口）时，表示流量的目的地是本地 Pod，对于 Pod 向外部发送的流量就不会经过这个接口。所有 \u0060review\u0060 Pod 的出站流量只适用于规则 4、7、8、9。\n\n**规则 1**\n\n- 目的：**透传** Envoy 代理发送到本地应用容器的流量，使其绕过 Envoy 代理，直达应用容器。\n- 对应图示中的步骤：6 到 7。\n- 详情：该规则使得所有来自 \u0060127.0.0.6\u0060（该 IP 地址将在下文解释）的请求，跳出该链，返回 iptables 的调用点（即 \u0060OUTPUT\u0060）后继续执行其余路由规则，即 \u0060POSTROUTING\u0060 规则，把流量发送到任意目的地址，如本地 Pod 内的应用容器。如果没有这条规则，由 Pod 内 Envoy 代理发出的对 Pod 内容器访问的流量将会执行下一条规则，即规则 2，流量将再次进入到了 Inbound Handler 中，从而形成了死循环。将这条规则放在第一位可以避免流量在 Inbound Handler 中死循环的问题。\n\n**规则 2、5**\n\n- 目的：处理 Envoy 代理发出的站内流量（Pod 内部的流量），但不是对 localhost 的请求，通过后续规则将其转发给 Envoy 代理的 Inbound Handler。该规则适用于 Pod 对自身 IP 地址调用的场景，即 Pod 内服务之间的访问。\n- 详情：如果流量的目的地非 localhost，且数据包是由 1337 UID（即 \u0060istio-proxy\u0060 用户，Envoy 代理）发出的，流量将被经过 \u0060ISTIO_IN_REDIRECT\u0060 最终转发到 Envoy 的 Inbound Handler。\n\n**规则 3、6**\n\n- 目的：**透传** Pod 内的应用容器的站内流量。该规则适用于容器内部的流量。例如在 Pod 内对 Pod IP 或 localhost 的访问。\n- 对应图示中的步骤：6 到 7。\n- 详情：如果流量不是由 Envoy 用户发出的，那么就跳出该链，返回 \u0060OUTPUT\u0060 调用 \u0060POSTROUTING\u0060，直达目的地。\n\n**规则 4、7**\n\n- 目的：**透传**  Envoy 代理发出的出站请求。\n- 对应图示中的步骤：14 到 15。\n- 详情：如果请求是由 Envoy 代理发出的，则返回 \u0060OUTPUT\u0060 继续调用 \u0060POSTROUTING\u0060 规则，最终直接访问目的地。\n\n**规则 8**\n\n- 目的：**透传** Pod 内部对 localhost 的请求。\n- 详情：如果请求的目的地是 localhost，则返回 OUTPUT 调用 \u0060POSTROUTING\u0060，直接访问 localhost。\n\n**规则 9**\n\n- 目的：所有其他的流量将被转发到 \u0060ISTIO_REDIRECT\u0060 后，最终达到 Envoy 代理的 Outbound Handler。\n- 对应图示中的步骤：10 到 11。\n\n以上规则避免了 Envoy 代理到应用程序的路由在 iptables 规则中的死循环，保障了流量可以被正确的路由到 Envoy 代理上，也可以发出真正的出站请求。\n\n**关于 RETURN target**\n\n你可能留意到上述规则中有很多 RETURN target，它的意思是，指定到这条规则时，跳出该规则链，返回 iptables 的调用点（在我们的例子中即 \u0060OUTPUT\u0060）后继续执行其余路由规则，在我们的例子中即 \u0060POSTROUTING\u0060 规则，把流量发送到任意目的地址，你可以把它直观的理解为**透传**。\n\n**关于 127.0.0.6 IP 地址**\n\n127.0.0.6 这个 IP 是 Istio 中默认的 \u0060InboundPassthroughClusterIpv4\u0060，在 Istio 的代码中指定。即流量在进入 Envoy 代理后被绑定的 IP 地址，作用是让 Outbound 流量重新发送到  Pod 中的应用容器，即 **Passthought（透传），绕过 Outbound Handler**。该流量是对 Pod 自身的访问，而不是真正的对外流量。至于为什么选择这个 IP 作为流量透传，请参考 [Istio Issue-29603](https:\/\/github.com\/istio\/istio\/issues\/29603)。\n\n## 流量路由过程详解\n\n通过上文，你已经了解了 Istio 是如何在 Pod 中做透明流量劫持的，那么流量被劫持到 Envoy 代理中之后是如何被处理的呢？流量路由分为 Inbound 和 Outbound 两个过程，下面将根据上文中的示例及 sidecar 的配置为读者详细分析此过程。\n\n### 理解 Inbound Handler\n\nInbound Handler 的作用是将 iptables 拦截到的 downstream 的流量转发给 Pod 内的应用程序容器。在我们的实例中，假设其中一个 Pod 的名字是 \u0060reviews-v1-545db77b95-jkgv2\u0060，运行 \u0060istioctl proxy-config listener reviews-v1-545db77b95-jkgv2 --port 15006\u0060 查看该 Pod 中 15006 端口上的监听器情况，你将看到下面的输出。\n\n\u0060\u0060\u0060ini\nADDRESS PORT  MATCH                                                                                           DESTINATION\n0.0.0.0 15006 Addr: *:15006                                                                                   Non-HTTP\/Non-TCP\n0.0.0.0 15006 Trans: tls; App: istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: 0.0.0.0\/0                        InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; App: http\/1.1,h2c; Addr: 0.0.0.0\/0                                           InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: TCP TLS; Addr: 0.0.0.0\/0                                                       InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; Addr: 0.0.0.0\/0                                                              InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; Addr: 0.0.0.0\/0                                                                     InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: istio,istio-peer-exchange,istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: *:9080 Cluster: inbound|9080||\n0.0.0.0 15006 Trans: raw_buffer; Addr: *:9080                                                                 Cluster: inbound|9080||\n\u0060\u0060\u0060\n\n下面列出了以上输出中各字段的含义：\n\n- ADDRESS：下游地址\n- PORT：Envoy 监听器监听的端口\n- MATCH：请求使用的传输协议或匹配的下游地址\n- DESTINATION：路由目的地\n\n\u0060reviews\u0060 Pod 中的 Iptables 将入站流量劫持到 15006 端口上，从上面的输出我们可以看到 Envoy 的 Inbound Handler 在 15006 端口上监听，对目的地为任何 IP 的 9080 端口的请求将路由到 \u0060inbound|9080||\u0060 Cluster 上。\n\n从该 Pod 的 Listener 列表的最后两行中可以看到，\u00600.0.0.0:15006\/TCP\u0060 的 Listener（其实际名字是 \u0060virtualInbound\u0060）监听所有的 Inbound 流量，其中包含了匹配规则，来自任意 IP 的对 \u00609080\u0060 端口的访问流量，将会路由到 \u0060inbound|9080||\u0060 Cluster，如果你想以 Json 格式查看该 Listener 的详细配置，可以执行 \u0060istioctl proxy-config listeners reviews-v1-545db77b95-jkgv2 --port 15006 -o json\u0060 命令，你将获得类似下面的输出。\n\n\u0060\u0060\u0060json\n[\n    \/*省略部分内容*\/\n    {\n        \u0022name\u0022: \u0022virtualInbound\u0022,\n        \u0022address\u0022: {\n            \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u00220.0.0.0\u0022,\n                \u0022portValue\u0022: 15006\n            }\n        },\n        \u0022filterChains\u0022: [\n            \/*省略部分内容*\/\n            {\n                \u0022filterChainMatch\u0022: {\n                    \u0022destinationPort\u0022: 9080,\n                    \u0022transportProtocol\u0022: \u0022tls\u0022,\n                    \u0022applicationProtocols\u0022: [\n                        \u0022istio\u0022,\n                        \u0022istio-peer-exchange\u0022,\n                        \u0022istio-http\/1.0\u0022,\n                        \u0022istio-http\/1.1\u0022,\n                        \u0022istio-h2\u0022\n                    ]\n                },\n                \u0022filters\u0022: [\n                    \/*省略部分内容*\/\n                    {\n                        \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n                        \u0022typedConfig\u0022: {\n                            \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n                            \u0022statPrefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n                            \u0022routeConfig\u0022: {\n                                \u0022name\u0022: \u0022inbound|9080||\u0022,\n                                \u0022virtualHosts\u0022: [\n                                    {\n                                        \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                        \u0022domains\u0022: [\n                                            \u0022*\u0022\n                                        ],\n                                        \u0022routes\u0022: [\n                                            {\n                                                \u0022name\u0022: \u0022default\u0022,\n                                                \u0022match\u0022: {\n                                                    \u0022prefix\u0022: \u0022\/\u0022\n                                                },\n                                                \u0022route\u0022: {\n                                                    \u0022cluster\u0022: \u0022inbound|9080||\u0022,\n                                                    \u0022timeout\u0022: \u00220s\u0022,\n                                                    \u0022maxStreamDuration\u0022: {\n                                                        \u0022maxStreamDuration\u0022: \u00220s\u0022,\n                                                        \u0022grpcTimeoutHeaderMax\u0022: \u00220s\u0022\n                                                    }\n                                                },\n                                                \u0022decorator\u0022: {\n                                                    \u0022operation\u0022: \u0022reviews.default.svc.cluster.local:9080\/*\u0022\n                                                }\n                                            }\n                                        ]\n                                    }\n                                ],\n                                \u0022validateClusters\u0022: false\n                            },\n                            \/*省略部分内容*\/\n                        }\n                    }\n                ],\n            \/*省略部分内容*\/\n        ],\n        \u0022listenerFilters\u0022: [\n        \/*省略部分内容*\/\n        ],\n        \u0022listenerFiltersTimeout\u0022: \u00220s\u0022,\n        \u0022continueOnListenerFiltersTimeout\u0022: true,\n        \u0022trafficDirection\u0022: \u0022INBOUND\u0022\n    }\n]\n\u0060\u0060\u0060\n\n既然 Inbound Handler 的流量中将来自任意地址的对该 Pod \u00609080\u0060 端口的流量路由到 \u0060inbound|9080||\u0060 Cluster，那么我们运行 \u0060istioctl pc cluster reviews-v1-545db77b95-jkgv2 --port 9080 --direction inbound -o json\u0060 查看下该 Cluster 配置，你将获得类似下面的输出。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||\u0022,\n        \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n        \u0022connectTimeout\u0022: \u002210s\u0022,\n        \u0022lbPolicy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {\n                    \u0022maxConnections\u0022: 4294967295,\n                    \u0022maxPendingRequests\u0022: 4294967295,\n                    \u0022maxRequests\u0022: 4294967295,\n                    \u0022maxRetries\u0022: 4294967295,\n                    \u0022trackRemaining\u0022: true\n                }\n            ]\n        },\n        \u0022cleanupInterval\u0022: \u002260s\u0022,\n        \u0022upstreamBindConfig\u0022: {\n            \u0022sourceAddress\u0022: {\n                \u0022address\u0022: \u0022127.0.0.6\u0022,\n                \u0022portValue\u0022: 0\n            }\n        },\n        \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n                \u0022istio\u0022: {\n                    \u0022services\u0022: [\n                        {\n                            \u0022host\u0022: \u0022reviews.default.svc.cluster.local\u0022,\n                            \u0022name\u0022: \u0022reviews\u0022,\n                            \u0022namespace\u0022: \u0022default\u0022\n                        }\n                    ]\n                }\n            }\n        }\n    }\n]\n\u0060\u0060\u0060\n\n我们看其中的 \u0060TYPE\u0060 为 \u0060ORIGINAL_DST\u0060，将流量发送到原始目标地址（Pod IP），因为原始目标地址即当前 Pod，你还应该注意到 \u0060upstreamBindConfig.sourceAddress.address\u0060 的值被改写为了 \u0060127.0.0.6\u0060，而且对于 Pod 内流量是通过 \u0060lo\u0060 网卡发送的，这刚好呼应了上文中的 iptables \u0060ISTIO_OUTPUT\u0060 链中的第一条规则，根据该规则，流量将被透传到 Pod 内的应用容器。\n\n### 理解 Outbound Handler\n\n在本示例中 \u0060reviews\u0060 会向 \u0060ratings\u0060 服务发送 HTTP 请求，请求的地址是：\u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060，Outbound Handler 的作用是将 iptables 拦截到的本地应用程序向外发出的流量，经由 Envoy 代理路由到上游。\n\nEnvoy 监听在 15001 端口上监听所有 Outbound 流量，Outbound Handler 处理，然后经过 \u0060virtualOutbound\u0060 Listener、\u00600.0.0.0_9080\u0060 Listener，然后通过 Route 9080 找到上游的 cluster，进而通过 EDS 找到 Endpoint 执行路由动作。\n\n**\u0060ratings.default.svc.cluster.local:9080\u0060 路由**\n\n运行 \u0060istioctl proxy-config routes reviews-v1-545db77b95-jkgv2 --name 9080 -o json\u0060 查看 route 配置，因为 sidecar 会根据 HTTP header 中的 domains 来匹配 VirtualHost，所以下面只列举了 \u0060ratings.default.svc.cluster.local:9080\u0060 这一个 VirtualHost。\n\n\u0060\u0060\u0060json\n[\n  {\n    \u0022name\u0022: \u00229080\u0022,\n    \u0022virtualHosts\u0022: [\n       {\n           \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n           \u0022domains\u0022: [\n               \u0022ratings.default.svc.cluster.local\u0022,\n               \u0022ratings.default.svc.cluster.local:9080\u0022,\n               \u0022ratings\u0022,\n               \u0022ratings:9080\u0022,\n               \u0022ratings.default.svc\u0022,\n               \u0022ratings.default.svc:9080\u0022,\n               \u0022ratings.default\u0022,\n               \u0022ratings.default:9080\u0022,\n               \u002210.8.8.106\u0022,\n               \u002210.8.8.106:9080\u0022\n           ],\n           \u0022routes\u0022: [\n               {\n                   \u0022name\u0022: \u0022default\u0022,\n                   \u0022match\u0022: {\n                       \u0022prefix\u0022: \u0022\/\u0022\n                   },\n                   \u0022route\u0022: {\n                       \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                       \u0022timeout\u0022: \u00220s\u0022,\n                       \u0022retryPolicy\u0022: {\n                           \u0022retryOn\u0022: \u0022connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes\u0022,\n                           \u0022numRetries\u0022: 2,\n                           \u0022retryHostPredicate\u0022: [\n                               {\n                                   \u0022name\u0022: \u0022envoy.retry_host_predicates.previous_hosts\u0022\n                               }\n                           ],\n                           \u0022hostSelectionRetryMaxAttempts\u0022: \u00225\u0022,\n                           \u0022retriableStatusCodes\u0022: [\n                               503\n                           ]\n                       },\n                       \u0022maxStreamDuration\u0022: {\n                           \u0022maxStreamDuration\u0022: \u00220s\u0022,\n                           \u0022grpcTimeoutHeaderMax\u0022: \u00220s\u0022\n                       }\n                   },\n                   \u0022decorator\u0022: {\n                       \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n                   }\n               }\n           ],\n           \u0022includeRequestAttemptCount\u0022: true\n       },\n       \/*省略部分内容*\/\n     ],\n     \u0022validateClusters\u0022: false\n    }\n]\n\u0060\u0060\u0060\n\n从该 Virtual Host 配置中可以看到将流量路由到\u0060outbound|9080||ratings.default.svc.cluster.local\u0060 集群。\n\n**\u0060outbound|9080||ratings.default.svc.cluster.local\u0060 集群的端点**\n\n运行 \u0060istioctl proxy-config endpoint reviews-v1-545db77b95-jkgv2 --port 9080 -o json --cluster \u0022outbound|9080||ratings.default.svc.cluster.local\u0022\u0060 查看集群的 Endpoint 配置，结果如下。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n        \u0022addedViaApi\u0022: true,\n        \u0022hostStatuses\u0022: [\n            {\n                \u0022address\u0022: {\n                    \u0022socketAddress\u0022: {\n                        \u0022address\u0022: \u002210.4.1.12\u0022,\n                        \u0022portValue\u0022: 9080\n                    }\n                },\n                \u0022stats\u0022: [\n                    {\n                        \u0022name\u0022: \u0022cx_connect_fail\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022cx_total\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_error\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_success\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_timeout\u0022\n                    },\n                    {\n                        \u0022name\u0022: \u0022rq_total\u0022\n                    },\n                    {\n                        \u0022type\u0022: \u0022GAUGE\u0022,\n                        \u0022name\u0022: \u0022cx_active\u0022\n                    },\n                    {\n                        \u0022type\u0022: \u0022GAUGE\u0022,\n                        \u0022name\u0022: \u0022rq_active\u0022\n                    }\n                ],\n                \u0022healthStatus\u0022: {\n                    \u0022edsHealthStatus\u0022: \u0022HEALTHY\u0022\n                },\n                \u0022weight\u0022: 1,\n                \u0022locality\u0022: {\n                    \u0022region\u0022: \u0022us-west2\u0022,\n                    \u0022zone\u0022: \u0022us-west2-a\u0022\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {\n                    \u0022maxConnections\u0022: 4294967295,\n                    \u0022maxPendingRequests\u0022: 4294967295,\n                    \u0022maxRequests\u0022: 4294967295,\n                    \u0022maxRetries\u0022: 4294967295\n                },\n                {\n                    \u0022priority\u0022: \u0022HIGH\u0022,\n                    \u0022maxConnections\u0022: 1024,\n                    \u0022maxPendingRequests\u0022: 1024,\n                    \u0022maxRequests\u0022: 1024,\n                    \u0022maxRetries\u0022: 3\n                }\n            ]\n        },\n        \u0022observabilityName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022\n    }\n]\n\u0060\u0060\u0060\n\n我们看到端点的地址是 \u006010.4.1.12\u0060。实际上，Endpoint 可以是一个或多个，sidecar 将根据一定规则选择适当的 Endpoint 来路由。至此 \u0060review\u0060 Pod 找到了它上游服务 \u0060rating\u0060 的 Endpoint。\n\n## 小结\n\n本文使用了 Istio 官方提供的 bookinfo 示例，按图索骥得带领读者了解了 sidecar 注入、iptables 透明流量劫持及 sidecar 中流量路由背后的实现细节。Sidecar 模式和流量透明劫持是 Istio 服务网格的特色和基础功能，理解该功能的背后过程及实现细节，将有助于大家理解 Service Mesh 的原理，因此希望读者可以在自己的环境中从头来试验一遍以加深理解。\n\n使用 iptables 做流量劫持只是 service mesh 的数据平面中做流量劫持的方式之一，还有更多的流量劫持方案，下面引用自 [云原生网络代理 MOSN 官网中给出的流量劫持](https:\/\/mosn.io\/docs\/products\/structure\/traffic-hijack\/)部分的描述。\n\n### 使用 iptables 做流量劫持时存在的问题\n\n目前 Istio 使用 iptables 实现透明劫持，主要存在以下三个问题：\n\n1. 需要借助于 conntrack 模块实现连接跟踪，在连接数较多的情况下，会造成较大的消耗，同时可能会造成 track 表满的情况，为了避免这个问题，业内有关闭 conntrack 的做法。\n1. iptables 属于常用模块，全局生效，不能显式的禁止相关联的修改，可管控性比较差。\n1. iptables 重定向流量本质上是通过 loopback 交换数据，outbond 流量将两次穿越协议栈，在大并发场景下会损失转发性能。\n\n上述几个问题并非在所有场景中都存在，比方说某些场景下，连接数并不多，且 NAT 表未被使用到的情况下，iptables 是一个满足要求的简单方案。为了适配更加广泛的场景，透明劫持需要解决上述三个问题。\n\n### 透明劫持方案优化\n\n为了优化 Istio 中的透明流量劫持的性能，业界提出了以下方案。\n\n**使用 Merbridge 开源项目利用 eBPF 劫持流量**\n\n[Merbridge](https:\/\/github.com\/merbridge\/merbridge) 是由 DaoCloud 在 2022 年初开源的的一款利用 eBPF 加速 Istio 服务网格的插件。使用 Merbridge 可以在一定程度上优化数据平面的网络性能。\n\nMerbridge 利用 eBPF 的 \u0060sockops\u0060 和 \u0060redir\u0060 能力，可以直接将数据包从 inbound socket 传输到 outbound socket。eBPF 提供了 \u0060bpf_msg_redirect_hash\u0060 函数可以直接转发应用程序的数据包。\n\n详见 [Istio 服务网格 —— 云原生应用网络构建指南](https:\/\/jimmysong.io\/istio-handbook\/ecosystem\/merbridge.html)。\n\n**使用 tproxy 处理 inbound 流量**\n\ntproxy 可以用于 inbound 流量的重定向，且无需改变报文中的目的 IP\/端口，不需要执行连接跟踪，不会出现 conntrack 模块创建大量连接的问题。受限于内核版本，tproxy 应用于 outbound 存在一定缺陷。目前 Istio 支持通过 tproxy 处理 inbound 流量。\n\n**使用 hook connect 处理 outbound 流量**\n\n为了适配更多应用场景，outbound 方向通过 hook connect 来实现，实现原理如下：\n\n![hook-connect 原理示意图](hook-connect.svg)\n\n无论采用哪种透明劫持方案，均需要解决获取真实目的 IP\/端口的问题，使用 iptables 方案通过 getsockopt 方式获取，tproxy 可以直接读取目的地址，通过修改调用接口，hook connect 方案读取方式类似于 tproxy。\n\n实现透明劫持后，在内核版本满足要求（4.16 以上）的前提下，通过 sockmap 可以缩短报文穿越路径，进而改善 outbound 方向的转发性能。\n\n## 更新说明\n\n下面是本文的几次更新说明。\n\n**2020 年 4 月 27 日，第一版，基于 Istio 1.5**\n\n本文的第一版，基于 Istio 1.5 创作，在此之前，我曾写过基于 Istio 1.1 版本的[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，为了更细致的理解 Istio 中透明流量劫持的全过程，专门创作本文。\n\n**2022 年  1 月 17 日，第二版，基于 Istio 1.11**\n\n本文第一版发布后，在社区里获得了比较大的反响，收到了很多读者的评论和留言。基于这些评论，我也发现了第一版中的很多错误，在加上 Istio 版本发布频繁，在近两年的时间内，Istio 已经作出了众多更新，其中不乏重大更新。因此笔者撰写了本文的第二版，修改了之前版本中的纰漏并根据时下 Istio 的最新版本更新了本文。\n\nIstio 1.11 与 Istio 1.1 中的 sidecar 注入和流量劫持环节最大的变化是：\n\n- iptables 改用命令行工具，不再使用 shell 脚本。\n- sidecar inbound 和 outbound 分别指定了端口，而之前是使用同一个端口（15001）。\n\n**2022 年 4 月 24，第三版，基于 Istio  1.13**\n\n这个版本的文章主要是根据当时 Istio 的最新版本更新了文章的部分内容，并重新排版，增加更新说明。\n\nIstio 1.13 相比 Istio 1.11 的变化是 \u0060istioctl proxy-config\u0060 命令的输出有了较大变化。\n\n**2022 年 5 月 6 日，第四版，基于 Istio 1.13**\n\n- 修改了对 \u0060ISTIO_ROUTE\u0060 iptables 规则 2、5 的解释\n- 在示意图中增加了路径 16\n\n**2022 年 5 月 12 日，第五版，基于 Istio 1.13**\n\n- 将 iptables 说明和 sidecar 注入、init 容器部分独立成了两篇单独的博客，以缩减博客的篇幅，见 [Istio 数据平面 Pod 启动过程详解](\/blog\/istio-pod-process-lifecycle\/)和[理解 iptables](\/blog\/understanding-iptables\/)。\n\n**2023 年 7 月 17 日，第六版，基于 Istio 1.13**\n\n- 修改了对 ISTIO_INBOUND 链的说明\n\n## 参考\n\n- [Debugging Envoy and Istiod - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/proxy-cmd\/)\n- [揭开 Istio Sidecar 注入模型的神秘面纱 - istio.io](https:\/\/istio.io\/latest\/zh\/blog\/2019\/data-plane-setup\/)\n- [MOSN 作为 Sidecar 使用时的流量劫持方案 - mosn.io](https:\/\/mosn.io\/docs\/products\/structure\/traffic-hijack\/)\n', '\/blog\/sidecar-injection-iptables-and-traffic-routing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文基于 Istio 1.13 版本，介绍了 sidecar 模式及其优势 sidecar 如何注入到数据平面，Envoy 如何做流量劫持和路由转发的，包括 Inbound 流量和 Outbound 流量。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-pod-process-lifecycle/">Istio 数据平面 Pod 启动过程详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 数据平面 Pod 启动过程详解', '本文将为你讲解 Istio 的 Init 容器、Pod 内部进程及启动过程。', '\n本文将为你讲解：\n\n- Istio 中 sidecar 自动注入过程\n- Istio 中的 init 容器启动过程\n- 启用了 Sidecar 自动注入的 Pod 的启动流程\n\n下图中展示了 Istio 数据平面中的 Pod 启动完后的组件。\n\n![Istio 数据平面 Pod 内部组件](istio-pod-lifecycle.webp)\n\n## Istio 中的 sidecar 注入\n\nIstio 中提供了以下两种 sidecar 注入方式：\n\n- 使用 \u0060istioctl\u0060 手动注入。\n- 基于 Kubernetes 的 [突变 webhook 准入控制器（mutating webhook addmission controller](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/) 的自动 sidecar 注入方式。\n\n不论是手动注入还是自动注入，sidecar 的注入过程都需要遵循如下步骤：\n\n1. Kubernetes 需要了解待注入的 sidecar 所连接的 Istio 集群及其配置；\n1. Kubernetes 需要了解待注入的 sidecar 容器本身的配置，如镜像地址、启动参数等；\n1. Kubernetes 根据 sidecar 注入模板和以上配置填充 sidecar 的配置参数，将以上配置注入到应用容器的一侧；\n\n使用下面的命令可以手动注入 sidecar。\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f ${YAML_FILE} | kuebectl apply -f -\n\u0060\u0060\u0060\n\n该命令会使用 Istio 内置的 sidecar 配置来注入，下面使用 Istio 详细配置请参考 [Istio 官网](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/sidecar-injection\/#manual-sidecar-injection)。\n\n注入完成后您将看到 Istio 为原有 pod template 注入了 \u0060initContainer\u0060 及 sidecar proxy 相关的配置。\n\n### Init 容器\n\nInit 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n\n一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。\n\nInit 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。\n\n在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 \u0060restartPolicy\u0060 指定的策略进行重试。然而，如果 Pod 的 \u0060restartPolicy\u0060 设置为 Always，Init 容器失败时会使用 \u0060RestartPolicy\u0060 策略。\n\n在所有的 Init 容器没有成功之前，Pod 将不会变成 \u0060Ready\u0060 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 \u0060Pending\u0060 状态，但应该会将 \u0060Initializing\u0060 状态设置为 true。Init 容器运行完成以后就会自动终止。\n\n关于 Init 容器的详细信息请参考 [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册](\/book\/kubernetes-handbook\/objects\/init-containers\/)。\n\n## Init 容器解析\n\nIstio 在 pod 中注入的 Init 容器名为 \u0060istio-init\u0060，我们在上面 Istio 注入完成后的 YAML 文件中看到了该容器的启动命令是：\n\n\u0060\u0060\u0060bash\nistio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b \u0027*\u0027 -d 15090,15020\n\u0060\u0060\u0060\n\n我们再检查下该容器的 [Dockerfile](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/docker\/Dockerfile.proxyv2) 看看 \u0060ENTRYPOINT\u0060 是怎么确定启动时执行的命令。\n\n\u0060\u0060\u0060docker\n# 前面的内容省略\n# The pilot-agent will bootstrap Envoy.\nENTRYPOINT [\u0022\/usr\/local\/bin\/pilot-agent\u0022]\n\u0060\u0060\u0060\n\n我们看到 \u0060istio-init\u0060 容器的入口是 \u0060\/usr\/local\/bin\/istio-iptables\u0060 命令行，该命令行工具的代码的位置在 Istio 源码仓库的 [tools\/istio-iptables](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/istio-iptables) 目录。\n\n注意：在 Istio 1.1 版本时还是使用 \u0060isito-iptables.sh\u0060 命令行来操作 IPtables。\n\n### Init 容器启动入口\n\nInit 容器的启动入口是 \u0060istio-iptables\u0060 命令行，该命令行工具的用法如下：\n\n\u0060\u0060\u0060bash\n$ istio-iptables [flags]\n  -p: 指定重定向所有 TCP 流量的 sidecar 端口（默认为 $ENVOY_PORT = 15001）\n  -m: 指定入站连接重定向到 sidecar 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE)\n  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS）\n  -d: 指定要从重定向到 sidecar 中排除的入站端口列表（可选），以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS）\n  -o：逗号分隔的出站端口列表，不包括重定向到 Envoy 的端口。\n  -i: 指定重定向到 sidecar 的 IP 地址范围（可选），以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR）\n  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。\n  -k：逗号分隔的虚拟接口列表，其入站流量（来自虚拟机的）将被视为出站流量。\n  -g：指定不应用重定向的用户的 GID。(默认值与 -u param 相同)\n  -u：指定不应用重定向的用户的 UID。通常情况下，这是代理容器的 UID（默认值是 1337，即 istio-proxy 的 UID）。\n  -z: 所有进入 pod\/VM 的 TCP 流量应被重定向到的端口（默认 $INBOUND_CAPTURE_PORT = 15006）。\n\u0060\u0060\u0060\n\n以上传入的参数都会重新组装成 [\u0060iptables\u0060 ](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)规则，关于该命令的详细用法请访问 [tools\/istio-iptables\/pkg\/cmd\/root.go](https:\/\/github.com\/istio\/istio\/blob\/master\/tools\/istio-iptables\/pkg\/cmd\/root.go)。\n\n该容器存在的意义就是让 sidecar 代理可以拦截所有的进出 pod 的流量，15090 端口（Mixer 使用）和 15092 端口（Ingress Gateway）除外的所有入站（inbound）流量重定向到 15006 端口（sidecar），再拦截应用容器的出站（outbound）流量经过 sidecar 处理（通过 15001 端口监听）后再出站。关于 Istio 中端口用途请参考 [Istio 官方文档](https:\/\/istio.io\/latest\/zh\/docs\/ops\/deployment\/requirements\/)。\n\n**命令解析**\n\n这条启动命令的作用是：\n\n- 将应用容器的所有流量都转发到 sidecar 的 15006 端口。\n- 使用 \u0060istio-proxy\u0060 用户身份运行，UID 为 1337，即 sidecar 所处的用户空间，这也是 \u0060istio-proxy\u0060 容器默认使用的用户，见 YAML 配置中的 \u0060runAsUser\u0060 字段。\n- 使用默认的 \u0060REDIRECT\u0060 模式来重定向流量。\n- 将所有出站流量都重定向到 sidecar 代理（通过 15001 端口）。\n\n因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 sidecar 容器中。\n\n## Pod 启动流程\n\n启用了 Sidecar 自动注入的 Pod 启动流程如下：\n\n1. Init 容器先启动，向 Pod 中注入 iptables 规则，进行透明流量拦截。\n2. 随后，Kubernetes 会根据 Pod Spec 中容器的声明顺序依次启动容器，但这是非阻塞的，无法保证第一个容器启动完成后才启动下一个。\u0060istio-proxy\u0060 容器启动时，\u0060pilot-agent\u0060 将作为 PID 1 号进程，它是 Linux 用户空间的第一个进程，负责拉起其他进程和处理僵尸进程。\u0060pilot-agent\u0060 将生成 Envoy bootstrap 配置并拉起 \u0060envoy\u0060 进程；应用容器几乎跟 \u0060istio-proxy\u0060 容器同时启动，为了防止 Pod 内的容器在还没启动好的情况而接收到外界流量，这时候就绪探针就派上用场了。Kubernetes 会在 \u0060istio-proxy\u0060 容器的 15021 端口进行就绪检查，直到 \u0060isito-proxy\u0060 启动完成后 kubelet 才会将流量路由到 Pod 内。\n3. 在 Pod 启动完成后，\u0060pilot-agent\u0060  将变为守护进程监视系统其他进程，除此之外，该进程还为 Envoy 提供 Bootstrap 配置、证书、健康检查、配置热加载、身份支持及进程生命周期管理等。\n\n## Pod 内容器启动顺序问题\n\n在 Pod 启动的过程中存在容器启动顺序问题，假设下面这种情况，应用容器先启动，请求其他服务，这时候 \u0060istio-proxy\u0060 容器还没启动完成，那么该请求将会失败，如果你的应用的健壮性不足，甚至可能导致应用容器崩溃，进而 Pod 重启。对于这种情况的解决方案是：\n\n- 修改应用程序，增加超时重试。\n- 增加应用容器中进程的启动延迟，比如增加 \u0060sleep\u0060 时间。\n- 在应用容器中增加一个 [\u0060postStart\u0060](https:\/\/kubernetes.io\/zh\/docs\/tasks\/configure-pod-container\/attach-handler-lifecycle-event\/) 配置，检测应用进程是否启动完成，只有当检测成功时，Kubernetes 才会将 Pod 的状态标记为 \u0060Running\u0060。\n\n## 总结\n\n这篇文章带领大家了解了 Istio 数据平面中的 Pod 启动过程，还有因为 Pod 内容器启动顺序带来的问题。\n\n## 参考\n\n- istio 常见问题：Sidecar 启动顺序问题 - imroc.cc\n', '\/blog\/istio-pod-process-lifecycle\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为你讲解 Istio 的 Init 容器、Pod 内部进程及启动过程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-iptables/">理解 iptables</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 iptables', '本文将为大家简单介绍下 iptables，其中的表及执行顺序。', '\niptables 作为 Linux 内核中的重要功能，有着广泛的应用，在 Istio 中默认就是利用 iptables 做透明流量劫持的。理解 iptables，对于我们理解 Istio 的运作有十分重要的作用。本文将为大家简单介绍下 iptbles。\n\n## iptables 简介\n\n\u0060iptables\u0060 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。\n\n在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。\n\n下图展示了 iptables 调用链。\n\n![iptables 调用链](iptables.jpg)\n\n[图片来源](https:\/\/stuffphilwrites.com\/wp-content\/uploads\/2014\/09\/FW-IDS-iptables-Flowchart-v2019-04-30-1.png)\n\n## iptables 中的表\n\nInit 容器中使用的的 iptables 版本是 \u0060v1.6.0\u0060，共包含 5 张表：\n\n1. \u0060raw\u0060 用于配置数据包，\u0060raw\u0060 中的数据包不会被系统跟踪。\n1. \u0060filter\u0060 是用于存放所有与防火墙相关操作的默认表。\n1. \u0060nat\u0060 用于 [网络地址转换](https:\/\/en.wikipedia.org\/wiki\/Network_address_translation)（例如：端口转发）。\n1. \u0060mangle\u0060 用于对特定数据包的修改（参考[损坏数据包](https:\/\/en.wikipedia.org\/wiki\/Mangled_packet)）。\n1. \u0060security\u0060 用于[强制访问控制](https:\/\/wiki.archlinux.org\/index.php\/Security#Mandatory_access_control) 网络规则。\n\n**注**：在本示例中只用到了 \u0060nat\u0060 表。\n\n不同的表中的具有的链类型如下表所示：\n\n| 规则名称    | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      |      | ✓      | ✓        |\n| OUTPUT      | ✓    | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     |      | ✓      |      | ✓      | ✓        |\n\n## 理解 iptables 规则\n\n查看 \u0060istio-proxy\u0060 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\n我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为 INPUT\/FORWARD\/OUTPUT），后跟默认策略（ACCEPT）。\n\n每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。\n\n- **pkts**：处理过的匹配的报文数量\n- **bytes**：累计处理的报文大小（字节数）\n- **target**：如果报文与规则匹配，指定目标就会被执行。\n- **prot**：协议，例如 \u0060tdp\u0060、\u0060udp\u0060、\u0060icmp\u0060 和 \u0060all\u0060。\n- **opt**：很少使用，这一列用于显示 IP 选项。\n- **in**：入站网卡。\n- **out**：出站网卡。\n- **source**：流量的源 IP 地址或子网，或者是 \u0060anywhere\u0060。\n- **destination**：流量的目的地 IP 地址或子网，或者是 \u0060anywhere\u0060。\n\n还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。\u0060prot\u0060、\u0060opt\u0060、\u0060in\u0060、\u0060out\u0060、\u0060source\u0060 和 \u0060destination\u0060 和显示在 \u0060destination\u0060 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 \u0060target\u0060。\n\n**target 支持的类型**\n\n\u0060target\u0060 类型包括 ACCEPT\u0060、REJECT\u0060、\u0060DROP\u0060、\u0060LOG\u0060 、\u0060SNAT\u0060、\u0060MASQUERADE\u0060、\u0060DNAT\u0060、\u0060REDIRECT\u0060、\u0060RETURN\u0060 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 \u0060RETURN\u0060 类型，类似编程语言中的 \u0060return\u0060 语句，返回到它的调用点，继续执行下一条规则。\u0060target\u0060 支持的配置详解请参考 [iptables 详解（1）：iptables 概念](http:\/\/www.zsythink.net\/archives\/1199)。\n\n## 总结\n\n以上就是对 iptables 的简要介绍，你已经了解了 iptables 是怎样运行的，规则链及其执行顺序。\n', '\/blog\/understanding-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为大家简单介绍下 iptables，其中的表及执行顺序。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-components-and-ports/">Istio 中的各组件端口及功能详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的各组件端口及功能详解', '本文将向你介绍 Istio 控制平面和数据平面的各个端口及功能。', '\n在我的前两篇博客中：\n\n- [Istio 中的 Sidecar 注入、透明流量劫持及流量路由过程详解](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/)\n- [Sidecar 中的流量类型及 iptables 规则详解](https:\/\/jimmysong.io\/blog\/istio-sidecar-traffic-types\/)\n\n我向你详细介绍了 Istio 数据平面中的流量，但数据平面并不能孤立的存在，本文将向你展示 Istio 中的控制平面和数据平面各组件的端口及其功能，有助于你了解这些流量之间的关系及故障排查。\n\n## Istio 中的组件及端口示意图\n\n按照习惯，我们首先展示一个全局示意图。下图展示的是 Istio 数据平面中 sidecar 的组成，以及与其交互的对象。\n\n![Istio sidecar 组成示意图](istio-ports-components.webp)\n\n我们可以使用 \u0060nsenter\u0060 命令进入 Bookinfo 示例的 \u0060productpage\u0060  Pod 的网络空间，查看其内部监听的端口信息。\n\n![Istio sidecar 中监听的端口信息](sidecar-ports.webp)\n\n从图中我们可以看到除了 \u0060productpage\u0060 应用本身监听的 9080 端口以外，Sidecar 容器还有监听大量的其他端口，如 \u006015000\u0060、\u006015001\u0060、\u006015004\u0060、\u006015006\u0060、\u006015021\u0060、\u006015090\u0060 等，你可以在 Istio 文档上了解 Istio 中使用的端口。\n\n我们再进入 \u0060productpage\u0060 Pod 中，使用 \u0060lsof -i\u0060 命令查看它打开的端口，如下图所示。\n\n![Productpage Pod 中打开的端口](product-pod-ports.webp)\n\n我们可以看到其中有 \u0060pilot-agent\u0060 与 \u0060istiod\u0060 建立了 TCP 连接，上文中所述的监听中的端口，还有在 Pod 内部建立的 TCP 连接，这些连接对应了文章开头的示意图。\n\nSidecar 容器（\u0060istio-proxy\u0060 ）的根进程是 \u0060pilot-agent\u0060，启动命令如下图所示：\n\n![Sidecar 中的进程](sidecar-procecces.webp)\n\n从图中我们可以看到，它 \u0060pilot-agent\u0060 进程的 PID 是 1，是它拉起了 \u0060envoy\u0060 进程。\n\n在 \u0060istiod\u0060 的 Pod 中查看它打开的端口，如下图所示。\n\n![Istiod 中的端口](sidecar-lsof.webp)\n\n我们可以看到其中的监听的端口、进程间和远程通信连接。\n\n## Istio 中各端口的功能概述\n\n这些端口在你进行问题排查时可以起着举足轻重的作用。下面将根据端口所在的组件和功能分类描述。\n\n## Istiod 中的端口\n\nIstiod 中的端口相对比较少且功能单一：\n\n- 9876：ControlZ 用户界面，暴露 \u0060istiod\u0060 的进程信息\n- 8080：\u0060istiod\u0060 调试端口，通过该端口可以查询网格的配置和状态信息\n- 15010：暴露 xDS API 和颁发纯文本证书\n- 15012：功能同 15010 端口，但使用 TLS 通信\n- 15014：暴露控制平面的指标给 Prometheus\n- 15017：Sidecar 注入和配置校验端口\n\n## Sidecar 中的端口\n\n从上文中，我们看到 sidecar 中有众多端口：\n\n- 15000：Envoy [管理接口](https:\/\/jimmysong.io\/envoy-handbook\/admin-interface\/enabling-admin-interface.html)，你可以用它来查询和修改 Envoy 代理的的配置，详情请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/operations\/admin)。\n- 15001：用于处理出站流量。\n- 15004：调试端口，将在下文中解释。\n- 15006：用于处理入站流量。\n- 15020：汇总统计数据，对 Envoy 和 DNS 代理进行健康检查，调试 \u0060pilot-agent\u0060  进程，将在下文中详细解释。\n- 15021：用于 sidecar 健康检查，以判断已注入 Pod 是否准备好接收流量。我们在该端口的 \u0060\/healthz\/ready\u0060 路径上设置了就绪探针，Istio 把 sidecar 的就绪检测交给了 \u0060kubelet\u0060，最大化利用 Kubernetes 平台自身的功能。\u0060envoy\u0060  进程将健康检查路由到 \u0060pilot-agent\u0060 进程的 15020 端口，实际的健康检查将发生在那里。\n- 15053：本地 DNS 代理，用于解析 Kubernetes DNS 解析不了的集群内部域名的场景。\n- 15090：Envoy Prometheus 查询端口，\u0060pilot-agent\u0060 将通过此端口收集统计信息。\n\n以上端口可以分为以下几类：\n\n- 负责进程间通信，例如 15001、15006、15053\n- 负责健康检查和信息统计，例如 150021、15090\n- 调试：15000、15004\n\n下文将对几个重点端口详解。\n\n## 15000 端口\n\n15000 是 Envoy 的 Admin 接口，该接口允许我们修改 Envoy，并获得一个视图和查询指标和配置。\n\n管理接口由一个具有多个端点的 REST API 和一个简单的用户界面组成，你可以使用下面的命令开启 \u0060productpage\u0060 Pod 中的 Envoy 管理接口视图。\n\n\u0060\u0060\u0060bash\nkubectl -n default port-forward deploy\/productpage-v1 15000\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/localhost:15000\u0060，你将看到 Envoy Admin 界面如下图所示。\n\n![Envoy Admin 界面](envoy-admin.webp)\n\n## 15004 端口\n\n通过 \u0060pilot-agent\u0060 代理 \u0060istiod\u0060 8080 端口上的调试端点，你可以进入数据平面 Pod 中访问 localhost 的 15004 端口查询网格信息，其效果与下面的 8080 端口等同。\n\n## 8080 端口\n\n你还可以在本地转发 \u0060istiod\u0060  8080 端口，请运行下面的命令。\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward deploy\/istiod 8080\n\u0060\u0060\u0060\n\n在浏览器中访问 \u0060http:\/\/localhost:8080\/debug\u0060，你将看到调试端点，如下图所示。\n\n![Pilot 调试控制台](pilot-debug-console.webp)\n\n当然，这只是一种获取网格信息和调试网格的方式，你还可以使用 \u0060istioctl\u0060 命令或 Kiali 来调试，那样将更加高效和直观。\n\n## 15020 端口\n\n15020 端口有三大功能：\n\n1. 汇总统计数据：查询 15090 端口获取 \u0060envoy\u0060 的指标，也可以配置查询应用程序的指标，将 \u0060envoy\u0060、应用程序和自身的指标汇总以供 Prometheus 收集。对应的调试端点是 \u0060\/stats\/prometheus\u0060。\n2. 对 Envoy 和 DNS 代理进行健康检查：对应的调试端点是 \u0060\/healthz\/ready\u0060 和 \u0060\/app-health\u0060。\n3. 调试 \u0060pilot-agent\u0060  进程：对应的调试端点是 \u0060\/quitquitquit\u0060、\u0060debug\/ndsz\u0060 和 \u0060\/debug\/pprof\u0060。\n\n下图展示的是使用本地端口转发后，在浏览器中打开 \u0060http:\/\/localhost:15020\/debug\/pprof\u0060 看到的调试信息。\n\n![pprof 端点](pprof.webp)\n\n图中信息展示的是 \u0060pilot-agent\u0060 的堆栈信息。\n\n## 总结\n\n通过对 Istio 中各组件端口的了解，你应该对 Istio 中各组件的关系及其内部流量有了更进一步的认识，熟悉这些端口的功能，有助于对网格的故障排除。\n', '\/blog\/istio-components-and-ports\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你介绍 Istio 控制平面和数据平面的各个端口及功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-sidecar-traffic-types/">Istio sidecar 中的流量类型及 iptables 规则详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/05/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio sidecar 中的流量类型及 iptables 规则详解', '本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。', '\n我在[之前的一篇博客中](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/)讲解过 Istio 中 sidecar 的注入、使用 iptables 进行透明流量拦截及流量路由的详细过程，并以 Bookinfo 示例中的 \u0060productpage\u0060 服务访问 \u0060reviews\u0060 服务，和 \u0060reviews\u0060 服务访问 \u0060ratings\u0060 服务为例绘制了透明流量劫持示意图。在那个示意图中仅展示了 \u0060reviews\u0060 pod 接收流量和对外访问的路由，实际上 sidecar 内的流量远不止于此。\n\n## ISTIO_OUTPUT 规则\n\n在所有的 iptables 调用链中最复杂的一个是 \u0060ISTIO_OUTPUT\u0060，其中共有 9 条规则如下：\n\n| **Rule** | **Target**        | **In** | **Out** | **Source** | **Destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n\n本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，以示意图的形式带你一览其全貌，其中详细指出了路由具体使用的是 \u0060ISTIO_OUTPUT\u0060 中的哪一条规则。\n\n## Sidecar 中的 iptables 流量路由\n\nSidecar 中的流量可以划分为以下几类：\n\n- 远程服务访问本地服务：Remote Pod -\u003e Local Pod\n- 本地服务访问远程服务：Local Pod -\u003e Remote Pod\n- Prometheus 抓取本地服务的 metrics：Prometheus -\u003e Local Pod\n- 本地 Pod 服务间的流量：Local Pod -\u003e Local Pod\n- Envoy 内部的进程间 TCP 流量\n- Sidecar 到 Istiod 的流量\n\n下面将依次解释每个场景下 Sidecar 内的 iptables 路由规则。\n\n## 类型一：Remote Pod -\u003e Local Pod\n\n以下是远程服务、应用或客户端访问数据平面本地 Pod IP 的 iptables 规则。\n\nRemote Pod -\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060 -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n我们看到流量只经过一次 Envoy 15006 Inbound 端口。这种场景下的 iptables 规则的示意图如下。\n\n![Remote Pod 到 Local Pod](remote-pod-local-pod.svg)\n\n## 类型二：Local Pod -\u003e Remote Pod\n\n以下是本地 Pod IP 访问远程服务经过的 iptables 规则。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e ISTIO_REDIRECT -\u003e Envoy 15001 (Outbound)-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060 -\u003e Remote Pod\n\n我们看到流量只经过 Envoy 15001 Outbound 端口。\n\n![Local Pod 到 Remote Pod](local-pod-remote-pod.svg)\n\n以上两种场景中的流量都只经过一次 Envoy，因为该 Pod 中只有发出或接受请求一种场景发生。\n\n## 类型三：Prometheus -\u003e Local Pod\n\nPrometheus 抓取数据平面 metrics 的流量不会也无须经过 Envoy 代理。\n\n这些流量通过的 iptables 规则如下。\n\nPrometheus-\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060（对目的地为 15020、15090 端口流量将转到 \u0060INPUT\u0060）-\u003e \u0060INPUT\u0060 -\u003e  Local Pod\n\n这种场景下的 iptables 规则的示意图如下。\n\n![Prometheus 到 Local Pod](prometheus-local-pod.svg)\n\n## 类型四：Local Pod -\u003e Local Pod\n\n一个 Pod 可能同时存在两个或多个服务，如果 Local Pod 访问的服务也在该当前 Pod 上，流量会依次经过 Envoy 15001 和 Envoy 15006 端口最后到达本地 Pod 的服务端口上。\n\n这些流量通过的 iptables 规则如下。\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e \u0060ISTIO_REDIRECT\u0060 -\u003e Envoy 15001（Outbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 2** -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n![Local Pod 到 Local Pod](local-pod-local-pod.svg)\n\n## 类型五：Envoy 内部的进程间 TCP 流量\n\nEnvoy 内部进程的 UID 和 GID 为 1337，它们之间的流量将使用 lo 网卡，使用 localhost 域名来通信。\n\n这些流量通过的 iptables 规则如下。\n\nEnvoy 进程（Localhost） -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 8** -\u003e \u0060POSTROUTING\u0060 -\u003e Envoy 进程（Localhost）\n\n![Envoy 内部的进程间 TCP 流量](envoy-internal-tcp-traffic.svg)\n\n## 类型六：Sidecar 到 Istiod 的流量\n\nSidecar 需要访问 Istiod 以同步配置，\u0060pilot-agent\u0060 进程会向 Istiod 发送请求，以同步配置。\n\n这些流量通过的 iptables 规则如下。\n\n\u0060pilot-agent\u0060 进程 -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060Istio_OUTPUT\u0060 RULE 9** -\u003e Envoy 15001 (Outbound Handler) -\u003e OUTPUT -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060  -\u003e Istiod\n\n![Sidecar 到 Istiod 的流量](sidecar-istiod.svg)\n\n## 总结\n\nIstio 注入在 Pod 内或虚拟机中安装的所有 sidecar 代理组成了服务网格的数据平面，也是 Istio 的主要工作负载所在地，通过 [Istio 中的透明流量劫持](https:\/\/jimmysong.io\/blog\/sidecar-injection-iptables-and-traffic-routing\/) 及这篇博客，相信你一定对 sidecar 代理中的流量有了一个深刻的了解，但这还只是管中窥豹，略见一斑，在我的[下一篇博客](https:\/\/jimmysong.io\/blog\/istio-components-and-ports\/)中，我将带你了解 Envoy 中各个组件的端口及其功能，这样可以让我们对 Istio 中的流量有一个更全面的了解。\n', '\/blog\/istio-sidecar-traffic-types\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你展示 Istio sidecar 中的六种流量类型及其 iptables 规则，并以示意图的形式带你一览其全貌。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-has-applied-to-join-the-cncf/">Istio 捐献给 CNCF 意味着什么？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/04/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 捐献给 CNCF 意味着什么？', '来自 Tetrate CEO、Istio 联合创始人 Varun Talwar 的解读。', '\n在 2022 年 4 月 25 日，IstioCon 2022 开幕的当天，Istio 社区宣布正在[申请将项目捐献给 CNCF](https:\/\/istio.io\/latest\/blog\/2022\/istio-has-applied-to-join-the-cncf\/)，这是 Istio 项目的一个里程碑，企业级服务网格公司 Tetrate 的 CEO\/Istio 项目联合创始人 Varun Talwar 对此进行了解读。\n\n以下是来自 Varun 对 Istio 捐献给 CNCF 的[解读](https:\/\/www.tetrate.io\/blog\/istio-has-applied-to-join-the-cncf\/)。\n\n------\n\n将 Istio 纳入 CNCF，使得 Istio 和 Envoy 的发展更容易同步推进。它还有助于将 Istio 与 Envoy 一起定位为 CNCF 验证的 \u0022云原生技术栈\u0022 的一部分。根据 CNCF 的年度[调查](https:\/\/www.cncf.io\/reports\/cncf-annual-survey-2021\/)，到目前为止，Istio 是生产中最受欢迎和使用最多的服务网格。有 20 多家不同的公司在推动 Istio 社区的发展，这一宣布为 CNCF 管理下的持续创新和增长创造了条件。\n\n## 2016：Istio 的起源\n\n我想借此机会解释一下 Istio 的起源。Istio 来自谷歌的 API 平台团队，名为 One Platform。(今天，具有讽刺意味的是，Istio 是美国政府项目 [Platform One](https:\/\/www.tetrate.io\/blog\/tetrate-first-to-provide-hardened-istio-to-dods-iron-bank\/) 的一部分，它使用 Tetrate 产品和服务）。一个平台利用了谷歌所有的基础设施优势（stubby、monarch、loas 等），并增加了最初的服务管理经验，并将其全部暴露给应用团队。\n\n每个团队都会编写他们的方案和方法，并定义他们的 \u0022One Platform API\u0022。一旦与 API 平台团队达成一致，各团队就不必再处理任何跨领域的问题，因为 Istio 处理了这些服务：流量管理、弹性、可观测性（使用具有一致名词的每个服务的预建仪表板）、认证、授权、速率限制等等。\n\nIstio 的想法来自于此；我们基本上采用了 One Platform 的想法，将 Envoy 加入其中（作为一个更好的数据平面），并将其与 LOAS 服务身份概念相结合，也就是今天世人所知的 Spiffe）。我们把这个想法告诉了 12 家公司，他们都很喜欢这个想法。这些公司包括大型互联网公司、金融服务公司和科技公司，特别是 SaaS 供应商。\n\n## 2017：形成核心\n\n2017 年 5 月的，Istio 在 Gluecon 上[首次公布](https:\/\/cloud.google.com\/blog\/products\/gcp\/istio-modern-approach-to-developing-and)。0.1 展示了 Istio 的潜力，引发了大量的关注和讨论。\n\n## 2018-2019：稳定核心，增加能力\n\n接下来的两年里，我们收集了客户的需求，将使用反馈内化，并稳定了核心功能。此外，我们还做出了一些关键的架构决定，如定义多集群模型，并将代码重新架构为一个单一的二进制文件，以方便使用。\n\n## 2020：团结社区\n\n随着 Istio 的采用和用户生态系统的发展，人们对管理和商标保护的担忧也越来越大。然而，正如我们在[这里](https:\/\/www.tetrate.io\/blog\/istio-ouc\/)所提到的，作为一个社区保持团结是项目成功的关键。我可以自豪地说，Istio 就是这样做的。因此，今天加入 CNCF 的行动是发展社区和建立最终用户信任的又一步骤。\n\n## 2021：向 Wasm 和其他领域发展\n\n人们对加入其他基础设施，如虚拟机、功能和裸机工作负载，以及使用 Wasm 等技术的定制和其他功能作为本地 API 的兴趣越来越大，这样用户就不必再使用 Envoy 过滤器了。2021 年见证了其中一些功能的建立和推广。\n\n\u0022Varun Talwar 是项目的创始人之一，他一直认为 Istio 是云原生生态系统的一个重要组成部分。今天的公告验证了他对项目的愿景，我要感谢 Tetrate 成为 Istio 和我们社区的有力支持者。\u0022——Louis Ryan（Istio 联合创始人，谷歌工程负责人）\n\n## 零信任的基础\n\n关于零信任的话题已经有很多讨论，但很少有明确的说法。正如 Eric Brewer 今天在 IstioCon 的[主题演讲](https:\/\/events.istio.io\/istiocon-2022\/sessions\/zero-trust-istio\/)中提到的，Istio 正在成为零信任的一个重要组成部分。其中最主要的是面向身份的控制，而不是面向网络的控制。这方面的核心原则在谷歌白皮书[《BeyondProd：云原生安全的新方法》](https:\/\/cloud.google.com\/blog\/products\/identity-security\/beyondprod-whitepaper-discusses-cloud-native-security-at-google)。\n\n然而，作为一个行业，这里有更多的事情要做。我们需要确保我们可以把应用用户和数据服务都带进来。如果我们能将身份概念扩展到用户，并为我们提供灵活而丰富的策略机制来指定、监控和跟踪访问控制，我们就能达到一个可操作的零信任结构 —— 一个将用户、服务和数据统一到一个管理层的结构。我在 2020 年为美国国家标准与技术研究院（NIST）举办的围绕信任云原生应用的主题演讲中也提到了这一点。这就是为什么我们在 Tetrate 创建了 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)—— 一个管理平面，使大型组织可操作。\n\nTetrate Service Bridge 的基础是：\n\n- 用户、服务和数据的身份。每个人都有一个加密身份，构成所有政策的骨干。\n- 策略和访问控制。定义 Istio 策略，也包括应用和组织策略，包括用户和设备，以及大规模管理它们的能力。\n- 自动化。在运行时自动化、测量和持续监测策略的能力。\n\n如果我们能让企业以这种方式为云原生工作负载部署和运营安全，我们就能作为一个行业取得巨大进步。\n\n## 人才\n\n归根结底，没有高素质、富有创造性的人才，任何项目或技术都不会成为主流。在 Tetrate，我们相信我们需要对社区进行有关这项技术的教育，并为负责任的采用路径做出贡献。因此，我们提供世界级的认证和免费的在线培训课程，使社区中的任何人都可以在 [academy.terate.io](https:\/\/academy.tetrate.io\/) 轻松参加 Istio 和 Envoy 的初级和高级课程。\n\n我们 Tetrate 的所有人，特别是我自己，都期待着下一步的发展，我们将始终支持 Istio 项目和社区。\n', '\/blog\/istio-has-applied-to-join-the-cncf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">来自 Tetrate CEO、Istio 联合创始人 Varun Talwar 的解读。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-new-in-istio-1-13/">Istio 1.13 有哪些值得注意的更新？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/03/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.13 有哪些值得注意的更新？', '2022 年 2 月 Istio 发布 Istio 1.13.0 和 Istio 1.13.1，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。', '\n2022 年 2 月 Istio 发布 [1.13.0](https:\/\/istio.io\/latest\/news\/releases\/1.13.x\/announcing-1.13\/) 和 [1.13.1](https:\/\/istio.io\/latest\/news\/releases\/1.13.x\/announcing-1.13.1\/)，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。\n\nIstio 1.13 是 2022 年的第一个版本，不出意外的话，Istio 团队会依然按照每个季度的频率发布新版本。总体来看，这个版本中的新特性包括：\n\n- 对 Kubernetes 更新版本的支持\n- 引入了一个新的 API——ProxyConfig，用来配置 sidecar proxy\n- 完善了 Telemetry API\n- 支持多网络网关的基于主机名的负载均衡器\n\n## 对 Kubernetes 版本的支持\n\n我经常看到有人在社区里问 Istio 支持哪些 Kubernetes 版本，其实 Istio 官网中已经明确列出了支持的 Kubernetes 版本，你可以在[这里](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases)看到，Istio 1.13 支持 Kubernetes 1.20、1.21、1.22 和 1.23 版本，并在 Kubernetes 1.16、1.17、1.18、1.19 中测试过，但并得到官方支持。\n\n在配置 Istio 的时候，其实还有很多检查列表，我将他们都记录到了 [Istio cheatsheet](https:\/\/github.com\/tetratelabs\/istio-cheatsheet) 中，这个项目中整理了很多关于配置 Istio、资源对象的使用、常见问题处理等相关的 cheatsheet，将于近期上线，敬请期待。\n\n![Istio cheatsheet 页面截图](istio-cheatsheet.jpg)\n\n## 引入新的 ProxyConfig API\n\n在 Istio 1.13 版本之前，如果你想自定义 sidecar proxy 的配置，有两种方式。\n\n**\u0060方式一：MeshConfig\u0060**\n\n使用 \u0060MeshConfig\u0060，在 Mesh 级别使用 IstioOperator 来修改。例如，使用下面的配置来修改 \u0060istiod\u0060 的默认发现端口。\n\n\u0060\u0060\u0060yaml\napVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n\t  defaultConfig:\n      discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n**方式二：Pod 中的 annotation**\n\n你也可以在 Pod 级别使用 annotation 的方式自定义配置，例如在 Pod 中增加下面的配置同样可以修改工作负载所有连接的 \u0060istiod\u0060 的默认端口。 \n\n\u0060\u0060\u0060yaml\nanannotations:\n  proxy.istio.io\/config: |\n    discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n当你同时使用了以上两种方式配置了 sidecar，\u0060annotations\u0060 中设置的字段将完全覆盖 \u0060MeshConfig\u0060 默认的字段。关于 \u0060ProxyConfig\u0060 的所有配置项请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#ProxyConfig)。\n\n**新方式：\u0060ProxyConfig\u0060 API**\n\n但是在 1.13 版本中，新增了一个顶级自定义资源 \u0060ProxyConfig\u0060，你可以一站式的在一个地方来自定义 sidecar proxy 的配置，你可以通过指定 namespace、使用 \u0060selector\u0060 来选择工作负载的范围，就像其他 CRD 一样。目前 Istio 对该 API 的支持有限，关于 \u0060ProxyConfig\u0060 API 的详细信息请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/proxy-config\/)。\n\n但是不论你用哪种方式自定义 sidecar proxy 的配置，该配置都无法动态生效，需要重启工作负载才可以生效。例如，对于上面的配置，因为你修改了 \u0060istiod\u0060 的默认端口，mesh 中的所有工作负载都需要重启才可以与 control plane 建立连接。\n\n## Telemetry API\n\n在 Istio 服务网格中，很多扩展和自定义的配置都是通过 [\u0060MeshConfig\u0060](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-ExtensionProvider) 的方式来完成的。可观测性的三种类型 Metric、遥测和日志，分别可以对接不同的提供者，[Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/) 可以让你有一个一站式的灵活的配置它们。与 ProxyConfig API 类似，Telemetry API 也遵循着工作负载选择器\u003e本地命名空间\u003e根配置命名空间的配置层级关系。该 API 是在 Istio 1.11 中引入，在该版本中得到了进一步完善，增加了 \u0060OpenTelemetry\u0060 日志、过滤访问日志以及自定义跟踪服务名称的支持。详见 [Telemetry 配置](https:\/\/istio.io\/latest\/docs\/reference\/config\/telemetry\/)。\n\n## 自动解析多网络网关主机名\n\n2021 年 9 月，Istio 社区里[有人报告](https:\/\/szabo.jp\/2021\/09\/22\/multicluster-istio-on-eks\/)，在 AWS EKS 中运行多集群多主的 Istio 时，出现 EKS 的负载均衡器无法解析的问题。对于多集群多网络的网格，跨集群边界的服务负载，需要通过专用的东西向网关，以间接的方式通讯。你可以按照 [Istio 官网上的说明](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)配置多网络的 primary-remote 集群，Istio 会根据主机名自动解析负载均衡器的 IP 地址。\n\n## Istio 1.13.1 修复重大安全漏洞\n\n当月，Istio 1.13.1 发布，修复了一个已知的[重大漏洞](https:\/\/cve.mitre.org\/cgi-bin\/cvekey.cgi?keyword=CVE-2022-23635)，该漏洞可能导致未经认证的控制平面拒绝服务攻击。\n\n![跨网络的主从集群](primary-remote-cluster-mesh.jpg)\n\n在安装多网络的 [primary-remote](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/) 模式的 Istio 网格时，为了让 remote Kubernetes 集群能够访问控制平面，需要在 primary 集群中安装一个东西向的 Gateway，将控制平面 \u0060istiod\u0060 的 15012 端口暴露到互联网。攻击者可能向该端口发送特制的消息，导致控制平面崩溃。如果你设置了防火墙，只允许来自部分 IP 的流量访问该端口，将可以缩小该问题的影响范围。建议你立即升级到 Istio 1.13.1 来彻底解决该问题。\n\n## IstioCon 2022\n\n![IstioCon 2022](istiocon-2022.jpg)\n\n最后，作为上一届和本届 IstioCon 的筹备委员会成员之一，我号召大家报名参加 4 月 25 日在线上举行的 [IstioCon 2022](https:\/\/events.istio.io\/istiocon-2022\/)！IstioCon 2022 是一个以行业为重点的活动，一个连接贡献者和用户的平台，讨论 Istio 在不同架构设置中的用途，有哪些限制，以及项目的下一步发展方向。主要的焦点将是在最终用户公司，因为我们期待着分享多样化的案例研究，展示如何在生产中使用 Istio。\n', '\/blog\/what-is-new-in-istio-1-13\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">2022 年 2 月 Istio 发布 Istio 1.13.0 和 Istio 1.13.1，这篇博客将想你介绍这两个版本中有哪些值得注意的新特性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/7/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/9/" class="page-link">
             9
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/9/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
