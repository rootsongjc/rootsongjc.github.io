<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/doordash-service-mesh/">[译] DoorDash 的服务网格之旅：如何实现高效的区域感知路由</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://doordash.engineering/2024/01/16/staying-in-the-zone-how-doordash-used-a-service-mesh-to-manage-data-transfer-reducing-hops-and-cloud-spend/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('DoorDash 的服务网格之旅：如何实现高效的区域感知路由', '本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。', '\nDoorDash 从单体应用架构演变为基于[单元（cells）](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)和[微服务（microservices）](https:\/\/doordash.engineering\/2020\/12\/02\/how-doordash-transitioned-from-a-monolith-to-microservices\/)架构后，获得了许多好处。新的架构降低了开发、测试和部署所需的时间，同时提高了可伸缩性和用户体验，包括商家、送餐员和消费者。然而，随着微服务和后端数量的增加，DoorDash 注意到了跨可用区（AZ）的数据传输成本上升。这些数据传输成本 — [在发送和接收时发生](https:\/\/aws.amazon.com\/blogs\/architecture\/overview-of-data-transfer-costs-for-common-architectures\/) — 允许 DoorDash 为其最终用户提供高可用性的服务，可以抵御一个或多个 AZ 的降级。\n\n成本上升促使我们的工程团队调查了以更高效的方式提供相同级别的服务的替代方法。在本博客文章中，我们描述了 DoorDash 使用服务网格实现数据传输成本节省而不牺牲服务质量的过程。\n\n## DoorDash 流量架构\n\n在我们深入解决方案之前，让我们回顾一下 DoorDash 的流量基础设施。\n\n*基于单元的架构：* 如下图所示，我们的流量架构遵循[基于单元的设计](https:\/\/www.youtube.com\/watch?v=ReRrhU-yRjg)。所有微服务 Pod 都部署在多个隔离的单元中。每个服务在每个单元中都有一个 Kubernetes 部署。为了确保单元之间的隔离，不允许单元间的流量。这种方法使我们能够减小单个单元故障的影响范围。对于单例服务或尚未迁移到单元架构的服务，部署在一个全局单元中。内部的[Envoy](https:\/\/www.envoyproxy.io\/)路由器允许全局单元与复制的单元之间进行通信。\n\n*Kubernetes 集群部署：* 每个单元由多个 Kubernetes 集群组成；每个微服务都专门部署在给定单元内的一个集群中。这个设计确保了可伸缩性和可靠性，同时与我们的基于单元的架构保持一致。\n\n![图 1：基于单元的多集群部署](f1.jpg)\n\n*高可用性：* 为了增强可用性和容错性，每个 Kubernetes 集群都部署在多个 AZ 中。这个做法最大程度地减少了由于一个或多个 AZ 中断引起的中断。\n\n*平面网络中的直接通信：* 利用[AWS-CNI](https:\/\/github.com\/aws\/amazon-vpc-cni-k8s)，在一个单元中的不同集群中的微服务 Pod 可以直接通信。这种平面网络架构简化了通信路径，促进了微服务之间的高效交互。\n\n*自定义多集群服务发现：* 我们的自定义服务发现解决方案，DoorDash 数据中心服务发现（DDSD），提供了一个自定义的 DNS 域，以支持多集群通信。客户端使用 DNS 名称动态发现所需服务的所有 Pod IP 地址。DDSD 的功能类似于 Kubernetes 的[无头服务](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/service\/#headless-services)，但它也适用于集群间通信。例如，不同集群中的客户端可以使用*payment-service.service.prod.ddsd*来检索与支付服务相关联的所有 Pod IP 地址。\n\n*客户端负载平衡：* 服务网格负责客户端负载平衡。对于未加入服务网格的服务，负载平衡发生在客户端应用程序端。\n\n图 2 描述了上述四个特征：\n\n![图 2：单元内和跨 AZ 通信模式](f2.jpg)\n\n*服务网格架构：* 如图 3 所示，DoorDash 的服务网格部署在每个单元中，采用了一种边车容器设计模式，利用[Envoy](https:\/\/www.envoyproxy.io\/)代理作为数据平面。我们建立了我们自己的基于[xDS 的](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)控制平面来管理 Envoy 配置。边车容器作为一种即插即用的解决方案，可以在不需要对应用程序代码进行任何修改的情况下，无缝地拦截、控制和转换进出 DoorDash 微服务的所有 HTTP1\/HTTP2\/gRPC 流量。\n\n![图 3：服务网格高级架构](f3.jpg)\n\n虽然 DoorDash 的流量架构具有独特的组件，但我们认为我们在网络流量效率方面遇到的挑战和经验可以广泛应用于其他架构。\n\n## DoorDash 的常见数据传输模式\n\n对于跨可用区的流量，我们将我们的流量模式分类如下：\n\n*HTTP1\/HTTP2\/gRPC流量：* 在同一单元内的微服务之间进行直接的 Pod 到 Pod 通信；在全局单元中的微服务与涉及到调用路径中的额外跃点的单元之间的流量 — 例如内部路由器 — 增加了跨可用区流量的可能性。\n\n*存储流量：* 包括来自微服务到有状态系统（如 Aurora PostgreSQL、CockroachDB、Redis 和 Kafka）的流量。\n\n*内部基础设施流量：* 内部 Kubernetes 流量，例如[coredns](https:\/\/github.com\/coredns\/coredns)流量或[Kubernetes 控制平面组件](https:\/\/kubernetes.io\/docs\/concepts\/overview\/components\/#control-plane-components)之间的通信。这种类型的流量通常使用 Kubernetes 内部 DNS 而不是 DDSD。\n\n## 初步假设\n\n我们认为，由于我们的微服务架构，同一单元内的 HTTP1\/HTTP2\/gRPC 流量是跨可用区数据传输成本的最大来源。我们还确定服务网格可能通过[Envoy 中的该功能](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/load_balancing\/zone_aware)实现所有微服务的区域感知路由。了解了这两点后，我们优先研究和优化 HTTP1\/HTTP2\/gRPC 流量模式，以提高效率而不降低服务质量。\n\n## 解决 HTTP1\/HTTP2\/gRPC 流量成本问题\n\n最初，服务之间的流量在不同的 AZ 之间均匀分布，如图 4 所示。有了 Envoy 的区域感知路由功能，调用者服务现在更倾向于将流量引导到同一 AZ 中的被调用者服务，如图 5 所示，从而降低了跨可用区的数据传输成本。\n\n![图 4：Pod 之间的简单轮询负载平衡](f4.jpg)\n\n![图 5：区域感知路由](f5.jpg)\n\n为了启用 Envoy 的区域感知路由功能，我们在服务网格的控制平面中进行了更改，将服务发现类型从[STRICT_DNS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#strict-dns)切换到终端发现服务（[EDS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#endpoint-discovery-service-eds)）。如下图所示，对于 DDSD 域，控制平面现在会动态地将来自每个 Envoy 集群的 EDS 资源发送回 Envoy 边车容器。EDS 资源包括 Pod IP 地址及其 AZ 信息。\n\n\u0060\u0060\u0060yaml\nresources:\n - \u0022@type\u0022: type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\n   cluster_name: payment-service.service.prod.ddsd\n   endpoints:\n     - locality:\n         zone: us-west-2a\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 1.1.1.1\n                 port_value: 80\n     - locality:\n         zone: us-west-2b\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 2.2.2.2\n                 port_value: 80\n     - locality:\n         zone: us-west-2c\n       lb_endpoints:\n         - endpoint:\n             address:\n               socket_address:\n                 address: 3.3.3.3\n                 port_value: 80\n\u0060\u0060\u0060\n\n*图 6：一个 EDS 响应的示例*\n\n通过 EDS 响应中提供的数据，Envoy 获取了调用者服务和被调用者服务的 AZ 分布。这些信息使 Envoy 能够[计算](https:\/\/github.com\/envoyproxy\/envoy\/blob\/v1.28.0\/source\/common\/upstream\/load_balancer_impl.cc#L520)Pod 之间的权重。尽管仍然优先通过本\n\n地 AZ 发送流量，但为了确保均衡分布并避免过载任何单个 Pod，一些流量可能仍然会引导到跨越 AZ，如图 7 所示。\n\n![图 7：优先使用本地 AZ，同时确保流量均衡](f7.jpg)\n\n这种路由解决方案具有多种好处，包括：\n\n- 在服务不均匀分布在不同 AZ 的情况下仍然保持流量平衡\n- 可以动态设置 Pod 之间的流量权重，消除手动操作\n- 减少单个或多个 AZ 中断的影响范围\n- 减少流量延迟 — 调用者服务连接到更近的被调用者服务\n\n我们的解决方案在服务 Pod 均匀部署在可用区时变得更加有效。为实现这一目标，我们利用了[topologySpreadConstraints](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/)，并将[maxSkew](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/topology-spread-constraints\/#spread-constraint-definition)设置为 1，当 Unsatisfiable 时设置为 ScheduleAnyway，如图 8 所示。这意味着 Kubernetes 调度器将仍然调度 Pod，即使条件未满足，优先选择最小化偏差的节点。\n\n这种方法确保了 Pod 仍然被调度；否则将会减少装箱量，增加空闲计算量，并最终影响了区域感知的与流量相关的成本减少。在我们的生产系统中，我们观察到有 10% 的流量是根据这个 topologySpreadConstraints 策略跨可用区发送的。\n\n\u0060\u0060\u0060yaml\ntopologySpreadConstraints:\n  - maxSkew: 1\n    topologyKey: topology.kubernetes.io\/zone\n    whenUnsatisfiable: ScheduleAnyway\n\u0060\u0060\u0060\n\n*图 8：配置以均匀部署 Pod 在可用区之间*\n\n随着我们逐渐推出上述更改，我们看到了 AWS 跨可用区传输费用的改进。即便如此，我们预期的减少要更大。因此，我们着手调查为什么我们没有节省多少预期的费用。\n\n## 大海捞针：更好地了解跨可用区的流量\n\n我们通过验证[Envoy 在可用区之间的指标](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats#config-cluster-manager-cluster-per-az-stats)和应用程序日志，确认了区域感知路由正在按预期工作，但我们需要更多的可见性来确定数据传输成本降低的根本原因低于预期。这促使我们使用了多种可观测性工具，包括[VPC 流量日志](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html)，[ebpf 代理指标](https:\/\/doordash.engineering\/2023\/08\/15\/bpfagent-ebpf-for-monitoring-at-doordash\/)和 Envoy 网络字节指标，以纠正这种情况。\n\n使用 VPC 流量日志，我们将[srcaddr 和 dstaddr IP 地址](https:\/\/docs.aws.amazon.com\/vpc\/latest\/userguide\/flow-logs.html#flow-logs-fields)映射到部署在我们的 AWS 帐户结构中的相应子网。这个映射提供了一个汇总规则，让我们理解托管云足迹的不同部分之间的出口\/入口流量模式，包括用于生产 Kubernetes 集群、存储解决方案、缓存和消息代理的子网，如表 1 所示。我们确认，我们跨可用区传输费用的最大来源是每个单元内的非存储流量。其中约有 20% 的费用是由于流量传输到用于我们事件接收流水线（[Iguazu](https:\/\/doordash.engineering\/2022\/08\/02\/building-scalable-real-time-event-processing-with-kafka-and-flink\/)）的一个弹性负载均衡器（ELB）引起的。\n\n![表 1：使用 VPC 流量日志进行跨可用区流量归因](t1.jpg)\n\n此外，我们检查了服务网格 HTTP1\/HTTP2\/gRPC 指标，特别是用于所有请求和响应的连接字节，包括入口和出口流量。来自服务网格 Envoy 代理的最重要的指标是[来自 Envoy 侦听器和集群的 cx_rx_bytes_total 和 cx_tx_bytes_total](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/upstream\/cluster_manager\/cluster_stats.html#general)。但是，由于当时并非所有服务都已加入到服务网格中，因此我们依赖于 BPFAgent 的指标，该指标在每个生产 Kubernetes 节点上都全球部署，以增加对总网络字节的可见性。使用这两个来源的指标，我们发现了 90% 的流量是 HTTP1\/HTTP2\/gRPC 流量；其中 45% 的流量已经加入了服务网格，并且该部分流量的 91% 被发送到 Iguazu！\n\n## 环环相扣：Iguazu 的流量流动\n\n在分析了如图 9 所示的 Iguazu 流量流动之后，我们意识到在调用者和被调用者服务或 Pod 之间存在多个中间跃点。当流量从调用者服务传输到 Iguazu 时，它首先经过 ELBs，然后着陆在全球单元中不同 Kubernetes 集群中的一个工作节点上。因为[externalTrafficPolicy](https:\/\/kubernetes.io\/docs\/tasks\/access-application-cluster\/create-external-load-balancer\/#preserving-the-client-source-ip)配置为集群，*iptables*会将流量重定向到另一个节点以确保负载均衡。\n\n![图 9：Iguazu 的原始流量流动](f9.jpg)\n\n我们观察到以下数据传输行为：\n\n- 向 ELBs 发送流量的客户端仍然直接使用 ELB DNS 名称。因为客户端没有使用内部的 DDSD 域，所以 Envoy 集群中的服务发现类型仍然是 STRICT_DNS，而不是 EDS，这是启用区域感知路\n\n由的先决条件。这意味着 Envoy Sidecar 容器使用简单的轮询方法来将流量分发给 ELBs。\n- 在 ELBs 到 Cluster 2 的 Kubernetes 工作节点的流量的情况下，禁用了跨可用区的负载均衡。\n- 当流量从 Iguazu ELB 到达 Kubernetes 工作节点时，*iptables*会将其进一步重定向到随机节点，这也增加了跨可用区流量的概率。\n\n考虑到 Iguazu 调用图内部的多个跃点的复杂性，我们决定将 Iguazu 服务迁移到与其客户端部署在同一单元的地方。我们还配置了所有客户端 Envoy Sidecar 的[路由规则](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/rds)，将流量路由到新集群中的 Iguazu Pod，而不需要我们的工程师对其服务进行任何代码或配置更改。这使我们能够为 Iguazu 流量启用直接的 Pod 间通信，实现区域感知路由，同时减少了 ELBs 处理的流量量，如图 10 所示。\n\n![图 10：Iguazu 的新流量流动](f10.jpg)\n\n这些操作使 DoorDash 的数据传输成本以及 ELB 成本受到了很大的打击，以至于我们的云服务提供商与我们联系，询问我们是否遇到了与生产相关的问题。\n\n## 吸取的教训\n\n在我们的旅程中，我们获得了一些关键的发现，包括：\n\n- 云服务提供商的数据传输定价比起初看起来更加复杂。值得投入时间来理解定价模型，以构建正确的效率解决方案。\n- 要全面了解\/查看所有跨可用区的流量是具有挑战性的。然而，将来自不同来源的网络字节指标结合起来，足以识别热点，一旦解决，可以在使用和成本方面产生实质性影响。\n- Envoy 的区域感知路由可以将流量发送到其本地可用区，同时通过平衡流量自动确保弹性。\n- 随着微服务调用图中跃点数量的增加，数据被传输到跨可用区的可能性增加，增加了确保所有跃点支持区域感知路由的复杂性。\n- 如果你考虑使用服务网格来管理流量，你也可以利用它来提高效率。\n- 要了解更多关于 DoorDash 的服务网格之旅的信息，请查看 Hochuen 的 KubeCon \u002b CloudNativeCon North America 2023[服务网格会议](https:\/\/www.youtube.com\/watch?v=I6E_7f40YP0)。\n\n## 未来的工作\n\n我们已经列出了我们希望实施的解决方案增强功能的列表，包括：\n\n- 简化从不同来源收集指标并提供成本和使用情况的统一概述的过程。\n- 启用内部 Envoy 路由器的区域感知路由功能。\n- 使解决方案更具可扩展性，以支持 DDSD 之外的其他域的 HTTP1\/HTTP2\/gRPC 流量。\n- 使用 Kubernetes 网络代理 kube-proxy 为内部基础设施流量启用[拓扑感知路由](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/topology-aware-routing\/)功能。\n- 探索优化的路由，用于与 DoorDash 的有状态系统（例如 PostgreSQL、CRDB、Redis 和 Kafka）之间的大数据传输操作。这将允许流量在有意义的情况下保持在单一 AZ 泳道中，进一步降低成本。\n\n## 致谢\n\n我们感谢**Darshit Gavhane**和**Allison Cheng**将所有 Iguazu 服务迁移到客户端正在运行的同一单元，以及**Steve Hoffman**和**Sebastian Yates**在旅程中的建议和指导。\n', '\/trans\/doordash-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 DoorDash 如何使用服务网格来优化其跨可用区的数据传输，降低成本和延迟。作者分享了他们的流量架构、问题分析和解决方案设计，以及使用 Envoy 和 Istio 实现区域感知路由的过程和效果。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/enhancing-istio-with-tis-comprehensive-installation-and-monitoring-guide/">使用 TIS 增强 Istio：安装与监控指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 TIS 增强 Istio：安装与监控指南', '在这篇博客中我将指导你如何安装 TIS 并启用监控插件。', '\n在这篇博客中我将指导你如何安装 TIS 并启用监控插件。\n\n## 什么是 TIS？\n\nTetrate Istio Subscription（TIS）是由 Tetrate 提供的企业级、全面支持的产品，提供了经过全面测试且适用于所有主要云平台的 Istio 版本。TIS 基于开源的 Tetrate Istio Distro 项目，增加了对这些构建版本的全面高级支持，并可选提供 FIPS 验证的加密模块。此外，TIS 包含一系列经过测试和支持的 Add-Ons 和 Integrations，使得 Istio 的功能扩展和与常用基础设施工具的集成变得简单安全。\n\n## 为什么使用 TIS？\n\nTIS 不是 Istio 的一个分支，而是提供针对特定环境进行测试的上游发行版。我们对 Istio 所做的任何增强都会应用于上游。TIS 与普通的 Istio 相比有以下关键优势：\n\n1. **长期支持**：TIS 提供 14 个月的安全更新支持，确保稳定性和安全性。\n2. **商业支持**：TIS 有商业支持选项，适用于企业用例，包括合规性需求。\n3. **易于管理**：TIS 提供简化的安装和管理过程，减少了操作复杂性。\n4. **多环境适配**：TIS 支持不同云环境，满足各种部署需求。\n5. **FIPS 验证**：提供 FIPS 验证版本，适用于高安全性要求的场景。\n\n想要了解 TIS 的更多信息请访问：\u003chttps:\/\/docs.tetrate.io\/istio-subscription\/\u003e\n\n## 准备条件\n\n在安装 TIS 及其插件前，你需要准备：\n\n- 安装 [Terraform](https:\/\/www.terraform.io\/)：用于导入 Dashboard 到 Grafana\n- 向 Tetrate 请求安装 TIS 所需的 credentials\n\n## 安装 Istio 及 Monitoring addons\n\n首先使用下面的命令查看 TIS 支持的 Istio 版本：\n\n\u0060\u0060\u0060bash\nhelm search repo tetratelabs\/base --versions\nNAME            \tCHART VERSION  \tAPP VERSION    \tDESCRIPTION\ntetratelabs\/base\t1.20.1\u002btetrate0\t1.20.1-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.20.0\u002btetrate0\t1.20.0-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.19.5\u002btetrate0\t1.19.5-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.19.4\u002btetrate0\t1.19.4-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.19.3\u002btetrate0\t1.19.3-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.18.6\u002btetrate0\t1.18.6-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.18.5\u002btetrate0\t1.18.5-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.18.3\u002btetrate0\t1.18.3-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.17.8\u002btetrate0\t1.17.8-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.17.6\u002btetrate0\t1.17.6-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.16.7\u002btetrate0\t1.16.7-tetrate0\tHelm chart for deploying Istio cluster resource...\ntetratelabs\/base\t1.16.6\u002btetrate0\t1.16.6-tetrate0\tHelm chart for deploying Istio cluster resource...\n\u0060\u0060\u0060\n\n我们将安装当前最新的 Istio 1.20.1 版本。\n\n\u0060\u0060\u0060bash\nexport TIS_USER=\u003ctis_username\u003e\nexport TIS_PASS=\u003ctis-password\u003e\n# Helm chart version\nexport VERSION=1.20.1\u002btetrate0\n# Image tag\nexport TAG=1.20.1-tetrate0\nkubectl create namespace istio-system\n\nkubectl create secret docker-registry tetrate-tis-creds \\\n    --docker-server=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --docker-username=${TIS_USER} \\\n    --docker-password=${TIS_PASS} \\\n    -n istio-system\n\n# Install Istio\nhelm install istio-base tetratelabs\/base -n istio-system \\\n    --set global.tag=${TAG} \\\n    --set global.hub=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --set \u0022global.imagePullSecrets[0]=tetrate-tis-creds\u0022 \\\n    --version ${VERSION}\n\nhelm install istiod tetratelabs\/istiod -n istio-system \\\n    --set global.tag=${TAG} \\\n    --set global.hub=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --set \u0022global.imagePullSecrets[0]=tetrate-tis-creds\u0022 \\\n    --version ${VERSION} \\\n    --wait\n\n# install ingress Gateway\nkubectl create namespace istio-ingress\n\nkubectl create secret docker-registry tetrate-tis-creds \\\n    --docker-server=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --docker-username=${TIS_USER} \\\n    --docker-password=${TIS_PASS} \\\n    -n istio-ingress\n\nhelm install istio-ingress tetratelabs\/istio-ingress -n istio-ingress \\\n    --set global.tag=${TAG} \\\n    --set global.hub=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --set \u0022global.imagePullSecrets[0]=tetrate-tis-creds\u0022 \\\n    --version ${VERSION} \\\n    --wait\n\n# Install TIS addon\nhelm install istio-monitoring-demo tis-addons\/istio-monitoring-demo --namespace tis --create-namespace\n\u0060\u0060\u0060\n\n端口转发 Grafana 服务，然后在本地浏览器中打开 Grafana：http:\/\/localhost:3000\n\n\u0060\u0060\u0060bash\nkubectl port-forward --namespace tis svc\/grafana 3000:3000\n\u0060\u0060\u0060\n\n注意：请保持该命令持续运行，因为我们在向 Grafana 导入 dashboard 时还需要访问该端口。\n\n## 安装 Istio Monitoring Addons\n\n使用默认的用户名密码 \u0060admin\/admin\u0060 登录后，在左侧导航栏中选择 Administration - Service accounts，参考 Grafana 文档上的说明创建一个 admin 权限的 Service account。\n\n![在 Grafana 中创建一个 Service account](grafana-service-account.jpg)\n\n记下这个 Token，我们将在下面的操作中用到。\n\n使用 Terraform 向 Grafana 中导入 dashboard：\n\n\u0060\u0060\u0060bash\ncat\u003e~\/.terraformrc\u003c\u003cEOF\ncredentials \u0022terraform.cloudsmith.io\u0022 {\n  token = \u0022tetrate\/tis-containers\/kuhb8CPZhaOiR3v6\u0022\n}\nEOF\n\n# Create a terraform module file\ncat\u003eistio-monitoring-grafana.tf\u003c\u003cEOF\nmodule \u0022istio_monitoring_grafana\u0022 {\n  source = \u0022terraform.cloudsmith.io\/tis-containers\/istio-monitoring-grafana\/tetrate\u0022\n  version = \u0022v0.2.0\u0022\n  gf_url  = \u0022\u003chttp:\/\/localhost:3000\u003e\u0022\n  gf_auth = \u0022\u003cgrafana_token\u003e\u0022\n}\nEOF\n\n# Run the commands\nterraform init\nterraform plan\nterraform apply -auto-approve\n\u0060\u0060\u0060\n\n恭喜你现在已经成功的向 Grafana 中导入了以下四个 dashboard：\n\n- TIS Workload Dashboard\n- TIS Service Dashboard\n- TIS Wasm Extension Dashboard\n- TIS Control Plan Dashboard\n\n但是现在有些 dashboard 还没有数据，我们需要在网格中制造一些流量。\n\n## 测试监控\n\n部署 Bookinfo 应用和入口网关：\n\n\u0060\u0060\u0060bash\nkubectl create secret docker-registry tetrate-tis-creds \\\n    --docker-server=\u0022addon-containers.istio.tetratelabs.com\u0022 \\\n    --docker-username=${TIS_USER} \\\n    --docker-password=${TIS_PASS} \\\n    -n default\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml -n default\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml -n default\n\u0060\u0060\u0060\n\n获取入口网关的 IP 并发送一些流量：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_IP=$(kubectl -n istio-ingress get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\nfor i in $(seq 1 100);do curl http:\/\/$GATEWAY_IP\/productpage ; sleep 3;done\n\u0060\u0060\u0060\n\n现在访问 Grafana dashboard，你可以看到监控数据了。\n\n![TIS Workload Dashboard](istio-workload-dashboard.jpg)\n\n除此之外，在导入了这些 dashboard 的同时，我们还导入了以下警报规则：\n\n![导入的警报规则](alerting-rules.jpg)\n\n你也可以在 Grafana 中定义警报规则，比如[整合 Telegram](https:\/\/grafana.com\/blog\/2023\/12\/28\/how-to-integrate-grafana-alerting-and-telegram\/) 或 Slack 来发送通知。\n\n## 清理\n\n运行下面的命令清理 Bookinfo 应用和 TIS：\n\n\u0060\u0060\u0060bash\nkubectl delete -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml -n default\nkubectl delete -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml -n default\nhelm uninstall istio-ingress -n istio-ingress\nhelm uninstall istio-monitoring-demo -n tis\nhelm uninstall istiod -n istio-system\nhelm uninstall istio-base -n istio-system\nkubectl delete namespace tis\nkubectl delete namespace istio-ingress\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## 总结\n\n通过执行这些步骤，您已经使用 TIS 成功地在 Istio 中设置和测试了监视。在 Istio 环境中享受增强监控的见解和优势！\n', '\/blog\/enhancing-istio-with-tis-comprehensive-installation-and-monitoring-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在这篇博客中我将指导你如何安装 TIS 并启用监控插件。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/scaling-and-sizing-the-sidecar/">[译] Istio Sidecar 的资源和性能管理：从监控到自动扩缩容的最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://karlstoney.com/scaling-and-sizing-the-sidecar/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Sidecar 的资源和性能管理：从监控到自动扩缩容的最佳实践', '这篇博客介绍了作者在使用 Istio Sidecar 时，如何通过可视化和分析 Sidecar 的数据，以及使用 HPA 和 VPA 来自动调整 Sidecar 的大小，提高应用程序的效率和稳定性', '\n本文讨论我们如何在工作负载中扩展 Istio Sidecar，以及如何考虑 Sidecar 资源与应用程序紧密耦合的关系。\n\n目前有很多关于 Istio 新的 [Ambient Mesh](https:\/\/istio.io\/v1.15\/blog\/2022\/introducing-ambient-mesh\/) 的讨论。这种部署服务网格的新方法放弃了 Sidecar，而采用了两个新组件，\u0060ztunnel\u0060，一个用于处理核心 L4 网络问题的每节点组件，以及（如果需要）\u0060waypoint proxy\u0060 来处理 L7 问题。\n\n![](image.jpg)\n\n来源：\u003chttps:\/\/istio.io\/v1.15\/blog\/2022\/introducing-ambient-mesh\u003e\n\n我听到的远离 Sidecar 的一个主要原因是，扩展 Sidecar 很复杂。如果只使用 L4 功能，我同意这一观点。然而，作为 L7 功能的重度用户，对我来说，似乎我们只是在管理 Waypoint 代理的规模，而不是 Sidecar。对我个人而言，也许有点自私，它感觉像是一个横向（充其量）的步骤，而不是前进。\n\n此外，我并不觉得管理 Sidecar 资源很痛苦，所以我很难产生共鸣。这部分是因为我从早期就开始使用 Istio，并建立了有助于这一过程的工具和流程。我意识到我从未真正分享过关于我们如何管理这一过程的信息，所以在这里分享一下。\n\n### 一些背景\n\n背景很重要，你如何思考监控和伸缩将取决于你如何构建你的 Kubernetes 设置，以及你的组织结构。也没有一种大小适合所有情况，这只是对我们有效的方法。因此我相信 Ambient 模式将减少某些 Operator 的复杂性，但可能会增加其他 Operator 的复杂性（我承认，这可能是少数情况）。\n\n我们运行大约 700 个个别服务（“工作负载”）。每个服务都有：\n\n- 在自己的 \u0060Namespace\u0060 中运行\n- 使用自己的 \u0060Service Account\u0060\n- 拥有自己的 \u0060Service\u0060\n- 由自己的隔离 CI\/CD 流水线部署\n- 从 Istio 和网络策略的角度来看，都在默认拒绝的设置中运行\n\n![](workload.png)\n\n对于我们来说，命名空间是工作负载的边界，这是一种一对一的关系，而且是一条坚决的规则。因此，我相信我们也会为每个命名空间创建一个 waypoint 代理。我们不会在多个工作负载之间共享 waypoint 代理，因为这会导致耦合（风险\/冲击范围）。因此，我们将得到类似于这样的结果：\n\n![](waypoint.png)\n\n与其扩展 \u0060Sidecar\u0060，我们将扩展 \u0060Waypoint\u0060 - 这就是我所说的对于我们来说，是横向的。我们仍然需要考虑某种规模的问题。\n\n### 可观测性：只是另一个容器\n\n这基本上总结了我对 Sidecar 的看法。它只是你的工作负载中的另一个容器。为了[有效管理](https:\/\/karlstoney.com\/managing-your-costs-on-kubernetes\/)成本（\u0022合适大小\u0022），你应该已经在监控你的工作负载时监控关键指标，这些指标自然扩展到涵盖 \u0060istio-proxy\u0060。对我来说，这些指标包括：\n\n- CPU 和内存 **请求**（例如 \u0060kube_pod_container_resource_requests\u0060）\n- CPU 和内存 **使用**（例如 \u0060container_memory_working_set_bytes\u0060）\n- CPU 和内存 **计算利用率**（Usage \/ Requests）。\n\n暂时忽略 Istio，如果你没有做上述操作，那么你应该开始做。为了帮助你，这是我用于 CPU 计算利用率的指标：\n\n\u0060\u0060\u0060yaml\n - record: \u0022container_cpu_usage_against_request:pod:rate1m\u0022\n   expr: |\n    (   \n      count(kube_pod_container_resource_requests{resource=\u0022cpu\u0022, container!=\u0022\u0022}) by (container, pod, namespace)\n      *   \n      avg(\n        irate(\n          container_cpu_usage_seconds_total{container!=\u0022\u0022}[1m]\n        )   \n      ) by (container, pod, namespace)\n    )   \n    \/   \n    avg(\n      avg_over_time(\n        kube_pod_container_resource_requests{resource=\u0022cpu\u0022, container!=\u0022\u0022}[1m]\n      )   \n    ) by (container, pod, namespace) * 100 \n    *   \n    on(pod) group_left(workload) (\n      avg by (pod, workload) (\n        label_replace(kube_pod_info{created_by_kind=~\u0022ReplicaSet|Job\u0022}, \u0022workload\u0022, \u0022$1\u0022, \u0022created_by_name\u0022, \u0022^(.*)-([^-]\u002b)$\u0022)\n        or  \n        label_replace(kube_pod_info{created_by_kind=~\u0022DaemonSet|StatefulSet\u0022}, \u0022workload\u0022, \u0022$1\u0022, \u0022created_by_name\u0022, \u0022(.*)\u0022)\n        or  \n        label_replace(kube_pod_info{created_by_kind=\u0022Node\u0022}, \u0022workload\u0022, \u0022node\u0022, \u0022\u0022, \u0022\u0022) \n        or  \n        label_replace(kube_pod_info{created_by_kind=\u0022\u0022}, \u0022workload\u0022, \u0022none\u0022, \u0022\u0022, \u0022\u0022) \n      )   \n    )\n\u0060\u0060\u0060\n\n你会注意到在这个指标中，我还与 \u0060kube_pod_info\u0060 进行了关联，这为我的指标提供了一些额外的维度，特别是 \u0060workload\u0060。这仅在我们有一个部署与一个命名空间相对应，等于一个工作负载的关系时才有效。这是可选的，只是帮助我在各个级别查看这个指标，包括 \u0060container\u0060、\u0060pod\u0060、\u0060node\u0060 或 \u0060workload\u0060。这样做将自然地为你的所有容器提供数据，当然也包括你的 Sidecar：\n\n![](Screenshot-2023-10-03-at-08.33.17.jpg)\n\n### Sidecar 与工作负载一起扩展\n\n对于 HTTP 工作负载，我们观察到 Sidecar 的扩展方式与底层应用程序非常相似。你可以在上面的截图中看到 \u0060istio-proxy\u0060 容器的 \u0022计算利用率\u0022 如何紧密跟随 \u0060master\u0060 容器。\n\n这就是我真正喜欢 Sidecar 模式的地方。你的 Sidecar 利用率与你的工作负载利用率紧密耦合，而工作负载利用率与工作负载的副本数量紧密耦合。在上面的示例中，如果我们需要水平扩展工作负载，利用率将保持大致相同。例如，你可以看到 \u0060master\u0060 容器的利用率峰值为 75%，而 \u0060istio-proxy\u0060 的利用率为 60%，如果我们将副本数量加倍，这两个值会松散减半，但保持大致一致。我们只是水平扩展一个 \u0060Deployment\u0060 对象，而不是两个。我们认为这更容易理解。\n\n我们向应用程序所有者提供的指导是，我们希望利用率在峰值时保持在 75% 左右。在这里，人们自然会问为什么我们不使用自动扩展。自动扩展依赖于底层云提供商提供的计算资源。我们曾经遇到过多次影响客户的事件，因为我们无法按需扩展，原因是底层云提供商的容量存在问题。此外，自动扩展会带来延迟，很难对突然的负载急剧增加做出响应，因此它只对具有明显逐渐季节性的工作负载有效，就像上面的工作负载一样。我们认为与自动扩展相关的成本节省不值得与不能对需求做出反应的风险相匹配，因此我们会略微过度配置我们的工作负载（因此是 75%）。\n\n但是，如果你对自动扩展感到满意，你可以在自动扩展配置中设置目标 CPU，然后就可以了。你有一个工作负载，以及一个与之紧密相关的 Sidecar，它们一起扩展。\n\n这就是我对 Waypoint 的看法。因为在我们的设置中，我们每个工作负载都有一个 waypoint 代理，我们将创建两个需要以不同方式但同步扩展的独立部署，这将解耦了我们自身有意关联的东西。\n\n### 设置正确的 CPU 和内存值\n\n在上面的示例中，你可以看到我们有一个相对健康的工作负载。\u0060istio-proxy\u0060 容器被分配了适合工作负载配置文件的 \u0060CPU\u0060 量，允许其利用率紧密跟踪底层应用程序的利用率。经验告诉我，一旦你将这两者对齐，它们就不会松散对齐。它们会漂移的唯一时间是如果任一容器的性能配置发生了显著变化（例如，如果开发人员将应用程序性能提高了 2 倍，则 \u0060master\u0060 的利用率会下降）。\n\n在 AutoTrader，我们的平台团队负责构建“交付平台”，开发人员将应用程序部署到其中，但应用程序开发人员负责确定其工作负载的大小（CPU 和 RAM）。平台团队构建了帮助他们做出明智决策的工具，涉及这些值。\n\n这意味着简单的抽象。我们不让开发人员编写 100 个 Kubernetes 清单来部署工作负载。他们不需要关心 Istio \u0060VirtualServices\u0060、\u0060Sidecars\u0060、Kubernetes \u0060Deployments\u0060 或记住在哪里放置注释以正确设置 Sidecar 的规模。相反，我们要求在他们的存储库中提供一个 yaml 文件，其内容如下：\n\n\u0060\u0060\u0060yaml\ndeployment:\n  istio:\n    resources:\n      cpu: 500m\n      memory: 80Mi\n  container:\n    replicas: 6\n    resources:\n      cpu: 1000m\n      memory: 956Mi\n\u0060\u0060\u0060\n\n因此，你可以看到，服务的所有者负责设置其 \u0060master\u0060 容器和其 \u0060istio-proxy\u0060 的资源。我们的责任是构建工具，帮助他们在选择这些值时做出明智决策。\n\n你已经看到了我们如何在上面的 Grafana 仪表板中使用 \u0022Utilisation\u0022 等指标来做到这一点，但我们还做了一些称为 \u0022建议\u0022 的事情。这些是我们向应用程序所有者提供的有关优化配置其服务的提示：\n\n![](Screenshot-2023-10-03-at-09.19.52.jpg)\n\n因此，你可以在这里看到我们有一个名为 \u0060ProxyMasterImbalance\u0060 的建议。如果我们检测到给定工作负载内的 \u0060master\u0060 和 \u0060istio-proxy\u0060 容器之间的漂移超过 30%，则此建议将处于活动状态。以下是此建议触发的示例：\n\n![](Screenshot-2023-10-03-at-09.44.09.png)\n\n### 总结\n\n希望你可以看到在大小调整 Sidecar 方面，它如何可以轻松地融入到你现有的用于大小调整工作负载的业务流程中。无论如何，你都应该这样做，以保持你的基础架构的健康利用率。\n\n我们已经建立了一种文化，小组关心并拥有他们的软件在生产环境中运行，其中包括关键的 CFR（成本），他们知道通过掌握这些事物，他们正在为更大的目标做出贡献，总体而言，他们做到了。至关重要的是，他们已经关心他们的 \u0060master\u0060 容器利用率，因此 \u0060istio-proxy\u0060 只是他们需要设置 2 个值（CPU\/内存）的另一个容器，我们提供了使其尽可能容易的数据，而在绝大多数情况下 - 这只是你需要调整一次的事情。\n\n我还想指出，这篇文章专门思考了规模的问题。将代理与应用程序分离出来还存在其他潜在优势（例如隔离升级）。不过再次强调，我个人认为这有利有弊（就像技术中的大多数决策一样），但这是另一天的博客文章。\n', '\/trans\/scaling-and-sizing-the-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇博客介绍了作者在使用 Istio Sidecar 时，如何通过可视化和分析 Sidecar 的数据，以及使用 HPA 和 VPA 来自动调整 Sidecar 的大小，提高应用程序的效率和稳定性</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/primary-remote-istio-ingress-gateway-mtls/">Istio 多集群身份验证与 mTLS 连接解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/12/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 多集群身份验证与 mTLS 连接解析', '这篇博客为你深度解析 Istio 主 - 远程部署模式下的远程网关的初始身份验证及 mTLS 连接流程。', '\n## 前言\n\n我经常在 [Istio 的 GitHub Discussions](https:\/\/github.com\/istio\/istio\/discussions) 上回答网友的问题，最近我遇到了一个关于 Istio 主 - 远程部署的[讨论](https:\/\/github.com\/istio\/istio\/discussions\/48343)，问题是关于远程集群中网关如何最初验证到外部 Istiod 实例的。这个问题触及到服务网格在多集群配置中的核心安全机制，我认为这值得在社区中进行更深入的分享。\n\n## 正文\n\n在 Istio 官方的[不同网络上安装 Primary-Remote](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/primary-remote_multi-network\/)文档中，有一个步骤是[将 cluster2 作为 cluster1 的远程集群进行附加](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/primary-remote_multi-network\/#attach-cluster2-as-a-remote-cluster-of-cluster1)。这个过程中会创建一个包含 kubeconfig 配置的 Secret，这个配置文件中含有访问远程集群（cluster2）所需的证书和令牌。\n\n\u0060\u0060\u0060yaml\n# 这个文件是自动生成的，请不要编辑。\napiVersion: v1\nkind: Secret\nmetadata:\n  annotations:\n    networking.istio.io\/cluster: cluster2\n  creationTimestamp: null\n  labels:\n    istio\/multiCluster: \u0022true\u0022\n  name: istio-remote-secret-cluster2\n  namespace: istio-system\nstringData:\n  cluster2: |\n    apiVersion: v1\n    clusters:\n    - cluster:\n        certificate-authority-data: {CERTIFICATE}\n        server: {CLUSTER2-APISERVER-ADDRESS}\n      name: cluster2\n    contexts:\n    - context:\n        cluster: cluster2\n        user: cluster2\n      name: cluster2\n    current-context: cluster2\n    kind: Config\n    preferences: {}\n    users:\n    - name: cluster2\n      user:\n        token: {TOKEN}\n\u0060\u0060\u0060\n\n这个 Secret 的关键作用是让主集群（cluster1）中的 Istio 能够访问远程集群的 API 服务器，从而获得服务信息。此外，远程集群（cluster2）中的 Istiod 服务，通过端点指向主集群中 Istiod 服务的 LoadBalancer IP（端口 15012 和 15017），使得 cluster2 能够通过 Istiod 与主集群进行通信。\n\n因为这两个集群共用一个 CA（由主集群提供），并且远程集群能够访问自己的 API 服务器，所以主集群中的 Istiod 可以验证来自远程集群（cluster2）的请求。下面的序列图清晰地展示了这一过程：\n\n\u0060\u0060\u0060mermaid \u0022Istio 多集群身份验证与 mTLS 连接过程时序图\u0022\nsequenceDiagram\n    participant IG as Ingress Gateway（远程集群）\n    participant K8s as Kubernetes API（远程集群）\n    participant SA as Service Account（远程集群）\n    participant Istiod as Istiod（主集群）\n\n    Note over IG: 启动\n    IG-\u003e\u003eK8s: 请求Service Account令牌\n    K8s-\u003e\u003eSA: 创建\/检索令牌\n    SA--\u003e\u003eIG: 返回令牌\n    Note over IG: 令牌挂载在Pod中\n\n    IG-\u003e\u003eIstiod: 使用令牌进行身份验证\n    Note over Istiod: 验证令牌\n    Istiod-\u003e\u003eIstiod: 生成mTLS证书\n    Istiod--\u003e\u003eIG: 发送mTLS证书\n\n    Note over IG: 使用mTLS证书进行Mesh内的安全通信\n\u0060\u0060\u0060\n\n![Istio 多集群身份验证与 mTLS 连接过程时序图](7183c70e686f598e80f374d029080ea6.svg)\n\n\n\n这一过程是 Istio 多集群配置中的关键一环，确保了服务网格中跨集群通信的安全性。正如我们在这次讨论中看到的，无论是远程网关还是服务都依赖于主集群的 CA 来进行初始的 mTLS 认证，这为整个服务网格的安全通信提供了坚实的基础。\n\n## 总结\n\n在本篇博客中，我们探讨了在 Istio 主 - 远程部署中，远程集群的网关如何进行初始验证以连接到外部的 Istiod。我们解释了如何通过创建一个含有 kubeconfig 的 Secret 来允许主集群的 Istio 访问远程集群的 API，以及如何通过共享的 CA 和服务账户令牌来确保 mTLS 认证的安全性。这一过程确保了服务网格中的跨集群通信的安全，为理解和实施 Istio 的多集群配置提供了重要的见解。\n', '\/blog\/primary-remote-istio-ingress-gateway-mtls\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇博客为你深度解析 Istio 主 - 远程部署模式下的远程网关的初始身份验证及 mTLS 连接流程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/externalname-and-serviceentry/">外部服务别名：ExternalName 与 ServiceEntry 对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('外部服务别名：ExternalName 与 ServiceEntry 对比', '了解 ExternalName 和 ServiceEntry 的优劣，根据需求选用。ExternalName 简单，适用于基本服务发现；ServiceEntry 复杂，适合复杂流量管理和服务发现。', '\n随着 Kubernetes 不断演进，Istio 功能逐渐在 Kubernetes 中找到对应实现，如 [Sidecar 容器](https:\/\/kubernetes.io\/blog\/2023\/08\/25\/native-sidecar-containers\/)、[Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 以及本文的主题 [ExternalName](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/service\/#externalname)。ExternalName 和 ServiceEntry 都能起到引入 Kubernetes 集群外部服务的作用，但是它们的功能和使用场景也有所区别，本文将为你详细解析。\n\n## ExternalName vs ServiceEntry\n\n下表从多个方面对比了 \u0060ExternalName\u0060 和 \u0060ServiceEntry\u0060 ：\n\n| 特性\/用例      | ExternalName                   | ServiceEntry                                                 |\n| -------------- | ------------------------------ | ------------------------------------------------------------ |\n| **流量控制**   | 有限，仅支持 TCP 和 UDP           | 更灵活，支持 TCP、UDP、HTTP 等多种协议，可以指定端口、TLS 等选项 |\n| **服务发现**   | 适用于外部服务的简单别名       | 适用于描述网格内外服务，包括外部和内部服务的详细配置         |\n| **配置复杂性** | 简单，适用于基本的服务发现需求 | 较复杂，适用于需要高级流量控制和详细配置的场景               |\n| **TLS 支持**    | 有限，较简单                   | 更丰富的 TLS 支持，可以指定证书等详细选项                      |\n| **安全性**     | 较基本，适用于简单的用例       | 更强大的安全性支持，可以定义 \u0060subjectAltNames\u0060 等选项        |\n| **用途**       | 适用于简单的外部服务别名       | 适用于复杂的流量管理和服务发现需求，尤其是在多协议和复杂网络拓扑中 |\n\n## 使用场景\n\n**ExternalName 的使用情况：**\n\n1. **简单的服务别名：** 外部服务只需一个简单别名，无需复杂流量控制，可选用 \u0060ExternalName\u0060。\n2. **无详细流量控制需求：** 不需要对服务流量进行详细控制，只需简单的服务别名访问，选用 \u0060ExternalName\u0060。\n\n**ServiceEntry 的使用情况：**\n\n1. **复杂流量控制需求：** 需要更复杂的流量控制，如指定协议、端口、TLS 选项等，选择 \u0060ServiceEntry\u0060。\n2. **描述网格内外服务：** 需要描述网格内外服务，包括外部和内部服务的详细配置，\u0060ServiceEntry\u0060 更适合。\n3. **对服务详细属性有要求：** 需要为服务定义特殊属性，如 \u0060subjectAltNames\u0060 等，需使用 \u0060ServiceEntry\u0060。\n\n### 在 Istio 中使用 ExternalName 可能遇到的问题\n\n在 Istio 1.20 以前，网格内存在 ExternalName 类型的 Service 时，若该 Service 的端口与其他外部服务的端口重叠，流量可能错误路由到该 ExternalName Service。该问题已在 Istio 1.20 版本中解决，详见 [Better support ExternalName #37331](https:\/\/github.com\/istio\/istio\/issues\/37331)。\n\n## 总结\n\n在服务网格的选择中，ExternalName 和 ServiceEntry 分别提供了简单的服务别名和更复杂的流量管理与服务发现选项。ExternalName 适用于简单的外部服务别名，而 ServiceEntry 在处理复杂流量控制和网格内外服务时更具优势。在实际应用中，根据具体需求和配置的复杂性权衡，灵活选择合适的机制。随着 Istio 和 Kubernetes 的不断演进，这些功能的使用方式可能会受到影响，因此保持关注相关社区的更新和最佳实践是保持系统健康和高效运行的关键。选择合适的服务网格组件将有助于构建可靠、安全且高度可扩展的微服务架构。\n', '\/blog\/externalname-and-serviceentry\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">了解 ExternalName 和 ServiceEntry 的优劣，根据需求选用。ExternalName 简单，适用于基本服务发现；ServiceEntry 复杂，适合复杂流量管理和服务发现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-120-release/">Istio 1.20 有哪些更新？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.20 有哪些更新？', 'Istio 1.20 带来关键更新：全面支持 Gateway API、ExternalName 优化、Envoy 过滤器统一排序等，提升服务网格灵活性和性能。', '\nIstio 1.20 代表了 Istio 服务网格能力的显著进步，为运维人员和开发人员提供了更好的体验。这个新版本引入了一些关键的功能和更新，将影响到服务网格架构的设计和实施。\n\n## Gateway API 支持\n\nIstio 1.20 全面支持 Kubernetes Gateway API，并已正式发布（GA）。这标志着服务网格生态系统的重大进步，为用户提供了一组稳定且丰富的网络 API，与 Kubernetes 的核心服务相一致。Istio 对 Gateway API 的支持是实现更无缝和灵活的流量管理的重要一步，使用户能够利用一致的声明方式定义在 Kubernetes 集群内如何路由流量。如果你想了解更多关于 Gateway API 的信息，可以阅读我的博客 [Istio 1.19 有哪些更新：Gateway API 还有更多](\/blog\/istio-119-release\/)。\n\n## 增强的 ExternalName 服务支持\n\n在服务发现领域，Istio 1.20 对于\u0060ExternalName\u0060服务的处理进行了重要更新（见 [Better support ExternalName #37331](https:\/\/github.com\/istio\/istio\/issues\/37331)），使得 Istio 的行为更加符合 Kubernetes 的行为。这个变化简化了配置，并使得 Istio 能够更好地处理 DNS，对于依赖于外部终点的服务至关重要。关于 ExternalName 服务的更多信息，你可以参考 [Kubernetes 官方文档](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/service\/#externalname)。\n\n\u0060ExternalName\u0060 和 Istio 中的 \u0060ServiceEntry\u0060 都可以用于处理服务发现，特别是引入 Kubernetes 集群之外的服务，但有一些关键区别：\n\n- \u0060ExternalName\u0060 是 Kubernetes 的原生 Service 类型，相当于给集群外部服务这设置了一个别名，使得外部服务在 Kubernetes 内部的表现与原生 Service 保持一致，从而可以统一管理和使用内部和外部服务。你可以先定义 \u0060ExternalName\u0060 类型的服务，如果后来你决定将服务移到集群中，则可以启动其 Pod，添加适当的选择算符或端点并更改服务的类型。使用时需要注意不要在多个命名空间中使用相同的 \u0060ExternalName\u0060，可能会引起命名冲突或混淆。\n- \u0060ServiceEntry\u0060 是 Istio 特有的配置对象，它提供了更灵活的控制，可以描述网格内或网格外的服务，以及指定特定的协议、端口等属性。例如，可以使用\u0060ServiceEntry\u0060将网格内服务访问网格外的服务，或者定义自定义的服务入口点。\n\n## 其他更新\n\n**一致的 Envoy 过滤器排序：** 在新版本中，Envoy 过滤器的排序在所有流量方向和协议上变得一致了。这确保了过滤器的统一应用，对于服务网格的可预测行为和安全性至关重要。\n\n**网络 Wasm 插件扩展：** Istio 继续通过引入新的\u0060NETWORK\u0060类型扩展网络 Wasm 插件的支持，推动了可扩展性的边界。这个扩展巩固了 Istio 作为服务网格创新领域的领导地位，为用户提供了更多的控制和定制选项。\n\n**TCP 元数据交换增强：** Istio 1.20 中的两个更新旨在改进 TCP 元数据交换：回退元数据发现过程和控制 ALPN 令牌的能力。这些改进显示了 Istio 对强大高效的网络的承诺。\n\n**流量镜像到多个目的地：** 新版本扩展了 Istio 的流量镜像功能以支持多个目的地。这个功能对于调试和监控非常宝贵，可以提供关于跨不同服务版本或配置的流量行为的见解。\n\n**可插拔的根证书轮换：** 加强了安全性，Istio 现在支持可插拔的根证书轮换，增强了服务网格在使用更新的加密凭证时保持服务间信任的能力。\n\n**Sidecar 容器中的 StartupProbe:** 为了改善启动时间，Istio 在 Sidecar 容器中引入了\u0060startupProbe\u0060，它可以在初始阶段进行积极的轮询，而不会在整个 Pod 的生命周期中持续存在。\n\n**OpenShift 安装增强：** 通过去除某些特权要求，Istio 简化了在 OpenShift 上的安装过程，从而降低了 OpenShift 用户的使用门槛。\n\n## 总结\n\n在 Istio 1.20 中的这些功能和增强将简化运维操作，加强安全性，并提供更具动态和可定制的服务网格体验。随着服务网格领域的不断发展，Istio 的最新版本证明了社区对改进和创新的不懈追求。\n', '\/blog\/istio-120-release\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Istio 1.20 带来关键更新：全面支持 Gateway API、ExternalName 优化、Envoy 过滤器统一排序等，提升服务网格灵活性和性能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-119-release/">Istio 1.19 有哪些更新：Gateway API 还有更多</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.19 有哪些更新：Gateway API 还有更多', '我很高兴呈现 Istio 的最新版本— Istio 1.19。这篇博客将概述此版本中的更新内容。', '\n我很高兴呈现 Istio 的最新版本— [Istio 1.19](https:\/\/istio.io\/latest\/news\/releases\/1.19.x\/announcing-1.19\/)。这篇博客将概述此版本中的更新内容。\n\n## Gateway API: 彻底改变服务网格\n\n我们的[前一篇博客](https:\/\/tetrate.io\/blog\/why-the-gateway-api-is-the-unified-future-of-ingress-for-kubernetes-and-service-mesh\/)强调了 Gateway API 将 Kubernetes 和服务网格中的入口网关统一的潜力，为跨命名空间的流量支持打开了大门。有了 Istio 的官方支持，Gateway API 成为了焦点。它不仅用于北 - 南流量（网格的入口和出口），现在还扩展到东 - 西流量的领域，也就是网格内部的流量。\n\n在 Kubernetes 中，服务承担多项职责，从服务发现和 DNS 到工作负载选择、路由和负载均衡。然而，对这些功能的控制一直有限，工作负载选择是显著的例外。Gateway API 改变了这一局面，让你可以控制服务路由。这与 Istio 的 VirtualService 有一些重叠，因为两者都对流量路由有影响。以下是三种情况的简介：\n\n1. Kubernetes 内部请求：在没有 Istio 的情况下，Kubernetes 的所有内部流量都走服务路由。\n2. 北 - 南流量：通过将 Gateway API 应用到入口网关，流入 Kubernetes 的流量会按照 xRoute（目前支持 HTTPRoute, TCPRoute 和 gRPCRoute）到服务。\n3. 东 - 西流量：在 Istio 内部，当流量进入数据平面时，Gateway API 的 xRoute 接管。它引导流量到原始服务或新的目标服务。\n\n![图 1：流量路由](gateway-api-request.svg)\n\nGateway API 与 Istio 的这种动态结合不仅精细化了服务网络，也巩固了 Istio 在 Kubernetes 生态系统中的地位。\n\n## 服务网格的 Gateway API: 深入探讨\n\n在当前的实验阶段（v0.8.0 版本），服务网格的 Gateway API 引入了一种新的方法来配置 Kubernetes 中的服务网格支持。它直接将单个路由资源（如 HTTPRoute）与服务资源关联起来，简化了配置过程。\n\n以下是一些关键点：\n\n实验阶段：在 v0.8.0 版本中，服务网格的 Gateway API 仍处于实验阶段。建议不要在生产环境中使用。\n\n服务与路由关联：在配置服务网格时，与使用 Gateway 和 GatewayClass 资源不同，单个路由资源直接与服务资源关联。\n\n服务的前端和后端：服务的前端包括其名称和集群 IP，后端由其端点 IP 的集合组成。这种区分使得在网格内进行路由无需引入冗余资源。\n\n路由附加到服务：将路由附加到服务上以将配置应用到指向该服务的任何流量。如果没有附加路由，流量会遵循网格的默认行为。\n\n命名空间关系：\n\n- *相同命名空间：* 在与其服务相同的命名空间中的路由，被称为生产者路由，通常由工作负载创建者创建以定义可接受的使用情况。它影响来自任何命名空间中的任何工作负载的客户端的所有请求。\n- *不同命名空间：* 在与其服务不同的命名空间中的路由，被称为消费者路由，细化了给定工作负载的消费者提出请求的方式。这个路由只影响与路由在同一命名空间中的工作负载的请求。\n\n![图 2：生产者路由和消费者路由](gateway-api-reference.svg)\n\n组合路由：在单个命名空间中的同一服务的多个路由，无论是生产者路由还是消费者路由，都将根据 Gateway API 路由合并规则进行合并。这意味着在同一命名空间中为多个消费者定义不同的消费者路由是不可能的。\n\n请求流程：\n\n- 客户端工作负载发起对命名空间中特定服务的请求。\n- 网格数据平面拦截请求并识别目标服务。\n- 基于关联的路由，请求被允许、拒绝，或根据匹配规则转发到适当的工作负载。\n\n请记住，在实验阶段，服务网格的 Gateway API 可能会有更多的变化，不建议在生产环境中使用。\n\n但等等，还有更多！我们的旅程并没有结束 - 使用 API 的入口流量支持正快速向通用可用性 (GA) 进发，预计还会有更多动态的发展！\n\n让我们进一步探讨这个版本中的其他增强功能。\n\n## Ambient Mesh 增强\n\nIstio 团队一直在不断优化 ambient mesh，这是一种创新的部署模型，提供了一个替代传统 sidecar 方法的选择。如果你还没有探索 ambient，现在是深入了解[介绍博客](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)的好时机。\n\n在这次更新中，我们强化了对\u0060ServiceEntry\u0060、\u0060WorkloadEntry\u0060、\u0060PeerAuthentication\u0060以及 DNS 代理的支持。并且，修复了一些 bug，增强了可靠性，以确保无缝的体验。\n\n请记住，ambient mesh 在这个版本中处于 alpha 阶段。Istio 社区热切期待你的反馈，以推动它向 Beta 阶段前进。\n\n## 简化虚拟机和多集群体验\n\n简单易用是关键，特别是在处理虚拟机和多集群设置的时候。在这个版本中，我们在\u0060WorkloadEntry\u0060资源中使地址字段变为可选。这个看似小小的调整将大大简化你的工作流程。\n\n## 提升安全配置\n\n你现在可以为你的 Istio 入口网关的 TLS 设置配置\u0060OPTIONAL_MUTUAL\u0060，提供可选的客户端证书验证的灵活性。此外，你可以通过\u0060MeshConfig\u0060微调你偏好的非 Istio mTLS 流量使用的密码套件。\n\n有了这些更新，Istio 1.19 赋予你在管理你的服务网格时更大的控制、灵活性和安全性。\n\n欢迎你探索这些增强功能，并与 Istio 社区分享你的体验。更多详细信息，请参考[官方发布说明](https:\/\/istio.io\/latest\/news\/releases\/1.19.x\/announcing-1.19\/)。\n\n祝你网格愉快！\n\n------\n\n本博客最初在[tetrate.io](https:\/\/tetrate.io\/blog\/whats-new-in-istio-1-19-gateway-api-and-beyond\/)上发布。\n', '\/blog\/istio-119-release\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我很高兴呈现 Istio 的最新版本— Istio 1.19。这篇博客将概述此版本中的更新内容。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ica-review/">CNCF 与 Tetrate 合作推出 Istio Certificated Associate（ICA）认证</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('CNCF 与 Tetrate 合作推出 Istio Certificated Associate（ICA）认证', 'CNCF 与 Tetrate 共同推出的 Istio 认证庆祝一个月，提升了在微服务、安全和流量管理方面的 Kubernetes 技能。', '\n云计算专业人士，自 **Istio Certified Associate (ICA) 认证** 旅程开始已经一个月了。这是云原生计算基金会（CNCF）、Linux 基金会培训与认证以及 Tetrate 合作的成果，为微服务管理设立了新的标杆。\n\n[Tetrate](https:\/\/tetrate.io) 是 Istio 项目的关键贡献者，最初创建了 Tetrate 认证的 Istio 管理员（CIAT），为 ICA 认证奠定了基础。自从推出以来，ICA 已成为 Kubernetes 生态系统的重要组成部分，帮助数千人掌握服务网格技术。\n\n认证课程涵盖了诸如**安装**、**流量管理**和**安全**等基本领域，反映出该领域所需的全面专业知识。在短短时间内，ICA 获得了显著动力，得益于 Tetrate 对云原生领域的愿景和投入。\n\n在 ICA 成立一个月之际，Tetrate 继续通过其 Tetrate Academy 承诺开源教育，提供有关服务网格和 Kubernetes 安全的免费、高质量课程。对于那些打算在生产中部署 Istio 的人来说，Tetrate 提供了**Tetrate Istio Distribution (TID)**，一种安全且得到支持的 Istio 发行版。\n\n如果您还没有加入，现在是时候加入这个不断增长的 Istio 专家社区了。提升您的职业生涯，为云原生技术的演进做出贡献。\n\n## 什么是 ICA 认证？\n\nICA 是专为工程师，CI\/CD 从业者或任何对 Istio 有特殊兴趣的人设计的专业前认证。\n\n获得认证的 ICA 学员可确认他们对 Istio 原则、术语和最佳实践的基础知识，并展示他们建立 Istio 的能力。\n\nICA 认证考试展示了考生对 Istio 原则、术语和建立 Istio 的最佳实践的深入理解。\n\n## ICA 认证考试内容\n\nICA 认证考试包括这些一般领域及其在考试中的权重：\n\n- 安装、升级和配置：7%\n- 流量管理：40%\n- 弹性和故障注入：20%\n- 保护工作负载：20%\n- 高级场景：13%\n\n详细内容如下：\n\n**安装、升级和配置：7%**\n\n- 使用 IstioCLI 安装基本集群\n- 使用 IstioOperatorAPI 定制 Istio 安装\n- 使用覆盖来管理 Istio 组件设置\n\n**流量管理：40%**\n\n- 控制服务网格内的网络流量\n- 配置 Sidecar 注入\n- 使用 Gateway 资源配置入口和出口流量\n- 了解如何使用 ServiceEntry 资源向内部服务注册中心添加条目\n- 使用 DestinationRule 定义流量策略\n- 配置流量镜像功能 \n\n**弹性和故障注入：20%**\n\n- 配置断路器 (带或不带离群值检测)\n- 使用弹性特性\n- 创建故障注入\n\n**固定工作负载：20%**\n\n- 了解 Istio 安全特性\n- 在 mesh 中为 HTTP\/TCP 流量建立 Istio 授权\n- 在网格、命名空间和工作负载级别配置相互 TLS\n\n**高级场景：13%**\n\n- 了解如何将非 kubernetes 工作负载装载到网格\n- 排除配置问题\n\n## 如何获得 ICA 认证？\n\n[点击开始您的 ICA 认证吧！](https:\/\/training.linuxfoundation.cn\/certificates\/33)\n\n这只是一个开始。让我们期待在服务网格熟练度上达到更多里程碑，由 Tetrate 和 CNCF 引领潮流。\n\n注：ICA 认证提供中文认证考试，证书有效期 3 年。\n', '\/blog\/ica-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">CNCF 与 Tetrate 共同推出的 Istio 认证庆祝一个月，提升了在微服务、安全和流量管理方面的 Kubernetes 技能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/secure-apps-with-istio/">[译] 使用相互 TLS 和 Istio 保护应用程序通信</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2023/secure-apps-with-istio/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用相互 TLS 和 Istio 保护应用程序通信', '本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。', '\n\u003e 摘要：本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。\n\n用户采用服务网格的最大原因之一是使用相互 TLS（mTLS）基于可通过加密验证的身份来启用应用程序之间的安全通信。在此博客中，我们将讨论应用程序之间安全通信的要求，以及 mTLS 如何实现并满足所有这些要求，以及使用 Istio 启用应用程序之间 mTLS 的简单步骤。\n\n## 您需要什么来保护应用程序之间的通信？\n\n现代云原生应用程序经常分布在多个 Kubernetes 集群或虚拟机中。新版本经常进行阶段性部署，它们可以根据用户请求快速扩展和缩小。由于现代应用程序通过不依赖共同定位来提高资源利用效率，因此能够应用访问策略并保护这些分布式应用程序之间的通信至关重要，因为增加的多个入口点导致了更大的攻击面。忽视这一点将邀请数据丢失、数据盗窃、伪造数据或简单处理等巨大的业务风险。\n\n以下是应用程序之间安全通信的常见关键要求：\n\n### 身份\n\n身份是任何安全架构的基本组成部分。在您的应用程序可以安全地发送数据之前，必须为应用程序建立**身份**。这个建立身份的过程被称为**身份验证** - 它涉及由某个知名的，受信任的**权威机构**对应用程序工作负载进行一次或多次检查，以确认它是它所声称的那样。一旦权威机构满意，它就会授予工作负载一个身份。\n\n考虑出示护照的行为 - 你会向某个权威机构请求一个，那个权威机构可能会要求你提供几个不同的身份验证证明你是你所说的那个人 - 出生证明、现住址、医疗记录等。一旦你满足了所有的身份验证要求，你将（希望）被授予身份证件。你可以将那个身份证件给别人作为你已经满足了发证机构的所有身份验证要求的证据，如果他们信任发证机构（和身份证件本身），他们就可以信任关于你的所有内容（或者他们可以联系受信任的权威机构并验证该文件）。\n\n身份可以采取任何形式，但是，就像任何形式的身份证明一样，身份验证越弱，伪造就越容易，身份证明对于使用它进行决策的任何人来说就越无用。这就是为什么在计算中，密码可验证的身份非常重要 - 它们由可验证的权威机构签署，类似于您的护照和驾驶执照。基于任何较少的身份都是一个可以相对容易地利用的安全弱点。\n\n您的系统可能具有源自网络属性（例如 IP 地址）的身份，具有分布式身份缓存，跟踪身份与这些网络属性之间的映射。这些身份不像密码可验证的身份那样具有强大的保证，因为 IP 地址可能被重新分配给不同的工作负载，并且身份缓存可能并不总是更新到最新的状态。\n\n您希望应用程序使用密码可验证的身份，因为在建立连接时交换应用程序的密码可验证身份本质上比依赖于将 IP 地址映射到身份的系统更可靠，更安全。这些系统依赖于具有最终一致性和过时问题的分布式身份缓存，这可能在 Kubernetes 中创建结构性弱点，其中高频率的自动 pod 转换是常态。\n\n### 机密性\n\n加密应用程序之间传输的数据至关重要 - 因为在破坏常见、成本高昂和实际上微不足道的世界中，完全依赖于*安全的*内部环境或其他安全边界早已不再适用。为了防止[中间人攻击](https:\/\/en.wikipedia.org\/wiki\/Man-in-the-middle_attack)，你需要为源 - 目标对创建一个唯一的加密通道，因为你希望有强大的身份唯一性保证以避免[混淆副手问题](https:\/\/en.wikipedia.org\/wiki\/Confused_deputy_problem)。换句话说，仅仅加密通道是不够的 - 它必须使用直接从唯一源和目标身份派生的唯一密钥进行加密，以便只有源和目标可以解密数据。此外，您可能需要根据安全团队的要求定制加密，例如通过选择特定的密码。\n\n### 完整性\n\n从源发送到目标的加密数据在发送后不能被除源和目标之外的任何身份修改。换句话说，接收到的数据与发送的数据相同。如果你没有[data integrity](https:\/\/en.wikipedia.org\/wiki\/Data_integrity)，那么中间的人可能在源和目标之间的通信过程中修改一些位或整个数据的内容。\n\n### 访问策略执行\n\n应用程序所有者需要对其应用程序应用访问策略，并正确、一致且不含糊地执行它们。为了对通信渠道的两端应用策略，我们需要为每一端确定一个应用程序身份。一旦我们为可能的通信渠道的两端都有了一个可以通过密码验证的身份，并且来源链条明确，我们就可以开始确定谁可以与何物进行通信的策略。标准的 TLS，这是一种广泛使用的密码协议，用于保护客户端（例如，Web 浏览器）和服务器（例如，Web 服务器）之间的通信，只真正验证并要求一方的身份 - 服务器。但是，对于全面的端到端策略执行，对双方 - 客户端和服务器都有一个可靠、可验证、明确的身份至关重要。这对内部应用程序来说是一个共同的需求 - 想象一下，只有一个 \u0060frontend\u0060 应用程序应该调用后端 \u0060checkout\u0060 应用程序的 **GET** 方法，但是不应该被允许调用 \u0060POST\u0060 或 \u0060DELETE\u0060 方法。或者，只有那些由特定 JWT 发行者发出 JWT 令牌的应用程序才能调用 \u0060checkout\u0060 应用程序的 \u0060GET\u0060 方法。通过利用双端的密码身份，我们可以确保强大的访问策略被正确地、安全地、可靠地执行，而且有可验证的审计轨迹。\n\n### FIPS 合规性\n\n[联邦信息处理标准 (FIPS)](https:\/\/www.nist.gov\/standardsgov\/compliance-faqs-federal-information-processing-standards-fips) 是由 [国家标准与技术研究院 (NIST)](https:\/\/www.nist.gov\/) 制定的联邦计算机系统的标准和指南。并非每个人都需要 FIPS 合规性，但 FIPS 合规性意味着满足了美国政府为保护敏感信息而设立的所有必要安全要求。与联邦政府合作时需要它。为了遵循美国政府制定的与网络安全相关的指南，许多私营部门都自愿使用这些 FIPS 标准。\n\n为了说明上述安全应用程序要求（身份、机密性和完整性），让我们使用 \u0060frontend\u0060 应用程序调用 \u0060checkout\u0060 应用程序的例子。记住，您可以把图中的 **ID** 看作是任何类型的身份证明，比如政府颁发的护照、照片识别器：\n\n![前端调用结账应用程序时的要求](requirements-flow.png)\n\n## mTLS 如何满足上述要求？\n\nTLS 1.3（在撰写本文时的最新 TLS 版本） [规范](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446) 的主要目标是在两个通信对等方之间提供一个安全通道。TLS 安全通道具有以下属性：\n\n1. 验证：通道的服务器端始终被验证，客户端可选地被验证。当客户端也被验证时，安全通道成为一个相互的 TLS 通道。\n2. 机密性：数据被加密且只对客户端和服务器可见。必须使用与源和目标身份证明无歧义地密码绑定的密钥来加密数据，以便可靠地保护应用程序层的流量。\n3. 完整性：通过通道发送的数据无法在未被检测到的情况下进行修改。这是通过只有源和目标拥有给定会话的加密和解密密钥的事实来保证的。\n\n### mTLS 内部逻辑\n\n我们已经确定了，使用可以通过加密验证的身份标识对于保护通道和支持访问策略执行至关重要，我们也已经确定了，mTLS 是一种经过严密测试的协议，它为在通道的两端使用可以通过加密验证的身份标识提供了一些极其重要的保证 - 让我们深入了解一下 mTLS 协议在实际运行中是如何工作的。\n\n### 握手协议\n\n[握手协议](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-4) 验证了通信双方的身份，协商了加密模式和参数，并建立了共享的密钥材料。换句话说，握手的角色是验证通信双方的身份并协商会话密钥，以便连接的其余部分可以根据会话密钥进行加密。当您的应用程序建立 mTLS 连接时，服务器和客户端协商一个密码套件，该套件规定了您的应用程序将用于连接其余部分的加密算法，您的应用程序还协商了要使用的加密会话密钥。整个握手过程都被设计为能抵抗篡改 - 任何未持有与源和\/或目标相同的独特，能够通过加密验证的身份文档的实体的干扰都会被拒绝。因此，在任何通信方继续进行应用程序数据之前，都有必要检查整个握手过程并验证其完整性。\n\n握手可以被认为是按照 TLS 1.3 规范中的[握手协议概述](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-2)有三个阶段 - 再次使用\u0060frontend\u0060应用程序调用后端\u0060checkout\u0060应用程序的例子：\n\n1. 第一阶段：\u0060frontend\u0060和\u0060checkout\u0060协商可以用来保护握手和流量数据的加密参数和密钥。\n2. 第二阶段：在此阶段和之后的所有内容都是加密的。在这个阶段，\u0060frontend\u0060和\u0060checkout\u0060建立其他握手参数，并确定是否也对客户端进行身份验证 - 也就是说，mTLS。\n3. 第三阶段：\u0060frontend\u0060通过其可通过加密验证的身份验证\u0060checkout\u0060（在 mTLS 中，\u0060checkout\u0060以相同的方式验证\u0060frontend\u0060）。\n\n自 TLS 1.2 以来，与握手相关的有几个主要区别，有关更多详细信息，请参考 TLS 1.3 规范：\n\n1. 所有握手消息（第二阶段和第三阶段）都使用在第一阶段协商的加密密钥进行加密。\n2. 已经削减了遗留的对称加密算法。\n3. 添加了零往返时间（0-RTT）模式，节省了连接设置的一个往返时间。\n\n### 记录协议\n\n在握手阶段协商了 TLS 协议版本、会话密钥和[HMAC](https:\/\/en.wikipedia.org\/wiki\/HMAC)后，双方现在可以通过[记录协议](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-5)安全地交换被分块的加密数据。使用握手中协商的完全相同的参数对流量进行加密是至关重要的（并且是规范的一部分），以确保流量的机密性和完整性。\n\n将 TLS 1.3 规范中的两个协议放在一起，并使用\u0060frontend\u0060和\u0060checkout\u0060应用程序来说明以下流程：\n\n![当前端调用结账应用程序时的 mTLS 流程](mtls-flow.png)\n\n谁为\u0060frontend\u0060和\u0060checkout\u0060发出身份证书？它们通常由具有自己的[根证书](https:\/\/en.wikipedia.org\/wiki\/Root_certificate)或使用其根 CA 的中间证书的[证书颁发机构（CA）](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority)发出。根证书基本上是一份标识根 CA 的公钥证书，您的组织可能已经拥有此证书。根证书会与\u0060frontend\u0060（或\u0060checkout\u0060）的自己的根签名身份证书一起分发到\u0060frontend\u0060。这就是基本的公钥基础设施（PKI）的工作方式 - CA 负责验证实体的身份文档，然后以证书的形式授予它一个无法伪造的身份文档。\n\n您可以依赖您的 CA 和中间 CA 作为身份**真理**的来源，以一种维持高可用性并提供稳定、持久可验证的身份保证的结构化方式，而一个庞大的分布式 IP 和身份映射缓存则无法做到这一点。当\u0060frontend\u0060和\u0060checkout\u0060的身份证书由同一个根证书发出时，\u0060frontend\u0060和\u0060checkout\u0060可以始终以一致且可靠的方式验证其对等身份，无论它们运行在哪个集群或节点或规模中。\n\n您了解了 mTLS 如何提供加密身份、机密性和完整性，那么当您的应用程序数量增长到数千个或更多，并且跨多个集群时，其可扩展性如何呢？如果您在多个集群中建立一个单一的根证书，那么只要它被根证书信任，系统就不需要在应用程序收到来自另一个集群的连接请求时进行处理 - 系统知道连接上的身份已经通过加密进行了验证。当您的应用程序 pod 更改 IP 或被重新部署到另一个集群或网络时，您的应用程序（或代表其行动的组件）只需使用其由 CA 铸造的受信任证书向目标发起流量即可。无论是 500\u002b 网络跳转还是直接连接，您的访问策略都会以相同的方式执行，无需跟踪身份缓存并计算哪个 IP 地址映射到哪个应用程序 pod。\n\n那么关于 FIPS 合规性呢？根据 TLS 1.3 规范，TLS 兼容的应用程序必须实现\u0060TLS_AES_128_GCM_SHA256\u0060密码套件，并建议实现\u0060TLS_AES_256_GCM_SHA384\u0060，这两者都在 NIST 的[TLS 指南](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-52r2.pdf)中。RSA 或 ECDSA 服务器证书也被 TLS 1.3 规范和 NIST 的 TLS 指南推荐。只要您为 mTLS 连接使用 FIPS 140-2 或 140-3 合规的加密模块，您就会走上[FIPS 140-2 或 140-3 验证](https:\/\/csrc.nist.gov\/projects\/cryptographic-module-validation-program\/validated-modules)的正确路径。\n\n## 可能出现的问题\n\n按照 TLS 1.3 规范正确实施 mTLS 至关重要。如果不按照 TLS 规范正确使用 mTLS，以下是一些可能在未被检测的情况下出现的问题：\n\n### 如果有人在连接中间静默地捕获加密数据会怎么样？\n\n如果连接没有按照 TLS 规范中概述的握手和记录协议来进行，例如，连接遵循握手协议，但在记录协议中没有使用握手中协商的会话密钥和参数，您可能会发现您的连接的握手和记录协议之间没有关联，握手和记录协议之间的身份可能不同。TLS 要求握手和记录协议在同一连接中共享，因为将它们分开会增加中间人攻击的攻击面。\n\nmTLS 连接从握手开始到结束都具有一致的端到端安全性。加密数据是用证书中公钥协商的会话密钥加密的。只有源和目标可以使用私钥解密数据。换句话说，只有拥有私钥的证书所有者才能解密数据。除非黑客控制了证书的私钥，否则他或她没有办法搞乱 mTLS 连接以成功执行中间人攻击。\n\n### 如果源或目标身份没有加密安全怎么办？\n\n如果身份基于网络属性，如 IP 地址，这些属性可能会重新分配给其他 pod，就无法使用加密技术验证该身份。由于此类身份不基于加密身份，因此您的系统可能有一个身份缓存，用于跟踪身份、pod 的网络标签、相应的 IP 地址和部署 pod 的 Kubernetes 节点信息之间的映射。使用身份缓存，您可能会遇到 pod IP 地址被重用和身份错误，当身份缓存在短时间内同步出现问题时，策略可能无法正确执行。例如，如果您的连接之间的对等方没有加密身份，您的系统将不得不从可能过时或不完整的身份缓存中获取身份。\n\n将身份映射到工作负载 IP 的这些身份缓存不是 ACID（原子性、一致性、隔离性和持久性），您希望您的安全系统应用于具有强保证的事物。考虑以下属性和您可能想要问自己的问题：\n\n- 过时：对等方如何验证缓存中的条目是否是**当前**的？\n- 不完整：如果缓存未命中并且系统未能关闭连接，只有缓存**同步器**失败时网络才会变得不稳定吗？\n- 如果某个东西根本没有 IP 怎么办？例如，默认情况下，AWS Lambda 服务没有公共 IP。\n- 非事务性：如果您读取两次身份，会看到相同的值吗？如果在访问策略或审计实施中不小心，这可能会导致真正的问题。\n- 谁将守护守护者自己？是否有既定的实践来保护缓存，就像 CA 有的那样？您有什么证据证明缓存没有被篡改吗？您是否被迫对一些不是您的 CA 的复杂基础设施的安全性进行推理（和审计）？\n\n以上问题中有些比其他问题更糟。您可以应用**失败关闭**原则，但这并不能解决所有问题。\n\n身份也用于执行访问策略，例如授权策略，这些访问策略在请求路径中，您的系统必须快速做出决定，允许或拒绝访问。每当身份出现错误时，访问策略可能会被绕过，而无法被检测或审计。例如，您的身份缓存可能将您的\u0060checkout\u0060 pod 的先前分配的 IP 地址作为\u0060checkout\u0060身份之一。如果\u0060checkout\u0060 pod 被回收，同一 IP 地址刚刚被分配给一个\u0060frontend\u0060 pod，那么在缓存更新之前，该\u0060frontend\u0060 pod 可能具有\u0060checkout\u0060的身份，这可能导致错误的访问策略被执行。\n\n让我们假设以下大规模多集群部署，说明身份缓存过时问题：\n\n1. 100 个集群，每个集群有 100 个节点，每个节点有 20 个 pod。总的 pod 数量是 200,000。\n2. 0.25% 的 pod 一直在变动（滚动更新，重启，恢复，节点变动等），每次变动的窗口是 10 秒。\n3. 每 10 秒有 500 个正在变动的 pod 分布到 10,000 个节点（缓存）。\n4. 如果缓存同步器停滞，系统在 5 分钟后过时的%可能高达**7.5%**！\n\n以上假设缓存同步器处于稳态。如果缓存同步器出现问题，会影响其健康检查，增加变动率，导致级联不稳定。\n\nCA 也可能被攻击者[攻击](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority#CA_compromise)，攻击者假装是别人，欺骗 CA 发出证书。然后，攻击者可以使用该证书与其他对等方通信。这是[证书撤销](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority#Certificate_revocation)可以通过撤销证书使其无效来解决问题。否则，攻击者可以利用被攻击的证书直到其过期。保持根证书的私钥在 HSM 中至关重要，该 HSM 应保持[离线](https:\/\/en.wikipedia.org\/wiki\/Online_and_offline)，并使用中间证书签署工作负载证书。在 CA 停顿或停滞 5 分钟的情况下，您将无法获得新的或续期的工作负载证书，但之前发出的有效证书将继续为您的工作负载提供强大的身份保证。为了提高发行的可靠性，您可以将中间 CA 部署到不同的区域和地区。\n\n## Istio 中的 mTLS\n\n### 启用 mTLS\n\n在 Istio 中为内网应用程序启用 mTLS 非常简单。您需要做的就是将您的应用程序添加到网格中，这可以通过为您的命名空间标记侧车注入或环境来完成。在侧车的情况下，需要进行滚动重启，以便侧车被注入到您的应用程序 pod 中。\n\n### 加密身份\n\n在 Kubernetes 环境中，[Istio](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#istio-identity)根据其服务帐户创建应用程序的身份。将应用程序添加到网格后，将向网格中的每个应用程序 pod 提供身份证书。\n\n默认情况下，您的 pod 的身份证书在 24 小时后过期，Istio 每 12 小时旋转一次 pod 身份证书，以便在出现妨害行为的情况下（例如，被攻击的 CA 或被盗的 pod 的私钥），被攻击的证书只能在证书过期并因此限制其可能造成的损害的非常有限的时间内工作。\n\n### 强制执行严格的 mTLS\n\n默认的 mTLS 行为是尽可能使用 mTLS，但并不强制执行。要严格强制您的应用程序只接受 mTLS 流量，您可以使用 Istio 的[PeerAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/peer_authentication\/)策略，对整个网格或每个命名空间或工作负载进行操作。此外，您还可以应用 Istio 的[AuthorizationPolicy](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/)来控制您的工作负载的访问。\n\n### TLS 版本\n\nTLS 版本 1.3 是 Istio 在内网应用程序通信中的默认设置，使用 Envoy 的[默认密码套件](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/tls\/v3\/common.proto)（例如，对于 Istio 1.19.0，为\u0060TLS_AES_256_GCM_SHA384\u0060）。如果您需要旧的 TLS 版本，您可以为您的工作负载[配置不同的网格范围内的最小 TLS 协议版本](https:\/\/istio.io\/latest\/docs\/tasks\/security\/tls-configuration\/workload-min-tls-version\/)。\n\n## 结束语\n\n由互联网工程任务组（IETF）制定的 TLS 协议是存在的最广泛审查、专家批准、经过战斗测试的数据安全协议之一。TLS 也在全球广泛使用 - 每当您访问任何安全网站，您都可以放心购物，部分原因是因为锁定图标表明您正在使用 TLS 安全连接到受信任的网站。TLS 1.3 协议设计具有端到端的身份验证、保密性和完整性，以确保您的应用程序的身份和通信不被破坏，并防止中间人攻击。为了实现这一点（并被认为是符合标准的 TLS），正确验证通信对等方并使用从握手协商的密钥加密流量不仅重要，而且至关重要。现在您知道 mTLS 在满足您的安全应用程序通信要求（加密身份、保密性、完整性和访问策略执行）方面表现优秀，您可以简单地使用 Istio 将您的内网应用程序通信升级到 mTLS - 配置非常少！\n\n*特别感谢 Louis Ryan、Ben Leggett、John Howard、Christian Posta、Justin Pettit 花费大量时间审查和提出博客的更新！*\n', '\/trans\/secure-apps-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/implementing-gitops-and-canary-deployment-with-argo-project-and-istio/">使用 Argo 项目 Istio 及 SkyWalking 实现 GitOps 和金丝雀部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/10/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Argo 项目 Istio 及 SkyWalking 实现 GitOps 和金丝雀部署', '本文讨论如何使用 Kubernetes Deployment、Argo 项目和 Istio 来实现 GitOps 和金丝雀部署。', '\n{{\u003ccallout note 关于本文\u003e}}\n\n本文根据笔者在 KubeCon\u0026CloudNativeCon China 2023 的通话仓活动 [IstioCon China](https:\/\/istioconchina2023.sched.com\/event\/1RoVG\/nano-argo-istio-re-skywalking-jiong-gitops-reqi-zha-yao-pi-how-to-achieve-the-perfect-union-of-gitops-and-observability-with-argo-istio-and-skywalking-jimmy-song-tetrate) 上的分享整理而成，原标题为《如何在 Argo、Istio 和 SkyWalking 中实现 GitOps 和可观测性的完美结合》。\n\n{{\u003c\/callout\u003e}}\n\n云原生应用的发展导致开发左移，应用迭代频率更高，这就催生了 GitOps 的需求。本文将介绍如何使用 Argo 项目，包括 ArgoCD 和 Argo Rollouts，通过 Istio 实现 GitOps 和金丝雀部署。文中还有一个演示，展示了如何基于 Tetrate Service Express（也适用于 Tetrate Service Bridge）提供的 Istio 环境实现 GitOps。\n\n本文 demo 的部署架构图如图 1 所示。如果您已经熟悉本文介绍的部署策略和 Argo 项目，可以直接跳到 [demo 部分](#demo)。\n\n![图 1：在 TSE\/TSB 中使用 Istio 和 Argo 项目实现 GitOps 和金丝雀发布的架构图](f1.svg)\n\n## 部署策略 {#deployment-strategy}\n\n首先，我想简单介绍一下 Argo Rollouts 支持的两种部署策略，可以实现零停机部署。\n\n蓝绿部署和金丝雀部署的步骤如图 2 所示。\n\n![Figure 2: Steps of blue-green deployment and canary deployment](f2.svg)\n\n- 蓝绿部署是一种在单独的环境中并行部署新版本应用程序而不影响当前生产环境的策略。在蓝绿部署中，当前的生产环境称为“蓝色环境”，部署新版本应用程序的环境称为“绿色环境”。一旦绿色环境被认为稳定并通过测试，流量将逐渐从蓝色环境切换到绿色环境，让用户逐步接入新版本。如果切换过程中出现问题，可以快速回滚到蓝环境，最大程度地减少对用户的影响。蓝绿部署的优点是可以提供高可用性和零停机部署。\n- 金丝雀部署是一种逐步将新版本或功能引入生产环境的策略。在金丝雀部署中，新版本或新功能首先部署到生产环境中的少数用户，称为“金丝雀用户”。通过监控金丝雀用户的反馈和性能指标，开发团队可以评估新版本或功能的稳定性和可靠性。如果没有问题，可以逐步将更多用户纳入金丝雀部署中，直到所有用户都使用新版本。如果发现问题，可以快速回滚或修复，避免对整个用户群造成负面影响。金丝雀部署的优点是可以快速发现问题并在影响较小的范围内进行调整。\n\n蓝绿部署和金丝雀部署的主要区别在于部署方式和变更规模。蓝绿部署是将整个应用部署在新的环境中，然后进行切换，适合大规模的变更，比如整个应用的重大升级。金丝雀部署逐渐引入新版本或功能，适合小规模更改，例如添加或修改单个功能。\n\n从应用场景来看，蓝绿部署适合对高可用、零宕机部署要求较高的系统。在部署大规模变更时，蓝绿部署可以保证稳定性和可靠性，并且可以快速回滚以应对突发情况。金丝雀部署适合需要快速验证新功能或版本的系统。通过逐步引入变更，可以及早发现问题并进行调整，尽量减少对用户的影响。\n\n## Kubernetes Deployment 的发布策略 {#kuberentes-deployment}\n\n在 Kubernetes 中，Deployment 资源对象是管理应用程序部署和更新的主要工具之一。部署提供了一种声明式方式来定义应用程序的预期状态，并通过控制器的功能实现发布策略。Deployment 的架构如图 3 所示，其中彩色方块代表不同版本的 Pod。\n\n![图 3：Kubernetes Deployment 架构图](f3.svg)\n\n发布策略可以在 Deployment 的 spec 字段中配置。以下是一些常见的发布策略选项：\n\n1. ReplicaSet 的管理：Deployment 使用 ReplicaSet 来创建和管理应用程序的副本。可以通过设置 \u0060spec.replicas\u0060 字段来指定所需的副本数量。在发布过程中，Kubernetes 控制器保证新版本 ReplicaSet 的副本数量在创建时逐渐增加，旧版本 ReplicaSet 的副本数量在删除时逐渐减少，实现平滑切换。\n2. 滚动更新策略：部署支持多种滚动更新策略，可以通过设置 \u0060spec.strategy.type\u0060 字段来选择。常见政策包括：\n   - \u0060RollingUpdate\u0060：默认策略以一定的时间间隔逐渐更新副本。不同时可用的副本数量以及额外可用的副本数量可以通过设置 \u0060spec.strategy.rollingUpdate.maxUnavailable\u0060 和 \u0060spec.strategy.rollingUpdate.maxSurge\u0060 字段来控制。\n   - \u0060ReCreate\u0060：该策略在更新过程中首先删除旧版本的所有副本，然后创建新版本的副本。此策略将导致应用程序在更新期间暂时不可用。\n3. 版本控制：Deployment 通过 \u0060spec.template.metadata.labels\u0060 字段为每个版本的 ReplicaSet 设置标签，以便控制器准确跟踪和管理。这样 ReplicaSet 的多个版本可以共存，并且可以精确控制每个版本的副本数量。\n\n通过使用这些配置选项，Deployment 可以实现不同的发布策略。更新 Deployment 对象的 spec 字段可以触发新版本的发布。Kubernetes 控制器会根据指定的策略自动处理副本的创建、更新和删除，以实现平滑的应用更新和部署策略。\n\n## 使用 ArgoCD 实施 GitOps {#argocd-gitops}\n\n可以使用 Deployment 来手动管理发布策略，但要实现自动化，我们还需要使用 ArgoCD 等 GitOps 工具。\n\nArgoCD 是一个基于 GitOps 的持续交付工具，用于自动化和管理 Kubernetes 应用程序的部署。它为提高应用程序部署的效率和可靠性提供了一些关键的帮助。\n\n以下是 ArgoCD 为 Kubernetes 应用程序部署提供的一些帮助：\n\n1. **声明式配置**：ArgoCD 使用声明式方式定义应用程序的预期状态，并将应用程序配置存储在 Git 存储库中。通过版本控制和持续集成\/持续交付 (CI\/CD) 流程，可以轻松跟踪和管理应用程序配置更改。\n2. **持续部署**：ArgoCD 可以监控 Git 存储库中的配置变化，并自动将应用程序部署到 Kubernetes 环境。提供可定制的同步策略，自动触发应用部署和更新，实现持续部署。\n3. **状态比较和自动修复**：ArgoCD 定期检查应用程序的当前状态并将其与预期状态进行比较。如果发现不一致，它会自动尝试修复并将应用程序恢复到所需状态，以确保预期状态与实际状态的一致性。\n4. **多环境管理**：ArgoCD 支持管理多个 Kubernetes 环境，例如开发、测试和生产环境。可以轻松地在不同环境之间部署和同步应用配置，确保一致性和可控性。\n\n与 Deployment 资源对象相比，ArgoCD 提供了更高级的功能和工作流程，补充了原生 Kubernetes 资源对象的功能：\n\n- **基于 GitOps 的配置管理**：ArgoCD 将应用程序配置存储在 Git 存储库中，从而实现基于 GitOps 的配置管理。这种方法确保配置更改是可跟踪、可审计的，并且可以与现有的 CI\/CD 管道集成。\n\n- **自动化部署和持续交付**：ArgoCD 可以自动检测 Git 存储库中的配置更改并将应用程序部署到 Kubernetes 环境，从而实现自动化部署和持续交付。\n\n- **状态管理和自动恢复**：ArgoCD 持续监控应用程序的状态并将其与预期状态进行比较。如果检测到不一致，它会自动恢复并确保应用程序状态与预期状态保持一致。\n\n## 使用 Istio 实现细粒度的流量路由 {#istio-routing-traffic}\n\n虽然 ArgoCD 可以实现 GitOps，但它本质上是在 Kubernetes 部署上运行并通过副本数量控制流量路由。为了实现细粒度的流量路由，使用了 Istio 等服务网格。\n\nIstio 通过以下方法实现更细粒度的流量路由和应用发布：\n\n**VirtualService**：Istio 使用 VirtualService 来定义流量路由规则。通过配置 VirtualService，可以根据请求头、路径、权重等请求属性对流量进行路由和分发，将请求定向到不同的服务实例或版本。\n\n**DestinationRule**：Istio 的 DestinationRule 用于定义服务版本策略和负载均衡设置。通过指定不同版本服务实例之间不同的流量权重，可以实现金丝雀发布、蓝绿部署等高级应用发布策略。\n\n**流量控制和策略**：Istio 提供了丰富的流量控制和策略能力，如流量限制、故障注入、超时设置、重试机制等，这些功能帮助应用程序实现更高级别的负载均衡、容错和可靠性要求。\n\n与 ArgoCD 和 Kubernetes Deployment 对象相比，Istio 在应用部署方面提供了以下优势：\n\n**细粒度的流量路由控制**：Istio 提供了更丰富的流量路由能力，可以根据多种请求属性进行灵活的路由和分发，从而实现更细粒度的流量控制和管理。\n\n**高级发布策略支持**：Istio 的 DestinationRule 可以指定不同版本服务实例之间的流量权重，支持金丝雀发布、蓝绿部署等高级应用发布策略。这使得应用程序的版本管理和发布更加灵活可控。\n\n**强大的流量控制和策略能力**：Istio 提供了丰富的流量控制和策略能力，如流量限制、故障注入、超时设置、重试机制等，这些功能帮助应用程序实现更高级别的负载均衡、容错和可靠性要求。\n\n将 Istio 与 Argo Rollouts 相结合，可以充分发挥 Istio 细粒度流量路由的优势。现在让我们一起进行演示。在我们的演示中，我们将使用 TSE 提供的 Kubernetes 和 Istio 环境，使用 ArgoCD 实现 GitOps，并使用 Argo Rollouts 实现金丝雀发布。\n\n## Demo\n\n我们的演示中使用的软件版本是：\n\n-  Kubernetes v1.24.14\n-  Istio v1.15.7\n-  Argo CD v2.7.4\n-  Argo 发布 v1.5.1\n-  TSE Preview 2\n\n我们将使用 Istio 的 VirtualService 和 DestinationRule 来实现基于 Subset 的流量分组路由，并使用 ArgoCD Rollouts 进行渐进式发布。\n\n### 部署 ArgoCD 和 Argo Rollouts {#deployment-argocd-and-rollouts}\n\n我提前创建了一个 Kubernetes 集群并将其添加到 TSE 中，TSE 会自动为集群安装 Istio 控制平面。我们还需要安装 ArgoCD 和 Argo Rollouts：\n\n\u0060\u0060\u0060bash\n# Install ArgoCD\nkubectl create namespace argocd\nkubectl apply -n argocd -f https:\/\/raw.githubusercontent.com\/argoproj\/argo-cd\/stable\/manifests\/install.yaml\n\n# Install ArgoCD CLI on macOS\nbrew install argocd\n\n# Change the service type of argocd-server to LoadBalancer\nkubectl patch svc argocd-server -n argocd -p \u0027{\u0022spec\u0022: {\u0022type\u0022: \u0022LoadBalancer\u0022}}\u0027\n\n# Get the ArgoCD UI address\nARGOCD_ADDR=$(kubectl get svc argocd-server -n argocd -o jsonpath=\u0027{.status.loadBalancer.ingress[0].hostname}\u0027)\n\n# Login using ArgoCD CLI, see https:\/\/argo-cd.readthedocs.io\/en\/stable\/getting_started\/#4-login-using-the-cli to get password\nargocd login $ARGOCD_ADDR --skip-test-tls --grpc-web --insecure\n\n# Install Argo Rollouts\nkubectl create namespace argo-rollouts\nkubectl apply -n argo-rollouts -f https:\/\/github.com\/argoproj\/argo-rollouts\/releases\/download\/latest\/install.yaml\n\n# Install rollouts plugin on macOS\ncurl -LO https:\/\/github.com\/argoproj\/argo-rollouts\/releases\/download\/v1.5.0\/kubectl-argo-rollouts-darwin-amd64\nchmod \u002bx .\/kubectl-argo-rollouts-darwin-amd64\nsudo mv .\/kubectl-argo-rollouts-darwin-amd64 \/usr\/local\/bin\/kubectl-argo-rollouts\n\u0060\u0060\u0060\n\n该功能不适用于 TSE Bridge Mode，因此我们将使用 TSE Direct Mode 来实现渐进式发布。\n\n{{\u003ccallout note \u0022💡什么是桥接模式和直接模式？\u0022\u003e}}\n\n\n直接模式和桥接模式是 TSE 中控制平面下发配置的两种模式。适用于流量、安全、网关组配置模式。BRIDGED 模式是一种极简模式，允许用户使用 Tetrate 特定的 API 快速配置服务网格中最常用的功能，而 DIRECT 模式为高级用户提供更大的灵活性，允许他们直接使用 Istio API 进行配置。\n\n{{\u003c\/callout\u003e}}\n\n接下来，部署 Rollouts Dashboard：\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/argoproj\/argo-rollouts.git\nkustomize build manifests\/dashboard-install|kubectl apply -n argo-rollouts -f -\nkubectl port-forward svc\/argo-rollouts-dashboard -n argo-rollouts 3100:3100\n\u0060\u0060\u0060\n\n您现在可以通过 \u003chttps:\/\/localhost:3100\/rollouts\/\u003e 访问 Rollouts 仪表板。\n\n### 部署 Bookinfo 应用 {#bookinfo}\n\n我们已经为 Bookinfo 应用程序准备了配置文件（保存在 [tse-gitops-demo](https:\/\/github.com\/tetrateio\/tse-gitops-demo\/) 存储库中），您也可以将其 fork 到您自己的帐户并将其替换为您自己的存储库。运行以下命令来部署 Bookinfo 应用程序：\n\n\u0060\u0060\u0060bash\nargocd app create bookinfo-app --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path application --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated\n\u0060\u0060\u0060\n\n注意：我们在 [\u0060reviews\u0060 部署](https:\/\/github.com\/tetrateio\/tse-gitops-demo\/blob\/main\/application\/bookinfo.yaml#L151)中将 \u0060replicas\u0060 设置为 \u00600\u0060 ，因为我们将创建 Argo Rollouts 来操纵 \u0060reviews\u0060 的实例数量服务。如果这里设置为非零正整数，我们将无法实现金丝雀部署。\n\n现在您可以在浏览器中打开 ArgoCD UI，如图 4 所示。\n\n![图 4：ArgoCD 用户界面](f4.png)\n\n如果您发现应用程序状态不同步，可以运行以下命令或单击 UI 中的 SYNC 按钮。\n\n\u0060\u0060\u0060bash\nargocd app sync bookinfo-app\n\u0060\u0060\u0060\n\n## 使用 Istio 实施细粒度流量管理 {#istio-fine-grain-traffic-management}\n\n首先，我们使用 Argo CD 创建 Istio 相关的资源对象：\n\n\u0060\u0060\u0060bash\nargocd app create bookinfo-tse-conf --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path argo\/tse --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated --self-heal\n\n# Check the creation status\nargocd app get bookinfo-tse-conf\n\u0060\u0060\u0060\n\n### 将 Deployment 转换为 Rollout {#convert-deployment-to-rollout}\n\n假设我们要发布新版本的 \u0060reviews\u0060 服务。为了实现零停机更新，我们将使用金丝雀部署，具体步骤如下：\n\n1. 将 \u0060reviews\u0060 Deployment 的 \u0060replicas\u0060 减少为 0；\n2. 创建引用先前在 Bookinfo 应用程序中部署的 \u0060reviews\u0060 Deployment 的 Rollout；\n3. 将流量发送到 \u0060reviews\u0060 服务以实现自动金丝雀部署进度。\n\n您可以在 GitHub 上查看本演示中使用的 Rollout 和 AnalysisTemplate 配置。运行以下命令来部署 \u0060reivews-rollout\u0060 ：\n\n\u0060\u0060\u0060bash\nargocd app create reviews-rollout --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path argo\/rollout --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated\n\u0060\u0060\u0060\n\n注意：我们可以使用 \u0060argocd\u0060 命令来部署或使用 \u0060kubectl apply\u0060 。推荐使用 \u0060argocd\u0060 ，因为您可以同时在 ArgoCD UI 和 Argo Rollouts Dashboard 中查看部署状态，并使用 \u0060argocd\u0060 命令管理部署。\n\n在 Argo Rollouts Dashboard 中查看 \u0060reviews\u0060 部署的状态，并使用以下命令将流量发送到 \u0060reviews\u0060 服务一段时间：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_HOSTNAME=$(kubectl -n bookinfo get service tsb-gateway-bookinfo -o jsonpath=\u0027{.status.loadBalancer.ingress[0].hostname}\u0027)\nwhile 1;do curl -H \u0022Host: bookinfo.tetrate.com\u0022 http:\/\/$GATEWAY_HOSTNAME\/api\/v1\/products\/1\/reviews;sleep 3;done\n\u0060\u0060\u0060\n\n您将在输出中看到来自具有不同 rollouts-pod-template-hash 标签的 pod 的响应，这证明金丝雀部署是有效的。大约 10 分钟后，您看到的 Argo Rollouts 仪表板将如图 5 所示。\n\n![图 5：Argo Rollouts 仪表板](f5.png)\n\n从图 5 中我们可以看到金丝雀部署进展顺利，已经到了第三步。这是因为 \u0060reviews\u0060 服务的 \u0060apdex\u0060 （应用性能指数）指标正常。您可以[使用 Postman 向 SkyWalking 提交 GraphQL 查询](https:\/\/tetrate.io\/blog\/how-to-use-graphql-to-query-observability-data-from-skywalking-with-postman\/)来验证这一点，如图 6 所示。\n\n![图 6：使用 Postman 将 GraphQL 查询提交到 SkyWalking](f6.png)\n\n我们构建的 GraphQL 查询语句如下：\n\n\u0060\u0060\u0060graphql\nquery ReadMetricsValues {\n    readMetricsValues(condition: {\n    name: \u0022service_apdex\u0022, entity: {scope: Service, serviceName: \u0022canary|reviews|bookinfo|cluster-1|-\u0022, normal: true}\n  }, duration: {\n    start: \u00222023-07-13 0812\u0022,\n    end: \u00222023-07-13 0813\u0022,\n    step: MINUTE\n  }) {\n        label\n        values {\n            values {\n                id\n                value\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n该语句从 UTC \u00602023-07-13 8:12\u0060 到 \u00602023 8:13\u0060 查询 \u0060canary|reviews|bookinfo|cluster-1|-\u0060 服务的 \u0060apdex\u0060 指标，持续两分钟，得到以下结果：\n\n\u0060\u0060\u0060json\n{\n    \u0022data\u0022: {\n        \u0022readMetricsValues\u0022: {\n            \u0022label\u0022: null,\n            \u0022values\u0022: {\n                \u0022values\u0022: [\n                    {\n                        \u0022id\u0022: \u0022service_apdex_202307130812_Y2FuYXJ5fHJldmlld3N8Ym9va2luZm98Y2x1c3Rlci0xfC0=.1\u0022,\n                        \u0022value\u0022: 10000\n                    },\n                    {\n                        \u0022id\u0022: \u0022service_apdex_202307130813_Y2FuYXJ5fHJldmlld3N8Ym9va2luZm98Y2x1c3Rlci0xfC0=.1\u0022,\n                        \u0022value\u0022: 10000\n                    }\n                ]\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n\u0060apdex\u0060 指标的值大于 9900（AnalysisTemplate 的 \u0060successCondition\u0060 中配置的阈值），因此 Rollouts 会顺利进行。您还可以在 Argo Rollouts Dashboard 上单击“手动升级”来升级它，或运行以下命令：\n\n\u0060\u0060\u0060bash\nkubectl argo rollouts promote reviews-rollout -n bookinf\n\u0060\u0060\u0060\n\n## 清理 {#clean-up}\n\n删除已部署的 ArgoCD 应用程序和 Rollout：\n\n\u0060\u0060\u0060bash\nargocd app delete -y reviews-rollout\nargocd app delete -y bookinfo-tse-conf\nargocd app delete -y bookinfo-app\n\u0060\u0060\u0060\n\n## Argo Rollouts 原理 {#rollouts-principle}\n\n与 Istio 集成时，Argo Rollouts 支持基于 VirtualService 和 Subset 的流量拆分，如图 7 所示。\n\n![图 7：Argo Rollouts 使用 Istio 进行流量分配](f7.svg)\n\n下表提供了这两种流量分段方法的详细比较。\n\n| 类型           | 适用场景                             | 资源对象                                          | 原则                                                         |\n| :------------- | :----------------------------------- | :------------------------------------------------ | :----------------------------------------------------------- |\n| 主机级流量分割 | 适用于根据主机名访问不同版本的服务； | 2 个服务、1 个虚拟服务、1 个部署；                | Rollout 将 rollouts-pod-template-hash 标签注入到 ReplicaSet 中，并通过更新 Service 中的选择器来选择带有这些标签的 pod； |\n| 子集级流量分割 | 适用于根据标签访问不同的服务；       | 1 个服务、1 个虚拟服务、1 个目标规则和 1 个转出； | Rollout 将 rollouts-pod-template-hash 标签注入到 ReplicaSet 中，并通过更新 DestinationRule 中的选择器来选择具有这些标签的 pod； |\n\n本演示中使用基于子集的流量分割，Argo 不断推出：\n\n- 修改 VirtualService \u0060spec.http[].route[].weight\u0060 以匹配当前所需的金丝雀权重\n- 修改 DestinationRule \u0060spec.subsets[].labels\u0060 以包含 canary 和稳定 ReplicaSet 的 \u0060rollouts-pod-template-hash\u0060 标签\n\n请访问 [Argo Rollouts 文档](https:\/\/argo-rollouts.readthedocs.io\/en\/stable\/features\/traffic-management\/istio\/)，了解有关使用 Istio 进行流量管理的详细信息。\n\n## 总结 {#summary}\n\n本文介绍如何使用 Argo 项目和 Istio 实现 GitOps 和金丝雀部署。首先我们使用 ArgoCD 实现 GitOps，然后使用 Argo Rollout 和 SkyWalking 实现自动化金丝雀发布。从 demo 中我们可以看到 TSE 部署的 Istio 与开源版本完全兼容。TSE 有许多功能值得探索，请访问 [Tetrate 网站](https:\/\/tetrate.io\/tetrate-service-express\/)了解更多信息。\n', '\/blog\/implementing-gitops-and-canary-deployment-with-argo-project-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论如何使用 Kubernetes Deployment、Argo 项目和 Istio 来实现 GitOps 和金丝雀部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/2/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/4/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/7/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(70)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(40)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
