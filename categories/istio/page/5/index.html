<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/secure-apps-with-istio/">[译] 使用相互 TLS 和 Istio 保护应用程序通信</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2023/secure-apps-with-istio/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用相互 TLS 和 Istio 保护应用程序通信', '本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。', '\n\u003e 摘要：本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。\n\n用户采用服务网格的最大原因之一是使用相互 TLS（mTLS）基于可通过加密验证的身份来启用应用程序之间的安全通信。在此博客中，我们将讨论应用程序之间安全通信的要求，以及 mTLS 如何实现并满足所有这些要求，以及使用 Istio 启用应用程序之间 mTLS 的简单步骤。\n\n## 您需要什么来保护应用程序之间的通信？\n\n现代云原生应用程序经常分布在多个 Kubernetes 集群或虚拟机中。新版本经常进行阶段性部署，它们可以根据用户请求快速扩展和缩小。由于现代应用程序通过不依赖共同定位来提高资源利用效率，因此能够应用访问策略并保护这些分布式应用程序之间的通信至关重要，因为增加的多个入口点导致了更大的攻击面。忽视这一点将邀请数据丢失、数据盗窃、伪造数据或简单处理等巨大的业务风险。\n\n以下是应用程序之间安全通信的常见关键要求：\n\n### 身份\n\n身份是任何安全架构的基本组成部分。在您的应用程序可以安全地发送数据之前，必须为应用程序建立**身份**。这个建立身份的过程被称为**身份验证** - 它涉及由某个知名的，受信任的**权威机构**对应用程序工作负载进行一次或多次检查，以确认它是它所声称的那样。一旦权威机构满意，它就会授予工作负载一个身份。\n\n考虑出示护照的行为 - 你会向某个权威机构请求一个，那个权威机构可能会要求你提供几个不同的身份验证证明你是你所说的那个人 - 出生证明、现住址、医疗记录等。一旦你满足了所有的身份验证要求，你将（希望）被授予身份证件。你可以将那个身份证件给别人作为你已经满足了发证机构的所有身份验证要求的证据，如果他们信任发证机构（和身份证件本身），他们就可以信任关于你的所有内容（或者他们可以联系受信任的权威机构并验证该文件）。\n\n身份可以采取任何形式，但是，就像任何形式的身份证明一样，身份验证越弱，伪造就越容易，身份证明对于使用它进行决策的任何人来说就越无用。这就是为什么在计算中，密码可验证的身份非常重要 - 它们由可验证的权威机构签署，类似于您的护照和驾驶执照。基于任何较少的身份都是一个可以相对容易地利用的安全弱点。\n\n您的系统可能具有源自网络属性（例如 IP 地址）的身份，具有分布式身份缓存，跟踪身份与这些网络属性之间的映射。这些身份不像密码可验证的身份那样具有强大的保证，因为 IP 地址可能被重新分配给不同的工作负载，并且身份缓存可能并不总是更新到最新的状态。\n\n您希望应用程序使用密码可验证的身份，因为在建立连接时交换应用程序的密码可验证身份本质上比依赖于将 IP 地址映射到身份的系统更可靠，更安全。这些系统依赖于具有最终一致性和过时问题的分布式身份缓存，这可能在 Kubernetes 中创建结构性弱点，其中高频率的自动 pod 转换是常态。\n\n### 机密性\n\n加密应用程序之间传输的数据至关重要 - 因为在破坏常见、成本高昂和实际上微不足道的世界中，完全依赖于*安全的*内部环境或其他安全边界早已不再适用。为了防止[中间人攻击](https:\/\/en.wikipedia.org\/wiki\/Man-in-the-middle_attack)，你需要为源 - 目标对创建一个唯一的加密通道，因为你希望有强大的身份唯一性保证以避免[混淆副手问题](https:\/\/en.wikipedia.org\/wiki\/Confused_deputy_problem)。换句话说，仅仅加密通道是不够的 - 它必须使用直接从唯一源和目标身份派生的唯一密钥进行加密，以便只有源和目标可以解密数据。此外，您可能需要根据安全团队的要求定制加密，例如通过选择特定的密码。\n\n### 完整性\n\n从源发送到目标的加密数据在发送后不能被除源和目标之外的任何身份修改。换句话说，接收到的数据与发送的数据相同。如果你没有[data integrity](https:\/\/en.wikipedia.org\/wiki\/Data_integrity)，那么中间的人可能在源和目标之间的通信过程中修改一些位或整个数据的内容。\n\n### 访问策略执行\n\n应用程序所有者需要对其应用程序应用访问策略，并正确、一致且不含糊地执行它们。为了对通信渠道的两端应用策略，我们需要为每一端确定一个应用程序身份。一旦我们为可能的通信渠道的两端都有了一个可以通过密码验证的身份，并且来源链条明确，我们就可以开始确定谁可以与何物进行通信的策略。标准的 TLS，这是一种广泛使用的密码协议，用于保护客户端（例如，Web 浏览器）和服务器（例如，Web 服务器）之间的通信，只真正验证并要求一方的身份 - 服务器。但是，对于全面的端到端策略执行，对双方 - 客户端和服务器都有一个可靠、可验证、明确的身份至关重要。这对内部应用程序来说是一个共同的需求 - 想象一下，只有一个 \u0060frontend\u0060 应用程序应该调用后端 \u0060checkout\u0060 应用程序的 **GET** 方法，但是不应该被允许调用 \u0060POST\u0060 或 \u0060DELETE\u0060 方法。或者，只有那些由特定 JWT 发行者发出 JWT 令牌的应用程序才能调用 \u0060checkout\u0060 应用程序的 \u0060GET\u0060 方法。通过利用双端的密码身份，我们可以确保强大的访问策略被正确地、安全地、可靠地执行，而且有可验证的审计轨迹。\n\n### FIPS 合规性\n\n[联邦信息处理标准 (FIPS)](https:\/\/www.nist.gov\/standardsgov\/compliance-faqs-federal-information-processing-standards-fips) 是由 [国家标准与技术研究院 (NIST)](https:\/\/www.nist.gov\/) 制定的联邦计算机系统的标准和指南。并非每个人都需要 FIPS 合规性，但 FIPS 合规性意味着满足了美国政府为保护敏感信息而设立的所有必要安全要求。与联邦政府合作时需要它。为了遵循美国政府制定的与网络安全相关的指南，许多私营部门都自愿使用这些 FIPS 标准。\n\n为了说明上述安全应用程序要求（身份、机密性和完整性），让我们使用 \u0060frontend\u0060 应用程序调用 \u0060checkout\u0060 应用程序的例子。记住，您可以把图中的 **ID** 看作是任何类型的身份证明，比如政府颁发的护照、照片识别器：\n\n![前端调用结账应用程序时的要求](requirements-flow.png)\n\n## mTLS 如何满足上述要求？\n\nTLS 1.3（在撰写本文时的最新 TLS 版本） [规范](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446) 的主要目标是在两个通信对等方之间提供一个安全通道。TLS 安全通道具有以下属性：\n\n1. 验证：通道的服务器端始终被验证，客户端可选地被验证。当客户端也被验证时，安全通道成为一个相互的 TLS 通道。\n2. 机密性：数据被加密且只对客户端和服务器可见。必须使用与源和目标身份证明无歧义地密码绑定的密钥来加密数据，以便可靠地保护应用程序层的流量。\n3. 完整性：通过通道发送的数据无法在未被检测到的情况下进行修改。这是通过只有源和目标拥有给定会话的加密和解密密钥的事实来保证的。\n\n### mTLS 内部逻辑\n\n我们已经确定了，使用可以通过加密验证的身份标识对于保护通道和支持访问策略执行至关重要，我们也已经确定了，mTLS 是一种经过严密测试的协议，它为在通道的两端使用可以通过加密验证的身份标识提供了一些极其重要的保证 - 让我们深入了解一下 mTLS 协议在实际运行中是如何工作的。\n\n### 握手协议\n\n[握手协议](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-4) 验证了通信双方的身份，协商了加密模式和参数，并建立了共享的密钥材料。换句话说，握手的角色是验证通信双方的身份并协商会话密钥，以便连接的其余部分可以根据会话密钥进行加密。当您的应用程序建立 mTLS 连接时，服务器和客户端协商一个密码套件，该套件规定了您的应用程序将用于连接其余部分的加密算法，您的应用程序还协商了要使用的加密会话密钥。整个握手过程都被设计为能抵抗篡改 - 任何未持有与源和\/或目标相同的独特，能够通过加密验证的身份文档的实体的干扰都会被拒绝。因此，在任何通信方继续进行应用程序数据之前，都有必要检查整个握手过程并验证其完整性。\n\n握手可以被认为是按照 TLS 1.3 规范中的[握手协议概述](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-2)有三个阶段 - 再次使用\u0060frontend\u0060应用程序调用后端\u0060checkout\u0060应用程序的例子：\n\n1. 第一阶段：\u0060frontend\u0060和\u0060checkout\u0060协商可以用来保护握手和流量数据的加密参数和密钥。\n2. 第二阶段：在此阶段和之后的所有内容都是加密的。在这个阶段，\u0060frontend\u0060和\u0060checkout\u0060建立其他握手参数，并确定是否也对客户端进行身份验证 - 也就是说，mTLS。\n3. 第三阶段：\u0060frontend\u0060通过其可通过加密验证的身份验证\u0060checkout\u0060（在 mTLS 中，\u0060checkout\u0060以相同的方式验证\u0060frontend\u0060）。\n\n自 TLS 1.2 以来，与握手相关的有几个主要区别，有关更多详细信息，请参考 TLS 1.3 规范：\n\n1. 所有握手消息（第二阶段和第三阶段）都使用在第一阶段协商的加密密钥进行加密。\n2. 已经削减了遗留的对称加密算法。\n3. 添加了零往返时间（0-RTT）模式，节省了连接设置的一个往返时间。\n\n### 记录协议\n\n在握手阶段协商了 TLS 协议版本、会话密钥和[HMAC](https:\/\/en.wikipedia.org\/wiki\/HMAC)后，双方现在可以通过[记录协议](https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-5)安全地交换被分块的加密数据。使用握手中协商的完全相同的参数对流量进行加密是至关重要的（并且是规范的一部分），以确保流量的机密性和完整性。\n\n将 TLS 1.3 规范中的两个协议放在一起，并使用\u0060frontend\u0060和\u0060checkout\u0060应用程序来说明以下流程：\n\n![当前端调用结账应用程序时的 mTLS 流程](mtls-flow.png)\n\n谁为\u0060frontend\u0060和\u0060checkout\u0060发出身份证书？它们通常由具有自己的[根证书](https:\/\/en.wikipedia.org\/wiki\/Root_certificate)或使用其根 CA 的中间证书的[证书颁发机构（CA）](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority)发出。根证书基本上是一份标识根 CA 的公钥证书，您的组织可能已经拥有此证书。根证书会与\u0060frontend\u0060（或\u0060checkout\u0060）的自己的根签名身份证书一起分发到\u0060frontend\u0060。这就是基本的公钥基础设施（PKI）的工作方式 - CA 负责验证实体的身份文档，然后以证书的形式授予它一个无法伪造的身份文档。\n\n您可以依赖您的 CA 和中间 CA 作为身份**真理**的来源，以一种维持高可用性并提供稳定、持久可验证的身份保证的结构化方式，而一个庞大的分布式 IP 和身份映射缓存则无法做到这一点。当\u0060frontend\u0060和\u0060checkout\u0060的身份证书由同一个根证书发出时，\u0060frontend\u0060和\u0060checkout\u0060可以始终以一致且可靠的方式验证其对等身份，无论它们运行在哪个集群或节点或规模中。\n\n您了解了 mTLS 如何提供加密身份、机密性和完整性，那么当您的应用程序数量增长到数千个或更多，并且跨多个集群时，其可扩展性如何呢？如果您在多个集群中建立一个单一的根证书，那么只要它被根证书信任，系统就不需要在应用程序收到来自另一个集群的连接请求时进行处理 - 系统知道连接上的身份已经通过加密进行了验证。当您的应用程序 pod 更改 IP 或被重新部署到另一个集群或网络时，您的应用程序（或代表其行动的组件）只需使用其由 CA 铸造的受信任证书向目标发起流量即可。无论是 500\u002b 网络跳转还是直接连接，您的访问策略都会以相同的方式执行，无需跟踪身份缓存并计算哪个 IP 地址映射到哪个应用程序 pod。\n\n那么关于 FIPS 合规性呢？根据 TLS 1.3 规范，TLS 兼容的应用程序必须实现\u0060TLS_AES_128_GCM_SHA256\u0060密码套件，并建议实现\u0060TLS_AES_256_GCM_SHA384\u0060，这两者都在 NIST 的[TLS 指南](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-52r2.pdf)中。RSA 或 ECDSA 服务器证书也被 TLS 1.3 规范和 NIST 的 TLS 指南推荐。只要您为 mTLS 连接使用 FIPS 140-2 或 140-3 合规的加密模块，您就会走上[FIPS 140-2 或 140-3 验证](https:\/\/csrc.nist.gov\/projects\/cryptographic-module-validation-program\/validated-modules)的正确路径。\n\n## 可能出现的问题\n\n按照 TLS 1.3 规范正确实施 mTLS 至关重要。如果不按照 TLS 规范正确使用 mTLS，以下是一些可能在未被检测的情况下出现的问题：\n\n### 如果有人在连接中间静默地捕获加密数据会怎么样？\n\n如果连接没有按照 TLS 规范中概述的握手和记录协议来进行，例如，连接遵循握手协议，但在记录协议中没有使用握手中协商的会话密钥和参数，您可能会发现您的连接的握手和记录协议之间没有关联，握手和记录协议之间的身份可能不同。TLS 要求握手和记录协议在同一连接中共享，因为将它们分开会增加中间人攻击的攻击面。\n\nmTLS 连接从握手开始到结束都具有一致的端到端安全性。加密数据是用证书中公钥协商的会话密钥加密的。只有源和目标可以使用私钥解密数据。换句话说，只有拥有私钥的证书所有者才能解密数据。除非黑客控制了证书的私钥，否则他或她没有办法搞乱 mTLS 连接以成功执行中间人攻击。\n\n### 如果源或目标身份没有加密安全怎么办？\n\n如果身份基于网络属性，如 IP 地址，这些属性可能会重新分配给其他 pod，就无法使用加密技术验证该身份。由于此类身份不基于加密身份，因此您的系统可能有一个身份缓存，用于跟踪身份、pod 的网络标签、相应的 IP 地址和部署 pod 的 Kubernetes 节点信息之间的映射。使用身份缓存，您可能会遇到 pod IP 地址被重用和身份错误，当身份缓存在短时间内同步出现问题时，策略可能无法正确执行。例如，如果您的连接之间的对等方没有加密身份，您的系统将不得不从可能过时或不完整的身份缓存中获取身份。\n\n将身份映射到工作负载 IP 的这些身份缓存不是 ACID（原子性、一致性、隔离性和持久性），您希望您的安全系统应用于具有强保证的事物。考虑以下属性和您可能想要问自己的问题：\n\n- 过时：对等方如何验证缓存中的条目是否是**当前**的？\n- 不完整：如果缓存未命中并且系统未能关闭连接，只有缓存**同步器**失败时网络才会变得不稳定吗？\n- 如果某个东西根本没有 IP 怎么办？例如，默认情况下，AWS Lambda 服务没有公共 IP。\n- 非事务性：如果您读取两次身份，会看到相同的值吗？如果在访问策略或审计实施中不小心，这可能会导致真正的问题。\n- 谁将守护守护者自己？是否有既定的实践来保护缓存，就像 CA 有的那样？您有什么证据证明缓存没有被篡改吗？您是否被迫对一些不是您的 CA 的复杂基础设施的安全性进行推理（和审计）？\n\n以上问题中有些比其他问题更糟。您可以应用**失败关闭**原则，但这并不能解决所有问题。\n\n身份也用于执行访问策略，例如授权策略，这些访问策略在请求路径中，您的系统必须快速做出决定，允许或拒绝访问。每当身份出现错误时，访问策略可能会被绕过，而无法被检测或审计。例如，您的身份缓存可能将您的\u0060checkout\u0060 pod 的先前分配的 IP 地址作为\u0060checkout\u0060身份之一。如果\u0060checkout\u0060 pod 被回收，同一 IP 地址刚刚被分配给一个\u0060frontend\u0060 pod，那么在缓存更新之前，该\u0060frontend\u0060 pod 可能具有\u0060checkout\u0060的身份，这可能导致错误的访问策略被执行。\n\n让我们假设以下大规模多集群部署，说明身份缓存过时问题：\n\n1. 100 个集群，每个集群有 100 个节点，每个节点有 20 个 pod。总的 pod 数量是 200,000。\n2. 0.25% 的 pod 一直在变动（滚动更新，重启，恢复，节点变动等），每次变动的窗口是 10 秒。\n3. 每 10 秒有 500 个正在变动的 pod 分布到 10,000 个节点（缓存）。\n4. 如果缓存同步器停滞，系统在 5 分钟后过时的%可能高达**7.5%**！\n\n以上假设缓存同步器处于稳态。如果缓存同步器出现问题，会影响其健康检查，增加变动率，导致级联不稳定。\n\nCA 也可能被攻击者[攻击](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority#CA_compromise)，攻击者假装是别人，欺骗 CA 发出证书。然后，攻击者可以使用该证书与其他对等方通信。这是[证书撤销](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority#Certificate_revocation)可以通过撤销证书使其无效来解决问题。否则，攻击者可以利用被攻击的证书直到其过期。保持根证书的私钥在 HSM 中至关重要，该 HSM 应保持[离线](https:\/\/en.wikipedia.org\/wiki\/Online_and_offline)，并使用中间证书签署工作负载证书。在 CA 停顿或停滞 5 分钟的情况下，您将无法获得新的或续期的工作负载证书，但之前发出的有效证书将继续为您的工作负载提供强大的身份保证。为了提高发行的可靠性，您可以将中间 CA 部署到不同的区域和地区。\n\n## Istio 中的 mTLS\n\n### 启用 mTLS\n\n在 Istio 中为内网应用程序启用 mTLS 非常简单。您需要做的就是将您的应用程序添加到网格中，这可以通过为您的命名空间标记侧车注入或环境来完成。在侧车的情况下，需要进行滚动重启，以便侧车被注入到您的应用程序 pod 中。\n\n### 加密身份\n\n在 Kubernetes 环境中，[Istio](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#istio-identity)根据其服务帐户创建应用程序的身份。将应用程序添加到网格后，将向网格中的每个应用程序 pod 提供身份证书。\n\n默认情况下，您的 pod 的身份证书在 24 小时后过期，Istio 每 12 小时旋转一次 pod 身份证书，以便在出现妨害行为的情况下（例如，被攻击的 CA 或被盗的 pod 的私钥），被攻击的证书只能在证书过期并因此限制其可能造成的损害的非常有限的时间内工作。\n\n### 强制执行严格的 mTLS\n\n默认的 mTLS 行为是尽可能使用 mTLS，但并不强制执行。要严格强制您的应用程序只接受 mTLS 流量，您可以使用 Istio 的[PeerAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/peer_authentication\/)策略，对整个网格或每个命名空间或工作负载进行操作。此外，您还可以应用 Istio 的[AuthorizationPolicy](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/)来控制您的工作负载的访问。\n\n### TLS 版本\n\nTLS 版本 1.3 是 Istio 在内网应用程序通信中的默认设置，使用 Envoy 的[默认密码套件](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/tls\/v3\/common.proto)（例如，对于 Istio 1.19.0，为\u0060TLS_AES_256_GCM_SHA384\u0060）。如果您需要旧的 TLS 版本，您可以为您的工作负载[配置不同的网格范围内的最小 TLS 协议版本](https:\/\/istio.io\/latest\/docs\/tasks\/security\/tls-configuration\/workload-min-tls-version\/)。\n\n## 结束语\n\n由互联网工程任务组（IETF）制定的 TLS 协议是存在的最广泛审查、专家批准、经过战斗测试的数据安全协议之一。TLS 也在全球广泛使用 - 每当您访问任何安全网站，您都可以放心购物，部分原因是因为锁定图标表明您正在使用 TLS 安全连接到受信任的网站。TLS 1.3 协议设计具有端到端的身份验证、保密性和完整性，以确保您的应用程序的身份和通信不被破坏，并防止中间人攻击。为了实现这一点（并被认为是符合标准的 TLS），正确验证通信对等方并使用从握手协商的密钥加密流量不仅重要，而且至关重要。现在您知道 mTLS 在满足您的安全应用程序通信要求（加密身份、保密性、完整性和访问策略执行）方面表现优秀，您可以简单地使用 Istio 将您的内网应用程序通信升级到 mTLS - 配置非常少！\n\n*特别感谢 Louis Ryan、Ben Leggett、John Howard、Christian Posta、Justin Pettit 花费大量时间审查和提出博客的更新！*\n', '\/trans\/secure-apps-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论了使用相互 TLS (mTLS) 和 Istio 保护应用程序通信的重要性。mTLS 提供了端到端的安全性，只有源和目标可以解密数据，从而防止中间人攻击。然而，如果源或目标的身份没有加密，可能会出现问题。Istio 中的 mTLS 可以简单地启用，并为每个应用程序 pod 提供身份证书。为了强制执行严格的 mTLS，可以使用 Istio 的 PeerAuthentication 策略和 AuthorizationPolicy。最后，TLS 协议是最广泛审查、专家批准、经过战斗测试的数据安全协议之一，Istio 默认在内网应用程序通信中使用 TLS 1.3 版本。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/implementing-gitops-and-canary-deployment-with-argo-project-and-istio/">使用 Argo 项目 Istio 及 SkyWalking 实现 GitOps 和金丝雀部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/10/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Argo 项目 Istio 及 SkyWalking 实现 GitOps 和金丝雀部署', '本文讨论如何使用 Kubernetes Deployment、Argo 项目和 Istio 来实现 GitOps 和金丝雀部署。', '\n{{\u003ccallout note 关于本文\u003e}}\n\n本文根据笔者在 KubeCon\u0026CloudNativeCon China 2023 的通话仓活动 [IstioCon China](https:\/\/istioconchina2023.sched.com\/event\/1RoVG\/nano-argo-istio-re-skywalking-jiong-gitops-reqi-zha-yao-pi-how-to-achieve-the-perfect-union-of-gitops-and-observability-with-argo-istio-and-skywalking-jimmy-song-tetrate) 上的分享整理而成，原标题为《如何在 Argo、Istio 和 SkyWalking 中实现 GitOps 和可观测性的完美结合》。\n\n{{\u003c\/callout\u003e}}\n\n云原生应用的发展导致开发左移，应用迭代频率更高，这就催生了 GitOps 的需求。本文将介绍如何使用 Argo 项目，包括 ArgoCD 和 Argo Rollouts，通过 Istio 实现 GitOps 和金丝雀部署。文中还有一个演示，展示了如何基于 Tetrate Service Express（也适用于 Tetrate Service Bridge）提供的 Istio 环境实现 GitOps。\n\n本文 demo 的部署架构图如图 1 所示。如果您已经熟悉本文介绍的部署策略和 Argo 项目，可以直接跳到 [demo 部分](#demo)。\n\n![图 1：在 TSE\/TSB 中使用 Istio 和 Argo 项目实现 GitOps 和金丝雀发布的架构图](f1.svg)\n\n## 部署策略 {#deployment-strategy}\n\n首先，我想简单介绍一下 Argo Rollouts 支持的两种部署策略，可以实现零停机部署。\n\n蓝绿部署和金丝雀部署的步骤如图 2 所示。\n\n![Figure 2: Steps of blue-green deployment and canary deployment](f2.svg)\n\n- 蓝绿部署是一种在单独的环境中并行部署新版本应用程序而不影响当前生产环境的策略。在蓝绿部署中，当前的生产环境称为“蓝色环境”，部署新版本应用程序的环境称为“绿色环境”。一旦绿色环境被认为稳定并通过测试，流量将逐渐从蓝色环境切换到绿色环境，让用户逐步接入新版本。如果切换过程中出现问题，可以快速回滚到蓝环境，最大程度地减少对用户的影响。蓝绿部署的优点是可以提供高可用性和零停机部署。\n- 金丝雀部署是一种逐步将新版本或功能引入生产环境的策略。在金丝雀部署中，新版本或新功能首先部署到生产环境中的少数用户，称为“金丝雀用户”。通过监控金丝雀用户的反馈和性能指标，开发团队可以评估新版本或功能的稳定性和可靠性。如果没有问题，可以逐步将更多用户纳入金丝雀部署中，直到所有用户都使用新版本。如果发现问题，可以快速回滚或修复，避免对整个用户群造成负面影响。金丝雀部署的优点是可以快速发现问题并在影响较小的范围内进行调整。\n\n蓝绿部署和金丝雀部署的主要区别在于部署方式和变更规模。蓝绿部署是将整个应用部署在新的环境中，然后进行切换，适合大规模的变更，比如整个应用的重大升级。金丝雀部署逐渐引入新版本或功能，适合小规模更改，例如添加或修改单个功能。\n\n从应用场景来看，蓝绿部署适合对高可用、零宕机部署要求较高的系统。在部署大规模变更时，蓝绿部署可以保证稳定性和可靠性，并且可以快速回滚以应对突发情况。金丝雀部署适合需要快速验证新功能或版本的系统。通过逐步引入变更，可以及早发现问题并进行调整，尽量减少对用户的影响。\n\n## Kubernetes Deployment 的发布策略 {#kuberentes-deployment}\n\n在 Kubernetes 中，Deployment 资源对象是管理应用程序部署和更新的主要工具之一。部署提供了一种声明式方式来定义应用程序的预期状态，并通过控制器的功能实现发布策略。Deployment 的架构如图 3 所示，其中彩色方块代表不同版本的 Pod。\n\n![图 3：Kubernetes Deployment 架构图](f3.svg)\n\n发布策略可以在 Deployment 的 spec 字段中配置。以下是一些常见的发布策略选项：\n\n1. ReplicaSet 的管理：Deployment 使用 ReplicaSet 来创建和管理应用程序的副本。可以通过设置 \u0060spec.replicas\u0060 字段来指定所需的副本数量。在发布过程中，Kubernetes 控制器保证新版本 ReplicaSet 的副本数量在创建时逐渐增加，旧版本 ReplicaSet 的副本数量在删除时逐渐减少，实现平滑切换。\n2. 滚动更新策略：部署支持多种滚动更新策略，可以通过设置 \u0060spec.strategy.type\u0060 字段来选择。常见政策包括：\n   - \u0060RollingUpdate\u0060：默认策略以一定的时间间隔逐渐更新副本。不同时可用的副本数量以及额外可用的副本数量可以通过设置 \u0060spec.strategy.rollingUpdate.maxUnavailable\u0060 和 \u0060spec.strategy.rollingUpdate.maxSurge\u0060 字段来控制。\n   - \u0060ReCreate\u0060：该策略在更新过程中首先删除旧版本的所有副本，然后创建新版本的副本。此策略将导致应用程序在更新期间暂时不可用。\n3. 版本控制：Deployment 通过 \u0060spec.template.metadata.labels\u0060 字段为每个版本的 ReplicaSet 设置标签，以便控制器准确跟踪和管理。这样 ReplicaSet 的多个版本可以共存，并且可以精确控制每个版本的副本数量。\n\n通过使用这些配置选项，Deployment 可以实现不同的发布策略。更新 Deployment 对象的 spec 字段可以触发新版本的发布。Kubernetes 控制器会根据指定的策略自动处理副本的创建、更新和删除，以实现平滑的应用更新和部署策略。\n\n## 使用 ArgoCD 实施 GitOps {#argocd-gitops}\n\n可以使用 Deployment 来手动管理发布策略，但要实现自动化，我们还需要使用 ArgoCD 等 GitOps 工具。\n\nArgoCD 是一个基于 GitOps 的持续交付工具，用于自动化和管理 Kubernetes 应用程序的部署。它为提高应用程序部署的效率和可靠性提供了一些关键的帮助。\n\n以下是 ArgoCD 为 Kubernetes 应用程序部署提供的一些帮助：\n\n1. **声明式配置**：ArgoCD 使用声明式方式定义应用程序的预期状态，并将应用程序配置存储在 Git 存储库中。通过版本控制和持续集成\/持续交付 (CI\/CD) 流程，可以轻松跟踪和管理应用程序配置更改。\n2. **持续部署**：ArgoCD 可以监控 Git 存储库中的配置变化，并自动将应用程序部署到 Kubernetes 环境。提供可定制的同步策略，自动触发应用部署和更新，实现持续部署。\n3. **状态比较和自动修复**：ArgoCD 定期检查应用程序的当前状态并将其与预期状态进行比较。如果发现不一致，它会自动尝试修复并将应用程序恢复到所需状态，以确保预期状态与实际状态的一致性。\n4. **多环境管理**：ArgoCD 支持管理多个 Kubernetes 环境，例如开发、测试和生产环境。可以轻松地在不同环境之间部署和同步应用配置，确保一致性和可控性。\n\n与 Deployment 资源对象相比，ArgoCD 提供了更高级的功能和工作流程，补充了原生 Kubernetes 资源对象的功能：\n\n- **基于 GitOps 的配置管理**：ArgoCD 将应用程序配置存储在 Git 存储库中，从而实现基于 GitOps 的配置管理。这种方法确保配置更改是可跟踪、可审计的，并且可以与现有的 CI\/CD 管道集成。\n\n- **自动化部署和持续交付**：ArgoCD 可以自动检测 Git 存储库中的配置更改并将应用程序部署到 Kubernetes 环境，从而实现自动化部署和持续交付。\n\n- **状态管理和自动恢复**：ArgoCD 持续监控应用程序的状态并将其与预期状态进行比较。如果检测到不一致，它会自动恢复并确保应用程序状态与预期状态保持一致。\n\n## 使用 Istio 实现细粒度的流量路由 {#istio-routing-traffic}\n\n虽然 ArgoCD 可以实现 GitOps，但它本质上是在 Kubernetes 部署上运行并通过副本数量控制流量路由。为了实现细粒度的流量路由，使用了 Istio 等服务网格。\n\nIstio 通过以下方法实现更细粒度的流量路由和应用发布：\n\n**VirtualService**：Istio 使用 VirtualService 来定义流量路由规则。通过配置 VirtualService，可以根据请求头、路径、权重等请求属性对流量进行路由和分发，将请求定向到不同的服务实例或版本。\n\n**DestinationRule**：Istio 的 DestinationRule 用于定义服务版本策略和负载均衡设置。通过指定不同版本服务实例之间不同的流量权重，可以实现金丝雀发布、蓝绿部署等高级应用发布策略。\n\n**流量控制和策略**：Istio 提供了丰富的流量控制和策略能力，如流量限制、故障注入、超时设置、重试机制等，这些功能帮助应用程序实现更高级别的负载均衡、容错和可靠性要求。\n\n与 ArgoCD 和 Kubernetes Deployment 对象相比，Istio 在应用部署方面提供了以下优势：\n\n**细粒度的流量路由控制**：Istio 提供了更丰富的流量路由能力，可以根据多种请求属性进行灵活的路由和分发，从而实现更细粒度的流量控制和管理。\n\n**高级发布策略支持**：Istio 的 DestinationRule 可以指定不同版本服务实例之间的流量权重，支持金丝雀发布、蓝绿部署等高级应用发布策略。这使得应用程序的版本管理和发布更加灵活可控。\n\n**强大的流量控制和策略能力**：Istio 提供了丰富的流量控制和策略能力，如流量限制、故障注入、超时设置、重试机制等，这些功能帮助应用程序实现更高级别的负载均衡、容错和可靠性要求。\n\n将 Istio 与 Argo Rollouts 相结合，可以充分发挥 Istio 细粒度流量路由的优势。现在让我们一起进行演示。在我们的演示中，我们将使用 TSE 提供的 Kubernetes 和 Istio 环境，使用 ArgoCD 实现 GitOps，并使用 Argo Rollouts 实现金丝雀发布。\n\n## Demo\n\n我们的演示中使用的软件版本是：\n\n-  Kubernetes v1.24.14\n-  Istio v1.15.7\n-  Argo CD v2.7.4\n-  Argo 发布 v1.5.1\n-  TSE Preview 2\n\n我们将使用 Istio 的 VirtualService 和 DestinationRule 来实现基于 Subset 的流量分组路由，并使用 ArgoCD Rollouts 进行渐进式发布。\n\n### 部署 ArgoCD 和 Argo Rollouts {#deployment-argocd-and-rollouts}\n\n我提前创建了一个 Kubernetes 集群并将其添加到 TSE 中，TSE 会自动为集群安装 Istio 控制平面。我们还需要安装 ArgoCD 和 Argo Rollouts：\n\n\u0060\u0060\u0060bash\n# Install ArgoCD\nkubectl create namespace argocd\nkubectl apply -n argocd -f https:\/\/raw.githubusercontent.com\/argoproj\/argo-cd\/stable\/manifests\/install.yaml\n\n# Install ArgoCD CLI on macOS\nbrew install argocd\n\n# Change the service type of argocd-server to LoadBalancer\nkubectl patch svc argocd-server -n argocd -p \u0027{\u0022spec\u0022: {\u0022type\u0022: \u0022LoadBalancer\u0022}}\u0027\n\n# Get the ArgoCD UI address\nARGOCD_ADDR=$(kubectl get svc argocd-server -n argocd -o jsonpath=\u0027{.status.loadBalancer.ingress[0].hostname}\u0027)\n\n# Login using ArgoCD CLI, see https:\/\/argo-cd.readthedocs.io\/en\/stable\/getting_started\/#4-login-using-the-cli to get password\nargocd login $ARGOCD_ADDR --skip-test-tls --grpc-web --insecure\n\n# Install Argo Rollouts\nkubectl create namespace argo-rollouts\nkubectl apply -n argo-rollouts -f https:\/\/github.com\/argoproj\/argo-rollouts\/releases\/download\/latest\/install.yaml\n\n# Install rollouts plugin on macOS\ncurl -LO https:\/\/github.com\/argoproj\/argo-rollouts\/releases\/download\/v1.5.0\/kubectl-argo-rollouts-darwin-amd64\nchmod \u002bx .\/kubectl-argo-rollouts-darwin-amd64\nsudo mv .\/kubectl-argo-rollouts-darwin-amd64 \/usr\/local\/bin\/kubectl-argo-rollouts\n\u0060\u0060\u0060\n\n该功能不适用于 TSE Bridge Mode，因此我们将使用 TSE Direct Mode 来实现渐进式发布。\n\n{{\u003ccallout note \u0022💡什么是桥接模式和直接模式？\u0022\u003e}}\n\n\n直接模式和桥接模式是 TSE 中控制平面下发配置的两种模式。适用于流量、安全、网关组配置模式。BRIDGED 模式是一种极简模式，允许用户使用 Tetrate 特定的 API 快速配置服务网格中最常用的功能，而 DIRECT 模式为高级用户提供更大的灵活性，允许他们直接使用 Istio API 进行配置。\n\n{{\u003c\/callout\u003e}}\n\n接下来，部署 Rollouts Dashboard：\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/argoproj\/argo-rollouts.git\nkustomize build manifests\/dashboard-install|kubectl apply -n argo-rollouts -f -\nkubectl port-forward svc\/argo-rollouts-dashboard -n argo-rollouts 3100:3100\n\u0060\u0060\u0060\n\n您现在可以通过 \u003chttps:\/\/localhost:3100\/rollouts\/\u003e 访问 Rollouts 仪表板。\n\n### 部署 Bookinfo 应用 {#bookinfo}\n\n我们已经为 Bookinfo 应用程序准备了配置文件（保存在 [tse-gitops-demo](https:\/\/github.com\/tetrateio\/tse-gitops-demo\/) 存储库中），您也可以将其 fork 到您自己的帐户并将其替换为您自己的存储库。运行以下命令来部署 Bookinfo 应用程序：\n\n\u0060\u0060\u0060bash\nargocd app create bookinfo-app --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path application --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated\n\u0060\u0060\u0060\n\n注意：我们在 [\u0060reviews\u0060 部署](https:\/\/github.com\/tetrateio\/tse-gitops-demo\/blob\/main\/application\/bookinfo.yaml#L151)中将 \u0060replicas\u0060 设置为 \u00600\u0060 ，因为我们将创建 Argo Rollouts 来操纵 \u0060reviews\u0060 的实例数量服务。如果这里设置为非零正整数，我们将无法实现金丝雀部署。\n\n现在您可以在浏览器中打开 ArgoCD UI，如图 4 所示。\n\n![图 4：ArgoCD 用户界面](f4.png)\n\n如果您发现应用程序状态不同步，可以运行以下命令或单击 UI 中的 SYNC 按钮。\n\n\u0060\u0060\u0060bash\nargocd app sync bookinfo-app\n\u0060\u0060\u0060\n\n## 使用 Istio 实施细粒度流量管理 {#istio-fine-grain-traffic-management}\n\n首先，我们使用 Argo CD 创建 Istio 相关的资源对象：\n\n\u0060\u0060\u0060bash\nargocd app create bookinfo-tse-conf --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path argo\/tse --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated --self-heal\n\n# Check the creation status\nargocd app get bookinfo-tse-conf\n\u0060\u0060\u0060\n\n### 将 Deployment 转换为 Rollout {#convert-deployment-to-rollout}\n\n假设我们要发布新版本的 \u0060reviews\u0060 服务。为了实现零停机更新，我们将使用金丝雀部署，具体步骤如下：\n\n1. 将 \u0060reviews\u0060 Deployment 的 \u0060replicas\u0060 减少为 0；\n2. 创建引用先前在 Bookinfo 应用程序中部署的 \u0060reviews\u0060 Deployment 的 Rollout；\n3. 将流量发送到 \u0060reviews\u0060 服务以实现自动金丝雀部署进度。\n\n您可以在 GitHub 上查看本演示中使用的 Rollout 和 AnalysisTemplate 配置。运行以下命令来部署 \u0060reivews-rollout\u0060 ：\n\n\u0060\u0060\u0060bash\nargocd app create reviews-rollout --repo https:\/\/github.com\/tetrateio\/tse-gitops-demo.git --path argo\/rollout --dest-server https:\/\/kubernetes.default.svc --dest-namespace bookinfo --sync-policy automated\n\u0060\u0060\u0060\n\n注意：我们可以使用 \u0060argocd\u0060 命令来部署或使用 \u0060kubectl apply\u0060 。推荐使用 \u0060argocd\u0060 ，因为您可以同时在 ArgoCD UI 和 Argo Rollouts Dashboard 中查看部署状态，并使用 \u0060argocd\u0060 命令管理部署。\n\n在 Argo Rollouts Dashboard 中查看 \u0060reviews\u0060 部署的状态，并使用以下命令将流量发送到 \u0060reviews\u0060 服务一段时间：\n\n\u0060\u0060\u0060bash\nexport GATEWAY_HOSTNAME=$(kubectl -n bookinfo get service tsb-gateway-bookinfo -o jsonpath=\u0027{.status.loadBalancer.ingress[0].hostname}\u0027)\nwhile 1;do curl -H \u0022Host: bookinfo.tetrate.com\u0022 http:\/\/$GATEWAY_HOSTNAME\/api\/v1\/products\/1\/reviews;sleep 3;done\n\u0060\u0060\u0060\n\n您将在输出中看到来自具有不同 rollouts-pod-template-hash 标签的 pod 的响应，这证明金丝雀部署是有效的。大约 10 分钟后，您看到的 Argo Rollouts 仪表板将如图 5 所示。\n\n![图 5：Argo Rollouts 仪表板](f5.png)\n\n从图 5 中我们可以看到金丝雀部署进展顺利，已经到了第三步。这是因为 \u0060reviews\u0060 服务的 \u0060apdex\u0060 （应用性能指数）指标正常。您可以[使用 Postman 向 SkyWalking 提交 GraphQL 查询](https:\/\/tetrate.io\/blog\/how-to-use-graphql-to-query-observability-data-from-skywalking-with-postman\/)来验证这一点，如图 6 所示。\n\n![图 6：使用 Postman 将 GraphQL 查询提交到 SkyWalking](f6.png)\n\n我们构建的 GraphQL 查询语句如下：\n\n\u0060\u0060\u0060graphql\nquery ReadMetricsValues {\n    readMetricsValues(condition: {\n    name: \u0022service_apdex\u0022, entity: {scope: Service, serviceName: \u0022canary|reviews|bookinfo|cluster-1|-\u0022, normal: true}\n  }, duration: {\n    start: \u00222023-07-13 0812\u0022,\n    end: \u00222023-07-13 0813\u0022,\n    step: MINUTE\n  }) {\n        label\n        values {\n            values {\n                id\n                value\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n该语句从 UTC \u00602023-07-13 8:12\u0060 到 \u00602023 8:13\u0060 查询 \u0060canary|reviews|bookinfo|cluster-1|-\u0060 服务的 \u0060apdex\u0060 指标，持续两分钟，得到以下结果：\n\n\u0060\u0060\u0060json\n{\n    \u0022data\u0022: {\n        \u0022readMetricsValues\u0022: {\n            \u0022label\u0022: null,\n            \u0022values\u0022: {\n                \u0022values\u0022: [\n                    {\n                        \u0022id\u0022: \u0022service_apdex_202307130812_Y2FuYXJ5fHJldmlld3N8Ym9va2luZm98Y2x1c3Rlci0xfC0=.1\u0022,\n                        \u0022value\u0022: 10000\n                    },\n                    {\n                        \u0022id\u0022: \u0022service_apdex_202307130813_Y2FuYXJ5fHJldmlld3N8Ym9va2luZm98Y2x1c3Rlci0xfC0=.1\u0022,\n                        \u0022value\u0022: 10000\n                    }\n                ]\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n\u0060apdex\u0060 指标的值大于 9900（AnalysisTemplate 的 \u0060successCondition\u0060 中配置的阈值），因此 Rollouts 会顺利进行。您还可以在 Argo Rollouts Dashboard 上单击“手动升级”来升级它，或运行以下命令：\n\n\u0060\u0060\u0060bash\nkubectl argo rollouts promote reviews-rollout -n bookinf\n\u0060\u0060\u0060\n\n## 清理 {#clean-up}\n\n删除已部署的 ArgoCD 应用程序和 Rollout：\n\n\u0060\u0060\u0060bash\nargocd app delete -y reviews-rollout\nargocd app delete -y bookinfo-tse-conf\nargocd app delete -y bookinfo-app\n\u0060\u0060\u0060\n\n## Argo Rollouts 原理 {#rollouts-principle}\n\n与 Istio 集成时，Argo Rollouts 支持基于 VirtualService 和 Subset 的流量拆分，如图 7 所示。\n\n![图 7：Argo Rollouts 使用 Istio 进行流量分配](f7.svg)\n\n下表提供了这两种流量分段方法的详细比较。\n\n| 类型           | 适用场景                             | 资源对象                                          | 原则                                                         |\n| :------------- | :----------------------------------- | :------------------------------------------------ | :----------------------------------------------------------- |\n| 主机级流量分割 | 适用于根据主机名访问不同版本的服务； | 2 个服务、1 个虚拟服务、1 个部署；                | Rollout 将 rollouts-pod-template-hash 标签注入到 ReplicaSet 中，并通过更新 Service 中的选择器来选择带有这些标签的 pod； |\n| 子集级流量分割 | 适用于根据标签访问不同的服务；       | 1 个服务、1 个虚拟服务、1 个目标规则和 1 个转出； | Rollout 将 rollouts-pod-template-hash 标签注入到 ReplicaSet 中，并通过更新 DestinationRule 中的选择器来选择具有这些标签的 pod； |\n\n本演示中使用基于子集的流量分割，Argo 不断推出：\n\n- 修改 VirtualService \u0060spec.http[].route[].weight\u0060 以匹配当前所需的金丝雀权重\n- 修改 DestinationRule \u0060spec.subsets[].labels\u0060 以包含 canary 和稳定 ReplicaSet 的 \u0060rollouts-pod-template-hash\u0060 标签\n\n请访问 [Argo Rollouts 文档](https:\/\/argo-rollouts.readthedocs.io\/en\/stable\/features\/traffic-management\/istio\/)，了解有关使用 Istio 进行流量管理的详细信息。\n\n## 总结 {#summary}\n\n本文介绍如何使用 Argo 项目和 Istio 实现 GitOps 和金丝雀部署。首先我们使用 ArgoCD 实现 GitOps，然后使用 Argo Rollout 和 SkyWalking 实现自动化金丝雀发布。从 demo 中我们可以看到 TSE 部署的 Istio 与开源版本完全兼容。TSE 有许多功能值得探索，请访问 [Tetrate 网站](https:\/\/tetrate.io\/tetrate-service-express\/)了解更多信息。\n', '\/blog\/implementing-gitops-and-canary-deployment-with-argo-project-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论如何使用 Kubernetes Deployment、Argo 项目和 Istio 来实现 GitOps 和金丝雀部署。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/demystifying-the-load-balancing-in-istio/">Istio 中的负载均衡详解及多集群路由实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的负载均衡详解及多集群路由实践', 'Istio 负载均衡详解尤其是多集群如何实现路由与负载均衡的，并给出一个多集群路由的演示。', '\n{{\u003ccallout note 编者按\u003e}}\n\n本文介绍了 Istio 中支持的负载均衡类型，然后提出多集群网格负载均衡的解决方案。如果您已经了解 Istio 中负载均衡，可以直接从[多集群网格中的负载均衡](#multicluster)部分开始阅读。\n\n{{\u003c\/callout\u003e}}\n\n在之前的博客[为什么在使用了 Kubernetes 后你可能还需要 Istio](\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/) 中提到 Istio 是在 Kubernetes 的基础之上构建起来的，Kubernetes 中的组件 kube-proxy 本身已有负载均衡功能，但是只支持四层流量的负载均衡，而且无法实现服务超时、熔断等高级功能。具体来说，服务网格比起 Kubernetes 新增了以下负载均衡及韧性（Resiliency）特性：\n\n1. **Layer 7 负载均衡**：服务网格在应用层（Layer 7）操作和管理流量，可以更细粒度地识别和控制流量。这使得它可以实现更高级的负载均衡策略，如基于 HTTP 请求头、URL 路径、Cookie 等的路由和流量分发。\n\n2. **动态负载均衡**：服务网格通常具备自动负载均衡的能力，可以根据后端服务的实时健康状态和性能指标来动态分发流量。这允许它实现智能负载均衡策略，将流量路由到性能最佳的服务实例。\n\n3. **故障检测和自动故障转移**：服务网格具备高级的故障检测和自动故障转移功能。它可以检测到后端服务实例的故障，并自动将流量从故障实例转移到健康实例，以确保应用程序的可用性。\n\n4. **A\/B 测试和金丝雀发布**：服务网格允许实施高级部署策略，如 A\/B 测试和金丝雀发布。这些策略允许在不同的服务版本之间动态分配流量，并根据结果进行决策。\n\n5. **熔断和重试**：服务网格通常包含熔断和重试机制，以提高应用程序的可用性和稳定性。它可以根据后端服务的性能和可用性情况来自动执行熔断操作，并在必要时重试请求。\n\n6. **全局流量控制**：服务网格提供了集中式的流量控制和策略定义，允许对整个服务网格中的流量进行全局管理。这使得实现统一的安全性、监控和策略成为可能。\n\n7. **深度集成的监控和追踪**：服务网格通常集成了强大的监控和追踪工具，可以提供有关流量性能和可见性的详细信息，帮助进行故障排除和性能优化。\n\n虽然 Kubernetes 提供了基本的负载均衡能力，但服务网格在其之上构建了更高级的负载均衡和流量管理功能，以满足微服务架构中复杂的需求。\n\n### 客户端负载均衡 vs 服务端负载均衡\n\n客户端负载均衡和服务端负载均衡是两种不同的负载均衡方法，它们在不同的场景和应用中有各自的优势。以下是对它们的解释，适用的场景，实现案例以及相关的开源项目：\n\n**客户端负载均衡（Client-Side Load Balancing）**\n\n客户端负载均衡的示意图如图 1 所示。\n\n![图 1：客户端负载均衡](client-side-load-balancing.svg)\n\n- **定义**：在客户端负载均衡中，负载均衡决策是由服务的消费者（客户端）来做出的。客户端负载均衡器通常会维护一个服务实例列表，并根据配置和策略选择要发送请求的实例。\n\n- **适用场景**：客户端负载均衡适用于以下情况：\n  - 多个客户端需要访问同一组后端服务，每个客户端可以根据自己的需求和策略选择后端服务。\n  - 服务消费者需要更多的流量控制和策略定义，例如 A\/B 测试、金丝雀发布等。\n\n- **实现案例**：常见的实现客户端负载均衡的开源项目包括：\n  - **Ribbon**：Netflix Ribbon 是一个用于客户端负载均衡的开源项目，它可以与 Spring Cloud 集成。\n  - **Envoy**：Envoy 是一个高性能的代理服务器，支持客户端负载均衡，广泛用于服务网格和微服务架构中。\n  - **NGINX**：虽然 NGINX 通常用于反向代理，但也可以用作客户端负载均衡器。\n\n**服务端负载均衡（Server-Side Load Balancing）**\n\n服务端负载均衡如图 2 所示。\n\n![图 2：服务端负载均衡](server-side-load-balancing.svg)\n\n- **定义**：在服务端负载均衡中，负载均衡决策是由服务端的负载均衡器或代理来做出的。客户端只需将请求发送到服务端，然后服务端决定将请求路由到哪个后端服务实例。\n\n- **适用场景**：服务端负载均衡适用于以下情况：\n  - 客户端不关心后端服务的具体实例，只关心发送请求到服务的名称或地址。\n  - 负载均衡策略需要在服务端进行全局配置，客户端不需要关心负载均衡细节。\n\n- **实现案例**：常见的实现服务端负载均衡的开源项目包括：\n  - **NGINX**：NGINX 可以用作反向代理服务器，执行服务端负载均衡，将请求路由到后端服务。\n  - **HAProxy**：HAProxy 是一种高性能的负载均衡器，通常用于服务端负载均衡。\n  - **Amazon ELB（Elastic Load Balancer）**：亚马逊提供的负载均衡服务，用于将请求路由到 AWS 后端服务实例。\n\n在实际应用中，有时也会将客户端负载均衡和服务端负载均衡结合使用，以满足特定的需求。选择哪种负载均衡方法通常取决于您的架构、部署需求以及性能要求。服务网格（如 Istio）通常使用客户端负载均衡来实现细粒度的流量控制和策略定义，而在云服务提供商中，服务端负载均衡通常用于自动扩展和流量管理。\n\n### Istio 如何实现负载均衡 {#how-istio-do-lb}\n\n在服务网格（如 Istio）中，客户端负载均衡通常是通过 Envoy 代理实现的。Envoy 是一个高性能的代理服务器，它可以用于构建服务网格的数据平面，用于处理服务之间的通信。客户端负载均衡是一种在服务消费者（客户端）一侧实现的负载均衡策略，它决定了请求应该如何路由到后端服务实例。\n\n单集群单网络 Istio 服务网格的负载均衡如图 3 所示。\n\n![图 3：单集群单网络的 Istio 服务网格的负载均衡](istio-load-balancing.svg)\n\n以下是服务网格中如何实现客户端负载均衡的一般流程：\n\n1. **Sidecar 代理**: 在服务网格中，每个部署的服务实例通常都与一个 Sidecar 代理（通常是 Envoy）关联。这个 Sidecar 代理位于服务实例旁边，负责处理该服务实例的入站和出站流量。\n\n2. **服务注册与发现**: 在服务网格中，服务实例的注册和发现通常由服务注册表（Kubernetes 的服务发现机制）处理。这些注册表维护了服务实例的信息，包括它们的网络地址和健康状态。\n\n3. **客户端负载均衡配置**: 在客户端（服务消费者）发送请求时，Sidecar 代理会执行负载均衡策略。这些负载均衡策略通常在服务注册表中获取的服务实例列表上操作。策略可以基于多种因素进行选择，例如权重、健康状态、延迟等。\n\n4. **请求路由**: 根据负载均衡策略，Sidecar 代理将请求路由到选择的后端服务实例。这可以包括使用轮询、加权轮询、最少连接等算法来选择目标实例。\n\n5. **通信处理**: 一旦选择了目标实例，Sidecar 代理将请求转发给该实例，然后将响应传回给客户端。它还可以处理连接管理、故障检测和自动故障转移等任务。\n\n总之，客户端负载均衡是在服务消费者一侧（通常是 Envoy 代理）实现的负载均衡策略，它使服务网格能够有效地分发流量并处理后端服务实例的故障。这种方式使得负载均衡决策在服务消费者的控制下，并允许更精细的流量控制和策略定义。Envoy 代理是实现客户端负载均衡的关键组件之一，它具有丰富的配置选项，可用于满足不同的负载均衡需求。\n\n## Istio 中的负载均衡类型 {#lb-types}\n\n在 Istio 的[DestinationRule](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/)资源中，\u0060loadBalancer\u0060部分用于配置负载均衡策略，控制请求如何分发到不同的服务实例或版本，如下图所示。\n\n![图 4：Istio 中的负载均衡配置参数](istio-loadbalancer.svg)\n\n从图中我们可以看出，Istio 支持三种类型的负载均衡，分别是：\n\n- \u0060simple\u0060：基于常用负载均衡算法的简单负载均衡\n- \u0060consistentHashLB\u0060：基于一致性哈希算法的负载均衡\n- \u0060localityLbSetting\u0060：基于地域的本地性负载均衡\n\n以下是与负载均衡配置相关的字段的含义：\n\n1. **simple**：这个部分定义了一些简单的负载均衡策略选项，其中包括以下选项：\n   - **ROUND_ROBIN**：请求会依次分发到所有可用的后端实例，以轮询的方式。\n   - **LEAST_CONN**：请求将路由到当前连接数最少的后端实例。\n   - **RANDOM**：请求将随机路由到后端实例。\n   - **PASSTHROUGH**：Istio 不会进行负载均衡，而是将请求直接路由到服务的一个实例，适用于特定用例。\n2. **consistentHashLB**：这个部分允许你配置一致性哈希负载均衡，其中包括以下字段：\n   - **httpHeaderName**：用于哈希计算的 HTTP 标头的名称。\n   - **httpCookie**：用于哈希计算的 HTTP Cookie 的配置，包括名称、路径和生存时间（TTL）。\n   - **useSourceIp**：是否使用请求的源 IP 地址进行哈希计算。\n   - **httpQueryParameterName**：用于哈希计算的 HTTP 查询参数的名称。\n   - **ringHash**：配置环形哈希负载均衡，包括最小环大小（minimumRingSize）。\n   - **maglev**：配置 Maglev 负载均衡，包括表格大小（tableSize）和最小环大小（minimumRingSize）。\n3. **localityLbSetting**：这个部分用于配置本地性负载均衡设置，其中包括以下字段：\n   - **distribute**：定义了请求的分布，包括起始位置（from）和结束位置（to）。\n   - **failover**：定义了故障切换，包括起始位置（from）和结束位置（to）。\n   - **failoverPriority**：故障切换的优先级设置。\n   - **enabled**：是否启用本地性负载均衡。\n\n这些字段允许你根据你的需求选择适当的负载均衡策略，并配置额外的选项，以确保请求按照所需的方式分发到后端服务实例。不同的策略和配置选项可以满足各种负载均衡需求，如性能、可靠性和流量控制。关于这些字段的详细介绍请见 [Istio 文档](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/)。\n\n## 如何在 Istio 中为服务设置负载均衡 {#istio-lb}\n\n正如我在[如何理解 Istio 中的 VirtualService 和 DestinationRule](\/blog\/understand-istio-vs-and-dr\/)这篇文章中所说的，\u0060VirtualService\u0060 主要用于设置路由规则，而服务弹性（负载均衡、超时、重试、熔断等）需要靠它和 DestinationRule 来共同维持。只有同时部署了以上两种资源，负载均衡才能真正生效。\n\n以下是设置负载均衡的一般步骤：\n\n1. **创建 DestinationRule 资源**：首先，你需要创建一个 DestinationRule 资源，该资源定义了服务的流量策略和目标规则。在 DestinationRule 中，你可以指定要设置负载均衡的服务的名称（host）以及负载均衡策略。\n\n   以下是一个 DestinationRule 的示例，其中将流量分发到具有标签 \u0022version: v1\u0022 和 \u0022version: v2\u0022 的两个子集中，并使用 \u0060ROUND_ROBIN\u0060 负载均衡策略：\n\n   \u0060\u0060\u0060yaml\n   apiVersion: networking.istio.io\/v1alpha3\n   kind: DestinationRule\n   metadata:\n     name: my-destination-rule\n   spec:\n     host: my-service.example.com\n     trafficPolicy:\n       loadBalancer:\n         simple: ROUND_ROBIN\n     subsets:\n       - name: v1\n         labels:\n           version: v1\n       - name: v2\n         labels:\n           version: v2\n   \u0060\u0060\u0060\n\n2. **应用 DestinationRule**：创建 DestinationRule 后，将其应用于要进行负载均衡的服务。这通常可以通过 Istio 的 VirtualService 资源来完成，通过在 VirtualService 中引用 DestinationRule。\n\n   以下是一个 VirtualService 示例，将流量引导到名为 \u0022my-destination-rule\u0022 的 DestinationRule：\n\n   \u0060\u0060\u0060yaml\n   apiVersion: networking.istio.io\/v1alpha3\n   kind: VirtualService\n   metadata:\n     name: my-virtual-service\n   spec:\n     hosts:\n       - my-service.example.com\n     http:\n       - route:\n           - destination:\n               host: my-service.example.com\n               subset: v1\n         weight: 80\n       - route:\n           - destination:\n               host: my-service.example.com\n               subset: v2\n         weight: 20\n   \u0060\u0060\u0060\n\n   在上面的示例中，根据权重配置，80% 的流量将路由到子集 v1，而 20% 的流量将路由到子集 v2。\n\n3. **应用配置**：最后，将 VirtualService 和 DestinationRule 资源应用到你的 Istio 环境中，以确保负载均衡规则生效。\n\n   使用 kubectl 命令将 VirtualService 和 DestinationRule 应用到 Istio 中：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f your-service.yaml\n   \u0060\u0060\u0060\n\n通过这些步骤，你可以为你的服务设置负载均衡策略，根据需要将流量分发到不同的服务版本或实例，并控制流量的权重。这有助于实现诸如金丝雀发布、A\/B 测试和灰度发布等部署策略。请根据你的具体需求和环境调整负载均衡配置。\n\n### 为什么要分开配置？{#devide}\n\n在 Istio 中，负载均衡和路由是两个不同的概念，它们通常用于控制服务之间的流量和行为，因此通常分别配置在两个不同的资源对象中：\u0060DestinationRule\u0060 用于负载均衡，\u0060VirtualService\u0060 用于路由。这种分离的设计有一些优点：\n\n1. **模块化和清晰性：** 将负载均衡和路由配置分离成两个资源对象可以使配置更加模块化和清晰。这样，您可以更容易地理解和维护这两个方面的配置，而不会使配置对象过于复杂。\n\n2. **可维护性：** 将负载均衡和路由配置分开可以使它们更容易维护和修改，因为它们位于不同的资源对象中。这样，您可以针对不同的需求更改负载均衡策略而不会影响路由规则，反之亦然。\n\n3. **可重用性：** 模块化的配置允许您更容易地重用配置片段。您可以在不同的 \u0060DestinationRule\u0060 或 \u0060VirtualService\u0060 中使用相同的负载均衡策略或路由规则，以提高配置的可重用性。\n\n4. **精细控制：** 分离的配置允许您对每个方面进行更精细的控制。您可以根据需要为每个服务定制不同的路由规则和负载均衡策略，以满足特定的用例和要求。\n\n虽然负载均衡和路由通常是分开配置的，但它们之间仍然存在紧密的关联，因为路由规则决定了请求将如何被路由到后端服务，而负载均衡策略决定了在所选目标服务之间如何分发流量。因此，在 Istio 中，这两个配置对象通常需要协同工作，以实现您的流量管理需求。通过将它们分开配置，使得配置更加清晰和可维护，并允许更灵活地满足不同的需求。\n\n## 多集群网格中的负载均衡 {#multicluster}\n\n在微服务领域，Istio 已被证明是管理服务通信的无价之宝。虽然它在单集群场景下表现出色，但多集群设置引入了独特的挑战，特别是在负载均衡方面。接下来我们将揭秘 Istio 中的多集群负载均衡，为您提供解决这一复杂任务的清晰路线图。\n\n### 两层入口网关：实现多集群通信的关键 {#two-tier-ingress-gateway}\n\n在涉及来自不同供应商的集群的多集群设置中，第一步是为每个集群建立一个网关。然而，需要特别注意的关键一点是需要一个唯一的用户访问入口点。尽管可以在同一集群中部署此网关，但通常建议将其放置在一个单独的集群中。\n\n两层入口网格的部署架构如图 4 所示。\n\n![图 4：两层入口网关](tier1-gw-listening.svg)\n\n### 多集群通信所需组件 {#components}\n\n基于 Istio 创建的多集群网格，通常是[多网格多网络模式](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)，为了让网格互通，我们需要添加一个一级（Tier-1）集群，并在每个集群中创建如下组件：\n\n1. **入口网关**：每个网格必须有一个入口网关。\n2. **ServiceEntry**：用于允许集群发现彼此的端点。\n3. **VirtualServices 和 DestinationRules**：对于每个集群内部的服务发现和路由至关重要。\n\n## 实战演示：一个多集群演示 {#demo}\n\n在这个演示中，我将涵盖三个 GKE 上的 Kubernetes 集群，分布在不同的区域，如图 5 所示。当然你也可以使用不同的供应商或者跨供应商。在每个集群中部署了 Istio，为多集群通信奠定了基础。\n\n建立了两层集群：一个专门托管 \u0060productpage\u0060 服务，另一个包含完整 [bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) 的服务套件。\n\n![图 5：演示环境的部署情况](init-infra.svg)\n\n### 实现多集群路由和负载均衡 {#multicluster-routing-and-lb}\n\n为了实现诸如负载均衡和故障转移等高级功能，解决多集群路由问题至关重要。由于一级集群也部署了 Istio，可以将先前讨论的负载均衡技巧应用于此网关。\n\n关键步骤：\n\n1. 在每个集群中创建入口网关，并获取网关使用的负载均衡器的 IP 地址。\n\n2. 在每个集群中创建 **VirtualServices、DestinationRules 和 ServiceEntries**。确保 ServiceEntries 包含每个集群入口网关的入口点。\n\n3. 为进一步的测试，**检索 Tier 1 网关的 IP 地址**。\n\n   \u0060\u0060\u0060bash\n   export GATEWAY_IP=$(kubectl -n tier1 get service tier1-gateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n   \u0060\u0060\u0060\n\n   注意：这一步需要在一级集群中操作。\n\n一级集群的网关作为统一网关入口，你可以通过在这个集群中配置 Gateway、VirtualService、DestinationRule 和 ServiceEntry 资源对象，实现多集群的路由，如图 6 所示。\n\n![图 6：一级集群中的 Istio 资源](istio-resources.svg)\n\n在这个演示中我们将实现基于 HTTP header 和 prefix 的多集群的路由，最终的路由路径如图 7 所示。\n\n![图 7：路由路径](final.svg)\n\n关于操作的细节可以参考 TSB 文档中的[统一网关](https:\/\/docs.tetrate.io\/service-bridge\/next\/howto\/gateway\/unified-gateway)。\n\n### 测试设置 {#test}\n\n演示继续进行实际测试，使用 \u0060curl\u0060 命令：\n\n1. 无需 HTTP 标头的请求 URL。\n\n   \u0060\u0060\u0060bash\n   curl -Ss \u0022http:\/\/bookinfo.tetrate.io\/productpage\u0022 --resolve \u0022bookinfo.tetrate.io:80:$GATEWAY_IP\u0022 -v \u003e index1.html\n   \u0060\u0060\u0060\n\n2. 使用指示首选集群的 HTTP 标头请求 URL。\n\n   \u0060\u0060\u0060bash\n   curl -Ss \u0022http:\/\/bookinfo.tetrate.io\/productpage\u0022 --resolve \u0022bookinfo.tetrate.io:80:$GATEWAY_IP\u0022 -v -H \u0022X-CLUSTER-SELECTOR: gke-jimmy-us-west1-1\u0022 \u003e index2.html\n   curl -Ss \u0022http:\/\/bookinfo.tetrate.io\/productpage\u0022 --resolve \u0022bookinfo.tetrate.io:80:$GATEWAY_IP\u0022 -v -H \u0022X-CLUSTER-SELECTOR: gke-jimmy-us-west1-2\u0022 \u003e index3.html\n   \u0060\u0060\u0060\n\n通过导出的 HTML 文件验证结果。在浏览器中分别打开 \u0060index1.html\u0060、\u0060index2.html\u0060 和 \u0060index3.html\u0060 这三个文件，你将看到页面 1 和页面 2 中都显示 reviews 和 details 服务不可用，只有页面 3 中的所有服务都可访问。\n\n### 多集群负载均衡 {#multicluster-lb}\n\n演示成功展示了如何利用 HTTP 标头和路径路由。路由是负载均衡的基础。实现了多集群路由之后，你就可以将来自二级（Tier-2）集群的端点添加到一个 subset 中，从而在 DestinationRule 中实现负载均衡配置。\n\n可以通过将二级集群中的入口网关配置为东西向网关，从而解决 Cluster 1 中的故障转移问题。请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)。\n\n### 自动化的呼声 {#automation}\n\n尽管 Istio 提供了基于 Envoy 的各种负载均衡类型，但手动在多个集群中创建资源对象容易出错且效率低下。自动化，最好是在 Istio 之上添加一个解释层，是下一个发展阶段。\n\nTetrate 使用 TSB 解决了这个需求，TSB 与上游的 Istio 兼容，为多集群部署提供了无缝的解决方案。有关更多信息，请访问 [Tetrate 网站](https:\/\/tetrate.io)。\n\n## 总结 {#summary}\n\n精通 Istio 中的多集群负载均衡对于在复杂环境中发挥微服务的全部潜力至关重要。通过谨慎的配置和合适的工具，您可以在集群之间实现强大且可靠的通信，确保您的应用程序无论部署在何处都能顺利运行。对于更精细的负载均衡调整，请考虑探索 EnvoyFilter。感谢您加入我们一起揭秘 Istio 中的多集群负载均衡之旅！\n\n## 参考 {#reference}\n\n- [Install Multi-Primary on different networks - istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Unified Gateway - docs.tetrate.io](https:\/\/docs.tetrate.io\/service-bridge\/next\/howto\/gateway\/unified-gateway)\n- [DestinationRule - istio.io](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/)\n', '\/blog\/demystifying-the-load-balancing-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Istio 负载均衡详解尤其是多集群如何实现路由与负载均衡的，并给出一个多集群路由的演示。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-use-graphql-to-query-observability-data-from-skywalking-with-postman/">如何使用 GraphQL 和 Postman 查询 SkyWalking 中的数据</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/07/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 GraphQL 和 Postman 查询 SkyWalking 中的数据', '本文介绍如何使用 GraphQL 从 SkyWalking 查询可观测性数据。它首先介绍了 GraphQL 和 SkyWalking，然后介绍了如何设置 Postman 发送 GraphQL 查询，最后提供了一些示例 GraphQL 查询，可用于从 SkyWalking 查询可观测性数据。', '\n在本文中，我将解释如何使用 [GraphQL 与](https:\/\/graphql.org\/)[Postman](https:\/\/www.postman.com\/) 一起从 [SkyWalking](https:\/\/skywalking.apache.org\/) 查询数据。它包括获取不记名令牌、构建查询以检索特定服务的负载指标以及使用 GraphQL 自省来查看 SkyWalking GraphQL API 架构的步骤。本文还提供了更多信息的参考。\n\n## 什么是 GraphQL？\n\nGraphQL 是 Facebook 开发的一种 API 查询语言和运行时。它允许客户端准确指定他们需要的数据并仅接收该数据作为响应，从而为传统 REST API 提供了更高效、更强大、更灵活的替代方案。使用 GraphQL，客户端可以在单个请求中查询多个资源，从而减少与服务器的往返次数并提高性能。\n\n## GraphQL 和 REST API 之间有什么区别？\n\nGraphQL 允许客户端仅请求他们需要的数据，而 REST API 要求客户端检索资源中的所有内容，无论他们是否需要。此外，GraphQL 允许客户端在单个请求中查询多个资源，这使其比 REST API 更高效、更简洁。\n\n## 如何查询 SkyWalking 数据？\n\nSkyWalking 定义了查询阶段的通信协议。SkyWalking 原生 UI 和 CLI 使用此协议从后端持续获取数据，无需担心后端更新。\n\n从 SkyWalking 查询指标有两种方法：\n\n1. [GraphQL API](https:\/\/skywalking.apache.org\/docs\/main\/v9.4.0\/en\/api\/query-protocol\/)\n2. [PromQL API](https:\/\/skywalking.apache.org\/docs\/main\/v9.4.0\/en\/api\/promql-service\/)\n\n本文提供了有关如何使用 GraphQL 从 SkyWalking 查询指标的指南。如果你对 PromQL API 感兴趣，可以参阅文章[为 Apache SkyWalking 构建 Grafana Dashboard - 原生 PromQL 支持](https:\/\/skywalking.apache.org\/zh\/2023-03-17-build-grafana-dashboards-for-apache-skywalking-native-promql-support\/) 。继续执行以下步骤需要安装 TSB。如果你没有，但仍想体验使用 GraphQL 在 SkyWalking 中查询数据，你可以使用 SkyWalking 提供的免费[演示环境](https:\/\/skywalking.apache.org\/)（用户名 \/ 密码：skywalking\/skywalking）。登录演示网站并获取查询令牌。GraphQL 查询的端点地址是 \u003chttp:\/\/demo.skywalking.apache.org\/graphql\u003e 。构造查询的步骤与下面描述的相同。\n\n## 观察 TSB 中的 GraphQL 查询\n\n在我们使用 Postman 构建自己的 GraphQL 查询之前，我们首先观察 TSB 如何从 SkyWalking 获取数据。\n\n1. 打开 Chrome DevTools 并切换到“Network”选项卡。\n2. 访问网站上的**Organization - Services** 选项卡。\n\n观察网络请求列表并右键单击其中一个 graphql 请求，如下图所示：\n\n![图 1：Chrome DevTool](f1.jpg)\n\n你看到的 curl 命令将如下所示。在终端中执行该命令，你将从 SkyWalking 中获取 TSB 管理的服务列表。\n\n\u0060\u0060\u0060bash\ncurl \u0027\u003chttps:\/\/saturn.tetrate.work\/ui\/graphql\u003e\u0027 \\\\\n  -H \u0027Accept-Language: en,zh-CN;q=0.9,zh;q=0.8,en-US;q=0.7,zh-TW;q=0.6\u0027 \\\\\n  -H \u0027Cache-Control: no-cache\u0027 \\\\\n  -H \u0027Client-Timestamp: 1686104776136\u0027 \\\\\n  -H \u0027Connection: keep-alive\u0027 \\\\\n  -H \u0027Content-Type: application\/json\u0027 \\\\\n  -H \u0027Cookie: ...\u0027 \\\\\n  -H \u0027Origin: \u003chttps:\/\/saturn.tetrate.work\u003e\u0027 \\\\\n  -H \u0027Pragma: no-cache\u0027 \\\\\n  -H \u0027Referer: \u003chttps:\/\/saturn.tetrate.work\/mp\/services\u003e\u0027 \\\\\n  -H \u0027Request-Id: ...\u0027 \\\\\n  -H \u0027Sec-Fetch-Dest: empty\u0027 \\\\\n  -H \u0027Sec-Fetch-Mode: cors\u0027 \\\\\n  -H \u0027Sec-Fetch-Site: same-origin\u0027 \\\\\n  -H \u0027User-Agent: Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/114.0.0.0 Safari\/537.36\u0027 \\\\\n  -H \u0027X-Bridge-Csrf-Token: IOmJszLAqY3TRIUNhTuGu7vQgnfQY1FtgYFm\u002bl\/\u002bMu4EmVQU5T8EaQ7bngkCv4hQ12ZGids\u002bI21pHMdepE9\/qQ==\u0027 \\\\\n  -H \u0027X-Csrf-Token: xTbxZerD3t8N3PaS7nbjKCfxk1Q9dtvvrx4D\u002bIJohHicb0VfB4iAZaP0zh1eXDWctQyCYZWaKLhAYT3M6Drk3A==\u0027 \\\\\n  -H \u0027accept: application\/json\u0027 \\\\\n  -H \u0027sec-ch-ua: \u0022Not.A\/Brand\u0022;v=\u00228\u0022, \u0022Chromium\u0022;v=\u0022114\u0022, \u0022Google Chrome\u0022;v=\u0022114\u0022\u0027 \\\\\n  -H \u0027sec-ch-ua-mobile: ?0\u0027 \\\\\n  -H \u0027sec-ch-ua-platform: \u0022macOS\u0022\u0027 \\\\\n  --data-raw $\u0027{\u0022query\u0022:\u0022query ServiceRegistryListMetrics(...)}\u0027 \\\\\n  --compressed\n\u0060\u0060\u0060\n\n**注意：** *上例中的某些字段太长，用点 (...) 替换*。\n\n接下来，我将指导你构建一个查询来检索特定服务的负载指标。\n\n## 获取 Bearer Token\n\n首先，你需要获取网站的 Bearer Token。登录到 TSB UI，点击右上角的用户按钮，然后点击“Show token information”。在弹出窗口中，你将看到 Bearer Token，如下图所示。\n\n![图 2：从 TSB UI 获取 Bear Token](f2.jpg)\n\n注意：Bearer token 的有效期比较短。当它过期时，你需要重新登录 TSB 以获取新的 token。\n\n我们已经预先部署了[bookinfo 应用程序](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)并发送了一些测试流量。要在 Postman 客户端中使用 GraphQL 查询\u0060reviews\u0060的负载指标，请执行以下步骤：\n\n1. 创建一个新的 GraphQL 请求，并输入请求 URL：\u0060$TSB_ADDRESS\/graphql\u0060\n2. 添加带有值\u0060Bearer $TOKEN\u0060的\u0060Authorization\u0060头\n3. 使用 GraphQL Introspection 查看 SkyWalking GraphQL APIs 的模式。查找并单击\u0060readMetricsValues\u0060项。你将在右侧看到变量。填写\u0060condition\u0060和\u0060duration\u0060项目，如下图所示。\n\n![图 3：Postman 查询](f3.jpg)\n\n变量如下：\n\n\u0060\u0060\u0060graphql\nquery ReadMetricsValues {\n    readMetricsValues(condition: {\n    name: \u0022service_cpm\u0022, entity: {scope: Service, serviceName: \u0022reviews\u0022, normal: true}\n  }, duration: {\n    start: \u00222023-06-05 0625\u0022,\n    end: \u00222023-06-05 0627\u0022,\n    step: MINUTE\n  }) {\n        label\n        values {\n            values {\n                id\n                value\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n单击 Query 按钮以获取结果。它应该类似于以下内容：\n\n\u0060\u0060\u0060json\n{\n    \u0022data\u0022: {\n        \u0022readMetricsValues\u0022: {\n            \u0022label\u0022: null,\n            \u0022values\u0022: {\n                \u0022values\u0022: [\n                    {\n                        \u0022id\u0022: \u0022service_cpm_202306050625_cmV2aWV3cw==.1\u0022,\n                        \u0022value\u0022: 0\n                    },\n                    {\n                        \u0022id\u0022: \u0022service_cpm_202306050626_cmV2aWV3cw==.1\u0022,\n                        \u0022value\u0022: 0\n                    },\n                    {\n                        \u0022id\u0022: \u0022service_cpm_202306050627_cmV2aWV3cw==.1\u0022,\n                        \u0022value\u0022: 0\n                    }\n                ]\n            }\n        }\n    }\n}\n\u0060\u0060\u0060\n\n以上是使用 SkyWalking Demo 环境测试 GraphQL 查询。TSE 也支持 GraphQL 查询，并且端点地址为\u0060$TSB_SERVER\/graphql\u0060。\n\n注意：此处的查询端点与 DevTool 中看到的不同。TSB UI 特定的 GraphQL 查询端点是\u0060$TSB_SERVER\/ui\/graphql\u0060。\n\n有关 SkyWalking GraphQL 查询协议的详细信息，请参见[GitHub](https:\/\/github.com\/apache\/skywalking-query-protocol\/tree\/master)。\n\n## 总结\n\n在本文中，我介绍了如何在 Postman 中使用 GraphQL 查询协议查询 SkyWalking 中的数据。你可以根据 SkyWalking 的 GraphQL 模式构建自己的查询条件。TSB \/ TSE 中也提供了此功能。\n', '\/blog\/how-to-use-graphql-to-query-observability-data-from-skywalking-with-postman\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍如何使用 GraphQL 从 SkyWalking 查询可观测性数据。它首先介绍了 GraphQL 和 SkyWalking，然后介绍了如何设置 Postman 发送 GraphQL 查询，最后提供了一些示例 GraphQL 查询，可用于从 SkyWalking 查询可观测性数据。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh/">使用 Geneve 隧道实现 Istio Ambient Mesh 的流量拦截</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/03/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Geneve 隧道实现 Istio Ambient Mesh 的流量拦截', '本文介绍了什么是 Geneve 隧道，与 VXLAN 的区别，以及它在 Istio Ambient Mesh 中的应用，最后谈及使用 eBPF 优化流量拦截。', '\n在我[之前的博客](\/blog\/ambient-mesh-l4-traffic-path\/)分享中提到 Istio Ambient Mesh 使用 iptables 和 Geneve 隧道将应用程序 Pod 中的流量拦截到 Ztunnel 中。很多读者可能还不了解这种隧道协议，本文将为你介绍 Geneve 隧道的定义，报文结构，以及与 VXLAN 协议的比较有哪些优势。最后，本文将介绍 Istio Ambient Mesh 如何应用 Geneve 隧道来实现流量拦截，以及 Istio 1.18 中新推出的 eBPF 模式。\n\n## Geneve 隧道简介\n\nGENEVE（Generic Network Virtualization Encapsulation）是一种网络虚拟化封装（隧道）协议，它的设计的初衷是为了解决当前数据传输缺乏灵活性和安全性的问题。Geneve 只定义了一种数据封装格式，不包括控制平面的信息。GENEVE 相较于 VXLAN 封装的关键优势在于其通过添加 TLV 格式的选项来扩展可封装的协议类型。\n\n## Geneve vs VXLAN\n\nVXLAN 和 Geneve 都是网络虚拟化协议，它们之间有很多共同点。虚拟化协议是一种将虚拟网络与物理网络分离的技术，它允许网络管理员在虚拟环境中创建多个虚拟网络，每个虚拟网络都可以拥有自己的 VLAN 标识符、IP 地址和路由。此外，VXLAN 和 Geneve 协议都使用 UDP 封装，这使得它们能够通过现有网络基础设施进行扩展。VXLAN 和 Geneve 协议还具有灵活性，它们可以在不同的网络拓扑结构中使用，并且可以与不同的虚拟化平台兼容。\n\n图 1 展示了 VXLAN 与 Geneve 协议的报文结构及其各自的 Header 区别。\n\n![图 1：VXLAN 与 Geneve 报文格式示意图](vxlan-vs-geneve.svg)\n\n从图中我们可以看到，VXLAN 与 Geneve 隧道报文的结构类似，其主要区别在于使用不同的 UDP 端口号和协议头 ——VXLAN 使用 4789 端口，Geneve 使用 6081 端口；Geneve 协议头比 VXLAN 更具扩展性。\n\nGeneve 隧道协议比 VXLAN 更加可扩展是因为 Geneve 隧道协议中增加了变长选项，它可以包含零或多个 TLV 格式的选项数据。TLV 是指类型 - 长度 - 值（Type-Length-Value）格式，用于传输和解析网络包的元数据信息。在 Geneve 协议中，每个元数据信息都由一个 TLV 格式的字段组成，以便于灵活地添加、删除和修改这些元数据。\n\n具体来说，TLV 格式的字段包括：\n\n- Type：8 位的类型字段。\n- Length：5 位的选项长度字段，以 4 字节倍数表示，不包括选项头。\n- Data：可变长的选项数据字段，可以不存在或者为 4 到 128 字节之间。\n\n通过使用 TLV 格式，Geneve 协议可以轻松地扩展和修改元数据信息，同时保持兼容性和灵活性。\n\n关于 VXLAN 隧道报文的详细信息请参考 [RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks](https:\/\/tools.ietf.org\/html\/rfc7348) 。\n\n关于 Geneve 隧道报文的详细信息请参考 [RFC 8926 Geneve: Generic Network Virtualization Encapsulation](https:\/\/www.rfc-editor.org\/rfc\/rfc8926#name-geneve-packet-format-over-i) 。\n\n### 工作原理\n\nGeneve 隧道主要应用在云计算和虚拟机化场景，它可以将数据包封装在一个新的数据包中，以便在虚拟网络中传输。Geneve 隧道使用一个 24 位的虚拟网络标识符 (VNI)，将数据包从一个物理网络传输到另一个物理网络。Geneve 隧道还可以使用安全性协议，如 IPsec、TL，来保护数据包的传输。\n\n当数据包到达目的主机时，Geneve 隧道协议会将数据包从 Geneve 协议头中解封装出来，并将其传递给虚拟网络中的目的地。在解封装过程中，Geneve 协议头中的 VNI 信息会被来判断数据包的目的地，以确保数据包被正确地路由到虚拟网络中的目的地。\n\n假设有一个虚拟网络，其 VNI 为 1001。当数据包从一个物理网络传输到另一个物理网络时，可以使用隧道将数据包从一个物理网络传输到另一个物理网络。在这种情况下，隧道将源物理网络和目标物理网络之间的虚拟网络标识符 (VNI) 设置为 1001，以便在传输期间跟踪数据包。当数据包到达目标物理网络时，隧道将 VNI 从数据包中删除，并将数据包传递给目标物理网络。\n\n### 安全性\n\nGeneve 隧道协议本身并没有提供任何安全机制，因此在 Geneve 隧道中传输的数据包可能会受到威胁，例如数据包被篡改、截获、重放等。\n\n为了保障 Geneve 隧道中传输的数据包的安全性，可以使用一些安全协议。以下是一些常见的安全协议：\n\n1. IPsec（Internet Protocol Security）：IPsec 是一种网络层安全协议，可以对 Geneve 隧道中的数据包进行加密、认证和完整性保护。使用 IPsec 可以提供端到端的安全性。\n2. TLS（Transport Layer Security）：TLS 是一种基于传输层的加密协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 TLS 可以提供端到端的安全性。\n3. MACSec（Media Access Control Security）：MACSec 是一种数据链路层的安全协议，可以对 Geneve 隧道中的数据包进行加密和认证。使用 MACSec 可以提供链路层的安全性。\n\n需要注意的是，以上安全协议都需要进行相应的配置和部署，且可能会对性能产生一定的影响。在选择合适的安全协议时，需要考虑安全性、性能、可管理性等方面的因素。\n\n### 为什么选择 Geneve？\n\n下表对比了 VXLAN 与 Geneve 在多个方面的特点。\n\n| 特性 | VXLAN | Geneve |\n| --- | --- | --- |\n| 头部格式 | 固定格式 | 可扩展格式 |\n| 可扩展性 | 更多地专注于 L2 扩展 | 更好地支持新兴网络服务 |\n| 可操作性 | 较难管理和扩展 | 更容易管理和扩展 |\n| 性能 | 头部较短，性能较高 | 头部较长，性能略低 |\n\n使用 Geneve 协议的主要原因是将目前网络虚拟化封装技术（例如 VXLAN、NVGRE 和 STT）中的优点合并到一个协议中。我们通过多年的网络虚拟化开发经验得知，其中一个重要的需求是可扩展性。Geneve 协议使用可扩展的 TLV 结构对元数据进行编码，因此可以独立地发展软件和硬件端点的功能，以满足不断增长的需求。\n\n## Istio Ambient Mesh 如何应用 Geneve 隧道\n\n在[之前的博客](https:\/\/jimmysong.io\/blog\/ambient-mesh-l4-traffic-path\/)中，我讲解了 Istio Ambient Mesh 如何使用 Ztunnel 实现 L4 代理的，图 2 展示使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径。\n\n![图 2：使用 iptables 和 Geneve 隧道的 L4 透明流量劫持路径示意图](geneve-tunnel.svg)\n\n从图中我们可以看到：\n\n- Istio CNI 在节点上创建 \u0060istioout\u0060 网卡和 iptables 规则，将节点中的出站流量透明劫持到 \u0060pistioout\u0060 虚拟网卡；\n- Istio CNI 在节点上创建 \u0060istioin\u0060 网卡和 iptables 规则，将节点中的入站流量透明劫持到 \u0060pistioin\u0060 虚拟网卡；\n- Istio CNI 在 ztunnel 中创建 \u0060pistioin\u0060 和 \u0060pistioout\u0060 网卡，用于接收 Geneve 隧道中的发来的数据包；\n\n\u0060pistioin\u0060 和 \u0060pistioout\u0060 这两个网卡是由 ztunnel 中的 init 容器或 Istio CNI（见 [\u0060CreateRulesWithinNodeProxyNS\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/ambient\/net_linux.go#L910) 函数）创建的，其 IP 地址和端口也是固定的。应用容器发出的数据包需要经过 \u0060istioout\u0060 网卡并使用 Geneve 隧道封装后转发给 ztunnel 容器。\n\n## 使用 eBPF 进行透明流量劫持\n\neBPF（extended Berkeley Packet Filter）是一个功能强大的技术，它可以在 Linux 内核中运行安全的用户态程序。eBPF 最初是一种用于过滤网络数据包的技术，但现在已经扩展到其他领域，如跟踪系统调用、性能分析和安全监控等。eBPF 的优势在于其轻量级、高效、安全和可编程性。它可以被用于实时监控、网络安全、应用程序调试和优化、容器网络等多个领域。\n\n在 Istio 1.18 之前，Ambient 模式中使用 iptables 和 Geneve 隧道将应用程序流量透明劫持到 ztunnel 中。在 Istio 1.18 中，增加了 eBPF 选项，你可以选择使用 iptables 或 eBPF 来做流量劫持。如图 3 所示，eBPF 程序直接运行在宿主机内核，将应用程序的流量转发到 ztunnel 中。\n\n![图 3：使用 eBPF 劫持应用程序的流量](ebpf.svg)\n\n图 3：使用 eBPF 劫持应用程序的流量\n\n| 对比项 | eBPF 方式 | 使用 iptables 和 Geneve 隧道 |\n| --- | --- | --- |\n| 效率 | 更高 | 略低 |\n| 兼容性 | 需要较高的 Linux 内核版本 | 更好 |\n| 实现难度 | 较高 | 较低 |\n| 扩展性 | 较好 | 较差 |\n\n根据 [Istio 官方博客](https:\/\/istio.io\/latest\/blog\/2023\/ambient-ebpf-redirection\/)介绍，使用 eBPF 方式避免了部分 iptables 规则和隧道封装，相比使用 iptables 和 Geneve 隧道更加高效。然而，eBPF 对 Linux 内核版本的要求更高（至少 4.20），而 iptables 方式则具有更好的兼容性。此外，eBPF 方式的实现难度较高，但扩展性较好。\n\n要想使用 eBPF 模式运行 Ambient Mesh，只需要在安装 Istio 时设置 \u0060values.cni.ambient.redirectMode\u0060 参数即可，如下：\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=ambient --set values.cni.ambient.redirectMode=\u0022ebpf\u0022\n\u0060\u0060\u0060\n\n## 总结\n\n本文介绍了 Geneve 隧道协议的工作原理、安全性和与 VXLAN 的比较。此外，还介绍了 Istio Ambient Mesh 如何使用 Geneve 隧道实现流量拦截，并讨论了使用 eBPF 进行透明流量劫持的优缺点。Geneve 隧道协议是一种通用的隧道协议，可以在虚拟网络中传输数据包，具有更多的优势，因此在选择隧道协议时，用户可以考虑使用 Geneve 隧道。在 Istio 1.18 中新推出了 Ambient Mesh 的的 eBPF 模式，可以提供网络效率，但对 Linux 内核版本有更高要求，用户可以根据自己的实际情况选用。\n\n## 参考\n\n- [RFC 7348 Virtual eXtensible Local Area Network (VXLAN): A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks](https:\/\/tools.ietf.org\/html\/rfc7348)\n- [RFC 8926 Geneve: Generic Network Virtualization Encapsulation](https:\/\/www.rfc-editor.org\/rfc\/rfc8926#name-geneve-packet-format-over-i)\n- [Istio Ambient Mesh](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/architecture\/#istio-ambient-mesh)\n- [Open vSwitch Geneve(8) man page](https:\/\/www.mankier.com\/8\/ovs-vswitchd.conf.db(5))\n', '\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了什么是 Geneve 隧道，与 VXLAN 的区别，以及它在 Istio Ambient Mesh 中的应用，最后谈及使用 eBPF 优化流量拦截。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ocsp-stapling-for-istio-gateways/">Istio Gateway 中对证书撤销的支持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/02/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Gateway 中对证书撤销的支持', '这篇博客将向你介绍证书撤销的方式和 Istio 的解决方案。', '\n最近 Istio 社区正在处理 [Issue 17763](https:\/\/github.com\/istio\/istio\/issues\/17763)，以增加 Istio 对证书撤销的支持，目前该功能正在开发工程中，见 [PR #42859 - OSCP Stapling](https:\/\/github.com\/istio\/istio\/pull\/42859) 和 [OCSP Stapling for Istio Gateways](https:\/\/docs.google.com\/document\/d\/15wwYyVyOluubL2KIM89b2X8NFwyhMVxq2_I1MESrZdI\/edit#)。这篇博客将向你介绍证书撤销的方式和 Istio 的解决方案进展。\n\nIstio 使用 Envoy SDS 分发证书，一共有两种情形：\n\n- 分发内部证书，用于 mTLS，这种情况需要分别验证客户端和服务端的证书是否被撤销\n- 分发外部服务的证书给集群内的服务，用于向集群外的通信加密，此时集群内的服务相当于客户端，仅需验证服务端证书是否被撤销\n\n本文探讨的是第二种情形，即 Istio Gateway 的证书撤销，如下图所示：\n\n![Istio Gateway 的证书撤销示意图](cert-revoke.svg)\n\nCA 通过设置 TTL 控制证书的寿命，如果要提前结束证书可以将证书撤销，有两种方式撤销证书：\n\n1. 配置证书撤销列表（CRL）\n2. 在线证书状态协议（OCSP）\n\n## CRL（证书撤销列表）\n\nCRL（证书吊销列表）是一种用于管理和验证证书有效性的机制。它包含一个已被撤销的证书列表，颁发机构（CA）定期更新该列表。当验证证书的客户端（如浏览器）收到证书时，它会检查该证书是否在 CRL 中被列为已撤销，如果是，则该证书被视为无效。\n\nCRL 通常存储在颁发机构（CA）的服务器上，并可以通过互联网公开访问。验证证书的客户端（例如，浏览器）可以下载并检查 CRL 以确定证书是否有效。CRL 可以以多种格式（如 DER 或 PEM）存储，并通过 HTTP，LDAP 或其他协议发布，以便进行验证。\n\nCRL 文件通常是以二进制形式存储的，不是直接可读的文本文件。但是，可以使用工具（例如 OpenSSL）转换为其他格式，例如 PEM，以方便阅读。下面是一个名为 \u0060crl.pem\u0060 的 CRL 示例文件，以 PEM 格式表示：\n\n\u0060\u0060\u0060dockerfile\n-----BEGIN X509 CRL-----\nMIIBtjCBqwIBATANBgkqhkiG9w0BAQUFADBBMQswCQYDVQQGEwJVUzERMA8GA1UE\nCBMITmV3IFlvcmsxETAPBgNVBAcTCE5ldyBZb3JrMREwDwYDVQQKEwhNeSBDQTEQ\nMA4GA1UECxMHQ2VydGlmaWNhdGUxGDAWBgNVBAMTD01ZIEJ1c2luZXNzIENBMB4X\nDTA5MDUwMzE1MTQwMFoXDTEwMDUwMjE1MTQwMFqgLzAtMB8GA1UdIwQYMBaAFJ4f\n6Nz7Vuw\/NcZXG0U8O6OZ9XB0MAsGA1UdDwQEAwIFoDAdBgNVHQ4EFgQUU6G9fjRK\nop\u002bJU6vQPnnhxBxHtzUwDQYJKoZIhvcNAQEFBQADgYEAbYoLz7MnJ4ltIS\u002bnCquG\nN\/v\u002b8rE00\/N0pGzN\/dCv\/8t0W0tGTGr2zGRb0mv67MPOmWmHcZZq3sOxgEIp8T\u002bO\nOJxDCD\/xJN6hB0NgN\/Z0\u002bfX9hU6bL\/6zhwUy\/l51xddmSd5KKhJ7FmOh2Py5m9Au\n4fJh7w\u002bOLyjKV7rz55WKjvY=\n-----END X509 CRL-----\n\u0060\u0060\u0060\n\n使用 OpenSSL 将其转换为可读格式：\n\n\u0060\u0060\u0060bash\nopenssl crl -inform PEM -in crl.pem -noout -text\n\u0060\u0060\u0060\n\n输出结果为：\n\n\u0060\u0060\u0060\nCertificate Revocation List (CRL):\n        Version 2 (0x1)\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: \/C=US\/ST=New York\/L=New York\/O=My CA\/OU=Certificate\/CN=My Business CA\n        Last Update: May 3 11:40:00 2009 GMT\n        Next Update: May 2 11:40:00 2010 GMT\n    Revoked Certificates:\n        Serial Number: 1 (0x1)\n            Revocation Date: May 3 11:40:00 2009 GMT\n\u0060\u0060\u0060\n\n**注意**：该 CRL 文件的列表中只保存了一个撤销证书。\n\nCRL 虽被广泛使用，但使用 CRL 文件来撤销证书存在以下几个缺点：\n\n1. **时效性**：CRL 文件必须定期更新，否则将无法识别近期撤销的证书；\n2. **可用性**：如果无法访问 CRL 服务器，则无法验证证书是否已被撤销；\n3. **效率**：CRL 文件随着证书数量的增加而变得越来越大，因此验证证书的过程可能会变慢；\n4. **安全性**：CRL 文件本身也需要安全保护，否则攻击者可能会篡改 CRL 以逃避撤销证书的限制；\n\n因此，现在有更高效和安全的证书撤销机制，例如 OCSP（Online Certificate Status Protocol），它可以实时验证证书的状态，并且不需要存储所有已撤销证书的列表。\n\n## OCSP Stapling\n\nOCSP Stapling（正式名称为 TLS 证书状态查询扩展）是一种 TLS（Transport Layer Security）扩展，用于证明证书的状态是有效的。它允许服务器预先检索证书状态信息，并将该信息“钉”到 TLS 证书中，以减少对证书颁发机构的依赖，并提高证书状态验证的效率。可代替 OCSP 来查询 X.509 证书的状态。服务器在 TLS 握手时发送事先缓存的 OCSP 响应，用户只需验证该响应的有效性而不用再向数字证书认证机构（CA）发送请求。详见[维基百科](https:\/\/en.wikipedia.org\/wiki\/OCSP_stapling)。\n\nOCSP 只适用于单个证书，而不是列表。客户端在收到证书后，与 CA 通信以检查撤销状态。响应可以是 \u0022good\u0022、\u0022revoked\u0022 或 \u0022unknown\u0022 之一。\n\n使用 OSCP Stapling 虽然省去了维护 CRL 的负担，但是它依然有以下几个缺点：\n\n1. **额外的资源开销**：CA 服务器需要不断地响应 OCSP 质询以确保证书的有效性，这将对服务器的 CPU 和网络带宽造成额外的开销；\n2. **可用性问题**：如果 OCSP 服务器不可用，则客户端将无法获得证书的有效性信息；\n3. **安全问题**：如果 OCSP 响应被篡改或服务器不安全，则证书的有效性信息可能被篡改，从而影响安全；\n4. **兼容性问题**：OCSP Stapling 不是所有浏览器都支持的功能，因此可能需要在旧浏览器上实现额外的兼容性。\n\nOCSP 的挑战是，它给 CA 带来了很大的负担，因为每个客户端都需要独立地获得证书的验证。总体而言，OCSP Stapling 可以提高证书验证的效率和安全性，但是也存在一些需要考虑的问题。因此，在采用该技术时需要综合考虑多方面的因素。\n\n## Istio 对 OSCP Stapling 支持\n\n很多 Web 服务器都支持 OSCP Stapling，云原生边缘代理 Envoy 也支持该功能，需要对 Envoy 进行以下配置：\n\n- 配置 [\u0060DownstreamTlsContext\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/tls\/v3\/tls.proto#envoy-v3-api-msg-extensions-transport-sockets-tls-v3-downstreamtlscontext) 中的 \u0060oscp_staple_policy\u0060：\n  - \u0060LENIENT_STAPLING\u0060：OCSP 响应是可选的，此为默认值\n  - \u0060STRICT_STAPLING\u0060：OCSP 响应是可选的，但如果存在并且有效，就会使用。\n  - \u0060MUST_STAPLE\u0060: OCSP 响应是必需的\n- 配置 [\u0060TlsCertificate\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/tls\/v3\/common.proto#envoy-v3-api-msg-extensions-transport-sockets-tls-v3-tlscertificate) 中的 \u0060oscp_staple\u0060，响应必须是 DER 编码的，只能通过文件名或 \u0060inline_bytes\u0060 提供。响应可能只与一个证书有关。\n\n目前 Envoy 已支持 OSCP Stapling，其作为 Istio 的数据平面和 Istio Gateway 中的代理，理论上 Istio 也可以支持该功能。不过 Istio 的 OSCP Stapling 证书撤销功能支持仍在进行中，详见 [PR #42859 - OSCP Stapling](https:\/\/github.com\/istio\/istio\/pull\/42859)。该功能的新进展将在本文中更新，请保持关注。\n', '\/blog\/ocsp-stapling-for-istio-gateways\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇博客将向你介绍证书撤销的方式和 Istio 的解决方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/optimize-traffic-management-and-security-with-these-service-mesh-best-practices/">[译] 服务网格安全性优化最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/02/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/optimize-traffic-management-and-security-with-these-service-mesh-best-practices/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格安全性优化最佳实践', '本文推荐了服务网格安全性优化的一些最佳实践。', '\n这是 [服务网格最佳实践系列文章](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 中的第三篇，摘自 Tetrate 创始工程师 Zack Butcher 即将出版的新书 Istio in Production。\n\nIstio 就像一组乐高积木：它具有许多功能，可以按照你想要的任何方式进行组装。出现的结构取决于你如何组装零件。在 [上一篇中](..\/service-mesh-deployment-best-practices-for-security-and-high-availability\/)，我们描述了一种运行时拓扑结构，用于构建健壮、有弹性且可靠的基础架构。在本文中，我们将描述一组网格配置，以帮助在运行时实现稳健性、弹性、可靠性和安全性。\n\nIstio 在其所谓的 [根命名空间](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-root_namespace) 中支持全局默认配置 —— 默认在 \u0060istio-system\u0060。在根命名空间中发布的配置默认适用于所有服务，但在本地命名空间中发布的任何配置都会覆盖它。因此，一些配置应该在根命名空间中发布，并且不允许在其他任何地方发布（例如用于在传输中强制加密的 PeerAuthentication 策略）。其他配置应该在每个服务自己的命名空间中编写（例如 VirtualService 控制它的弹性设置）。\n\n我们看到的最成功的网格采用将网格本身隐藏在另一个界面后面：例如 Helm 模板、Terraform 或更高级的解决方案，例如 [Tetrate Service Bridge (TSB)](https:\/\/tetrate.io\/tetrate-service-bridge\/)。核心思想是只公开应用程序开发人员应该配置的一小部分网格功能，最好是使用他们理解的语言（例如，TSB 可以使用 [带注释的 OpenAPI 规范](https:\/\/docs.tetrate.io\/service-bridge\/1.6.x\/en-us\/quickstart\/apps) 进行配置）。首先，我们通常只向应用程序开发人员公开流量设置和授权。身份验证和遥测由各自的团队或代表他们的平台团队集中控制。[NIST SP800-204 系列](https:\/\/tetrate.io\/blog\/nist-standards-for-zero-trust-the-sp-800-204-series\/)，尤其是 [SP 800-204A](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204a\/final) 和 [SP 800-204B](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)。Istio 项目站点也有一组 [最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/)，也值得收藏。\n\n## 服务网格命名约定\n\n**建议**：为 Istio 资源开发和维护一致的命名方案，最好基于它们配置的服务或主机。\n\n**建议**：为跨集群的团队保持一致的名称。命名空间应该由一个团队拥有。\n\nIstio 资源应该根据它们配置的服务或主机来命名：\u0060ServiceEntry\u0060 添加 \u0060api.example.com\u0060 到网格的应该命名为 \u0060external-api-example-com\u0060；服务的 \u0060DestinationRule\u0060、\u0060VirtualService\u0060、\u0060PeerAuthentication\u0060 和 \u0060Authorization\u0060 策略也都应该有相同的名称。PCI 命名空间中的内部服务 Payments（应用程序代码中的 hostname \u0060payments.pci\u0060）应该被命名为 \u0060payment-pci\u0060，其所有的网格配置名称也应该匹配。这些命名方案并不是硬性规定，但你应该在你的组织内建立并坚持一个一致的惯例。\n\n这些资源应该全部发布在它们配置的服务的命名空间中，或者发布在 \u0060istio-system\u0060 命名空间中以进行网格范围的配置。外部服务通常发布到 \u0060istio-system\u0060 中并由中心团队（平台或安全团队）管理。\n\n我们建议跨集群的团队使用一致的名称：无论集群租户模型如何，命名空间都应由单个团队拥有（请参阅下一节）。\n\n## 服务网格全局设置\n\n**配置可见性**。Istio 有一个配置可见性的想法：配置可以默认应用于整个集群，或者它可以只应用于本地命名空间，甚至可以只应用于单个服务（选择对整个集群可见，或者只是特定的命名空间）。为了性能和安全，你应该将该字段默认为 \u0060exportTo\u0060 本地名称空间（“.”）。你应该在安装时为 [*Services*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_service_export_to)、[*VirtualServices*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_virtual_service_export_to) 和 [*DestinationRules*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_destination_rule_export_to) 设置这个默认值。查看 Istio 的 [全局配置](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_service_export_to) 来配置这些默认值：\n\n\u0060\u0060\u0060yaml\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n name: controlplane\n namespace: istio-system\nspec:\n # profile: default\n # ...\n meshConfig:\n   defaultServiceExportTo:\n   - \u0022.\u0022# only the namespace the resource is published in\n   defaultVirtualServiceExportTo:\n   - \u0022.\u0022\n   # equivalent, just different YAML syntax\n   defaultDestinationRuleExportTo: [\u0022.\u0022]\n\u0060\u0060\u0060\n\n示例 1：默认全局设置\n\n**每个命名空间的 Sidecar 资源配置**。Istio 的 \u0060Sidecar\u0060 （API）资源控制 Istio 将哪些配置发送到每个命名空间中的 Sidecar。为了获得最佳性能和最低开销，你应该为每个命名空间管理一个配置，并管理 egress 部分以仅包括服务必须与之通信的主机。这将导致 Istio 向该命名空间中的 Envoy 实例发送更少的配置，从而减少它们的内存和 CPU 消耗。结合仅注册表出站流量策略（见下一条），Sidecar 资源还可以帮助限制攻击者通过 Envoy 的表面区域，因为不在 Sidecar 的 egress 部分的主机将是该 Envoy 实例的 \u0022出站流量\u0022。这本身并不是一个足够的安全策略（见下面的安全部分），而是增加了一个攻击者必须穿越的额外防御层。\n\n**编写明确的出站（egress）流量策略**。Istio 提供了一些选项来配置它如何处理网格中的服务，该服务试图与 Istio 未知的端点进行通信：[Outbound Traffic Policy](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-OutboundTrafficPolicy-Mode)。Istio 可以允许所有流量，也可以将流量限制在网格已知的服务上。你应该在安装时配置 Istio，只允许连接到注册表中的服务。此外，你应该将所有需要与之通信的外部服务建模为 Mesh 中的 ServiceEntries（例如，SaaS 服务的 DNS 解析等），使用 DestinationRules 来配置与它们通信的 TLS。这些外部服务应该由安全团队集中管理，或者由平台团队代表他们管理。\n\n## 运行时流量管理配置\n\n**为服务使用一致的全局名称，并使用 Istio 将它们映射到本地实例**。你应该使用一致的全局名称来访问服务。你可以使用 Istio 将这些全局名称映射到本地实例。例如，\u0060payments.tetrate.internal\u0060 可以被所有内部应用程序使用，而 Istio 可以用来将该名称映射到服务实例，例如“在 \u0060us-east-2\u0060 Kubernetes 集群中的 \u0060payments.default.svc.cluster.local\u0060 服务”。这种全局命名方案使开发人员可以像 SaaS 一样考虑所有服务，而无需仔细考虑运行时拓扑的细节，并且可以轻松地执行故障转移、金丝雀和跨集群路由等操作，作为你的网格使用成熟或组织需求演变。\n\n**在根配置中定义粗略的默认弹性设置**。你应该为网格中的所有服务定义粗略的超时、重试、熔断和异常值检测设置。你可以在根配置命名空间中使用 \u0060VirtualService\u0060 来实现此目的。各个团队应在其本地命名空间中指定自己的名称以覆盖默认值。\n\n**为应用程序团队提供简化的“低 \/ 中 \/ 高”弹性设置**。将网格的底层 API 隐藏在更高级别接口后面的系统中，为配置默认断路和异常值检测设置的应用程序开发人员提供简化的“低 \/ 中 \/ 高”旋钮很有价值，因为很多领域容易配置错误，导致该应用程序性能不佳。\n\n## 运行时安全配置\n\n以下安全建议来自我们为微服务应用程序建立美国安全标准的工作，该标准由美国国家标准与技术研究院（NIST）在 [SP 800-204 系列](https:\/\/tetrate.io\/blog\/nist-standards-for-zero-trust-the-sp-800-204-series\/) 中发布。[你可以在我们的综合指南](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/) 中阅读 NIST 针对微服务应用程序的所有安全建议。\n\n**最小控制**。运行时的零信任至少需要以下五个控制：\n\n1. **加密传输中的所有内容**：提供消息真实性和窃听保护（[SP 800-204，§MS-SS-4](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n2. **验证服务到服务的通信**：每个应用程序都应验证与之通信的应用程序的身份（[SP 800-204A，§SM-DR16；SP 800-204B，§APE-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n3. **授权服务到服务访问**：每个应用程序都应使用其运行时身份授权与之通信的应用程序（[SP 800-204B，§SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n4. **验证最终用户身份**：每个请求都必须在服务调用图中的每个跃点进行身份验证（[SP 800-204B，§EAUN-SR-1，§EUAZ-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n5. **授权最终用户访问资源**：对每种资源的每次访问都应获得授权，而不仅仅是在前门访问一次（[SP 800-204B，§EAUZ-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\nIstio 提供传输中的加密（我们在上面讨论了全局启用），以及可验证的服务身份 ([SPIFFE](https:\/\/tetrate.io\/blog\/why-would-you-need-spire-for-authentication-with-istio\/) ) 和服务到服务的访问控制 (Istio \u0060AuthorizationPolicy\u0060)。此外，它可以配置为代表应用程序（JWT、OIDC 令牌）验证某些形式的最终用户身份，最后 Istio 支持可插拔授权系统（Envoy 的 \u0060ext_authz\u0060）以强制最终用户访问资源。\n\n**安装限制性默认授权策略**。根据 [Istio 最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/#use-default-deny-patterns)，你应该安装一个不允许流量的默认授权策略，为每个服务发布对象创建 \u0060AuthorizationPolicy\u0060 对象以管理允许它们与之通信的对象（[SP 800-204B，SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。有助于实现这一目标的两个授权策略：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: deny-all-audit\n  namespace: istio-system\nspec:\n  action: AUDIT\n\u0060\u0060\u0060\n\n示例 2：\u0060IstioAuthorizationPolicy\u0060会拒绝所有流量，并审计记录它。你可能会运行这样的策略几周，以了解在启用强制执行之前你需要的策略。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: deny-all\n  namespace: istio-system\nspec:\n  {} # or action: ALLOW\n\u0060\u0060\u0060\n\n示例 3：拒绝所有流量的 Istio AuthorizationPolicy。或者，你可以创建一个允许但具有空规则集的策略，这与空主体相同。\n\n**默认情况下需要 mTLS 进行服务到服务通信**。通过在由安全或平台团队管理的根命名空间中配置 \u0060PeerAuthentication\u0060 资源，应将传输中的加密设置为严格（即 [需要 mTLS 才能与服务通信](https:\/\/tetrate.io\/blog\/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture\/)）。网格外部的服务调用网格中的应用程序应该通过应用程序入口网关进行通信，它可以向外部服务提供简单的 TLS（甚至明文），因为它不太可能有证书来对网格执行 mTLS。网格内部的服务呼出应配置为使用简单的 TLS 或明文，并带有用于外部服务的 DestinationRule 的明文 ([NIST SP 800-204A, §SM-DR8](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/) )。\n\n**TLS 配置默认值**。Istio 开箱即用，具有良好的 TLS 设置（[TLS 最低版本 1.2，具有一组有限的密码套件](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#mutual-tls-authentication)），但你可能需要根据你的环境对其进行调整（例如，在 [FedRAMP](https:\/\/www.fedramp.gov\/) 环境中遵守 [FIPS 140-3](https:\/\/csrc.nist.gov\/publications\/detail\/fips\/140\/3\/final) ）：\n\n- Envoy 支持通过配置 [网关](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings-cipher_suites) 为每个服务配置最低 TLS 版本和一组受支持的密码套件。\n- 如果可能，我们建议将 **TLS 1.3 作为最低版本** 执行（如果你只执行 mTLS Envoy-to-Envoy），并为需要较旧或安全性较低的 TLS 配置的外部流量使用网关。\n\n**为每个服务分配一个唯一的运行时身份，以促进表达性强、细粒度的授权策略并限制暴露于攻击**。为你正在部署的每个服务分配一个唯一的运行时标识。在 Kubernetes 中，不要在每个命名空间中使用默认的 Kubernetes 服务帐户，而是为每个命名空间中的每个服务分配一个唯一的服务帐户。授权策略只能在身份的粒度上轻松管理。当多个运行时组件共享相同的身份时，很难管理一个访问控制策略来表达你的预期访问权限，同时不允许使用共享身份的某些组件进行过于广泛的访问。这导致更大的表面积暴露给可能危及系统的一个组件的攻击者（[NIST SP 800-204A §SM-DR11，§SM-DR18](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\n**将服务到服务的通信限制在本地命名空间**。默认情况下，服务间通信应限制在本地名称空间内。不幸的是，这不能写为根配置命名空间中的单个 AuthorizationPolicy。相反，可以将仅允许在本地命名空间中访问的默认 AuthorizationPolicy 模板化为默认值，并且应允许应用程序团队编写他们自己的更专业（受限）的策略（[NIST SP800-204B，§SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\n## 下一步\n\n我们希望从我们多年帮助客户构建成功的服务网格实践的经验中获得的这些最佳实践将有助于促进你的部署。如果你还没有，请查看服务网格最佳实践系列中的其他帖子： \n\n- [第 1 部分：如何将服务网格作为安全模型的一部分，以分层形式将微服务安全与传统安全结合起来](\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/)\n- [第 2 部分：服务网格安全性和高可用性部署最佳实践](\/trans\/service-mesh-deployment-best-practices-for-security-and-high-availability\/)\n\n如需全面了解 NIST 微服务安全标准，请 [下载我们的免费指南](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)。\n\n### 接下来：多租户的服务网格最佳实践\n\n在我们关于服务网格最佳实践系列的下一篇文章中，我们将讨论我们看到客户正在努力解决的常见租赁决策点，并重点关注网格如何帮助促进这些决策。我们将涵盖的主题包括 Kubernetes 集群所有权、命名空间所有权、配置所有权，以及如何使用服务网格应用程序网关来缓解中断。\n', '\/trans\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文推荐了服务网格安全性优化的一些最佳实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-deployment-best-practices-for-security-and-high-availability/">[译] 服务网格安全性和高可用性部署最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/service-mesh-deployment-best-practices-for-security-and-high-availability/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格安全性和高可用性部署最佳实践', '本文强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。', '\n这是 [服务网格最佳实践系列文章](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 中的第二篇，摘自 Tetrate 创始工程师 Zack Butcher 即将出版的书籍 Istio in Production。\n\n当涉及到在多集群的基础设施中部署服务网格时，有一些可移动的部分。这里主要想强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。\n\n## 使服务网格控制平面与故障域保持一致\n\n**建议：围绕故障域部署松散耦合的控制平面以实现高可用性。**\n\n构建高可用性系统可能具有挑战性，而且通常成本很高。我们知道的一种经过验证的技术是围绕故障域构建。故障域是当关键系统发生故障时受影响的基础架构部分。我们构建可靠系统的基本方法是将系统跨越的故障域分组为多个独立的孤岛。最终系统的整体可靠性取决于我们可以使孤岛的独立程度。实际上，总是存在一些相互依赖性，将其最小化总是成本与可用性的权衡。\n\n在没有耦合故障域的情况下创建隔离孤岛的最简单方法是在每个孤岛中运行关键服务的独立副本。我们可以说这些副本是筒仓的本地副本 —— 它们共享相同的故障域。在云原生架构中，Kubernetes 集群形成了最自然的筒仓边界。Istio 是一项关键服务，因此我们在每个应用程序集群中运行一个 Istio 控制平面实例。换句话说，我们部署 Istio 使其故障域与你的应用程序的故障域保持一致。\n\n此外，我们确保 Istio 控制平面实例是松散耦合的，不需要直接与其他集群通信，从而最大限度地减少其与孤岛外部的通信。有关如何实现此目的的详细信息，请参阅下面的多集群部分。\n\n## 使用应用程序入口网关隔离每个应用程序的流量\n\n**建议：从每个应用程序或应用程序团队的网关（应用程序入口网关）开始，以帮助缓解共享中断。随着时间的推移你操作经验的增加，将应用程序入口合并到共享网关以优化成本。**\n\n虽然 Istio 默认附带共享 \u0060istio-ingressgateway\u0060，但我们不建议使用共享网关。大多数采用网格的团队都需要时间来构建实施共享网关模型所需的审查实践和操作，而没有共享中断的风险。特别是在 Istio 实施的早期，我们建议每个团队部署一个 Envoy 网关。我们称这些为应用程序入口网关。随着你获得操作经验，你可以开始将应用程序合并到共享网关上以优化成本。\n\n使用共享网关模型实现每个团队隔离的捷径是为每个团队分配一个单独的主机名。按主机名隔离的团队可以更安全地配置共享网关实例。然而，其他共同命运的中断风险仍然存在，例如入口代理部署的错误配置、嘈杂的邻居消耗资源和增加所有应用程序的延迟等。根据我们的经验，每个团队一个网关的方法会产生最快的影响，并且失败的机会最少，并且总体成本相对较低。\n\n我们期望成熟部署的最终状态是 80-20 的比例：大多数应用程序将通过共享网关接收流量，而一小部分高度关键或敏感的应用程序将保留专用网关。\n\n## 使用应用程序边缘网关在多个集群之间分配入口流量\n\n**建议：使用应用程序边缘网关为客户端提供单一地址，以供客户端使用并将流量分配到跨多个集群的应用程序入口网关。**\n\n![图 1：基于 Envoy 的应用程序边缘网关。](f1.png)\n\n我们经常看到客户需要跨多个集群分配入口流量。例如，他们可能希望启用蓝 \/ 绿基础设施升级，以促进跨区域故障转移，或者通过使用 Envoy 的 L7 功能将流量从单体迁移到微服务来实现扼杀模式。我们称这些为应用程序边缘网关。\n\n为了实现这个用例，我们将部署 Envoy—— 在专用的 Kubernetes 集群中或作为一组虚拟机 —— 来接收外部流量。这些 Envoy 实例将通过其 Kubernetes 入口或 VM VIP 将流量转发到你的应用程序。这与 ingress-per-team 方法协同工作：多集群网关为客户端提供一个单一地址以供使用，根据你的基础设施需要提供尽可能多的应用程序网关和集群。\n\n虽然此网关确实存在共享故障域，但其配置远比每个应用程序一个入口网关的配置简单。因此，作为共享基础架构运行起来更容易，也更安全。每个集群都有一个应用程序入口网关的共享应用程序边缘网关是一种强大而灵活的模型，用于在网格上部署和操作应用程序，还可以更轻松地操作底层基础设施。\n\n## 证书和公钥基础设施 (PKI) 的建议\n\n**建议：从你现有的企业根目录为网格 mTLS 创建一个中间签名证书。**\n\nIstio 使用常规 X.509 证书进行身份验证并在网格中启用传输加密。我们建议为现有企业根目录中的所有网格 mTLS 创建一个网格中间签名证书。如果每个环境都有一个根，请为每个环境创建一个网格中间签名证书。使用该网格中间颁发证书为每个 Istio 安装创建一个签名证书。我们建议创建一个网格中间签名证书，以便在任何特定环境中网格的整个 PKI 是一棵树，如果需要可以一起失效。成本是一些额外的证书管理，与控制平面签名证书相比，在管理网格中间签名证书的生命周期时需要更加小心。\n\n![图 2. Tetrate 推荐的将网格与现有 PKI 集成的方法：在环境（如 prod）中为 Istio 生成中间签名证书，使用它向该环境中的每个 Istio 控制平面实例颁发签名证书，并让 Istio 像往常一样向每个集群中的所有 pod 颁发工作负载（叶）证书。](f2.png)\n\nIstio 监视文件系统，并在检测到文件更改时重新加载其签名证书。因此，只要你有一个批准的机制来将秘密加载到 *istiod* pod 的文件系统中 —— 比如 *cert-manager*、Vault 的 *init-agent* 或 sidecar，或者只是存储在加密 *etcd* 中的普通旧 Kubernetes Secret—— 集成 Istio 进入你的 PKI 应该很容易。控制平面签名证书的轮换应由你的 PKI 自动执行。\n\nIstio 使用众所周知的密码学库：Istio 的内部 CA 使用 Golang 的密码学套件，Envoy（sidecar 和 ingress）使用 BoringSSL 进行证书验证和传输中的加密。通过 Tetrate 的开源 Istio 发行版 [Tetrate Istio Distro](https:\/\/tetr8.io\/tid) ，经过 FIPS 验证的控制平面和数据平面构建也作为 [Tetrate Istio 订阅](https:\/\/tetr8.io\/tis) 的一部分提供，因此你可能期望的所有 X.509 约束（基本约束，如 CA 和深度，开箱即用地支持和强制执行命名约束、策略约束等）。\n\n### 使用极短寿命的工作负载证书以轻松吊销\n\n**建议：使用 Istio 来自动化证书管理，以便设置极短的工作负载证书 TTL 变得切实可行，从而使 [证书撤销列表（CRL）](https:\/\/csrc.nist.gov\/glossary\/term\/certificate_revocation_list) 保持简短且易于管理。**\n\n在证书颁发和轮换（Istio 为你自动执行）之后，PKI 中最大的挑战是证书吊销。证书吊销是通过证书吊销列表实现的，通常 CRL 具有 24 小时的强制执行 SLA：添加到列表中的证书在吊销后最多 24 小时内可能会被基础设施视为有效。此外，由于吊销的证书必须在其整个生命周期 (TTL) 内保留在列表中，因此吊销列表会变得庞大而笨拙。\n\nIstio 提供的一个更好的解决方案是自动化证书管理，以便设置极短的工作负载证书 TTL 是切实可行的。默认情况下，Istio 附带 24 小时的工作负载证书 TTL。这足够短，大多数安全组织可以选择让受损的证书过期，而不是明确地撤销它们。而且，当你向 CRL 添加证书时，它只需要在那里停留很短的时间（因为我们不需要在 CRL 上保留过期的证书）。通过这种方式，网格有助于解决大多数组织面临的最痛苦的 PKI 问题：它颁发和吊销短期证书，这意味着吊销列表可以在需要时保持简短且易于管理。\n\n**注意**：由于网格使用 mTLS 证书作为身份，Istio 将 Envoy 配置为自动丢弃已建立的连接，以强制客户端和服务器在任何一方轮换证书时重新验证彼此。这是 Istio 实现中的设计决策，通常通过 Istio 的弹性功能对应用程序隐藏：对应用程序透明的自动重试重新建立连接。在网格中设置较短的证书 TTL 会强制这些重新连接更频繁地发生。值得注意的是，这种行为偶尔会中断一些期望长期 TCP 连接的应用程序。\n\n### 进一步的证书推荐\n\n你应该与你的安全团队协调，为你的网格颁发的证书建立适当的约束。我们推荐的一些常见约束如下。\n\n**证书生命周期 (TTL)**。请注意，只要证书是从同一个根颁发的，Istio 就支持控制平面签名证书和工作负载证书的零停机轮换。我们建议每个级别的证书生命周期如下：\n\n- 网格中间签名证书 1-3 年\n- 控制平面签名证书 3 个月\n- 工作负载证书需要 12-24 小时\n\nIstio 自动处理工作负载证书的轮换。这些证书上的短 TTL（少于 24 小时）有助于限制可能被盗的凭据进行时间限制攻击，还可以减少对 CRL 的需求。控制平面证书应按一个月的偏移轮换以确保平稳过渡 —— 换句话说，在 3 个月的 TTL 到期前 1 个月轮换控制平面签名证书。类似地，当网格中间签名证书还剩一半到三分之一的生命周期时轮换（一年 TTL 提前 3-4 个月，三年 TTL 提前 6-8 个月）。\n\n**基础（CA 和深度）**。控制平面签名证书应该只能颁发叶证书：用于工作负载识别的非签名证书。因此，应配置深度限制以防止控制平面签名证书颁发任何其他签名证书。\n\n网格中间签名证书需要创建控制平面签名证书，因此它应该配置一个深度，以便能够**在它下面创建一个级别的签名证书，而不是更多**。\n\n**名称约束**。Istio 颁发的工作负载证书不会填充 X.509 主体名称 (SN) 字段；网格身份验证依赖于作为主体备用名称 (SAN) 字段携带的 SPIFFE 身份。阅读 [SPIFFE 规范以获取有关验证和身份验证工作的信息](https:\/\/github.com\/spiffe\/spiffe\/blob\/main\/standards\/X509-SVID.md#4-constraints-and-usage)，以及 Istio 的 [文档](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#istio-identity) 以了解 Istio 如何根据 SPIFFE 对身份进行编码。在为网格中间和控制平面签名证书编写名称约束时，请记住这一点。\n\n**密钥用法**。 \u0060keyCertSign\u0060 必须为网格中间签名证书和控制平面签名证书设置，但应为工作负载证书禁用。换句话说，网格中间和控制平面证书是签名证书，而工作负载证书不是。\n\n根据 SPIFFE 的建议，不应将签名证书用于传输中的加密，并且应配置密钥使用以防止它（通过加密约束）。\n\n**扩展密钥用法**。虽然此处没有具体要求，但 SPIFFE X.509 SVID 规范说明 \u0060id-kp-serverAuth\u0060 和 \u0060id-kp-clientAuth\u0060 应针对叶（工作负载）证书进行配置。\n\nSPIFFE 规范还推荐了 [各种证书约束](https:\/\/github.com\/spiffe\/spiffe\/blob\/main\/standards\/X509-SVID.md#4-constraints-and-usage)，尽管其中大部分上面已经约束了。\n\n## 下一步\n\n我们希望从多年帮助我们的客户充分利用服务网格的经验中收集的这些最佳实践将有助于促进你的部署。如果你还没有，请查看 [如何将服务网格作为安全模型的一部分，以分层形式将微服务安全与传统安全结合起来](\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 这篇文章。\n\n接下来：服务网格运行时配置建议。在我们的下一篇文章中，我们将谈论：\n\n- 命名约定\n- 全局设置\n- 流量管理\n- 安全\n- 遥测\n\n敬请关注。\n', '\/trans\/service-mesh-deployment-best-practices-for-security-and-high-availability\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/secure-ingress-gateway-of-istio/">使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书', '本文就将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。', '\n本文将以 Bookinfo 应用为例，为 Istio 的入口网关设置一个真实的 TLS\/SSL 证书。我们将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。\n\n## 准备 {#prerequisite}\n\n请先参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/setup\/)安装 Istio 和 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，笔者在 GKE 中安装了 Istio 1.16。\n\n本文中安装的各组件版本信息如下：\n\n- Kubernetes 1.24.7\n- Istio 1.16\n- Gateway API 0.5.1\n- cert-manager 1.10.1\n\n## 架构 {#arch}\n\n本实验中包含以下关键组件：\n\n- 使用 Cloudflare 提供 DNS 解析\n- 使用 Let\u0027s Encrypt 创建证书\n- 使用 cert-manager 自动申请和续期证书\n- 使用 Gateway API 来创建入口网关\n- 所有组件部署在 GKE 中\n\n图 1 展示了本实验的架构以及流量路由过程。\n\n![图 1：Istio 入口网关证书挂载模式](arch.svg)\n\n流量路由过程如下：\n\n1. 在 Gateway 创建完成后通过 LoadBalancer 暴露网关 IP，将该 IP 配置在 DNS 解析记录中；\n2. Gateway 通过注解引用 [ACME Issuer](https:\/\/cert-manager.io\/docs\/configuration\/acme\/)；\n3. ACME Issuer 向 cert-manager 发送请求证书（[order 和 challenge](https:\/\/cert-manager.io\/docs\/concepts\/acme-orders-challenges\/)），并使用 [DNS01 Challenge Provider](https:\/\/cert-manager.io\/docs\/configuration\/acme\/dns01\/)；\n4. cert-manager 向 ACME 服务器 Let\u0027s Encrypt 请求证书并创建 Kubernetes Secret；\n5. 在 Gateway 中通过应用 Secret 挂载 TLS 证书；\n6. HTTPRoute 将入口流量路由到 productpage 服务；\n\n## ACME Issuer\n\nIstio 包含了开箱即用的 mTLS 支持，你也可以使用[自定义 CA](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/) 或 [SPIRE](\/blog\/cert-manager-spire-istio\/) 来管理集群内证书，但是对于入口网关的证书，就需要我们单独设置。你可以[手动为入口网关配置证书](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)，不过管理起来会比较麻烦，因为你需要负责证书的轮换以防止证书过期，或使用 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/) 这样的 ACME Issuer 来自动化管理证书。\n\nACME (Automated Certificate Management Environment) Issuer 是一种认证机构，可以使用 ACME 协议为客户端申请和管理证书。ACME 是一种用于自动化 SSL\/TLS 证书颁发和管理的开放协议。它通常用于网站或其他在线服务的证书管理，以确保安全连接。\n\nLet\u0027s Encrypt 是一个非营利性的 ACME Issuer，可以为网站提供免费的 SSL\/TLS 证书。它的目标是使加密技术普及化，并帮助提升网络安全水平。Let\u0027s Encrypt 使用 ACME 协议与客户端通信，可以为客户端申请和管理证书。ACME 协议是开放的，因此任何机构都可以成为 ACME Issuer，只要它们遵守 ACME 协议的规定。\n\n## 详细步骤 {#details-steps}\n\n1. 安装 Gateway API：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/github.com\/kubernetes-sigs\/gateway-api\/releases\/download\/v0.5.1\/standard-install.yaml\n   \u0060\u0060\u0060\n\n2. 安装 cert-manager\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/gist.githubusercontent.com\/rootsongjc\/78487acdea70a3c27c1a1b794546d031\/raw\/0df08b91dfaff6412bbd891ccedffaa882a9a99f\/cert-manager.yaml\n   \u0060\u0060\u0060\n\n   它为 cert-manager Deployment 增加了以下启动项：\n\n   \u0060\u0060\u0060bash\n   args:\n     - --feature-gates=ExperimentalGatewayAPISupport=true\n   \u0060\u0060\u0060\n\n3. 在 Cloudflare 中创建一个名为 \u0060lets-encrypt-token\u0060 的 API token，自定义模板设置如下：\n\n   Permissions：\n\n   - \u0060Zone - DNS - Edit\u0060\n   - \u0060Zone - Zone - Read\u0060\n\n   Zone Resources:\n\n   - \u0060Include - All Zones\u0060\n\n   将该 token 存储在一个 Secret 中：\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: v1\n   kind: Secret\n   metadata:\n     name: cloudflare-api-token-secret\n     namespace: istio-system\n   type: Opaque\n   stringData:\n     api-token: \u003cAPI Token\u003e\n   EOF\n   \u0060\u0060\u0060\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本次实验中该 Token 实际上并没起到作用，正常情况下 cert-manager 会通过 Cloudflare API 与 Cloudflare 交互，为我们配置 DNS 记录。该问题还需要进一步排查。\n\n   {{\u003c\/callout\u003e}}\n\n4. 配置 Let\u0027s Encrypt  Issuer：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: cert-manager.io\/v1\n   kind: Issuer\n   metadata:\n     name: letsencrypt\n   spec:\n     acme:\n       email: rootsongjc@gmail.com\n       server: https:\/\/acme-v02.api.letsencrypt.org\/directory\n       privateKeySecretRef:\n         name: lets-encrypt-issuer-account-key\n       solvers:\n       - dns01:\n           cloudflare:\n             apiTokenSecretRef:\n               name: cloudflare-api-token-secret\n               key: api-token\n         selector:\n           dnsNames:\n           - \u0027bookinfo.jimmysong.io\u0027\n   EOF\n   \u0060\u0060\u0060\n\n5. 配置 Gateway：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: Gateway\n   metadata:\n     name: bookinfo-gateway\n     annotations:\n       cert-manager.io\/issuer: letsencrypt\n   spec:\n     gatewayClassName: istio\n     listeners:\n     - name: http\n       hostname: bookinfo.jimmysong.io\n       port: 443\n       protocol: HTTPS\n       allowedRoutes:\n         namespaces:\n           from: Same\n       tls:\n         mode: Terminate\n         certificateRefs:\n           kind: Secret\n           group: \u0022\u0022\n           name: bookinfo-tls\n   EOF\n   \u0060\u0060\u0060\n\n   在 Gateway 创建完成后，会在 default 命名空间中创建一个网关 Pod 以及 LoadBalancer 资源的服务。\n\n   查看 \u0060default\u0060 命名空间中的 Secret，你会发现 \u0060bookinfo-tls\u0060，它是由 cert-manager 创建的，查看该 Secret 中保存的证书，你将会看到由 Let\u0027s Encrypt 颁发的证书信任链：\n\n   - \u0060bookinfo.jimmysong.io\u0060 \n   - \u0060ISRG Root X1\u0060\n   - \u0060DST Root CA X3\u0060\n\n6. 配置 HTTPRoute：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: HTTPRoute\n   metadata:\n     name: bookinfo\n   spec:\n     parentRefs:\n     - name: bookinfo-gateway\n     rules:\n     - matches:\n       - path:\n           type: Exact\n           value: \/productpage\n       - path:\n           type: PathPrefix\n           value: \/static\n       - path:\n           type: Exact\n           value: \/login\n       - path:\n           type: Exact\n           value: \/logout\n       - path:\n           type: PathPrefix\n           value: \/api\/v1\/products\n       backendRefs:\n       - name: productpage\n         port: 9080\n   EOF\n   \u0060\u0060\u0060\n\n7. 在 Cloudflare 中配置域名记录：将网关服务的外网 IP 及域名 \u0060bookinfo.jimmysong.io\u0060 添加到 Cloudflare 的 DNS 记录中就可以实现域名解析。\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本实验中发现网关 Pod 并没有挂载 \u0060bookinfo-tls\u0060  Secret 中的证书，我们只好通过 Cloudflare 来配置 TLS 证书：为网站开启全（严格）SSL\/TLS，这将使用 Cloudflare 颁发的 TLS 证书。\n\n   {{\u003c\/callout\u003e}}\n\n8. 在浏览器中访问 \u003chttps:\/\/bookinfo.jimmysong.io\/productpage\u003e 就可以访问 bookinfo 应用了。\n\n## 总结 {#summary}\n\n本次实验虽然实现了网关的 TLS 加密，也为网关生成了 TLS 证书，但实际上网关使用的是 Cloudflare 颁发的证书。这并不是我们最初的目标，即使用 ACME Server（Let\u0027s Encrypt）为网关颁发的证书。为什么网关 Pod 没有挂载我们应用的 Secret 中的证书，Cloudflare DNS01 Challenge Provider 为什么没有生效，这两个问题还需要我们进一步调查。\n\n## 参考 {#reference}\n\n- [Acquire SSL Certificates In Kubernetes From Let’s Encrypt With Cert-Manager - thinktecture.com](https:\/\/www.thinktecture.com\/en\/kubernetes\/ssl-certificates-with-cert-manager-in-kubernetes\/)\n- [How To Secure Kubernetes NGINX Ingress With Cert-Manager](https:\/\/getbetterdevops.io\/k8s-ingress-with-letsencrypt\/)\n- [Securing gateway.networking.k8s.io Gateway Resources - cert-manager.io](https:\/\/cert-manager.io\/docs\/usage\/gateway\/)\n', '\/blog\/secure-ingress-gateway-of-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文就将使用 Let&#39;s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/">[译] 如何通过服务网格增强微服务的安全性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何通过服务网格增强微服务的安全性', '我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。', '\n本文是 Tetrate 即将出版的《Istio in Production》一书中摘录的服务网格最佳实践系列的第一篇，作者是 Tetrate 创始工程师 Zack Butcher。\n\n我们接到许多实施网格的企业的问题，其中之一是“我还需要哪些控制，而网格提供哪些控制？”换句话说，他们想知道网格如何适应现有的安全模型。我们发现，网格最适合作为一组安全控制的内圈，这些控制从物理网络到应用本身的每一层都被实施。\n\n## 服务网格作为通用策略执行点\n\n我们看到网格的 Sidecar 作为通用策略执行点（[NIST SP 800-204B：使用服务网格的基于属性的访问控制](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)）。由于它拦截了所有进出应用程序的流量，Sidecar 为我们提供了一个强大的位置来实现各种策略。我们可以实现传统的安全策略，如基于应用程序标识而非网络位置的更高保证的应用程序之间的授权。但我们也可以实施之前不切实际或需要与应用程序深度参与的策略。例如，网格允许你编写以下策略：“后端可以从数据库读取（使用应用级身份进行身份验证和授权），但前提是请求具有有效的最终用户凭证并具有读取范围（使用最终用户身份进行身份验证和授权）。”\n\n虽然服务网格提供了一个强大，动态和一致的安全基线，你可以在其上构建应用程序安全模型，但网格本身永远无法提供应用程序所需的 100% 运行时安全。例如，由于 Sidecar 位于用户空间中，网格在减轻许多类型的网络拒绝服务攻击方面不如传统防火墙机制。另一方面，由于同样的原因，网格在减轻许多应用级拒绝服务攻击方面比传统基础设施更有效。\n\n## 作为一个强大的中间层\n\n网格作为基础架构的强大中间层：位于物理网络和所实施的 L3\/L4 控制之上，但位于应用程序之下。这允许更脆弱和更难以改变的松散配置 —— 允许更高层的更大敏捷性 —— 因为控制体系在更高层被考虑。\n\n![图 1：增加细粒度策略层以增强传统安全。](f1.png)\n\n网格提供的主要安全功能是：\n\n- 作为 X.509 证书的**运行时身份**，用于在传输期间加密，以及服务之间通信的身份验证和授权。\n- **策略执行点**，用于在网格中的所有应用程序上实施一致的最终用户身份验证和授权。\n- 服务身份和最终用户身份的**运行时策略执行**（例如，“A 只能使用具有读取范围的有效最终用户凭证与 B 进行通信”）。\n- **速率限制和弹性功能**，用于减轻常见的应用级拒绝服务攻击，并保护免受常见的级联故障模式的影响。\n- **WAF** 和其他**深层包检测**功能，用于内部流量，而不仅仅是在边缘。\n- 来自网格中所有应用程序的**一致的操作遥测**，可用于理解、实施和审核安全策略。\n- 具有动态运行时更新的**策略即代码**（Policy-as-code）模型，独立于应用程序生命周期。\n\n## 服务网格作为分层防御的一部分\n\n考虑到网格的安全功能，我们认为，组织采用它作为分层防御方法的一部分是最合理的。\n\n![图 2：每层策略的示例以及一个示例部署拓扑。](f2.png)\n\n## L3 层的敏捷性：粗粒度的入口和出口策略以及 L7 的细粒度控制\n\n在边缘的 L3 控制（如防火墙）在粗粒度的入口和出口策略方面仍然有效，但通常会减慢应用程序开发敏捷性。由于网格提供了细粒度的服务间授权，所以可以在 L3 上设置更广泛的策略，为平台、安全和应用程序团队提供更多敏捷性。\n\n**实施对外部服务的访问控制**。网格的出口代理特别适用于实施应用程序到外部服务的控制，而只有出口代理本身被外出防火墙 allow-listed：这为平台或安全团队在管理哪些应用程序允许与企业基础架构之外的通信提供了很多敏捷性，同时保持现有的基于周界的模型。\n\n**使用加密和动态访问控制代替“可达性即授权”**。网格可以开始有效地取代 VPN 和基于 IPSec 的网络“可达性即授权”模式，提供传输中的加密，以及每个应用而不是每个主机的认证和授权。\n\n## L4 层的改进：更扁平和易于管理的网络微分段\n\n微分段之类的控制可以通过网格进一步改进：尽管我们可能允许整个（小）子网在基于分段的策略中进行通信，但我们可以使用网格按方法和动词对单独的服务间通信进行控制。\n\n**补充现有的微分段同时展平网络**。通过提供细粒度的服务间控制，网格往往会补充现有的微分段策略，同时使得组织更容易管理的较平的网络得以采用（例如，在云环境中）。\n\n**使用工作负载身份启用传输期间的加密（mTLS）和服务级别访问控制**。传输层几乎总是处理加密传输，网格通过根据 SPIFFE 规范发布和轮换短期（\u003c24 小时）工作负载身份证书来为应用程序实现此功能，从而允许传输期间的加密以及服务级别的身份验证和授权。\n\n## L7 层的增强：无处不在的边缘和访问控制\n\n**为所有流量提供边缘控制**。L7 控制，如 Web 应用程序防火墙（WAF）以及“API 网关功能”（如流量限制）几乎总是在边缘实施。网格可以通过为网格中所有流量（包括内部的“东西”通信）启用相同的功能来增强这些现有部署。\n\n**简化应用程序的访问控制**。除了使边缘控制无处不在之外，网格还可以在应用程序看到请求之前执行端用户身份验证和粗粒度授权，从而大大简化应用程序本身必须执行的访问控制。在未来，我们将看到越来越多的访问控制功能从应用程序迁移到网格中。\n\n## 总结和展望\n\n我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。作为一个通用策略执行点，网格在更改最困难的较低层提供了更松散的策略，将敏捷性推向堆栈的顶部，其中更多的上下文允许在更高层实现更特定的控制。这种强大的安全层对于大多数组织来说都是采用分层防御深度方法的最佳选择。\n\n## 接下来：服务网格部署最佳实践\n\n我们服务网格最佳实践系列博客文章的下一篇将讨论部署拓扑。在多个集群的真实基础架构中部署服务网格时存在一些移动部分。在下一篇文章中，我们将更详细地研究：\n\n- 控制平面应如何部署在应用程序附近。 \n- 应该如何部署入口，以促进安全和敏捷性。\n- 如何使用 Envoy 促进跨集群的负载平衡。\n- 证书在网格中应该是什么样子的。\n\n---\n\n如果你不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供了一系列免费在线课程，可以让你快速了解 Istio 和 Envoy。\n\n如果你正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为你知道你有一个值得信赖的发行版，有一个支持你的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，你可能需要更简单的方法来管理和保护你的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。你可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n', '\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/4/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/6/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(83)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/napkin-ai-visualization-tool/">AI 工具推荐 Napkin.ai：让复杂想法一键变成直观图表</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cilium-annual-report-2024/">Cilium 2024 年度报告解读</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-packet-lifecycle-optimization/">Istio Ambient 模式中的数据包生命周期及流量优化</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
