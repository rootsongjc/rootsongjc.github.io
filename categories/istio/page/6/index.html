<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/optimize-traffic-management-and-security-with-these-service-mesh-best-practices/">[译] 服务网格安全性优化最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/02/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/optimize-traffic-management-and-security-with-these-service-mesh-best-practices/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格安全性优化最佳实践', '本文推荐了服务网格安全性优化的一些最佳实践。', '\n这是 [服务网格最佳实践系列文章](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 中的第三篇，摘自 Tetrate 创始工程师 Zack Butcher 即将出版的新书 Istio in Production。\n\nIstio 就像一组乐高积木：它具有许多功能，可以按照你想要的任何方式进行组装。出现的结构取决于你如何组装零件。在 [上一篇中](..\/service-mesh-deployment-best-practices-for-security-and-high-availability\/)，我们描述了一种运行时拓扑结构，用于构建健壮、有弹性且可靠的基础架构。在本文中，我们将描述一组网格配置，以帮助在运行时实现稳健性、弹性、可靠性和安全性。\n\nIstio 在其所谓的 [根命名空间](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-root_namespace) 中支持全局默认配置 —— 默认在 \u0060istio-system\u0060。在根命名空间中发布的配置默认适用于所有服务，但在本地命名空间中发布的任何配置都会覆盖它。因此，一些配置应该在根命名空间中发布，并且不允许在其他任何地方发布（例如用于在传输中强制加密的 PeerAuthentication 策略）。其他配置应该在每个服务自己的命名空间中编写（例如 VirtualService 控制它的弹性设置）。\n\n我们看到的最成功的网格采用将网格本身隐藏在另一个界面后面：例如 Helm 模板、Terraform 或更高级的解决方案，例如 [Tetrate Service Bridge (TSB)](https:\/\/tetrate.io\/tetrate-service-bridge\/)。核心思想是只公开应用程序开发人员应该配置的一小部分网格功能，最好是使用他们理解的语言（例如，TSB 可以使用 [带注释的 OpenAPI 规范](https:\/\/docs.tetrate.io\/service-bridge\/1.6.x\/en-us\/quickstart\/apps) 进行配置）。首先，我们通常只向应用程序开发人员公开流量设置和授权。身份验证和遥测由各自的团队或代表他们的平台团队集中控制。[NIST SP800-204 系列](https:\/\/tetrate.io\/blog\/nist-standards-for-zero-trust-the-sp-800-204-series\/)，尤其是 [SP 800-204A](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204a\/final) 和 [SP 800-204B](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)。Istio 项目站点也有一组 [最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/)，也值得收藏。\n\n## 服务网格命名约定\n\n**建议**：为 Istio 资源开发和维护一致的命名方案，最好基于它们配置的服务或主机。\n\n**建议**：为跨集群的团队保持一致的名称。命名空间应该由一个团队拥有。\n\nIstio 资源应该根据它们配置的服务或主机来命名：\u0060ServiceEntry\u0060 添加 \u0060api.example.com\u0060 到网格的应该命名为 \u0060external-api-example-com\u0060；服务的 \u0060DestinationRule\u0060、\u0060VirtualService\u0060、\u0060PeerAuthentication\u0060 和 \u0060Authorization\u0060 策略也都应该有相同的名称。PCI 命名空间中的内部服务 Payments（应用程序代码中的 hostname \u0060payments.pci\u0060）应该被命名为 \u0060payment-pci\u0060，其所有的网格配置名称也应该匹配。这些命名方案并不是硬性规定，但你应该在你的组织内建立并坚持一个一致的惯例。\n\n这些资源应该全部发布在它们配置的服务的命名空间中，或者发布在 \u0060istio-system\u0060 命名空间中以进行网格范围的配置。外部服务通常发布到 \u0060istio-system\u0060 中并由中心团队（平台或安全团队）管理。\n\n我们建议跨集群的团队使用一致的名称：无论集群租户模型如何，命名空间都应由单个团队拥有（请参阅下一节）。\n\n## 服务网格全局设置\n\n**配置可见性**。Istio 有一个配置可见性的想法：配置可以默认应用于整个集群，或者它可以只应用于本地命名空间，甚至可以只应用于单个服务（选择对整个集群可见，或者只是特定的命名空间）。为了性能和安全，你应该将该字段默认为 \u0060exportTo\u0060 本地名称空间（“.”）。你应该在安装时为 [*Services*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_service_export_to)、[*VirtualServices*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_virtual_service_export_to) 和 [*DestinationRules*](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_destination_rule_export_to) 设置这个默认值。查看 Istio 的 [全局配置](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-default_service_export_to) 来配置这些默认值：\n\n\u0060\u0060\u0060yaml\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n name: controlplane\n namespace: istio-system\nspec:\n # profile: default\n # ...\n meshConfig:\n   defaultServiceExportTo:\n   - \u0022.\u0022# only the namespace the resource is published in\n   defaultVirtualServiceExportTo:\n   - \u0022.\u0022\n   # equivalent, just different YAML syntax\n   defaultDestinationRuleExportTo: [\u0022.\u0022]\n\u0060\u0060\u0060\n\n示例 1：默认全局设置\n\n**每个命名空间的 Sidecar 资源配置**。Istio 的 \u0060Sidecar\u0060 （API）资源控制 Istio 将哪些配置发送到每个命名空间中的 Sidecar。为了获得最佳性能和最低开销，你应该为每个命名空间管理一个配置，并管理 egress 部分以仅包括服务必须与之通信的主机。这将导致 Istio 向该命名空间中的 Envoy 实例发送更少的配置，从而减少它们的内存和 CPU 消耗。结合仅注册表出站流量策略（见下一条），Sidecar 资源还可以帮助限制攻击者通过 Envoy 的表面区域，因为不在 Sidecar 的 egress 部分的主机将是该 Envoy 实例的 \u0022出站流量\u0022。这本身并不是一个足够的安全策略（见下面的安全部分），而是增加了一个攻击者必须穿越的额外防御层。\n\n**编写明确的出站（egress）流量策略**。Istio 提供了一些选项来配置它如何处理网格中的服务，该服务试图与 Istio 未知的端点进行通信：[Outbound Traffic Policy](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-OutboundTrafficPolicy-Mode)。Istio 可以允许所有流量，也可以将流量限制在网格已知的服务上。你应该在安装时配置 Istio，只允许连接到注册表中的服务。此外，你应该将所有需要与之通信的外部服务建模为 Mesh 中的 ServiceEntries（例如，SaaS 服务的 DNS 解析等），使用 DestinationRules 来配置与它们通信的 TLS。这些外部服务应该由安全团队集中管理，或者由平台团队代表他们管理。\n\n## 运行时流量管理配置\n\n**为服务使用一致的全局名称，并使用 Istio 将它们映射到本地实例**。你应该使用一致的全局名称来访问服务。你可以使用 Istio 将这些全局名称映射到本地实例。例如，\u0060payments.tetrate.internal\u0060 可以被所有内部应用程序使用，而 Istio 可以用来将该名称映射到服务实例，例如“在 \u0060us-east-2\u0060 Kubernetes 集群中的 \u0060payments.default.svc.cluster.local\u0060 服务”。这种全局命名方案使开发人员可以像 SaaS 一样考虑所有服务，而无需仔细考虑运行时拓扑的细节，并且可以轻松地执行故障转移、金丝雀和跨集群路由等操作，作为你的网格使用成熟或组织需求演变。\n\n**在根配置中定义粗略的默认弹性设置**。你应该为网格中的所有服务定义粗略的超时、重试、熔断和异常值检测设置。你可以在根配置命名空间中使用 \u0060VirtualService\u0060 来实现此目的。各个团队应在其本地命名空间中指定自己的名称以覆盖默认值。\n\n**为应用程序团队提供简化的“低 \/ 中 \/ 高”弹性设置**。将网格的底层 API 隐藏在更高级别接口后面的系统中，为配置默认断路和异常值检测设置的应用程序开发人员提供简化的“低 \/ 中 \/ 高”旋钮很有价值，因为很多领域容易配置错误，导致该应用程序性能不佳。\n\n## 运行时安全配置\n\n以下安全建议来自我们为微服务应用程序建立美国安全标准的工作，该标准由美国国家标准与技术研究院（NIST）在 [SP 800-204 系列](https:\/\/tetrate.io\/blog\/nist-standards-for-zero-trust-the-sp-800-204-series\/) 中发布。[你可以在我们的综合指南](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/) 中阅读 NIST 针对微服务应用程序的所有安全建议。\n\n**最小控制**。运行时的零信任至少需要以下五个控制：\n\n1. **加密传输中的所有内容**：提供消息真实性和窃听保护（[SP 800-204，§MS-SS-4](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n2. **验证服务到服务的通信**：每个应用程序都应验证与之通信的应用程序的身份（[SP 800-204A，§SM-DR16；SP 800-204B，§APE-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n3. **授权服务到服务访问**：每个应用程序都应使用其运行时身份授权与之通信的应用程序（[SP 800-204B，§SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n4. **验证最终用户身份**：每个请求都必须在服务调用图中的每个跃点进行身份验证（[SP 800-204B，§EAUN-SR-1，§EUAZ-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n5. **授权最终用户访问资源**：对每种资源的每次访问都应获得授权，而不仅仅是在前门访问一次（[SP 800-204B，§EAUZ-SR-3](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\nIstio 提供传输中的加密（我们在上面讨论了全局启用），以及可验证的服务身份 ([SPIFFE](https:\/\/tetrate.io\/blog\/why-would-you-need-spire-for-authentication-with-istio\/) ) 和服务到服务的访问控制 (Istio \u0060AuthorizationPolicy\u0060)。此外，它可以配置为代表应用程序（JWT、OIDC 令牌）验证某些形式的最终用户身份，最后 Istio 支持可插拔授权系统（Envoy 的 \u0060ext_authz\u0060）以强制最终用户访问资源。\n\n**安装限制性默认授权策略**。根据 [Istio 最佳实践](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/#use-default-deny-patterns)，你应该安装一个不允许流量的默认授权策略，为每个服务发布对象创建 \u0060AuthorizationPolicy\u0060 对象以管理允许它们与之通信的对象（[SP 800-204B，SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。有助于实现这一目标的两个授权策略：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: deny-all-audit\n  namespace: istio-system\nspec:\n  action: AUDIT\n\u0060\u0060\u0060\n\n示例 2：\u0060IstioAuthorizationPolicy\u0060会拒绝所有流量，并审计记录它。你可能会运行这样的策略几周，以了解在启用强制执行之前你需要的策略。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: deny-all\n  namespace: istio-system\nspec:\n  {} # or action: ALLOW\n\u0060\u0060\u0060\n\n示例 3：拒绝所有流量的 Istio AuthorizationPolicy。或者，你可以创建一个允许但具有空规则集的策略，这与空主体相同。\n\n**默认情况下需要 mTLS 进行服务到服务通信**。通过在由安全或平台团队管理的根命名空间中配置 \u0060PeerAuthentication\u0060 资源，应将传输中的加密设置为严格（即 [需要 mTLS 才能与服务通信](https:\/\/tetrate.io\/blog\/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture\/)）。网格外部的服务调用网格中的应用程序应该通过应用程序入口网关进行通信，它可以向外部服务提供简单的 TLS（甚至明文），因为它不太可能有证书来对网格执行 mTLS。网格内部的服务呼出应配置为使用简单的 TLS 或明文，并带有用于外部服务的 DestinationRule 的明文 ([NIST SP 800-204A, §SM-DR8](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/) )。\n\n**TLS 配置默认值**。Istio 开箱即用，具有良好的 TLS 设置（[TLS 最低版本 1.2，具有一组有限的密码套件](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#mutual-tls-authentication)），但你可能需要根据你的环境对其进行调整（例如，在 [FedRAMP](https:\/\/www.fedramp.gov\/) 环境中遵守 [FIPS 140-3](https:\/\/csrc.nist.gov\/publications\/detail\/fips\/140\/3\/final) ）：\n\n- Envoy 支持通过配置 [网关](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings-cipher_suites) 为每个服务配置最低 TLS 版本和一组受支持的密码套件。\n- 如果可能，我们建议将 **TLS 1.3 作为最低版本** 执行（如果你只执行 mTLS Envoy-to-Envoy），并为需要较旧或安全性较低的 TLS 配置的外部流量使用网关。\n\n**为每个服务分配一个唯一的运行时身份，以促进表达性强、细粒度的授权策略并限制暴露于攻击**。为你正在部署的每个服务分配一个唯一的运行时标识。在 Kubernetes 中，不要在每个命名空间中使用默认的 Kubernetes 服务帐户，而是为每个命名空间中的每个服务分配一个唯一的服务帐户。授权策略只能在身份的粒度上轻松管理。当多个运行时组件共享相同的身份时，很难管理一个访问控制策略来表达你的预期访问权限，同时不允许使用共享身份的某些组件进行过于广泛的访问。这导致更大的表面积暴露给可能危及系统的一个组件的攻击者（[NIST SP 800-204A §SM-DR11，§SM-DR18](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\n**将服务到服务的通信限制在本地命名空间**。默认情况下，服务间通信应限制在本地名称空间内。不幸的是，这不能写为根配置命名空间中的单个 AuthorizationPolicy。相反，可以将仅允许在本地命名空间中访问的默认 AuthorizationPolicy 模板化为默认值，并且应允许应用程序团队编写他们自己的更专业（受限）的策略（[NIST SP800-204B，§SAUZ-SR-1](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)）。\n\n## 下一步\n\n我们希望从我们多年帮助客户构建成功的服务网格实践的经验中获得的这些最佳实践将有助于促进你的部署。如果你还没有，请查看服务网格最佳实践系列中的其他帖子： \n\n- [第 1 部分：如何将服务网格作为安全模型的一部分，以分层形式将微服务安全与传统安全结合起来](\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/)\n- [第 2 部分：服务网格安全性和高可用性部署最佳实践](\/trans\/service-mesh-deployment-best-practices-for-security-and-high-availability\/)\n\n如需全面了解 NIST 微服务安全标准，请 [下载我们的免费指南](https:\/\/tetrate.io\/tetrates-guide-to-federal-security-requirements-for-microservices\/)。\n\n### 接下来：多租户的服务网格最佳实践\n\n在我们关于服务网格最佳实践系列的下一篇文章中，我们将讨论我们看到客户正在努力解决的常见租赁决策点，并重点关注网格如何帮助促进这些决策。我们将涵盖的主题包括 Kubernetes 集群所有权、命名空间所有权、配置所有权，以及如何使用服务网格应用程序网关来缓解中断。\n', '\/trans\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文推荐了服务网格安全性优化的一些最佳实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/service-mesh-deployment-best-practices-for-security-and-high-availability/">[译] 服务网格安全性和高可用性部署最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/service-mesh-deployment-best-practices-for-security-and-high-availability/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('服务网格安全性和高可用性部署最佳实践', '本文强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。', '\n这是 [服务网格最佳实践系列文章](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 中的第二篇，摘自 Tetrate 创始工程师 Zack Butcher 即将出版的书籍 Istio in Production。\n\n当涉及到在多集群的基础设施中部署服务网格时，有一些可移动的部分。这里主要想强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。\n\n## 使服务网格控制平面与故障域保持一致\n\n**建议：围绕故障域部署松散耦合的控制平面以实现高可用性。**\n\n构建高可用性系统可能具有挑战性，而且通常成本很高。我们知道的一种经过验证的技术是围绕故障域构建。故障域是当关键系统发生故障时受影响的基础架构部分。我们构建可靠系统的基本方法是将系统跨越的故障域分组为多个独立的孤岛。最终系统的整体可靠性取决于我们可以使孤岛的独立程度。实际上，总是存在一些相互依赖性，将其最小化总是成本与可用性的权衡。\n\n在没有耦合故障域的情况下创建隔离孤岛的最简单方法是在每个孤岛中运行关键服务的独立副本。我们可以说这些副本是筒仓的本地副本 —— 它们共享相同的故障域。在云原生架构中，Kubernetes 集群形成了最自然的筒仓边界。Istio 是一项关键服务，因此我们在每个应用程序集群中运行一个 Istio 控制平面实例。换句话说，我们部署 Istio 使其故障域与你的应用程序的故障域保持一致。\n\n此外，我们确保 Istio 控制平面实例是松散耦合的，不需要直接与其他集群通信，从而最大限度地减少其与孤岛外部的通信。有关如何实现此目的的详细信息，请参阅下面的多集群部分。\n\n## 使用应用程序入口网关隔离每个应用程序的流量\n\n**建议：从每个应用程序或应用程序团队的网关（应用程序入口网关）开始，以帮助缓解共享中断。随着时间的推移你操作经验的增加，将应用程序入口合并到共享网关以优化成本。**\n\n虽然 Istio 默认附带共享 \u0060istio-ingressgateway\u0060，但我们不建议使用共享网关。大多数采用网格的团队都需要时间来构建实施共享网关模型所需的审查实践和操作，而没有共享中断的风险。特别是在 Istio 实施的早期，我们建议每个团队部署一个 Envoy 网关。我们称这些为应用程序入口网关。随着你获得操作经验，你可以开始将应用程序合并到共享网关上以优化成本。\n\n使用共享网关模型实现每个团队隔离的捷径是为每个团队分配一个单独的主机名。按主机名隔离的团队可以更安全地配置共享网关实例。然而，其他共同命运的中断风险仍然存在，例如入口代理部署的错误配置、嘈杂的邻居消耗资源和增加所有应用程序的延迟等。根据我们的经验，每个团队一个网关的方法会产生最快的影响，并且失败的机会最少，并且总体成本相对较低。\n\n我们期望成熟部署的最终状态是 80-20 的比例：大多数应用程序将通过共享网关接收流量，而一小部分高度关键或敏感的应用程序将保留专用网关。\n\n## 使用应用程序边缘网关在多个集群之间分配入口流量\n\n**建议：使用应用程序边缘网关为客户端提供单一地址，以供客户端使用并将流量分配到跨多个集群的应用程序入口网关。**\n\n![图 1：基于 Envoy 的应用程序边缘网关。](f1.png)\n\n我们经常看到客户需要跨多个集群分配入口流量。例如，他们可能希望启用蓝 \/ 绿基础设施升级，以促进跨区域故障转移，或者通过使用 Envoy 的 L7 功能将流量从单体迁移到微服务来实现扼杀模式。我们称这些为应用程序边缘网关。\n\n为了实现这个用例，我们将部署 Envoy—— 在专用的 Kubernetes 集群中或作为一组虚拟机 —— 来接收外部流量。这些 Envoy 实例将通过其 Kubernetes 入口或 VM VIP 将流量转发到你的应用程序。这与 ingress-per-team 方法协同工作：多集群网关为客户端提供一个单一地址以供使用，根据你的基础设施需要提供尽可能多的应用程序网关和集群。\n\n虽然此网关确实存在共享故障域，但其配置远比每个应用程序一个入口网关的配置简单。因此，作为共享基础架构运行起来更容易，也更安全。每个集群都有一个应用程序入口网关的共享应用程序边缘网关是一种强大而灵活的模型，用于在网格上部署和操作应用程序，还可以更轻松地操作底层基础设施。\n\n## 证书和公钥基础设施 (PKI) 的建议\n\n**建议：从你现有的企业根目录为网格 mTLS 创建一个中间签名证书。**\n\nIstio 使用常规 X.509 证书进行身份验证并在网格中启用传输加密。我们建议为现有企业根目录中的所有网格 mTLS 创建一个网格中间签名证书。如果每个环境都有一个根，请为每个环境创建一个网格中间签名证书。使用该网格中间颁发证书为每个 Istio 安装创建一个签名证书。我们建议创建一个网格中间签名证书，以便在任何特定环境中网格的整个 PKI 是一棵树，如果需要可以一起失效。成本是一些额外的证书管理，与控制平面签名证书相比，在管理网格中间签名证书的生命周期时需要更加小心。\n\n![图 2. Tetrate 推荐的将网格与现有 PKI 集成的方法：在环境（如 prod）中为 Istio 生成中间签名证书，使用它向该环境中的每个 Istio 控制平面实例颁发签名证书，并让 Istio 像往常一样向每个集群中的所有 pod 颁发工作负载（叶）证书。](f2.png)\n\nIstio 监视文件系统，并在检测到文件更改时重新加载其签名证书。因此，只要你有一个批准的机制来将秘密加载到 *istiod* pod 的文件系统中 —— 比如 *cert-manager*、Vault 的 *init-agent* 或 sidecar，或者只是存储在加密 *etcd* 中的普通旧 Kubernetes Secret—— 集成 Istio 进入你的 PKI 应该很容易。控制平面签名证书的轮换应由你的 PKI 自动执行。\n\nIstio 使用众所周知的密码学库：Istio 的内部 CA 使用 Golang 的密码学套件，Envoy（sidecar 和 ingress）使用 BoringSSL 进行证书验证和传输中的加密。通过 Tetrate 的开源 Istio 发行版 [Tetrate Istio Distro](https:\/\/tetr8.io\/tid) ，经过 FIPS 验证的控制平面和数据平面构建也作为 [Tetrate Istio 订阅](https:\/\/tetr8.io\/tis) 的一部分提供，因此你可能期望的所有 X.509 约束（基本约束，如 CA 和深度，开箱即用地支持和强制执行命名约束、策略约束等）。\n\n### 使用极短寿命的工作负载证书以轻松吊销\n\n**建议：使用 Istio 来自动化证书管理，以便设置极短的工作负载证书 TTL 变得切实可行，从而使 [证书撤销列表（CRL）](https:\/\/csrc.nist.gov\/glossary\/term\/certificate_revocation_list) 保持简短且易于管理。**\n\n在证书颁发和轮换（Istio 为你自动执行）之后，PKI 中最大的挑战是证书吊销。证书吊销是通过证书吊销列表实现的，通常 CRL 具有 24 小时的强制执行 SLA：添加到列表中的证书在吊销后最多 24 小时内可能会被基础设施视为有效。此外，由于吊销的证书必须在其整个生命周期 (TTL) 内保留在列表中，因此吊销列表会变得庞大而笨拙。\n\nIstio 提供的一个更好的解决方案是自动化证书管理，以便设置极短的工作负载证书 TTL 是切实可行的。默认情况下，Istio 附带 24 小时的工作负载证书 TTL。这足够短，大多数安全组织可以选择让受损的证书过期，而不是明确地撤销它们。而且，当你向 CRL 添加证书时，它只需要在那里停留很短的时间（因为我们不需要在 CRL 上保留过期的证书）。通过这种方式，网格有助于解决大多数组织面临的最痛苦的 PKI 问题：它颁发和吊销短期证书，这意味着吊销列表可以在需要时保持简短且易于管理。\n\n**注意**：由于网格使用 mTLS 证书作为身份，Istio 将 Envoy 配置为自动丢弃已建立的连接，以强制客户端和服务器在任何一方轮换证书时重新验证彼此。这是 Istio 实现中的设计决策，通常通过 Istio 的弹性功能对应用程序隐藏：对应用程序透明的自动重试重新建立连接。在网格中设置较短的证书 TTL 会强制这些重新连接更频繁地发生。值得注意的是，这种行为偶尔会中断一些期望长期 TCP 连接的应用程序。\n\n### 进一步的证书推荐\n\n你应该与你的安全团队协调，为你的网格颁发的证书建立适当的约束。我们推荐的一些常见约束如下。\n\n**证书生命周期 (TTL)**。请注意，只要证书是从同一个根颁发的，Istio 就支持控制平面签名证书和工作负载证书的零停机轮换。我们建议每个级别的证书生命周期如下：\n\n- 网格中间签名证书 1-3 年\n- 控制平面签名证书 3 个月\n- 工作负载证书需要 12-24 小时\n\nIstio 自动处理工作负载证书的轮换。这些证书上的短 TTL（少于 24 小时）有助于限制可能被盗的凭据进行时间限制攻击，还可以减少对 CRL 的需求。控制平面证书应按一个月的偏移轮换以确保平稳过渡 —— 换句话说，在 3 个月的 TTL 到期前 1 个月轮换控制平面签名证书。类似地，当网格中间签名证书还剩一半到三分之一的生命周期时轮换（一年 TTL 提前 3-4 个月，三年 TTL 提前 6-8 个月）。\n\n**基础（CA 和深度）**。控制平面签名证书应该只能颁发叶证书：用于工作负载识别的非签名证书。因此，应配置深度限制以防止控制平面签名证书颁发任何其他签名证书。\n\n网格中间签名证书需要创建控制平面签名证书，因此它应该配置一个深度，以便能够**在它下面创建一个级别的签名证书，而不是更多**。\n\n**名称约束**。Istio 颁发的工作负载证书不会填充 X.509 主体名称 (SN) 字段；网格身份验证依赖于作为主体备用名称 (SAN) 字段携带的 SPIFFE 身份。阅读 [SPIFFE 规范以获取有关验证和身份验证工作的信息](https:\/\/github.com\/spiffe\/spiffe\/blob\/main\/standards\/X509-SVID.md#4-constraints-and-usage)，以及 Istio 的 [文档](https:\/\/istio.io\/latest\/docs\/concepts\/security\/#istio-identity) 以了解 Istio 如何根据 SPIFFE 对身份进行编码。在为网格中间和控制平面签名证书编写名称约束时，请记住这一点。\n\n**密钥用法**。 \u0060keyCertSign\u0060 必须为网格中间签名证书和控制平面签名证书设置，但应为工作负载证书禁用。换句话说，网格中间和控制平面证书是签名证书，而工作负载证书不是。\n\n根据 SPIFFE 的建议，不应将签名证书用于传输中的加密，并且应配置密钥使用以防止它（通过加密约束）。\n\n**扩展密钥用法**。虽然此处没有具体要求，但 SPIFFE X.509 SVID 规范说明 \u0060id-kp-serverAuth\u0060 和 \u0060id-kp-clientAuth\u0060 应针对叶（工作负载）证书进行配置。\n\nSPIFFE 规范还推荐了 [各种证书约束](https:\/\/github.com\/spiffe\/spiffe\/blob\/main\/standards\/X509-SVID.md#4-constraints-and-usage)，尽管其中大部分上面已经约束了。\n\n## 下一步\n\n我们希望从多年帮助我们的客户充分利用服务网格的经验中收集的这些最佳实践将有助于促进你的部署。如果你还没有，请查看 [如何将服务网格作为安全模型的一部分，以分层形式将微服务安全与传统安全结合起来](\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) 这篇文章。\n\n接下来：服务网格运行时配置建议。在我们的下一篇文章中，我们将谈论：\n\n- 命名约定\n- 全局设置\n- 流量管理\n- 安全\n- 遥测\n\n敬请关注。\n', '\/trans\/service-mesh-deployment-best-practices-for-security-and-high-availability\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文强调的是控制平面应该如何部署在应用程序附近，入口应该如何部署以促进安全性和敏捷性，如何使用 Envoy 促进跨集群负载均衡，以及网格内部如何使用证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/secure-ingress-gateway-of-istio/">使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager ACME Issuer 为 Istio 中的入口网关设置证书', '本文就将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。', '\n本文将以 Bookinfo 应用为例，为 Istio 的入口网关设置一个真实的 TLS\/SSL 证书。我们将使用 Let\u0027s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。\n\n## 准备 {#prerequisite}\n\n请先参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/setup\/)安装 Istio 和 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，笔者在 GKE 中安装了 Istio 1.16。\n\n本文中安装的各组件版本信息如下：\n\n- Kubernetes 1.24.7\n- Istio 1.16\n- Gateway API 0.5.1\n- cert-manager 1.10.1\n\n## 架构 {#arch}\n\n本实验中包含以下关键组件：\n\n- 使用 Cloudflare 提供 DNS 解析\n- 使用 Let\u0027s Encrypt 创建证书\n- 使用 cert-manager 自动申请和续期证书\n- 使用 Gateway API 来创建入口网关\n- 所有组件部署在 GKE 中\n\n图 1 展示了本实验的架构以及流量路由过程。\n\n![图 1：Istio 入口网关证书挂载模式](arch.svg)\n\n流量路由过程如下：\n\n1. 在 Gateway 创建完成后通过 LoadBalancer 暴露网关 IP，将该 IP 配置在 DNS 解析记录中；\n2. Gateway 通过注解引用 [ACME Issuer](https:\/\/cert-manager.io\/docs\/configuration\/acme\/)；\n3. ACME Issuer 向 cert-manager 发送请求证书（[order 和 challenge](https:\/\/cert-manager.io\/docs\/concepts\/acme-orders-challenges\/)），并使用 [DNS01 Challenge Provider](https:\/\/cert-manager.io\/docs\/configuration\/acme\/dns01\/)；\n4. cert-manager 向 ACME 服务器 Let\u0027s Encrypt 请求证书并创建 Kubernetes Secret；\n5. 在 Gateway 中通过应用 Secret 挂载 TLS 证书；\n6. HTTPRoute 将入口流量路由到 productpage 服务；\n\n## ACME Issuer\n\nIstio 包含了开箱即用的 mTLS 支持，你也可以使用[自定义 CA](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/) 或 [SPIRE](\/blog\/cert-manager-spire-istio\/) 来管理集群内证书，但是对于入口网关的证书，就需要我们单独设置。你可以[手动为入口网关配置证书](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)，不过管理起来会比较麻烦，因为你需要负责证书的轮换以防止证书过期，或使用 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/) 这样的 ACME Issuer 来自动化管理证书。\n\nACME (Automated Certificate Management Environment) Issuer 是一种认证机构，可以使用 ACME 协议为客户端申请和管理证书。ACME 是一种用于自动化 SSL\/TLS 证书颁发和管理的开放协议。它通常用于网站或其他在线服务的证书管理，以确保安全连接。\n\nLet\u0027s Encrypt 是一个非营利性的 ACME Issuer，可以为网站提供免费的 SSL\/TLS 证书。它的目标是使加密技术普及化，并帮助提升网络安全水平。Let\u0027s Encrypt 使用 ACME 协议与客户端通信，可以为客户端申请和管理证书。ACME 协议是开放的，因此任何机构都可以成为 ACME Issuer，只要它们遵守 ACME 协议的规定。\n\n## 详细步骤 {#details-steps}\n\n1. 安装 Gateway API：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/github.com\/kubernetes-sigs\/gateway-api\/releases\/download\/v0.5.1\/standard-install.yaml\n   \u0060\u0060\u0060\n\n2. 安装 cert-manager\n\n   \u0060\u0060\u0060bash\n   kubectl apply -f https:\/\/gist.githubusercontent.com\/rootsongjc\/78487acdea70a3c27c1a1b794546d031\/raw\/0df08b91dfaff6412bbd891ccedffaa882a9a99f\/cert-manager.yaml\n   \u0060\u0060\u0060\n\n   它为 cert-manager Deployment 增加了以下启动项：\n\n   \u0060\u0060\u0060bash\n   args:\n     - --feature-gates=ExperimentalGatewayAPISupport=true\n   \u0060\u0060\u0060\n\n3. 在 Cloudflare 中创建一个名为 \u0060lets-encrypt-token\u0060 的 API token，自定义模板设置如下：\n\n   Permissions：\n\n   - \u0060Zone - DNS - Edit\u0060\n   - \u0060Zone - Zone - Read\u0060\n\n   Zone Resources:\n\n   - \u0060Include - All Zones\u0060\n\n   将该 token 存储在一个 Secret 中：\n\n   \u0060\u0060\u0060yaml\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: v1\n   kind: Secret\n   metadata:\n     name: cloudflare-api-token-secret\n     namespace: istio-system\n   type: Opaque\n   stringData:\n     api-token: \u003cAPI Token\u003e\n   EOF\n   \u0060\u0060\u0060\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本次实验中该 Token 实际上并没起到作用，正常情况下 cert-manager 会通过 Cloudflare API 与 Cloudflare 交互，为我们配置 DNS 记录。该问题还需要进一步排查。\n\n   {{\u003c\/callout\u003e}}\n\n4. 配置 Let\u0027s Encrypt  Issuer：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: cert-manager.io\/v1\n   kind: Issuer\n   metadata:\n     name: letsencrypt\n   spec:\n     acme:\n       email: rootsongjc@gmail.com\n       server: https:\/\/acme-v02.api.letsencrypt.org\/directory\n       privateKeySecretRef:\n         name: lets-encrypt-issuer-account-key\n       solvers:\n       - dns01:\n           cloudflare:\n             apiTokenSecretRef:\n               name: cloudflare-api-token-secret\n               key: api-token\n         selector:\n           dnsNames:\n           - \u0027bookinfo.jimmysong.io\u0027\n   EOF\n   \u0060\u0060\u0060\n\n5. 配置 Gateway：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: Gateway\n   metadata:\n     name: bookinfo-gateway\n     annotations:\n       cert-manager.io\/issuer: letsencrypt\n   spec:\n     gatewayClassName: istio\n     listeners:\n     - name: http\n       hostname: bookinfo.jimmysong.io\n       port: 443\n       protocol: HTTPS\n       allowedRoutes:\n         namespaces:\n           from: Same\n       tls:\n         mode: Terminate\n         certificateRefs:\n           kind: Secret\n           group: \u0022\u0022\n           name: bookinfo-tls\n   EOF\n   \u0060\u0060\u0060\n\n   在 Gateway 创建完成后，会在 default 命名空间中创建一个网关 Pod 以及 LoadBalancer 资源的服务。\n\n   查看 \u0060default\u0060 命名空间中的 Secret，你会发现 \u0060bookinfo-tls\u0060，它是由 cert-manager 创建的，查看该 Secret 中保存的证书，你将会看到由 Let\u0027s Encrypt 颁发的证书信任链：\n\n   - \u0060bookinfo.jimmysong.io\u0060 \n   - \u0060ISRG Root X1\u0060\n   - \u0060DST Root CA X3\u0060\n\n6. 配置 HTTPRoute：\n\n   \u0060\u0060\u0060bash\n   kubectl apply -n default -f - \u003c\u003cEOF\n   apiVersion: gateway.networking.k8s.io\/v1beta1\n   kind: HTTPRoute\n   metadata:\n     name: bookinfo\n   spec:\n     parentRefs:\n     - name: bookinfo-gateway\n     rules:\n     - matches:\n       - path:\n           type: Exact\n           value: \/productpage\n       - path:\n           type: PathPrefix\n           value: \/static\n       - path:\n           type: Exact\n           value: \/login\n       - path:\n           type: Exact\n           value: \/logout\n       - path:\n           type: PathPrefix\n           value: \/api\/v1\/products\n       backendRefs:\n       - name: productpage\n         port: 9080\n   EOF\n   \u0060\u0060\u0060\n\n7. 在 Cloudflare 中配置域名记录：将网关服务的外网 IP 及域名 \u0060bookinfo.jimmysong.io\u0060 添加到 Cloudflare 的 DNS 记录中就可以实现域名解析。\n\n   {{\u003ccallout warning 注意\u003e}}\n\n   本实验中发现网关 Pod 并没有挂载 \u0060bookinfo-tls\u0060  Secret 中的证书，我们只好通过 Cloudflare 来配置 TLS 证书：为网站开启全（严格）SSL\/TLS，这将使用 Cloudflare 颁发的 TLS 证书。\n\n   {{\u003c\/callout\u003e}}\n\n8. 在浏览器中访问 \u003chttps:\/\/bookinfo.jimmysong.io\/productpage\u003e 就可以访问 bookinfo 应用了。\n\n## 总结 {#summary}\n\n本次实验虽然实现了网关的 TLS 加密，也为网关生成了 TLS 证书，但实际上网关使用的是 Cloudflare 颁发的证书。这并不是我们最初的目标，即使用 ACME Server（Let\u0027s Encrypt）为网关颁发的证书。为什么网关 Pod 没有挂载我们应用的 Secret 中的证书，Cloudflare DNS01 Challenge Provider 为什么没有生效，这两个问题还需要我们进一步调查。\n\n## 参考 {#reference}\n\n- [Acquire SSL Certificates In Kubernetes From Let’s Encrypt With Cert-Manager - thinktecture.com](https:\/\/www.thinktecture.com\/en\/kubernetes\/ssl-certificates-with-cert-manager-in-kubernetes\/)\n- [How To Secure Kubernetes NGINX Ingress With Cert-Manager](https:\/\/getbetterdevops.io\/k8s-ingress-with-letsencrypt\/)\n- [Securing gateway.networking.k8s.io Gateway Resources - cert-manager.io](https:\/\/cert-manager.io\/docs\/usage\/gateway\/)\n', '\/blog\/secure-ingress-gateway-of-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文就将使用 Let&#39;s Encrypt、cert-manager 来管理 Istio 中入口网关的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/">[译] 如何通过服务网格增强微服务的安全性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何通过服务网格增强微服务的安全性', '我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。', '\n本文是 Tetrate 即将出版的《Istio in Production》一书中摘录的服务网格最佳实践系列的第一篇，作者是 Tetrate 创始工程师 Zack Butcher。\n\n我们接到许多实施网格的企业的问题，其中之一是“我还需要哪些控制，而网格提供哪些控制？”换句话说，他们想知道网格如何适应现有的安全模型。我们发现，网格最适合作为一组安全控制的内圈，这些控制从物理网络到应用本身的每一层都被实施。\n\n## 服务网格作为通用策略执行点\n\n我们看到网格的 Sidecar 作为通用策略执行点（[NIST SP 800-204B：使用服务网格的基于属性的访问控制](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)）。由于它拦截了所有进出应用程序的流量，Sidecar 为我们提供了一个强大的位置来实现各种策略。我们可以实现传统的安全策略，如基于应用程序标识而非网络位置的更高保证的应用程序之间的授权。但我们也可以实施之前不切实际或需要与应用程序深度参与的策略。例如，网格允许你编写以下策略：“后端可以从数据库读取（使用应用级身份进行身份验证和授权），但前提是请求具有有效的最终用户凭证并具有读取范围（使用最终用户身份进行身份验证和授权）。”\n\n虽然服务网格提供了一个强大，动态和一致的安全基线，你可以在其上构建应用程序安全模型，但网格本身永远无法提供应用程序所需的 100% 运行时安全。例如，由于 Sidecar 位于用户空间中，网格在减轻许多类型的网络拒绝服务攻击方面不如传统防火墙机制。另一方面，由于同样的原因，网格在减轻许多应用级拒绝服务攻击方面比传统基础设施更有效。\n\n## 作为一个强大的中间层\n\n网格作为基础架构的强大中间层：位于物理网络和所实施的 L3\/L4 控制之上，但位于应用程序之下。这允许更脆弱和更难以改变的松散配置 —— 允许更高层的更大敏捷性 —— 因为控制体系在更高层被考虑。\n\n![图 1：增加细粒度策略层以增强传统安全。](f1.png)\n\n网格提供的主要安全功能是：\n\n- 作为 X.509 证书的**运行时身份**，用于在传输期间加密，以及服务之间通信的身份验证和授权。\n- **策略执行点**，用于在网格中的所有应用程序上实施一致的最终用户身份验证和授权。\n- 服务身份和最终用户身份的**运行时策略执行**（例如，“A 只能使用具有读取范围的有效最终用户凭证与 B 进行通信”）。\n- **速率限制和弹性功能**，用于减轻常见的应用级拒绝服务攻击，并保护免受常见的级联故障模式的影响。\n- **WAF** 和其他**深层包检测**功能，用于内部流量，而不仅仅是在边缘。\n- 来自网格中所有应用程序的**一致的操作遥测**，可用于理解、实施和审核安全策略。\n- 具有动态运行时更新的**策略即代码**（Policy-as-code）模型，独立于应用程序生命周期。\n\n## 服务网格作为分层防御的一部分\n\n考虑到网格的安全功能，我们认为，组织采用它作为分层防御方法的一部分是最合理的。\n\n![图 2：每层策略的示例以及一个示例部署拓扑。](f2.png)\n\n## L3 层的敏捷性：粗粒度的入口和出口策略以及 L7 的细粒度控制\n\n在边缘的 L3 控制（如防火墙）在粗粒度的入口和出口策略方面仍然有效，但通常会减慢应用程序开发敏捷性。由于网格提供了细粒度的服务间授权，所以可以在 L3 上设置更广泛的策略，为平台、安全和应用程序团队提供更多敏捷性。\n\n**实施对外部服务的访问控制**。网格的出口代理特别适用于实施应用程序到外部服务的控制，而只有出口代理本身被外出防火墙 allow-listed：这为平台或安全团队在管理哪些应用程序允许与企业基础架构之外的通信提供了很多敏捷性，同时保持现有的基于周界的模型。\n\n**使用加密和动态访问控制代替“可达性即授权”**。网格可以开始有效地取代 VPN 和基于 IPSec 的网络“可达性即授权”模式，提供传输中的加密，以及每个应用而不是每个主机的认证和授权。\n\n## L4 层的改进：更扁平和易于管理的网络微分段\n\n微分段之类的控制可以通过网格进一步改进：尽管我们可能允许整个（小）子网在基于分段的策略中进行通信，但我们可以使用网格按方法和动词对单独的服务间通信进行控制。\n\n**补充现有的微分段同时展平网络**。通过提供细粒度的服务间控制，网格往往会补充现有的微分段策略，同时使得组织更容易管理的较平的网络得以采用（例如，在云环境中）。\n\n**使用工作负载身份启用传输期间的加密（mTLS）和服务级别访问控制**。传输层几乎总是处理加密传输，网格通过根据 SPIFFE 规范发布和轮换短期（\u003c24 小时）工作负载身份证书来为应用程序实现此功能，从而允许传输期间的加密以及服务级别的身份验证和授权。\n\n## L7 层的增强：无处不在的边缘和访问控制\n\n**为所有流量提供边缘控制**。L7 控制，如 Web 应用程序防火墙（WAF）以及“API 网关功能”（如流量限制）几乎总是在边缘实施。网格可以通过为网格中所有流量（包括内部的“东西”通信）启用相同的功能来增强这些现有部署。\n\n**简化应用程序的访问控制**。除了使边缘控制无处不在之外，网格还可以在应用程序看到请求之前执行端用户身份验证和粗粒度授权，从而大大简化应用程序本身必须执行的访问控制。在未来，我们将看到越来越多的访问控制功能从应用程序迁移到网格中。\n\n## 总结和展望\n\n我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。作为一个通用策略执行点，网格在更改最困难的较低层提供了更松散的策略，将敏捷性推向堆栈的顶部，其中更多的上下文允许在更高层实现更特定的控制。这种强大的安全层对于大多数组织来说都是采用分层防御深度方法的最佳选择。\n\n## 接下来：服务网格部署最佳实践\n\n我们服务网格最佳实践系列博客文章的下一篇将讨论部署拓扑。在多个集群的真实基础架构中部署服务网格时存在一些移动部分。在下一篇文章中，我们将更详细地研究：\n\n- 控制平面应如何部署在应用程序附近。 \n- 应该如何部署入口，以促进安全和敏捷性。\n- 如何使用 Envoy 促进跨集群的负载平衡。\n- 证书在网格中应该是什么样子的。\n\n---\n\n如果你不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供了一系列免费在线课程，可以让你快速了解 Istio 和 Envoy。\n\n如果你正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为你知道你有一个值得信赖的发行版，有一个支持你的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，你可能需要更简单的方法来管理和保护你的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。你可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n', '\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cert-manager-spire-istio/">使用 cert-manager 和 SPIRE 管理 Istio 中的证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager 和 SPIRE 管理 Istio 中的证书', '本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。', '{{\u003ccallout warning\u0022注意\u0022\u003e}}\n\n从 v1.5.4 版本开始，SPIRE 移除了 Kubernetes Workload Registrar 组件，改用 SPIRE Controller Manager，详见 [spire\/spire issue #3853](https:\/\/github.com\/spiffe\/spire\/pull\/3853)。根据我的测试，本文中的程序在 v1.5.4 或更高版本上无法执行，因为会遇到一系列身份验证失败的问题。\n{{\u003c\/callout\u003e}}\n\n在[上一篇博客](\/blog\/istio-certificates-management\/)中我介绍了 Istio 中是如何管理证书的，这篇文章将指导你如何使用外置 CA，通过集成 [SPIRE](https:\/\/spiffe.io\/) 和 [cert-manager](https:\/\/cert-manager.io\/) 实现细粒度的证书管理和自动证书轮换。\n\n如果你还不了解什么是 SPIRE 以及为什么我们要使用 SPIRE，推荐你阅读以下内容：\n\n- [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n- [如何在 Istio 中集成 SPIRE？](\/blog\/how-to-integrate-spire-with-istio\/)\n- [零信任的基石：使用 SPIFFE 为基础设施创建通用身份](\/book\/spiffe\/)\n\n## 证书签发管理流程简介 {#intro}\n\n下图展示了本文中使用的基于 cert-manager 和 SPIRE 的证书信任链：\n\n![基于 cert-manager、SPIRE 的证书信任链](spire-chain-tree.svg)\n\n从图中你可以看出：\n\n- cert-manager 作为根 CA 为 *istiod* 和 SPIRE 颁发证书，我们使用了[自签名 Issuer](https:\/\/cert-manager.io\/docs\/configuration\/selfsigned\/)，你还可以为其配置使用 Let\u0027s Encrypt、Vault、Venafi 等内置 Issuer，或其他外置的 Issuer；另外你也可以选择使用其他 [UpstreamAuthority](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)，例如 Vault、SPIRE 联邦等；\n- SPIRE 为 Istio 网格内工作负载和 Ingress Gateway、Egress Gateway 颁发 SVID 证书，用于服务间 mTLS；\n- 其中网格外访问 Ingress Gateway 时的使用的证书及 Egress Gateway 访问网格外服务使用的证书需要额外配置；\n\n下图展示了在 Istio 中集成 SPIRE 和 cert-manger 后的证书颁发和更新流程。\n\n![Istio 集成 SPIRE 和 cert-manager 后的证书颁发和更新流程](cert-manager-spire-istio.svg)\n\n1. SPIRE Server 中的 SPIRE Controller Manager 自动注册 Kubernetes 中的工作负载，为所有工作负载生成 SPIFFE 标准的身份；\n2. cert-manager 为 *istiod* 颁发并管理 CA 证书；\n3. 工作负载中的 Envoy 代理通过 UNIX Domain Socket（UDS）通过 SDS API 向同节点上的 SPIRE Agent 发送 CSR 请求；\n4. SPIRE Agent 向 SPIRE Server 发送 CSR；\n5. SPIRE Server 向 SPIRE Agent 返回签名后的证书；\n6. SPIRE Agent 向工作负载返回签名后的证书；\n7. SPIRE 负责工作负载的证书管理和更新；\n\n在了解了大致流程后，下面我们将依次安装各个组件。各个组件版本如下：\n\n- cert-manager v1.15.1\n- SPIRE v1.2.0\n- Istio v1.21.1\n\n## 安装 cert-manager {#install-cert-manager}\n\n运行下面的命令安装 cert-manager，我们将使用它来实现自动证书轮换：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/cert-manager\/cert-manager\/releases\/download\/v1.15.1\/cert-manager.yaml\n\u0060\u0060\u0060\n\n根 CA 是用自签名证书，运行下面的命令配置根 CA：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Issuer\nmetadata:\n  name: selfsigned\n  namespace: cert-manager\nspec:\n  selfSigned: {}\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: selfsigned-ca\n  namespace: cert-manager\nspec:\n  isCA: true\n  duration: 21600h\n  secretName: selfsigned-ca\n  commonName: certmanager-ca\n  subject:\n    organizations:\n      - cert-manager\n  issuerRef:\n    name: selfsigned\n    kind: Issuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io\/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned-ca\nspec:\n  ca:\n    secretName: selfsigned-ca\nEOF\n\u0060\u0060\u0060\n\n然后为 *istiod* 配置证书：\n\n\u0060\u0060\u0060yaml\nkubectl create namespace istio-system\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 1440h\n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n现在我们已经安装好了 cert-manager，并创建了名为 \u0060selfsigned-ca\u0060 的 \u0060clusterIssuer\u0060，接下来，我们来安装 SPIRE 并将 cert-manager 作为 SPIRE 的  [\u0060UpstreamAuthority\u0060](https:\/\/github.com\/spiffe\/spire\/blob\/main\/doc\/plugin_server_upstreamauthority_cert_manager.md)。\n\n## 安装 SPIRE {#install-spire}\n\n运行下面的命令快速安装 SPIRE：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/jimmysong.io\/blog\/cert-manager-spire-istio\/manifests\/spire-with-cert-manager-upstream-authority-quick-start.yaml\n\u0060\u0060\u0060\n\n该 YAML 文件比起 Istio 安装包中的 [\u0060samples\/security\/spire\/spire-quickstart.yaml\u0060](https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.22\/samples\/security\/spire\/spire-quickstart.yaml) 文件增加了对 cert-manager 的适配，如：\n\n- 为 \u0060spire-server-cluster-role\u0060 ClusterRole 增加了对 \u0060cert-manager.io\u0060 API 组的权限；\n- 在 SPIRE Server 的配置中增加了 \u0060UpstreamAuthority \u0022cert-manager\u0022\u0060 配置； \n\n{{\u003ccallout note \u0022注意\u0022\u003e}}\n\nSPIRE Server 配置中的 \u0060trust_domain\u0060 应与安装 Istio 时指定的 \u0060TRUST_DOMAIN\u0060 环境变量的值保持一致。\n\n{{\u003c\/callout\u003e}}\n\n该命令中会安装 SPIRE Controller Manager，自动注册 Kubernetes 中的工作负载。所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式 \u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n如果你想调整 SPIRE CA 和 SVID 证书的 TTL，可以在 SPIRE Server 的配置中修改 \u0060ca_ttl\u0060（默认 24h）和 \u0060default_svid_ttl\u0060（默认 1h），详见 [SPIRE Server 配置](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)。\n\n## 安装 Istio {#install-istio}\n\nPod 中的 Envoy 代理将共享本地 SPIRE Agent 的 Unix Domain Socket，通过 Workload API 与 SPIRE Server 通信获取证书，如下图所示。\n\n![SPIRE Agent 架构图](spire-agent.svg)\n\n运行下面的命令安装 Istio 并启用 CA 证书自动轮换：\n\n\u0060\u0060\u0060yaml\nistioctl install --skip-confirmation -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\nspec:\n  profile: default\n  meshConfig:\n    # 信任域应与 SPIRE Server 中配置的信任域相同\n    trustDomain: example.org\n  values:\n    global:\n    # 自定义 sidecar 模板\n    sidecarInjectorWebhook:\n      templates:\n        spire: |\n          spec:\n            containers:\n            - name: istio-proxy\n              volumeMounts:\n              - name: workload-socket\n                mountPath: \/run\/secrets\/workload-spiffe-uds\n                readOnly: true\n            volumes:\n              - name: workload-socket\n                csi:\n                  driver: \u0022csi.spiffe.io\u0022\n                  readOnly: true\n  components:\n    pilot:\n      k8s:\n        env:\n          # 如果启用，如果用户引入新的中间插件 CA，用户不需要重新启动 istiod 来获取证书。Istiod 会获取新添加的中间插件 CA 的证书并更新它。不支持插入新的 Root-CA。\n          - name: AUTO_RELOAD_PLUGIN_CERTS\n            value: \u0022true\u0022 \n    ingressGateways:\n      - name: istio-ingressgateway\n        enabled: true\n        label:\n          istio: ingressgateway\n        k8s:\n          overlays:\n            - apiVersion: apps\/v1\n              kind: Deployment\n              name: istio-ingressgateway\n              patches:\n                - path: spec.template.spec.volumes.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    csi:\n                      driver: \u0022csi.spiffe.io\u0022\n                      readOnly: true\n                - path: spec.template.spec.containers.[name:istio-proxy].volumeMounts.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    mountPath: \u0022\/run\/secrets\/workload-spiffe-uds\u0022\n                    readOnly: true\nEOF\n\u0060\u0060\u0060\n\n因为我们要使用 Istio Operator 中声明的 \u0060spire\u0060 模板来部署工作负载，因此我们运行下面的命令部署 Bookinfo 应用：\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f bookinfo-with-spire-template.yaml | kubectl apply -n default -f -\n\u0060\u0060\u0060\n\n**注意**：上面命令中使用的 \u0060bookinfo-with-spire-template.yaml\u0060 文件可以在[这里](.\/manifests\/bookinfo-with-spire-template.yaml)找到，与 Istio 安装包中的 [\u0060samples\/bookinfo\/platform\/kube\/bookinfo.yaml\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml) 文件唯一的区别就是每个 Deployment 的 template 中都增加了以下注解：\n\n\u0060\u0060\u0060yaml\nannotations:\n  inject.istio.io\/templates: \u0022sidecar,spire\u0022\n\u0060\u0060\u0060\n\n## 验证 SPIRE {#validate-spire}\n\n我们将通过检查 productpage 服务的身份和证书配置来验证 SPIRE 是否生效。\n\n使用下面的命令可以检查 SPIRE 是否给工作负载颁发了身份证明：\n\n\u0060\u0060\u0060bash\nkubectl exec -i -t spire-server-0 -n spire -c spire-server -- \/bin\/sh -c \u0022bin\/spire-server entry show -socketPath \/run\/spire\/sockets\/server.sock -spiffeID spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\u0022\n\u0060\u0060\u0060\n\n你可以在输出结果中看到 protuctpage 服务的身份信息：\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 69fbf896-a296-4c3c-8179-44bf4e49e474\nSPIFFE ID        : spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\nParent ID        : spiffe:\/\/example.org\/k8s-workload-registrar\/demo-cluster\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nTTL              : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:default\nSelector         : k8s:pod-uid:73347537-a3e5-4e43-b8c5-bd315c7385b7\nDNS name         : productpage-v1-7f444fc4dd-rq47m\nDNS name         : productpage.default.svc\n\u0060\u0060\u0060\n\n查看 \u0060productpage\u0060 pod 的证书信任链：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n查看根证书：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n\u0060\u0060\u0060\n\n\u0060chain.pem\u0060 文件是证书信任链，其中包含两个证书，将它们保存到两个文件中：\n\n\u0060\u0060\u0060bash\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\n\u0060\u0060\u0060\n\n后使用 OpenSSL 查看所有证书：\n\n\u0060\u0060\u0060\nopenssl x509 -noout -text -in cert-aa\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in root.pem\n\u0060\u0060\u0060\n\n你将看到如下的证书信任链 \u0060root.pem\u0060 -\u003e \u0060cert-aa\u0060  -\u003e \u0060cert-ab\u0060，如下图所示：\n\n![Productpage 服务的证书信任链](spire-bookinfo-cert-chain.svg)\n\n查看 Istiod 的证书：\n\n\u0060\u0060\u0060bash\nistioctl -n istio-system proxy-config secret deployment\/istiod -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n从证书信任链中我们可以看到：\n\n- cert-manager 做为 PKI 的根节点为 *istiod* 颁发证书；\n- SPIRE 作为中间 CA 再为各个工作负载颁发证书；\n- Istio 网格中工作负载的 X509 v3 主体别名中的 URI 遵循了 SPIFF 身份规范；\n- Istio 服务网格中的所有工作负载的身份和证书都由 SPIRE 来管理；\n\n## 设置证书自动轮换 {#cert-auto-rotate}\n\n如果你要修改 *istiod* 证书的轮换周期，从 60 天（1440 小时）缩短到 30 天（720 小时），运行下面的命令：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 720h \n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n运行下面的命令查看 *istiod* 的日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -l app=istiod -n istio-system -f\n\u0060\u0060\u0060\n\n过两分钟后，你将看到类似如下的证书更改记录：\n\n\u0060\u0060\u0060\n2022-12-23T03:48:42.697360Z\tinfo\tUpdate Istiod cacerts\n2022-12-23T03:48:42.697503Z\tinfo\tUsing kubernetes.io\/tls secret type for signing ca files\n2022-12-23T03:48:42.778241Z\tinfo\tIstiod has detected the newly added intermediate CA and updated its key and certs accordingly\n2022-12-23T03:48:42.779459Z\tinfo\tx509 cert - Issuer: \u0022CN=istiod.istio-system.svc\u0022, Subject: \u0022\u0022, SN: d7acac2301045f741e5e30cff380deaf, NotBefore: \u00222022-12-23T03:46:42Z\u0022, NotAfter: \u00222032-12-20T03:48:42Z\u0022\n2022-12-23T03:48:42.779561Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=istiod.istio-system.svc\u0022, SN: 164bf045670a1716ed3f0f1c89b56122, NotBefore: \u00222022-12-23T03:48:14Z\u0022, NotAfter: \u00222023-01-22T03:48:14Z\u0022\n2022-12-23T03:48:42.779642Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=certmanager-ca,O=cert-manager\u0022, SN: 8533dbfe0b84ed1fc4e3c76be7ef612f, NotBefore: \u00222022-12-20T07:50:12Z\u0022, NotAfter: \u00222025-06-07T07:50:12Z\u0022\n2022-12-23T03:48:42.779657Z\tinfo\tIstiod certificates are reloaded\n\u0060\u0060\u0060\n\n要修改工作负载证书的自动轮换周期，你可以设置 \u0060pilot-agent\u0060 命令的环境变量 \u0060SECRET_TTL\u0060，默认值为 \u006024h0m0s\u0060。\n\n## 总结 {#summary}\n\n在本文中，我们使用了 cert-manager 作为 PKI，将 SPIRE 集成到我们的证书信任链中，并为 Istio 网格中的工作负载创建身份和证书。通过使用 cert-manager，你不用担心 *istiod* 证书过期的问题，还可以根据需要更新证书。你还可以根据需要将 cert-manager 集成到其他证书供应商，如 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/)、[HashiCorp Vault](https:\/\/www.vaultproject.io\/)、[Venafi](https:\/\/www.venafi.com\/) 等。你也可以使用 [istio-csr](https:\/\/github.com\/cert-manager\/istio-csr) 直接让 cert-manager 来管理 Istio 中的证书，或[使用 Vault 来存储证书](https:\/\/cloudnativecn.com\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)。\n\n## 参考 {#reference}\n\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - cloudnativecn.com](https:\/\/cloudnativecn.com\/blog\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换 - cloudnativecn.com](https:\/\/cloudnativecn.com\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - cloudnativecn.com](https:\/\/cloudnativecn.com\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n- [如何在 Istio 中集成 SPIRE - cloudnativecn.com](https:\/\/cloudnativecn.com\/blog\/istio-spire-integration\/)\n- [SPIRE Server Configuration Reference - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/#built-in-plugins)\n- [Server plugin: UpstreamAuthority \u0022cert-manager\u0022 - github.com](https:\/\/github.com\/spiffe\/spire\/blob\/v1.5.3\/doc\/plugin_server_upstreamauthority_cert_manager.md)\n- [Configuring SPIRE - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/configuring\/)\n', '\/blog\/cert-manager-spire-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-trust/">[译] 将 Istio 纳入信任链：使用现有 PKI 作为信任根</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/istio-trust/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('将 Istio 纳入信任链：使用现有 PKI 作为信任根', '本文讲解了如何让 Istio 信任现有 PKI 的步骤。', '\n当我们与想要使用 Istio 的客户或用户交流时，这一个问题时长会出现——Istio 中的证书信任如何工作的？Istio 有自己的证书颁发机构，而我们也有自己的证书颁发机构，如何确保它们相互信任？ \n\n简而言之，通过中间签名证书将 Istio 纳入到您现有的信任链中。 \n\n如果您使用 Istio 作为演示或开箱即用，它将拥有自己的自签名证书 —— 它是自己的根证书。对于在多个集群中运行 Istio 的用户来说，这是一个常见的痛点：他们无意中创建了两个互不不信任的孤岛，因此没有安全通信。\n\n以下是如何通过让 Istio 信任您现有的 PKI 的步骤。\n\n## 简述\n\n这是简短的版本：您应该通过为每个 Istio 部署创建一个中间签名证书来让 Istio 信任您现有的 PKI（并且每个集群应该有一个 Istio 部署）。然后你会：\n\n1. 启用跨 Istio 部署的通信\n2. 允许细粒度的证书撤销，而无需同时在整个基础架构中强制使用新证书（如果这听起来像是等待发生的重大中断，那么您是对的）。 \n3. 启用签名证书的轻松轮换。您需要做的就是创建一个新的中间件并使用新证书重新启动 Istio。因为它在同一个信任根中，所以一切都继续工作。 \n\nIstio 必须适应您现有的架构，以在组织内实现增量采用 —— 使网格适应您的组织，而不是让组织来适应网格。从了解对中间证书签名密钥的需求开始，将为您的成功做好准备，并使任何基础架构或环境更改更加顺利。\n\n## 详述\n\n我们先来了解一下证书验证的过程。在基本证书中，证书检查从信任根开始，向下延伸到特定身份（叶子）。证书路径验证算法是我们确保证书可信的方式。当我们使用 TLS 等安全协议连接到另一台机器时，服务器会向我们提供部分或全部证书链以证明其身份。如果链中的证书被确定为无效，则证书链将被拒绝且不会建立信任。如果我们顺利到达链的末端，则路径（以及证书）是有效的。成功！我们可以信任服务器！\n\n![带有叶证书、中间证书和根证书的证书链。服务器可以选择发送整个链，或者只发送一部分；只要有足够的链从根到叶，我们就可以验证证书。](f1.jpg)\n\n当 TLS 握手时，路径验证算法不关心有多少证书链驻留在我们的信任包中。基于我们带来的和他们提供的证书，它只关心我们能否构建一条从服务器的叶节点到我们的捆绑包中的信任根的链。上面的示例显示验证发生在证书交换中，这足以让叶子在证书颁发机构中找到它的位置。 \n\n当您在生产环境中运行 Istio 时，您将拥有多个叶节点和中间节点，但**只有一个根节点。**\n\n![具有根、三个中间签名 CA 和四个叶证书（由树中的各种中间体颁发）的 PKI 证书树。](f2.jpg)\n\n这就是为什么要在现有 PKI 中建立信任，因为有以下三个主要好处：\n\n1. 可以在 Istio 部署之间的交叉通信\n2. 细粒度证书撤销\n3. 轻松轮换证书\n\n### 跨 Istio 部署的通信\n\n对于 Istio，有两种方法可以确保跨部署的通信 —— 简单的方法和困难的方法。 \n\n困难的方法涉及 Istio 运维人员采取耗时、复杂且昂贵的步骤来确保两个根同时在另一个的证书颁发机构 (CA) 捆绑包中。\n\n![我们可以通过确保所有参与方的根都在 CA 捆绑包中来确保跨不同根的信任。如果它们不是彼此信任包的一部分，则来自每个 Citadel 的证书不能用于跨集群通信。](f3.jpg)\n\n简单的方法是为每个部署使用单独的中间签名证书部署 Istio，所有这些证书都共享相同的根。\n\n![当 Citadel 使用来自同一根 PKI 的中间证书时，最容易促进跨集群通信。我们看到与上面相同的 PKI 树，但中间 CA 被标记为不同集群中的 Citadel 实例。](f4.jpg)\n\n当涉及到细粒度撤销和证书轮换时，这一决定的连锁反应是巨大的。\n\n### 细粒度证书撤销\n\n撤销证书会将证书标记为不再受信任。当证书路径验证算法从叶节点走到根节点时，会对每个证书进行吊销状态检查。这使您能够撤销对单个组件或整个部署部分的信任。\n\n![使用与之前相同的 PKI 树，我们展示了在树的一部分中撤销中间 CA 如何使该中间证书以及由它创建的叶证书无效。](f5.jpg)\n\n这很重要，因为如果签名密钥被泄露，恶意行为者可能会通过出示您的客户认为是有效证书来冒充您的服务器。这在 Istio 中更为重要，因为我们使用证书来识别彼此的工作负载 —— 攻击者可以伪装成您网格中的任何服务！ \n\n通常，处理撤销是管理任何 PKI 中最困难的部分。Istio 帮助降低这种风险的方法之一是颁发非常短暂的证书。典型的吊销列表最多可能需要 24 小时才能在整个组织中传播。Istio 颁发的证书有效期少于 12 小时，因此几乎不需要撤销 Istio 颁发的身份证书。您只需要担心为每个 Istio 部署创建的签名证书。\n\n### 轻松轮换证书\n\n与吊销一样，中间证书的轮换更容易。优点包括，如果您能够按集群轮换证书而不是在根节点轮换证书，您将体验到更少的停机时间（以及相关的复杂性，即在任何地方发布一个带有新根的更新的 CA 包）。而且，就像任何好的 PKI 一样，这可以让您使根离线并安全地存储起来。\n\n## 总结\n\n用简单的方法来做！将 Istio 引入您现有的信任根中，以避免痛苦和心痛。中间签名证书的存在是为了让采用 Istio 更容易、更安全。\n', '\/trans\/istio-trust\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲解了如何让 Istio 信任现有 PKI 的步骤。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-certificates-management/">Istio 中的证书管理方式介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的证书管理方式介绍', '本文介绍了数字证书和 Istio 中的证书管理方式。', '\n我在[如何理解 Istio 中的 mTLS 流量加密](\/blog\/understanding-the-tls-encryption-in-istio\/)这篇文章中提出流量加密的关键是证书管理。我们可以使用 Istio 中内置了 CA（证书授权机构）也可以使用自定义 CA 来管理网格内的证书。这篇博客将为你讲解 Istio 是如何进行证书管理的。\n\n## 什么是证书？ {#certificates-introduction}\n\n在介绍 Istio 的证书管理方式之前，我们先来了解一下什么是证书。若你已了解证书的作用及原理，请直接跳到 Istio 中的证书管理部分。\n\n证书（Certificate），又称电子证书，是用于身份认证和加密通信的一种数字证明文件。在了解 Istio 的证书管理之前，我们先来了解一下什么是证书。如果你已经了解了证书，可以跳过这一节。\n\n证书有很多类别，本文中的证书特指的是 [X.509 V3 证书](https:\/\/datatracker.ietf.org\/doc\/html\/rfc5280)。X509 证书是一种常见的数字证书格式，用于在计算机网络中识别实体的身份。X509 是公钥基础设施（PKI）的国际标准，主要用于身份认证和信息加密，例如 TLS。X.509 证书中包含了个人、组织或计算机的身份信息和公钥。V3 是它的最新版本。它主要用于在客户端和服务器之间进行安全通信，例如在通过 HTTPS 访问网站时。x509 证书通常由 CA 颁发，该 CA 会验证实体的身份，并将这些信息编码到证书中。当客户端连接到服务器时，服务器会向客户端提供其 x509 证书，客户端会验证证书的有效性，并通过该证书来识别服务器的身份。通过这种方式，双方可以安全地进行通信，并确保数据传输的完整性和保密性。\n\n### 哈希函数 {#hash}\n\n谈到证书就不得不提哈希（Hash）函数，因为证书的内容会使用哈希函数进行哈希处理，然后用证书颁发者的私钥进行签名。这样，当收到一份证书时，接收者就可以使用证书颁发者的公钥来验证证书的合法性。\n\n哈希函数是一种将任意长度的输入（也称为消息）映射为固定长度的输出的函数。这个输出也称为哈希值或消息摘要。\n\n哈希函数有许多用途，其中一个重要的用途是密码存储。当用户在系统中设置密码时，通常不会将真实的密码直接存储在系统中。相反，会将密码进行哈希处理，并将哈希值存储在系统中。当用户登录时，系统会将用户输入的密码进行哈希处理，然后与存储的哈希值进行比较。如果两者相同，则证明用户输入的密码正确，反之则错误。\n\n哈希函数有很多种类型，例如 MD5、SHA-1 等。这些函数都有一些共同的特点，比如输出固定长度、不可逆、散列冲突少等。\n\n哈希函数的安全性与其输出的长度有关。一般来说，输出长度越长，哈希函数就越安全。但是，输出长度越长，哈希处理的时间就越长，因此要在安全性和效率之间进行平衡。\n\n### 证书的作用 {#cert-works}\n\n证书的用途广泛，凡是需要加密、认证、授权的场景都会用到它，比如：\n\n- 在 Kubernetes 中你需要给各个组件配置证书，你可以选择[手动生成证书](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)；\n- Istio 中为实现自动 mTLS 给各个工作负载颁发的证书；\n- 访问 HTTPS 网站所用到的证书等；\n\n证书就像是由权威机构印发的名片，供使用者表明其身份，同时还可以为信息加密，保证通信的安全性和完整性。下图展示的是 TLS 通信的大概步骤，其中证书承担了证明服务器身份和加密通信的职责。\n\n下面以一个网站的 HTTP 链接为例，颁发数字证书、验证和加密通信的过程如下图所示。\n\n![TLS 证书颁发和校验过程](tls.svg)\n\n详细步骤如下：\n\n1. 服务器（网站所有者）向 CA 提交证书签名请求；\n2. CA  验证服务器的身份和网站的真实性后为服务器颁发数字证书，服务器安装该证书，以便访问者能够验证网站的安全性；\n3. 用户通过浏览器（客户端）向网站发送请求；\n4. 服务器向客户端返回 TLS 证书；\n5. 客户端向 CA 验证证书的有效性，若有效则建立连接，若无效则提示用户拒绝连接；\n6. 客户端生成一对随机的公钥和私钥；\n7. 客户端将并将自己的公钥发送给服务端；\n8. 服务端使用客户端的公钥加密消息；\n9. 服务端将加密后的数据发送给客户端；\n10. 客户端使用自己的私钥解密服务端发送的数据；\n\n至此，双方建立了一个安全的通道，并可以通过该通道进行双向加密的数据传输。\n\n### 如何生成证书？{#how-to-generate-certificates}\n\n你可以通过以下开源工具生成 X.509 证书：\n\n- [Easy-RSA](https:\/\/github.com\/OpenVPN\/easy-rsa)：一个简单地命令行工具，由 OpenVPN 项目组维护，使用 EasyRSA 可以轻松地为 OpenVPN 网络生成安全的证书和密钥；\n- [OpenSSL](https:\/\/github.com\/openssl\/openssl)：由个人发起于 1995 年，现由独立组织维护，只提供命令行工具；\n- [CFSSL](https:\/\/github.com\/cloudflare\/cfssl)：由 CloudFlare 开发和维护，不仅仅是一个用于生成证书的命令行工具，还可以作为 PKI 服务器；\n- [BoringSSL](https:\/\/github.com\/google\/boringssl)：Google 开发和维护的 OpenSSL 分支，已用于 Chrome 浏览器和安卓操作系统；\n\n因为可能大多数人都对 OpenSSL 比较熟悉，所以下文中我们将使用 OpenSSL 来创建证书。\n\n### 证书的组成 {#cert-component}\n\n下面以 X.509 V3 证书为例，讲解数字证书的组成。下面是该证书的一个示例：\n\n\u0060\u0060\u0060\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            fc:c6:18:2e:20:bd:27:b5:6b:60:bc:47:23:6b:8b:d9\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: O=cluster.local\n        Validity\n            Not Before: Dec 15 07:25:32 2022 GMT\n            Not After : Dec 16 07:27:32 2022 GMT\n        Subject:\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (2048 bit)\n                Modulus:\n                    00:eb:40:16:87:6c:17:5a:9c:b2:91:00:94:d1:31:\n                    37:bb:d7:1e:e6:06:1c:a1:c1:35:64:54:82:54:af:\n                    b8:4b:40:6f:e0:73:86:4e:c1:c6:75:b8:c8:30:ac:\n                    69:16:e8:68:25:cb:dd:e8:53:55:ec:7a:bd:a9:d3:\n                    42:44:7f:e5:f5:52:dd:99:ae:c2:1a:a2:06:1f:be:\n                    1b:e6:3e:69:87:a3:fc:91:21:39:b0:a7:67:11:f2:\n                    3c:55:c6:4b:04:15:1b:ff:49:14:88:c4:58:87:79:\n                    96:5b:6e:00:1c:c1:e7:2c:53:0c:d1:77:dc:a8:82:\n                    cc:fa:26:c1:bb:6c:df:a8:43:0c:b7:cc:f0:a2:11:\n                    9b:e8:3f:8a:1d:ed:2a:ff:1f:d1:03:eb:8a:b9:98:\n                    40:18:83:24:4f:14:95:a3:59:ef:67:0f:35:6d:ae:\n                    91:81:b2:04:02:16:80:d1:39:bd:70:cf:0f:cb:9a:\n                    81:39:d9:fe:52:a5:cf:79:4f:a3:69:d8:0d:39:6a:\n                    48:24:8d:2b:88:04:fa:81:de:65:50:7d:1a:3d:cd:\n                    f3:1c:42:63:29:75:a0:9b:8e:16:44:3a:89:d6:2b:\n                    41:76:65:a5:2e:c8:b6:d2:89:42:5d:21:24:33:30:\n                    f0:9d:0b:4d:cf:78:d5:45:2d:49:5a:55:50:98:93:\n                    03:f5\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Key Usage: critical\n                Digital Signature, Key Encipherment\n            X509v3 Extended Key Usage:\n                TLS Web Server Authentication, TLS Web Client Authentication\n            X509v3 Basic Constraints: critical\n                CA:FALSE\n            X509v3 Authority Key Identifier:\n                keyid:BA:31:8A:9C:ED:EB:49:D2:54:09:98:D9:4C:3A:9C:42:D0:64:8D:B2\n\n            X509v3 Subject Alternative Name: critical\n                URI:spiffe:\/\/cluster.local\/ns\/default\/sa\/httpbin\n    Signature Algorithm: sha256WithRSAEncryption\n         90:7f:cb:6f:0b:16:cb:59:7d:f4:87:a7:5a:38:fa:0a:16:d8:\n         83:0d:b1:36:77:a2:4a:fe:38:52:ab:49:e9:89:50:1a:4c:e9:\n         94:07:37:7f:27:bc:2c:ce:c1:d2:33:75:5d:b6:ab:ae:cb:2e:\n         71:f4:22:c0:40:15:27:02:75:c1:32:2e:83:49:73:6c:9a:ea:\n         04:ef:55:2d:8d:71:30:9b:e4:30:dd:95:20:0d:7c:d2:f4:30:\n         2f:07:2e:9f:53:37:e6:3d:14:c7:41:f4:09:8b:a3:76:56:c7:\n         c7:92:0f:fc:17:5a:5a:32:6c:9e:87:18:2e:51:75:54:68:d8:\n         01:c1:07:cc:b0:35:bf:0b:6c:62:a6:5b:23:61:35:c8:4f:7f:\n         e7:1f:a0:e9:11:44:a6:17:52:4d:00:40:21:de:63:ee:02:c8:\n         2b:5d:a1:7a:5d:7f:d5:d3:c1:7d:5f:00:40:e8:80:8d:cc:e9:\n         8a:c6:b4:98:fe:7a:7d:37:0c:6f:4c:31:91:7a:79:30:84:cd:\n         01:a7:14:f6:1b:33:8f:0f:50:1c:36:38:6b:24:da:cf:49:8a:\n         5b:28:cf:27:76:e1:a5:c7:e6:d5:6e:d8:36:85:aa:1f:a5:ac:\n         fa:f1:2e:a2:36:2e:25:b0:71:24:d1:3e:d5:e5:19:2b:0b:6f:\n         b7:17:e4:75\n\u0060\u0060\u0060\n\n证书中各个字段的含义如下：\n\n- 证书版本（Version）：表示证书的版本号。\n- 序列号（Serial Number）：表示证书的唯一序列号。\n- 签名算法（Signature Algorithm）：表示证书的签名算法，例如 RSA、DSA 或 ECDSA 等。\n- 证书颁发机构（Issuer）：表示颁发该证书的可信的第三方机构的名称。\n- 有效期（Validity）：表示证书的有效期，包括证书生效日期（Not Before）和证书失效日期（Not After）。\n- 使用者（Subject）：表示证书所有者的名称。\n- 公钥信息（Subject Public Key Info）：表示证书所有者的公钥以及公钥的算法。\n- 扩展（Extensions）：表示证书的扩展信息，包括：\n  - 密钥用法扩展（Key Usage Extension）：表示证书所有者的密钥可用于哪些操作，例如数字签名、密钥加密等。\n  - 扩展密钥用法扩展（Extended Key Usage Extension）：表示证书所有者的密钥可用于哪些扩展的操作，例如 TLS Web Server Authentication、TLS Web Client Authentication 等。\n  - 基本约束扩展（Basic Constraints Extension）：表示证书所有者是否是证书颁发机构的下级机构，以及是否允许其作为证书颁发机构颁发其他证书。\n  - 主体密钥表示扩展（Authority Key Identifier）：包含一个或多个唯一的标识符，用于表示证书颁发机构的密钥。这些标识符可以是证书颁发机构的公钥哈希值，也可以是证书颁发机构的证书序列号。该扩展用于验证证书的合法性，例如在验证证书链时，用于验证证书颁发机构是否为可信的机构。这个扩展字段是可选的，但在许多情况下都会被使用。\n  - 主体替代名称扩展（Subject Alternative Name Extension）：表示证书所有者的其他名称，例如域名、IP 地址、电子邮件地址等。\n\n### 证书信任链 {#certificate-trust-chain}\n\n证书的验证需要通过证书信任链（Certificate Trust Chain）。证书信任链是指用于身份验证的一系列证书，它们形成一条从一个可信任的根证书颁发机构开始，逐级向下连接，直到用于验证某个特定证书的中间证书或终端证书的一种方式。证书信任链允许数字证书的可信度随着证书级别的升高而提高。\n\n在下面的证书信任链示意图中，你可以看到四条信任链。\n\n![证书信任链](certificate-trust-chain.svg)\n\n证书的信任链是一个树形结构，每个 CA 都可以有一或多个子 CA，一共有三种角色：\n\n- 根 CA：最顶层的 CA，可以颁发证书给中间 CA；\n- 中间 CA：除根 CA 以外的 CA，可颁发终端证书；\n- 终端实体：拥有终端证书的设备或服务；\n\n根 CA 是数字证书的最顶级颁发机构，因此它所颁发的证书是最可信的。根证书颁发机构通常由政府机构或其他权威机构（如国际基础设施安全组织）经营和监管。常见的根 CA 包括：\n\n- Symantec\/VeriSign\n- Comodo\n- DigiCert\n- GlobalSign\n- GoDaddy\n- Entrust\n- GeoTrust\n- RapidSSL\n- Baltimore CyberTrust Root\n\n请注意，上述列表只是一个样例，实际上有许多其他根 CA。\n\n在 Chrome 浏览器中打开一个 HTTPS 网页，你可以通过点击地址栏左侧的锁图标查看证书信息，其中包括证书信任链，例如 [https:\/\/tetrate.io](https:\/\/tetrate.io) 的证书信任链如下图：\n\n![Tetrate.io 的证书信任链](tetrate-cert.jpg)\n\n证书信任链允许客户端（例如，Web 浏览器）在验证终端证书时，逐级向上验证每个证书，以确定它是否可信。数字证书签发的原理是 CA 将证书拥有者的公钥与身份信息绑定在一起，然后 CA 使用其专有的私钥生成正式的数字签名，用以表示这个证书是经 CA 签发的。在证书校验时使用 CA 的公钥对这个证书上的数字签字进行验证即可。\n\n## 将 Istio 纳入 PKI 证书信任链 {#istio-pki}\n\n在使用 Istio 之前，企业通常有自己的内部 PKI（公钥基础设施），那么如何将 Istio 纳入到 PKI 的证书信任链中呢？\n\n我们知道 Istio 内置了证书管理功能，可以开箱即用，Istio 启动时会为 *istiod* 创建自签名证书，作为网格内所有工作负载的根证书。这样做有个问题，如果你有多网格，内置的根证书无法做到网格间互信。正确的做法是不使用 Istio 自签名证书，而是将 Istio 纳入到你的证书信任链中，将 Istio 集成到你的 PKI，为 PKI 每个网格创建一个中间证书，这样两个网格拥有了共同的信任根，就可以做到网格间互信。\n\n通过为 Istio 网格创建中间 CA 使其纳入到企业内部 PKI 证书信任链中，如下图所示。\n\n![为多网格创建中间 CA 使得 Istio 纳入到企业内部 PKI 证书信任链](cluster-ca.svg)\n\n将 Istio 纳入企业内部 PKI 证书信任链后有诸多好处：\n\n- 可以实现跨网格\/集群之间的通信：有了共同的信任根，集群之间就可以互相验证身份，进而实现跨集群通信；\n- 更细粒度的证书撤销：你可以撤销某个实体或中间 CA 的证书来撤销某个服务或集群的证书；\n- 轻松实现证书轮换：你可以按集群\/网格实现证书轮换，而不是轮换根节点证书，这样会减少停机时间，推荐您使用 [cert-manager](https:\/\/github.com\/cert-manager\/cert-manager) 来实现自动化的大规模 CA 证书轮换，详情请参考[在生产中大规模自动化 Istio CA 轮换](https:\/\/cloudnativecn.com\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)；\n\n关于将 Istio 纳入企业内部 PKI 的证书信任链的详细说明请参考[这篇博客](https:\/\/cloudnativecn.com\/blog\/istio-trust\/)。\n\n## Istio 中使用自定义 CA 的步骤 {#istio-custom-ca}\n\n默认情况下，Istio CA 会生成一个自签名的根证书和密钥，并使用它们来签署工作负载证书。为了保护根 CA 密钥，你应该使用在安全机器上离线运行的根 CA，并使用根 CA 向运行在每个集群上的 Istio CA 签发中间证书。Istio CA 可以使用管理员指定的证书和密钥来签署工作负载证书，并将管理员指定的根证书作为信任根分配给工作负载。\n\n下图展示了 Istio 中的证书签发和挂载过程。\n\n![Istio 中的证书签发和挂载过程](cert-process.svg)\n\n1. Istio 向 Pod 中注入的 Envoy 代理中有两个进程——\u0060envoy\u0060 和 \u0060pilot-agent\u0060。\u0060pilot-agent\u0060 为 Envoy 生成私钥，通过 UNIX Domain Socekt（UDS）使用 Secret Discovery Service（SDS）向 CA 发起证书签名请求（CSR），如果你没有配置 CA 插件的话，Istio 默认向 *istiod* 发起 CSR；\n2. \u0060istiod\u0060 内置 CA 向 \u0060pilot-agent\u0060 返回证书；\n3. \u0060pilot-agent\u0060 将生成的私钥和 CA 返回的证书发送给 \u0060envoy\u0060 挂载；\n\nIstio 默认使用内置于 *istiod* 中的 CA，也支持插入其他 CA，见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)。若想使用自定义的 CA 证书和密钥为服务创建身份，你需要：\n\n- 创建 CA 配置文件并使用它来创建自签名的 CA 根证书和密钥；\n- 为服务创建私钥、签名请求配置文件；\n- 为服务创建证书签名请求（CSR）；\n- 使用根证书和密钥以及服务的签名请求文件为服务创建证书；\n\n接下来，我们将以为 Bookinfo 的 productpage 服务创建和挂载证书为例详述 Istio 内置 CA 签发证书的流程。\n\n## Istio 内置 CA 签发证书流程  {#istio-ca}\n\nIstio 启动时将创建一个自签名的 CA 证书，然后再用该 CA 证书为网格内的服务颁发证书。下面我们手动模拟 Istio 内置 CA 签发证书的步骤：\n\n1. 创建 CA 私钥 \u0060ca.key\u0060；\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out ca.key\n   \u0060\u0060\u0060\n\n2. 创建 CA 配置文件 \u0060ca.conf\u0060：\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = req_dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = Root CA\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n3. 使用 CA 私钥 \u0060ca.key\u0060 生成自签名证书 \u0060ca.pem\u0060，其中主题中包含 CA 的信息：\n\n   \u0060\u0060\u0060bash\n   openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.pem -config ca.conf\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022关于 PEM 文件\u0022\u003e}}\n\n   PEM 文件是一种用于存储证书、公钥或私钥的文件。它采用 Base64 编码的 ASCII 格式，并使用特定的文件扩展名，例如 \u0060.pem\u0060、\u0060.crt\u0060、\u0060.cer\u0060 或 \u0060.key\u0060。PEM 文件通常用于存储加密密钥、数字证书和公钥基础设施（PKI）证书。\n\n   PEM 文件的内容通常以一组特定的标头和脚本开始，例如 \u0060-----BEGIN RSA PRIVATE KEY-----\u0060 和 \u0060-----END RSA PRIVATE KEY-----\u0060。这些标头和脚本指定了文件的类型和数据的开始和结束位置。\n\n   PEM 文件可以通过文本编辑器直接打开，但并不可读，因为它是由二进制编码格式 DER（可分辨编码规则）转化而来，要想解析它需要使用特别的工具，例如 OpenSSL。\n\n   {{\u003c\/callout\u003e}}\n\n4. 为工作负载创建私钥 \u0060workload.key\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out workload.key\n   \u0060\u0060\u0060\n\n5. 创建证书签名请求配置文件 \u0060csr.conf\u0060，其中包含 CA 的地址及附加信息；\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = productpage\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n6. 基于工作负载的 CSR 配置文件 \u0060csr.conf\u0060 和工作负载的私钥文件 \u0060workload.key\u0060 创建证书签名请求 \u0060workload.csr\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl req -new -key workload.key -out workload.csr -config csr.conf\n   \u0060\u0060\u0060\n\n7. 基于 CA 的私钥 \u0060ca.key\u0060、CA 的证书 \u0060ca.pem\u0060 和工作负载的证书签名请求创建服务器证书 \u0060workload.pem\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -req -in workload.csr -CA ca.pem -CAkey ca.key \\\n       -CAcreateserial -out workload.pem -days 365 \\\n       -extensions req_ext -extfile csr.conf -sha256\n   \u0060\u0060\u0060\n\n   Istiod 在收到工作负载的 CSR 后将根证书 \u0060ca.pem\u0060 和服务证书下发给工作负载；\n\n8. 查看工作负载中 Envoy 代理挂载的证书链：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n   \u0060\u0060\u0060\n\n   \u0060chain.pem\u0060 文件中保存着 \u0060productpage\u0060 服务的证书链，因为我们使用的 Istio 内置 CA 作为根 CA，所以该文件中只保存有一个证书，可以运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in chain.pem\n   \u0060\u0060\u0060\n\n9. 查看 Envoy 代理挂载的根证书：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n   \u0060\u0060\u0060\n\n   \u0060root.pem\u0060 即为根证书，运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in root.pem\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022提示\u0022\u003e}}\n\n   \u0060root.pem\u0060 中的内容与 \u0060istiod-ca-cert\u0060 ConfigMap 中的 \u0060root-cert.pem\u0060 及 \u0060istio-ca-secret\u0060 中的 \u0060ca-cert.pem\u0060 是一样的，虽然现在 Envoy 已不在通过读取挂载卷来获得证书内容，但之所以保留了这些卷是为了向后兼容。\n\n   {{\u003c\/callout\u003e}}\n\n   证书挂载到 Envoy 代理之后，*istiod* 将负责定期替换密钥证书，以及根据需要撤销密钥证书。\n\n## 总结 {#summary}\n\n本文向你介绍了数字证书的作用、组成和证书信任链，以及 Istio 中内置的开箱即用的证书管理器运作的流程。但是 Istio 内置 CA 仍然有一定限制，在下一篇博客中我将向你介绍如何使用插件 SPIRE 和 cert-manager 来实现细粒度的证书管理和自动证书轮换。\n\n## 参考 {#reference}\n\n- [插入 CA 证书 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)\n- [如何设置 SSL 证书 - istio.tetratelabs.io](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)\n- [管理集群中的 TLS 认证 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/tls\/managing-tls-in-a-cluster\/)\n- [手动生成证书 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - jimmysong.io](https:\/\/cloudnativecn.com\/blog\/istio-trust\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - jimmysong.io](https:\/\/cloudnativecn.com\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n', '\/blog\/istio-certificates-management\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了数字证书和 Istio 中的证书管理方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/">[译] 如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书', '本文将指导你使用 Vault 存储 Istio 的证书。', '\n在本文中，我们将探讨如何使用 Hashicorp Vault 作为一种比使用 Kubernetes [Secret](https:\/\/kubernetes.io\/docs\/concepts\/configuration\/secret) 更安全的方式来存储 Istio 证书。默认情况下，Secret 使用 base64 编码存储在 *etcd* 中。在安全策略严格的环境中，这可能是不可接受的，因此需要额外的措施来保护它们。一种此类解决方案涉及将机密存储在外部机密存储提供程序中，例如 [HashiCorp Vault](https:\/\/www.vaultproject.io\/)。\n\nVault 可以托管在 Kubernetes 集群内部和外部。在本案例中，我们将探索使用托管在 Kubernetes 外部的 Vault，以便它可以同时为多个集群提供秘密。该设置也非常适合探索 Istio 的[多集群功能](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster)，它需要一个共享的信任域。\n\n利用 \u0060vault-agent-init\u0060 容器，我们可以将证书和私钥材料注入实际的 Istio 控制平面 Pod，以便它们使用外部 CA 证书进行引导。这避免了依赖 Secret 来引导 Istio 控制平面。该技术也完全适用于入口和出口证书。\n\n有关如何在 Istio 中使用和管理证书的更多信息，请参见官方文档：\n\n- [身份和证书管理](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/#pki)\n- [插入 CA 证书](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert)\n- [使用 Kubernetes CSR 的自定义 CA 集成](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/custom-ca-k8s)\n\n有关基于实际生产经验的最佳实践，另请查看以下 [Tetrate](https:\/\/tetrate.io\/) 的博客文章：\n\n- [在 Istio 中构建证书信任链：将现有 PKI 作为信任根](\/trans\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换](\/trans\/automate-istio-ca-rotation-in-production-at-scale)\n\n这篇博文附带的代码可以在以下存储库中找到：\n\nhttps:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\n\n## **Istiod 证书处理**\n\n尽管上述博文中解释了一些决策逻辑，但也值得参考[源代码](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/pkg\/bootstrap\/istio_ca.go)以查找一些未记录的行为。\n\n在 Istio 的源码 \u0060istio\/pilot\/pkg\/bootstrap\/istio_ca.go\u0060 文件中，你将看到：为了向后兼容，Istio 保留了对用于自签名证书 \u0060cacerts\u0060 Secret 的支持。它安装在相同的位置，如果发现了就会被使用——创建秘密就足够了，不需要额外的选项。在旧安装程序中，\u0060LocalCertDir\u0060 被硬编码到 \u0060\/etc\/cacerts\u0060 并使用 \u0060cacerts\u0060  Secret 安装。已删除对签署其他根 CA 的支持——太危险，没有明确的用例。\n\n默认配置，用于向后兼容 Citadel：\n\n- 如果 \u0060istio-system\u0060 中存在 \u0060cacerts\u0060 秘密，将被挂载。它可能包含一个可选的 \u0060root-cert.pem\u0060，\n带有额外的根和可选的 \u0060{ca-key, ca-cert, cert-chain}.pem\u0060 由用户提供的根 CA。\n- 如果未找到用户提供的根 CA，则使用 \u0060istio-ca-secret\u0060 Secret，以及 \u0060ca-cert.pem\u0060 和 \u0060ca-key.pem\u0060 文件。\n- 如果两者均未找到，将创建 \u0060istio-ca-secret\u0060。\n- 带有 \u0060caTLSRootCert\u0060 文件的 \u0060istio-security\u0060 ConfigMap 将用于根证书，并在需要时创建。该 ConfigMap 由节点代理使用，不再可能在 sds-agent 中使用，但我们仍保留它以向后兼容。将与 node-agent 一起删除。sds-agent 使用 K8S root 直接调用 \u0060NewCitadelClient\u0060 。\n\n为了指示 Istio 从其他地方获取证书，而不是标准 Kubernetes Secret，我们将利用 *istio-pilot*（又名 istiod 或 Istio 控制平面）的环境变量（[见此文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-discovery)），从 Kubernetes Pod 中的另一个位置获取证书。这是必需的，因为 \u0060vault-agent-init\u0060 注入容器将创建一个新的挂载卷 \u0060\/vault\/secrets\u0060 ，以放置从外部 Vault 服务器拉出的证书和私钥。\n\n| 变量名称      | 类型   | 默认值         | 描述                         |\n| ------------- | ------ | -------------- | ---------------------------- |\n| \u0060ROOT_CA_DIR\u0060 | 字符串 | \u0060\/etc\/cacerts\u0060 | 本地或安装的 CA 根目录的位置 |\n\n## Pod 内的 \u0060vault-agent-init\u0060 容器注解\n\n我们将利用 Vault 注入器注解来指示 Sidecar 提取哪些数据以及在这样做时使用什么 Vault 角色。我们还确保容器在我们实际的主容器之前运行，因此后者可以获取证书和密钥材料以正确引导自身。[此处](https:\/\/developer.hashicorp.com\/vault\/docs\/platform\/k8s\/injector\/annotations)列举并记录了 Vault 注解。我们将在本教程中使用的相关注释如下：\n\n| **注解**                                     | **默认值** | **描述**                                                     |\n| -------------------------------------------- | ---------- | ------------------------------------------------------------ |\n| \u0060vault.hashicorp.com\/agent-inject\u0060           | false      | 配置是否为 Pod 显式启用或禁用注入。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/agent-init-first\u0060       | false      | 如果为 true，则将 Pod 配置为首先运行 Vault Agent init 容器（如果为 false，则最后运行）。当其他 init 容器需要预填充的秘密时，这很有用。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/role\u0060                   | –          | 配置 Vault 代理自动验证方法使用的 Vault 角色。\u0060vault.hashicorp.com\/agent-configmap\u0060 未设置时需要。 |\n| \u0060vault.hashicorp.com\/auth-path\u0060              | –          | 配置 Kubernetes 身份验证方法的身份验证路径。默认为 \u0060auth\/kubernetes\u0060。 |\n| \u0060vault.hashicorp.com\/agent-inject-secret-\u0060   | –          | 配置 Vault 代理以从容器所需的 Vault 中检索秘密。Secret 的名称是 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 之后的任意唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-secret-foobar\u0060 该值是 secret 所在的 Vault 中的路径。 |\n| \u0060vault.hashicorp.com\/agent-inject-template-\u0060 | –          | 配置 Vault Agent 应该用于呈现秘密的模板。模板的名称是 v\u0060ault.hashicorp.com\/agent-inject-template-\u0060 之后的任何唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-template-foobar\u0060。这应该映射到 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 中提供的相同唯一值。如果未提供，则使用默认的通用模板。 |\n\n## Vault 服务器注意事项 {#vault-server-considerations}\n\nVault 支持多种客户端验证自己的方法。我们将利用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)，这意味着我们将利用 Kubernetes ServiceAccount JWT 令牌验证。请注意，自 Kubernetes 1.24 以来，不再自动生成 ServiceAccount 令牌。您仍然可以手动创建这些 API 令牌，如[此处所述](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-service-account\/#manually-create-an-api-token-for-a-serviceaccount)。\n\n至于证书和私钥材料的存储，我们有两种选择：\n\n- [PKI 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/pki)\n- [KV 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/kv)\n\n因为 PKI 秘密引擎不提供精简的 API 来检索我们需要的证书和私钥，并且因为 PKI 秘密引擎会为每次调用（例如，每次 *istiod* 重启）生成一个新的中间证书，我们将使用通用的 KV 秘密引擎，将我们需要的所有值存储在一个简单的键值数据结构中。我们假设中间证书的更新是通过一些服务门户或 CI\/CD 过程在外部处理的，这些过程也将更新的中间证书存储在 Vault 服务器中。\n\nIstio 的控制平面 Pod 需要以下文件才能在 CA 中正确引导其构建：\n\n| Key            | 值（PEM 编码） | 细节                                    |\n| -------------- | -------------- | --------------------------------------- |\n| ca-key.pem     | 私钥           | 中间证书的私钥，用作 *istiod* 的根 CA。 |\n| ca-cert.pem    | CA 公共证书    | 中间证书，用作 *istiod* 的根 CA。       |\n| root-cert.pem  | CA 根证书      | 我们新生成的中间证书的信任根。          |\n| cert-chain.pem | 完整的证书链   | 中间证书在顶部，根证书在底部。          |\n\n## 设置\n\n如果要遵循本地设置，则安装软件的先决条件包括：\n\n- *kubectl* 与 Kubernetes 集群交互（[下载](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)）\n- *helm* 安装 Vault injector 和 Istio chart（[下载](https:\/\/helm.sh\/docs\/intro\/install)）\n- 用于配置 Vault 服务器的 *vault cli* 工具（[下载](https:\/\/developer.hashicorp.com\/vault\/tutorials\/getting-started\/getting-started-install#install-vault)）\n\n如果您想要本地演示环境，请按照[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/local-setup.md)的说明进行操作，该说明使用 \u0060docker-compose\u0060 启动一个 Vault 服务器和两个独立的 k3s 集群。如果您使用自己的 Kubernetes 集群和外部托管的 Vault 实例，请跳至下一节。\n\n- *docker-compose* 启动本地环境（[下载](https:\/\/github.com\/docker\/compose\/releases)）\n\n为了取得进展，我们希望根据您的环境设置以下 shell 变量。\n\n\u0060\u0060\u0060bash\nexport VAULT_SERVER=\nexport K8S_API_SERVER_1=\nexport K8S_API_SERVER_2=\n\u0060\u0060\u0060\n\n## **Vault Kubernetes 身份验证后端**\n\n正如在有关 [Vault 服务器注意事项](#vault-server-considerations)的介绍部分中提到的，我们将使用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)。由于 *istiod* 将从 Vault 服务器获取证书和私钥材料，让我们从在两个集群中创建相应的服务账户开始。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml create ns istio-system\nkubectl --kubeconfig kubecfg2.yml create ns istio-system\nkubectl --kubeconfig kubecfg1.yml apply -f istio-sa.yml\nkubectl --kubeconfig kubecfg2.yml apply -f istio-sa.yml\n\u0060\u0060\u0060\n\nServiceAccount、Secret 和 ClusterRoleBinding 如下：\n\n\u0060\u0060\u0060yaml\n# istio-sa.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: istiod\n  namespace: istio-system\n  labels: # added for istio helm installation\n    app: istiod\n    app.kubernetes.io\/managed-by: Helm\n    release: istio-istiod\n  annotations: # added for istio helm installation\n    meta.helm.sh\/release-name: istio-istiod\n    meta.helm.sh\/release-namespace: istio-system\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: istiod\n  namespace: istio-system\n  annotations:\n    kubernetes.io\/service-account.name: istiod\ntype: kubernetes.io\/service-account-token\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: role-tokenreview-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:auth-delegator\nsubjects:\n  - kind: ServiceAccount\n    name: istiod\n    namespace: istio-system\n\u0060\u0060\u0060\n\n\u003e 注意：*我们在 istiod ServiceAccount 上添加了 Helm 标签和注解，以免与稍后的 Istio Helm 部署发生冲突。*\n\n在两个集群中创建 ServiceAccount 后，让我们将它们的 Secret 令牌和 ca.cert 值存储在 output 文件夹中：\n\n\u0060\u0060\u0060bash\nmkdir -p .\/output\nkubectl --kubeconfig kubecfg1.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod1.jwt\nkubectl --kubeconfig kubecfg1.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert1.pem\nkubectl --kubeconfig kubecfg2.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod2.jwt\nkubectl --kubeconfig kubecfg2.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert2.pem\n\u0060\u0060\u0060\n\n关于 Kubernetes API 证书和 istiod ServiceAccount JWT 令牌的详细内容的更多信息可以在[这里](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/output)找到，在这里我们也更深入地描述了 Vault 的交互过程，即通过 REST API 调用来验证和获取秘密。在调试权限拒绝的问题时，这些可以派上用场。\n\n让我们根据刚刚检索到的 Kubernetes CA 证书和 JWT 令牌创建必要的 Vault 身份验证配置：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault auth enable --path=kubernetes-cluster1 kubernetes\nvault auth enable --path=kubernetes-cluster2 kubernetes\nvault write auth\/kubernetes-cluster1\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_1\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert1.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod1.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\nvault write auth\/kubernetes-cluster2\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_2\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert2.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod2.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\n\u0060\u0060\u0060\n\n\u003e 注意：如果您使用的是 *docker-compose* 提供的环境，则 \u0060VAULT_ADDR\u0060 设置为 localhost。\n\n## *Vault kv* Secret 中的 Istio 证书和私钥\n\n接下来我们将创建一个新的自签名根证书并为我们的两个集群生成中间证书。我们将在[这里](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/certs)使用上游 Istio 提供的辅助 *Makefile* 脚本：\n\n\u0060\u0060\u0060bash\ncd certs\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk root-ca\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster1-cacerts\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster2-cacerts\ncd ..\n\u0060\u0060\u0060\n\n有关实际内容和正在设置的 X509v3 扩展的更多详细信息，请参见[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs)。您可以通过[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs-gen)的 *Makefile*文档和相应的 *Makefile* 覆盖值微调证书。\n\n让我们将生成的证书和私钥添加到 Vault *kv* secret 中：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault secrets enable -path=kubernetes-cluster1-secrets kv\nvault secrets enable -path=kubernetes-cluster2-secrets kv\nvault kv put kubernetes-cluster1-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster1\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster1\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster1\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster1\/root-cert.pem\nvault kv put kubernetes-cluster2-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster2\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster2\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster2\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster2\/root-cert.pem\n\u0060\u0060\u0060\n\n通过限制对每个集群的这些证书和私钥的访问，绑定到基于 Kubernetes *istiod* ServiceAccount 的身份验证后端：\n\n\u0060\u0060\u0060bash\necho \u0027path \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster1 -\necho \u0027path \u0022kubernetes-cluster2-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster2 -\nvault write auth\/kubernetes-cluster1\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster1 \\\n  ttl=24h\nvault write auth\/kubernetes-cluster2\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster2  \\\n  ttl=24h\n\u0060\u0060\u0060\n\n## 部署 *vault-inject* 和 Istio Helm Charts\n\n为了部署 Vault 注入器，我们将利用官方 Vault [Helm chart](https:\/\/github.com\/hashicorp\/vault-helm)。\n\n\u0060\u0060\u0060bash\nhelm repo add hashicorp https:\/\/helm.releases.hashicorp.com\nhelm repo update\nkubectl --kubeconfig kubecfg1.yml create ns vault\nkubectl --kubeconfig kubecfg2.yml create ns vault\nhelm --kubeconfig kubecfg1.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nhelm --kubeconfig kubecfg2.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nkubectl --kubeconfig kubecfg1.yml -n vault get pods\nkubectl --kubeconfig kubecfg2.yml -n vault get pods\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vt9w   1\/1     Running   0          92s\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vjnx   1\/1     Running   0          91s\n\u0060\u0060\u0060\n\n要安装 Istio，我们将使用 Tetrate Istio Distro [Helm chart](https:\/\/github.com\/tetratelabs\/helm-charts)。\n\n\u0060\u0060\u0060bash\nhelm repo add tetratelabs https:\/\/tetratelabs.github.io\/helm-charts\nhelm repo update\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster1-values.yaml\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster2-values.yaml\nkubectl --kubeconfig kubecfg1.yml -n istio-system get pods\nkubectl --kubeconfig kubecfg2.yml -n istio-system get pods\n\u0060\u0060\u0060\n\n请注意我们如何利用多个 Istio Helm chart 值覆盖来我们预期的目标：\n\n- 注入一个 pilot Pod 环境变量 \u0060ROOT_CA_DIR\u0060 来告诉 *istiod* 从哪里获取证书和私钥\n- 告诉 \u0060vault-agent-init\u0060 容器在 *istiod* 容器之前运行，因此秘密安装在 \u0060\/vault\/secrets\u0060 的卷中可用\n- 指示 Vault 注入器从正确的位置和数据密钥获取机密\n- 这样做时承担 Vault *istiod* 角色\n- 覆盖默认的 Kubernetes auth-path，因为我们有多个集群 \n\n\u0060\u0060\u0060yaml\npilot:\n  env:\n    ROOT_CA_DIR: \/vault\/secrets\n  podAnnotations:\n    vault.hashicorp.com\/agent-inject: \u0022true\u0022\n    vault.hashicorp.com\/agent-init-first: \u0022true\u0022\n    vault.hashicorp.com\/agent-inject-secret-ca-key.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-key.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_key }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-ca-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-root-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-root-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.root_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-cert-chain.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-cert-chain.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.cert_chain }}\n        {{ end -}}\n    vault.hashicorp.com\/role: \u0022istiod\u0022\n    vault.hashicorp.com\/auth-path: \u0022auth\/kubernetes-cluster1\u0022\n\u0060\u0060\u0060\n\n当我们查看 \u0060vault-agent-init\u0060 容器日志时，我们应该看到类似这样的内容。我们的控制平面已经正确地获取了 Vault 注入的秘密。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c vault-agent-init --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n==\u003e Vault agent started! Log data will stream in below:\n\n  ==\u003e Vault agent configuration:\n\n                      Cgo: disabled\n                Log Level: info\n                  Version: Vault v1.12.0, built 2022-10-10T18:14:33Z\n              Version Sha: 558abfa75702b5dab4c98e86b802fb9aef43b0eb\n\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: creating file sink\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: file sink configured: path=\/home\/vault\/.vault-token mode=-rw-r-----\n  2022-11-18T11:01:21.398Z [INFO]  template.server: starting template server\n  2022-11-18T11:01:21.398Z [INFO]  sink.server: starting sink server\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: starting auth handler\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: authenticating\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: authentication successful, sending token to sinks\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: starting renewal process\n  2022-11-18T11:01:21.402Z [INFO]  sink.file: token written: path=\/home\/vault\/.vault-token\n  2022-11-18T11:01:21.402Z [INFO]  sink.server: sink server stopped\n  2022-11-18T11:01:21.402Z [INFO]  sinks finished, exiting\n  2022-11-18T11:01:21.402Z [INFO]  template.server: template server received new token\n  2022-11-18T11:01:21.402Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO] (runner) starting\n  2022-11-18T11:01:21.403Z [INFO]  auth.handler: renewed auth token\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/root-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/cert-chain.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-key.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.516Z [INFO]  template.server: template server stopped\n  2022-11-18T11:01:21.516Z [INFO] (runner) received finish\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: shutdown triggered, stopping lifetime watcher\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: auth handler stopped\n\u0060\u0060\u0060\n\n当我们查看 \u0060discovery\u0060 容器日志时，我们应该看到如下内容：\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c discovery --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n info\tUsing istiod file format for signing ca files\n  info\tUse plugged-in cert at \/vault\/secrets\/ca-key.pem\n  info\tx509 cert - Issuer: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, Subject: \u0022\u0022, SN: 39f67569f10d36a1fc91e9d82156b07d, NotBefore: \u00222022-11-18T11:11:59Z\u0022, NotAfter: \u00222032-11-15T11:13:59Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, SN: dedf298a147681d6, NotBefore: \u00222022-11-17T22:01:54Z\u0022, NotAfter: \u00222024-11-16T22:01:54Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Root CA,O=Istio\u0022, SN: f5bcd7e89bdb6248, NotBefore: \u00222022-11-17T22:01:52Z\u0022, NotAfter: \u00222032-11-14T22:01:52Z\u0022\n  info\tIstiod certificates are reloaded\n  info\tspiffe\tAdded 1 certs to trust domain cluster.local in peer cert verifier\n\u0060\u0060\u0060\n\n我们可以看到我们的 Istio 控制平面已经正确地获取了我们的 Vault 注入证书和私钥。任务完成！\n\n## 结论\n\n在本文中，我们已经使用外部 Vault 存储的证书和私钥成功引导了 Istio 控制平面。实现这一目标的步骤包括：\n\n- 将证书和私钥存储在每个集群专用的 Vault 秘密安装路径中\n- 为每个集群设置 Kubernetes Vault 身份验证后端，链接到正确的 ServiceAccount\n- 定义适当的角色和策略以允许从 *istiod* ServiceAccount 访问 Vault 机密\n- 将 Istio Pilot 引导程序参数调整为：\n  - 注入 *vault-agent-init* sidecar\n  - 获取包含我们的证书和私钥的正确 Vault 机密\n  - 使用正确的角色和身份验证后端来这样做\n  - 从正确的 vault secret 安装路径中获取证书和私钥\n\n我们可以使用完全相同的技术来注入*入口网关*和*出口网关*证书。创建 Istio [Gateway](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings) 对象时，请确保将 *serverCertificate*、*privateKey* 和 *caCertificates* 指向 \u0060\/vault\/secrets\u0060 挂载卷中的正确文件。我们将把它作为练习留给读者。\n\n通过将证书注入绑定到 Kubernetes ServiceAccount，我们现在已将证书生命周期管理委托给外部秘密 Vault 实例。现在可以使用专用角色和写入\/更新策略创建服务门户或 CI\/CD 管道等外部流程，以提供必要的证书生命周期管理安全性。\n', '\/trans\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你使用 Vault 存储 Istio 的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/distributed-tracing-with-skywalking-in-istio/">如何在 Istio 中使用 SkyWalking 进行分布式追踪？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中使用 SkyWalking 进行分布式追踪？', '本文主要介绍了在云原生应用中分布式追踪的相关内容，包括分布式追踪基础、Istio 实现分布式追踪的方式、分布式追踪系统的选择、以 Bookinfo 和 SkyWalking 为例的实验以及总结和参考。', '\n在云原生应用中，一次请求往往需要经过一系列的 API 或后台服务处理才能完成，这些服务有些是并行的，有些是串行的，而且位于不同的平台或节点。那么如何确定一次调用的经过的服务路径和节点以帮助我们进行问题排查？这时候就需要使用到分布式追踪。\n\n本文将向你介绍：\n\n- 分布式追踪的原理\n- 如何选择分布式追踪软件\n- 在 Istio 中如何使用分布式追踪\n- 以 Bookinfo 和 SkyWalking 为例说明如何查看分布式追踪数据\n\n## 分布式追踪基础 {#tracing-basic}\n\n分布式追踪是一种用来跟踪分布式系统中请求的方法，它可以帮助用户更好地理解、控制和优化分布式系统。分布式追踪中用到了两个概念：TraceID 和 SpanID。\n\n- TraceID 是一个全局唯一的 ID，用来标识一个请求的追踪信息。一个请求的所有追踪信息都属于同一个 TraceID，TraceID 在整个请求的追踪过程中都是不变的；\n\n- SpanID 是一个局部唯一的 ID，用来标识一个请求在某一时刻的追踪信息。一个请求在不同的时间段会产生不同的 SpanID，SpanID 用来区分一个请求在不同时间段的追踪信息；\n\nTraceID 和 SpanID 是分布式追踪的基础，它们为分布式系统中请求的追踪提供了一个统一的标识，方便用户查询、管理和分析请求的追踪信息。\n\n![分布式追踪原理图](basic.svg)\n\n下面是分布式追踪的过程：\n\n1. 当一个系统收到请求后，分布式追踪系统会为该请求分配一个 TraceID，用于串联起整个调用链；\n2. 分布式追踪系统会为该请求在系统内的每一次服务调用生成一个 SpanID 和 ParentID，用于记录调用的父子关系，没有 ParentID 的 Span 将作为调用链的入口；\n3. 每个服务调用过程中都要传递 TraceID 和 SpanID；\n4. 在查看分布式追踪时，通过 TraceID 查询某次请求的全过程；\n\n## Istio 如何实现分布式追踪 {#distributed-tracing-in-istio}\n\nIstio 中的分布式追踪是基于数据平面中的 Envoy 代理实现的。服务请求在被劫持到 Envoy 中后，Envoy 在转发请求时会附加大量 Header，其中与分布式追踪相关的有：\n\n- 作为 TraceID：\u0060x-request-id\u0060\n- 用于在 LightStep 追踪系统中建立 Span 的父子关系：\u0060x-ot-span-context\u0060\n- 用于 Zipkin，同时适用于 Jaeger、SkyWalking，详见 [b3-propagation](https:\/\/github.com\/openzipkin\/b3-propagation)：\n  - \u0060x-b3-traceid\u0060\n  - \u0060x-b3-spanid\u0060\n  - \u0060x-b3-parentspanid\u0060\n  - \u0060x-b3-sampled\u0060\n  - \u0060x-b3-flags\u0060\n  - \u0060b3\u0060\n- 用于 Datadog：\n  - \u0060x-datadog-trace-id\u0060\n  - \u0060x-datadog-parent-id\u0060\n  - \u0060x-datadog-sampling-priority\u0060\n- 用于 SkyWalking：\u0060sw8\u0060\n- 用于 AWS X-Ray：\u0060x-amzn-trace-id\u0060\n\n关于这些 Header 的详细用法请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers)。\n\nEnvoy 会在 Ingress Gateway 中为你产生用于追踪的 Header，不论你的应用程序使用何种语言开发，Envoy 都会将这些 Header 转发到上游集群。但是，你还要对应用程序代码做一些小的修改，才能为使用分布式追踪功能。这是因为应用程序无法自动传播这些 Header，可以在程序中集成分布式追踪的 Agent，或者在代码中手动传播这些 Header。Envoy 会将追踪数据发送到 tracer 后端处理，然后就可以在 UI 中查看追踪数据了。\n\n例如在 Bookinfo 应用中的 Productpage 服务，如果你查看它的代码可以发现，其中集成了 Jaeger 客户端库，并在 \u0060getForwardHeaders (request)\u0060 方法中将 Envoy 生成的 Header 同步给对 Details 和 Reviews 服务的 HTTP 请求：\n\n\u0060\u0060\u0060python\ndef getForwardHeaders(request):\n    headers = {}\n\n    # 使用 Jaeger agent 获取 x-b3-* header\n    span = get_current_span()\n    carrier = {}\n    tracer.inject(\n        span_context=span.context,\n        format=Format.HTTP_HEADERS,\n        carrier=carrier)\n\n    headers.update(carrier)\n\n    # 手动处理非 x-b3-* header\n    if \u0027user\u0027 in session:\n        headers[\u0027end-user\u0027] = session[\u0027user\u0027]\n    incoming_headers = [\n        \u0027x-request-id\u0027,\n        \u0027x-ot-span-context\u0027,\n        \u0027x-datadog-trace-id\u0027,\n        \u0027x-datadog-parent-id\u0027,\n        \u0027x-datadog-sampling-priority\u0027,\n        \u0027traceparent\u0027,\n        \u0027tracestate\u0027,\n        \u0027x-cloud-trace-context\u0027,\n        \u0027grpc-trace-bin\u0027,\n        \u0027sw8\u0027,\n        \u0027user-agent\u0027,\n        \u0027cookie\u0027,\n        \u0027authorization\u0027,\n        \u0027jwt\u0027,\n    ]\n\n    for ihdr in incoming_headers:\n        val = request.headers.get(ihdr)\n        if val is not None:\n            headers[ihdr] = val\n\n    return headers\n\u0060\u0060\u0060\n\n关于 Istio 中分布式追踪的常见问题请见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)。\n\n## 分布式追踪系统如何选择 {#how-to-choose-a-distributed-tracing-system}\n\n分布式追踪系统的原理类似，市面上也有很多这样的系统，例如 [Apache SkyWalking](https:\/\/github.com\/apache\/skywalking)、[Jaeger](https:\/\/github.com\/jaegertracing\/jaeger)、[Zipkin](https:\/\/github.com\/openzipkin\/zipkin\/)、LightStep、[Pinpoint](https:\/\/github.com\/pinpoint-apm\/pinpoint) 等。我们将选择其中三个，从多个维度进行对比。之所以选择它们是因为：\n\n- 它们是当前最流行的开源分布式追踪系统；\n- 都是基于 OpenTracing 规范；\n- 都支持与 Istio 及 Envoy 集成；\n\n{{\u003ctable \u0022分布式追踪系统对比表（数据截止时间 2022-12-07）\u0022\u003e}}\n| 类别      | Apache SkyWalking                                            | Jaeger                                       | Zipkin                                       |\n| --------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| 实现方式  | 基于语言的探针、服务网格探针、eBPF agent、第三方指标库（当前支持 Zipkin） | 基于语言的探针                               | 基于语言的探针                               |\n| 数据存储  | ES、H2、MySQL、TiDB、Sharding-sphere、BanyanDB               | ES、MySQL、Cassandra、内存                   | ES、MySQL、Cassandra、内存                   |\n| 支持语言  | Java、Rust、PHP、NodeJS、Go、Python、C\u002b\u002b、.NET、Lua          | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b |\n| 发起者    | 个人                                                         | Uber                                         | Twitter                                      |\n| 治理方式  | Apache Foundation                                            | CNCF                                         | CNCF                                         |\n| 版本      | 9.3.0                                                        | 1.39.0                                       | 2.23.19                                      |\n| Star 数量 | 20.9k                                                        | 16.8k                                        | 15.8k                                        |\n\n{{\u003c\/table\u003e}}\n\n虽然 Apache SkyWalking 的 Agent 支持的语言没有 Jaeger 和 Zipkin 多，但是 SkyWalking 的实现方式更丰富，并且与 Jaeger、Zipkin 的追踪数据兼容，开发更为活跃，且为国人开发，中文资料丰富，是构建遥测平台的最佳选择之一。\n\n## 实验 {#demo}\n\n参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/skywalking\/)来安装和配置 Apache SkyWalking。\n\n### 环境说明 {#environments}\n\n以下是我们实验的环境：\n\n- Kubernetes 1.24.5\n- Istio 1.16\n- SkyWalking 9.1.0\n\n### 安装 Istio {#install-istio}\n\n安装之前可以先检查下环境是否有问题：\n\n\u0060\u0060\u0060bash\n$ istioctl experimental precheck\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\n  To get started, check out https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/\n\u0060\u0060\u0060\n\n然后使用 \u0060istioctl\u0060 安装 Istio 同时配置发送追踪信息的目的地为 SkyWalking：\n\n\u0060\u0060\u0060bash\n# 将安装配置保存到文件中\ncat\u003c\u003cEOF\u003eistio-install.yaml\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\n  name: istio-with-skywalking\nspec:\n  meshConfig:\n    defaultProviders:\n      tracing:\n      - \u0022skywalking\u0022\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: tracing.istio-system.svc.cluster.local\n        port: 11800\nEOF\n\n# 使用 istioctl 安装 Istio\nistioctl install -f istio-install.yaml\n\u0060\u0060\u0060\n\n### 部署 Apache SkyWalking {#install-skywalking}\n\nIstio 1.16 支持使用 Apache SkyWalking 进行分布式追踪，执行下面的代码安装 SkyWalking：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\n它将在 \u0060istio-system\u0060 命名空间下安装：\n\n- SkyWalking OAP (Observability Analysis Platform) ：用于接收追踪数据，支持 SkyWalking 原生数据格式，Zipkin v1 和 v2 以及 Jaeger 格式。\n- UI：用于查询分布式追踪数据。\n\n关于 SkyWalking 的详细信息请参考 SkyWalking 文档。\n\n### 部署 Bookinfo 应用 {#install-bookinfo}\n\n执行下面的命令安装 bookinfo 示例：\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n\u0060\u0060\u0060\n\n然后给 productpage 服务发送请求，如果你是在 Kind 中安装的 Istio，则默认的 IngressGateway 将是 LoadBalancer 类型，你可以使用端口转发的方式来暴露网关。\n\n\u0060\u0060\u0060bash\nkubectl port-forward -n istio-system svc\/istio-ingressgateway 8081:80\n\u0060\u0060\u0060\n\n通过 \u0060http:\/\/localhost:8081\/productpage\u0060 就可以访问到 productpage 服务。多访问几次来制造一些流量，后面我们就能在 SkyWalking UI 上看到拓扑图了。\n\n打开 SkyWalking UI：\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nSkyWalking 的 General Service 页面展示了 bookinfo 应用中的所有服务。\n\n![SkyWalking 的 General Service 页面](general-service.jpg)\n\n你还可以看到实例、端点、拓扑、追踪等信息。例如下图展示了 bookinfo 应用的服务拓扑。\n\n![Bookinfo 应用的服务拓扑](topology.jpg)\n\nSkyWalking 的追踪视图有多种显示形式，如列表、树形、表格和统计。\n\n![SkyWalking 通用服务追踪支持多种显示样式](gs-styles.jpg)\n\n为了方便我们检查，将追踪的采样率设置为 100%：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  tracing:\n  - randomSamplingPercentage: 100.00\nEOF\n\u0060\u0060\u0060\n\n### 卸载 {#purge}\n\n在实验完后，执行下面的命令卸载 Istio 和 SkyWalking：\n\n\u0060\u0060\u0060bash\nsamples\/bookinfo\/platform\/kube\/cleanup.sh\nistioctl unintall --purge\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## Bookinfo demo 追踪信息说明 {#bookinfo-tracing}\n\n在 Apache SkyWalking UI 中导航到 General Service 分页，查看最近的 \u0060istio-ingressgateway\u0060 服务的追踪信息，表视图如下所示。图中展示了此次请求所有 Span 的基本信息，点击每个 Span 可以查看详细信息。\n\n![表格视图中显示了 Span 的基本信息](span-table.jpg)\n\n切换为列表视图，可以看到每个 Span 的执行顺序及持续时间，如下图所示。\n\n![列表视图](trace-list.jpg)\n\n你可能会感到困惑，为什么这么简单的一个应用会产生如此多的 Span 信息？因为我们为 Pod 注入了 Envoy 代理之后，每个服务间的请求都会被 Envoy 拦截和处理，如下图所示。\n\n![Envoy 拦截请求产生 Span](span.svg)\n\n整个追踪流程如下图所示。\n\n![Bookinfo 的分布式追踪痕迹](bookinfo-spans-with-time.svg)\n\n图中给每一个 Span 标记了序号，并在括号里注明了耗时。为了便于说明我们将所有 Span 汇总在下面的表格中。\n\n| 序号 | 方法     | 总耗时（ms） | 组件耗时（ms） | 当前服务         | 说明                    |\n| -------- | ------------ | ------------------------ | -------------------------- | -------------------- | ------------------------------- |\n| 1    | \/productpage | 190                      | 0                          | istio-ingressgateway | Envoy Outbound          |\n| 2    | \/productpage | 190                      | 1                          | istio-ingressgateway | Ingress -\u003e Productpage 网络传输 |\n| 3    | \/productpage | 189                      | 1                          | productpage          | Envoy Inbound       |\n| 4    | \/productpage | 188                      | 21                         | productpage          | 应用内部处理        |\n| 5    | \/details\/0   | 8                        | 1                          | productpage          | Envoy Outbound      |\n| 6    | \/details\/0   | 7                        | 3                          | productpage          | Productpage -\u003e Details 网络传输     |\n| 7    | \/details\/0   | 4                        | 0                          | details              | Envoy Inbound           |\n| 8    | \/details\/0   | 4                        | 4                          | details              | 应用内部                |\n| 9    | \/reviews\/0   | 159                      | 0                          | productpage          | Envoy Outbound      |\n| 10   | \/reviews\/0   | 159                      | 14                         | productpage          | Productpage -\u003e Reviews 网络传输 |\n| 11   | \/reviews\/0   | 145                      | 1                          | reviews              | Envoy Inbound           |\n| 12   | \/reviews\/0   | 144                      | 109                        | reviews              | 应用内部处理              |\n| 13   | \/ratings\/0   | 35                       | 2                          | reviews              | Envoy Outbound          |\n| 14   | \/ratings\/0   | 33                       | 16                         | reviews              | Reviews -\u003e Ratings 网络传输         |\n| 15   | \/ratings\/0   | 17                       | 1                          | ratings              | Envoy Inbound           |\n| 16   | \/ratings\/0   | 16                       | 16                         | ratings              | 应用内部处理            |\n\n从以上信息可以发现：\n\n- 本次请求总耗时 190ms；\n- 在 Istio sidecar 模式下，每次流量在进出应用容器时都需要经过一次 Envoy 代理，每次耗时在 0 到 2 ms；\n- 在 Pod 间的网络请求耗时在 1 到 16ms 之间；\n- 将耗时做多的调用链 Ingress Gateway -\u003e Productpage -\u003e Reviews -\u003e Ratings 上的所有耗时累计 182 ms，小于请求总耗时 190ms，这是因为数据本身有误差，以及 Span 的开始时间并不一定等于父 Span 的结束时间，如果你在 SkyWalking 的追踪页面，选择「列表」样式查看追踪数据（见图 2）可以更直观的发现这个问题；\n- 我们可以查看到最耗时的部分是 Reviews 应用，耗时 109ms，因此我们可以针对该应用进行优化；\n\n## 总结 {#summary}\n\n只要对应用代码稍作修改就可以在 Istio 很方便的使用分布式追踪功能。在 Istio 支持的众多分布式追踪系统中，[Apache SkyWalking](https:\/\/skywalking.apache.org\/) 是其中的佼佼者。它不仅支持分布式追踪，还支持指标和日志收集、报警、Kubernetes 和服务网格监控，[使用 eBPF 诊断服务网格性能](https:\/\/skywalking.apache.org\/zh\/diagnose-service-mesh-network-performance-with-ebpf\/)等功能，是一个功能完备的云原生应用分析平台。本文中为了方便演示，将追踪采样率设置为了 100%，在生产使用时请根据需要调整采样策略（采样百分比），防止产生过多的追踪日志。\n\n## 参考 {#reference}\n\n- [Istio 分布式追踪概览 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/observability\/distributed-tracing\/overview\/)\n- [Istio 分布式追踪 FAQ - istio.io](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)\n', '\/blog\/distributed-tracing-with-skywalking-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要介绍了在云原生应用中分布式追踪的相关内容，包括分布式追踪基础、Istio 实现分布式追踪的方式、分布式追踪系统的选择、以 Bookinfo 和 SkyWalking 为例的实验以及总结和参考。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-the-tls-encryption-in-istio/">如何理解 Istio 中的 mTLS 流量加密？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 mTLS 流量加密？', '本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。', '\nIstio 服务网格可以帮助云原生应用实现自动 mTLS，完成网格内的流量加密，有助于缩小云原生部署的攻击面，是构建零信任应用网络的关键框架。为了理解 Istio 中的 mTLS 流量加密，本文将包括以下内容：\n\n- 介绍什么是 TLS、mTLS 和 TLS 终止\n- 介绍 Istio 中如何实现 TLS 加密\n- 如何使用 Istio 为 Kubernetes 中的服务实现 mTLS？\n- 何时需要 mTLS？何时不需要 mTLS？\n\n## 什么是 TLS 和 mTLS？{#what-is-tls-and-mtls}\n\nTLS（Transport Layer Security，传输层安全性）是一种广泛采用的安全协议，用于在联网计算机之间建立经过身份验证和加密的链接，旨在促进互联网通信的私密性和数据安全性。TLS 作为 [SSL](https:\/\/www.ssl.com\/faqs\/faq-what-is-ssl\/)（Secure Socket Layer，安全套接字层）的继任者，实际上是由 SSL 改名而来，因此人们经常将 TLS\/SSL 混用，在本文中我们将统称为 TLS。TLS 1.0 发布于 1999 年，最新版本为 1.3（发布于 2018 年 8 月），1.0 和 1.1 版本已弃用。\n\n我们在浏览网页时看到的 HTTPS 实际上就使用了 TLS，如下图所示。TLS 是建立在 TCP 之上的，作为 OSI 模型中的会话层。为了保证兼容性，TLS 通常使用 443 端口，但是你也可以使用任意端口。\n\n![HTTP vs HTTPS](http-vs-https.svg)\n\n当客户端需要验证服务端身份，以防中间人攻击同时保证通信安全的情况下，在和服务端通信时会要求 TLS 加密。下图展示了的是 TLS 加密通信的流程。\n\n![TLS 加密通信流程](tls-flow.svg)\n\n1. 服务器向受信任的 CA（证书管理机构）申请并获得证书（X.509 证书）；\n2. 客户端向服务端发起请求，其中包含客户端支持的 TLS 版本和密码组合等信息；\n3. 服务器回应客户端请求并附上数字证书；\n4. 客户端验证证书的状态、有效期和数字签名等信息，确认服务器的身份；\n5. 客户端和服务器使用共享秘钥实现加密通信；\n\n以上仅是对 TLS 通信流程的一个概要描述，实际的 TLS 握手过程比较复杂，请参考[这篇文档](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)。\n\n从以上过程中你会发现，证书是代表服务器身份的关键要素，对于互联网公开服务，服务器需要使用权威认证的 CA 颁发的证书，而对于私有环境内部的服务，可以使用 PKI（Private Key Infrastructure，私钥基础设施）来管理证书。\n\n双向 TLS 或相互 TLS（Mutual TLS 或 mTLS）是指在服务端和客户端之间使用双向加密通道，需要双方相互提供证书并验证对方身份。关于如何在 Kubernetes 中使用 mTLS 请参考[这篇文章](https:\/\/cloudnativecn.com\/blog\/mtls-guide\/)。关于 mTLS 的详细介绍请见[这篇文章](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)。\n\n## 什么是 TLS 终止？{#what-is-tls-termination}\n\nTLS 终止（TLS Termination）指的是在将 TLS 加密流量传递给 Web 服务器之前对其进行解密的过程。将 TLS 流量卸载到入口网关或专用设备上，可以提高 Web 应用的性能，同时确保加密流量的安全性。一般运行在集群入口处，当流量到达入口处时实施 TLS 终止，入口与集群内服务器之间的通信将直接使用 HTTP 明文，这样可以提高服务性能。\n\n![TLS 终止](tls-termination.svg)\n\nIstio 默认在入口网关处终止 TLS，然后再为网格内的服务开启 mTLS。你也可以让流量直通（passthrough）到后端服务处理，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\n详见[网关 TLS  配置](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways)。\n\n## Istio 中如何实现自动 mTLS？{#istio-mtls}\n\n下图中展示的是 Istio 安全架构图，从图中可以看到在入口处使用 JWS \u002b TLS 认证和加密，在 Istio 网格内部的所有服务间都开启了 mTLS。\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio 中内置了 CA，使用 xDS 中的 SDS（Secret Discovery Service，秘密发现服务）实现 SVID 证书的签发和轮换。Istio 网格内的 mTLS 流程如下：\n\n1. Sidecar 代替工作负载向 Istiod 申请证书，Istiod 签发 [SVID](\/book\/kubernetes-handbook\/auth\/spiffe\/#svid) 证书（该过程比较复杂，我将在今后的博客中说明）；\n2. 客户端请求被 Pod 内的 sidecar 拦截；\n3. 客户端 sidecar 与服务端 sidecar 开始 mTLS 握手。在握手的同时，客户端 sidecar 中的 JWT 和认证过滤器将对请求的身份进行认证，认证通过后将身份存储在过滤器元数据中，然后请求经过授权过滤器，判断请求权限。\n4. 若请求通过了认证与授权，则客户端和服务端开始建立连接进行通信。\n\nIstio 中有三个资源对象可用于配置服务间的认证与授权：\n\n- \u0060RequestAuthentication\u0060：用于定义服务支持的请求级认证方式，目前只支持  JWT（[查看 JWT 组件详解](https:\/\/cloudnativecn.com\/blog\/jwt-components-explained\/)）；\n- \u0060PeerAuthentication\u0060：配置服务间的传输认证模式，如 \u0060STRICT\u0060、\u0060PERMISSIVE\u0060 或 \u0060DISABLE\u0060 等，以开启 mTLS 或明文请求；\n- \u0060AuthorizationPolicy\u0060：用于授权服务间的流量，定义谁可以做什么？例如主体 A 允许（\u0060ALLOW\u0060）或拒绝（\u0060DENY\u0060）来自主体 B 的流量；\n\n## 如何使用 Istio 为服务开启自动 mTLS？ {#how-to-setup-mtls}\n\n你可以在 \u0060PeerAuthentication\u0060 中指定对目标工作负载实施的 mTLS 模式。对等认证支持以下模式：\n\n- \u0060PERMISSIVE\u0060：默认值，工作负载可接受双向 TLS 或纯文本流量；\n- \u0060STRICT\u0060：工作负载仅接受 mTLS 流量；\n- \u0060DISABLE\u0060：禁用 mTLS。从安全角度来看，除非你有自己的安全解决方案，否则不应禁用 mTLS；\n- \u0060UNSET\u0060：从父级继承，优先级为服务特定 \u003e 命名空间范围 \u003e 网格范围的设置；\n\nIstio 的对等认证默认使用 \u0060PERMISSIVE\u0060 模式，自动将 mTLS 流量发送到这些工作负载，将纯文本流量发送到没有 sidecar 的工作负载。在将 Kubernetes 服务纳入 Istio 网格后，为了防止服务无法通过 mTLS，我们可以先使用 \u0060PERMISSIVE\u0060 模式。当我想为某些服务开启严格的 mTLS 模式时，可以使用以下两种方式之一：\n\n- 使用 \u0060PeerAuthentication\u0060 定义流量如何在 sidecar 之间传输；\n- 使用 \u0060DestinationRule\u0060 定义流量路由策略中的 TLS 设置；\n\n下面以为 \u0060default\u0060 命名空间下的 \u0060reviews\u0060 服务设置 mTLS 为例说明。\n\n### 使用 PeerAuthentication 为工作负载设置 mTLS {#peerauthentication-tls-setting}\n\n你可以使用 \u0060namespace\u0060 和 \u0060selector\u0060 指定某个命名空间下的某个工作负载开启严格的 mTLS。例如下面的配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\n你也可以给安装 Istio  的命名空间 \u0060istio-system\u0060 设置严格的 mTLS，那样会为网格中的所有服务开启严格的 mTLS，详细步骤请参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/authentication\/mtls-migration\/)。\n\n### 使用 DestinationRule 为工作负载设置 mTLS {#destinationrule-tls-setting}\n\nDestinationRule 用于设置流量路由策略，例如负载均衡、异常点检测、TLS 设置等。其中 TLS 设置中包含[多种模式](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ClientTLSSettings-TLSmode)，使用 \u0060ISTIO_MUTUAL\u0060 模式可以为工作负载开启 Istio 的自动 TLS，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## 什么时候用 mTLS？{#when-use-mtls}\n\n互联网客户端对 Web 服务的访问，一般使用单向 TLS，即只需要服务端提供身份证明，而不关心客户端的身份。当你需要验证客户端身份时，使用单向 TLS 可以使用密码、token、双因子认证等方式。不过这样的认证方式需要应用程序内部支持，而双向 TLS 是运行在应用程序之外的，不需要多应用逻辑进行修改。\n\n当你需要正如你在上文中看到的，实施 mTLS 的服务间需要交换证书，当服务数量变大时，就需要管理大量的证书，这需要消耗大量的精力，使用服务网格可以帮助你实现自动 mTLS，彻底解决证书管理的难题。\n\n## 什么时候不用 mTLS？{#when-not-use-mtls}\n\n虽然 mTLS 是确保云原生应用程序服务间通信安全的首选协议，但是应用 mTLS 需要完成复杂的对称加密、解密过程，这将非常耗时且消耗大量的 CPU 资源。对于某些安全级别不高的流量，如果我们在流量入口处终止 TLS，并网格内部仅对针对性的服务开启 mTLS，就可以加快请求响应和减少计算资源消耗。\n\n另外当有的服务无法获取证书，例如 Kubelet 上使用 HTTP 的健康检查，无法通过 TLS 访问服务内的健康检查端点，这时候就需要[为 Pod 禁用探针重写](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod)。\n\n最后当网格中的服务访问一些外部服务时，也不需要 mTLS。\n\n## 总结 {#summary}\n\nmTLS 实现了网格内流量的加密，是构建零信任应用网络的关键一步。借助 Istio 我们可以很方便的为 Kubernetes 中的服务开启自动 mTLS，省去管理证书的麻烦。同时，我们也可以针对性的为网格内的部分服务开启 mTLS，便于我们将 Kubernetes 中的服务迁移到网格内。关于 Istio 中的证书管理，我们将在今后的博客中再做说明。\n\n## 参考 {#reference}\n\n- [什么是 TLS（传输层安全性）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/ssl\/transport-layer-security-tls\/)\n- [什么是相互 TLS（mTLS）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)\n- [What happens in a TLS handshake? | SSL handshake - cloudflare.com](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n- [写给 Kubernetes 工程师的 mTLS 指南 - jimmysong.io](https:\/\/cloudnativecn.com\/blog\/mtls-guide\/)\n- [云原生安全白皮书中文版 - github.com](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/security-whitepaper\/v1\/cloud-native-security-whitepaper-simplified-chinese.md)\n- [Istio 安全 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/)\n- [JWT 组件详解 - jimmysong.io](https:\/\/cloudnativecn.com\/blog\/jwt-components-explained\/)\n', '\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/5/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/7/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
