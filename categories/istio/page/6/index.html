<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Istio 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/istio/" />
  <meta property="og:title" content="Istio 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Istio 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />
  <meta property="twitter:description" content="欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/istio/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio 专栏
                </p>
                <p class="page-description">
                    欢迎来到 Istio 专栏，这里是关于服务网格 Istio 的全面资源和深入解读。涵盖了从入门到高级使用的各种主题，包括服务发现、负载均衡、流量管理、策略执行和可观测性。无论你是初学者还是资深用户，都能在这里找到有价值的内容。通过教程、指南和最佳实践，你将能够更好地理解和应用 Istio，提升你的微服务架构的可靠性和可管理性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/">[译] 如何通过服务网格增强微服务的安全性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/05</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何通过服务网格增强微服务的安全性', '我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。', '\n本文是 Tetrate 即将出版的《Istio in Production》一书中摘录的服务网格最佳实践系列的第一篇，作者是 Tetrate 创始工程师 Zack Butcher。\n\n我们接到许多实施网格的企业的问题，其中之一是“我还需要哪些控制，而网格提供哪些控制？”换句话说，他们想知道网格如何适应现有的安全模型。我们发现，网格最适合作为一组安全控制的内圈，这些控制从物理网络到应用本身的每一层都被实施。\n\n## 服务网格作为通用策略执行点\n\n我们看到网格的 Sidecar 作为通用策略执行点（[NIST SP 800-204B：使用服务网格的基于属性的访问控制](https:\/\/csrc.nist.gov\/publications\/detail\/sp\/800-204b\/final)）。由于它拦截了所有进出应用程序的流量，Sidecar 为我们提供了一个强大的位置来实现各种策略。我们可以实现传统的安全策略，如基于应用程序标识而非网络位置的更高保证的应用程序之间的授权。但我们也可以实施之前不切实际或需要与应用程序深度参与的策略。例如，网格允许你编写以下策略：“后端可以从数据库读取（使用应用级身份进行身份验证和授权），但前提是请求具有有效的最终用户凭证并具有读取范围（使用最终用户身份进行身份验证和授权）。”\n\n虽然服务网格提供了一个强大，动态和一致的安全基线，你可以在其上构建应用程序安全模型，但网格本身永远无法提供应用程序所需的 100% 运行时安全。例如，由于 Sidecar 位于用户空间中，网格在减轻许多类型的网络拒绝服务攻击方面不如传统防火墙机制。另一方面，由于同样的原因，网格在减轻许多应用级拒绝服务攻击方面比传统基础设施更有效。\n\n## 作为一个强大的中间层\n\n网格作为基础架构的强大中间层：位于物理网络和所实施的 L3\/L4 控制之上，但位于应用程序之下。这允许更脆弱和更难以改变的松散配置 —— 允许更高层的更大敏捷性 —— 因为控制体系在更高层被考虑。\n\n![图 1：增加细粒度策略层以增强传统安全。](f1.png)\n\n网格提供的主要安全功能是：\n\n- 作为 X.509 证书的**运行时身份**，用于在传输期间加密，以及服务之间通信的身份验证和授权。\n- **策略执行点**，用于在网格中的所有应用程序上实施一致的最终用户身份验证和授权。\n- 服务身份和最终用户身份的**运行时策略执行**（例如，“A 只能使用具有读取范围的有效最终用户凭证与 B 进行通信”）。\n- **速率限制和弹性功能**，用于减轻常见的应用级拒绝服务攻击，并保护免受常见的级联故障模式的影响。\n- **WAF** 和其他**深层包检测**功能，用于内部流量，而不仅仅是在边缘。\n- 来自网格中所有应用程序的**一致的操作遥测**，可用于理解、实施和审核安全策略。\n- 具有动态运行时更新的**策略即代码**（Policy-as-code）模型，独立于应用程序生命周期。\n\n## 服务网格作为分层防御的一部分\n\n考虑到网格的安全功能，我们认为，组织采用它作为分层防御方法的一部分是最合理的。\n\n![图 2：每层策略的示例以及一个示例部署拓扑。](f2.png)\n\n## L3 层的敏捷性：粗粒度的入口和出口策略以及 L7 的细粒度控制\n\n在边缘的 L3 控制（如防火墙）在粗粒度的入口和出口策略方面仍然有效，但通常会减慢应用程序开发敏捷性。由于网格提供了细粒度的服务间授权，所以可以在 L3 上设置更广泛的策略，为平台、安全和应用程序团队提供更多敏捷性。\n\n**实施对外部服务的访问控制**。网格的出口代理特别适用于实施应用程序到外部服务的控制，而只有出口代理本身被外出防火墙 allow-listed：这为平台或安全团队在管理哪些应用程序允许与企业基础架构之外的通信提供了很多敏捷性，同时保持现有的基于周界的模型。\n\n**使用加密和动态访问控制代替“可达性即授权”**。网格可以开始有效地取代 VPN 和基于 IPSec 的网络“可达性即授权”模式，提供传输中的加密，以及每个应用而不是每个主机的认证和授权。\n\n## L4 层的改进：更扁平和易于管理的网络微分段\n\n微分段之类的控制可以通过网格进一步改进：尽管我们可能允许整个（小）子网在基于分段的策略中进行通信，但我们可以使用网格按方法和动词对单独的服务间通信进行控制。\n\n**补充现有的微分段同时展平网络**。通过提供细粒度的服务间控制，网格往往会补充现有的微分段策略，同时使得组织更容易管理的较平的网络得以采用（例如，在云环境中）。\n\n**使用工作负载身份启用传输期间的加密（mTLS）和服务级别访问控制**。传输层几乎总是处理加密传输，网格通过根据 SPIFFE 规范发布和轮换短期（\u003c24 小时）工作负载身份证书来为应用程序实现此功能，从而允许传输期间的加密以及服务级别的身份验证和授权。\n\n## L7 层的增强：无处不在的边缘和访问控制\n\n**为所有流量提供边缘控制**。L7 控制，如 Web 应用程序防火墙（WAF）以及“API 网关功能”（如流量限制）几乎总是在边缘实施。网格可以通过为网格中所有流量（包括内部的“东西”通信）启用相同的功能来增强这些现有部署。\n\n**简化应用程序的访问控制**。除了使边缘控制无处不在之外，网格还可以在应用程序看到请求之前执行端用户身份验证和粗粒度授权，从而大大简化应用程序本身必须执行的访问控制。在未来，我们将看到越来越多的访问控制功能从应用程序迁移到网格中。\n\n## 总结和展望\n\n我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。作为一个通用策略执行点，网格在更改最困难的较低层提供了更松散的策略，将敏捷性推向堆栈的顶部，其中更多的上下文允许在更高层实现更特定的控制。这种强大的安全层对于大多数组织来说都是采用分层防御深度方法的最佳选择。\n\n## 接下来：服务网格部署最佳实践\n\n我们服务网格最佳实践系列博客文章的下一篇将讨论部署拓扑。在多个集群的真实基础架构中部署服务网格时存在一些移动部分。在下一篇文章中，我们将更详细地研究：\n\n- 控制平面应如何部署在应用程序附近。 \n- 应该如何部署入口，以促进安全和敏捷性。\n- 如何使用 Envoy 促进跨集群的负载平衡。\n- 证书在网格中应该是什么样子的。\n\n---\n\n如果你不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供了一系列免费在线课程，可以让你快速了解 Istio 和 Envoy。\n\n如果你正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为你知道你有一个值得信赖的发行版，有一个支持你的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，你可能需要更简单的方法来管理和保护你的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。你可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n', '\/trans\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们认为，服务网格最适合作为现有安全模型的一部分，通过在传统安全控制之上添加更细粒度的安全策略来实现。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cert-manager-spire-istio/">使用 cert-manager 和 SPIRE 管理 Istio 中的证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 cert-manager 和 SPIRE 管理 Istio 中的证书', '本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。', '{{\u003ccallout warning\u0022注意\u0022\u003e}}\n\n从 v1.5.4 版本开始，SPIRE 移除了 Kubernetes Workload Registrar 组件，改用 SPIRE Controller Manager，详见 [spire\/spire issue #3853](https:\/\/github.com\/spiffe\/spire\/pull\/3853)。根据我的测试，本文中的程序在 v1.5.4 或更高版本上无法执行，因为会遇到一系列身份验证失败的问题。\n{{\u003c\/callout\u003e}}\n\n在[上一篇博客](\/blog\/istio-certificates-management\/)中我介绍了 Istio 中是如何管理证书的，这篇文章将指导你如何使用外置 CA，通过集成 [SPIRE](https:\/\/spiffe.io\/) 和 [cert-manager](https:\/\/cert-manager.io\/) 实现细粒度的证书管理和自动证书轮换。\n\n如果你还不了解什么是 SPIRE 以及为什么我们要使用 SPIRE，推荐你阅读以下内容：\n\n- [为什么 Istio 要使用 SPIRE 做身份认证？](\/blog\/why-istio-need-spire\/)\n- [如何在 Istio 中集成 SPIRE？](\/blog\/how-to-integrate-spire-with-istio\/)\n- [零信任的基石：使用 SPIFFE 为基础设施创建通用身份](\/book\/spiffe\/)\n\n## 证书签发管理流程简介 {#intro}\n\n下图展示了本文中使用的基于 cert-manager 和 SPIRE 的证书信任链：\n\n![基于 cert-manager、SPIRE 的证书信任链](spire-chain-tree.svg)\n\n从图中你可以看出：\n\n- cert-manager 作为根 CA 为 *istiod* 和 SPIRE 颁发证书，我们使用了[自签名 Issuer](https:\/\/cert-manager.io\/docs\/configuration\/selfsigned\/)，你还可以为其配置使用 Let\u0027s Encrypt、Vault、Venafi 等内置 Issuer，或其他外置的 Issuer；另外你也可以选择使用其他 [UpstreamAuthority](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)，例如 Vault、SPIRE 联邦等；\n- SPIRE 为 Istio 网格内工作负载和 Ingress Gateway、Egress Gateway 颁发 SVID 证书，用于服务间 mTLS；\n- 其中网格外访问 Ingress Gateway 时的使用的证书及 Egress Gateway 访问网格外服务使用的证书需要额外配置；\n\n下图展示了在 Istio 中集成 SPIRE 和 cert-manger 后的证书颁发和更新流程。\n\n![Istio 集成 SPIRE 和 cert-manager 后的证书颁发和更新流程](cert-manager-spire-istio.svg)\n\n1. SPIRE Server 中的 SPIRE Controller Manager 自动注册 Kubernetes 中的工作负载，为所有工作负载生成 SPIFFE 标准的身份；\n2. cert-manager 为 *istiod* 颁发并管理 CA 证书；\n3. 工作负载中的 Envoy 代理通过 UNIX Domain Socket（UDS）通过 SDS API 向同节点上的 SPIRE Agent 发送 CSR 请求；\n4. SPIRE Agent 向 SPIRE Server 发送 CSR；\n5. SPIRE Server 向 SPIRE Agent 返回签名后的证书；\n6. SPIRE Agent 向工作负载返回签名后的证书；\n7. SPIRE 负责工作负载的证书管理和更新；\n\n在了解了大致流程后，下面我们将依次安装各个组件。各个组件版本如下：\n\n- cert-manager v1.15.1\n- SPIRE v1.2.0\n- Istio v1.21.1\n\n## 安装 cert-manager {#install-cert-manager}\n\n运行下面的命令安装 cert-manager，我们将使用它来实现自动证书轮换：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/cert-manager\/cert-manager\/releases\/download\/v1.15.1\/cert-manager.yaml\n\u0060\u0060\u0060\n\n根 CA 是用自签名证书，运行下面的命令配置根 CA：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Issuer\nmetadata:\n  name: selfsigned\n  namespace: cert-manager\nspec:\n  selfSigned: {}\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: selfsigned-ca\n  namespace: cert-manager\nspec:\n  isCA: true\n  duration: 21600h\n  secretName: selfsigned-ca\n  commonName: certmanager-ca\n  subject:\n    organizations:\n      - cert-manager\n  issuerRef:\n    name: selfsigned\n    kind: Issuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io\/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned-ca\nspec:\n  ca:\n    secretName: selfsigned-ca\nEOF\n\u0060\u0060\u0060\n\n然后为 *istiod* 配置证书：\n\n\u0060\u0060\u0060yaml\nkubectl create namespace istio-system\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 1440h\n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n现在我们已经安装好了 cert-manager，并创建了名为 \u0060selfsigned-ca\u0060 的 \u0060clusterIssuer\u0060，接下来，我们来安装 SPIRE 并将 cert-manager 作为 SPIRE 的  [\u0060UpstreamAuthority\u0060](https:\/\/github.com\/spiffe\/spire\/blob\/main\/doc\/plugin_server_upstreamauthority_cert_manager.md)。\n\n## 安装 SPIRE {#install-spire}\n\n运行下面的命令快速安装 SPIRE：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/jimmysong.io\/blog\/cert-manager-spire-istio\/manifests\/spire-with-cert-manager-upstream-authority-quick-start.yaml\n\u0060\u0060\u0060\n\n该 YAML 文件比起 Istio 安装包中的 [\u0060samples\/security\/spire\/spire-quickstart.yaml\u0060](https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.22\/samples\/security\/spire\/spire-quickstart.yaml) 文件增加了对 cert-manager 的适配，如：\n\n- 为 \u0060spire-server-cluster-role\u0060 ClusterRole 增加了对 \u0060cert-manager.io\u0060 API 组的权限；\n- 在 SPIRE Server 的配置中增加了 \u0060UpstreamAuthority \u0022cert-manager\u0022\u0060 配置； \n\n{{\u003ccallout note \u0022注意\u0022\u003e}}\n\nSPIRE Server 配置中的 \u0060trust_domain\u0060 应与安装 Istio 时指定的 \u0060TRUST_DOMAIN\u0060 环境变量的值保持一致。\n\n{{\u003c\/callout\u003e}}\n\n该命令中会安装 SPIRE Controller Manager，自动注册 Kubernetes 中的工作负载。所有工作负载将根据其服务账户注册 SPIFFE 标准的服务身份格式 \u0060spiffe:\/\/\u003ctrust-domain\u003e\/ns\/\u003cnamespace\u003e\/sa\/\u003cservice-account\u003e\u0060。\n\n如果你想调整 SPIRE CA 和 SVID 证书的 TTL，可以在 SPIRE Server 的配置中修改 \u0060ca_ttl\u0060（默认 24h）和 \u0060default_svid_ttl\u0060（默认 1h），详见 [SPIRE Server 配置](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/)。\n\n## 安装 Istio {#install-istio}\n\nPod 中的 Envoy 代理将共享本地 SPIRE Agent 的 Unix Domain Socket，通过 Workload API 与 SPIRE Server 通信获取证书，如下图所示。\n\n![SPIRE Agent 架构图](spire-agent.svg)\n\n运行下面的命令安装 Istio 并启用 CA 证书自动轮换：\n\n\u0060\u0060\u0060yaml\nistioctl install --skip-confirmation -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\nspec:\n  profile: default\n  meshConfig:\n    # 信任域应与 SPIRE Server 中配置的信任域相同\n    trustDomain: example.org\n  values:\n    global:\n    # 自定义 sidecar 模板\n    sidecarInjectorWebhook:\n      templates:\n        spire: |\n          spec:\n            containers:\n            - name: istio-proxy\n              volumeMounts:\n              - name: workload-socket\n                mountPath: \/run\/secrets\/workload-spiffe-uds\n                readOnly: true\n            volumes:\n              - name: workload-socket\n                csi:\n                  driver: \u0022csi.spiffe.io\u0022\n                  readOnly: true\n  components:\n    pilot:\n      k8s:\n        env:\n          # 如果启用，如果用户引入新的中间插件 CA，用户不需要重新启动 istiod 来获取证书。Istiod 会获取新添加的中间插件 CA 的证书并更新它。不支持插入新的 Root-CA。\n          - name: AUTO_RELOAD_PLUGIN_CERTS\n            value: \u0022true\u0022 \n    ingressGateways:\n      - name: istio-ingressgateway\n        enabled: true\n        label:\n          istio: ingressgateway\n        k8s:\n          overlays:\n            - apiVersion: apps\/v1\n              kind: Deployment\n              name: istio-ingressgateway\n              patches:\n                - path: spec.template.spec.volumes.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    csi:\n                      driver: \u0022csi.spiffe.io\u0022\n                      readOnly: true\n                - path: spec.template.spec.containers.[name:istio-proxy].volumeMounts.[name:workload-socket]\n                  value:\n                    name: workload-socket\n                    mountPath: \u0022\/run\/secrets\/workload-spiffe-uds\u0022\n                    readOnly: true\nEOF\n\u0060\u0060\u0060\n\n因为我们要使用 Istio Operator 中声明的 \u0060spire\u0060 模板来部署工作负载，因此我们运行下面的命令部署 Bookinfo 应用：\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f bookinfo-with-spire-template.yaml | kubectl apply -n default -f -\n\u0060\u0060\u0060\n\n**注意**：上面命令中使用的 \u0060bookinfo-with-spire-template.yaml\u0060 文件可以在[这里](.\/manifests\/bookinfo-with-spire-template.yaml)找到，与 Istio 安装包中的 [\u0060samples\/bookinfo\/platform\/kube\/bookinfo.yaml\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml) 文件唯一的区别就是每个 Deployment 的 template 中都增加了以下注解：\n\n\u0060\u0060\u0060yaml\nannotations:\n  inject.istio.io\/templates: \u0022sidecar,spire\u0022\n\u0060\u0060\u0060\n\n## 验证 SPIRE {#validate-spire}\n\n我们将通过检查 productpage 服务的身份和证书配置来验证 SPIRE 是否生效。\n\n使用下面的命令可以检查 SPIRE 是否给工作负载颁发了身份证明：\n\n\u0060\u0060\u0060bash\nkubectl exec -i -t spire-server-0 -n spire -c spire-server -- \/bin\/sh -c \u0022bin\/spire-server entry show -socketPath \/run\/spire\/sockets\/server.sock -spiffeID spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\u0022\n\u0060\u0060\u0060\n\n你可以在输出结果中看到 protuctpage 服务的身份信息：\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 69fbf896-a296-4c3c-8179-44bf4e49e474\nSPIFFE ID        : spiffe:\/\/example.org\/ns\/default\/sa\/bookinfo-productpage\nParent ID        : spiffe:\/\/example.org\/k8s-workload-registrar\/demo-cluster\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nTTL              : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:default\nSelector         : k8s:pod-uid:73347537-a3e5-4e43-b8c5-bd315c7385b7\nDNS name         : productpage-v1-7f444fc4dd-rq47m\nDNS name         : productpage.default.svc\n\u0060\u0060\u0060\n\n查看 \u0060productpage\u0060 pod 的证书信任链：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n查看根证书：\n\n\u0060\u0060\u0060bash\nistioctl -n default proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n\u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n\u0060\u0060\u0060\n\n\u0060chain.pem\u0060 文件是证书信任链，其中包含两个证书，将它们保存到两个文件中：\n\n\u0060\u0060\u0060bash\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\n\u0060\u0060\u0060\n\n后使用 OpenSSL 查看所有证书：\n\n\u0060\u0060\u0060\nopenssl x509 -noout -text -in cert-aa\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in root.pem\n\u0060\u0060\u0060\n\n你将看到如下的证书信任链 \u0060root.pem\u0060 -\u003e \u0060cert-aa\u0060  -\u003e \u0060cert-ab\u0060，如下图所示：\n\n![Productpage 服务的证书信任链](spire-bookinfo-cert-chain.svg)\n\n查看 Istiod 的证书：\n\n\u0060\u0060\u0060bash\nistioctl -n istio-system proxy-config secret deployment\/istiod -o json | jq -r \\\n\u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n\u0060\u0060\u0060\n\n从证书信任链中我们可以看到：\n\n- cert-manager 做为 PKI 的根节点为 *istiod* 颁发证书；\n- SPIRE 作为中间 CA 再为各个工作负载颁发证书；\n- Istio 网格中工作负载的 X509 v3 主体别名中的 URI 遵循了 SPIFF 身份规范；\n- Istio 服务网格中的所有工作负载的身份和证书都由 SPIRE 来管理；\n\n## 设置证书自动轮换 {#cert-auto-rotate}\n\n如果你要修改 *istiod* 证书的轮换周期，从 60 天（1440 小时）缩短到 30 天（720 小时），运行下面的命令：\n\n\u0060\u0060\u0060yaml\ncat \u003c\u003c EOF | kubectl apply -f -\n---\napiVersion: cert-manager.io\/v1\nkind: Certificate\nmetadata:\n  name: cacerts\n  namespace: istio-system\nspec:\n  secretName: cacerts\n  duration: 720h \n  renewBefore: 360h\n  commonName: istiod.istio-system.svc\n  isCA: true\n  usages:\n    - digital signature\n    - key encipherment\n    - cert sign\n  dnsNames:\n    - istiod.istio-system.svc\n  issuerRef:\n    name: selfsigned-ca\n    kind: ClusterIssuer\n    group: cert-manager.io\nEOF\n\u0060\u0060\u0060\n\n运行下面的命令查看 *istiod* 的日志：\n\n\u0060\u0060\u0060bash\nkubectl logs -l app=istiod -n istio-system -f\n\u0060\u0060\u0060\n\n过两分钟后，你将看到类似如下的证书更改记录：\n\n\u0060\u0060\u0060\n2022-12-23T03:48:42.697360Z\tinfo\tUpdate Istiod cacerts\n2022-12-23T03:48:42.697503Z\tinfo\tUsing kubernetes.io\/tls secret type for signing ca files\n2022-12-23T03:48:42.778241Z\tinfo\tIstiod has detected the newly added intermediate CA and updated its key and certs accordingly\n2022-12-23T03:48:42.779459Z\tinfo\tx509 cert - Issuer: \u0022CN=istiod.istio-system.svc\u0022, Subject: \u0022\u0022, SN: d7acac2301045f741e5e30cff380deaf, NotBefore: \u00222022-12-23T03:46:42Z\u0022, NotAfter: \u00222032-12-20T03:48:42Z\u0022\n2022-12-23T03:48:42.779561Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=istiod.istio-system.svc\u0022, SN: 164bf045670a1716ed3f0f1c89b56122, NotBefore: \u00222022-12-23T03:48:14Z\u0022, NotAfter: \u00222023-01-22T03:48:14Z\u0022\n2022-12-23T03:48:42.779642Z\tinfo\tx509 cert - Issuer: \u0022CN=certmanager-ca,O=cert-manager\u0022, Subject: \u0022CN=certmanager-ca,O=cert-manager\u0022, SN: 8533dbfe0b84ed1fc4e3c76be7ef612f, NotBefore: \u00222022-12-20T07:50:12Z\u0022, NotAfter: \u00222025-06-07T07:50:12Z\u0022\n2022-12-23T03:48:42.779657Z\tinfo\tIstiod certificates are reloaded\n\u0060\u0060\u0060\n\n要修改工作负载证书的自动轮换周期，你可以设置 \u0060pilot-agent\u0060 命令的环境变量 \u0060SECRET_TTL\u0060，默认值为 \u006024h0m0s\u0060。\n\n## 总结 {#summary}\n\n在本文中，我们使用了 cert-manager 作为 PKI，将 SPIRE 集成到我们的证书信任链中，并为 Istio 网格中的工作负载创建身份和证书。通过使用 cert-manager，你不用担心 *istiod* 证书过期的问题，还可以根据需要更新证书。你还可以根据需要将 cert-manager 集成到其他证书供应商，如 [Let\u0027s Encrypt](https:\/\/letsencrypt.org\/)、[HashiCorp Vault](https:\/\/www.vaultproject.io\/)、[Venafi](https:\/\/www.venafi.com\/) 等。你也可以使用 [istio-csr](https:\/\/github.com\/cert-manager\/istio-csr) 直接让 cert-manager 来管理 Istio 中的证书，或[使用 Vault 来存储证书](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)。\n\n## 参考 {#reference}\n\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - cloudnative.to](https:\/\/cloudnative.to\/blog\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换 - cloudnative.to](https:\/\/cloudnative.to\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - cloudnative.to](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n- [如何在 Istio 中集成 SPIRE - cloudnative.to](https:\/\/cloudnative.to\/blog\/istio-spire-integration\/)\n- [SPIRE Server Configuration Reference - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/spire_server\/#built-in-plugins)\n- [Server plugin: UpstreamAuthority \u0022cert-manager\u0022 - github.com](https:\/\/github.com\/spiffe\/spire\/blob\/v1.5.3\/doc\/plugin_server_upstreamauthority_cert_manager.md)\n- [Configuring SPIRE - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/deploying\/configuring\/)\n', '\/blog\/cert-manager-spire-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍如何集成 SPIRE 和使用 cert-manager 实现细粒度的证书管理以及证书轮换。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-trust/">[译] 将 Istio 纳入信任链：使用现有 PKI 作为信任根</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/istio-trust/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('将 Istio 纳入信任链：使用现有 PKI 作为信任根', '本文讲解了如何让 Istio 信任现有 PKI 的步骤。', '\n当我们与想要使用 Istio 的客户或用户交流时，这一个问题时长会出现——Istio 中的证书信任如何工作的？Istio 有自己的证书颁发机构，而我们也有自己的证书颁发机构，如何确保它们相互信任？ \n\n简而言之，通过中间签名证书将 Istio 纳入到您现有的信任链中。 \n\n如果您使用 Istio 作为演示或开箱即用，它将拥有自己的自签名证书 —— 它是自己的根证书。对于在多个集群中运行 Istio 的用户来说，这是一个常见的痛点：他们无意中创建了两个互不不信任的孤岛，因此没有安全通信。\n\n以下是如何通过让 Istio 信任您现有的 PKI 的步骤。\n\n## 简述\n\n这是简短的版本：您应该通过为每个 Istio 部署创建一个中间签名证书来让 Istio 信任您现有的 PKI（并且每个集群应该有一个 Istio 部署）。然后你会：\n\n1. 启用跨 Istio 部署的通信\n2. 允许细粒度的证书撤销，而无需同时在整个基础架构中强制使用新证书（如果这听起来像是等待发生的重大中断，那么您是对的）。 \n3. 启用签名证书的轻松轮换。您需要做的就是创建一个新的中间件并使用新证书重新启动 Istio。因为它在同一个信任根中，所以一切都继续工作。 \n\nIstio 必须适应您现有的架构，以在组织内实现增量采用 —— 使网格适应您的组织，而不是让组织来适应网格。从了解对中间证书签名密钥的需求开始，将为您的成功做好准备，并使任何基础架构或环境更改更加顺利。\n\n## 详述\n\n我们先来了解一下证书验证的过程。在基本证书中，证书检查从信任根开始，向下延伸到特定身份（叶子）。证书路径验证算法是我们确保证书可信的方式。当我们使用 TLS 等安全协议连接到另一台机器时，服务器会向我们提供部分或全部证书链以证明其身份。如果链中的证书被确定为无效，则证书链将被拒绝且不会建立信任。如果我们顺利到达链的末端，则路径（以及证书）是有效的。成功！我们可以信任服务器！\n\n![带有叶证书、中间证书和根证书的证书链。服务器可以选择发送整个链，或者只发送一部分；只要有足够的链从根到叶，我们就可以验证证书。](f1.jpg)\n\n当 TLS 握手时，路径验证算法不关心有多少证书链驻留在我们的信任包中。基于我们带来的和他们提供的证书，它只关心我们能否构建一条从服务器的叶节点到我们的捆绑包中的信任根的链。上面的示例显示验证发生在证书交换中，这足以让叶子在证书颁发机构中找到它的位置。 \n\n当您在生产环境中运行 Istio 时，您将拥有多个叶节点和中间节点，但**只有一个根节点。**\n\n![具有根、三个中间签名 CA 和四个叶证书（由树中的各种中间体颁发）的 PKI 证书树。](f2.jpg)\n\n这就是为什么要在现有 PKI 中建立信任，因为有以下三个主要好处：\n\n1. 可以在 Istio 部署之间的交叉通信\n2. 细粒度证书撤销\n3. 轻松轮换证书\n\n### 跨 Istio 部署的通信\n\n对于 Istio，有两种方法可以确保跨部署的通信 —— 简单的方法和困难的方法。 \n\n困难的方法涉及 Istio 运维人员采取耗时、复杂且昂贵的步骤来确保两个根同时在另一个的证书颁发机构 (CA) 捆绑包中。\n\n![我们可以通过确保所有参与方的根都在 CA 捆绑包中来确保跨不同根的信任。如果它们不是彼此信任包的一部分，则来自每个 Citadel 的证书不能用于跨集群通信。](f3.jpg)\n\n简单的方法是为每个部署使用单独的中间签名证书部署 Istio，所有这些证书都共享相同的根。\n\n![当 Citadel 使用来自同一根 PKI 的中间证书时，最容易促进跨集群通信。我们看到与上面相同的 PKI 树，但中间 CA 被标记为不同集群中的 Citadel 实例。](f4.jpg)\n\n当涉及到细粒度撤销和证书轮换时，这一决定的连锁反应是巨大的。\n\n### 细粒度证书撤销\n\n撤销证书会将证书标记为不再受信任。当证书路径验证算法从叶节点走到根节点时，会对每个证书进行吊销状态检查。这使您能够撤销对单个组件或整个部署部分的信任。\n\n![使用与之前相同的 PKI 树，我们展示了在树的一部分中撤销中间 CA 如何使该中间证书以及由它创建的叶证书无效。](f5.jpg)\n\n这很重要，因为如果签名密钥被泄露，恶意行为者可能会通过出示您的客户认为是有效证书来冒充您的服务器。这在 Istio 中更为重要，因为我们使用证书来识别彼此的工作负载 —— 攻击者可以伪装成您网格中的任何服务！ \n\n通常，处理撤销是管理任何 PKI 中最困难的部分。Istio 帮助降低这种风险的方法之一是颁发非常短暂的证书。典型的吊销列表最多可能需要 24 小时才能在整个组织中传播。Istio 颁发的证书有效期少于 12 小时，因此几乎不需要撤销 Istio 颁发的身份证书。您只需要担心为每个 Istio 部署创建的签名证书。\n\n### 轻松轮换证书\n\n与吊销一样，中间证书的轮换更容易。优点包括，如果您能够按集群轮换证书而不是在根节点轮换证书，您将体验到更少的停机时间（以及相关的复杂性，即在任何地方发布一个带有新根的更新的 CA 包）。而且，就像任何好的 PKI 一样，这可以让您使根离线并安全地存储起来。\n\n## 总结\n\n用简单的方法来做！将 Istio 引入您现有的信任根中，以避免痛苦和心痛。中间签名证书的存在是为了让采用 Istio 更容易、更安全。\n', '\/trans\/istio-trust\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲解了如何让 Istio 信任现有 PKI 的步骤。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-certificates-management/">Istio 中的证书管理方式介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的证书管理方式介绍', '本文介绍了数字证书和 Istio 中的证书管理方式。', '\n我在[如何理解 Istio 中的 mTLS 流量加密](\/blog\/understanding-the-tls-encryption-in-istio\/)这篇文章中提出流量加密的关键是证书管理。我们可以使用 Istio 中内置了 CA（证书授权机构）也可以使用自定义 CA 来管理网格内的证书。这篇博客将为你讲解 Istio 是如何进行证书管理的。\n\n## 什么是证书？ {#certificates-introduction}\n\n在介绍 Istio 的证书管理方式之前，我们先来了解一下什么是证书。若你已了解证书的作用及原理，请直接跳到 Istio 中的证书管理部分。\n\n证书（Certificate），又称电子证书，是用于身份认证和加密通信的一种数字证明文件。在了解 Istio 的证书管理之前，我们先来了解一下什么是证书。如果你已经了解了证书，可以跳过这一节。\n\n证书有很多类别，本文中的证书特指的是 [X.509 V3 证书](https:\/\/datatracker.ietf.org\/doc\/html\/rfc5280)。X509 证书是一种常见的数字证书格式，用于在计算机网络中识别实体的身份。X509 是公钥基础设施（PKI）的国际标准，主要用于身份认证和信息加密，例如 TLS。X.509 证书中包含了个人、组织或计算机的身份信息和公钥。V3 是它的最新版本。它主要用于在客户端和服务器之间进行安全通信，例如在通过 HTTPS 访问网站时。x509 证书通常由 CA 颁发，该 CA 会验证实体的身份，并将这些信息编码到证书中。当客户端连接到服务器时，服务器会向客户端提供其 x509 证书，客户端会验证证书的有效性，并通过该证书来识别服务器的身份。通过这种方式，双方可以安全地进行通信，并确保数据传输的完整性和保密性。\n\n### 哈希函数 {#hash}\n\n谈到证书就不得不提哈希（Hash）函数，因为证书的内容会使用哈希函数进行哈希处理，然后用证书颁发者的私钥进行签名。这样，当收到一份证书时，接收者就可以使用证书颁发者的公钥来验证证书的合法性。\n\n哈希函数是一种将任意长度的输入（也称为消息）映射为固定长度的输出的函数。这个输出也称为哈希值或消息摘要。\n\n哈希函数有许多用途，其中一个重要的用途是密码存储。当用户在系统中设置密码时，通常不会将真实的密码直接存储在系统中。相反，会将密码进行哈希处理，并将哈希值存储在系统中。当用户登录时，系统会将用户输入的密码进行哈希处理，然后与存储的哈希值进行比较。如果两者相同，则证明用户输入的密码正确，反之则错误。\n\n哈希函数有很多种类型，例如 MD5、SHA-1 等。这些函数都有一些共同的特点，比如输出固定长度、不可逆、散列冲突少等。\n\n哈希函数的安全性与其输出的长度有关。一般来说，输出长度越长，哈希函数就越安全。但是，输出长度越长，哈希处理的时间就越长，因此要在安全性和效率之间进行平衡。\n\n### 证书的作用 {#cert-works}\n\n证书的用途广泛，凡是需要加密、认证、授权的场景都会用到它，比如：\n\n- 在 Kubernetes 中你需要给各个组件配置证书，你可以选择[手动生成证书](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)；\n- Istio 中为实现自动 mTLS 给各个工作负载颁发的证书；\n- 访问 HTTPS 网站所用到的证书等；\n\n证书就像是由权威机构印发的名片，供使用者表明其身份，同时还可以为信息加密，保证通信的安全性和完整性。下图展示的是 TLS 通信的大概步骤，其中证书承担了证明服务器身份和加密通信的职责。\n\n下面以一个网站的 HTTP 链接为例，颁发数字证书、验证和加密通信的过程如下图所示。\n\n![TLS 证书颁发和校验过程](tls.svg)\n\n详细步骤如下：\n\n1. 服务器（网站所有者）向 CA 提交证书签名请求；\n2. CA  验证服务器的身份和网站的真实性后为服务器颁发数字证书，服务器安装该证书，以便访问者能够验证网站的安全性；\n3. 用户通过浏览器（客户端）向网站发送请求；\n4. 服务器向客户端返回 TLS 证书；\n5. 客户端向 CA 验证证书的有效性，若有效则建立连接，若无效则提示用户拒绝连接；\n6. 客户端生成一对随机的公钥和私钥；\n7. 客户端将并将自己的公钥发送给服务端；\n8. 服务端使用客户端的公钥加密消息；\n9. 服务端将加密后的数据发送给客户端；\n10. 客户端使用自己的私钥解密服务端发送的数据；\n\n至此，双方建立了一个安全的通道，并可以通过该通道进行双向加密的数据传输。\n\n### 如何生成证书？{#how-to-generate-certificates}\n\n你可以通过以下开源工具生成 X.509 证书：\n\n- [Easy-RSA](https:\/\/github.com\/OpenVPN\/easy-rsa)：一个简单地命令行工具，由 OpenVPN 项目组维护，使用 EasyRSA 可以轻松地为 OpenVPN 网络生成安全的证书和密钥；\n- [OpenSSL](https:\/\/github.com\/openssl\/openssl)：由个人发起于 1995 年，现由独立组织维护，只提供命令行工具；\n- [CFSSL](https:\/\/github.com\/cloudflare\/cfssl)：由 CloudFlare 开发和维护，不仅仅是一个用于生成证书的命令行工具，还可以作为 PKI 服务器；\n- [BoringSSL](https:\/\/github.com\/google\/boringssl)：Google 开发和维护的 OpenSSL 分支，已用于 Chrome 浏览器和安卓操作系统；\n\n因为可能大多数人都对 OpenSSL 比较熟悉，所以下文中我们将使用 OpenSSL 来创建证书。\n\n### 证书的组成 {#cert-component}\n\n下面以 X.509 V3 证书为例，讲解数字证书的组成。下面是该证书的一个示例：\n\n\u0060\u0060\u0060\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            fc:c6:18:2e:20:bd:27:b5:6b:60:bc:47:23:6b:8b:d9\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: O=cluster.local\n        Validity\n            Not Before: Dec 15 07:25:32 2022 GMT\n            Not After : Dec 16 07:27:32 2022 GMT\n        Subject:\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (2048 bit)\n                Modulus:\n                    00:eb:40:16:87:6c:17:5a:9c:b2:91:00:94:d1:31:\n                    37:bb:d7:1e:e6:06:1c:a1:c1:35:64:54:82:54:af:\n                    b8:4b:40:6f:e0:73:86:4e:c1:c6:75:b8:c8:30:ac:\n                    69:16:e8:68:25:cb:dd:e8:53:55:ec:7a:bd:a9:d3:\n                    42:44:7f:e5:f5:52:dd:99:ae:c2:1a:a2:06:1f:be:\n                    1b:e6:3e:69:87:a3:fc:91:21:39:b0:a7:67:11:f2:\n                    3c:55:c6:4b:04:15:1b:ff:49:14:88:c4:58:87:79:\n                    96:5b:6e:00:1c:c1:e7:2c:53:0c:d1:77:dc:a8:82:\n                    cc:fa:26:c1:bb:6c:df:a8:43:0c:b7:cc:f0:a2:11:\n                    9b:e8:3f:8a:1d:ed:2a:ff:1f:d1:03:eb:8a:b9:98:\n                    40:18:83:24:4f:14:95:a3:59:ef:67:0f:35:6d:ae:\n                    91:81:b2:04:02:16:80:d1:39:bd:70:cf:0f:cb:9a:\n                    81:39:d9:fe:52:a5:cf:79:4f:a3:69:d8:0d:39:6a:\n                    48:24:8d:2b:88:04:fa:81:de:65:50:7d:1a:3d:cd:\n                    f3:1c:42:63:29:75:a0:9b:8e:16:44:3a:89:d6:2b:\n                    41:76:65:a5:2e:c8:b6:d2:89:42:5d:21:24:33:30:\n                    f0:9d:0b:4d:cf:78:d5:45:2d:49:5a:55:50:98:93:\n                    03:f5\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Key Usage: critical\n                Digital Signature, Key Encipherment\n            X509v3 Extended Key Usage:\n                TLS Web Server Authentication, TLS Web Client Authentication\n            X509v3 Basic Constraints: critical\n                CA:FALSE\n            X509v3 Authority Key Identifier:\n                keyid:BA:31:8A:9C:ED:EB:49:D2:54:09:98:D9:4C:3A:9C:42:D0:64:8D:B2\n\n            X509v3 Subject Alternative Name: critical\n                URI:spiffe:\/\/cluster.local\/ns\/default\/sa\/httpbin\n    Signature Algorithm: sha256WithRSAEncryption\n         90:7f:cb:6f:0b:16:cb:59:7d:f4:87:a7:5a:38:fa:0a:16:d8:\n         83:0d:b1:36:77:a2:4a:fe:38:52:ab:49:e9:89:50:1a:4c:e9:\n         94:07:37:7f:27:bc:2c:ce:c1:d2:33:75:5d:b6:ab:ae:cb:2e:\n         71:f4:22:c0:40:15:27:02:75:c1:32:2e:83:49:73:6c:9a:ea:\n         04:ef:55:2d:8d:71:30:9b:e4:30:dd:95:20:0d:7c:d2:f4:30:\n         2f:07:2e:9f:53:37:e6:3d:14:c7:41:f4:09:8b:a3:76:56:c7:\n         c7:92:0f:fc:17:5a:5a:32:6c:9e:87:18:2e:51:75:54:68:d8:\n         01:c1:07:cc:b0:35:bf:0b:6c:62:a6:5b:23:61:35:c8:4f:7f:\n         e7:1f:a0:e9:11:44:a6:17:52:4d:00:40:21:de:63:ee:02:c8:\n         2b:5d:a1:7a:5d:7f:d5:d3:c1:7d:5f:00:40:e8:80:8d:cc:e9:\n         8a:c6:b4:98:fe:7a:7d:37:0c:6f:4c:31:91:7a:79:30:84:cd:\n         01:a7:14:f6:1b:33:8f:0f:50:1c:36:38:6b:24:da:cf:49:8a:\n         5b:28:cf:27:76:e1:a5:c7:e6:d5:6e:d8:36:85:aa:1f:a5:ac:\n         fa:f1:2e:a2:36:2e:25:b0:71:24:d1:3e:d5:e5:19:2b:0b:6f:\n         b7:17:e4:75\n\u0060\u0060\u0060\n\n证书中各个字段的含义如下：\n\n- 证书版本（Version）：表示证书的版本号。\n- 序列号（Serial Number）：表示证书的唯一序列号。\n- 签名算法（Signature Algorithm）：表示证书的签名算法，例如 RSA、DSA 或 ECDSA 等。\n- 证书颁发机构（Issuer）：表示颁发该证书的可信的第三方机构的名称。\n- 有效期（Validity）：表示证书的有效期，包括证书生效日期（Not Before）和证书失效日期（Not After）。\n- 使用者（Subject）：表示证书所有者的名称。\n- 公钥信息（Subject Public Key Info）：表示证书所有者的公钥以及公钥的算法。\n- 扩展（Extensions）：表示证书的扩展信息，包括：\n  - 密钥用法扩展（Key Usage Extension）：表示证书所有者的密钥可用于哪些操作，例如数字签名、密钥加密等。\n  - 扩展密钥用法扩展（Extended Key Usage Extension）：表示证书所有者的密钥可用于哪些扩展的操作，例如 TLS Web Server Authentication、TLS Web Client Authentication 等。\n  - 基本约束扩展（Basic Constraints Extension）：表示证书所有者是否是证书颁发机构的下级机构，以及是否允许其作为证书颁发机构颁发其他证书。\n  - 主体密钥表示扩展（Authority Key Identifier）：包含一个或多个唯一的标识符，用于表示证书颁发机构的密钥。这些标识符可以是证书颁发机构的公钥哈希值，也可以是证书颁发机构的证书序列号。该扩展用于验证证书的合法性，例如在验证证书链时，用于验证证书颁发机构是否为可信的机构。这个扩展字段是可选的，但在许多情况下都会被使用。\n  - 主体替代名称扩展（Subject Alternative Name Extension）：表示证书所有者的其他名称，例如域名、IP 地址、电子邮件地址等。\n\n### 证书信任链 {#certificate-trust-chain}\n\n证书的验证需要通过证书信任链（Certificate Trust Chain）。证书信任链是指用于身份验证的一系列证书，它们形成一条从一个可信任的根证书颁发机构开始，逐级向下连接，直到用于验证某个特定证书的中间证书或终端证书的一种方式。证书信任链允许数字证书的可信度随着证书级别的升高而提高。\n\n在下面的证书信任链示意图中，你可以看到四条信任链。\n\n![证书信任链](certificate-trust-chain.svg)\n\n证书的信任链是一个树形结构，每个 CA 都可以有一或多个子 CA，一共有三种角色：\n\n- 根 CA：最顶层的 CA，可以颁发证书给中间 CA；\n- 中间 CA：除根 CA 以外的 CA，可颁发终端证书；\n- 终端实体：拥有终端证书的设备或服务；\n\n根 CA 是数字证书的最顶级颁发机构，因此它所颁发的证书是最可信的。根证书颁发机构通常由政府机构或其他权威机构（如国际基础设施安全组织）经营和监管。常见的根 CA 包括：\n\n- Symantec\/VeriSign\n- Comodo\n- DigiCert\n- GlobalSign\n- GoDaddy\n- Entrust\n- GeoTrust\n- RapidSSL\n- Baltimore CyberTrust Root\n\n请注意，上述列表只是一个样例，实际上有许多其他根 CA。\n\n在 Chrome 浏览器中打开一个 HTTPS 网页，你可以通过点击地址栏左侧的锁图标查看证书信息，其中包括证书信任链，例如 [https:\/\/tetrate.io](https:\/\/tetrate.io) 的证书信任链如下图：\n\n![Tetrate.io 的证书信任链](tetrate-cert.jpg)\n\n证书信任链允许客户端（例如，Web 浏览器）在验证终端证书时，逐级向上验证每个证书，以确定它是否可信。数字证书签发的原理是 CA 将证书拥有者的公钥与身份信息绑定在一起，然后 CA 使用其专有的私钥生成正式的数字签名，用以表示这个证书是经 CA 签发的。在证书校验时使用 CA 的公钥对这个证书上的数字签字进行验证即可。\n\n## 将 Istio 纳入 PKI 证书信任链 {#istio-pki}\n\n在使用 Istio 之前，企业通常有自己的内部 PKI（公钥基础设施），那么如何将 Istio 纳入到 PKI 的证书信任链中呢？\n\n我们知道 Istio 内置了证书管理功能，可以开箱即用，Istio 启动时会为 *istiod* 创建自签名证书，作为网格内所有工作负载的根证书。这样做有个问题，如果你有多网格，内置的根证书无法做到网格间互信。正确的做法是不使用 Istio 自签名证书，而是将 Istio 纳入到你的证书信任链中，将 Istio 集成到你的 PKI，为 PKI 每个网格创建一个中间证书，这样两个网格拥有了共同的信任根，就可以做到网格间互信。\n\n通过为 Istio 网格创建中间 CA 使其纳入到企业内部 PKI 证书信任链中，如下图所示。\n\n![为多网格创建中间 CA 使得 Istio 纳入到企业内部 PKI 证书信任链](cluster-ca.svg)\n\n将 Istio 纳入企业内部 PKI 证书信任链后有诸多好处：\n\n- 可以实现跨网格\/集群之间的通信：有了共同的信任根，集群之间就可以互相验证身份，进而实现跨集群通信；\n- 更细粒度的证书撤销：你可以撤销某个实体或中间 CA 的证书来撤销某个服务或集群的证书；\n- 轻松实现证书轮换：你可以按集群\/网格实现证书轮换，而不是轮换根节点证书，这样会减少停机时间，推荐您使用 [cert-manager](https:\/\/github.com\/cert-manager\/cert-manager) 来实现自动化的大规模 CA 证书轮换，详情请参考[在生产中大规模自动化 Istio CA 轮换](https:\/\/cloudnative.to\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)；\n\n关于将 Istio 纳入企业内部 PKI 的证书信任链的详细说明请参考[这篇博客](https:\/\/cloudnative.to\/blog\/istio-trust\/)。\n\n## Istio 中使用自定义 CA 的步骤 {#istio-custom-ca}\n\n默认情况下，Istio CA 会生成一个自签名的根证书和密钥，并使用它们来签署工作负载证书。为了保护根 CA 密钥，你应该使用在安全机器上离线运行的根 CA，并使用根 CA 向运行在每个集群上的 Istio CA 签发中间证书。Istio CA 可以使用管理员指定的证书和密钥来签署工作负载证书，并将管理员指定的根证书作为信任根分配给工作负载。\n\n下图展示了 Istio 中的证书签发和挂载过程。\n\n![Istio 中的证书签发和挂载过程](cert-process.svg)\n\n1. Istio 向 Pod 中注入的 Envoy 代理中有两个进程——\u0060envoy\u0060 和 \u0060pilot-agent\u0060。\u0060pilot-agent\u0060 为 Envoy 生成私钥，通过 UNIX Domain Socekt（UDS）使用 Secret Discovery Service（SDS）向 CA 发起证书签名请求（CSR），如果你没有配置 CA 插件的话，Istio 默认向 *istiod* 发起 CSR；\n2. \u0060istiod\u0060 内置 CA 向 \u0060pilot-agent\u0060 返回证书；\n3. \u0060pilot-agent\u0060 将生成的私钥和 CA 返回的证书发送给 \u0060envoy\u0060 挂载；\n\nIstio 默认使用内置于 *istiod* 中的 CA，也支持插入其他 CA，见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)。若想使用自定义的 CA 证书和密钥为服务创建身份，你需要：\n\n- 创建 CA 配置文件并使用它来创建自签名的 CA 根证书和密钥；\n- 为服务创建私钥、签名请求配置文件；\n- 为服务创建证书签名请求（CSR）；\n- 使用根证书和密钥以及服务的签名请求文件为服务创建证书；\n\n接下来，我们将以为 Bookinfo 的 productpage 服务创建和挂载证书为例详述 Istio 内置 CA 签发证书的流程。\n\n## Istio 内置 CA 签发证书流程  {#istio-ca}\n\nIstio 启动时将创建一个自签名的 CA 证书，然后再用该 CA 证书为网格内的服务颁发证书。下面我们手动模拟 Istio 内置 CA 签发证书的步骤：\n\n1. 创建 CA 私钥 \u0060ca.key\u0060；\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out ca.key\n   \u0060\u0060\u0060\n\n2. 创建 CA 配置文件 \u0060ca.conf\u0060：\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = req_dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = Root CA\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n3. 使用 CA 私钥 \u0060ca.key\u0060 生成自签名证书 \u0060ca.pem\u0060，其中主题中包含 CA 的信息：\n\n   \u0060\u0060\u0060bash\n   openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.pem -config ca.conf\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022关于 PEM 文件\u0022\u003e}}\n\n   PEM 文件是一种用于存储证书、公钥或私钥的文件。它采用 Base64 编码的 ASCII 格式，并使用特定的文件扩展名，例如 \u0060.pem\u0060、\u0060.crt\u0060、\u0060.cer\u0060 或 \u0060.key\u0060。PEM 文件通常用于存储加密密钥、数字证书和公钥基础设施（PKI）证书。\n\n   PEM 文件的内容通常以一组特定的标头和脚本开始，例如 \u0060-----BEGIN RSA PRIVATE KEY-----\u0060 和 \u0060-----END RSA PRIVATE KEY-----\u0060。这些标头和脚本指定了文件的类型和数据的开始和结束位置。\n\n   PEM 文件可以通过文本编辑器直接打开，但并不可读，因为它是由二进制编码格式 DER（可分辨编码规则）转化而来，要想解析它需要使用特别的工具，例如 OpenSSL。\n\n   {{\u003c\/callout\u003e}}\n\n4. 为工作负载创建私钥 \u0060workload.key\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl genrsa -out workload.key\n   \u0060\u0060\u0060\n\n5. 创建证书签名请求配置文件 \u0060csr.conf\u0060，其中包含 CA 的地址及附加信息；\n\n   \u0060\u0060\u0060ini\n   [ req ]\n   default_bits = 2048\n   prompt = no\n   utf8 = yes\n   encrypt_key = no\n   distinguished_name  = dn\n   req_extensions = req_ext\n   x509_extensions = req_ext\n   \n   [ req_dn ]\n   O = Istio\n   CN = productpage\n   \n   [ req_ext ]\n   subjectKeyIdentifier = hash\n   basicConstraints = critical, CA:true\n   keyUsage = critical, digitalSignature, nonRepudiation, keyEncipherment, keyCertSign\n   \u0060\u0060\u0060\n\n6. 基于工作负载的 CSR 配置文件 \u0060csr.conf\u0060 和工作负载的私钥文件 \u0060workload.key\u0060 创建证书签名请求 \u0060workload.csr\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl req -new -key workload.key -out workload.csr -config csr.conf\n   \u0060\u0060\u0060\n\n7. 基于 CA 的私钥 \u0060ca.key\u0060、CA 的证书 \u0060ca.pem\u0060 和工作负载的证书签名请求创建服务器证书 \u0060workload.pem\u0060：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -req -in workload.csr -CA ca.pem -CAkey ca.key \\\n       -CAcreateserial -out workload.pem -days 365 \\\n       -extensions req_ext -extfile csr.conf -sha256\n   \u0060\u0060\u0060\n\n   Istiod 在收到工作负载的 CSR 后将根证书 \u0060ca.pem\u0060 和服务证书下发给工作负载；\n\n8. 查看工作负载中 Envoy 代理挂载的证书链：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\n   \u0060\u0060\u0060\n\n   \u0060chain.pem\u0060 文件中保存着 \u0060productpage\u0060 服务的证书链，因为我们使用的 Istio 内置 CA 作为根 CA，所以该文件中只保存有一个证书，可以运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in chain.pem\n   \u0060\u0060\u0060\n\n9. 查看 Envoy 代理挂载的根证书：\n\n   \u0060\u0060\u0060bash\n   istioctl proxy-config secret deployment\/productpage-v1 -o json | jq -r \\\n   \u0027.dynamicActiveSecrets[1].secret.validationContext.trustedCa.inlineBytes\u0027 | base64 --decode \u003e root.pem\n   \u0060\u0060\u0060\n\n   \u0060root.pem\u0060 即为根证书，运行下面的命令查看：\n\n   \u0060\u0060\u0060bash\n   openssl x509 -noout -text -in root.pem\n   \u0060\u0060\u0060\n\n   {{\u003ccallout note \u0022提示\u0022\u003e}}\n\n   \u0060root.pem\u0060 中的内容与 \u0060istiod-ca-cert\u0060 ConfigMap 中的 \u0060root-cert.pem\u0060 及 \u0060istio-ca-secret\u0060 中的 \u0060ca-cert.pem\u0060 是一样的，虽然现在 Envoy 已不在通过读取挂载卷来获得证书内容，但之所以保留了这些卷是为了向后兼容。\n\n   {{\u003c\/callout\u003e}}\n\n   证书挂载到 Envoy 代理之后，*istiod* 将负责定期替换密钥证书，以及根据需要撤销密钥证书。\n\n## 总结 {#summary}\n\n本文向你介绍了数字证书的作用、组成和证书信任链，以及 Istio 中内置的开箱即用的证书管理器运作的流程。但是 Istio 内置 CA 仍然有一定限制，在下一篇博客中我将向你介绍如何使用插件 SPIRE 和 cert-manager 来实现细粒度的证书管理和自动证书轮换。\n\n## 参考 {#reference}\n\n- [插入 CA 证书 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert\/)\n- [如何设置 SSL 证书 - istio.tetratelabs.io](https:\/\/istio.tetratelabs.io\/zh\/istio-in-practice\/setting-up-ssl-certs\/)\n- [管理集群中的 TLS 认证 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/tls\/managing-tls-in-a-cluster\/)\n- [手动生成证书 - kubernetes.io](https:\/\/kubernetes.io\/zh-cn\/docs\/tasks\/administer-cluster\/certificates\/)\n- [将 Istio 纳入信任链：使用现有 PKI 作为信任根 - jimmysong.io](https:\/\/cloudnative.to\/blog\/istio-trust\/)\n- [如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书 - jimmysong.io](https:\/\/cloudnative.to\/blog\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/)\n', '\/blog\/istio-certificates-management\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了数字证书和 Istio 中的证书管理方式。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/">[译] 如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Hashicorp Vault 作为一种更安全的方式来存储 Istio 证书', '本文将指导你使用 Vault 存储 Istio 的证书。', '\n在本文中，我们将探讨如何使用 Hashicorp Vault 作为一种比使用 Kubernetes [Secret](https:\/\/kubernetes.io\/docs\/concepts\/configuration\/secret) 更安全的方式来存储 Istio 证书。默认情况下，Secret 使用 base64 编码存储在 *etcd* 中。在安全策略严格的环境中，这可能是不可接受的，因此需要额外的措施来保护它们。一种此类解决方案涉及将机密存储在外部机密存储提供程序中，例如 [HashiCorp Vault](https:\/\/www.vaultproject.io\/)。\n\nVault 可以托管在 Kubernetes 集群内部和外部。在本案例中，我们将探索使用托管在 Kubernetes 外部的 Vault，以便它可以同时为多个集群提供秘密。该设置也非常适合探索 Istio 的[多集群功能](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster)，它需要一个共享的信任域。\n\n利用 \u0060vault-agent-init\u0060 容器，我们可以将证书和私钥材料注入实际的 Istio 控制平面 Pod，以便它们使用外部 CA 证书进行引导。这避免了依赖 Secret 来引导 Istio 控制平面。该技术也完全适用于入口和出口证书。\n\n有关如何在 Istio 中使用和管理证书的更多信息，请参见官方文档：\n\n- [身份和证书管理](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/#pki)\n- [插入 CA 证书](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/plugin-ca-cert)\n- [使用 Kubernetes CSR 的自定义 CA 集成](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/cert-management\/custom-ca-k8s)\n\n有关基于实际生产经验的最佳实践，另请查看以下 [Tetrate](https:\/\/tetrate.io\/) 的博客文章：\n\n- [在 Istio 中构建证书信任链：将现有 PKI 作为信任根](\/trans\/istio-trust\/)\n- [在生产中大规模自动化 Istio CA 轮换](\/trans\/automate-istio-ca-rotation-in-production-at-scale)\n\n这篇博文附带的代码可以在以下存储库中找到：\n\nhttps:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\n\n## **Istiod 证书处理**\n\n尽管上述博文中解释了一些决策逻辑，但也值得参考[源代码](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/pkg\/bootstrap\/istio_ca.go)以查找一些未记录的行为。\n\n在 Istio 的源码 \u0060istio\/pilot\/pkg\/bootstrap\/istio_ca.go\u0060 文件中，你将看到：为了向后兼容，Istio 保留了对用于自签名证书 \u0060cacerts\u0060 Secret 的支持。它安装在相同的位置，如果发现了就会被使用——创建秘密就足够了，不需要额外的选项。在旧安装程序中，\u0060LocalCertDir\u0060 被硬编码到 \u0060\/etc\/cacerts\u0060 并使用 \u0060cacerts\u0060  Secret 安装。已删除对签署其他根 CA 的支持——太危险，没有明确的用例。\n\n默认配置，用于向后兼容 Citadel：\n\n- 如果 \u0060istio-system\u0060 中存在 \u0060cacerts\u0060 秘密，将被挂载。它可能包含一个可选的 \u0060root-cert.pem\u0060，\n带有额外的根和可选的 \u0060{ca-key, ca-cert, cert-chain}.pem\u0060 由用户提供的根 CA。\n- 如果未找到用户提供的根 CA，则使用 \u0060istio-ca-secret\u0060 Secret，以及 \u0060ca-cert.pem\u0060 和 \u0060ca-key.pem\u0060 文件。\n- 如果两者均未找到，将创建 \u0060istio-ca-secret\u0060。\n- 带有 \u0060caTLSRootCert\u0060 文件的 \u0060istio-security\u0060 ConfigMap 将用于根证书，并在需要时创建。该 ConfigMap 由节点代理使用，不再可能在 sds-agent 中使用，但我们仍保留它以向后兼容。将与 node-agent 一起删除。sds-agent 使用 K8S root 直接调用 \u0060NewCitadelClient\u0060 。\n\n为了指示 Istio 从其他地方获取证书，而不是标准 Kubernetes Secret，我们将利用 *istio-pilot*（又名 istiod 或 Istio 控制平面）的环境变量（[见此文档](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-discovery)），从 Kubernetes Pod 中的另一个位置获取证书。这是必需的，因为 \u0060vault-agent-init\u0060 注入容器将创建一个新的挂载卷 \u0060\/vault\/secrets\u0060 ，以放置从外部 Vault 服务器拉出的证书和私钥。\n\n| 变量名称      | 类型   | 默认值         | 描述                         |\n| ------------- | ------ | -------------- | ---------------------------- |\n| \u0060ROOT_CA_DIR\u0060 | 字符串 | \u0060\/etc\/cacerts\u0060 | 本地或安装的 CA 根目录的位置 |\n\n## Pod 内的 \u0060vault-agent-init\u0060 容器注解\n\n我们将利用 Vault 注入器注解来指示 Sidecar 提取哪些数据以及在这样做时使用什么 Vault 角色。我们还确保容器在我们实际的主容器之前运行，因此后者可以获取证书和密钥材料以正确引导自身。[此处](https:\/\/developer.hashicorp.com\/vault\/docs\/platform\/k8s\/injector\/annotations)列举并记录了 Vault 注解。我们将在本教程中使用的相关注释如下：\n\n| **注解**                                     | **默认值** | **描述**                                                     |\n| -------------------------------------------- | ---------- | ------------------------------------------------------------ |\n| \u0060vault.hashicorp.com\/agent-inject\u0060           | false      | 配置是否为 Pod 显式启用或禁用注入。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/agent-init-first\u0060       | false      | 如果为 true，则将 Pod 配置为首先运行 Vault Agent init 容器（如果为 false，则最后运行）。当其他 init 容器需要预填充的秘密时，这很有用。这应该设置为 true 或 false。 |\n| \u0060vault.hashicorp.com\/role\u0060                   | –          | 配置 Vault 代理自动验证方法使用的 Vault 角色。\u0060vault.hashicorp.com\/agent-configmap\u0060 未设置时需要。 |\n| \u0060vault.hashicorp.com\/auth-path\u0060              | –          | 配置 Kubernetes 身份验证方法的身份验证路径。默认为 \u0060auth\/kubernetes\u0060。 |\n| \u0060vault.hashicorp.com\/agent-inject-secret-\u0060   | –          | 配置 Vault 代理以从容器所需的 Vault 中检索秘密。Secret 的名称是 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 之后的任意唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-secret-foobar\u0060 该值是 secret 所在的 Vault 中的路径。 |\n| \u0060vault.hashicorp.com\/agent-inject-template-\u0060 | –          | 配置 Vault Agent 应该用于呈现秘密的模板。模板的名称是 v\u0060ault.hashicorp.com\/agent-inject-template-\u0060 之后的任何唯一字符串，例如 \u0060vault.hashicorp.com\/agent-inject-template-foobar\u0060。这应该映射到 \u0060vault.hashicorp.com\/agent-inject-secret-\u0060 中提供的相同唯一值。如果未提供，则使用默认的通用模板。 |\n\n## Vault 服务器注意事项 {#vault-server-considerations}\n\nVault 支持多种客户端验证自己的方法。我们将利用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)，这意味着我们将利用 Kubernetes ServiceAccount JWT 令牌验证。请注意，自 Kubernetes 1.24 以来，不再自动生成 ServiceAccount 令牌。您仍然可以手动创建这些 API 令牌，如[此处所述](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-service-account\/#manually-create-an-api-token-for-a-serviceaccount)。\n\n至于证书和私钥材料的存储，我们有两种选择：\n\n- [PKI 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/pki)\n- [KV 秘密引擎](https:\/\/developer.hashicorp.com\/vault\/docs\/secrets\/kv)\n\n因为 PKI 秘密引擎不提供精简的 API 来检索我们需要的证书和私钥，并且因为 PKI 秘密引擎会为每次调用（例如，每次 *istiod* 重启）生成一个新的中间证书，我们将使用通用的 KV 秘密引擎，将我们需要的所有值存储在一个简单的键值数据结构中。我们假设中间证书的更新是通过一些服务门户或 CI\/CD 过程在外部处理的，这些过程也将更新的中间证书存储在 Vault 服务器中。\n\nIstio 的控制平面 Pod 需要以下文件才能在 CA 中正确引导其构建：\n\n| Key            | 值（PEM 编码） | 细节                                    |\n| -------------- | -------------- | --------------------------------------- |\n| ca-key.pem     | 私钥           | 中间证书的私钥，用作 *istiod* 的根 CA。 |\n| ca-cert.pem    | CA 公共证书    | 中间证书，用作 *istiod* 的根 CA。       |\n| root-cert.pem  | CA 根证书      | 我们新生成的中间证书的信任根。          |\n| cert-chain.pem | 完整的证书链   | 中间证书在顶部，根证书在底部。          |\n\n## 设置\n\n如果要遵循本地设置，则安装软件的先决条件包括：\n\n- *kubectl* 与 Kubernetes 集群交互（[下载](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)）\n- *helm* 安装 Vault injector 和 Istio chart（[下载](https:\/\/helm.sh\/docs\/intro\/install)）\n- 用于配置 Vault 服务器的 *vault cli* 工具（[下载](https:\/\/developer.hashicorp.com\/vault\/tutorials\/getting-started\/getting-started-install#install-vault)）\n\n如果您想要本地演示环境，请按照[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/local-setup.md)的说明进行操作，该说明使用 \u0060docker-compose\u0060 启动一个 Vault 服务器和两个独立的 k3s 集群。如果您使用自己的 Kubernetes 集群和外部托管的 Vault 实例，请跳至下一节。\n\n- *docker-compose* 启动本地环境（[下载](https:\/\/github.com\/docker\/compose\/releases)）\n\n为了取得进展，我们希望根据您的环境设置以下 shell 变量。\n\n\u0060\u0060\u0060bash\nexport VAULT_SERVER=\nexport K8S_API_SERVER_1=\nexport K8S_API_SERVER_2=\n\u0060\u0060\u0060\n\n## **Vault Kubernetes 身份验证后端**\n\n正如在有关 [Vault 服务器注意事项](#vault-server-considerations)的介绍部分中提到的，我们将使用 [Kubernetes 身份验证后端](https:\/\/developer.hashicorp.com\/vault\/docs\/auth\/kubernetes)。由于 *istiod* 将从 Vault 服务器获取证书和私钥材料，让我们从在两个集群中创建相应的服务账户开始。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml create ns istio-system\nkubectl --kubeconfig kubecfg2.yml create ns istio-system\nkubectl --kubeconfig kubecfg1.yml apply -f istio-sa.yml\nkubectl --kubeconfig kubecfg2.yml apply -f istio-sa.yml\n\u0060\u0060\u0060\n\nServiceAccount、Secret 和 ClusterRoleBinding 如下：\n\n\u0060\u0060\u0060yaml\n# istio-sa.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: istiod\n  namespace: istio-system\n  labels: # added for istio helm installation\n    app: istiod\n    app.kubernetes.io\/managed-by: Helm\n    release: istio-istiod\n  annotations: # added for istio helm installation\n    meta.helm.sh\/release-name: istio-istiod\n    meta.helm.sh\/release-namespace: istio-system\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: istiod\n  namespace: istio-system\n  annotations:\n    kubernetes.io\/service-account.name: istiod\ntype: kubernetes.io\/service-account-token\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: role-tokenreview-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:auth-delegator\nsubjects:\n  - kind: ServiceAccount\n    name: istiod\n    namespace: istio-system\n\u0060\u0060\u0060\n\n\u003e 注意：*我们在 istiod ServiceAccount 上添加了 Helm 标签和注解，以免与稍后的 Istio Helm 部署发生冲突。*\n\n在两个集群中创建 ServiceAccount 后，让我们将它们的 Secret 令牌和 ca.cert 值存储在 output 文件夹中：\n\n\u0060\u0060\u0060bash\nmkdir -p .\/output\nkubectl --kubeconfig kubecfg1.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod1.jwt\nkubectl --kubeconfig kubecfg1.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert1.pem\nkubectl --kubeconfig kubecfg2.yml get secret -n istio-system istiod -o go-template=\u0022{{ .data.token }}\u0022 | base64 --decode \u003e output\/istiod2.jwt\nkubectl --kubeconfig kubecfg2.yml config view --raw --minify --flatten -o jsonpath=\u0022{.clusters[].cluster.certificate-authority-data}\u0022 | base64 --decode \u003e output\/k8sapi-cert2.pem\n\u0060\u0060\u0060\n\n关于 Kubernetes API 证书和 istiod ServiceAccount JWT 令牌的详细内容的更多信息可以在[这里](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/output)找到，在这里我们也更深入地描述了 Vault 的交互过程，即通过 REST API 调用来验证和获取秘密。在调试权限拒绝的问题时，这些可以派上用场。\n\n让我们根据刚刚检索到的 Kubernetes CA 证书和 JWT 令牌创建必要的 Vault 身份验证配置：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault auth enable --path=kubernetes-cluster1 kubernetes\nvault auth enable --path=kubernetes-cluster2 kubernetes\nvault write auth\/kubernetes-cluster1\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_1\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert1.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod1.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\nvault write auth\/kubernetes-cluster2\/config \\\n  kubernetes_host=\u0022$K8S_API_SERVER_2\u0022 \\\n  kubernetes_ca_cert=@output\/k8sapi-cert2.pem \\\n  token_reviewer_jwt=\u0060cat output\/istiod2.jwt\u0060 \\\n  disable_local_ca_jwt=\u0022true\u0022\n\u0060\u0060\u0060\n\n\u003e 注意：如果您使用的是 *docker-compose* 提供的环境，则 \u0060VAULT_ADDR\u0060 设置为 localhost。\n\n## *Vault kv* Secret 中的 Istio 证书和私钥\n\n接下来我们将创建一个新的自签名根证书并为我们的两个集群生成中间证书。我们将在[这里](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/certs)使用上游 Istio 提供的辅助 *Makefile* 脚本：\n\n\u0060\u0060\u0060bash\ncd certs\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk root-ca\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster1-cacerts\nmake -f ..\/certs-gen\/Makefile.selfsigned.mk istiod-cluster2-cacerts\ncd ..\n\u0060\u0060\u0060\n\n有关实际内容和正在设置的 X509v3 扩展的更多详细信息，请参见[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs)。您可以通过[此处](https:\/\/github.com\/tetratelabs\/istio-vault-ext-certs\/blob\/main\/certs-gen)的 *Makefile*文档和相应的 *Makefile* 覆盖值微调证书。\n\n让我们将生成的证书和私钥添加到 Vault *kv* secret 中：\n\n\u0060\u0060\u0060bash\nexport VAULT_ADDR=http:\/\/localhost:8200\nvault login root\nvault secrets enable -path=kubernetes-cluster1-secrets kv\nvault secrets enable -path=kubernetes-cluster2-secrets kv\nvault kv put kubernetes-cluster1-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster1\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster1\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster1\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster1\/root-cert.pem\nvault kv put kubernetes-cluster2-secrets\/istiod-service\/certs \\\n  ca_key=@certs\/istiod-cluster2\/ca-key.pem \\\n  ca_cert=@certs\/istiod-cluster2\/ca-cert.pem \\\n  cert_chain=@certs\/istiod-cluster2\/cert-chain.pem \\\n  root_cert=@certs\/istiod-cluster2\/root-cert.pem\n\u0060\u0060\u0060\n\n通过限制对每个集群的这些证书和私钥的访问，绑定到基于 Kubernetes *istiod* ServiceAccount 的身份验证后端：\n\n\u0060\u0060\u0060bash\necho \u0027path \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster1 -\necho \u0027path \u0022kubernetes-cluster2-secrets\/istiod-service\/certs\u0022 {\n  capabilities = [\u0022read\u0022]\n}\u0027 | vault policy write istiod-certs-cluster2 -\nvault write auth\/kubernetes-cluster1\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster1 \\\n  ttl=24h\nvault write auth\/kubernetes-cluster2\/role\/istiod \\\n  bound_service_account_names=istiod \\\n  bound_service_account_namespaces=istio-system \\\n  policies=istiod-certs-cluster2  \\\n  ttl=24h\n\u0060\u0060\u0060\n\n## 部署 *vault-inject* 和 Istio Helm Charts\n\n为了部署 Vault 注入器，我们将利用官方 Vault [Helm chart](https:\/\/github.com\/hashicorp\/vault-helm)。\n\n\u0060\u0060\u0060bash\nhelm repo add hashicorp https:\/\/helm.releases.hashicorp.com\nhelm repo update\nkubectl --kubeconfig kubecfg1.yml create ns vault\nkubectl --kubeconfig kubecfg2.yml create ns vault\nhelm --kubeconfig kubecfg1.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nhelm --kubeconfig kubecfg2.yml install -n vault vault-inject hashicorp\/vault --set \u0022injector.externalVaultAddr=$VAULT_SERVER\u0022\nkubectl --kubeconfig kubecfg1.yml -n vault get pods\nkubectl --kubeconfig kubecfg2.yml -n vault get pods\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vt9w   1\/1     Running   0          92s\nNAME                                           READY   STATUS    RESTARTS   AGE\nvault-inject-agent-injector-5776975795-9vjnx   1\/1     Running   0          91s\n\u0060\u0060\u0060\n\n要安装 Istio，我们将使用 Tetrate Istio Distro [Helm chart](https:\/\/github.com\/tetratelabs\/helm-charts)。\n\n\u0060\u0060\u0060bash\nhelm repo add tetratelabs https:\/\/tetratelabs.github.io\/helm-charts\nhelm repo update\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-base tetratelabs\/base\nhelm --kubeconfig kubecfg1.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster1-values.yaml\nhelm --kubeconfig kubecfg2.yml install -n istio-system istio-istiod tetratelabs\/istiod --values=.\/cluster2-values.yaml\nkubectl --kubeconfig kubecfg1.yml -n istio-system get pods\nkubectl --kubeconfig kubecfg2.yml -n istio-system get pods\n\u0060\u0060\u0060\n\n请注意我们如何利用多个 Istio Helm chart 值覆盖来我们预期的目标：\n\n- 注入一个 pilot Pod 环境变量 \u0060ROOT_CA_DIR\u0060 来告诉 *istiod* 从哪里获取证书和私钥\n- 告诉 \u0060vault-agent-init\u0060 容器在 *istiod* 容器之前运行，因此秘密安装在 \u0060\/vault\/secrets\u0060 的卷中可用\n- 指示 Vault 注入器从正确的位置和数据密钥获取机密\n- 这样做时承担 Vault *istiod* 角色\n- 覆盖默认的 Kubernetes auth-path，因为我们有多个集群 \n\n\u0060\u0060\u0060yaml\npilot:\n  env:\n    ROOT_CA_DIR: \/vault\/secrets\n  podAnnotations:\n    vault.hashicorp.com\/agent-inject: \u0022true\u0022\n    vault.hashicorp.com\/agent-init-first: \u0022true\u0022\n    vault.hashicorp.com\/agent-inject-secret-ca-key.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-key.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_key }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-ca-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-ca-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.ca_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-root-cert.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-root-cert.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.root_cert }}\n        {{ end -}}\n    vault.hashicorp.com\/agent-inject-secret-cert-chain.pem: \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022\n    vault.hashicorp.com\/agent-inject-template-cert-chain.pem: |\n        {{- with secret \u0022kubernetes-cluster1-secrets\/istiod-service\/certs\u0022 -}}\n        {{ .Data.cert_chain }}\n        {{ end -}}\n    vault.hashicorp.com\/role: \u0022istiod\u0022\n    vault.hashicorp.com\/auth-path: \u0022auth\/kubernetes-cluster1\u0022\n\u0060\u0060\u0060\n\n当我们查看 \u0060vault-agent-init\u0060 容器日志时，我们应该看到类似这样的内容。我们的控制平面已经正确地获取了 Vault 注入的秘密。\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c vault-agent-init --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n==\u003e Vault agent started! Log data will stream in below:\n\n  ==\u003e Vault agent configuration:\n\n                      Cgo: disabled\n                Log Level: info\n                  Version: Vault v1.12.0, built 2022-10-10T18:14:33Z\n              Version Sha: 558abfa75702b5dab4c98e86b802fb9aef43b0eb\n\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: creating file sink\n  2022-11-18T11:01:21.398Z [INFO]  sink.file: file sink configured: path=\/home\/vault\/.vault-token mode=-rw-r-----\n  2022-11-18T11:01:21.398Z [INFO]  template.server: starting template server\n  2022-11-18T11:01:21.398Z [INFO]  sink.server: starting sink server\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: starting auth handler\n  2022-11-18T11:01:21.398Z [INFO]  auth.handler: authenticating\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.398Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: authentication successful, sending token to sinks\n  2022-11-18T11:01:21.402Z [INFO]  auth.handler: starting renewal process\n  2022-11-18T11:01:21.402Z [INFO]  sink.file: token written: path=\/home\/vault\/.vault-token\n  2022-11-18T11:01:21.402Z [INFO]  sink.server: sink server stopped\n  2022-11-18T11:01:21.402Z [INFO]  sinks finished, exiting\n  2022-11-18T11:01:21.402Z [INFO]  template.server: template server received new token\n  2022-11-18T11:01:21.402Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating new runner (dry: false, once: false)\n  2022-11-18T11:01:21.402Z [INFO] (runner) creating watcher\n  2022-11-18T11:01:21.402Z [INFO] (runner) starting\n  2022-11-18T11:01:21.403Z [INFO]  auth.handler: renewed auth token\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/root-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-cert.pem\u0022\n  2022-11-18T11:01:21.515Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/cert-chain.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) rendered \u0022(dynamic)\u0022 =\u003e \u0022\/vault\/secrets\/ca-key.pem\u0022\n  2022-11-18T11:01:21.516Z [INFO] (runner) stopping\n  2022-11-18T11:01:21.516Z [INFO]  template.server: template server stopped\n  2022-11-18T11:01:21.516Z [INFO] (runner) received finish\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: shutdown triggered, stopping lifetime watcher\n  2022-11-18T11:01:21.516Z [INFO]  auth.handler: auth handler stopped\n\u0060\u0060\u0060\n\n当我们查看 \u0060discovery\u0060 容器日志时，我们应该看到如下内容：\n\n\u0060\u0060\u0060bash\nkubectl --kubeconfig kubecfg1.yml logs -n istio-system -l app=istiod -c discovery --tail=-1\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060\n info\tUsing istiod file format for signing ca files\n  info\tUse plugged-in cert at \/vault\/secrets\/ca-key.pem\n  info\tx509 cert - Issuer: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, Subject: \u0022\u0022, SN: 39f67569f10d36a1fc91e9d82156b07d, NotBefore: \u00222022-11-18T11:11:59Z\u0022, NotAfter: \u00222032-11-15T11:13:59Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Intermediate CA,O=Istio,L=istiod-cluster1\u0022, SN: dedf298a147681d6, NotBefore: \u00222022-11-17T22:01:54Z\u0022, NotAfter: \u00222024-11-16T22:01:54Z\u0022\n  info\tx509 cert - Issuer: \u0022CN=Root CA,O=Istio\u0022, Subject: \u0022CN=Root CA,O=Istio\u0022, SN: f5bcd7e89bdb6248, NotBefore: \u00222022-11-17T22:01:52Z\u0022, NotAfter: \u00222032-11-14T22:01:52Z\u0022\n  info\tIstiod certificates are reloaded\n  info\tspiffe\tAdded 1 certs to trust domain cluster.local in peer cert verifier\n\u0060\u0060\u0060\n\n我们可以看到我们的 Istio 控制平面已经正确地获取了我们的 Vault 注入证书和私钥。任务完成！\n\n## 结论\n\n在本文中，我们已经使用外部 Vault 存储的证书和私钥成功引导了 Istio 控制平面。实现这一目标的步骤包括：\n\n- 将证书和私钥存储在每个集群专用的 Vault 秘密安装路径中\n- 为每个集群设置 Kubernetes Vault 身份验证后端，链接到正确的 ServiceAccount\n- 定义适当的角色和策略以允许从 *istiod* ServiceAccount 访问 Vault 机密\n- 将 Istio Pilot 引导程序参数调整为：\n  - 注入 *vault-agent-init* sidecar\n  - 获取包含我们的证书和私钥的正确 Vault 机密\n  - 使用正确的角色和身份验证后端来这样做\n  - 从正确的 vault secret 安装路径中获取证书和私钥\n\n我们可以使用完全相同的技术来注入*入口网关*和*出口网关*证书。创建 Istio [Gateway](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/#ServerTLSSettings) 对象时，请确保将 *serverCertificate*、*privateKey* 和 *caCertificates* 指向 \u0060\/vault\/secrets\u0060 挂载卷中的正确文件。我们将把它作为练习留给读者。\n\n通过将证书注入绑定到 Kubernetes ServiceAccount，我们现在已将证书生命周期管理委托给外部秘密 Vault 实例。现在可以使用专用角色和写入\/更新策略创建服务门户或 CI\/CD 管道等外部流程，以提供必要的证书生命周期管理安全性。\n', '\/trans\/how-to-use-hashicorp-vault-as-a-more-secure-way-to-store-istio-certificates\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将指导你使用 Vault 存储 Istio 的证书。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/distributed-tracing-with-skywalking-in-istio/">如何在 Istio 中使用 SkyWalking 进行分布式追踪？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio 中使用 SkyWalking 进行分布式追踪？', '本文主要介绍了在云原生应用中分布式追踪的相关内容，包括分布式追踪基础、Istio 实现分布式追踪的方式、分布式追踪系统的选择、以 Bookinfo 和 SkyWalking 为例的实验以及总结和参考。', '\n在云原生应用中，一次请求往往需要经过一系列的 API 或后台服务处理才能完成，这些服务有些是并行的，有些是串行的，而且位于不同的平台或节点。那么如何确定一次调用的经过的服务路径和节点以帮助我们进行问题排查？这时候就需要使用到分布式追踪。\n\n本文将向你介绍：\n\n- 分布式追踪的原理\n- 如何选择分布式追踪软件\n- 在 Istio 中如何使用分布式追踪\n- 以 Bookinfo 和 SkyWalking 为例说明如何查看分布式追踪数据\n\n## 分布式追踪基础 {#tracing-basic}\n\n分布式追踪是一种用来跟踪分布式系统中请求的方法，它可以帮助用户更好地理解、控制和优化分布式系统。分布式追踪中用到了两个概念：TraceID 和 SpanID。\n\n- TraceID 是一个全局唯一的 ID，用来标识一个请求的追踪信息。一个请求的所有追踪信息都属于同一个 TraceID，TraceID 在整个请求的追踪过程中都是不变的；\n\n- SpanID 是一个局部唯一的 ID，用来标识一个请求在某一时刻的追踪信息。一个请求在不同的时间段会产生不同的 SpanID，SpanID 用来区分一个请求在不同时间段的追踪信息；\n\nTraceID 和 SpanID 是分布式追踪的基础，它们为分布式系统中请求的追踪提供了一个统一的标识，方便用户查询、管理和分析请求的追踪信息。\n\n![分布式追踪原理图](basic.svg)\n\n下面是分布式追踪的过程：\n\n1. 当一个系统收到请求后，分布式追踪系统会为该请求分配一个 TraceID，用于串联起整个调用链；\n2. 分布式追踪系统会为该请求在系统内的每一次服务调用生成一个 SpanID 和 ParentID，用于记录调用的父子关系，没有 ParentID 的 Span 将作为调用链的入口；\n3. 每个服务调用过程中都要传递 TraceID 和 SpanID；\n4. 在查看分布式追踪时，通过 TraceID 查询某次请求的全过程；\n\n## Istio 如何实现分布式追踪 {#distributed-tracing-in-istio}\n\nIstio 中的分布式追踪是基于数据平面中的 Envoy 代理实现的。服务请求在被劫持到 Envoy 中后，Envoy 在转发请求时会附加大量 Header，其中与分布式追踪相关的有：\n\n- 作为 TraceID：\u0060x-request-id\u0060\n- 用于在 LightStep 追踪系统中建立 Span 的父子关系：\u0060x-ot-span-context\u0060\n- 用于 Zipkin，同时适用于 Jaeger、SkyWalking，详见 [b3-propagation](https:\/\/github.com\/openzipkin\/b3-propagation)：\n  - \u0060x-b3-traceid\u0060\n  - \u0060x-b3-spanid\u0060\n  - \u0060x-b3-parentspanid\u0060\n  - \u0060x-b3-sampled\u0060\n  - \u0060x-b3-flags\u0060\n  - \u0060b3\u0060\n- 用于 Datadog：\n  - \u0060x-datadog-trace-id\u0060\n  - \u0060x-datadog-parent-id\u0060\n  - \u0060x-datadog-sampling-priority\u0060\n- 用于 SkyWalking：\u0060sw8\u0060\n- 用于 AWS X-Ray：\u0060x-amzn-trace-id\u0060\n\n关于这些 Header 的详细用法请参考 [Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers)。\n\nEnvoy 会在 Ingress Gateway 中为你产生用于追踪的 Header，不论你的应用程序使用何种语言开发，Envoy 都会将这些 Header 转发到上游集群。但是，你还要对应用程序代码做一些小的修改，才能为使用分布式追踪功能。这是因为应用程序无法自动传播这些 Header，可以在程序中集成分布式追踪的 Agent，或者在代码中手动传播这些 Header。Envoy 会将追踪数据发送到 tracer 后端处理，然后就可以在 UI 中查看追踪数据了。\n\n例如在 Bookinfo 应用中的 Productpage 服务，如果你查看它的代码可以发现，其中集成了 Jaeger 客户端库，并在 \u0060getForwardHeaders (request)\u0060 方法中将 Envoy 生成的 Header 同步给对 Details 和 Reviews 服务的 HTTP 请求：\n\n\u0060\u0060\u0060python\ndef getForwardHeaders(request):\n    headers = {}\n\n    # 使用 Jaeger agent 获取 x-b3-* header\n    span = get_current_span()\n    carrier = {}\n    tracer.inject(\n        span_context=span.context,\n        format=Format.HTTP_HEADERS,\n        carrier=carrier)\n\n    headers.update(carrier)\n\n    # 手动处理非 x-b3-* header\n    if \u0027user\u0027 in session:\n        headers[\u0027end-user\u0027] = session[\u0027user\u0027]\n    incoming_headers = [\n        \u0027x-request-id\u0027,\n        \u0027x-ot-span-context\u0027,\n        \u0027x-datadog-trace-id\u0027,\n        \u0027x-datadog-parent-id\u0027,\n        \u0027x-datadog-sampling-priority\u0027,\n        \u0027traceparent\u0027,\n        \u0027tracestate\u0027,\n        \u0027x-cloud-trace-context\u0027,\n        \u0027grpc-trace-bin\u0027,\n        \u0027sw8\u0027,\n        \u0027user-agent\u0027,\n        \u0027cookie\u0027,\n        \u0027authorization\u0027,\n        \u0027jwt\u0027,\n    ]\n\n    for ihdr in incoming_headers:\n        val = request.headers.get(ihdr)\n        if val is not None:\n            headers[ihdr] = val\n\n    return headers\n\u0060\u0060\u0060\n\n关于 Istio 中分布式追踪的常见问题请见 [Istio 文档](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)。\n\n## 分布式追踪系统如何选择 {#how-to-choose-a-distributed-tracing-system}\n\n分布式追踪系统的原理类似，市面上也有很多这样的系统，例如 [Apache SkyWalking](https:\/\/github.com\/apache\/skywalking)、[Jaeger](https:\/\/github.com\/jaegertracing\/jaeger)、[Zipkin](https:\/\/github.com\/openzipkin\/zipkin\/)、LightStep、[Pinpoint](https:\/\/github.com\/pinpoint-apm\/pinpoint) 等。我们将选择其中三个，从多个维度进行对比。之所以选择它们是因为：\n\n- 它们是当前最流行的开源分布式追踪系统；\n- 都是基于 OpenTracing 规范；\n- 都支持与 Istio 及 Envoy 集成；\n\n{{\u003ctable \u0022分布式追踪系统对比表（数据截止时间 2022-12-07）\u0022\u003e}}\n| 类别      | Apache SkyWalking                                            | Jaeger                                       | Zipkin                                       |\n| --------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| 实现方式  | 基于语言的探针、服务网格探针、eBPF agent、第三方指标库（当前支持 Zipkin） | 基于语言的探针                               | 基于语言的探针                               |\n| 数据存储  | ES、H2、MySQL、TiDB、Sharding-sphere、BanyanDB               | ES、MySQL、Cassandra、内存                   | ES、MySQL、Cassandra、内存                   |\n| 支持语言  | Java、Rust、PHP、NodeJS、Go、Python、C\u002b\u002b、.NET、Lua          | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b | Java、Go、Python、NodeJS、C#、PHP、Ruby、C\u002b\u002b |\n| 发起者    | 个人                                                         | Uber                                         | Twitter                                      |\n| 治理方式  | Apache Foundation                                            | CNCF                                         | CNCF                                         |\n| 版本      | 9.3.0                                                        | 1.39.0                                       | 2.23.19                                      |\n| Star 数量 | 20.9k                                                        | 16.8k                                        | 15.8k                                        |\n\n{{\u003c\/table\u003e}}\n\n虽然 Apache SkyWalking 的 Agent 支持的语言没有 Jaeger 和 Zipkin 多，但是 SkyWalking 的实现方式更丰富，并且与 Jaeger、Zipkin 的追踪数据兼容，开发更为活跃，且为国人开发，中文资料丰富，是构建遥测平台的最佳选择之一。\n\n## 实验 {#demo}\n\n参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/skywalking\/)来安装和配置 Apache SkyWalking。\n\n### 环境说明 {#environments}\n\n以下是我们实验的环境：\n\n- Kubernetes 1.24.5\n- Istio 1.16\n- SkyWalking 9.1.0\n\n### 安装 Istio {#install-istio}\n\n安装之前可以先检查下环境是否有问题：\n\n\u0060\u0060\u0060bash\n$ istioctl experimental precheck\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\n  To get started, check out https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/\n\u0060\u0060\u0060\n\n然后使用 \u0060istioctl\u0060 安装 Istio 同时配置发送追踪信息的目的地为 SkyWalking：\n\n\u0060\u0060\u0060bash\n# 将安装配置保存到文件中\ncat\u003c\u003cEOF\u003eistio-install.yaml\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\n  name: istio-with-skywalking\nspec:\n  meshConfig:\n    defaultProviders:\n      tracing:\n      - \u0022skywalking\u0022\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: tracing.istio-system.svc.cluster.local\n        port: 11800\nEOF\n\n# 使用 istioctl 安装 Istio\nistioctl install -f istio-install.yaml\n\u0060\u0060\u0060\n\n### 部署 Apache SkyWalking {#install-skywalking}\n\nIstio 1.16 支持使用 Apache SkyWalking 进行分布式追踪，执行下面的代码安装 SkyWalking：\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\n它将在 \u0060istio-system\u0060 命名空间下安装：\n\n- SkyWalking OAP (Observability Analysis Platform) ：用于接收追踪数据，支持 SkyWalking 原生数据格式，Zipkin v1 和 v2 以及 Jaeger 格式。\n- UI：用于查询分布式追踪数据。\n\n关于 SkyWalking 的详细信息请参考 SkyWalking 文档。\n\n### 部署 Bookinfo 应用 {#install-bookinfo}\n\n执行下面的命令安装 bookinfo 示例：\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n\u0060\u0060\u0060\n\n然后给 productpage 服务发送请求，如果你是在 Kind 中安装的 Istio，则默认的 IngressGateway 将是 LoadBalancer 类型，你可以使用端口转发的方式来暴露网关。\n\n\u0060\u0060\u0060bash\nkubectl port-forward -n istio-system svc\/istio-ingressgateway 8081:80\n\u0060\u0060\u0060\n\n通过 \u0060http:\/\/localhost:8081\/productpage\u0060 就可以访问到 productpage 服务。多访问几次来制造一些流量，后面我们就能在 SkyWalking UI 上看到拓扑图了。\n\n打开 SkyWalking UI：\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nSkyWalking 的 General Service 页面展示了 bookinfo 应用中的所有服务。\n\n![SkyWalking 的 General Service 页面](general-service.jpg)\n\n你还可以看到实例、端点、拓扑、追踪等信息。例如下图展示了 bookinfo 应用的服务拓扑。\n\n![Bookinfo 应用的服务拓扑](topology.jpg)\n\nSkyWalking 的追踪视图有多种显示形式，如列表、树形、表格和统计。\n\n![SkyWalking 通用服务追踪支持多种显示样式](gs-styles.jpg)\n\n为了方便我们检查，将追踪的采样率设置为 100%：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  tracing:\n  - randomSamplingPercentage: 100.00\nEOF\n\u0060\u0060\u0060\n\n### 卸载 {#purge}\n\n在实验完后，执行下面的命令卸载 Istio 和 SkyWalking：\n\n\u0060\u0060\u0060bash\nsamples\/bookinfo\/platform\/kube\/cleanup.sh\nistioctl unintall --purge\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## Bookinfo demo 追踪信息说明 {#bookinfo-tracing}\n\n在 Apache SkyWalking UI 中导航到 General Service 分页，查看最近的 \u0060istio-ingressgateway\u0060 服务的追踪信息，表视图如下所示。图中展示了此次请求所有 Span 的基本信息，点击每个 Span 可以查看详细信息。\n\n![表格视图中显示了 Span 的基本信息](span-table.jpg)\n\n切换为列表视图，可以看到每个 Span 的执行顺序及持续时间，如下图所示。\n\n![列表视图](trace-list.jpg)\n\n你可能会感到困惑，为什么这么简单的一个应用会产生如此多的 Span 信息？因为我们为 Pod 注入了 Envoy 代理之后，每个服务间的请求都会被 Envoy 拦截和处理，如下图所示。\n\n![Envoy 拦截请求产生 Span](span.svg)\n\n整个追踪流程如下图所示。\n\n![Bookinfo 的分布式追踪痕迹](bookinfo-spans-with-time.svg)\n\n图中给每一个 Span 标记了序号，并在括号里注明了耗时。为了便于说明我们将所有 Span 汇总在下面的表格中。\n\n| 序号 | 方法     | 总耗时（ms） | 组件耗时（ms） | 当前服务         | 说明                    |\n| -------- | ------------ | ------------------------ | -------------------------- | -------------------- | ------------------------------- |\n| 1    | \/productpage | 190                      | 0                          | istio-ingressgateway | Envoy Outbound          |\n| 2    | \/productpage | 190                      | 1                          | istio-ingressgateway | Ingress -\u003e Productpage 网络传输 |\n| 3    | \/productpage | 189                      | 1                          | productpage          | Envoy Inbound       |\n| 4    | \/productpage | 188                      | 21                         | productpage          | 应用内部处理        |\n| 5    | \/details\/0   | 8                        | 1                          | productpage          | Envoy Outbound      |\n| 6    | \/details\/0   | 7                        | 3                          | productpage          | Productpage -\u003e Details 网络传输     |\n| 7    | \/details\/0   | 4                        | 0                          | details              | Envoy Inbound           |\n| 8    | \/details\/0   | 4                        | 4                          | details              | 应用内部                |\n| 9    | \/reviews\/0   | 159                      | 0                          | productpage          | Envoy Outbound      |\n| 10   | \/reviews\/0   | 159                      | 14                         | productpage          | Productpage -\u003e Reviews 网络传输 |\n| 11   | \/reviews\/0   | 145                      | 1                          | reviews              | Envoy Inbound           |\n| 12   | \/reviews\/0   | 144                      | 109                        | reviews              | 应用内部处理              |\n| 13   | \/ratings\/0   | 35                       | 2                          | reviews              | Envoy Outbound          |\n| 14   | \/ratings\/0   | 33                       | 16                         | reviews              | Reviews -\u003e Ratings 网络传输         |\n| 15   | \/ratings\/0   | 17                       | 1                          | ratings              | Envoy Inbound           |\n| 16   | \/ratings\/0   | 16                       | 16                         | ratings              | 应用内部处理            |\n\n从以上信息可以发现：\n\n- 本次请求总耗时 190ms；\n- 在 Istio sidecar 模式下，每次流量在进出应用容器时都需要经过一次 Envoy 代理，每次耗时在 0 到 2 ms；\n- 在 Pod 间的网络请求耗时在 1 到 16ms 之间；\n- 将耗时做多的调用链 Ingress Gateway -\u003e Productpage -\u003e Reviews -\u003e Ratings 上的所有耗时累计 182 ms，小于请求总耗时 190ms，这是因为数据本身有误差，以及 Span 的开始时间并不一定等于父 Span 的结束时间，如果你在 SkyWalking 的追踪页面，选择「列表」样式查看追踪数据（见图 2）可以更直观的发现这个问题；\n- 我们可以查看到最耗时的部分是 Reviews 应用，耗时 109ms，因此我们可以针对该应用进行优化；\n\n## 总结 {#summary}\n\n只要对应用代码稍作修改就可以在 Istio 很方便的使用分布式追踪功能。在 Istio 支持的众多分布式追踪系统中，[Apache SkyWalking](https:\/\/skywalking.apache.org\/) 是其中的佼佼者。它不仅支持分布式追踪，还支持指标和日志收集、报警、Kubernetes 和服务网格监控，[使用 eBPF 诊断服务网格性能](https:\/\/skywalking.apache.org\/zh\/diagnose-service-mesh-network-performance-with-ebpf\/)等功能，是一个功能完备的云原生应用分析平台。本文中为了方便演示，将追踪采样率设置为了 100%，在生产使用时请根据需要调整采样策略（采样百分比），防止产生过多的追踪日志。\n\n## 参考 {#reference}\n\n- [Istio 分布式追踪概览 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/observability\/distributed-tracing\/overview\/)\n- [Istio 分布式追踪 FAQ - istio.io](https:\/\/istio.io\/latest\/zh\/about\/faq\/#distributed-tracing)\n', '\/blog\/distributed-tracing-with-skywalking-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要介绍了在云原生应用中分布式追踪的相关内容，包括分布式追踪基础、Istio 实现分布式追踪的方式、分布式追踪系统的选择、以 Bookinfo 和 SkyWalking 为例的实验以及总结和参考。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/understanding-the-tls-encryption-in-istio/">如何理解 Istio 中的 mTLS 流量加密？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何理解 Istio 中的 mTLS 流量加密？', '本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。', '\nIstio 服务网格可以帮助云原生应用实现自动 mTLS，完成网格内的流量加密，有助于缩小云原生部署的攻击面，是构建零信任应用网络的关键框架。为了理解 Istio 中的 mTLS 流量加密，本文将包括以下内容：\n\n- 介绍什么是 TLS、mTLS 和 TLS 终止\n- 介绍 Istio 中如何实现 TLS 加密\n- 如何使用 Istio 为 Kubernetes 中的服务实现 mTLS？\n- 何时需要 mTLS？何时不需要 mTLS？\n\n## 什么是 TLS 和 mTLS？{#what-is-tls-and-mtls}\n\nTLS（Transport Layer Security，传输层安全性）是一种广泛采用的安全协议，用于在联网计算机之间建立经过身份验证和加密的链接，旨在促进互联网通信的私密性和数据安全性。TLS 作为 [SSL](https:\/\/www.ssl.com\/faqs\/faq-what-is-ssl\/)（Secure Socket Layer，安全套接字层）的继任者，实际上是由 SSL 改名而来，因此人们经常将 TLS\/SSL 混用，在本文中我们将统称为 TLS。TLS 1.0 发布于 1999 年，最新版本为 1.3（发布于 2018 年 8 月），1.0 和 1.1 版本已弃用。\n\n我们在浏览网页时看到的 HTTPS 实际上就使用了 TLS，如下图所示。TLS 是建立在 TCP 之上的，作为 OSI 模型中的会话层。为了保证兼容性，TLS 通常使用 443 端口，但是你也可以使用任意端口。\n\n![HTTP vs HTTPS](http-vs-https.svg)\n\n当客户端需要验证服务端身份，以防中间人攻击同时保证通信安全的情况下，在和服务端通信时会要求 TLS 加密。下图展示了的是 TLS 加密通信的流程。\n\n![TLS 加密通信流程](tls-flow.svg)\n\n1. 服务器向受信任的 CA（证书管理机构）申请并获得证书（X.509 证书）；\n2. 客户端向服务端发起请求，其中包含客户端支持的 TLS 版本和密码组合等信息；\n3. 服务器回应客户端请求并附上数字证书；\n4. 客户端验证证书的状态、有效期和数字签名等信息，确认服务器的身份；\n5. 客户端和服务器使用共享秘钥实现加密通信；\n\n以上仅是对 TLS 通信流程的一个概要描述，实际的 TLS 握手过程比较复杂，请参考[这篇文档](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)。\n\n从以上过程中你会发现，证书是代表服务器身份的关键要素，对于互联网公开服务，服务器需要使用权威认证的 CA 颁发的证书，而对于私有环境内部的服务，可以使用 PKI（Private Key Infrastructure，私钥基础设施）来管理证书。\n\n双向 TLS 或相互 TLS（Mutual TLS 或 mTLS）是指在服务端和客户端之间使用双向加密通道，需要双方相互提供证书并验证对方身份。关于如何在 Kubernetes 中使用 mTLS 请参考[这篇文章](https:\/\/cloudnative.to\/blog\/mtls-guide\/)。关于 mTLS 的详细介绍请见[这篇文章](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)。\n\n## 什么是 TLS 终止？{#what-is-tls-termination}\n\nTLS 终止（TLS Termination）指的是在将 TLS 加密流量传递给 Web 服务器之前对其进行解密的过程。将 TLS 流量卸载到入口网关或专用设备上，可以提高 Web 应用的性能，同时确保加密流量的安全性。一般运行在集群入口处，当流量到达入口处时实施 TLS 终止，入口与集群内服务器之间的通信将直接使用 HTTP 明文，这样可以提高服务性能。\n\n![TLS 终止](tls-termination.svg)\n\nIstio 默认在入口网关处终止 TLS，然后再为网格内的服务开启 mTLS。你也可以让流量直通（passthrough）到后端服务处理，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\n详见[网关 TLS  配置](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways)。\n\n## Istio 中如何实现自动 mTLS？{#istio-mtls}\n\n下图中展示的是 Istio 安全架构图，从图中可以看到在入口处使用 JWS \u002b TLS 认证和加密，在 Istio 网格内部的所有服务间都开启了 mTLS。\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio 中内置了 CA，使用 xDS 中的 SDS（Secret Discovery Service，秘密发现服务）实现 SVID 证书的签发和轮换。Istio 网格内的 mTLS 流程如下：\n\n1. Sidecar 代替工作负载向 Istiod 申请证书，Istiod 签发 [SVID](\/book\/kubernetes-handbook\/auth\/spiffe\/#svid) 证书（该过程比较复杂，我将在今后的博客中说明）；\n2. 客户端请求被 Pod 内的 sidecar 拦截；\n3. 客户端 sidecar 与服务端 sidecar 开始 mTLS 握手。在握手的同时，客户端 sidecar 中的 JWT 和认证过滤器将对请求的身份进行认证，认证通过后将身份存储在过滤器元数据中，然后请求经过授权过滤器，判断请求权限。\n4. 若请求通过了认证与授权，则客户端和服务端开始建立连接进行通信。\n\nIstio 中有三个资源对象可用于配置服务间的认证与授权：\n\n- \u0060RequestAuthentication\u0060：用于定义服务支持的请求级认证方式，目前只支持  JWT（[查看 JWT 组件详解](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)）；\n- \u0060PeerAuthentication\u0060：配置服务间的传输认证模式，如 \u0060STRICT\u0060、\u0060PERMISSIVE\u0060 或 \u0060DISABLE\u0060 等，以开启 mTLS 或明文请求；\n- \u0060AuthorizationPolicy\u0060：用于授权服务间的流量，定义谁可以做什么？例如主体 A 允许（\u0060ALLOW\u0060）或拒绝（\u0060DENY\u0060）来自主体 B 的流量；\n\n## 如何使用 Istio 为服务开启自动 mTLS？ {#how-to-setup-mtls}\n\n你可以在 \u0060PeerAuthentication\u0060 中指定对目标工作负载实施的 mTLS 模式。对等认证支持以下模式：\n\n- \u0060PERMISSIVE\u0060：默认值，工作负载可接受双向 TLS 或纯文本流量；\n- \u0060STRICT\u0060：工作负载仅接受 mTLS 流量；\n- \u0060DISABLE\u0060：禁用 mTLS。从安全角度来看，除非你有自己的安全解决方案，否则不应禁用 mTLS；\n- \u0060UNSET\u0060：从父级继承，优先级为服务特定 \u003e 命名空间范围 \u003e 网格范围的设置；\n\nIstio 的对等认证默认使用 \u0060PERMISSIVE\u0060 模式，自动将 mTLS 流量发送到这些工作负载，将纯文本流量发送到没有 sidecar 的工作负载。在将 Kubernetes 服务纳入 Istio 网格后，为了防止服务无法通过 mTLS，我们可以先使用 \u0060PERMISSIVE\u0060 模式。当我想为某些服务开启严格的 mTLS 模式时，可以使用以下两种方式之一：\n\n- 使用 \u0060PeerAuthentication\u0060 定义流量如何在 sidecar 之间传输；\n- 使用 \u0060DestinationRule\u0060 定义流量路由策略中的 TLS 设置；\n\n下面以为 \u0060default\u0060 命名空间下的 \u0060reviews\u0060 服务设置 mTLS 为例说明。\n\n### 使用 PeerAuthentication 为工作负载设置 mTLS {#peerauthentication-tls-setting}\n\n你可以使用 \u0060namespace\u0060 和 \u0060selector\u0060 指定某个命名空间下的某个工作负载开启严格的 mTLS。例如下面的配置：\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\n你也可以给安装 Istio  的命名空间 \u0060istio-system\u0060 设置严格的 mTLS，那样会为网格中的所有服务开启严格的 mTLS，详细步骤请参考 [Istio 文档](https:\/\/istio.io\/latest\/zh\/docs\/tasks\/security\/authentication\/mtls-migration\/)。\n\n### 使用 DestinationRule 为工作负载设置 mTLS {#destinationrule-tls-setting}\n\nDestinationRule 用于设置流量路由策略，例如负载均衡、异常点检测、TLS 设置等。其中 TLS 设置中包含[多种模式](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ClientTLSSettings-TLSmode)，使用 \u0060ISTIO_MUTUAL\u0060 模式可以为工作负载开启 Istio 的自动 TLS，如下所示。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## 什么时候用 mTLS？{#when-use-mtls}\n\n互联网客户端对 Web 服务的访问，一般使用单向 TLS，即只需要服务端提供身份证明，而不关心客户端的身份。当你需要验证客户端身份时，使用单向 TLS 可以使用密码、token、双因子认证等方式。不过这样的认证方式需要应用程序内部支持，而双向 TLS 是运行在应用程序之外的，不需要多应用逻辑进行修改。\n\n当你需要正如你在上文中看到的，实施 mTLS 的服务间需要交换证书，当服务数量变大时，就需要管理大量的证书，这需要消耗大量的精力，使用服务网格可以帮助你实现自动 mTLS，彻底解决证书管理的难题。\n\n## 什么时候不用 mTLS？{#when-not-use-mtls}\n\n虽然 mTLS 是确保云原生应用程序服务间通信安全的首选协议，但是应用 mTLS 需要完成复杂的对称加密、解密过程，这将非常耗时且消耗大量的 CPU 资源。对于某些安全级别不高的流量，如果我们在流量入口处终止 TLS，并网格内部仅对针对性的服务开启 mTLS，就可以加快请求响应和减少计算资源消耗。\n\n另外当有的服务无法获取证书，例如 Kubelet 上使用 HTTP 的健康检查，无法通过 TLS 访问服务内的健康检查端点，这时候就需要[为 Pod 禁用探针重写](https:\/\/istio.io\/latest\/zh\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod)。\n\n最后当网格中的服务访问一些外部服务时，也不需要 mTLS。\n\n## 总结 {#summary}\n\nmTLS 实现了网格内流量的加密，是构建零信任应用网络的关键一步。借助 Istio 我们可以很方便的为 Kubernetes 中的服务开启自动 mTLS，省去管理证书的麻烦。同时，我们也可以针对性的为网格内的部分服务开启 mTLS，便于我们将 Kubernetes 中的服务迁移到网格内。关于 Istio 中的证书管理，我们将在今后的博客中再做说明。\n\n## 参考 {#reference}\n\n- [什么是 TLS（传输层安全性）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/ssl\/transport-layer-security-tls\/)\n- [什么是相互 TLS（mTLS）？- cloudflare.com](https:\/\/www.cloudflare.com\/zh-cn\/learning\/access-management\/what-is-mutual-tls\/)\n- [What happens in a TLS handshake? | SSL handshake - cloudflare.com](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n- [写给 Kubernetes 工程师的 mTLS 指南 - jimmysong.io](https:\/\/cloudnative.to\/blog\/mtls-guide\/)\n- [云原生安全白皮书中文版 - github.com](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/security-whitepaper\/v1\/cloud-native-security-whitepaper-simplified-chinese.md)\n- [Istio 安全 - istio.io](https:\/\/istio.io\/latest\/zh\/docs\/concepts\/security\/)\n- [JWT 组件详解 - jimmysong.io](https:\/\/cloudnative.to\/blog\/jwt-components-explained\/)\n', '\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 TLS、mTLS 相关知识，并介绍了 Istio 中如何开启 mTLS 和其应用场景。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ambient-mesh-l7-traffic-path/">Istio Ambient 模式中的七层流量路由路径详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的七层流量路由路径详解', '本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的七层（L7）流量路径。', '\n在[上一篇博客中](\/blog\/ambient-mesh-l4-traffic-path\/)我介绍了 Ambient 模式中的透明流量劫持和四层流量路由，在这一篇博客中，我将向你介绍在 Istio 的 Ambient 模式中，七层流量是如何路由的。\n\n下图展示了 Ambient 模式中七层网络流量路径。\n\n![Ambient Mesh 中的七层网络流量路径](ambient-mesh-l7-traffic-path.svg)\n\n注意：Waypoint Proxy 可以位于应用程序所在节点，甚至图中的服务 A、服务 B 和 Waypoint Proxy 都可以位于同一个节点，之所以将它们画在三个节点上是为了方便展示，但是对于实际的流量路径没有大的影响，只不过是不再通过 eth0 发送到另外一个节点。\n\n下文我们将从手操作探究图中过程。\n\n## 环境说明 {#environment}\n\n我们继续使用上一篇博客中部署的 Ambient 模式的 Istio，[查看环境说明](\/blog\/ambient-mesh-l4-traffic-path\/#environment)。为了说明七层网路路由，我们需要在此基础上再创建一个 Gateway：\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n name: productpage\n annotations:\n   istio.io\/service-account: bookinfo-productpage\nspec:\n gatewayClassName: istio-mesh\nEOF\n\u0060\u0060\u0060\n\n执行完该命令后，\u0060default\u0060 命名空间下会创建了一个 Waypoint proxy，在我的环境中这个 pod 的名字是 \u0060bookinfo-productpage-waypoint-proxy-6f88c55d59-4dzdx\u0060，专门用于处理发往 productpage 服务（服务 B）的 L7 流量，我将它称之为 Waypoint Proxy B。\n\nWaypoint 代理可以位于与工作负载相同或者不同的节点上，它也可以部署在独立的命名空间中，不论它位于哪个节点，对于 L7 流量路径没有影响。\n\nAmbient mesh 中透明流量的方式在 L4 和 L7 网络中没有什么不同，因此在这篇博客中我们将略过 Inbound 和 Outbound 流量劫持部分，你可以查看[上一篇博客](\/blog\/ambient-mesh-l4-traffic-path\/)了解详情。\n\n下面我们将直接从流量被劫持到 Ztunnel A 后，被转发到 Envoy 的 15006 端口开始。\n\n## Ztunnel A 上的出站流量路由 {#ztunel-a-outbound}\n\n使用下面的命令导出 Ztunnel A 上的 Envoy 代理配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system ztunnel-hptxk -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-a-all-include-eds.json\n\u0060\u0060\u0060\n\n查看 \u0060ztunnel-a-all-include-eds.json\u0060 文件中的 Listener 配置部分，根据目的端口和来源 IP 的匹配关系，你将看到 \u0060ztunnel_outbound\u0060 监听器中有如下配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=2 12 18\u0022\u003e}}\n{\n  \u002210.8.14.226\u0022: {\n    \u0022matcher\u0022: {\n    \u0022matcher_tree\u0022: {\n      \u0022input\u0022: {\n      \u0022name\u0022: \u0022port\u0022,\n      \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n      }\n      },\n      \u0022exact_match_map\u0022: {\n      \u0022map\u0022: {\n        \u00229080\u0022: {\n        \u0022action\u0022: {\n          \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022,\n          \u0022typed_config\u0022: {\n          \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n          \u0022value\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022\n          }\n        }\n        }\n      }\n      }\n    }\n    }\n  }\n}\n{{\u003c\/highlight\u003e}}\n\n\u006010.8.14.226\u0060 是目标服务的 Cluster  IP，服务端口是 9080。流量将被路由到 \u0060spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0060 集群，查看该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_server_waypoint_proxy_spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   }\n  },\n  \/* 省略 *\/\n}\n{{\u003c\/highlight\u003e}}\n\n该集群使用 EDS 服务发现。查看该集群的 EDS 信息：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=11 12\u0022\u003e}}\n{ \n \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n \u0022endpoints\u0022: [\n  {\n   \u0022locality\u0022: {},\n   \u0022lb_endpoints\u0022: [\n    {\n     \u0022endpoint\u0022: {\n      \u0022address\u0022: {\n       \u0022socket_address\u0022: {\n        \u0022address\u0022: \u002210.4.3.14\u0022,\n        \u0022port_value\u0022: 15006\n       }\n      },\n      \u0022health_check_config\u0022: {}\n     },\n     \u0022health_status\u0022: \u0022HEALTHY\u0022,\n     \u0022load_balancing_weight\u0022: 1\n    }\n   ]\n  }\n ],\n \u0022policy\u0022: {\n  \u0022overprovisioning_factor\u0022: 140\n }\n}\n{{\u003c\/highlight\u003e}}\n\n注意：这里还是缺少输出 \u0060cluster_name\u0060 字段。\n\n在这里直接将流量转发给 Waypoint Proxy 的端点 \u006010.4.3.14:15006\u0060。\n\n## Waypoint Proxy B 上的流量转发 {#waypoint-proxy-b}\n\n我们再导出 Waypoint Proxy B 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n default bookinfo-productpage-waypoint-proxy-6f88c55d59-4dzdx -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003ewaypoint-a-all-include-eds.json\n\u0060\u0060\u0060\n\n查看 \u0060inbound_CONNECT_terminate\u0060 监听器的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 39 44 58 62\u0022\u003e}}\n{\n  \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022,\n  \u0022active_state\u0022: {\n    \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n    \u0022listener\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n    \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022,\n    \u0022address\u0022: {\n      \u0022socket_address\u0022: {\n      \u0022address\u0022: \u00220.0.0.0\u0022,\n      \u0022port_value\u0022: 15006\n      }\n    },\n    \u0022filter_chains\u0022: [{\n      \u0022filters\u0022: [{\n        \u0022name\u0022: \u0022capture_tls\u0022,\n        \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n        \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.CaptureTLS\u0022\n        }\n      },\n      {\n        \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n        \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_hcm\u0022,\n        \u0022route_config\u0022: {\n          \u0022name\u0022: \u0022local_route\u0022,\n          \u0022virtual_hosts\u0022: [{\n          \u0022name\u0022: \u0022connect\u0022,\n          \u0022domains\u0022: [\n            \u0022*\u0022\n          ],\n          \u0022routes\u0022: [{...},\n            {\n            \u0022match\u0022: {\n              \u0022headers\u0022: [{\n              \u0022name\u0022: \u0022:authority\u0022,\n              \u0022exact_match\u0022: \u002210.8.14.226:9080\u0022\n              }],\n              \u0022connect_matcher\u0022: {}\n            },\n            \u0022route\u0022: {\n              \u0022cluster\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n              \u0022upgrade_configs\u0022: [{\n              \u0022upgrade_type\u0022: \u0022CONNECT\u0022,\n              \u0022connect_config\u0022: {}\n              }]\n            }\n            }\n          ]\n          }],\n          \u0022validate_clusters\u0022: false\n        },\n        \u0022http_filters\u0022: [...],\n        \u0022tracing\u0022: {...},\n        \u0022http2_protocol_options\u0022: {\n          \u0022allow_connect\u0022: true\n        },\n        \u0022use_remote_address\u0022: false,\n        \u0022upgrade_configs\u0022: [{\n          \u0022upgrade_type\u0022: \u0022CONNECT\u0022\n        }],\n        \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n        \u0022normalize_path\u0022: true,\n        \u0022request_id_extension\u0022: {...},\n        \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n        }\n      }\n      ],\n      \u0022transport_socket\u0022: {...},\n      \u0022name\u0022: \u0022inbound_CONNECT_terminate\u0022\n    }]\n    },\n    \u0022last_updated\u0022: \u00222022-11-17T06:24:51.467Z\u0022\n  }\n}\n{{\u003c\/highlight\u003e}}\n\n目的地为 \u006010.8.14.226:9080\u0060 的 TCP 流量将被转发到 \u0060inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0060，并将 HTTP 类型修改为 \u0060CONNECT\u0060，查看该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 37\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n  \u0022type\u0022: \u0022STATIC\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022passthrough_metadata\u0022: [\n     {\n      \u0022kind\u0022: {\n       \u0022cluster\u0022: {}\n      },\n      \u0022name\u0022: \u0022istio\u0022\n     }\n    ],\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {},\n  \u0022load_assignment\u0022: {\n   \u0022cluster_name\u0022: \u0022inbound-vip|9080|internal|productpage.default.svc.cluster.local\u0022,\n   \u0022endpoints\u0022: [\n    {\n     \u0022lb_endpoints\u0022: [\n      {\n       \u0022endpoint\u0022: {\n        \u0022address\u0022: {\n         \u0022envoy_internal_address\u0022: {\n          \u0022server_listener_name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022\n         }\n        }\n       }\n      }\n     ]\n    }\n   ]\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.137Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群的端点是一个内部监听器 \u0060inbound-vip|9080||productpage.default.svc.cluster.local\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=21-47 73-80\u0022\u003e}}\n{\n \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local\u0022,\n   \u0022filter_chains\u0022: [{\n    \u0022filters\u0022: [{\n      \u0022name\u0022: \u0022restore_tls\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n       \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.RestoreTLS\u0022\n      }\n     },\n     {\n      \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n       \u0022stat_prefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n       \u0022route_config\u0022: {\n        \u0022name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n        \u0022virtual_hosts\u0022: [{\n         \u0022name\u0022: \u0022inbound|http|9080\u0022,\n         \u0022domains\u0022: [\n          \u0022*\u0022\n         ],\n         \u0022routes\u0022: [{\n          \u0022match\u0022: {\n           \u0022prefix\u0022: \u0022\/\u0022\n          },\n          \u0022route\u0022: {\n           \u0022cluster\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n           \u0022timeout\u0022: \u00220s\u0022,\n           \u0022max_stream_duration\u0022: {\n            \u0022max_stream_duration\u0022: \u00220s\u0022,\n            \u0022grpc_timeout_header_max\u0022: \u00220s\u0022\n           }\n          },\n          \u0022decorator\u0022: {\n           \u0022operation\u0022: \u0022:9080\/*\u0022\n          },\n          \u0022name\u0022: \u0022default\u0022\n         }]\n        }],\n        \u0022validate_clusters\u0022: false\n       }\n      },\n      \u0022server_name\u0022: \u0022istio-envoy\u0022,\n      \u0022use_remote_address\u0022: false,\n      \u0022forward_client_cert_details\u0022: \u0022APPEND_FORWARD\u0022,\n      \u0022set_current_client_cert_details\u0022: {\n       \u0022subject\u0022: true,\n       \u0022dns\u0022: true,\n       \u0022uri\u0022: true\n      },\n      \u0022upgrade_configs\u0022: [{\n       \u0022upgrade_type\u0022: \u0022websocket\u0022\n      }],\n      \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n      \u0022normalize_path\u0022: true,\n      \u0022request_id_extension\u0022: {\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig\u0022,\n        \u0022use_request_id_for_trace_sampling\u0022: true\n       }\n      },\n      \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n     }\n    ],\n    \u0022name\u0022: \u0022inbound-vip|9080||productpage.default.svc.cluster.local-http\u0022\n   }],\n   \u0022listener_filters\u0022: [{\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.metadata_to_peer_node\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.telemetry.metadatatopeernode.v1.Config\u0022\n     }\n    }\n   ],\n   \u0022traffic_direction\u0022: \u0022INBOUND\u0022,\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.300Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-vip|9080|http|productpage.default.svc.cluster.local\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   },\n   \u0022service_name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022\n  },\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022metadata\u0022: {\n   \u0022filter_metadata\u0022: {\n    \u0022istio\u0022: {\n     \u0022services\u0022: [{\n      \u0022namespace\u0022: \u0022default\u0022,\n      \u0022name\u0022: \u0022productpage\u0022,\n      \u0022host\u0022: \u0022productpage.default.svc.cluster.local\u0022\n     }]\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {}\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.138Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群是 EDS 类型，查看 Endpoint 配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=14\u0022\u003e}}\n{\n \u0022endpoint_config\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n  \u0022cluster_name\u0022: \u0022inbound-vip|9080|http|productpage.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [{\n   \u0022locality\u0022: {\n    \u0022region\u0022: \u0022us-west2\u0022,\n    \u0022zone\u0022: \u0022us-west2-a\u0022\n   },\n   \u0022lb_endpoints\u0022: [{\n    \u0022endpoint\u0022: {\n     \u0022address\u0022: {\n      \u0022envoy_internal_address\u0022: {\n       \u0022server_listener_name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022\n      }\n     },\n     \u0022health_check_config\u0022: {}\n    },\n    \u0022health_status\u0022: \u0022HEALTHY\u0022,\n    \u0022metadata\u0022: {\n     \u0022filter_metadata\u0022: {\n      \u0022istio\u0022: {\n       \u0022workload\u0022: \u0022productpage-v1;default;productpage;v1;Kubernetes\u0022\n      }\n     }\n    },\n    \u0022load_balancing_weight\u0022: 1\n   }]\n  }],\n  \u0022policy\u0022: {\n   \u0022overprovisioning_factor\u0022: 140\n  }\n }\n}\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-pod|9080||10.4.0.5\u0060 监听器：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=33\u0022\u003e}}\n\n{\n \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n   \u0022filter_chains\u0022: [{\n    \u0022filters\u0022: [{\n      \u0022name\u0022: \u0022restore_tls\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/udpa.type.v1.TypedStruct\u0022,\n       \u0022type_url\u0022: \u0022type.googleapis.com\/istio.tls_passthrough.v1.RestoreTLS\u0022\n      }\n     },\n     {\n      \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n       \u0022stat_prefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n       \u0022route_config\u0022: {\n        \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n        \u0022virtual_hosts\u0022: [{\n         \u0022name\u0022: \u0022inbound|http|9080\u0022,\n         \u0022domains\u0022: [\n          \u0022*\u0022\n         ],\n         \u0022routes\u0022: [{\n          \u0022match\u0022: {\n           \u0022prefix\u0022: \u0022\/\u0022\n          },\n          \u0022route\u0022: {\n           \u0022cluster\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n           \u0022timeout\u0022: \u00220s\u0022,\n           \u0022max_stream_duration\u0022: {\n            \u0022max_stream_duration\u0022: \u00220s\u0022,\n            \u0022grpc_timeout_header_max\u0022: \u00220s\u0022\n           }\n          },\n          \u0022decorator\u0022: {\n           \u0022operation\u0022: \u0022:9080\/*\u0022\n          },\n          \u0022name\u0022: \u0022default\u0022\n         }]\n        }],\n        \u0022validate_clusters\u0022: false\n       },\n       \u0022http_filters\u0022: [{\n        \u0022name\u0022: \u0022envoy.filters.http.rbac\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.http.rbac.v3.RBAC\u0022,\n         \u0022rules\u0022: {\n          \u0022policies\u0022: {\n           \u0022ns[default]-policy[productpage-viewer]-rule[0]\u0022: {\n            \u0022permissions\u0022: [{\n             \u0022and_rules\u0022: {\n              \u0022rules\u0022: [{\n               \u0022any\u0022: true\n              }]\n             }\n            }],\n            \u0022principals\u0022: [{\n             \u0022and_ids\u0022: {\n              \u0022ids\u0022: [{\n               \u0022or_ids\u0022: {\n                \u0022ids\u0022: [{\n                  \u0022authenticated\u0022: {\n                   \u0022principal_name\u0022: {\n                    \u0022exact\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022\n                   }\n                  }\n                 },\n                 {\n                  \u0022authenticated\u0022: {\n                   \u0022principal_name\u0022: {\n                    \u0022exact\u0022: \u0022spiffe:\/\/cluster.local\/ns\/istio-system\/sa\/istio-ingressgateway-service-account\u0022\n                   }\n                  }\n                 }\n                ]\n               }\n              }]\n             }\n            }]\n           }\n          }\n         },\n         \u0022shadow_rules_stat_prefix\u0022: \u0022istio_dry_run_allow_\u0022\n        }\n       }],\n       \u0022server_name\u0022: \u0022istio-envoy\u0022,\n       \u0022use_remote_address\u0022: false,\n       \u0022forward_client_cert_details\u0022: \u0022APPEND_FORWARD\u0022,\n       \u0022set_current_client_cert_details\u0022: {\n        \u0022subject\u0022: true,\n        \u0022dns\u0022: true,\n        \u0022uri\u0022: true\n       },\n       \u0022upgrade_configs\u0022: [{\n        \u0022upgrade_type\u0022: \u0022websocket\u0022\n       }],\n       \u0022stream_idle_timeout\u0022: \u00220s\u0022,\n       \u0022normalize_path\u0022: true,\n       \u0022request_id_extension\u0022: {\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig\u0022,\n         \u0022use_request_id_for_trace_sampling\u0022: true\n        }\n       },\n       \u0022path_with_escaped_slashes_action\u0022: \u0022KEEP_UNCHANGED\u0022\n      }\n     }\n    ],\n    \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5-http\u0022\n   }],\n   \u0022listener_filters\u0022: [{\n    \u0022name\u0022: \u0022set_dst_address\u0022,\n    \u0022typed_config\u0022: {\n     \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n     \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n     \u0022value\u0022: {}\n    }\n   }],\n   \u0022traffic_direction\u0022: \u0022INBOUND\u0022,\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.339Z\u0022\n }\n}\n\n{{\u003c\/highlight\u003e}}\n\n数据包被转发到 \u0060inbound-pod|9080||10.4.0.5\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 43 48-55\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n  \u0022type\u0022: \u0022STATIC\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n    \u0022passthrough_metadata\u0022: [\n     {\n      \u0022kind\u0022: {\n       \u0022host\u0022: {}\n      },\n      \u0022name\u0022: \u0022tunnel\u0022\n     },\n     {\n      \u0022kind\u0022: {\n       \u0022host\u0022: {}\n      },\n      \u0022name\u0022: \u0022istio\u0022\n     }\n    ],\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  },\n  \u0022common_lb_config\u0022: {},\n  \u0022load_assignment\u0022: {\n   \u0022cluster_name\u0022: \u0022inbound-pod|9080||10.4.0.5\u0022,\n   \u0022endpoints\u0022: [\n    {\n     \u0022lb_endpoints\u0022: [\n      {\n       \u0022endpoint\u0022: {\n        \u0022address\u0022: {\n         \u0022envoy_internal_address\u0022: {\n          \u0022server_listener_name\u0022: \u0022inbound_CONNECT_originate\u0022,\n          \u0022endpoint_id\u0022: \u002210.4.0.5:9080\u0022\n         }\n        }\n       },\n       \u0022metadata\u0022: {\n        \u0022filter_metadata\u0022: {\n         \u0022tunnel\u0022: {\n          \u0022destination\u0022: \u002210.4.0.5:9080\u0022,\n          \u0022address\u0022: \u002210.4.0.5:15008\u0022\n         }\n        }\n       }\n      }\n     ]\n    }\n   ]\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.139Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群是 \u0060STATIC\u0060 类型，其中包含了 HBONE 隧道配置（HTTP\/2 CONNECT 地址是 \u006010.4.0.15008\u0060），端点是 Envoy 内部监听器 \u0060inbound_CONNECT_originate\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=16-27 33 36\u0022\u003e}}\n{\n \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.tcp_proxy\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_CONNECT_originate\u0022,\n        \u0022cluster\u0022: \u0022inbound_CONNECT_originate\u0022,\n        \u0022tunneling_config\u0022: {\n         \u0022hostname\u0022: \u0022%DYNAMIC_METADATA(tunnel:destination)%\u0022,\n         \u0022headers_to_add\u0022: [\n          {\n           \u0022header\u0022: {\n            \u0022key\u0022: \u0022x-envoy-original-dst-host\u0022,\n            \u0022value\u0022: \u0022%DYNAMIC_METADATA([\\\u0022tunnel\\\u0022, \\\u0022destination\\\u0022])%\u0022\n           }\n          }\n         ]\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \u0022use_original_dst\u0022: false,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    }\n   ],\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-17T03:27:46.339Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- \u0060listener_filters\u0060 中的 \u0060set_dst_address\u0060 将目的地地址设置为 \u006010.4.0.5.15008\u0060；\n- 在隧道中新增了一个 Header：\u0060x-envoy-original-dst-host\u0060，它的值是 \u006010.4.0.5:9080\u0060；\n- 该集群的端点是 \u0060inbound_CONNECT_originate\u0060 集群；\n\n查看 \u0060inbound_CONNECT_originate\u0060 集群：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-17T03:27:45Z\/82\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022inbound_CONNECT_originate\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022connect_timeout\u0022: \u00222s\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022cleanup_interval\u0022: \u002260s\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\u0022,\n    \u0022common_tls_context\u0022: {\n     \u0022tls_params\u0022: {\n      \u0022tls_minimum_protocol_version\u0022: \u0022TLSv1_3\u0022,\n      \u0022tls_maximum_protocol_version\u0022: \u0022TLSv1_3\u0022\n     },\n     \u0022alpn_protocols\u0022: [\n      \u0022h2\u0022\n     ],\n     \u0022tls_certificate_sds_secret_configs\u0022: [\n      {\n       \u0022name\u0022: \u0022default\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     ],\n     \u0022combined_validation_context\u0022: {\n      \u0022default_validation_context\u0022: {\n       \u0022match_subject_alt_names\u0022: [\n        {\n         \u0022prefix\u0022: \u0022spiffe:\/\/cluster.local\/\u0022\n        }\n       ]\n      },\n      \u0022validation_context_sds_secret_config\u0022: {\n       \u0022name\u0022: \u0022ROOTCA\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     }\n    }\n   }\n  },\n  \u0022typed_extension_protocol_options\u0022: {\n   \u0022envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022,\n    \u0022explicit_http_config\u0022: {\n     \u0022http2_protocol_options\u0022: {\n      \u0022allow_connect\u0022: true\n     }\n    }\n   }\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-17T03:27:46.140Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n该集群的类型是 \u0060ORIGINAL_DST\u0060，直接与上游建立 HBONE 隧道，将数据包发送到 Pod B 的 15008 端口。在节点 B 的 Ztunnel 的流量劫持和路由方式就跟 L4 是一样的了，在这里不再赘述。\n\n## 总结 {#summary}\n\nL7 流量路由是在 L4 的基础上增加了 Waypoint 代理，该代理中 Envoy 处理比较复杂。Waypoint 代理使用 Gateway API 生成基于 Deployment 部署的，我们可以根据个别服务的负载情况，单独扩缩容其 Waypoint 代理，也可以创建 HPA 来动态扩容。\n\n## 参考 {#reference}\n\n- [Original destination - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#arch-overview-service-discovery-types-original-destination)\n- [一文读懂 Ambient Mesh 七层服务治理 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/TXMyxbzBSfuYNquOZJmZTg)\n', '\/blog\/ambient-mesh-l7-traffic-path\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的七层（L7）流量路径。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ambient-mesh-l4-traffic-path/">Istio Ambient 模式中的透明流量劫持四层网络路由路径详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Ambient 模式中的透明流量劫持四层网络路由路径详解', '本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。', '\n本文通过动手操作，带领读者一步步了解 Istio ambient 模式中的四层流量路径。如果你还不了解什么是 Ambient 模式，以下文章可以帮助你了解：\n\n- [关于 Istio 推出 Ambient 数据平面模式的看法](\/blog\/istio-ambient-mode\/)\n- [Istio 无 sidecar 代理数据平面 ambient 模式简介](https:\/\/cloudnative.to\/blog\/introducing-ambient-mesh\/)\n- [Istio 服务网格 ambient 模式安全详解](https:\/\/cloudnative.to\/blog\/ambient-security\/)\n- [什么是 Ambient Mesh，它与 sidecar 模式有什么区别？](https:\/\/cloudnative.to\/blog\/what-is-ambient-mesh\/)\n\n如果你想略过实际动手步骤，只是想知道 Ambient 模式中的四层流量路径，请看下面服务 A 的一个 Pod 访问不同节点上服务 B 的 Pod 的四层流量路径图。\n\n![Ambient 模式中的四层流量路径](ambient-mesh-l4-traffic-path.svg)\n\n## 原理 {#principles}\n\nAmbient 模式使用 **tproxy** 和 **HBONE** 这两个关键技术实现透明流量劫持和路由的：\n\n- 使用 tproxy 将主机 Pod 中的流量劫持到 Ztunnel（Envoy Proxy）中，实现透明流量劫持；\n- 使用 HBONE 建立在 Ztunnel 之间传递 TCP 数据流隧道；\n\n### 什么是 tproxy？{#what-is-tproxy}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt) 。\n\n### 什么是 HBONE？{#what-is-hbone}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n## 环境说明 {#environment}\n\n在开始动手操作之前，需要先说明一下笔者的演示环境，本文中对应的对象名称：\n\n| 代号           | 名称                                         | IP            |\n| -------------- | -------------------------------------------- | ------------- |\n| 服务 A Pod     | sleep-5644bdc767-2dfg7                       | 10.4.4.19     |\n| 服务 B Pod     | productpage-v1-5586c4d4ff-qxz9f              | 10.4.3.20     |\n| Ztunnel A Pod  | ztunnel-rts54                                | 10.4.4.18     |\n| Ztunnel B Pod  | ztunnel-z4qmh                                | 10.4.3.14     |\n| 节点 A         | gke-jimmy-cluster-default-pool-d5041909-d10i | 10.168.15.222 |\n| 节点 B         | gke-jimmy-cluster-default-pool-d5041909-c1da | 10.168.15.224 |\n| 服务 B Cluster | productpage                                  | 10.8.14.226   |\n\n注意：因为这些名称将在后续的命令行中用到，文中将使用代称，以便你在自己的环境中实验。\n\n笔者在 GKE 中安装了 Ambient 模式的 Istio，请参考[该步骤](\/blog\/istio-ambient-mode\/#setup)安装，注意不要安装 Gateway，以免启用 L7 功能，否则流量路径将于 L4 流量不同。\n\n下面我们将动手实验，深入探究 \u0060sleep\u0060 服务的 Pod 访问不同节点上 \u0060productpage\u0060 服务的 Pod 的四层流量路径。我们将分别检视 Pod 的 outbound 和 inbound 流量。\n\n## Outbound 流量劫持 {#outbound}\n\nAmbient mesh 的 pod 出站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioout\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 [IP 集](https:\/\/ipset.netfilter.org\/)，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioout\u0060 虚拟网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioout\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15001 端口；\n3. Envoy 对数据包进行处理，并与上游端点建立 HBONE 隧道（HTTP CONNECT），将数据包转发到上游。\n\n### 检查节点 A 上的路由规则 {#node-a-rules}\n\n登录到服务 A 所在的节点 A，使用 \u0060iptables-save\u0060 查看规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=3 4 6 35\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A PREROUTING -m comment --comment \u0022kubernetes service portals\u0022 -j KUBE-SERVICES\n-A ztunnel-POSTROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n-A ztunnel-PREROUTING -m mark --mark 0x100\/0x100 -j ACCEPT\n\/* 省略 *\/\n*mangle\n\/* 省略 *\/\n-A PREROUTING -j ztunnel-PREROUTING\n-A INPUT -j ztunnel-INPUT\n-A FORWARD -j ztunnel-FORWARD\n-A OUTPUT -j ztunnel-OUTPUT\n-A OUTPUT -s 169.254.169.254\/32 -j DROP\n-A POSTROUTING -j ztunnel-POSTROUTING\n-A ztunnel-FORWARD -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-FORWARD -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-INPUT -m mark --mark 0x220\/0x220 -j CONNMARK --save-mark --nfmask 0x220 --ctmask 0x220\n-A ztunnel-INPUT -m mark --mark 0x210\/0x210 -j CONNMARK --save-mark --nfmask 0x210 --ctmask 0x210\n-A ztunnel-OUTPUT -s 10.4.4.1\/32 -j MARK --set-xmark 0x220\/0xffffffff\n-A ztunnel-PREROUTING -i istioin -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioin -j RETURN\n-A ztunnel-PREROUTING -i istioout -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -i istioout -j RETURN\n-A ztunnel-PREROUTING -p udp -m udp --dport 6081 -j RETURN\n-A ztunnel-PREROUTING -m connmark --mark 0x220\/0x220 -j MARK --set-xmark 0x200\/0x200\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING ! -i veth300a1d80 -m connmark --mark 0x210\/0x210 -j MARK --set-xmark 0x40\/0x40\n-A ztunnel-PREROUTING -m mark --mark 0x40\/0x40 -j RETURN\n-A ztunnel-PREROUTING ! -s 10.4.4.18\/32 -i veth300a1d80 -j MARK --set-xmark 0x210\/0x210\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -i veth300a1d80 -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -p udp -j MARK --set-xmark 0x220\/0x220\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n{{\u003c\/highlight\u003e}}\n\niptables 规则说明：\n\n- 第 3 行：PREROUTING 链是最先运行的，所有数据包将先进入 \u0060ztunnel-PREROUTING\u0060 链；\n- 第 4 行：将数据包发往 \u0060KUBE-SERVICES\u0060 链，在那里将 Kubernetes Service 的 Cluster IP 进行 DNAT 转换为 Pod IP；\n- 第 6 行：带有 \u00600x100\/0x100\u0060 标记的数据包通过 PREROUTING 链，不再经过 \u0060KUBE-SERVICES\u0060 链；\n- 第 35 行：这是添加到 \u0060ztunnel-PREROUTING\u0060 链上的最后一条规则，进入 \u0060ztunnel-PREROUTING\u0060 链中的在 \u0060ztunnel-pods-ips\u0060 IP 集中的所有 TCP 数据包都会被打上 \u00600x100\/0x100\u0060 的标记，它将覆盖前面的所有标记；\n\n{{\u003ccallout note \u0022关于 iptables 设置 mark 和 xmark 标记\u0022\u003e}}\n\n\u0060MARK\u0060 这个扩展目标可以用来给数据包打标记，标记分两种：一种是用于标记链接的 \u0060ctmark\u0060，一种是用于标记数据包的 \u0060nfmark\u0060 。\u0060nfmark\u0060占四个字节共 32 位，我们可以把它看成是一个长度为 32 位的无符号整数，一般用 16 进制来表示。\n\nMark 的设置一共有五个选项，分别是 \u0060--set-xmark\u0060、\u0060--set-mark\u0060、\u0060--and-mark\u0060、\u0060--and-mark\u0060、\u0060--or-mark\u0060 和 \u0060--xor-mark\u0060。在本文用到了前两种，下面将分别为大家介绍。\n\n**\u0060--set-xmark value[\/mask]\u0060**\n\n上面的 \u0060value\u0060 和掩码 \u0060mask\u0060 都是 32 位无符号整数，一般用 16 进制表示。内核设置数据包 nfmark 值的流程分为两步：\n\n1. 首先，内核会先用 mask 预处理数据包原来的 nfmark，处理方法是：如果 mask 的第 N 位（二进制）为 1，则将数据包的 nfmark 第的 N 位（二进制）清零（Zero out） ，如果 mask 的第 N 位为 0，那么数据包的 nfmark 位保持不变\n2. 再用上面预处理后的 nfmark 和 value 做异或运算，得到数据包最后的 nfmark 值。\n\n举个例子：假设我们设置了 \u0060--set-xmark 0x4000\/0xffffffff\u0060，掩码为 \u00600xffffffff\u0060，掩码表示为二进制的话 32 位每一位都是 \u00601\u0060，那么内核首先会将数据包原来的 \u0060nfmark\u0060 所有的位都清零（异或运算，相当于是先把 \u0060nfmark\u0060 置 0），然后再和 value 做异或操作，那么得到的最后的 \u0060nfmark\u0060 值就是 \u00600x4000\u0060。所以，数据包经过这条规则后，它的 nfmark 值就是 \u00600x4000\u0060。\n\n上面的掩码 \u0060mask\u0060 是个可选项，如果没有设置的话，默认为 \u00600xffffffff\u0060。\n\n根据上面的规则，省略 \u0060mask\u0060 的值或者将 \u0060mask\u0060 和 \u0060value\u0060 的值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF XOR value =value\u0060，\u0060value XOR value XOR value = value\u0060。\n\n**\u0060--set-mark value[\/mask]\u0060**\n\n设置步骤与上文类似。第一步预处理也是将原来的 \u0060nfmark\u0060 与 mask 进行异或运算，第二步不同，该方法是将预处理的 nfmark 和 value 做或（OR）运算。\n\n根据上面的规则，省略 \u0060mask\u0060 的值，或者将 \u0060mask\u0060 与 \u0060value\u0060 值设置成一样可以快速设置数据包的 \u0060nfmark\u0060 值为 \u0060value\u0060。读者可以自己推导一下：\u0060value XOR 0xFFFFFFFF OR value = value\u0060，\u00600 OR value = value\u0060）。\n\n查看 [netfilter 文档](https:\/\/ipset.netfilter.org\/iptables-extensions.man.html#lbDD) 了解详情。\n\n{{\u003c\/callout\u003e}}\n\n通过执行以上 iptables 规则，可以确保 Ambient Mesh 仅拦截 \u0060ztunnel-pods-ips\u0060 IP 集 Pod 中的数据包并给数据包打上 \u00600x100\/0x100\u0060 标记（\u0060nfmark\u0060，格式为 \u0060值\/掩码\u0060，值和掩码都是 32 位的二进制整数，），而不影响其他 Pod。\n\n{{\u003ccallout note \u0022关于 ztunnel-pods-ips IP 集\u0022\u003e}}\n\n\u0060ztunnel-pods-ips\u0060 是由 Istio CNI 创建的 [IP 集（IP Set）](https:\/\/ipset.netfilter.org\/)，这里面保存着该节点上 Ambient Mesh 中的所有 Pod 的 IP 地址。IP 集是 Linux 内核中的一个框架，可由 [ipset](https:\/\/ipset.netfilter.org\/ipset.man.html) 实用程序管理。IP 集可以存储不同类型的数据，例如 IP 地址、网络、（TCP\/UDP）端口号、MAC 地址、接口名称或它们的组合，从而确保在条目与集合匹配时具有闪电般的速度。\n\n{{\u003c\/callout\u003e}}\n\n{{\u003cdetail \u0022用 \u0060iptables -t nat -L\u0060 按顺序查看 iptables 规则，将可以更明显的看到路由路径。\u0022\u003e}}\n\n\u0060\u0060\u0060bash\n$ iptables -t nat -L\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n# 数据包首先进入 ztunnel-PREROUTING 链处理\nztunnel-PREROUTING  all  --  anywhere             anywhere\n# 然后进入 KUBE-SERVICES 链处理\nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nKUBE-SERVICES  all  --  anywhere             anywhere             \/* kubernetes service portals *\/\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nztunnel-POSTROUTING  all  --  anywhere             anywhere            \nKUBE-POSTROUTING  all  --  anywhere             anywhere             \/* kubernetes postrouting rules *\/\nIP-MASQ    all  --  anywhere             anywhere             \/* ip-masq: ensure nat POSTROUTING directs all non-LOCAL destination traffic to our custom IP-MASQ chain *\/ ADDRTYPE match dst-type !LOCAL\n\n\/* Omit KUBE-SVC chains *\/\n\nChain ztunnel-POSTROUTING (1 references)\ntarget     prot opt source               destination         \nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\nChain ztunnel-PREROUTING (1 references)\ntarget     prot opt source               destination   \n# 通过所有被打上 0x100\/0x100 标记的数据包\nACCEPT     all  --  anywhere             anywhere             mark match 0x100\/0x100\n\u0060\u0060\u0060\n\n{{\u003c\/detail\u003e}}\n\n我们再查看一下该节点的路由规则：\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n路由表将按顺序执行，第一列表示的是路由表的优先级，第二列表示要查找或跳转的路由表。你会看到所有带有 \u00600x100\/0x100\u0060 标记的数据包将查找 101 路由表。我们再查看一下该路由表：\n\n\u0060\u0060\u0060bash\n$ ip route show table 101\ndefault via 192.168.127.2 dev istioout \n10.4.4.18 dev veth52b75946 scope link \n\u0060\u0060\u0060\n\n你会看到 \u0060101\u0060 路由表中带有关键字 \u0060via\u0060 ，这表示数据包将通过网关传输，查看 [ip route 命令的用法](http:\/\/linux-ip.net\/html\/tools-ip-route.html#tools-ip-route-show)。所有数据包被通过 \u0060istioout\u0060 网卡发送到网关（IP 是 \u0060192.168.127.2\u0060）。另一行表示是当前节点上 ztunnel pod 的路由链路。\n\n{{\u003ccallout note  \u0022关于 101 路由表\u0022\u003e}}\n所谓路由表（Routing Table），指的是路由器或者其他互联网网络设备上存储的表，该表中存有到达特定网络终端的路径。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。为了完成这项工作，在路由器中保存着各种传输路径的相关数据，供路由选择时使用，表中包含的信息决定了数据转发的策略。路由表根据其建立的方法，可以分为**动态路由表**和**静态路由表**。\n\n101 路由表是由 Istio CNI 创建的，它的作用是将带有 \u00600x100\/0x00\u0060 fwmark 的数据包转发到 ztunnel 中。\n\n在 Linux 系统中，用户可以自定义编号 1 到 252 的路由表，Linux 系统维护了 4 个路由表：\n\n- 0：系统保留表\n- 253：defulte 表，没特别指定的默认路由都放在改表\n- 254：main 表，没指明路由表的所有路由放在该表，默认表，我们使用 \u0060ip route list\u0060 或 \u0060route -n\u0060 或 \u0060netstat -rn\u0060 查看的路由记录即为 main 表中的记录\n- 255：locale 表，保存本地接口地址，广播地址、NAT 地址 由系统维护，用户不得更改\n\n{{\u003c\/callout\u003e}}\n\n我们再查看一下 \u0060istioout\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioout\n24: istioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 62:59:1b:ad:79:01 brd ff:ff:ff:ff:ff:ff\n    geneve id 1001 remote 10.4.4.18 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535\n    inet 192.168.127.1\/30 brd 192.168.127.3 scope global istioout\n       valid_lft forever preferred_lft forever\n    inet6 fe80::6059:1bff:fead:7901\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\nPod A 中的 \u0060istioout\u0060 网卡通过 Geneve tunnel 与 ztunnel A 中的 \u0060pstioout\u0060 网卡连通。\n\n{{\u003ccallout note \u0022关于 istioout 网卡\u0022\u003e}}\n\n\u0060istioout\u0060 是一个 [Geneve（Generic Network Virtualization Encapsulation）](https:\/\/datatracker.ietf.org\/doc\/html\/draft-gross-geneve-00)类型的虚拟网卡，它的 IP 是 \u0060192.168.127.1\u0060，远端是 \u006010.4.2.19\u0060（节点 A 上的 ztunnel Pod 的 IP），网关是 \u0060192.168.127.2\u0060（节点 A 上 ztunnel Pod 中 \u0060pistioout\u0060 网卡的 IP，在下文会看到）。\n\n{{\u003c\/callout\u003e}}\n\n### 检查 Ztunnel A 上的路由规则 {#ztunnel-a-rules}\n\n进入 Ztunnel A Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11-20\u0022\u003e}}\n$ ip -d a\n1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 minmtu 0 maxmtu 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 127.0.0.1\/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0@if16: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1460 qdisc noqueue state UP group default \n    link\/ether 06:3e:d1:5d:95:16 brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 minmtu 68 maxmtu 65535 \n    veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 10.4.2.1\/24 brd 10.4.4.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: pistioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether 06:18:ee:29:7e:e4 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.2\/30 scope global pistioin\n       valid_lft forever preferred_lft forever\n4: pistioout: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default qlen 1000\n    link\/ether aa:40:40:7c:07:b2 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1001 remote 10.4.2.1 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.127.2\/30 scope global pistioout\n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n你将发现其中有两个网卡：\n\n- \u0060pistioin\u0060 ：IP 为 \u0060192.168.126.2\u0060\n- \u0060pistioout\u0060：IP 为 \u0060192.168.127.2\u0060\n\n{{\u003ccallout note \u0022关于 pistioin 和 pistioout 网卡\u0022\u003e}}\n\n这两个网卡都是由 ztunnel 中的 init 容器创建的 Geneve 类型的虚拟网卡，其 IP 地址也是固定的，如果你查看 ztunnel 的 YAML 配置将发现其中的网卡创建命令，在此我们按下不表，因为 Ambient 模式还在开发初期，这些启动命令未来可能有很大变化，感兴趣的读者可以自行查阅。\n\n{{\u003c\/callout\u003e}}\n\n自 Pod A 的流量进入 ztunnel 之后，如何对流量进行处理呢？答案是 iptables，查看 ztunnel A 中的 iptables 规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=11\u0022\u003e}}\n$ iptables-save\n\/* 省略 *\/\n*mangle\n:PREROUTING ACCEPT [185880:96984381]\n:INPUT ACCEPT [185886:96984813]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [167491:24099839]\n:POSTROUTING ACCEPT [167491:24099839]\n-A PREROUTING -j LOG --log-prefix \u0022mangle pre [ ztunnel-rts54] \u0022\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioout -p tcp -j TPROXY --on-port 15001 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\/* 省略 *\/\n{{\u003c\/highlight\u003e}}\n\n可以看到 ztunnel A 中的所有发往 \u0060pistioin\u0060 网卡的 TCP 流量透明转发到 \u006015001\u0060 端口（Envoy 的 outbound 端口），并打上了 \u00600x400\/0xfff\u0060 的标记。这个标记可以保证数据包发往正确的网卡。\n\n{{\u003ccallout note \u0022关于 tproxy\u0022\u003e}}\n\n\u0060tproxy\u0060 是 Linux 内核自 2.2 版本以来支持的透明代理（Transparent proxy），其中的 t 代表 transparent，即透明。你需要在内核配置中启用 \u0060NETFILTER_TPROXY\u0060 和策略路由。通过 tproxy，Linux 内核就可以作为一个路由器，将数据包重定向到用户空间。详见 [tproxy 文档](http:\/\/lxr.linux.no\/linux\u002bv3.10\/Documentation\/networking\/tproxy.txt)。\n\n{{\u003c\/callout\u003e}}\n\n查看 Ztunnel A 中的路由表。\n\n\u0060\u0060\u0060bash\n$ ip rule\n0:      from all lookup local\n20000:  from all fwmark 0x400\/0xfff lookup 100\n20001:  from all fwmark 0x401\/0xfff lookup 101\n20002:  from all fwmark 0x402\/0xfff lookup 102\n20003:  from all fwmark 0x4d3\/0xfff lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n你会看到所有标记 \u00600x400\/0xfff\u0060 的数据包应用 101 路由表，我们查看该路由表详情：\n\n\u0060\u0060\u0060bash\n$ ip route show table 100\nlocal default dev lo scope host \n\u0060\u0060\u0060\n\n你会看到这是一条本地路由，数据包发送到本地的回环网卡，即 \u0060127.0.0.1\u0060。\n\n以上就是 Pod 中出站流量的透明劫持过程。\n\n## Ztunnel A 上的出站流量路由 {#ztunnel-a-outbound}\n\n出站流量在被劫持到 Ztunnel 上，进入 Envoy 的 15001 端口处理。下面我们来查看 Ztunnel 如何路由出站流量。\n\n注意：Ztunnel 中的 Envoy 过滤器规则与 Sidecar 模式中的 Envoy 过滤器规则完全不同，我们不使用 \u0060istioctl proxy-config\u0060 命令来检视 Listener、Cluster、Endpoint 等配置，而是直接导出 ztunnel 中的 Envoy 完整配置。 \n\n我们直接在自己的本地机器上远程获取 ztunnel A 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system ztunnel-hptxk -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-a-all-include-eds.json\n\u0060\u0060\u0060\n\n注意：不要使用 \u0060istioctl proxy-config all ztunnel-rts54 -n istio-system\u0060 命令来获取 Envoy 配置，因为这样获取的配置中不包含 EDS 部分。导出的 Json 文件将有上万行，为了便于阅读，建议使用 [fx](https:\/\/github.com\/antonmedv\/fx) 或其他工具来解析该文件。\n\n### ztunnel_outbound 监听器 {#ztunnel_outbound-listener}\n\n在这个 Envoy 配置中包含了该节点上的所有 Pod 访问的流量规则配置，查看 \u0060ztunnel_outbound\u0060 Listener 部分配置（因配置太多，省略部分内容）：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 14 43 59 62 64 69 76 82 85 88-123\u0022\u003e}}\n{\n \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_outbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15001\n    }\n   },\n   \u0022filter_chains\u0022: [{...},...],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_dst\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_dst.v3.OriginalDst\u0022\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.original_src\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.listener.original_src.v3.OriginalSrc\u0022,\n      \u0022mark\u0022: 1234\n     }\n    },\n    {\n     \u0022name\u0022: \u0022envoy.filters.listener.workload_metadata\u0022,\n     \u0022config_discovery\u0022: {\n      \u0022config_source\u0022: {\n       \u0022ads\u0022: {},\n       \u0022initial_fetch_timeout\u0022: \u002230s\u0022\n      },\n      \u0022type_urls\u0022: [\n       \u0022type.googleapis.com\/istio.telemetry.workloadmetadata.v1.WorkloadMetadataResources\u0022\n      ]\n     }\n    }\n   ],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [\n    {\n     \u0022description\u0022: \u0022Set socket mark to packets coming back from outbound listener\u0022,\n     \u0022level\u0022: \u00221\u0022,\n     \u0022name\u0022: \u002236\u0022,\n     \u0022int_value\u0022: \u00221025\u0022\n    }\n   ],\n   \u0022access_log\u0022: [{...}],\n   \u0022default_filter_chain\u0022: {\u0022filters\u0022: [...], ...},\n   \u0022filter_chain_matcher\u0022: {\n    \u0022matcher_tree\u0022: {\n     \u0022input\u0022: {\n      \u0022name\u0022: \u0022port\u0022,\n      \u0022typed_config\u0022: {\n       \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n      }\n     },\n     \u0022exact_match_map\u0022: {\n      \u0022map\u0022: {\n       \u002215001\u0022: {\n        \u0022action\u0022: {\n         \u0022name\u0022: \u0022BlackHoleCluster\u0022,\n         \u0022typed_config\u0022: {\n          \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n          \u0022value\u0022: \u0022BlackHoleCluster\u0022\n         }\n        }\n       }\n      }\n     }\n    },\n    \u0022on_no_match\u0022: {\n     \u0022matcher\u0022: {\n      \u0022matcher_tree\u0022: {\n       \u0022input\u0022: {\n        \u0022name\u0022: \u0022source-ip\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.SourceIPInput\u0022\n        }\n       },\n       \u0022exact_match_map\u0022: {\n        \u0022map\u0022: {\n         \u002210.168.15.222\u0022: {...},\n         \u002210.4.4.19\u0022: {\n          \u0022matcher\u0022: {\n           \u0022matcher_tree\u0022: {\n            \u0022input\u0022: {\n             \u0022name\u0022: \u0022ip\u0022,\n             \u0022typed_config\u0022: {\n              \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput\u0022\n             }\n            },\n            \u0022exact_match_map\u0022: {\n             \u0022map\u0022: {\n              \u002210.8.4.226\u0022: {\n               \u0022matcher\u0022: {\n                \u0022matcher_tree\u0022: {\n                 \u0022input\u0022: {\n                  \u0022name\u0022: \u0022port\u0022,\n                  \u0022typed_config\u0022: {\n                   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput\u0022\n                  }\n                 },\n                 \u0022exact_match_map\u0022: {\n                  \u0022map\u0022: {\n                   \u00229080\u0022: {\n                    \u0022action\u0022: {\n                     \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n                     \u0022typed_config\u0022: {\n                      \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n                      \u0022value\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022\n                     }\n                    }\n                   }\n                  }\n                 }\n                }\n               }\n              },\n              {...}\n             }\n            }\n           }\n          }\n         },\n         \u002210.4.4.7\u0022: {...},\n         \u002210.4.4.11\u0022: {...},\n        }\n       }\n      },\n      \u0022on_no_match\u0022: {\n       \u0022action\u0022: {\n        \u0022name\u0022: \u0022PassthroughFilterChain\u0022,\n        \u0022typed_config\u0022: {\n         \u0022@type\u0022: \u0022type.googleapis.com\/google.protobuf.StringValue\u0022,\n         \u0022value\u0022: \u0022PassthroughFilterChain\u0022\n        }\n       }\n      }\n     }\n    }\n   }\n  },\n  \u0022last_updated\u0022: \u00222022-11-11T07:33:10.485Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n- 第 10、11、59、62、64、69、76、82、85 行：Envoy 监听 15001 端口，处理内核中使用 tproxy 转发的流量；对于目的地是 15001 端口的数据包直接抛弃，对于目的地是其他端口的流量再根据源 IP 地址匹配决定数据包去向；\n- 第 43 行：使用 \u0060IP_TRANSPARENT\u0060 套接字选项，开启 tproxy 透明代理，转发目的地非 ztunnel IP 的流量包；\n-  第 88 到 123 行：根据源 IP（\u006010.4.4.19\u0060 是 Pod A 的 IP）、目的 IP（\u006010.8.14.226\u0060 是服务 B 的 Cluster IP）和端口（9080）规则匹配，数据包将被发往 \u0060spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0060 集群。\n\n### Sleep 集群\n\n我们再查看一下该集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=5 6 18 23-37\u0022\u003e}}\n{\n \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022type\u0022: \u0022EDS\u0022,\n  \u0022eds_cluster_config\u0022: {\n   \u0022eds_config\u0022: {\n    \u0022ads\u0022: {},\n    \u0022initial_fetch_timeout\u0022: \u00220s\u0022,\n    \u0022resource_api_version\u0022: \u0022V3\u0022\n   }\n  },\n  \u0022transport_socket_matches\u0022: [\n   {\n    \u0022name\u0022: \u0022internal_upstream\u0022,\n    \u0022match\u0022: {\n     \u0022tunnel\u0022: \u0022h2\u0022\n    },\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.internal_upstream\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport\u0022,\n      \u0022passthrough_metadata\u0022: [\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022tunnel\u0022\n       },\n       {\n        \u0022kind\u0022: {\n         \u0022host\u0022: {}\n        },\n        \u0022name\u0022: \u0022istio\u0022\n       }\n      ],\n      \u0022transport_socket\u0022: {\n       \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n       }\n      }\n     }\n    }\n   },\n   {\n    \u0022name\u0022: \u0022tlsMode-disabled\u0022,\n    \u0022match\u0022: {},\n    \u0022transport_socket\u0022: {\n     \u0022name\u0022: \u0022envoy.transport_sockets.raw_buffer\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.raw_buffer.v3.RawBuffer\u0022\n     }\n    }\n   }\n  ]\n },\n \u0022last_updated\u0022: \u00222022-11-08T06:40:06.619Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该 Cluster 配置使用 EDS 获取端点\n- 第 18 行：对所有具有 \u0060tunnel: h2\u0060 元数据的字节流应用 [\u0060InternalUpstreamTransport\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/transport_sockets\/internal_upstream\/v3\/internal_upstream.proto#envoy-v3-api-msg-extensions-transport-sockets-internal-upstream-v3-internalupstreamtransport)，用于内部地址，定义位于同一代理实例中的环回用户空间 socket。除了常规字节流之外，该扩展还允许跨用户空间 socket 传递额外的结构化状态（\u0060passthrough_metadata\u0060）。目的是促进下游过滤器和上游内部连接之间的通信。与上游连接共享的所有过滤器状态对象也通过此传输 socket 与下游内部连接共享。\n- 第 23 到 37 行：向上游传递的结构化数据；\n\n### Sleep 集群的端点 {#sleep-endpoints}\n\n我们再检查下 EDS，你会发现在众多的 \u0060endpoint_config\u0060 中有这样一条：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=4 13 20-30\u0022\u003e}}\n{\n \u0022endpoint_config\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.endpoint.v3.ClusterLoadAssignment\u0022,\n  \u0022cluster_name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep_to_http_productpage.default.svc.cluster.local_outbound_internal\u0022,\n  \u0022endpoints\u0022: [\n   {\n    \u0022locality\u0022: {},\n    \u0022lb_endpoints\u0022: [\n     {\n      \u0022endpoint\u0022: {\n       \u0022address\u0022: {\n        \u0022envoy_internal_address\u0022: {\n         \u0022server_listener_name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n         \u0022endpoint_id\u0022: \u002210.4.3.20:9080\u0022\n        }\n       },\n       \u0022health_check_config\u0022: {}\n      },\n      \u0022health_status\u0022: \u0022HEALTHY\u0022,\n      \u0022metadata\u0022: {\n       \u0022filter_metadata\u0022: {\n        \u0022envoy.transport_socket_match\u0022: {\n         \u0022tunnel\u0022: \u0022h2\u0022\n        },\n        \u0022tunnel\u0022: {\n         \u0022address\u0022: \u002210.4.3.20:15008\u0022,\n         \u0022destination\u0022: \u002210.4.3.20:9080\u0022\n        }\n       }\n      },\n      \u0022load_balancing_weight\u0022: 1\n     }\n    ]\n   }\n  ],\n  \u0022policy\u0022: {\n   \u0022overprovisioning_factor\u0022: 140\n  }\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 4 行：截止 2022 年 11 月 14 日，实际在导出 Envoy 配置的时候并没有该字段，但是理应有这个字段，否则无法判断 Endpoint 属于哪个 Cluster；\n- 第 13 行：该端点的地址是一个 \u0060envoy_internal_address\u0060，Envoy 内部监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060；\n- 第 20 - 30 行：定义过滤器元数据，使用 HBONE 隧道传递给 Envoy 内部监听器；\n\n{{\u003ccallout warning \u0022关于 endpoint_config 中未显示 cluster_name 字段的问题\u0022\u003e}}\n\n这里的 [\u0060endpoint_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/endpoint\/v3\/endpoint.proto) 中缺少了必选的 \u0060cluster_name\u0060 字段，这可能是 Ambient 模式的一个 bug 导致了在导出 Envoy 的配置时缺少了该字段。我在 GItHub 上创建了一个 Issue 来追踪这个问题，详见 [Istio Issue-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)。\n\n{{\u003c\/callout\u003e}}\n\n### 通过 Envoy 内部监听器建立 HBONE 隧道 {#sleep-internal-upstream}\n\n我们再看下这个监听器 \u0060outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=16 18-28 40\u0022\u003e}}\n{\n \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-08T06:40:06Z\/63\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.tcp_proxy\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\u0022,\n        \u0022stat_prefix\u0022: \u0022outbound_tunnel_lis_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022cluster\u0022: \u0022outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n        \u0022access_log\u0022: [{...}, ...],\n        \u0022tunneling_config\u0022: {\n         \u0022hostname\u0022: \u0022%DYNAMIC_METADATA(tunnel:destination)%\u0022,\n         \u0022headers_to_add\u0022: [\n          {\n           \u0022header\u0022: {\n            \u0022key\u0022: \u0022x-envoy-original-dst-host\u0022,\n            \u0022value\u0022: \u0022%DYNAMIC_METADATA([\\\u0022tunnel\\\u0022, \\\u0022destination\\\u0022])%\u0022\n           }\n          }\n         ]\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \u0022use_original_dst\u0022: false,\n   \u0022listener_filters\u0022: [\n    {\n     \u0022name\u0022: \u0022set_dst_address\u0022,\n     \u0022typed_config\u0022: {\n      \u0022@type\u0022: \u0022type.googleapis.com\/xds.type.v3.TypedStruct\u0022,\n      \u0022type_url\u0022: \u0022type.googleapis.com\/istio.set_internal_dst_address.v1.Config\u0022,\n      \u0022value\u0022: {}\n     }\n    }\n   ],\n   \u0022internal_listener\u0022: {}\n  },\n  \u0022last_updated\u0022: \u00222022-11-08T06:40:06.750Z\u0022\n }\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 14 行：数据包将被转发到 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群；\n- 第 18 - 28 行： [\u0060tunneling_config\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/filters\/network\/tcp_proxy\/v3\/tcp_proxy.proto#envoy-v3-api-msg-extensions-filters-network-tcp-proxy-v3-tcpproxy-tunnelingconfig) ，用来配置上游 HTTP CONNECT 隧道。另外该监听器中的 \u0060TcpProxy\u0060 过滤器将流量传给上游 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群。TCP 过滤器上设置了 HTTP CONNECT 隧道（承载发送到 \u006010.4.3.20:9080\u0060 的流量），供 \u0060productpage\u0060 所在节点的 ztunnel 使用。有多少个端点，就会创建多少条隧道。HTTP 隧道是 Ambient 组件之间安全通信的承载协议。同时在隧道中的数据包添加了 \u0060x-envoy-original-dst-host\u0060 header，根据上一步 EDS 中选择的端点的 \u0060metadata\u0060 里的参数设置目的地址。前面 EDS  选择的端点是 \u006010.4.3.20:9080\u0060 ，那么这里的 tunnel 监听器就会 header 的值设置为 \u006010.4.3.20:9080\u0060，请留意这个 header，它会在隧道的另一端被用到；\n- 第 40 行：监听器中首先执行监听器过滤器，\u0060set_dst_address\u0060 过滤器将上游地址设置为下游的目的地址。\n\n{{\u003ccallout note \u0022关于 HBONE 隧道\u0022\u003e}}\n\nHBONE 是 HTTP-Based Overlay Network Environment 的缩写，是一种使用 HTTP 协议提供隧道能力的方法。客户端向 HTTP 代理服务器发送 HTTP CONNECT 请求（其中包含了目的地址）以建立隧道，代理服务器代表客户端与目的地建立 TCP 连接，然后客户端就可以通过代理服务器透明的传输 TCP 数据流到目的服务器。在 Ambient 模式中，Ztunnel（其中的 Envoy）实际上是充当了透明代理，它使用 [Envoy Internal Listener](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/other_features\/internal_listener) 来接收 HTTP CONNECT 请求和传递 TCP 流给上游集群。\n\n{{\u003c\/callout\u003e}}\n\n### Sleep 集群的 HBONE 隧道端点 {#sleep-tunnel-cluster}\n\n我们再查看一下 \u0060outbound_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0060 集群的配置：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=6 22-41 45-47\u0022\u003e}}\n {\n \u0022version_info\u0022: \u00222022-11-11T07:30:10Z\/37\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022outbound_pod_tunnel_clus_spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022connect_timeout\u0022: \u00222s\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022cleanup_interval\u0022: \u002260s\u0022,\n  \u0022transport_socket\u0022: {\n   \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n   \u0022typed_config\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\u0022,\n    \u0022common_tls_context\u0022: {\n     \u0022tls_params\u0022: {\n      \u0022tls_minimum_protocol_version\u0022: \u0022TLSv1_3\u0022,\n      \u0022tls_maximum_protocol_version\u0022: \u0022TLSv1_3\u0022\n     },\n     \u0022alpn_protocols\u0022: [\n      \u0022h2\u0022\n     ],\n     \u0022tls_certificate_sds_secret_configs\u0022: [\n      {\n       \u0022name\u0022: \u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/sleep~sleep-5644bdc767-2dfg7~85c8c34e-7ae3-4d29-9582-0819e2b10c69\u0022,\n       \u0022sds_config\u0022: {\n        \u0022api_config_source\u0022: {\n         \u0022api_type\u0022: \u0022GRPC\u0022,\n         \u0022grpc_services\u0022: [\n          {\n           \u0022envoy_grpc\u0022: {\n            \u0022cluster_name\u0022: \u0022sds-grpc\u0022\n           }\n          }\n         ],\n         \u0022set_node_on_first_message_only\u0022: true,\n         \u0022transport_api_version\u0022: \u0022V3\u0022\n        },\n        \u0022resource_api_version\u0022: \u0022V3\u0022\n       }\n      }\n     ]\n    }\n   }\n  },\n  \u0022original_dst_lb_config\u0022: {\n   \u0022upstream_port_override\u0022: 15008\n  },\n  \u0022typed_extension_protocol_options\u0022: {\n   \u0022envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022: {\n    \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\u0022,\n    \u0022explicit_http_config\u0022: {\n     \u0022http2_protocol_options\u0022: {\n      \u0022allow_connect\u0022: true\n     }\n    }\n   }\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:30:10.754Z\u0022\n}\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 6 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，即前文中 EDS 获取到的地址 \u006010.4.3.20:9080\u0060；\n- 第 22 - 41 行：配置了上游的 TLS 证书；\n- 第 45 - 48 行：将上游端口修改为 15008；\n\n以上就是使用 tproxy 和 HBONE 隧道实现的出站流量透明劫持的全过程。\n\n## Inbound 流量劫持 {#inbound}\n\n节点 B 接收节点 A 对 \u006010.4.3.20:15008\u0060 的请求。Ambient 模式的入站流量劫持与出站流量类似，同样使用 tproxy 和 HBONE 实现透明流量劫持。\n\nAmbient mesh 的 pod 入站流量的透明流量劫持流程如下：\n\n1. Istio CNI 在节点上创建 \u0060istioin\u0060 网卡和 iptables 规则，将 Ambient mesh 中的 Pod IP 加入 IP 集，并通过 netfilter \u0060nfmark\u0060 标记和路由规则，将 Ambient mesh 中的出站流量通过 Geneve 隧道透明劫持到 \u0060pistioin\u0060 虚拟机网卡；\n2. ztunnel 中的 init 容器创建 iptables 规则，将 \u0060pistioin\u0060 网卡中的所有流量转发到 ztunnel 中的 Envoy 代理的 15008 端口；\n3. Envoy 对数据包进行处理后转发给 Pod B。\n\n因为操作步骤与上文中的检查出站流量时相同，因此下文将省略部分输出。\n\n### 检查节点 B 上的路由规则 {#node-b-rules}\n\n登录到服务 B 所在的节点 B，查看节点上的 iptables：\n\n\u0060\u0060\u0060bash\n$ iptables-save\n\/* 省略 *\/\n-A ztunnel-PREROUTING -m mark --mark 0x200\/0x200 -j RETURN\n-A ztunnel-PREROUTING -p tcp -m set --match-set ztunnel-pods-ips src -j MARK --set-xmark 0x100\/0x100\n\/* 省略 *\/\n\u0060\u0060\u0060\n\n你将看到在前文中提到的给所有 \u0060ztunnel-pods-ips\u0060 IP 集中 Pod 发送的数据包打上 \u00600x100\/0x100\u0060 标记的上一条命令：给所有数据包打上 \u00600x200\/0x200\u0060 标记，然后继续执行 iptables。\n\n查看节点 B 上的路由表：\n\n\u0060\u0060\u0060bash\n0:      from all lookup local\n100:    from all fwmark 0x200\/0x200 goto 32766\n101:    from all fwmark 0x100\/0x100 lookup 101\n102:    from all fwmark 0x40\/0x40 lookup 102\n103:    from all lookup 100\n32766:  from all lookup main\n32767:  from all lookup default\n\u0060\u0060\u0060\n\n所有 Ambient Mesh 节点中的路由表数量和规则是一样的，路由表规则将按顺序执行，首先查找 \u0060local\u0060 表，然后所有带有 \u00600x200\/0x200\u0060 标记的数据包将首先跳转到 \u0060main\u0060 表（其中定义了 veth 路由），然后查找 \u0060100\u0060 表，在 \u0060100\u0060 表中有以下规则：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=8\u0022\u003e}}\n$ ip route show table 100\n10.4.3.14 dev veth28865c45 scope link \n10.4.3.15 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.16 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.17 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.18 via 192.168.126.2 dev istioin src 10.4.3. \n10.4.3.19 via 192.168.126.2 dev istioin src 10.4.3.1\n10.4.3.20 via 192.168.126.2 dev istioin src 10.4.3.1\n{{\u003c\/highlight\u003e}}\n\n你会看到发往 \u006010.4.3.20\u0060 的数据包将被路由到 \u0060istioin\u0060 网卡上的 \u0060192.168.126.2\u0060 网关。\n\n查看 \u0060istioin\u0060 网卡的详细信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=4 5\u0022\u003e}}\n$ ip -d addr show istioin \n17: istioin: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1410 qdisc noqueue state UNKNOWN group default \n    link\/ether 36:2a:2f:f1:5c:97 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65485 \n    geneve id 1000 remote 10.4.3.14 ttl auto dstport 6081 noudpcsum udp6zerocsumrx numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 \n    inet 192.168.126.1\/30 brd 192.168.126.3 scope global istioin\n       valid_lft forever preferred_lft forever\n    inet6 fe80::342a:2fff:fef1:5c97\/64 scope link \n       valid_lft forever preferred_lft forever\n{{\u003c\/highlight\u003e}}\n\n从输出中可以看到，\u0060istioin\u0060 是一个 Geneve 类型虚拟网卡，它创建了一个 Geneve 隧道，远端的 IP 是 \u006010.4.3.14 \u0060，这是 Ztunnel B 的 Pod IP。\n\n### 检查 Ztunnel B Pod 上的路由规则 {#ztunnel-b-rules}\n\n进入 Ztunnel B Pod，使用 \u0060ip -d a\u0060 命令检查它的网卡信息，你会看到有一个 \u0060pistioout\u0060 网卡，它的 IP 为 \u0060192.168.127.2\u0060，这正是与 \u0060istioout\u0060 虚拟网卡建立的 Geneve 隧道的远端。\n\n使用 \u0060iptables-save\u0060 查看 Pod 内的 iptables 规则，你会看到：\n\n\u0060\u0060\u0060bash\n-A PREROUTING -i pistioin -p tcp -m tcp --dport 15008 -j TPROXY --on-port 15008 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n-A PREROUTING -i pistioin -p tcp -j TPROXY --on-port 15006 --on-ip 127.0.0.1 --tproxy-mark 0x400\/0xfff\n\u0060\u0060\u0060\n\n所有发往 \u006010.4.3.20:15008\u0060 的流量将使用 tproxy 被路由到 15008 端口。\n\n{{\u003ccallout note \u0022关于 15006 和 15008 端口\u0022\u003e}}\n\n- 15006 端口用于处理非加密的（plain）TCP 数据包。\n- 15008 端口用于处理加密的（TLS）TCP 数据包。\n\n{{\u003c\/callout\u003e}}\n\n以上就是 Pod 中入站流量的透明劫持过程。\n\n## Ztunnel B 上的入站流量路由 {#ztunnel-b-inbound}\n\n出站的 TLS 加密流量在被劫持到 Ztunnel 上，进入 Envoy 的 15008 端口处理。下面我们来查看 Ztunnel 如何路由入站流量。\n\n我们直接在自己的本地机器上远程获取 ztunnel B 中的 Envoy 配置：\n\n\u0060\u0060\u0060bash\nkubectl exec -n istio-system \tztunnel-z4qmh -c istio-proxy -- curl \u0022127.0.0.1:15000\/config_dump?include_eds\u0022\u003eztunnel-b-all-include-eds.json\n\u0060\u0060\u0060\n\n### ztunnel_inbound 监听器 {#ztunnel_inbound-listener}\n\n查看 \u0060ztunnel_inbound\u0060 监听器的详细信息：\n\n{{\u003chighlight json \u0022linenos=table,hl_lines=7 10 11 17-22 39-65 78-82\u0022\u003e}}\n\n{\n \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n \u0022active_state\u0022: {\n  \u0022version_info\u0022: \u00222022-11-11T07:12:01Z\/16\u0022,\n  \u0022listener\u0022: {\n   \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.listener.v3.Listener\u0022,\n   \u0022name\u0022: \u0022ztunnel_inbound\u0022,\n   \u0022address\u0022: {\n    \u0022socket_address\u0022: {\n     \u0022address\u0022: \u00220.0.0.0\u0022,\n     \u0022port_value\u0022: 15008\n    }\n   },\n   \u0022filter_chains\u0022: [\n    {\n     \u0022filter_chain_match\u0022: {\n      \u0022prefix_ranges\u0022: [\n       {\n        \u0022address_prefix\u0022: \u002210.4.3.20\u0022,\n        \u0022prefix_len\u0022: 32\n       }\n      ]\n     },\n     \u0022filters\u0022: [\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.rbac\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.rbac.v3.RBAC\u0022,\n        \u0022rules\u0022: {...},\n        \u0022stat_prefix\u0022: \u0022tcp.\u0022,\n        \u0022shadow_rules_stat_prefix\u0022: \u0022istio_dry_run_allow_\u0022\n       }\n      },\n      {\n       \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n       \u0022typed_config\u0022: {\n        \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n        \u0022stat_prefix\u0022: \u0022inbound_hcm\u0022,\n        \u0022route_config\u0022: {\n         \u0022name\u0022: \u0022local_route\u0022,\n         \u0022virtual_hosts\u0022: [\n          {\n           \u0022name\u0022: \u0022local_service\u0022,\n           \u0022domains\u0022: [\n            \u0022*\u0022\n           ],\n           \u0022routes\u0022: [\n            {\n             \u0022match\u0022: {\n              \u0022connect_matcher\u0022: {}\n             },\n             \u0022route\u0022: {\n              \u0022cluster\u0022: \u0022virtual_inbound\u0022,\n              \u0022upgrade_configs\u0022: [\n               {\n                \u0022upgrade_type\u0022: \u0022CONNECT\u0022,\n                \u0022connect_config\u0022: {}\n               }\n              ]\n             }\n            }\n           ]\n          }\n         ]\n        },\n        \u0022http_filters\u0022: [\n         {\n          \u0022name\u0022: \u0022envoy.filters.http.router\u0022,\n          \u0022typed_config\u0022: {\n           \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.http.router.v3.Router\u0022\n          }\n         }\n        ],\n        \u0022http2_protocol_options\u0022: {\n         \u0022allow_connect\u0022: true\n        },\n        \u0022access_log\u0022: [{...}],\n        \u0022upgrade_configs\u0022: [\n         {\n          \u0022upgrade_type\u0022: \u0022CONNECT\u0022\n         }\n        ]\n       }\n      }\n     ],\n     \u0022transport_socket\u0022: {\n      \u0022name\u0022: \u0022envoy.transport_sockets.tls\u0022,\n      \u0022typed_config\u0022: {...} \n     },\n     \u0022name\u0022: \u0022inbound_10.4.3.20\u0022\n    },\n    {...}\n   ],\n   \u0022use_original_dst\u0022: true,\n   \u0022listener_filters\u0022: [{},...],\n   \u0022transparent\u0022: true,\n   \u0022socket_options\u0022: [{...}}],\n   \u0022access_log\u0022: [{...} ]\n  },\n  \u0022last_updated\u0022: \u00222022-11-14T03:54:07.040Z\u0022\n }\n}\n\n{{\u003c\/highlight\u003e}}\n\n从上面的配置中可以看出：\n\n- 发往 \u006010.4.3.20\u0060 的流量将被路由到 \u0060virtual_inbound\u0060 集群；\n- 第 78 - 82 行：[\u0060upgrade_type: \u0022CONNECT\u0022\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/route\/v3\/route_components.proto#config-route-v3-routeaction-upgradeconfig) 为 Envoy 的 HCM 启用 HTTP Connect 隧道，将该隧道中的 TCP 数据发送到上游；\n\n### virtual_inbound 集群 {#virtual_inbound-cluster}\n\n查看 \u0060virtual_inbound\u0060 集群的信息：\n\n{{\u003chighlight bash \u0022linenos=table,hl_lines=6 9\u0022\u003e}}\n\n{\n \u0022version_info\u0022: \u00222022-11-11T07:10:40Z\/13\u0022,\n \u0022cluster\u0022: {\n  \u0022@type\u0022: \u0022type.googleapis.com\/envoy.config.cluster.v3.Cluster\u0022,\n  \u0022name\u0022: \u0022virtual_inbound\u0022,\n  \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n  \u0022lb_policy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n  \u0022original_dst_lb_config\u0022: {\n   \u0022use_http_header\u0022: true\n  }\n },\n \u0022last_updated\u0022: \u00222022-11-11T07:10:42.111Z\u0022\n}\n\n{{\u003c\/highlight\u003e}}\n\n说明：\n\n- 第 7 行：该集群的类型是 \u0060ORIGINAL_DST\u0060，表示使用下游的原始目的地作为路由目的地，即 \u006010.4.3.20:15008\u0060，显然这个地址中的端口不正确；\n- 第 9 行：[\u0060use_http_header\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/cluster\/v3\/cluster.proto#config-cluster-v3-cluster-originaldstlbconfig) 为 \u0060true\u0060 时将使用 HTTP header [\u0060x-envoy-original-dst-host\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers#config-http-conn-man-headers-x-envoy-original-dst-host) 作为目的地址，而这个 header [在出站的 Ztunnel 中已设置](\/#sleep-internal-upstream)为 \u006010.4.3.20:9080\u0060，它将覆盖之前设置的目的地址；\n\n至此，入站流量被 ztunnel 准确地路由到了目的地。以上就是 Ambient 模式中不同节点间 L4 流量劫持和路由流程。\n\n## 总结 {#summary}\n\n为了方便演示，本文中展示的是不同节点上的服务 L4 网络访问数据包的路径，即使两个服务在同一个节点上路径也是类似的。根据本文中提供的操作说明，读者可以在自己的环境中尝试。Istio 的 Ambient 模式还在初级阶段，在笔者测试过程中，也发现导出的 Envoy 配置中 EDS 缺少 \u0060cluster_name\u0060 字段的问题（[Issue Istio-42022](https:\/\/github.com\/istio\/istio\/issues\/42022)）。另外 Ambient 模式使用 Istio CNI 在节点中注入 iptables 规则，通过设置 \u0060nfmark\u0060 的方式拦截 Pod 的流量到 Ztunnel 中，这种方式可能造成对其他 CNI 的兼容性问题，[Merbridge](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/) 项目正在寻求使用 eBPF 来绕过 IPtables，从而无需安装 Istio CNI，这样也就不会存在 CNI 兼容性问题。\n\n在了解了 L4 流量路径之后，今后笔者会再分享 Ambient 模式中的 L7 流量路径，欢迎关注。\n\n## 参考{#reference}\n\n- [安装 Ambient Mesh - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/get-started-ambient\/)\n- [深入 Ambient Mesh - 流量路径 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/PpP0pmxdJR8PknHeR-pVHQ)\n- [一文读懂 Ambient Mesh 七层服务治理 - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/TXMyxbzBSfuYNquOZJmZTg)\n- [深度剖析！Istio 共享代理新模式 Ambient Mesh - mp.weixin.qq.com](https:\/\/mp.weixin.qq.com\/s\/B0q73ACAvmY4SjW42A2GVw)\n- [Istio Ambient 模式流量管理实现机制详解（一）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-1\/)\n- [Istio Ambient 模式流量管理实现机制详解（二） - zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-09-11-ambient-deep-dive-2\/)\n- [Istio Ambient 模式流量管理实现机制详解（三）- zhaohuabing.com](https:\/\/www.zhaohuabing.com\/post\/2022-10-17-ambient-deep-dive-3\/)\n- [Merbridge 支持 Ambient Mesh，无惧 CNI 兼容性！- merbridge.io](https:\/\/merbridge.io\/zh\/blog\/2022\/11\/11\/ambient-mesh-support\/)\n', '\/blog\/ambient-mesh-l4-traffic-path\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文以图示和实际操作的形式详细介绍了 Ambient Mesh 中的透明流量劫持和四层（L4）流量路径。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/istio-ambient-mesh-introduction/">[译] 全面解析 Istio 新型部署模式：环境模式</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/10/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/ambient-mesh-what-you-need-to-know-about-this-experimental-new-deployment-model-for-istio/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('全面解析 Istio 新型部署模式：环境模式', '本文详细介绍了 Istio 的新型部署模式——环境模式（Ambient Mesh），这是一种实验性的无 sidecar 部署模式，旨在提高服务网格的性能和可靠性。', '\nIstio [最近宣布了“环境模式”](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)——一种实验性的、无 sidecar 的部署模式。我们最近在[如何从服务网格中获得最大性能和弹性](https:\/\/tetrate.io\/blog\/ebpf-and-sidecars-getting-the-most-performance-and-resiliency-out-of-the-service-mesh\/)的背景下讨论了 sidecar 与无 sidecar。在本文中，我们将特别介绍环境模式。\n\n## 什么是环境模式？\n\n环境模式是 Istio 最近引入的一种新的实验性部署模式。它将原本由 Envoy sidecar 执行的职责分解为两个独立的组件：一个节点级的加密组件（称为“ztunnel”）和一个每个服务部署的 L7 Envoy 实例，用于处理所有其他的流程（称为“waypoint”）。环境模式模型试图在生命周期和资源管理上获得一些效率提升——至少，这是其动机。\n\n## 为什么应该关心环境模式？\n\n对于大多数服务网格用户来说，Istio 数据平面的确切部署模式可能不是你需要过多考虑的问题。默认设置可能就足够好。对于*一些*服务网格用户，特别是那些有大量横向扩展且服务数量少的用户——在这种情况下，waypoint 架构最能获得效率提升——环境模式模式随着其成熟为生产就绪的基础设施软件，将会变得有用。\n\n## 简要总结\n\n- 环境模式部署模式相较于 sidecar 模式在生命周期管理、资源利用、故障排除和安全姿态方面做了一些权衡。两者并没有明显的优劣。\n- 环境模式是一项实验，最早将在 2023 年前成为生产就绪——即，**现在还不能在生产中使用**。当前的性能更差，功能不那么丰富，广泛使用的技术如 CNI 行为不明确。然而，我们预计随着实现的加固，这种情况将在未来几个月迅速改善。\n- 你关心的许多网格功能——如每次请求的流量管理和安全控制、分布式跟踪和应用级 RED 指标——都在 L7 层发生。目前尚不清楚仅 L4 部分的环境模式的适用范围有多广，以及分解这些数据平面职责将在多大程度上帮助推动网格的采用。\n\n本文的其余部分是我们对环境模型与 Istio 现有的 sidecar 部署模型的权衡，以及哪一个可能更适合你以及何时使用。\n\n## Istio 中的 L4 和 L7 处理是如何工作的？\n\n由于环境模式将 L4 和 L7 处理分开，了解每一层中发生的网格行为是很重要的：\n\n|                                  | **L4**                                                       | **L7**                                                       |\n| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **安全性**                       |                                                              |                                                              |\n| 服务对服务认证                   | [SPIFFE](https:\/\/spiffe.io\/), 通过 mTLS 证书。Istio 发行一个编码了 pod 服务账户身份的短期 X.509 证书。 | N\/A—服务身份在 Istio 中基于 TLS。                            |\n| 服务对服务授权                   | 基于网络的授权，加上基于身份的策略，例如：*A* 只能接受来自“10.2.0.0\/16”的入站调用；*A* 可以调用 *B*。 | 完整策略，例如：*A* 只能在拥有有效的终端用户凭据且包含 READ 范围时，从 *B* 获取 \/foo。 |\n| 终端用户认证                     | N\/A—我们无法应用每个用户的设置。                             | 本地认证 JWT，支持通过 OAuth 和 OIDC 流程的远程认证。        |\n| 终端用户授权                     | N\/A—见上文。                                                 | 服务对服务策略可以扩展到要求[具有特定范围、发行者、主体、受众等的终端用户凭据](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/conditions\/)—但它不能用于全面的用户对资源的访问控制。全面的用户对资源的访问控制应该使用外部授权来实现。 |\n| Envoy 的外部授权 API (ext_authz) | 不能执行任何每次请求的策略；ext_authz API 只能配置用于 L7 流量。 | 执行每次请求的策略，决策来自一个外部服务，例如 OPA。         |\n| **可观测性**                     |                                                              |                                                              |\n| 日志记录                         | 基本网络信息：网络 5 元组，发送\/接收的字节等。[参见 Envoy 文档](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/observability\/access_log\/usage#command-operators)。 | [完整的请求元数据日志记录](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/observability\/access_log\/usage#command-operators)，除了基本网络信息。 |\n| 跟踪                             | 今天不可行；可能最终通过 HBONE 实现。                        | Envoy 参与分布式跟踪。[参见 Istio 跟踪概述](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/overview\/)。 |\n| 指标                             | 仅 TCP（发送\/接收的字节，数据包数量等）。                    | L7 RED 指标：请求率、错误率、请求持续时间（延迟）。          |\n| **流量管理**                     |                                                              |                                                              |\n| 负载均衡                         | 仅在连接级别。[参见 TCP 流量转移任务](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/tcp-traffic-shifting\/)。 | 每次请求，启用例如金丝雀部署、gRPC 流量等。[参见 HTTP 流量转移任务](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/traffic-shifting\/)。 |\n| 断路器                           | [仅 TCP](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ConnectionPoolSettings-TCPSettings)。 | [HTTP 设置](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/destination-rule\/#ConnectionPoolSettings-HTTPSettings) 除了 TCP。 |\n| 异常检测                         | 在连接建立\/失败时。                                          | 在请求成功\/失败时。                                          |\n| 速率限制                         | [仅在连接建立时，L4 连接数据的速率限制](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/listeners\/network_filters\/rate_limit_filter#config-network-filters-rate-limit)，有全局和本地速率限制选项。 | [每次请求的 L7 请求元数据的速率限制](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_filters\/rate_limit_filter#config-http-filters-rate-limit)。 |\n| 超时 | 仅在连接建立时（通过断路器设置配置连接保持活动）。 | 每次请求。 |\n| 重试 | 重试连接建立。 | 重试每次请求失败。 |\n| 故障注入 | N\/A—TCP 连接上不能配置故障注入。 | 全面的应用和连接级故障（[超时、延迟、特定响应码](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/fault-injection\/)）。 |\n| 流量镜像 | N\/A—仅 HTTP。 | [请求的百分比基础镜像到多个后端](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/mirroring\/)。 |\n\n值得记住的是，一个在 L7 操作的代理可以执行 L4 *和* L7 栏中的所有操作，而一个仅在 L4 操作的代理只能执行 L4 栏中的操作。了解何处发生了什么以及 L4 与 L7 的限制，我们可以看看环境模式与 sidecar 模型相比的权衡。\n\n## 现在可以使用环境模式吗？（还不行）\n\n截至其 2022 年 9 月的公告，环境模式是一个实验性的概念验证。根据[几乎所有的度量](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#limitations)，它的表现不如 sidecar，并且有不少[限制](https:\/\/github.com\/istio\/istio\/tree\/experimental-ambient#limitations)。环境模式**还没有准备好**在生产环境中使用（对我们的客户来说——大型企业的平台团队——应用开发和测试环境也算是生产环境）。\n\n然而，我们预计这种状态会相对快速地改变，因为整个社区的工程师正在努力改进这种部署模型。它将像[所有其他 Istio 功能](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/)一样，通过功能阶段发展。关注[Istio 功能列表](https:\/\/istio.io\/latest\/docs\/releases\/feature-stages\/#istio-features)，环境模式可能在 2023 年某个时候被提升为 Alpha 状态。我们预计它会在 2023 年底或 2024 年初离开 Beta，并且我们不建议在那之前将其用于生产环境。\n\n## 关于服务网格和 Istio 的环境模式假设\n\n总结环境模式公告博客文章，驱动架构的核心假设是：\n\n1. **假设**：Envoy 的 L7 功能是使新应用加入网格变得困难的原因。\n2. **假设**：Envoy 的 L7 功能是发现 CVE 的地方（绝大多数 Envoy CVE 都在 L7 代码中，而不是处理 TLS 和连接的 L4 代码），因此，在节点级别保持多个容器的证书在严格的 L4 代理中是可接受的，而在节点级别进行 L7 处理则不是。\n3. **假设**：sidecar 常常导致资源过度分配。\n4. **假设**：额外的网络跳数比 Envoy 进行 L7 计算更便宜（从两个 L7 sidecar 转到一个 L7 waypoint 增加了一个跳数，但减少了一个执行 L7 处理的 Envoy）。\n5. **假设**：Istio 最有价值的功能是传输中的加密，因此，优化使这一用例易于实现是有价值的。\n\n## 环境模式假设与客户现场的经验如何匹配\n\n我们与世界上一些最大的企业紧密合作，以促进服务网格的采用，这些经验并没有完全证明这些激励思想：\n\n1. **L7 功能**：网格的一些 L7 功能*可以*使应用的采用更加困难，但根据我们的经验，应用入网的更多破坏是由于连接寿命的变化或双重加密的问题造成的。这些问题无论是 sidecar 还是节点级代理都会以类似的方式表现出来，但在节点部署模型中（通常缺乏权限检查特权\/节点级组件的日志）对应用团队来说更难排查问题。深入了解[节点级代理与 sidecar](https:\/\/tetrate.io\/blog\/ebpf-and-sidecars-getting-the-most-performance-and-resiliency-out-of-the-service-mesh\/)的区别，请参阅我们之前提到的博客文章。\n\n2. **L7 CVE**: 查看这些，我们看到：\n\n   - 三十三个与 L7 处理相关，主要是解析或 HTTP 处理。\n   - 剩下的 12 个是 L4 或 Envoy 固有的（连接处理、证书处理、噪声邻居 DOS、缓冲区溢出等）。\n   - L7 CVEs 的平均严重性高于非 L7 CVE。\n\n   一个仅 L4 的 Envoy *确实*提供了相比 L7 Envoy 更小的攻击面，因为代码更少（CVEs 也更少）。是否这样的攻击面足够低以证明在节点上保持每个 pod 的身份是个问题。环境模式安全模型的核心在于我们对 ztunnel 组件的信任程度——这是社区打算首先发展的组件。总体而言，环境的安全模型最好是与 sidecar 模型相比的一种侧步，但在将其纳入现有安全模型时，边界更难以推理。\n   \n3. **资源利用**：的确，如果没有配置 pod 资源请求，sidecar 可以导致资源利用不良，如果不使用[配置资源可见性](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/traffic-management\/#cross-namespace-configuration)或[sidecar API 资源](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)等技术。然而，我们在严格控制资源可见性并通过 sidecar API 资源限制配置范围的 Istio 部署中的经验是，sidecar 资源利用非常低，我们可以为每个 sidecar 设置比 Istio 默认配置文件更小的资源请求。手动维护这种配置类型的 sidecar API 资源*非常具有挑战性*——这就是为什么 [Tetrate Service Bridge](https:\/\/tetrate.io\/tetrate-service-bridge\/) 根据更高级别的访问构造自动生成它。\n\n   我们很高兴看到环境部署模型带来的资源利用改进——因为一个独立的 waypoint Envoy 通常可以处理比单个服务实例（及其 sidecar）看到的流量显著更多。\n\n4. **额外的网络跳数与 sidecar**：环境部署模型提供的最有趣的可能性之一是在 sidecar 架构中移除额外的 L7 Envoy。因为网格中的通信是 sidecar 对 sidecar，客户端和\n\n服务器都应用 L7 策策，我们必须对每个请求进行两次 L7 处理。在环境模式中，该策略将由服务器的 Waypoint 执行——所以 L7 处理只发生一次。然而，连接的两侧仍有 ztunnel 进行 L4 处理。\n\n   这种交易——一个网络跳数而不是 Envoy 进行 L7 处理——是否总体上值得仍有待观察。当然在同一可用区的云提供商网络中，由于延迟低且连接可靠，它可能是值得的。然而，我们的许多客户在预置和各种物理站点上部署服务网格，这些站点通常看起来不像云提供商网络。\n\n5. **mTLS**：Istio 的传输中加密无疑是其最强大的功能之一。它被用于（[以 FIPS 验证的形式](https:\/\/tetrate.io\/blog\/tetrate-istio-distro-achieves-fips-certification\/)）[FIPS 合规](https:\/\/tetrate.io\/blog\/tetrate-first-to-provide-hardened-istio-to-dods-iron-bank\/)、[PCI 合规](https:\/\/tetrate.io\/resource\/meeting-pci-compliance-standards\/) 和在各种安全优先的环境中。然而，当我们看到网格的能力时，通常加密本身并不是采用的原因：通常是加密与 L7 策略（包括流量控制）和可观测性一起激励技术投资。从上表中可以看出，这些能力不能仅靠 ztunnel 实现——它们需要一个 L7 Envoy。事实上，我们今天看到的大多数网格使用都需要一个 L7 Envoy。我们对任何使网格采用更容易的事情都感到非常热情，但我们还没有信心环境模式的部署模型将在这方面显著提供。\n\n## 关于环境模式的最后思考\n\n环境模式是对无 sidecar 服务网格模型的一种有趣看法。我们很期待看到它的发展，特别是如果它能帮助简化网格的采用。有一些特定的用例我们预计这种方法会带来好处，但现在还很早，尚不清楚这些权衡是否值得。无论如何，环境模式在被认为准备好生产之前可能还需要一段时间。直到那时，正如人们所说，让我们拭目以待。\n', '\/trans\/istio-ambient-mesh-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细介绍了 Istio 的新型部署模式——环境模式（Ambient Mesh），这是一种实验性的无 sidecar 部署模式，旨在提高服务网格的性能和可靠性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/5/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/istio/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
             
           
         
       
       
       
       
         <li class="page-item">
           <a href="/categories/istio/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
       
       
       
         
         
         
           
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/categories/istio/page/7/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/istio/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(84)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/free-ai-drawing-tool-raphael/">免费的 AI 绘图工具推荐：Raphael.app</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/cloud-native-observability-devops/">探索云原生可观测性：技术与团队协作的深度结合</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/http2-envoy-tunnel-demo/">使用 Envoy 实现 HTTP/2 CONNECT 隧道：原理与实践</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题开启！</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
