<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Kubernetes 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/kubernetes/" />
  <meta property="og:title" content="Kubernetes 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Kubernetes 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。" />
  <meta property="twitter:description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/kubernetes/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Kubernetes 专栏
                </p>
                <p class="page-description">
                    在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/kubernetes-next-decade/">[译] 云原生网络：展望 Kubernetes 的下一个十年</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/10/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/cloud-native-networking-as-kubernetes-starts-its-second-decade/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生网络：展望 Kubernetes 的下一个十年', '随着 Kubernetes 进入下一个十年，其网络与安全体系将迎来新挑战，eBPF、Gateway API 和 AI 的发展为其未来注入更多可能性。', '\n随着 Kubernetes 迈入青春期，让我们思考其网络和安全系统如何进一步发展与适应。\n\nKubernetes 最近迎来了[十周年](https:\/\/kubernetes.io\/blog\/2024\/06\/06\/10-years-of-kubernetes\/)纪念。作为一名家有三子的父亲，我感觉有责任提醒 Kubernetes 的管理员们：成长中的 Kubernetes 并不总是“乖巧”。\n\n可以预见，[Kubernetes](https:\/\/roadmap.sh\/kubernetes) 将进入其“叛逆期”。\n\nKubernetes 未来将经历增长的阵痛（随着新用例迫使它进行调整）；它或许会遭遇“身份危机”（到底是平台还是API？）；它将寻求更少的监控与更大的自主性（依赖AI工具来减少人类的直接监督）。\n\n借此机会，随着 KubeCon 北美大会即将在盐湖城召开，让我们展望一下云原生网络的发展方向，并探讨一些未来的趋势。\n\n### eBPF 将无处不在\n\n作为能够在 Linux 内核（未来也将支持 [Windows](https:\/\/thenewstack.io\/ebpf-is-coming-for-windows\/)）中运行自定义程序的技术，[eBPF](https:\/\/ebpf.io\/) 的势头不减。除了网络和安全功能（例如 [Cilium](https:\/\/cilium.io\/) 和 [Tetragon](https:\/\/tetragon.io\/) 项目），还出现了更多的应用场景：\n\n- 测量[功耗](https:\/\/sched.co\/1iW8V)：使用 eBPF。\n- 引入[混沌测试](https:\/\/youtu.be\/_5Zabryx0nE?si=KhGFMmeay9LtoJ_-)来验证系统的弹性：使用 eBPF。\n- 加速[加密流量](https:\/\/sched.co\/1i7lP)：使用 eBPF。\n- 在高流量加密数据中[检测异常](https:\/\/sched.co\/1i7ms)：使用 eBPF。\n\n我们可能会面临一种情况，不选择 eBPF 作为网络编程平台反而成为少数。尽管 [eBPF 是一种强大的工具](https:\/\/thenewstack.io\/ebpf-security-power-and-shortfalls\/)，我们不能将所有网络问题都视为“钉子”。\n\n### 最酷的组合：eBPF 与 OpenTelemetry\n\n在 eBPF 可以访问每一个数据包的能力下，网络可视化是一个非常强大的用例。\n\n[OpenTelemetry](https:\/\/www.cncf.io\/reports\/opentelemetry-project-journey-report\/) 作为 CNCF 项目中最活跃的项目之一，提供了标准的可观测框架，通过简单的应用程序仪表来生成和管理遥测数据。\n\n考虑到网络经常被认为是应用性能问题的根源，我们可以期待使用 [OpenTelemetry Network](https:\/\/sched.co\/1how7)，直接从 Linux 内核获取低级遥测数据，以提供关于应用健康状况的有价值见解。\n\n### 展望未来：回顾与反思\n\n在 Kubernetes 迈向十周年之际，我们也开始反思其网络架构的一些设计决策是否依然适用。\n\n例如，Ingress API 是 Kubernetes 早期的一个重要选择，然而其继任者 Gateway API 正在取代它。\n\n服务网格架构也在演变，从传统的 sidecar 架构向 [Cilium Service Mesh](https:\/\/isovalent.com\/blog\/post\/cilium-service-mesh\/) 和 Istio Ambient 模式的无 sidecar 方式转变。\n\n这似乎是反思的好时机。甚至 Kubernetes 的 SIG-Network 组也在考虑是否要放弃[容器网络接口插件模型](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/compute-storage-net\/network-plugins\/)，并可能引入更现代的 [Kubernetes 网络接口](https:\/\/github.com\/kubernetes\/enhancements\/issues\/4410)（KNI）。\n\n### 是时候告别 Ingress\n\n[Gateway API](https:\/\/gateway-api.sigs.k8s.io\/) 是 Kubernetes 生态系统中最具创新性的项目之一。它不仅解决了 Ingress 的不足，且其开发充满合作与包容精神。\n\n随着近三十个 Gateway API 的实现和即将推出的 1.2 版本，在今年的 KubeCon 上，Gateway API 的讨论将深入到实际的部署经验，而非入门课程。\n\nIngress 曾经广泛使用，但现在是时候迈向 Gateway API 了。\n\n### AI 在 Kubernetes 网络中的应用\n\n在讨论 [AI 与网络](https:\/\/www.youtube.com\/watch?v=mUbeiDF2B4k)时，我总是将其分为“面向 AI 工作负载的网络”和“用 AI 改善网络”。后者是当下的重点。\n\n我曾经尝试使用大型语言模型（LLM）来创建网络策略和分析日志，然而效果不一。我们期待 Kubernetes 能借助 AI 技术做出更智能的网络决策，例如自动生成网络策略。\n\n### 面向 AI 的 Kubernetes 网络\n\n随着 Kubernetes 成为 AI\/ML 应用的理想平台，AI 工作负载对网络的需求也愈加显著。它不仅需要本地 GPU，还需要通过远程直接内存访问（RDMA）连接远程 GPU。\n\n或许 Kubernetes 近期的动态资源分配（[DRA](https:\/\/kubernetes.io\/docs\/concepts\/scheduling-eviction\/dynamic-resource-allocation\/)）功能可以用来访问专门的网络硬件资源。\n\n### 结语\n\n是的，Kubernetes 将经历类似青少年的成长过程。但没关系，它有一个支持性强、不断创新的社区来帮助其发展成为一个稳定的系统。\n', '\/trans\/kubernetes-next-decade\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">随着 Kubernetes 进入下一个十年，其网络与安全体系将迎来新挑战，eBPF、Gateway API 和 AI 的发展为其未来注入更多可能性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/podless-kubernetes-istio/">[译] 如何实现无 Pod 的 Kubernetes 和 Istio 部署</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.howardjohn.info/posts/podless-kubernetes/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何实现无 Pod 的 Kubernetes 和 Istio 部署', '探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。', '\nKubernetes 经常被批评（有些不公平）操作起来过于复杂，促使大多数人依赖托管服务。然而，[\u0060k3s\u0060](https:\/\/k3s.io\/) 某种程度上颠覆了这一点，将完整的 Kubernetes 发行版打包成一个二进制文件。这非常方便，特别是在物联网等小型环境中运行时；虽然隔离组件对非常大规模、先进的部署有好处，但对较小的环境来说，操作微服务可能只是一种负担——这正是 [Istio 多年前选择重构为更单体架构的原因](https:\/\/blog.christianposta.com\/microservices\/istio-as-an-example-of-when-not-to-do-microservices\/)。\n\n然而，它还是没有那么“精简”。在一个空集群中运行 \u0060k3d cluster create test\u0060 后，我们会在集群中看到各种 pod：\n\n\u0060\u0060\u0060bash\n$ kubectl get pods --all-namespaces\nNAMESPACE     NAME                                      READY   STATUS     RESTARTS  AGE\nkube-system   local-path-provisioner-6c86858495-gc9jq   1\/1     Running    0         2m18s\nkube-system   coredns-6799fbcd5-pdf4b                   1\/1     Running    0         2m18s\nkube-system   helm-install-traefik-crd-cp9s2            0\/1     Completed  0         2m18s\nkube-system   helm-install-traefik-pch7c                0\/1     Completed  1         2m18s\nkube-system   traefik-f4564c4f4-q4lkj                   1\/1     Running    0         2m8s\nkube-system   metrics-server-54fd9b65b-d69w6            1\/1     Running    0         2m18s\nkube-system   svclb-traefik-58c5bb65-sq54b              2\/2     Running    0         2m8s\n\u0060\u0060\u0060\n\n\u003e [\u0060k3d\u0060](https:\/\/github.com\/k3d-io\/k3d\/) 是一个方便的工具，可以在 Docker 内部部署 \u0060k3s\u0060，便于测试。\n\n这是怎么回事？我们的“单二进制 Kubernetes”怎么变成了 6 个不同的容器？\n\n虽然 k3s 将许多组件（\u0060kube-proxy\u0060、\u0060flannel\u0060、\u0060containerd\u0060、\u0060kubelet\u0060 等）嵌入到一个二进制文件中，但其他组件则作为标准 pod 在集群中运行。\n\n此外，一旦我们部署了我们最喜欢的 [服务网格](https:\/\/istio.io\/)，我们将会有更多的 pod，使我们离没有 pod 的目标更远。\n\n## 没有 pod 的 Kubernetes？\n\n那么问题是——我们能否通过进一步推进 \u0060k3s\u0060 的理念，将完整的集群功能嵌入到一个二进制文件中，来获得一个功能齐全的 Kubernetes 和 Istio 部署？\n\n\u003e **警告**：这些是实验性概念；绝不要在生产环境中尝试！\n\n首先，我们可以直接去除一些不必要的组件，如 \u0060servicelb\u0060（负载均衡服务需要）、\u0060traefik\u0060（Ingress 需要）、\u0060local-storage\u0060（PVC 需要）和 \u0060metrics-server\u0060（\u0060kubectl top\u0060 需要）。\n\n这就剩下 \u0060coredns\u0060 和 Istio。\n\n如果我们追求极简，我们肯定会希望使用 Istio 的 [ambient mode](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/getting-started\/)，它完全不需要 sidecar。幸运的是，它开箱即用并且有完整的 [DNS 支持](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)。这让我们可以去掉 \u0060coredns\u0060。\n\n这样一来，如果我们能运行 Istio ambient，就可以去掉 \u0060kube-system\u0060 中的所有内容。这相对简单；难点在于不为 Istio 添加更多的 pod。\n\n## 嵌入 Istio\n\n通过 \u0060k3s\u0060 的一个分支，我修改了它，使 Istio 本身嵌入到 \u0060k3s\u0060 中。\u0060k3s\u0060 可以作为服务器和\/或代理运行。通常你会有 1 个服务器，每个其他节点作为代理运行。\n\n在 \u0060server\u0060 上，我们希望运行 \u0060Istiod\u0060（Istio 的控制平面）。在代理上，我们希望运行 \u0060istio-cni\u0060（每个节点的控制平面）和 \u0060ztunnel\u0060（每个节点的数据平面）。\n\n这三个组件都可以直接嵌入到 \u0060k3s\u0060 中，只需一些工作！\n\n使用这个自定义构建，我们可以通过一些自定义配置启动一个新的 \u0060k3d\u0060 集群，禁用我们不再需要的组件：\n\n\u0060\u0060\u0060yaml\napiVersion: k3d.io\/v1alpha5\nkind: Simple\nmetadata:\n  name: podless\nservers: 1\nagents: 1\noptions:\n  k3d:\n    wait: true\n    timeout: \u002260s\u0022\n    disableLoadbalancer: true\n    disableRollback: true\n  k3s:\n    extraArgs:\n      - arg: --disable-cloud-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable-kube-proxy\n        nodeFilters:\n          - server:*\n      - arg: --disable-network-policy\n        nodeFilters:\n          - server:*\n      - arg: --disable-helm-controller\n        nodeFilters:\n          - server:*\n      - arg: --disable=coredns,servicelb,traefik,local-storage,metrics-server\n        nodeFilters:\n          - server:*\n\u0060\u0060\u0060\n\n这里我们禁用了上面看到的所有 pod，包括一些额外的。\n\n一个显著的例子是 \u0060kube-proxy\u0060。像其他一些项目一样（如 [Cilium](https:\/\/docs.cilium.io\/en\/stable\/network\/kubernetes\/kubeproxy-free\/)），Istio 的 \u0060ztunnel\u0060 可以有效地替代大多数用例中的 \u0060kube-proxy\u0060。\n\n## 无 pod 的服务网格\n\n所有配置就绪后，我们的集群是什么样子？\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNo resources found\n\u0060\u0060\u0060\n\n到目前为止一切顺利....当然，什么都不运行很容易；真正的挑战是保持集群的功能。\n\n让我们部署一些应用程序 pod。再次强调，这些是集群中的唯一 pod：\n\n\u0060\u0060\u0060\n$ kubectl get pods --all-namespaces\nNAMESPACE   NAME                     READY   STATUS    RESTARTS   AGE\ndefault     shell-5fff89ccf5-98kgg   1\/1     Running   0          19s\ndefault     echo-66d88ff694-9qprp    1\/1     Running   0          14s\n\u0060\u0060\u0060\n\n然后我们可以发送流量：\n\n\u0060\u0060\u0060\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n\u0060\u0060\u0060\n\n流量完全正常，包括服务流量（以前由 \u0060kube-proxy\u0060 处理）和 DNS（以前由 \u0060coredns\u0060 处理）。现在这些全部由 \u0060ztunnel\u0060 处理，并且所有内容都通过安全的 mTLS 传输。\n\n除了 mTLS 加密，我们还可以基于 mTLS 身份应用策略。同样，这些都由 \u0060ztunnel\u0060 执行。\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: allow-default\nspec:\n  action: ALLOW\n  selector:\n    matchLabels:\n      app: echo\n  rules:\n  - from:\n    - source:\n        namespace: [\u0022cluster.local\/ns\/default\/sa\/shell\u0022]\n\u0060\u0060\u0060\n\n现在 \u0060default\u0060 命名空间的流量被允许，但其他流量不被允许。我们可以通过从 \u0060shell\u0060 发送流量以及我在 \u0060other\u0060 命名空间中部署的新测试工作负载来验证这一点：\n\n\u0060\u0060\u0060bash\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nHostname=echo-66d88ff694-9qprp\n$ kubectl exec deploy\/shell -n other -- curl -s echo\ncommand terminated with exit code 56\n\u0060\u0060\u0060\n\n正如预期的那样，我们的其他应用程序被拒绝了！\n\n此外，如果我们愿意，我们可以将流量升级通过完整的 HTTP 代理（[\u0022waypoint\u0022](https:\/\/istio.io\/latest\/docs\/ops\/ambient\/architecture\/)）：\n\n\u0060\u0060\u0060\n$ istioctl x waypoint apply --enroll-namespace\nwaypoint default\/waypoint applied\n\n$ kubectl get pods\nNAME                        READY   STATUS    RESTARTS   AGE\necho-66d88ff694-czd65       1\/1     Running  \n\n 0          93m\nshell-56bd5dbdbf-f4gh9      1\/1     Running   0          93m\nwaypoint-7cd4dc789f-2s7z2   1\/1     Running   0          41s\n\n$ kubectl exec deploy\/shell -- curl -s echo\nRequestHeader=Accept:*\/*\nRequestHeader=User-Agent:curl\/8.5.0\nRequestHeader=X-Request-Id:18d72190-9caa-4162-8bc5-4c11518d7568\nHostname=echo-66d88ff694-czd65\n\u0060\u0060\u0060\n\n现在我们的 waypoint 已经部署，所有到命名空间的流量会自动转发到它，在那里可以执行完整的 HTTP 策略。这里，我们可以看到 \u0060X-Request-Id\u0060 被添加到我们的请求中，但我们还可以获得 [自动配置的其他功能](https:\/\/istio.io\/latest\/blog\/2021\/zero-config-istio\/)，以及更多 [我们可以配置的内容](https:\/\/istio.io\/latest\/docs\/tasks\/)。\n\n## 总结\n\n最终，我们能够部署一个完整的 Kubernetes 集群和服务网格，所有基础设施组件嵌入到一个隐藏的节点二进制文件中——集群功能不需要 pod。\n\n这实际操作起来是否实用？不太实用。然而，这确实表明 Kubernetes\/Istio 被认为过于臃肿和复杂的看法并不完全准确。\n\n它真的比典型的集群更简单吗？某种程度上是的……我们确实替换了两个组件（\u0060kube-proxy\u0060 和 \u0060coredns\u0060），但其余的我们基本上只是隐藏和打包。这显然不如完全替换有意义，但也不错。话虽如此，隐藏东西对 [社交媒体参与度](https:\/\/twitter.com\/wm\/status\/1577081662848241664) 有好处，而 \u0060k3s\u0060 通过有效地隐藏和打包取得了巨大成功，因此显然提供了一些实实在在的好处。\n', '\/trans\/podless-kubernetes-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">探索如何将 Kubernetes 和 Istio 的完整功能嵌入到单一二进制文件中，实现无 Pod 的极简部署方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cni-deep-dive/">深入解读 CNI：容器网络接口</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/04/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入解读 CNI：容器网络接口', '本文详细解释了 CNI（容器网络接口）的基本概念、核心组件以及其与 CRI（容器运行时接口）的关系。', '\n在容器化环境中，有效管理网络是至关重要的。容器网络接口（CNI）是一个标准，定义了容器应如何配置网络。本文将深入探讨 CNI 的基础知识，并带你了解 CNI 与 CRI 的关系。\n\n## 什么是 CNI？{#what-is-cni}\n\nCNI（容器网络接口）规范为容器运行时和网络插件之间提供了一个通用的接口，旨在实现容器网络配置的标准化。\n\nCNI 规范包含以下几个核心组成部分：\n\n- **网络配置的格式**：定义了管理员如何定义网络配置。\n- **请求协议**：描述了容器运行时如何向网络插件发出网络配置或清理请求。\n- **插件执行过程**：详细阐述了插件如何根据提供的配置执行网络设置或清理。\n- **插件委派**：允许插件将特定功能委托给其他插件执行。\n- **结果返回**：定义了插件执行完成后如何向运行时返回结果的数据格式。\n\nCNI 规范通过定义这些核心组成部分，确保了不同的容器运行时和网络插件能够以一致的方式进行交互，实现网络配置的自动化和标准化。\n\n{{\u003ccallout note \u0022CNI 规范的一些要点\u0022\u003e}}\n\n- CNI 是一个插件化的容器化网络解决方案\n- CNI 插件为可执行文件\n- 单个 CNI 插件的职责是单一的\n- CNI 插件是呈链式调用的\n- CNI 规范为一个容器定义一个 Linux 网络命名空间\n- CNI 的网络定义存储为 JSON 格式\n- 网络定义通过 STDIN 输入流传输到插件，这意味着宿主机上不会存储网络配置文件，其他的配置参数通过环境变量传递给插件\n\n{{\u003c\/callout\u003e}}\n\nCNI 插件根据操作类型，接收相应的网络配置参数，执行网络配置或清理任务，并返回执行结果。这一流程确保了容器网络的动态配置与容器生命周期的同步。\n\n下图展示了 CNI 包含了众多的网络插件。\n\n\u0060\u0060\u0060mermaid \u0022CNI 插件的种类\u0022\ngraph TB\n    CR[Container Runtime] --\u003e CNI[\u0022Container Network Interface (CNI)\u0022]\n    CNI --\u003e LP[Loopback Plugin]\n    CNI --\u003e BP[Bridge Plugin]\n    CNI --\u003e PTP[PTP Plugin]\n    CNI --\u003e MACV[MACvlan Plugin]\n    CNI --\u003e IPV[IPvlan Plugin]\n    CNI --\u003e TPP[3rd-Party Plugin]\n\u0060\u0060\u0060\n\n![CNI 插件的种类](cdc38d55a4fc4468ab20df85ab63c2c7.svg)\n\n根据 [CNI 规范](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md#section-2-execution-protocol)，一个 CNI 插件负责以某种方式配置容器的网络接口。插件可分为两大类：\n\n- \u0022接口\u0022插件，负责在容器内部创建网络接口并确保其具有连通性。\n- \u0022链式\u0022插件，调整已创建接口的配置（但可能需要创建更多接口以完成此操作）。\n\n## CNI 与 CRI 的关系 {#relationship}\n\nCNI 和 CRI（容器运行时接口）是 Kubernetes 中两个关键的接口，它们分别处理容器的网络配置和运行时管理。在 Kubernetes 集群中，CRI 调用 CNI 插件来配置或清理容器的网络，这确保了网络配置的过程与容器的创建和销毁过程紧密协调。\n\n下图直观地展示了 CNI 如何与 CRI 协同运行的：\n\n\u0060\u0060\u0060mermaid \u0022CNI 如何与 CRI 协同运行的\u0022\nsequenceDiagram\n    participant K as Kubelet\n    participant CRI as Container Runtime Interface\n    participant CNI as Container Network Interface\n    participant P as Pod\n\n    K-\u003e\u003e\u002bCRI: 创建 Pod 容器\n    CRI-\u003e\u003e\u002bP: 启动容器\n    P--\u003e\u003e-CRI: 容器运行中\n    CRI--\u003e\u003e-K: 容器准备就绪\n    K-\u003e\u003e\u002bCNI: 调用 CNI 进行网络设置\n    CNI-\u003e\u003e\u002bP: 连接网络\n    P--\u003e\u003e-CNI: 网络配置完成\n    CNI--\u003e\u003e-K: Pod 网络就绪\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\u0060\u0060\u0060\n\n![CNI 如何与 CRI 协同运行的](5451dd983a8c3858a265283d74b7536b.svg)\n\n1. **Kubelet 到 CRI**：Kubelet 指示 CRI 创建已调度的 Pod 的容器。\n2. **CRI 到 Pod**：容器运行时在 Pod 中启动容器。\n3. **Pod 到 CRI**：一旦容器运行，它会向容器运行时发出信号。\n4. **CRI 到 Kubelet**：容器运行时通知 Kubelet 容器已准备就绪。\n5. **Kubelet 到 CNI**：容器已启动，Kubelet 调用 CNI 为 Pod 设置网络。\n6. **CNI 到 Pod**：CNI 为 Pod 配置网络，将其连接到必要的网络接口。\n7. **Pod 到 CNI**：网络配置完成后，Pod 向 CNI 确认网络设置。\n8. **CNI 到 Kubelet**：CNI 通知 Kubelet Pod 的网络已准备就绪。\n9. **Kubelet 到 Pod**：现在 Pod 完全可操作，两个容器均已运行且网络已配置。\n\n下图展示了在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤：\n\n\u0060\u0060\u0060mermaid \u0022在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤\u0022\nsequenceDiagram\n    participant P as Pod\n    participant K as Kubelet\n    participant CNI as Container Network Interface\n    participant NS as Network Setup\n    participant IPAM as IP Address Management\n\n    K-\u003e\u003e\u002bP: 调度 Pod\n    P-\u003e\u003e\u002bK: 请求网络设置\n    K-\u003e\u003e\u002bCNI: 调用 CNI\n    CNI-\u003e\u003e\u002bNS: 创建网络命名空间\n    NS--\u003e\u003e-CNI: 命名空间已创建\n    CNI-\u003e\u003e\u002bIPAM: 分配 IP 地址\n    IPAM--\u003e\u003e-CNI: IP 地址已分配\n    CNI-\u003e\u003eP: 设置网络接口\n    P--\u003e\u003e-K: 网络设置完成\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\n    Note over P,K: Pod 调度触发网络设置\n    Note over CNI,IPAM: CNI 处理网络命名空间创建和 IP 地址分配\n\u0060\u0060\u0060\n\n![在 Kubernetes 中为 Pod 设置网络所涉及的详细步骤](4f3017abf23385a5007302ea17241bdf.svg)\n\n1. **Pod 调度**：Kubelet 在节点上调度一个 Pod 运行。\n2. **请求网络设置**：已调度的 Pod 请求 Kubelet 进行网络设置。\n3. **调用 CNI**：Kubelet 调用 CNI 处理 Pod 的网络设置。\n4. **创建网络命名空间**：CNI 为 Pod 创建一个网络命名空间，隔离其网络环境。\n5. **分配 IP 地址**：CNI 通过其 IP 地址管理（IPAM）插件为 Pod 分配一个 IP 地址。\n6. **设置网络接口**：CNI 在 Pod 的网络命名空间内设置必要的网络接口，将其连接到网络。\n7. **网络设置完成**：Pod 通知 Kubelet 其网络设置已完成。\n8. **带有网络运行的 Pod**：Pod 现在已经运行，并且其网络已配置，可以与 Kubernetes 集群中的其他 Pod 和服务通信。\n\n## CNI 工作流程 {#cni-process}\n\n容器网络接口（CNI）规范定义了容器如何配置网络，其中包括 \u0060ADD\u0060、\u0060CHECK\u0060、\u0060DELETE\u0060、\u0060GC\u0060 和 \u0060VERSION\u0060 五种操作。容器运行时通过调用各种 CNI 插件来执行这些操作，从而实现容器网络的动态管理和更新。\n\n\u0060\u0060\u0060mermaid \u0022CNI 工作流程\u0022\nsequenceDiagram\n    participant K as Kubelet\n    participant P as Pod\n    participant CNI as CNI Plugins\n    participant CNII as Interface CNI Plugin\n    participant CNIC as Chained CNI Plugin\n    participant NS as Network Setup\n    participant IPAM as IP Address Management\n\n    K-\u003e\u003e\u002bP: 调度 Pod\n    P-\u003e\u003eK: 请求网络设置\n    K-\u003e\u003eCNI: 调用 CNI 插件\n    CNI-\u003e\u003eCNII: 调用接口插件\n    CNII-\u003e\u003eNS: 设置网络接口\n    CNII-\u003e\u003eCNIC: 调用链式插件\n    CNIC-\u003e\u003eIPAM: 分配 IP 地址\n    IPAM-\u003e\u003eCNIC: IP 地址已分配\n    CNIC-\u003e\u003eNS: 应用网络策略\n    CNIC--\u003e\u003eCNI: 链式配置完成\n    CNI--\u003e\u003eK: 网络设置完成\n    K-\u003e\u003eP: 带有网络运行的 Pod\n\n    Note over CNI,CNIC: CNI插件可以是接口类型或链式类型\n\u0060\u0060\u0060\n\n![CNI 工作流程](893d64215a1ed2a7e409925b258f32ee.svg)\n\n为了详细说明序列图中描述的每个步骤，涉及 Kubelet、Pod、CNI 插件（包括接口和链式 CNI 插件）、网络设置和 IP 地址管理（IPAM）之间的交互，让我们深入了解这个过程：\n\n1. **调度 Pod**：Kubelet 安排一个 Pod 在节点上运行。这一步启动了 Kubernetes 集群中 Pod 的生命周期。\n2. **请求网络设置**：Pod 向 Kubelet 发出网络设置请求。这个请求触发了为 Pod 配置网络的过程，确保它可以在 Kubernetes 集群内进行通信。\n3. **调用 CNI 插件**：Kubelet 调用配置的容器网络接口（CNI）插件。CNI 定义了一个标准化的方式，用于容器管理系统在 Linux 容器中配置网络接口。Kubelet 将必要的信息传递给 CNI 插件，以启动网络设置。\n4. **调用接口插件**：CNI 框架调用一个接口 CNI 插件，负责为 Pod 设置主要的网络接口。这个插件可能会创建一个新的网络命名空间、连接一对 veth 或执行其他操作，以确保 Pod 具有所需的网络接口。\n5. **设置网络接口**：接口 CNI 插件为 Pod 配置网络接口。这个设置包括分配 IP 地址、设置路由和确保接口准备好通信。\n6. **调用链式插件**：在设置网络接口之后，接口 CNI 插件或 CNI 框架调用链式 CNI 插件。这些插件执行额外的网络配置任务，比如设置 IP 伪装、配置入口\/出口规则或应用网络策略。\n7. **分配 IP 地址**：作为链式过程的一部分，链式 CNI 插件中的一个可能涉及 IP 地址管理（IPAM）。IPAM 插件负责为 Pod 分配一个 IP 地址，确保每个 Pod 在集群或命名空间内具有唯一的 IP。\n8. **IP 地址已分配**：IPAM 插件分配了一个 IP 地址，并将分配信息返回给调用插件。这些信息通常包括 IP 地址本身、子网掩码和可能的网关。\n9. **应用网络策略**：链式 CNI 插件将任何指定的网络策略应用于 Pod 的网络接口。这些策略可以规定允许的入口和出口流量，确保根据集群的配置要求进行网络安全和隔离。\n10. **链式配置完成**：一旦所有链式插件完成了它们的任务，Pod 的整体网络配置被认为已完成。CNI 框架或链中的最后一个插件向 Kubelet 发送信号，表明网络设置已完成。\n11. **网络设置完成**：Kubelet 收到了 Pod 的网络设置完成的确认。此时，Pod 具有完全配置的网络接口，具有 IP 地址、路由规则和应用的网络策略。\n12. **带有网络运行的 Pod**：Pod 现在已经运行，并配置了网络。它可以与 Kubernetes 集群中的其他 Pod 通信，根据网络策略访问外部资源，并执行其指定的功能。\n\n以下是针对 [CNI 官方示例](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md#appendix-examples)中的 \u0060ADD\u0060 操作、\u0060CHECK\u0060 操作和 \u0060DELETE\u0060 操作的示例序列图以及详细说明。通过这些操作，容器运行时与 CNI 插件之间进行交互，实现容器网络配置的动态管理和更新。\n\n### ADD 操作示例 {#add}\n\n以下是 ADD 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022ADD 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant PP as Portmap Plugin\n    participant TP as Tuning Plugin\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n\n    CR-\u003e\u003ePP: CNI_COMMAND=ADD\n    PP--\u003e\u003eCR: Portmap 配置完成\n    CR-\u003e\u003eTP: CNI_COMMAND=ADD\n    TP--\u003e\u003eCR: Tuning 配置完成\n    CR-\u003e\u003eBP: CNI_COMMAND=ADD\n    BP-\u003e\u003eHLP: CNI_COMMAND=ADD\n    HLP--\u003e\u003eBP: IPAM 配置完成\n    BP--\u003e\u003eCR: Bridge 配置完成\n\u0060\u0060\u0060\n\n![ADD 操作流程](4c05303a04984692bbba9bac12928387.svg)\n\n1. **容器运行时调用 Portmap 插件**：容器运行时通过调用 Portmap 插件执行 ADD 操作，配置容器的端口映射。\n2. **Portmap 配置完成**：Portmap 插件完成端口映射配置，并将结果返回给容器运行时。\n3. **容器运行时调用 Tuning 插件**：容器运行时调用 Tuning 插件执行 ADD 操作，配置容器的网络调优参数。\n4. **Tuning 配置完成**：Tuning 插件完成网络调优参数配置，并将结果返回给容器运行时。\n5. **容器运行时调用 Bridge 插件**：容器运行时调用 Bridge 插件执行 ADD 操作，配置容器的网络接口和 IP 地址。\n6. **Bridge 插件调用 Host-local 插件**：在完成自身配置之前，Bridge 插件调用 Host-local 插件执行 ADD 操作，配置容器的 IP 地址。\n7. **IPAM 配置完成**：Host-local 插件作为 IP 地址管理（IPAM）的授权方，完成 IP 地址分配，并将结果返回给 Bridge 插件。\n8. **Bridge 配置完成**：Bridge 插件完成网络接口和 IP 地址配置，并将结果返回给容器运行时。\n\n这些操作确保了在容器启动时，其所需的网络配置能够按照预期进行设置，包括端口映射、网络调优和 IP 地址分配等。\n\n### CHECK 操作示例 {#check}\n\n以下是 CHECK 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022CHECK 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n    participant TP as Tuning Plugin\n\n    CR-\u003e\u003eBP: CNI_COMMAND=CHECK with prevResult\n    BP-\u003e\u003eHLP: CNI_COMMAND=CHECK\n    HLP--\u003e\u003eBP: 返回无错误\n    BP--\u003e\u003eCR: 返回 0 返回码\n    CR-\u003e\u003eTP: CNI_COMMAND=CHECK with prevResult\n    TP--\u003e\u003eCR: 操作成功\n\u0060\u0060\u0060\n\n![CHECK 操作流程](eaf27d3bee18f3fe637b78d765c66d3c.svg)\n\n1. **容器运行时调用 Bridge 插件进行检查**：容器运行时通过调用 Bridge 插件执行 CHECK 操作，检查容器的网络配置是否符合预期。\n2. **Bridge 插件调用 Host-local 插件**：Bridge 插件调用 Host-local 插件执行 CHECK 操作，检查 IP 地址分配是否正常。\n3. **返回无错误**：Host-local 插件检查 IP 地址分配无异常，并返回无错误给 Bridge 插件。\n4. **返回 0 返回码**：Bridge 插件检查网络配置无异常，并返回 0 返回码给容器运行时。\n5. **容器运行时调用 Tuning 插件进行检查**：容器运行时调用 Tuning 插件执行 CHECK 操作，检查网络调优参数是否符合预期。\n6. **操作成功**：Tuning 插件检查网络调优参数无异常，返回操作成功给容器运行时。\n\n这些操作确保了在容器运行期间，其网络配置和网络调优参数能够按照预期进行检查和验证，以确保网络配置的一致性和正确性。\n\n### DELETE 操作示例 {#delete}\n\n以下是 DELETE 操作的示例序列图以及详细说明：\n\n\u0060\u0060\u0060mermaid \u0022DELETE 操作流程\u0022\nsequenceDiagram\n    participant CR as Container Runtime\n    participant PP as Portmap Plugin\n    participant TP as Tuning Plugin\n    participant BP as Bridge Plugin\n    participant HLP as Host-local Plugin\n\n    CR-\u003e\u003ePP: CNI_COMMAND=DEL\n    PP--\u003e\u003eCR: Portmap 删除完成\n    CR-\u003e\u003eTP: CNI_COMMAND=DEL\n    TP--\u003e\u003eCR: Tuning 删除完成\n    CR-\u003e\u003eBP: CNI_COMMAND=DEL\n    BP-\u003e\u003eHLP: CNI_COMMAND=DEL\n    HLP--\u003e\u003eBP: IPAM 删除完成\n    BP--\u003e\u003eCR: Bridge 删除完成\n\u0060\u0060\u0060\n\n![DELETE 操作流程](f7506b2840f92ecda6ad52e98a92e79c.svg)\n\n1. **容器运行时调用 Portmap 插件**：容器运行时通过调用 Portmap 插件执行 DELETE 操作，删除容器的端口映射配置。\n2. **Portmap 删除完成**：Portmap 插件完成端口映射的删除，并将结果返回给容器运行时。\n3. **容器运行时调用 Tuning 插件**：容器运行时调用 Tuning 插件执行 DELETE 操作，删除容器的网络调优参数配置。\n4. **Tuning 删除完成**：Tuning 插件完成网络调优参数的删除，并将结果返回给容器运行时。\n5. **容器运行时调用 Bridge 插件**：容器运行时调用 Bridge 插件执行 DELETE 操作，删除容器的网络接口和 IP 地址配置。\n6. **Bridge 插件调用 Host-local 插件**：在完成自身删除之前，Bridge 插件调用 Host-local 插件执行 DELETE 操作，删除容器的 IP 地址分配。\n7. **IPAM 删除完成**：Host-local 插件完成 IP 地址分配的删除，并将结果返回给 Bridge 插件。\n8. **Bridge 删除完成**：Bridge 插件完成网络接口和 IP 地址的删除，并将结果返回给容器运行时。\n\n这些操作确保了在容器停止运行时，其所需的网络配置能够被正确清理和移除，以确保网络资源的有效释放和管理。\n\n通过对 ADD、CHECK 和 DELETE 操作的示例序列图及详细说明，可以清晰地了解容器运行时与 CNI 插件之间的交互过程，以及如何实现容器网络配置的动态管理和更新。\n\n## 总结 {#summary}\n\nCNI 为容器化环境中的网络管理提供了一种标准化的接口，通过与 CRI 的配合，确保了 Kubernetes 集群中容器的网络配置高效且一致。通过深入理解 CNI，开发者和系统管理员可以更好地管理和优化其容器网络。\n\n## 参考 {#references}\n\n- [CNI 规范](https:\/\/github.com\/containernetworking\/cni\/blob\/main\/SPEC.md)\n', '\/blog\/cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文详细解释了 CNI（容器网络接口）的基本概念、核心组件以及其与 CRI（容器运行时接口）的关系。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/kubernetes-networking-by-using-cilium-beginner-level/">[译] 解密 Kubernetes 网络：跟随数据包的奇妙旅程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/03/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.dbi-services.com/blog/kubernetes-networking-by-using-cilium-beginner-level/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('解密 Kubernetes 网络：跟随数据包的奇妙旅程', '本文介绍了传统网络和 Kubernetes 网络的基本概念。通过比喻和图示，解释了 IP 地址、子网、MAC 地址等概念，并以“跟随数据包”的方式讲解了网络通信的过程。同时，也对 Kubernetes 中的网络通信进行了类比，解释了 Pod、CNI 和 eBPF 的概念。整体而言，文章从简单到复杂地讲解了网络通信的原理，便于读者理解。', '\n最近对于理解 Kubernetes 中的网络有很大的兴趣。本文是我对这个话题的贡献。我会尽力用直观的方式解释，并将技术部分翻译成易懂的语言，以便任何人都能理解。\n\n最好的学习网络的方式是通过“追踪数据包”或“数据包的生命周期”。基本上，你要跟随数据包从发送者到接收者的旅程，并在每一步停下来。我以前就用 [Calico 实现的 Pod 到另一个 Pod 的通信](https:\/\/www.dbi-services.com\/blog\/exploration-of-calico-in-minikube\/) 进行了这样的操作。这次我将使用另一个容器网络接口 (CNI) 叫做 [Cilium](https:\/\/cilium.io\/)，它基于 eBPF（了解快速和灵活的路由），并带有许多强大的功能和工具。让我们开始吧！\n\n## Kubernetes 中的传统网络\n\n我们将从头开始。我会假设你对网络一无所知。也许你已经知道 IP 地址是什么？IP 地址是计算机网络接口的数字地址。这就是你的计算机可以连接到你的 Wi-Fi 网络并让你访问互联网的方式。如果你使用的是笔记本电脑，你的 Wi-Fi 网络接口有一个 IP 地址。这个网络接口还有另一个由硬件提供商烧录的唯一地址。这个地址称为介质访问控制 (MAC) 地址。\n\nIP 地址属于一个组（IP 子网）。为了知道它属于哪个组，它使用一种称为子网掩码的东西。当子网掩码应用到 IP 地址时，会得到一个结果，对于属于同一组的每个 IP 地址来说，这个结果都是相同的。这就像你所在的社区一样。\n\n让我们用下面的图来做类比：\n\n![传统网络](f1.png)\n\n房子是一台计算机、服务器或虚拟机。它的大小可以不同，根据它的 CPU 和内存，但为了简单起见，我们使用相同的大小。一栋房子有一扇门，这就是你的网络接口。门上的序列号是你的 MAC 地址，房子上的数字（通常是钉在门上的）是你的 IP 地址。只有在你换门时，你的序列号才会改变。然而，你的房子号码是由你的社区的建筑师分配的，如果有重新分配或设计更改，它可能会改变。\n\n蓝色的第 10 个社区（使用从 10 到 19 的数字）属于同一组（同一 IP 子网），而绿色的第 20 个社区是另一组。在每个社区中，有五栋房子，所以有空间让社区成长。在每个社区里，门直接连接到一个喷泉，代表一个交换机。在喷泉处，有一个指示每条路径的标志，指示你可以到达哪扇门。是的，喷泉不知道房子号码，只知道门的序列号。对于人类来说，这不是很方便，所以我们使用一张地图（称为 ARP 表），它提供了房子号码与门的序列号之间的转换。\n\n如果你住在 14 号房子，想拜访 15 号房子，你会使用这条路（只有一条，而且是你的，所以不会有交通堵塞！）先到达喷泉，然后看看标志。你从地图上知道哪个序列号对应哪个房子，所以你可以沿着通往 15 号房子的路线前往。在这种星形拓扑中，你总是先去喷泉，而不是直接去你想要拜访的房子，因为没有直接的路径。社区内的路径代表了第 2 层链接。你无法通过这些路径到达另一个社区。\n\n### 在社区之间旅行\n\n现在，如果从你的 14 号房子，你想要去拜访 24 号房子怎么办？这是另一个社区，这意味着 14 号的 IP 地址\/子网掩码与 24 号不同。实际上，第 10 和第 20 社区是不同的。所以你知道目的地是另一个社区，这种情况下，你必须首先去找你的门卫（但总是通过喷泉，正如我们所见）。他是你社区的默认网关，他住在 11 号房子。规则是去找他，对于任何目的地在你社区之外的地方。\n\n只有他有地图（路由表）能够到达第 20 号社区，并且知道应该走哪条路（这被称为第 3 层路由，因为你正在离开你的社区）。这张地图显示了到达 20 号社区的正确门。等一下，如果一扇门是一个网络接口，那么门卫房子是不是还有另一扇门？完全正确！11 号房子有另一扇门，门上有另一个号码（101），当然这扇门上有另一个序列号（MAC 地址）。\n\n通过这扇门出去，你现在可以沿着路径到达第 20 号社区，这个社区有自己的门卫在 21 号房子。这个门卫的地图（路由表）指导你到达目的地的正确门。这扇门让你进入了第 20 号社区，因为你的目的地 24 属于它。门卫还给了你地图（ARP 表），所以你可以在喷泉上找到方向。现在，你可以沿着通往绿色喷泉的路径走了。从那里，你只需跟着标志和路径到达 24 号房子。当你想回家时，你沿着相反的方向走同样的路径回去。\n\n## Kubernetes 中的网络\n\n现在你了解了网络的基础知识，让我们来看看在 Kubernetes 中它是如何工作的。是的，它稍微复杂一些，但让我们一步一步来，使用下面的图片来更好地理解：\n\n![使用 Cilium 的 Kubernetes 网络](f2.png)\n\n我们现在没有房子，而是建筑。建筑之间的网络与传统网络仍然相同，中间有一个交换机\/喷泉。建筑的入口有一扇门，上面有建筑的号码（它的 IP 地址），它是 1000 个社区的一份子。一个建筑将代表我们 Kubernetes 集群的一个节点。\n\n你知道 Kubernetes 是一个容器编排器。一个容器包装成一个 pod。为了简单起见，让我们假设一个 pod 只有一个容器，因此这两个术语在这里是等价的。这个 pod 就像我们建筑中的一个私人部分。公寓的大小可以不同，因为它可能有 2、3 或 4 个卧室，这将是你的容器在节点上需要的 CPU 和内存容量。有些公寓是空的，所以建筑仍然有一些容量。然而，在 Kubernetes 中，pod 是根据需要创建和删除的。所以在我们的建筑中，这意味着有时会创建一个 2 卧室的公寓，当不再使用时，它可能会被从建筑物中移除。然后，如果建筑有足够的空间，可能会创建一个 5 卧室的公寓。然后想象一下，这是一座乐高建筑，里面你可以根据需要建造和拆除不同大小的公寓！这不是很棒吗？\n\n在每个建筑物中，容器\/pod 有自己的社区（IP 子网）。在 Kubernetes 中，CNI 的功能基本上是为 pod 分配号码（IP 地址），以便它们可以彼此通信。默认情况下，Cilium 为每个建筑使用不同的社区。当创建一个公寓时，Cilium 会为其分配一个号码。当删除并重新创建一个公寓时，它将获得另一个号码，因此它是临时的。这里蓝色的社区使用 10 号范围，绿色的社区使用 20 号。你可以注意到蓝色和绿色社区的数字范围与建筑物的范围不同。只是为了让你知道，这种设计被称为叠加网络。还有其他可能的，但这是常用的一种。这是一个在节点网络之上的 pod 网络。\n\n### 在同一建筑中的公寓之间旅行\n\n现在，你住在 12 号公寓，你要怎么去拜访 14 号公寓？就像我们在传统网络示例中所做的那样，你是我们要追踪的数据包！当然，你通过它的门（它的网络接口）离开公寓。与我们之前的示例不同之处在于，你现在不是离开房子，而是离开了你的公寓，但仍然在建筑物内部。然后你走过一个私人走廊，到达另一扇门（这是 LXC 接口）。\n\n这扇门给了你进入建筑的公共空间的访问，这里进行了路由和派发。我们称之为 Cilium 大厅（蓝色矩形）。当选择 Cilium 为这个 Kubernetes 集群提供通信时，每个建筑物都安装了这个大厅的 Cilium 代理。大厅里有一个门卫，他不住在公寓里，而是在大厅的一个甲板上等待。他有一个服务人员团队，在建筑物的不同门处等候提供指导。这是因为 Cilium 使用一个叫做 eBPF 的魔法路由地图，有效地帮助旅行者。\n\n当你到达走廊尽头的门时，你向等在这里的服务人员表示你要去 14 号。他在他的魔法 eBPF 地图中找到了一个与 14 号相匹配的项目，并直接向你展示了右上角的走廊门。你不必去大厅，他向你展示了一条秘密通道，直接到达那里。然后你打开那扇门，跟着走廊，到达了 14 号公寓。你回去到 12 号公寓，沿着相同的路径和过程，但是方向相反。\n\n因此，这种调度与传统的交换方式不同，并且非常快速，这要归功于魔法 eBPF 地图！\n\n### 在不同建筑物的公寓之间旅行\n\n现在，从 12 号公寓，你想去拜访另一个建筑物里的 22 号公寓。你的旅行开始和以前一样，你离开你的公寓，沿着走廊，询问等待在这里的服务人员的方向。由于目的地是另一个社区的 22 号，这次他把你引导到了大厅。在这里，与传统网络一样，你需要大厅中的门卫的帮助。门卫查看他的地图（路由表），指引你去 22 号的方向，并向你展示要使用的门号码 11（cilium_host）。\n\n当你打开那扇门时，你会看到后面有另一扇门：那就是蓝色的三角形，称为 VXLAN 接口。这扇门通向一个漂亮的透明隧道，穿过建筑物的主门。你受到雨水的保护，可以欣赏到另一个建筑物的景色。你甚至可以看到室外的喷泉！当你到达绿色建筑物时，你离开隧道，去见在绿色三角形（VXLAN 接口）处等待你的服务人员。你告诉他你的目的地，他在他的魔法 eBPF 地图中找到了与 22 号相匹配的项目，并向你展示了一条通往左上角走廊门的秘密通道。然后你跟着走廊，到达了你的目的地。和以前一样，你回去的路线将沿着相同的路径，但方向相反。\n\n这就是第 3 层路由，因为目的社区与你的不同。你可以看到在 Kubernetes 中比传统路由稍微复杂一些。\n\n## 总结\n\n希望这有助于你理解传统网络和 Kubernetes 网络之间的区别，也希望后者现在对你来说更清晰了。如果这就是你所需要的，那么我很高兴你阅读了这篇博文，希望你喜欢它。如果你现在想了解更多关于 Kubernetes 网络的内容，请保持关注，因为我将写一篇 [中级篇](https:\/\/www.dbi-services.com\/blog\/kubernetes-networking-by-using-cilium-intermediate-level-part-1\/)，你将在其中看到一个真实集群上建筑物的样子！\n', '\/trans\/kubernetes-networking-by-using-cilium-beginner-level\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了传统网络和 Kubernetes 网络的基本概念。通过比喻和图示，解释了 IP 地址、子网、MAC 地址等概念，并以“跟随数据包”的方式讲解了网络通信的过程。同时，也对 Kubernetes 中的网络通信进行了类比，解释了 Pod、CNI 和 eBPF 的概念。整体而言，文章从简单到复杂地讲解了网络通信的原理，便于读者理解。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/expose-loadbalanced-kubernetes-services-with-bgp-cilium/">[译] 使用 Cilium 和 BGP 为 Kubernetes 服务进行负载均衡</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/30</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://sue.eu/blogs/expose-loadbalanced-kubernetes-services-with-bgp-cilium/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Cilium 和 BGP 为 Kubernetes 服务进行负载均衡', '本文介绍了如何使用 Cilium 和 BGP 技术，将 Kubernetes 中的 LoadBalanced 类型的服务暴露给外部网络。作者分享了他们的实验环境、BGP 路由器和 Cilium 的配置过程，以及测试和验证的结果。', '\nCilium 是一个开源项目，旨在为云原生环境提供网络、安全和可观测性，例如 Kubernetes 集群和其他容器编排平台。本博客展示了如何使用 Cilium 和 BGP 将您的 Kubernetes 服务暴露给外部世界。\n\n**BGP**\n边界网关协议（BGP）是一种标准化的外部网关协议，旨在在互联网上的自治系统（AS）之间交换路由和可达性信息。该协议被分类为路径矢量协议，因此它根据由网络管理员配置的路径、网络策略或规则集来做出路由决策。它参与制定核心路由决策，这使得它对互联网的正常运行至关重要。\n\nBGP 专为健壮性和可扩展性而开发，用于在大型网络之间路由数据，包括 ISP 和其他大型组织。它确保了无环的域间路由，并有助于维护稳定的网络结构。BGP 可以处理数千个路由，并以其随着网络增长而扩展的能力而脱颖而出。由于其灵活性和对路由策略的控制，它被广泛使用，使其能够快速响应网络变化。\n\n**Cilium 和 BGP**\n在版本 1.10 中，Cilium 集成了对 MetalLB 的 BGP 支持，从而使其能够宣布 Kubernetes 服务的 IP 地址类型为[使用 BGP 的 LoadBalancer](https:\/\/sue.eu\/insights\/bgp-load-balancing\/)。其结果是，服务可以从 Kubernetes 网络外部访问，无需额外的组件，例如 Ingress 路由器。特别是“无需额外组件”的部分是令人振奋的消息，因为每个组件都会增加延迟，因此没有额外组件会减少延迟。\n\n![](f1.jpg)\n\n此示例中显示的网络配置代表了具有用于服务负载均衡的 BGP 集成的基于 Kubernetes 的环境。以下是配置的详细信息：\n\n**客户端网络（LAN 网络）：** 存在一个具有 IP 范围 192.168.10.0\/24 的本地区域网络（LAN），连接了多个客户端。该网络包含了设置的用户端，用户和其他设备可以在其中访问托管在 Kubernetes 集群上的服务。\n\n**Kubernetes 网络：** Kubernetes 集群具有自己的网络空间，由子网 192.168.1.0\/24 指定。该网络包括 Kubernetes 主节点（k8s-master1）和多个工作节点（从 k8s-worker1 到 k8s-worker5）。这些节点托管了 Kubernetes 集群的实际容器和工作负载。\n\n**管理网络：** 一个独立的管理网络，至少有一个设备（k8s-control）用于控制和管理 Kubernetes 集群。这与 Kubernetes 数据平面分开，以确保安全性和管理效率。\n\n**BGP 路由器：** bgp-router1 桥接了外部网络\/互联网和 Kubernetes 网络。它负责使用 BGP 来广播路由将流量路由到 Kubernetes 集群中的适当服务。IP 范围 172.16.10.0\/24 保留供 Kubernetes 集群内的 LoadBalancer 服务使用。当将 Kubernetes 服务公开为 LoadBalancer 时，它会分配一个来自此池的 IP 地址。然后，BGP 路由器将此 IP 广播到外部网络，从而使流量路由到 LoadBalancer 服务。\n\n此网络配置允许通过利用 BGP 进行 IP 地址管理和路由来实现运行在 Kubernetes 集群上的服务的可扩展和灵活的负载均衡。它将客户端访问、集群管理和服务流量分别分隔到不同的网络中，以进行组织和安全性目的。\n\n## 暴露服务\n\n一旦构建了上述基础架构，就可以创建一个部署并使用 BGP 将其暴露给网络。让我们从一个部署开始，其中包含一个简单的 NGINX Web 服务器，提供默认的 Web 页面。我们还添加了一个类型为 LoadBalancer 的 Service。这将导致使用 BGP 向我们的路由器宣布外部 IP 地址。\n\n一旦构建完成，命令 \u0060kubectl get svc\u0060 显示我们的服务具有外部 IP 地址：\n\u0060\u0060\u0060\nNAME          TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)         AGE\nkubernetes    ClusterIP      10.96.0.1        \u003cnone\u003e            443\/TCP         7d3h\nweb1-lb       LoadBalancer   10.106.236.120   172.16.10.0       80:30256\/TCP    7d2h\n\u0060\u0060\u0060\n172.16.10.0 这个地址看起来很奇怪，但没问题。通常会跳过.0 地址，而使用.1 地址作为第一个地址。其中一个原因是在早期，.0 地址用于广播，后来改为.255。由于.0 仍然是一个有效的地址，负责地址池的 MetalLB 会将其分配为第一个地址。在路由器 bgp-router1 上运行的命令 \u0060vtysh -c \u0027show bgp summary\u0027\u0060 显示它已接收到一个前缀：\n\n\u0060\u0060\u0060\nIPv4 Unicast description:\nBGP router identifier 192.168.1.1, local AS number 64512 vrf-id 0\nBGP table version 17\nRIB entries 1, using 192 bytes of memory\nPeers 6, using 128 KiB of memoryNeighbour V AS MsgRcvd MsgSent TblVer InQ OutQ Up\/Down State\/PfxRcd PfxSnt\n192.168.1.10 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.21 4 64512 446 435 0 0 0 03:36:54 1 0\n192.168.1.22 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.23 4 64512 445 435 0 0 0 03:36:56 1 0\n192.168.1.24 4 64512 446 435 0 0 0 03:36:56 1 0\n192.168.1.25 4 64512 445 435 0 0 0 03:36:56 1 0\n\nTotal number of neighbors 6\n\u0060\u0060\u0060\n\n路由表的以下片段（ip route）告诉我们，对于特定的 IP 地址 172.16.10.0，存在 6 个可能的路由\/目标。换句话说，所有 Kubernetes 节点都宣布它们正在处理该地址的流量。太棒了！！\n\n\u0060\u0060\u0060\n172.16.10.0 proto bgp metric 20\nnexthop via 192.168.1.10 dev enp7s0 weight 1\nnexthop via 192.168.1.21 dev enp7s0 weight 1\nnexthop via 192.168.1.22 dev enp7s0 weight 1\nnexthop via 192.168.1.23 dev enp7s0 weight 1\nnexthop via 192.168.1.24 dev enp7s0 weight 1\nnexthop via 192.168.1.25 dev enp7s0 weight 1\n\u0060\u0060\u0060\n\n实际上，现在从我们的路由器上可以看到 Web 页面。\n\n\u0060\u0060\u0060\n$ curl -s -v http:\/\/172.16.10.0\/ -o \/dev\/null\n\n* Trying 172.16.10.0…\n* TCP_NODELAY set\n* Connected to 172.16.10.0 (172.16.10.0) port 80 (#0)\n\u003e GET \/ HTTP\/1.1\n\u003e Host: 172.16.10.0\n\u003e User-Agent: curl\/7.61.1\n\u003e Accept: *\/*\n\u003c HTTP\/1.1 200 OK\n\u003c Server: nginx\/1.21.3\n\u003c Date: Sun, 31 Oct 2023 14:19:17 GMT\n\u003c Content-Type: text\/html\n\u003c Content-Length: 615\n\u003c Last-Modified: Tue, 07 Sep 2023 15:21:03 GMT\n\u003c Connection: keep-alive\n\u003c ETag: “6137835f-267”\n\u003c Accept-Ranges: bytes\u003e\n{ [615 bytes data]}\n* Connection #0 to host 172.16.10.0 left intact\n\u0060\u0060\u0060\n\n而且，位于我们客户端网络中的客户端也可以访问相同的页面，因为它使用 bgp-router1 作为默认路由。\n\n![](f2.jpg)\n\n## 更多细节\n\n现在一切都运作正常，大多数工程师都想看到更多细节，所以我不会让你失望。\n\n### Ping\n\n你将注意到的第一件事是，LoadBalancer 的 IP 地址无法通过 ping 访问。深入挖掘一下可以揭示原因。我们创建了源端口 80 和目标端口 80 之间的映射。此映射在接口上使用 eBPF 逻辑执行，并存在于所有节点上。此映射确保只有端口 80 的流量被均衡。所有其他流量，包括 ping，都不被接收。这就是为什么你可以看到 icmp 数据包到达节点，但从未发送响应的原因。\n\n### 观察流量\n\nHubble 是建立在 eBPF 和 Cilium 之上的网络和安全性可观测平台。通过命令行和图形 Web GUI，可以查看当前和历史流量。在这个示例中，Hubble 放置在 k8s-control 节点上，该节点直接访问 Hubble Relay 的 API。Hubble Relay 是从 Cilium 节点获取所需信息的组件。请注意，Hubble 命令也存在于每个 Cilium 代理 Pod 中，但那个命令只会显示特定代理的信息！以下输出显示了从路由器上执行 curl http:\/\/172.16.10.0\/ 命令后的观察者信息。\n\n\u0060\u0060\u0060\n$ hubble observe –namespace default –follow\n\nOct 31 15:43:41.382: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: SYN)\nOct 31 15:43:41.384: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.384: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:43:41.385: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.385: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\nOct 31 15:43:41.386: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:43:41.386: 192.168.1.1:36946 \u003c\u003e default\/web1-696bfbbbc4-jnxbc:80 to-overlay FORWARDED (TCP Flags: ACK)\n\u0060\u0060\u0060\n\n之前，我警告过不要在 Cilium 代理 Pod 内使用 hubble 命令，但在特定节点流量中看到具体的情况也可以非常有信息价值。在这种情况下，每个 Cilium 代理 Pod 中都执行了 \u0060hubble observe –namespace default –follow\u0060，并且路由器的 curl 执行了一次。\n\n在托管 Pod 的节点（k8s-worker2）上，我们看到与上面的输出相同的输出。但是，在另一个 Pod（k8s-worker1）上，我们看到以下输出：\n\n\u0060\u0060\u0060\nOct 31 15:56:05.220: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: SYN)\nOct 31 15:56:05.220: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: SYN, ACK)\nOct 31 15:56:05.220: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:05.221: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:05.221: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:05.222: 10.0.3.103:48278 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:05.222: 10.0.3.103:48278 \u003c- default\/web1-696bfbbbc4-jnxbc:80 to-stack FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:05.222: 10.0.3.103:48278 -\u003e default\/web1\n\n-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:12.739: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: SYN)\nOct 31 15:56:12.739: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: SYN, ACK)\nOct 31 15:56:12.742: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK)\nOct 31 15:56:12.742: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:12.745: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: ACK, PSH)\nOct 31 15:56:12.749: 10.0.4.105:36956 -\u003e default\/web1-696bfbbbc4-jnxbc:80 to-endpoint FORWARDED (TCP Flags: ACK, FIN)\nOct 31 15:56:12.749: default\/web1-696bfbbbc4-jnxbc:80 \u003c\u003e 10.0.4.105:36956 to-overlay FORWARDED (TCP Flags: ACK, FIN)\n\u0060\u0060\u0060\n\n我们在这里看到的是，我们的路由器将 IP 地址 172.16.10.0 的流量发送到 k8s-worker1，但该工作节点不托管我们的 web1 容器，因此它将流量转发到处理流量的 k8s-worker2。所有的转发逻辑都使用 eBPF 处理 - 附加到接口的一个小的 BPF 程序将在需要时发送流量和路由到另一个工作节点。这也是为什么在 k8s-worker1 上运行 tcpdump，初始接收到流量的地方，不会显示任何流量的原因。它已经在进入 k8s-worker1 的 IP 堆栈之前被重定向到 k8s-worker2。\n\n我们的合作伙伴 [Isovalent](https:\/\/docs.cilium.io\/en\/stable\/network\/ebpf\/intro\/) 有很多关于 eBPF 和内部工作原理的信息。如果你还没有听说过 eBPF，而且你对 Linux 和\/或网络感兴趣，请务必探索一下基础知识。在我看来，eBPF 将在不久的将来彻底改变 Linux 的网络，特别是对于云原生环境！\n\n[Cilium.io ](https:\/\/cilium.io\/)上有很多关于 eBPF 和内部工作原理的信息。如果你还没有听说过 eBPF，而且你对 Linux 和\/或网络感兴趣，请务必了解至少基础知识。在我看来，eBPF 将在不久的将来彻底改变 Linux 的网络，特别是对于云原生环境！\n\n### Hubble Web GUI\n\n通过一个工作正常的 BGP 设置，使 Hubble Web GUI 对外界也很简单。\n\n![](f3.jpg)\n\n## 最后的话\n\n通过 MetalLB 的集成，使用 BGP 设置 Cilium 变得非常简单，消除了昂贵的网络硬件的需求。Cilium\/BGP 的这种组合，特别是与停用 kube-proxy 结合使用，显著降低了到云端服务的延迟。它还通过仅宣布 LoadBalancer 的 IP 地址来增强安全性和透明性。虽然这种设置不需要 Ingress Controller，但对于大多数 HTTP 服务仍然建议使用一个。像 NGINX 或 Traefik 这样的控制器，通过 BGP 公开，提供协议级别的重写和请求速率限制等重大优势。\n\n这种云原生和基于 Linux 的网络的进步确实是一个飞跃，标志着网络技术的激动人心的时代！\n', '\/trans\/expose-loadbalanced-kubernetes-services-with-bgp-cilium\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何使用 Cilium 和 BGP 技术，将 Kubernetes 中的 LoadBalanced 类型的服务暴露给外部网络。作者分享了他们的实验环境、BGP 路由器和 Cilium 的配置过程，以及测试和验证的结果。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes/">[译] KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/12</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.kedify.io/blog-posts/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KEDA vs. 原生 Kubernetes：谁是云原生应用的自动伸缩王者？', '本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。', '\n### 1. 引言：自动伸缩的重要性\n\n在今天的云原生生态系统中，波动的工作负载和动态的流量模式是常态。适应这种不可预测的行为需要能够实时调整的系统。自动伸缩是必需的，可以确保资源的最佳分配，遏制过度成本，并促进资源的高效使用。\n\n自动伸缩不仅关乎成本。它在维护应用性能和吞吐量方面发挥着关键作用。通过避免欠配置（导致用户体验不佳）和过度配置（导致不必要的成本），自动伸缩可以实现合理的平衡。\n\n### 2. 竞争者：了解基础知识\n\n### 水平 Pod 自动伸缩器（HPA）\n\n[HPA](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/)，作为 Kubernetes 的本地解决方案，根据观察到的指标（主要是 CPU 和内存）来扩展 Pod 的数量。虽然对于统一的工作负载来说非常直接和有益，但当考虑到其无法扩展到零并且完全依赖 CPU 和内存指标时，它的局限性就变得明显了。\n\n![HPA 改变 Pod 的数量](1.jpg)\n\n### 垂直 Pod 自动伸缩器（VPA）\n\n[VPA](https:\/\/github.com\/kubernetes\/autoscaler\/tree\/master\/vertical-pod-autoscaler#intro)更多地涉及资源的调整而不是扩展它们。它评估需求并动态调整资源，确保工作负载的合适适配。但这里有一个问题：增强型的 Pod 并不一定更好。有时，拥有更多的工作进程来处理数据比拥有一个大而强大的工作进程更高效。\n\n![VPA 调整 Pod 的大小](2.jpg)\n\n## 3. 限制：当原生 Kubernetes 自动伸缩器不足以应对时\n\n尽管内置的 Kubernetes 自动伸缩器如 HPA 和 VPA 提供了基本的扩展能力，但它们在范围上天然有限。它们主要关注 CPU 和内存指标可能对于现代应用来说是一个重大限制，因为这些应用可能需要对各种指标做出反应，其中一些甚至可能不是来自应用程序本身的指标。\n\n现代应用面临的引人注目的挑战之一是根据外部系统的事件来进行扩展。例如：\n\n- **消息队列：** 应用程序可能需要根据队列中的消息数量（如 RabbitMQ 或 Kafka）来进行扩展。如果有大量未处理的消息涌入，这可能是一个扩展的指标。\n- **数据库触发器：** 数据库中的更改或更新（如某个表的行突然增加）可能需要将应用程序进行扩\n\n展以处理或分析数据的涌入。\n- **外部 Webhook：** 来自第三方服务的传入 Webhook（例如 GitHub 推送或电子商务交易事件）可能需要更多的资源来处理额外的负载。\n- ‍**IoT 信号：** 对于连接到物联网设备的应用程序，来自这些设备的信号可能是需要扩展的指标。\n\n此外，还存在将扩展到零的必要来有效管理资源的情况，或者存在不同指标的组合决定扩展逻辑的情况，例如 CPU 利用率与数据库读\/写速率。这些微妙的需求突显了内置 Kubernetes 自动伸缩器的不足之处。‍\n\n### HPA 的自定义指标扩展\n\nKubernetes 引入了一个[自定义指标](https:\/\/kubernetes.io\/docs\/tasks\/run-application\/horizontal-pod-autoscale\/#scaling-on-custom-metrics)的接口，旨在为水平 Pod 自动伸缩器（HPA）提供更多超越 CPU 和内存指标的适应性。然而，实际实现中出现了挑战。\n\n尽管强大，但自定义指标 API 并不直观易用。它要求对 Kubernetes 内部有详细的了解，使设置和调整变得繁琐。‍\n\n### 插曲：Prometheus 适配器\n\n[Prometheus 适配器](https:\/\/github.com\/kubernetes-sigs\/prometheus-adapter)试图通过利用自定义指标 API 来弥合这一差距，引入了 Prometheus 的广泛指标。但它也有一些缺点：复杂、不直观的配置以及仅与 Prometheus 指标相关联。实施和维护配置需要不断的警觉性。基础架构或应用程序的更改可能会触发重新配置的需求。\n\n### 4. 登场 KEDA：对决中的英雄\n\n[Kubernetes 事件驱动自动伸缩（KEDA）](https:\/\/keda.sh\/)不仅与 Kubernetes 的自定义指标 API 集成，还使其变得更加可访问。这是用户友好界面如何改变体验的证明，使自动伸缩真正具有可定制性和多功能性。\n\n### KEDA 的好处\n\nKEDA 提供了多个技术优势：\n\n- **事件驱动自动伸缩：** KEDA 能够响应特定事件，甚至扩展到零，确保资源得到明智地使用。\n- **易于使用：** 其直观的配置使实施变得轻松，允许开发人员专注于应用逻辑而不是配置语法。\n- **广泛应用：** 除了仅扩展 Pod 外，KEDA 还可以基于事件安排 Kubernetes 作业，适用于不需要持续运行但可能需要定期大量资源的任务。\n- **多功能集成：** 支持多种身份验证提供程序，集成 KEDA 既简单又安全。‍\n\n### KEDA 在实践中的应用\n\n![KEDA 扩展 Kafka Consumer 应用程序](3.jpg)\n\n虽然传统的指标如 CPU 和内存提供了一些见解，但现实世界的应用程序通常需要更精细和多样化的指标来进行有效的自动伸缩。以下是一些要考虑的情景：\n\n- **事件驱动应用程序：** 考虑一个基于 Kafka 的设置。虽然 CPU 使用率可能保持稳定，但传入 Kafka 事件的激增是确定负载的真正指标。在这种情况下，自动伸缩应该理想地对入站事件的速率或消息积压做出响应。\n- **电子商务交易：** 在电子商务框架中，特殊销售活动可能会导致订单结帐激增。CPU 可能不受影响，但真正的负载可能是数据库队列中积累的未处理订单。\n- **流数据管道：** 从平台（如 Apache Kafka 或 AWS Kinesis）处理数据流的应用程序会经历可变的数据流入率。在这里，相关的指标可能是处理的积压或滞后，而不是 CPU 或内存消耗。\n- **Selenium 测试工作者：** 在持续集成（CI）流水线中，当提交新代码时，可能会触发一系列 Selenium 测试。这里真正的度量标准可能是等待测试的队列。如果有大量等待测试的测试存在瓶颈，基于这个队列来自动伸缩 Selenium 工作者比仅仅观察 CPU 或内存指标更有效。\n- **API 速率限制：** 对于大量依赖第三方 API 且具有速率限制的应用程序，接近速率限制可能是需要进行伸缩的信号。与对速率限制错误的被动反应不同，基于 API 调用频率进行主动伸缩可以确保操作顺利进行。\n\n这样多样化的现实场景强调了需要一种多功能的自动伸缩解决方案，能够理解并响应多种度量标准。KEDA 凭借其灵活性和适应性有效地应对了这些挑战。\n\n### 5. 结论：KEDA 自动伸缩的未来\n\n尽管 Kubernetes 拥有原生的自动伸缩工具如 HPA 和 VPA，以及像 Prometheus 适配器这样的扩展，但它们通常伴随着复杂性。而 KEDA 提供了一个简单的平台，适用于各种各样的自动伸缩需求。它处理事件驱动的扩展，包括缩减到零，这是一个重大优势。此外，设置 KEDA 更加简单，减少了用户在处理 Kubernetes 自定义指标时通常会遇到的典型障碍。\n\nKEDA 的活跃社区证明了它的实用性。对该项目的定期贡献、像 Kedify 或 Microsoft 这样的供应商以及不断增加的[企业采用](https:\/\/keda.sh\/community\/#end-users)显示出它在 Kubernetes 生态系统中日益重要。\n', '\/trans\/battle-of-the-pods-kubernetes-autoscaling-showdown-keda-vs-vanilla-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文比较了 Kubernetes 的内置自动伸缩器（HPA 和 VPA）和 KEDA 项目的优缺点，分析了它们在不同场景下的适用性和效果，展示了 KEDA 如何解决 HPA 和 VPA 无法覆盖的复杂需求。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/">[译] 如何使用 Calico 构建和管理 Kubernetes Cluster Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tigera.io/blog/deep-dive/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何使用 Calico 构建和管理 Kubernetes Cluster Mesh', '这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。', '\nKubernetes 是构建灵活可扩展基础设施以运行动态工作负载的优秀解决方案。然而，随着我们的集群扩展，我们可能会面临同时扩展和管理多个集群的不可避免情况。这个概念可能会给我们的日常工作负载维护带来很多复杂性，并增加在所有环境中保持所有策略和服务的最新性的难度。在这种情况下，[集群网格](https:\/\/www.tigera.io\/blog\/using-calico-to-create-a-kubernetes-cluster-mesh-for-multi-cluster-environments\/) 可以在这些集群之间建立无缝的连接，并将工作负载集成到统一的网络环境中。\n\n集群网格是连接独立 Kubernetes 集群并在不同集群中的资源之间提供连接性的绝佳方式，以提供超出单个集群情况下可能的容错性和高可用性。\n\n在本博客文章中，我们将引导你完成构建多集群环境并建立集群网格所需的步骤，利用 Calico Open Source 的多功能能力。我们将探讨不同的方法，如顶级机架 (TOR) 和 overlay，以建立集群网格，解决不同环境提出的独特网络挑战。这是可能的，因为 Calico 提供了建立多集群环境的多种方法，灵活适应你的网络基础设施和特定要求。此外，我们还将介绍如何加入 DNS 连通性以增强集群间通信。\n\n随着你的集群网格环境扩展，我们将讨论涉及[联邦](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-federation\/)和使用 Calico Enterprise 进行多集群管理的下一步，以及涉及联邦集群。我们将展示 Calico 如何提供多集群管理平面，允许在集群间无缝实施安全性和可观测性。\n\n最后，我们将涉及到 Calico Enterprise 联邦身份如何在[多集群](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-multi-cluster\/)环境中弥合差距，提供一种统一的方式来定制网络策略，可以引用来自不同集群的资源并构建跨集群边界负载平衡请求的服务。\n\n## 什么是集群网格？\n\n集群网格连接了两个或多个独立集群内部资源。通常，每个 Kubernetes 集群将为内部资源分配私有 IP 地址，除非将**节点端口**或**负载均衡器**服务与它们关联，否则这些资源对任何外部实体都不可见。然而，将资源暴露给所有人可能会带来安全风险，并破坏你应该保持的[零信任安全](https:\/\/www.tigera.io\/learn\/guides\/zero-trust\/zero-trust-security\/)姿态，以保护你的环境。此外，它可以通过允许恶意用户利用漏洞并在关键服务中占据立足点来危及整个环境。\n\n在多集群环境中建立集群网格提供了一种安全机制，用于促进集群之间的直接通信。这种通信可以通过指定的集群服务或私有 IP 地址进行，确保强大而受控制的交互，同时减轻了将内部资源暴露给更广泛网络的风险。\n\n### 如何构建多集群环境并建立集群网格\n\n以下图片说明了 Calico 如何在你的集群之间建立集群网格连接。\n\n![](1.png)\n\nCalico 提供了不同的方式，你可以使用这些方式来构建多集群环境，从而提供了与你的网络基础设施和需求相匹配的灵活性。Calico 最好的部分是，在将两个集群连接在一起后，它将自动提供集群网格，你可以通过使用它们的内部集群服务和 IP 地址开始在不同的集群中使用资源。\n\n### 在扁平网络环境中的集群网格\n\n集群网格的配置可以根据底层基础设施的不同而变化，但其基本目的保持不变，实质上是用于建立独立集群之间的连接。\n\n例如，在我们的集群的参与节点通过广播域直接连接的环境中，我们可以通过传播内部路由到外部实体的路由协议来快速建立一个网格。这将允许我们广告内部路由，而无需通过**节点端口**服务将它们暴露给我们的目标服务。\n\n以下图片说明了扁平网络的常见设计：\n\n![](2.png)\n\n考虑观看我们的视频，[使用 Calico 开源进行 Kubernetes 的 BGP](https:\/\/www.youtube.com\/watch?v=PefluN8YM9o\u0026ab_channel=ProjectCalico)，以了解使用全网格方法部署集群网格的全面教程。\n\n### 在企业或云网络环境中的集群网格\n\n在复杂的网络环境中，例如云或企业网络，形成集群的基础设施资源通常分为单独的广播域。这是因为这些域中的每个实体都被要求通过网关来到达其目的地。但是，默认情况下，这个额外的跳跃（网关）需要了解我们在 Kubernetes 集群中创建的内部集群资源。因此，网关会丢弃前往这些内部资源的数据包，使简单的路由方法无法满足要求。\n\n以下图片说明了复杂网络环境的常见设计：\n\n![](3.png)\n\n既然我们知道了问题，让我们看看如何利用 Calico 来解决这个问题。\n\n为了在这样的环境中建立集群网格，我们可以使用两种方法：\n\n- 顶层机架（TOR）\n- overlay\n\n#### TOR 方法（推荐）\n\n在企业或云环境中，资源通常通过中间网关互连。通常，我们建议我们的客户使用 TOR，因为通过与云提供商自动建立路由传播机制来使你的集群了解你监管下的所有云资源，从而使你的集群具备高可用性。这也在云提供商的底层网络基础设施上发挥了作用，从而使你的集群在网络基础设施的支持下具备高可用性。\n\n假设你可以配置云网关并将其与像 Calico 这样的强大的[容器网络接口（CNI）](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-networking\/kubernetes-cni\/)配对，那么你可以利用 BGP 路由来建立集群网格。Calico BGP 集成提供了动态路由，允许你将内部 Pod 和集群 IP 路由传播到网络基础设施中的其他资源。\n\n以下图片说明了支持 BGP 的云环境的常见设计：\n\n![](4.png)\n\n在许多情况下，TOR（顶层机架）提高了高可用性和容错性。这种方法优化了网络流量分布，减轻了单点故障，并进一步增强了你的基础设施的可靠性和弹性。\n\n注意：要了解使用 TOR 方法部署集群网格的详细指南，请查看[此处](https:\/\/docs.tigera.io\/calico\/latest\/networking\/configuring\/bgp#top-of-rack-tor)的教程。\n\n#### IPIP overlay\n\n在某些情况下，你可能无法访问网关以修改其设置，或者它可能不支持 BGP 对等连接。在这种情况下，你可以使用 IPIP overlay 来封装流向目标集群的流量。overlay 网络允许网络设备在底层网络（称为底层）上相互通信，而底层网络不需要了解连接到 overlay 网络的设备。\n\n注意：如果你想了解更多关于 overlay 网络的信息，请单击[此处](https:\/\/docs.tigera.io\/calico\/latest\/about\/kubernetes-training\/about-networking#overlay-networks)。\n\n#### VXLAN overlay (Calico Enterprise)\n\n即将发布的 Calico Enterprise（3.18\u002b）版本将在多集群环境下启用 VXLAN 网络。这种方法的一个显著优势之一是能够使用身份感知策略来保护跨集群的流量（你将在接下来的联邦部分了解有关此功能的信息）。通过其多集群网络功能，Calico Enterprise 自动扩展 overlay 网络，以在集群之间建立 Pod IP 路由。\n\n在使用 VXLAN 的 Calico Enterprise 集群网格设置中，每个集群都充当本地集群和远程集群，本地集群配置为从远程集群的加密通道中检索端点和路由数据。VXLAN 集群网格提供了一种安全、可扩展和高效的解决方案，用于管理多集群网络，实现了跨集群的无缝通信和身份感知策略强制执行。\n\n注意：如果你想了解有关 VXLAN overlay 的更多信息，请单击[此处](https:\/\/www.tigera.io\/news\/tigera-introduces-powerful-enhancements-to-calico-open-source-and-calico-cloud-to-elevate-security-scalability-and-performance\/)。\n\n以下图片说明了没有 BGP 能力的云环境的常见设计：\n\n![](5.png)\n\n注意：要了解使用 TOR 方法部署集群网格的全面指南，请查看[此教程](https:\/\/youtu.be\/rv-DnExi6SM?t=2287)。\n\n### DNS 连接\n\n在建立多集群之后，各个集群可以在 IP 级别进行通信。然而，根据你的网络规模以及 Kubernetes IP 地址的性质，这些地址可以随时动态更改，因此你需要实现一种更容易建立这些集群之间连接的方式。域名解析可以成为你的集群网格的重要补充，允许更容易进行集群间通信。\n\n在大多数 Kubernetes 部署中，CoreDNS 作为负责解析集群域名的主要工作负载。要将 DNS 与集群网格无缝集成，只需对 CoreDNS 配置映射进行简单的修改即可。具体来说，你需要将其他集群的 CoreDNS 内部服务 IP 添加为转发器到你的配置中。\n\n这个简单的调整使你的集群能够通过向其他集群发送查询来解析名称，并检索所需资源的相应 IP 地址。这种集成大大简化了集群网格内的通信，增强了整体连通性，并提高了管理效率。\n\n注意：考虑观看[此视频](https:\/\/youtu.be\/rv-DnExi6SM?t=2574)以了解有关 DNS 连接的全面教程。\n\n## 联邦和多集群管理（下一步）\n\n随着你的环境扩展，你可能会遇到多个团队必须同时在所有集群上工作的情况。多集群管理（MCM）通常解决的一个常见问题是以集中的方式处理来自不同集群的对象，包括网络策略、Pod、[合规性](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-compliance\/)报告、可观测性和安全日志。\n\n虽然从技术上讲，可以通过 kubectl 为每个集群手动创建策略、网络集和其他资源，但这种方法会在你的日常维护任务中引入相当复杂性，并可能为意外的凭据泄漏开辟一条途径。此外，与我们在前一节中探讨的类似，它反映了没有良好结构的多集群环境所面临的挑战，特别是在集群管理、网络、故障排除和可观测性方面。\n\n### 使用 Calico Enterprise 进行多集群管理\n\nCalico Enterprise 提供了一个 MCM 平面，通过在这些集群之间建立安全连接，实现了多集群的安全和可观测性。该架构还支持跨集群联邦[网络策略](https:\/\/www.tigera.io\/learn\/guides\/kubernetes-security\/kubernetes-network-policy\/)资源，并为真正的集中式管理、可观测性和集群维护奠定了基础。\n\n以下图像是列出所有已连接集群的 MCM 页面的示例。\n\n![](6.png)\n\nMCM 的安全功能不仅限于集群的网络方面。由于 MCM 完全集成了 Kubernetes 基于角色的访问控制（RBAC），你可以制定授权，允许用户仅查看他们需要查看的信息。\n\n注意：使用[这个](https:\/\/www.tigera.io\/tutorials\/?_sft_tutorial_product=calico-enterprise)实际操作的工作坊来了解更多关于多集群管理的信息。\n\n### 利用 Calico Enterprise 的联邦身份和统一策略执行\n\nCalico Enterprise 联邦将工作负载和服务端点与在集群之间共享的唯一身份关联起来。\n\n联邦身份可以与网络安全策略关联，以创建引用位于不同集群中的端点的唯一资源，从而实现对集群间安全的无缝控制。\n\n此外，通过联邦服务，你可以发现并与位于不同集群中的远程 Pod 互动。这两个关键功能使得可以创建精确、细粒度的安全控制，加强了跨多个集群的整体安全姿态。\n\n![](7.png)\n\n通过实施联邦层和策略，你可以灵活地定义网络安全策略，这些策略可以普遍适用于所有集群，也可以专门针对一组定义的集群。这种方法提供了一种有效的手段，以在扩展部署以包括多个集群的同时扩展安全措施。通过将这些安全控制扩展到现有和新的集群，你有效地减少了策略的重复和简化了从创建到维护的整个过程。\n\n## 结论\n\n总结一下，集群网格连接不同 Kubernetes 集群中的内部资源。Calico 的灵活集群网格设置为在任何环境中连接到多个集群提供了构建块。\n\nCalico Enterprise MCM、联邦和联邦策略强制执行成为多集群架构的缺失环节，允许无缝通信，同时优先考虑安全性。Calico 在这个领域的能力使你能够无缝提供多集群管理、可观测性、联邦服务和身份，从而使你的组织能够自信而高效地应对现代网络的复杂性。随着组织的继续扩展和扩大规模，整合这些策略将在塑造多集群环境的未来中发挥关键作用。\n', '\/trans\/what-is-a-kubernetes-cluster-mesh-and-what-are-the-benefits\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了集群网格的概念和优势，以及如何使用 Calico Open Source 的多种方法，实现跨集群的服务间通信和负载均衡。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/does-kubernetes-really-perform-better-on-bare-metal-vs-vms/">[译] Kubernetes 在裸机上比虚拟机表现更好吗：Kubernetes 性能对比实验</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/12/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/does-kubernetes-really-perform-better-on-bare-metal-vs-vms/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 在裸机上比虚拟机表现更好吗：Kubernetes 性能对比实验', '本文对比了虚拟机和裸机上 Kubernetes 集群的 CPU、RAM、存储和网络性能的详细比较。', '\n许多人认为部署在裸机上的 Kubernetes 集群比部署在虚拟机上的性能更好，但直到现在都没有关于这一假设的证据。在 Gcore，我们只提供基于充分证据的信息给客户，因此我们决定自行测试 Kubernetes 是否在[裸机上](https:\/\/thenewstack.io\/bare-metal-in-a-cloud-native-world\/)比在虚拟机上表现更好，如果是的话，差距有多大。我将分享我们内部测试的结果。\n\n我故意不讨论虚拟节点与裸机节点竞争的其他方面，如[成本效益或基础设施控制级别](https:\/\/gcore.com\/blog\/kubernetes-on-bare-metal\/)。这超出了本文的范围，本文只关注性能比较。\n\n## VM 和裸机 Kubernetes 之间的区别\n\n当您在虚拟机上部署 Kubernetes 集群时，与裸机（BM）相比，您会得到额外的基础设施层，即虚拟机监视器和客户操作系统。\n\n![显示裸机和虚拟机架构差异的图表](39ff19bc-image1a-e1700581613781.png)\n\n图 1：裸机和虚拟机架构的差异。\n\n这些层占用物理 CPU 和 RAM 来运行，从工作负载中拿走一些计算能力。虚拟化还会影响网络和存储性能：虚拟网络和存储比物理网络和存储慢。\n\n相比之下，当您在[裸机服务器上部署 Kubernetes 集群](https:\/\/thenewstack.io\/provision-bare-metal-kubernetes-with-the-cluster-api\/)时，您没有任何额外的基础设施层和虚拟化。服务器的物理资源完全专用于您的工作负载，容器化应用程序可以直接访问这些资源。\n\n## 我们如何比较虚拟机和裸机 K8s 性能\n\n为了全面了解虚拟机和裸机集群性能的比较，我们测量了以下内容：\n\n- **CPU：** 速度和利用率\n- **RAM：** 延迟\n- **存储：** 每秒事务（TPS）和延迟\n- **网络：** 带宽和延迟\n\n为了保持工作负载的一致性，所有测试应用程序都以容器化方式部署在比较的工作节点上。\n\n### 我们的测试条件\n\n在测试中，我们使用了运行在[Gcore 托管的 Kubernetes](https:\/\/gcore.com\/cloud\/managed-kubernetes)上的 K8s 集群。然而，由于托管的 Kubernetes 不会增加工作节点性能的任何开销，因此这些结果也与标准 Kubernetes 相关。\n\n为了保持工作负载的相同条件，我们选择了相似的虚拟机和裸机工作节点的配置。以下是这种比较配置的示例：\n\n- **裸机工作节点：** 1x Intel Xeon E-2388 8C\/16T 3.2 GHz \/ 64 GB \/ Ubuntu 22.04\n- **虚拟机工作节点：** 16 vCPU \/ 64 GiB 内存 \/ Ubuntu 22.04\n\n## 测试结果摘要\n\n在测试中，我们比较了两个 Kubernetes 集群，一个部署在虚拟机（VMs）上，另一个部署在裸机上。它们的配置相似。作为测试工作负载，我们运行了以下内容：\n\n- 用于 CPU 测试的 CPU 基准测试\n- 用于 RAM 测试的 Sysbench\n- 用于存储测试的 Pgbench\n- 用于网络测试的 Netperf\n\n下面是总结最重要的测试结果的表格：\n\n![测试结果表格](417a03ef-summary1.jpg)\n\n显然，裸机集群在所有情况下效率更高。\n\n让我们详细查看结果，并确定裸机性能对您的工作负载意味着什么。\n\n## 详细测试结果\n\n现在，让我们详细查看每个评估标准下裸机和 VM 集群的性能。\n\n## CPU 速度和利用率\n\n对于 CPU 速度比较，我们使用了 Alex Dedyura 的 [CPU 基准测试](https:\/\/github.com\/alexdedyura\/cpu-benchmark)。这是一个计算到 10,000 位小数的 pi 的脚本。以秒为单位的计算时间，平均值在 10 次测试中被视为测试结果。计算 pi 是一个 CPU 密集型任务，因此该基准测试清晰地显示了被测试 CPU 的性能。\n\n以下是 CPU 速度比较的结果：\n\n![图表显示，裸机集群的 CPU 速度比虚拟机集群的 CPU 快了两倍多](f35507b7-image3a.png)\n\n图 3：裸机集群的 CPU 速度比虚拟机集群的 CPU 快了两倍多。\n\n虚拟机集群的 10 次重试的平均时间为 47.07 秒；而裸机集群为 21.46 秒。因此，裸机集群快了两倍多。\n\n以下是虚拟机集群的 CPU 利用率测试结果：\n\n![平均利用率为 86.81%](12670f56-image4a.png)\n\n图 4：虚拟机集群的 CPU 平均利用率为 86.81%。\n\n![图 5：虚拟机集群 CPU 的每个核心使用信息](ef618156-image5a.png)\n\n图 5：虚拟机集群 CPU 的每个核心使用信息。\n\n在上图 4 中，红色点表示最大的 CPU 核心负载*，绿色表示所有核心的总 CPU 负载。在执行脚本期间，大部分时间内核心都以 100% 的利用率运行；平均值为 86.81%。还有一个小的窃取时间峰值，大约在 15:16（参见图 4），这是一个常见情况，当一个虚拟机由于等待物理 CPU 共享计算资源而没有运行时会发生。\n\n***最大 CPU 核心负载：** 这个指标通常是指在虚拟机内或主机上所有虚拟机中观察到的单个 CPU 核心的最高利用率百分比。它表示在给定时刻一个特定的 CPU 核心有多重地被利用。\n\n**总 CPU 核心负载：** 此指标表示主机机器上所有可用 CPU 核心的整体 CPU 利用率。它考虑了所有 CPU 核心的综合使用情况，提供了运行在主机上的所有虚拟机使用了多少 CPU 容量的综合视图。\n\n以下是裸机集群的 CPU 利用率测试结果：\n\n![图表显示，裸机集群的 CPU 平均利用率为 43.75%](d79f8453-image6a.png)\n\n图 6：裸机集群的 CPU 平均利用率为 43.75%。\n\n平均 CPU 负载约为 43.75%，最大负载为 62.57%，没有窃取时间。因此，就 CPU 性能而言，测试显示裸机集群约为虚拟机集群的两倍有效。\n\n## RAM 延迟\n\n对于 RAM 测试，[我们使用了 sysbench](https:\/\/github.com\/akopytov\/sysbench) 并通过 RAM 传输了 6400 GB 的数据。以下是执行的写入和读取操作的关键结果：\n\n![图 7：裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍](684e605e-7a.png)\n\n图 7：裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍。\n\n虚拟机集群执行写入操作的平均时间为 174.53 毫秒，而裸机集群相同操作仅需 62.02 毫秒。读取操作分别在 173.75 和 47.33 毫秒内完成。\n\n这意味着裸机集群的 RAM 大约比虚拟机集群的 RAM 快三倍。\n\n## 存储 TPS 和延迟\n\n为了测试存储性能，我们运行了一个 PostgreSQL 集群，并使用了 [pgbench 基准测试](https:\/\/www.postgresql.org\/docs\/current\/pgbench.html)。我们测量了 TPS（每秒事务数）和延迟。我们还变化了工作负载，测试了相同集群配置下的 8 GB 和 75 GB 数据库。\n\n以下是这些实例的配置：\n\n![图 8：存储测试的裸机和虚拟机集群配置](87869729-image8a.png)\n\n图 8：存储测试的裸机和虚拟机集群配置。\n\n### 存储 TPS 结果\n\n以下是 TPS 比较的平均结果：\n\n![图 9：裸机集群的存储 TPS 值大约是虚拟机集群的两倍](7bda97df-image9a.png)\n\n图 9：裸机集群的存储 TPS 值大约是虚拟机集群的两倍。\n\n在运行 8 GB 数据库时，虚拟机集群显示了 7,359 TPS，而裸机集群为 14,087 TPS。75 GB 数据库的性能结果分别为 4,636 和 12,029 TPS。\n\n### 存储延迟结果\n\n以下是延迟测试的平均结果：\n\n![图表显示，8 GB 测试中裸机集群的存储延迟约为虚拟机集群的一半，在 75 GB 测试中几乎是其三倍](311dd007-image10.png)\n\n图 10：裸机在存储延迟方面优于虚拟机。\n\n在运行 8 GB 数据库时，虚拟机集群的延迟为 34.78 毫秒，而裸机集群的延迟为 18.17 毫秒。对于 75 GB 数据库，延迟分别为 55.21 毫秒和 21.28 毫秒。\n\n对于 8 GB 数据库，裸机集群的存储性能约为虚拟机集群的两倍。对于 75 GB 数据库，裸机集群相对于虚拟机集群的优势更加明显。\n\n## 网络带宽和延迟\n\n为了测试网络性能，我们使用了 [netperf 基准测试](https:\/\/github.com\/kubernetes\/perf-tests\/tree\/master\/network\/benchmarks\/netperf)，其中 MSS（最大段大小）从 1 到 65,536 不等。MSS 中的“段”元素是在网络上传输的一种 IP 数据包捆绑。因此，MSS 越大，传输的流量就越多。\n\n我们在两个物理节点上部署了三个工作节点：Worker 1 和 Worker 2 位于第一个节点上，而 Worker 3 位于第二个节点上。然后，我们测试了所有三个工作节点之间的网络性能。在所有情况下，结果趋势都相似 — 裸机优于虚拟机。\n\n最有趣的测试是物理距离最远的测试之一，即 Worker 1\/Worker 2（位于第一个节点上）与 Worker 3（位于第二个节点上）之间的距离，当流量在第一个和第二个物理节点之间传输时。我们可以将这看作是所有测试中最具挑战性的条件。图 10 和图 11 显示了此测试的结果。图 10 显示了 MSS 值为 1、2、4 和 8 时的网络带宽比较：\n\n![图 11：裸机集群的网络带宽比虚拟机集群的网络带宽大五倍](4d53bfd2-image11.png)\n\n图 11：裸机集群的网络带宽比虚拟机集群的网络带宽大五倍。\n\n虚拟机集群的带宽范围从 MSS=1 时的 862 KB\/秒到 MSS=8 时的 6.52 MB\/秒，而裸机集群的带宽在相同的 MSS 值范围内从 4.17 MB\/秒到 31 MB\/秒不等。平均而言，裸机集群的带宽比虚拟机集群的带宽大五倍。\n\n图 12 显示了使用相同 MSS 值的网络延迟比较：\n\n![图 12：裸机集群的网络延迟比虚拟机集群的网络延迟低了多达六倍](5f29719e-image12.png)\n\n图 12：裸机集群的网络延迟比虚拟机集群的网络延迟低了多达六倍。\n\n正如我们所见，当使用 MSS=8 时，虚拟机集群的延迟约为 145 微秒（us），而裸机的延迟为 24.5 微秒。此外，在裸机集群的情况下，随着 MSS 的增加，延迟增长较慢。\n\n对于所有测试，请注意我们报告的是*内部*集群网络的网络性能比较。我们在一个网络中的节点之间测量了带宽和延迟，位于一个位置。如果我们使用不同位置的节点，这将增加互联网延迟，这是不稳定的，并且可能因提供商而异。我们保持了合成纯净的条件；这可能无法在实际环境中复制。但是，一般趋势可以预期会被重现。\n\n## 裸机性能优势意味着什么\n\n更好的裸机性能相对于虚拟机提供了两个简单但关键的优势：\n\n- [部署在裸机工作节点上的应用程序](https:\/\/thenewstack.io\/how-do-applications-run-on-kubernetes\/)运行和响应速度比部署在虚拟机上的应用程序更快。\n- 因此，当选择裸机时，客户在使用您的产品时将有更好的体验。\n\n我们的测试结果证实了一个普遍的期望，即裸机对于需要高性能和低延迟的计算密集型工作负载（例如数据库、AI\/ML 模型和其他类型的实时应用程序）更为适用。虚拟机则更适合不需要高计算和低延迟敏感性的工作负载，如 Web 服务器、网站和开发环境。如果高性能和低延迟对于您的用户至关重要，并直接影响您的业务，您应该考虑在 Kubernetes 集群中使用裸机。\n\n## 结论\n\n我们的测试证实了裸机工作节点优于虚拟机工作节点的假设。即裸机比起虚拟机：\n\n- 在 CPU 速度和利用率方面高三倍\n- RAM 延迟是虚拟机的 1\/3\n- 存储性能高两倍多\n- 网络延迟是虚拟机的 1\/5\n', '\/trans\/does-kubernetes-really-perform-better-on-bare-metal-vs-vms\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文对比了虚拟机和裸机上 Kubernetes 集群的 CPU、RAM、存储和网络性能的详细比较。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/kubernetes-gateway-api-enhancement-cloud-native-network/">Kubernetes Gateway API 如何增强云原生网络</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/11/09</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes Gateway API 如何增强云原生网络', 'Kubernetes Gateway API 和 Backstage 的结合标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。', '\n上周 Kubernetes Gateway API 的[正式发布公告](https:\/\/kubernetes.io\/blog\/2023\/10\/31\/gateway-api-ga\/)标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。与此同时，Kubernetes 社区一致认同[Backstage](https:\/\/backstage.io\/docs\/features\/kubernetes\/)是内部开发平台和门户的领先解决方案。Kubernetes Gateway API 和 Backstage 都从一开始就鼓励社区的可扩展性。可以说 API Gateway 的出现为增强 Kubernetes 网络提供了巨大的机会。\n\n## Gateway API vs Istio 服务网格\n\n不过也有人对 Gateway API 与 Istio 服务网格的关系存在疑问。对于 Gateway API 和 Istio 服务网格，两者都是为了解决 Kubernetes 网络中的问题。然而，Gateway API 着重于提供一种标准化和简化的方式来配置和部署 Ingress 和 Egress，是一个更加通用的 API。另一方面，Istio 服务网格更关注于服务到服务的通信，提供丰富的流量管理，安全，策略和遥测功能。\n\n## Kubernetes Gateway API 的未来\n\nKubernetes Gateway API 代表了 API Gateway 的关键基础，引入了一种标准，基于角色的，高度适应性的方法来配置和部署 Gateway。Kubernetes Gateway API 相比现有的 Kubernetes Ingress 的显著改进之一是其基于角色的 API 结构。这使得基础设施，平台和应用程序领域的各种角色能够拥有直接与他们的用例相关的 API 的各个方面。Gateway API 的另一个关键特性是其针对可扩展性的设计 - API 专注于核心 Gateway 和路由用例，具有扩展附加能力的可能性，例如安全性，速率限制和转换。\n\n## 什么是 Backstage？\n\nBackstage 是一个开源的开发者平台，它集成了所有开发者需要的服务，提供了一个统一的视图。这包括版本控制系统、持续集成\/持续部署（CI\/CD）系统、监控、日志、警报和文档。它旨在让开发者更高效地进行日常任务，而无需在多个工具之间切换，它也可以帮助开发者更好地理解和管理他们的软件。\n\n![Backstage UI](backstage-ui.png)\n\nBackstage 可以应用在多种使用场景中：\n\n- **作为服务目录**：Backstage 的软件目录功能可以帮助开发者找到并了解公司内部的所有服务和应用。\n- **作为自动化工具**：Backstage 的软件模板可以自动化 API 上线流程，使得开发者能够更快速、更安全地部署他们的 API。\n- **提供中心化的 API 文档**：Backstage 的 Tech Docs 功能可以提供中心化的 API 文档，使得开发者能够在一个地方查找所有的 API 文档，而无需在多个工具间切换。\n- **作为开发者门户**：Backstage 可以集成多种开发工具，提供一站式的开发者服务，简化开发者的工作流程。\n\nBackstage 通过其[软件目录](https:\/\/backstage.io\/docs\/features\/software-catalog\/)用于发现 API，[软件模板](https:\/\/backstage.io\/docs\/features\/software-templates\/)用于提供带有防护栏的自动 API 上线流程，以及[Tech Docs](https:\/\/backstage.io\/docs\/features\/techdocs\/)用于提供 API 文档的中心用例，用于围绕 API Gateway 的协作。\n\nBackstage 的目标是简化开发者工作流程，提供一站式的解决方案，它使开发者能够在一个平台上查找他们需要的所有信息，而不是在多个工具间切换。此外，Backstage 可以让开发团队专注于编码，而不是管理工具。它还支持多种插件，可以根据团队的需求进行定制。\n\n## 关于未来\n\nBackstage 和 Kubernetes Gateway API 已经牢固地将自己建立为云原生 API Gateway 的基础支柱，两个项目都在各自的路线图中充满创新。其中最有趣的领域是 Kubernetes Gateway API 超越其传统的南北入口能力，包括东西服务至服务通信，通过引入[GAMMA API](https:\/\/developer.gamma.co.uk\/guides\/overview.html)。在真实的流量在每个方向上流动的情况下，为南北和东西流量提供单一基础将有助于提高任何容器化应用的安全性，弹性和可观测性。\n', '\/blog\/kubernetes-gateway-api-enhancement-cloud-native-network\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kubernetes Gateway API 和 Backstage 的结合标志着 Kubernetes 生态系统内 Gateway 能力的重要里程碑。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/run-gui-applications-as-containers-with-x11docker/">[译] 如何在 Docker 容器中运行 GUI 应用程序</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/19</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/run-gui-applications-as-containers-with-x11docker/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Docker 容器中运行 GUI 应用程序', '本文介绍了如何在 Docker 容器中运行 GUI 应用程序。通过使用 x11docker 应用程序，可以轻松启动带有桌面环境的 GUI 容器，并提供了许多功能，如 GPU 硬件加速、声音、剪贴板共享等。文章还提供了安装 Docker 运行时引擎和 x11docker 的详细步骤，并演示了使用 VLC 媒体播放器在容器中运行 GUI 应用程序的示例。', '\n作为开发人员，您可能需要使用 GUI 容器进行工作。如果是这种情况，您会很快发现，传统的 Docker 运行时引擎并不支持运行 GUI 应用程序（除非它们是基于 Web 的类型）。当您想要开发容器化的 GUI 应用程序时，您该怎么办呢？\n\n幸运的是，有许多第三方应用程序可以在桌面上轻松启动 GUI 容器。正如您可能预期的那样，这需要一个桌面环境（否则，您将在更传统的基于服务器的设置上进行开发）。其中一个应用程序叫做 [x11docker](https:\/\/github.com\/mviereck\/x11docker)。顾名思义，此应用程序与 Linux X 显示服务器配合使用（这意味着您需要一个 Linux 发行版才能使其正常工作）。\n\nx11docker 应用程序包括以下功能：\n\n- GPU 硬件加速\n- PulseAudio 或 ALSA 声音\n- 剪贴板共享\n- 打印机和摄像头访问\n- 持久的主目录\n- Wayland 支持\n- 语言区域设置创建\n- 容器内的多个 init 系统和 DBus\n- 支持多个容器运行时和后端（包括 Podman）\n\n您可能会问：“X11 不安全吗？”是的，确实。幸运的是，x11docker 通过使用多个 X 服务器来避免 X 服务器泄漏。因此，您可以放心使用该工具，而不必担心会暴露自己、系统或容器给典型的 X11 服务器弱点。\n\n需要记住的一件事是，x11docker 创建了一个非特权容器用户。该用户的密码为 x11docker，并限制了容器的功能。因此，某些应用程序可能无法按预期方式运行。例如，当尝试从容器内运行 Tor 浏览器时，它无法访问 \/dev\/stdout，这意味着容器将无法运行。但并不是所有容器都是如此。我将用 VLC 媒体播放器进行演示，该播放器可以按预期运行。\n\n接下来，我将向您展示如何在运行中的基于 Ubuntu 的桌面操作系统实例上安装 x11docker。当然，首先您必须安装 Docker 运行时引擎。为此，我将向您展示两种不同的方法。\n\n准备好了吗？我们开始吧。\n\n## 所需的工具\n\n正如我已经提到的，您需要运行中的基于 Ubuntu 的 Linux 桌面发行版实例。您还需要一个具有 sudo 权限的用户。就这些。\n\n## 安装 Docker\n\n首先，我们将使用传统的方法安装 Docker 运行时引擎。首先要做的是使用以下命令将官方 Docker GPG 添加到系统中：\n\n\u0060\u0060\u0060bash\ncurl -fsSL \u003chttps:\/\/download.docker.com\/linux\/ubuntu\/gpg\u003e | sudo gpg --dearmor -o \/usr\/share\/keyrings\/docker-archive-keyring.gpg\n\u0060\u0060\u0060\n\n接下来，我们必须添加 Docker 仓库，以便安装软件。使用以下命令完成此操作：\n\n\u0060\u0060\u0060bash\necho \u0022deb [arch=amd64 signed-by=\/usr\/share\/keyrings\/docker-archive-keyring.gpg] \u003chttps:\/\/download.docker.com\/linux\/ubuntu\u003e $(lsb_release -cs) stable\u0022 | sudo tee \/etc\/apt\/sources.list.d\/docker.list \u0026gt; \/dev\/null\n\u0060\u0060\u0060\n\n添加仓库后，我们将使用以下命令安装一些依赖项：\n\n\u0060\u0060\u0060bash\nsudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release -y\n\u0060\u0060\u0060\n\n使用以下命令更新 apt：\n\n\u0060\u0060\u0060bash\nsudo apt-get update\n\u0060\u0060\u0060\n\n现在，我们可以使用以下命令安装 Docker：\n\n\u0060\u0060\u0060bash\nsudo apt-get install docker-ce docker-ce-cli containerd.io -y\n\u0060\u0060\u0060\n\n为了能够在不使用 *sudo* 的情况下运行 Docker 命令（这可能存在安全风险），请使用以下命令将您的用户添加到 docker 用户组中：\n\n\u0060\u0060\u0060bash\nsudo usermod -aG docker $USER\n\u0060\u0060\u0060\n\n注销并重新登录以使更改生效。\n\n如果您希望采用快速方式，可以使用以下命令安装 Docker：\n\n\u0060\u0060\u0060bash\nsudo apt-get install curl wget uidmap -y\nwget -qO- https:\/\/get.docker.com\/ | sudo sh\n\u0060\u0060\u0060\n\n要能够以无特权方式运行 Docker，请执行以下命令：\n\n\u0060\u0060\u0060bash\ndockerd-rootless-setuptool.sh install\n\u0060\u0060\u0060\n\n## 如何安装 x11docker\n\n在安装 x11docker 之前，我们必须安装一些依赖项。可以使用以下命令完成此操作：\n\n\u0060\u0060\u0060bash\nsudo apt-get install xpra xserver-xephyr xinit xauth xclip x11-xserver-utils x11-utils -y\n\u0060\u0060\u0060\n\n接下来，使用以下命令安装 x11docker：\n\n\u0060\u0060\u0060bash\ncurl -fsSL https:\/\/raw.githubusercontent.com\/mviereck\/x11docker\/master\/x11docker | sudo bash -s -- --update\n\u0060\u0060\u0060\n\n然后，您可以使用以下命令更新 x11docker：\n\n\u0060\u0060\u0060bash\nsudo x11docker --update\n\u0060\u0060\u0060\n\n## 如何使用 x11docker\n\n安装了 x11docker 之后，就可以开始测试了。让我们使用 VLC 应用程序容器进行测试。首先，使用以下命令拉取镜像：\n\n\u0060\u0060\u0060bash\ndocker pull jess\/vlc\n\u0060\u0060\u0060\n\n拉取镜像后，使用以下命令（借助 x11docker）运行 VLC：\n\n\u0060\u0060\u0060bash\nx11docker --pulseaudio --share=$HOME\/Videos jess\/vlc\n\u0060\u0060\u0060\n\n您应该会看到 VLC 窗口打开，准备好供使用（图 1）。它的速度比直接安装在您的桌面上要慢一些，但除此之外，它应该按预期工作。\n\n![](docker.jpg)\n\n当然，如果您是开发人员，这对您帮助不大，因为您想要开发自己的容器。您可以始终创建要使用的映像，对其进行标记，将其推送到您选择的存储库，使用 docker pull 命令将其拉到开发系统上，然后使用 x11docker 部署容器。\n\n就是这样。现在，您可以通过 x11docker 在 Docker 容器中运行 GUI 应用程序了。借助自己的图像部署自己的定制容器，看看它的工作原理。\n', '\/trans\/run-gui-applications-as-containers-with-x11docker\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何在 Docker 容器中运行 GUI 应用程序。通过使用 x11docker 应用程序，可以轻松启动带有桌面环境的 GUI 容器，并提供了许多功能，如 GPU 硬件加速、声音、剪贴板共享等。文章还提供了安装 Docker 运行时引擎和 x11docker 的详细步骤，并演示了使用 VLC 媒体播放器在容器中运行 GUI 应用程序的示例。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/kubernetes/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/kubernetes/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/kubernetes/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/categories/kubernetes/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/kubernetes/page/3/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(87)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(6)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/mastering-github-copilot-for-open-source/">探索 GitHub Copilot：当 AI 成为你的贴身编码助手</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/beyond-sidecar/">超越 Sidecar：深入解析 Istio Ambient Mode 的流量机制与成本效益</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-installation-deep-dive/">Istio 安装方式深度剖析——选择与实践指南</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnativecn.com" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kcd-beijing-2025/">KCD Beijing 2025 - 提交议题及参会报名</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-community-domain-migration/">云原生社区网站域名变更通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
