<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Kubernetes 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/kubernetes/" />
  <meta property="og:title" content="Kubernetes 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Kubernetes 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。" />
  <meta property="twitter:description" content="在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/kubernetes/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Kubernetes 专栏
                </p>
                <p class="page-description">
                    在 Kubernetes 专栏中，我将探讨这个强大的容器编排平台的方方面面。无论是部署、管理还是扩展应用，Kubernetes 都提供了卓越的解决方案。通过本专栏，我希望分享我的经验、技巧和最佳实践，帮助你更好地掌握和应用 Kubernetes 技术。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/wasm-vs-kubernetes/">[译] WebAssembly 能够取代 Kubernetes 吗？探索其优势和限制</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/webassembly/yes-webassembly-can-replace-kubernetes/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('WebAssembly 能够取代 Kubernetes 吗？探索其优势和限制', 'WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。', '\n摘要：WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。与 Kubernetes 相比，WebAssembly 的优点在于简易性和安全性。但是，Kubernetes 始终有其用途，它将始终用于编排微服务和容器。因此，对于某些用例来说，WebAssembly 可以替代 Docker 和容器，但是在高度分布式的云原生环境中，使用 WebAssembly 来编排容器和微服务程度上与 Kubernetes 相同的程度是不可能的。\n\n------\n\n是的，WebAssembly 可以解决 Kubernetes 的一些问题。\n\nWebAssembly 或 Wasm 被证明是一种在 Web 浏览器上运行代码的非常实用的方式，它可以作为编译器。它已经作为一种语言运行得非常好，以至于世界万维网联盟（W3C）在 2019 年将其命名为 Web 标准，成为第四个 Web 标准，与 HTML、CSS 和 JavaScript 一起。\n\n主要的 Web 浏览器，包括 Mozilla、Chrome、Internet Explorer 等，都兼容 Wasm，用于编写代码和创建 Web 浏览器应用程序的使用越来越普遍。除了 Web 工作马车 JavaScript 外，Wasm 还可以容纳其他语言，包括 Go、.NET、C\u002b\u002b、Java、PHP、Rust 和 Python。\n\nAdobe 依赖于 Wasm\/WASI 平台在浏览器上直接运行 C\u002b\u002b 代码，这是其中一个更有趣的用例。这使得用户可以在浏览器上直接运行 Adobe 的 Photoshop 和 Acrobat，从而无需在用户的计算机上下载这些软件工具进行工作。\n\n最终，开发人员意识到 Wasm 也可以在服务器操作系统上运行，现在它的使用范围扩展到硬件平台。它在许多不同的硬件环境中表现出色，从服务器端到边缘部署和物联网设备，或者任何可以直接在 CPU 上运行代码的地方。代码打包在整洁的 Wasm 可执行文件中，可以将其与容器或甚至可以与较少配置的代码和目标运行的迷你操作系统进行比较。无论在哪里部署代码，应用程序都比仅限于 Web 浏览器环境更加广泛。\n\n在许多方面，Wasm 的功能可以与一个“大杂烩”多语言编译器相比。然而，与编译器相比，同一二进制可执行文件的 Wasm 可以针对多个平台进行目标和运行，而无需在 Wasm 代码和目标设备上进行配置。\n\n因此，与编译器相比，Wasm 在完美针对多个目标运行二进制可执行文件时显然比较优越。而在这种情况下，单个二进制可执行文件可以针对多个目标运行，而无需重新配置：这就是 Wasm 的优美之处。\n\n“Wasm 终于让我们在不涉及开发人员的情况下在服务器、云和边缘设备之间移动代码。这将最终结束开发人员花费大量时间担心调整他们的代码以及为不同的目标平台提供支持的时代，”Enterprise Management Associates（EMA）的分析师 Torsten Volk 告诉 The New Stack。“Wasm 的工作是在所有这些平台上提供一致的运行时。”\n\n因此，Wasm 可以在某些情况下为 Kubernetes 提供很好的替代方案。与 Kubernetes 相比的主要优点是：\n\n**简易性**。在部署应用程序时，即使将应用程序分发到不同的终端，也会有许多明显缺少的步骤。Cosmonic 的 PaaS 版本可以用几个命令行在图形界面中部署应用程序。当使用 Fermyon 和 Fastly 的 Compute@Edge 时，情况也是如此。\n\n**安全性**。在 Kubernetes 这种高度分布式的环境中，安全性是一个真正的问题，并且问题点的详尽列表太长，这里不再赘述。微服务之间的互连性意味着，在一个 Pod 中有数百个入口点中获得访问权限的攻击者可能会对组织的整个基础架构造成严重破坏。[秘密管理](https:\/\/thenewstack.io\/kubernetes-secrets-management-3-approaches-9-best-practices\/)是另一个问题，并且与名称一样，在容器中指定谁可以访问它们也存在困难。\n\nWasm 的可移植性和一致性可以使安全性和合规性更易于管理（再次强调，它在 CPU 级别的二进制格式中运行）。此外，Wasm 结构的简单性意味着代码在几乎直接到达端点的封闭沙箱环境中发布。Wasm 并非没有漏洞可以利用。只是相对于 Kubernetes，它的漏洞利用可能性更少。\n\n## 但它们并不是同一件事情\n\nWasm 提供了巨大的机会，并且可能会作为一种部署应用程序的方式，在未来几个月和几年中，我们将看到供应商变得更加有创造力，以便用户可以利用它。相比之下，那些预测 Wasm 最终将吃掉 Kubernetes 的午餐并完全取代它的人，可以说是错过了重点。不可能说会发生什么，以及其他用于在云环境中部署和管理高度分布式应用程序的技术可能最终取代 Kubernetes。但是，它高度不可能是 Wasm。\n\n这是因为 Kubernetes 始终有其用途。它将始终用于编排微服务，以及当然还有容器。它也可以被认为实际上就是 Wasm 将在其中运行的东西，并且其支持者已经说过 Wasm 非常适合在 Kubernetes 环境中运行。\n\n“[Wasm 是为开发人员提供无需编写和维护大量基础设施 YAML 的无服务器运行时](https:\/\/thenewstack.io\/webassembly\/serverless-webassembly-for-browser-developers\/)。Wasm 为应用程序代码提供了一组标准 API，以便访问关键的运行时服务，例如 SQL 或 NoSQL、Kafka 消息传递或代码调试，”Volk 说。“但是，然后 Wasm 依赖于资源编排层，可以由 Kubernetes 或任何其他调度器提供，以提供这些服务所需的基础设施资源。这些资源可以以容器、虚拟机、裸机或一些未曾想到的花哨未来技术的形式交付。”\n\n然而，并非所有人都认为 Kubernetes 作为容器编排的能力将无限期地保持其首选。许多 Wasm 领域的人都倾向于 HashiCorp 的 Nomad 调度器。的确，Fermyon 已经放弃了 Krustlet（Wasm-on-Kubernetes），并将重点转向 HashiCorp Nomad 作为其调度器。Butcher 说：“Nomad 在调度容器方面与 Kubernetes 相当，但具有一个至关重要的附加功能：它可以调度非容器工作负载。在 Fermyon 中，我们能够使 Nomad 调度和执行 WebAssembly 应用程序，而无需编写任何自定义代码。”\n\n与此同时，Kubernetes 开发人员需要在低级别上[接受 WebAssembly](https:\/\/thenewstack.io\/webassembly\/what-is-webassembly-and-why-do-you-need-it\/)，并更改内置的、容器特定的假设，Butcher 说。微软是第一家真正拥抱这个概念的公司，它的[runwasi](https:\/\/github.com\/containerd\/runwasi)项目是 WebAssembly 如何在 Kubernetes 内部执行的示例，Butcher 说。\n\n“runwasi 项目仅仅是 Kubernetes 需要经历的一系列转型中的第一步，如果它不想被 Nomad 和 Wasm 超越，它的开发人员和维护人员需要快速采取行动。”Butcher 说。“Kubernetes 的游戏要输，但如果它不想被 Nomad 和 Wasm 取代，它们需要迅速采取行动。”\n\n## 存在的威胁\n\nWebAssembly 对于 Docker 以及容器构成了一种存在的威胁，尽管在超越 Kubernetes 方面，WebAssembly 的简单性、可移植性和安全性等优势使其成为弥补 Docker 缺陷的良好选择，特别是对于边缘和分布式应用。然而，Butcher 指出，Docker 在以下两种应用程序提供环境时表现出色：\n\n- 长时间运行的过程，如数据库和消息队列，这些过程需要强大的 I\/O 和内存管理能力。\n- 遗留（传统）代码，该代码在应用程序中保留状态并大量使用线程。\n\n“Butcher 说：“我对 Docker 的看法是，它在市场上有一个强大且不可撼动的地位，WebAssembly 不太可能取代它。但是，当涉及到微服务和 Web 应用程序后端时，我认为 WebAssembly 有望削减 Docker 的使用。”\n\n因此，对于某些用例来说，Wasm 可以替代 Docker 和容器，但是在高度分布式的云原生环境中，使用 Wasm 来编排容器和微服务程度上与 Kubernetes 相同的程度是不可能的。\n', '\/trans\/wasm-vs-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">WebAssembly 可以作为一种部署应用程序的方式，可以在服务器操作系统上运行，且在许多不同的硬件环境中表现出色。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/7-steps-to-highly-effective-kubernetes-policies/">[译] 创建高效 Kubernetes 策略的 7 个步骤</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/7-steps-to-highly-effective-kubernetes-policies/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('创建高效 Kubernetes 策略的 7 个步骤', '本文介绍了 Kubernetes 策略的七个步骤，包括基线、修复标签和注释、迁移到受限制的 Pod Security 标准、压制误报、加入常见加固指南、插入并播放、添加自定义规则以应对未预料的特殊情况。通过实施这些步骤，可以逐步减少配置错误和漏洞的数量，实现认证、合规和长期安全目标。', '你刚刚开始了一份新工作，在这个工作中，你第一次有责任操作和管理 Kubernetes 基础设施。你对更深入地了解云原生充满了热情，但同时也非常担心。\n\n是的，你关注的是编写符合命名和资源使用控制最佳实践的安全应用程序的最佳方法，但是关于已经部署到生产环境中的所有其他内容呢？你打开一个新的工具来查看正在发生的情况，发现有 100 个高或严重的 CVE 和 YAML 配置问题。你关闭标签页告诉自己，你以后会处理所有这些问题的。\n\n你会吗？\n\n也许最有雄心壮志和无所畏惧的人会，但问题在于云原生社区喜欢谈论安全、标准化和“左移”，但这些对话都无法减轻因安全、资源、语法和工具问题而产生的不安全感。没有一个开发范式或工具似乎发现了在不压垮人的情况下让错误配置可见的正确方式。\n\n就像我们可能面对的所有待办事项列表一样，无论是工作还是家务，我们的大脑只能有效地处理有限数量的问题。太多问题了，我们就会迷失在上下文切换和优先处理不完整的临时解决方案之间。我们需要更好的方法来限制范围（即分类），设置里程碑，最终使安全工作可管理。\n\n是时候忽略问题的数量，专注于交互地塑造，然后强制执行你的组织使用已建立策略的方式，以产生影响——无需产生不安全感。\n\n## 云原生策略的历史\n\n从 Kubernetes 的第一天开始，YAML 配置就是构建完整集群和运行应用程序的基石。作为开发人员应用程序代码和运维工程师维护集群之间的必要桥梁，它们不仅难以正确获取，而且还是 Kubernetes 中大多数部署\/服务级别问题的根源。更有甚者，没有人——既不是开发人员，也不是运维工程师——想独自对此负责。\n\n策略作为一种自动化的方式进入了云原生空间，用于编写和审批为生产环境编写的 YAML 配置。如果没有一个人或团队想要根据内部样式指南手动检查每个配置，那么策略可以慢慢塑造团队解决安全、资源使用和云原生最佳实践中的常见配置错误的方式。更不用说任何唯一应用程序的规则或习语了。\n\nKubernetes 中策略的挑战在于它对如何、何时和为什么执行它们是不可知的。你可以用多种方式编写规则，在软件开发生命周期（SDLC）的不同点执行它们，并出于不同的原因使用它们。\n\n在此混乱中，没有比 Pod 安全策略（PSP）更好的例子了，它在 2016 年 v1.3 中进入 Kubernetes 生态系统。PSP 的设计目的是控制 pod 的操作方式并拒绝任何不符合要求的配置。例如，它允许 K8s 管理员防止开发人员在任何地方运行特权 pod，从而实质上将低级别的 Linux 安全决策与开发生命周期分离开来。\n\nPSP 从未离开 beta 阶段，有几个很好的理由。这些政策仅在人或进程请求创建 pod 时应用，这意味着没有办法对 PSP 进行改进或默认启用。Kubernetes 团队承认 PSP 使意外授予过于广泛的权限变得太容易了，除了[其他困难](https:\/\/youtu.be\/SFtHRmPuhEw?feature=shared\u0026t=970)。\n\nKubernetes 安全领域的 PSP 时代充满了风险，这启发了一个新的发布周期管理规则：任何 Kubernetes 项目不能超过两个发布周期处于 beta 状态，必须成为稳定的或者标记为[弃用](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/migrate-from-psp\/#disable-psp https:\/\/kubernetes.io\/blog\/2021\/04\/06\/podsecuritypolicy-deprecation-past-present-and-future\/)和删除。\n\n另一方面，PSP 使 Kubernetes 安全领域朝着积极的方向发展：通过将 Kubernetes 安全策略的创建和实例化分离，PSP 开辟了一个新的外部接入控制器和策略执行工具生态系统，例如[Kyverno](https:\/\/kyverno.io\/)、[Gatekeeper](https:\/\/open-policy-agent.github.io\/gatekeeper\/website\/)和[Monokle](https:\/\/monokle.io\/)。\n\n我们用这些工具摆脱了 PSP 的束缚，并用 Pod Security Standard（PSS）替换了它。一会我们再来谈这个巨大的区别。\n\n## 基于阶段的 Kubernetes 策略方法\n\n在确定了策略创建和实例化之间的解耦后，您现在可以在不管您选择哪些工具的情况下，在您的集群、环境和团队之间应用一致的策略语言。您也可以随时更改您用于创建和实例化的工具，并在您的集群中获得可靠的结果。\n\n创建通常发生在集成开发环境（IDE）中，这意味着您可以继续使用您当前最喜欢的语言来使用规则特定的语言，如[Open Policy Agent (OPA)](https:\/\/monokle.io\/learn\/what-is-opa-for-the-kubernetes-connoisseur-its-as-essential-as-salt)、Kyverno 的声明性语法或 Go 或 TypeScript 等编程语言。\n\n实例化和强制执行可以在软件开发生命周期的不同部分进行。正如我们在我们之前的[101 级帖子](https:\/\/medium.com\/kubeshop-i\/kubernetes-yaml-policies-101-649a23780371)中看到的那样，您可以在配置生命周期的一个或多个点应用验证：\n\n1. 通过开发人员的命令行界面（CLI）或 IDE 直接预提交\n2. 通过您的CI\/CD流水线进行预部署\n3. 通过像 Kyverno 或 Gatekeeper 这样的[接入控制器](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/)进行后部署，或者\n4. 在集群中检查部署状态是否仍符合您的策略标准。\n\n策略的实例化、验证和强制执行越晚，危险的错误配置就越容易滑入生产环境，发现和修复任何发现的错误配置的原始来源所需的工作也越多。您可以在几个阶段实例化和强制执行策略，但越早越好——这正是 Monokle 擅长的，具有强大的预提交和预部署验证支持。\n\n有了这个场景，以及对 Kubernetes 策略景观的理解，您可以开始消除您面前的误配置。\n\n### 步骤 1：实施 Pod Security 标准\n\n让我们从前面提到的 PSS 开始。Kubernetes 现在描述了[三个包容性策略](https:\/\/kubernetes.io\/docs\/concepts\/security\/pod-security-standards\/)，您可以快速在整个集群中实施和执行。 “特权”策略完全不受限制，应该仅保留给由管理员管理的系统和基础设施工作负载。\n\n您应该从实例化“基线”策略开始，它允许最小规格的 Pod，这是大多数新接触 Kubernetes 的开发人员开始的地方：\n\n从基线开始的好处是，您无需修改所有现有的 Dockerfile 和 Kubernetes 配置即可防止已知的权限升级。会有一些例外情况，稍后我会谈到。\n\n在命名空间级别上创建和实例化这个策略级别是相对简单的：\n\n您肯定会有一些特殊的服务需要比基线允许的访问权限更多，例如用于收集日志和可观测性的[Promtail 代理](https:\/\/grafana.com\/docs\/loki\/latest\/clients\/promtail\/)。在这些情况下，您需要在特权策略下运行那些命名空间。您需要跟进该供应商的安全改进，以限制您的风险。\n\n通过强制执行 Pod Security 标准的基线水平来处理大多数配置，并允许一些特权配置，然后修复违反这些策略的任何误配置，您就完成了下一个策略里程碑。\n\n### 步骤 2：修复标签和注释\n\n标签用于标识资源进行分组或过滤，而注释则用于重要但不用于识别的上下文。如果您的头脑仍在旋转，来自 Ambassador Labs 的 Richard Li 的[一个方便的定义](https:\/\/blog.getambassador.io\/kubernetes-labels-vs-annotations-95fc47196b6d)可能会帮助：“标签是为 Kubernetes 而设计的，而注释是为人类而设计的。”\n\n标签应仅用于其预定目的，即使在这种情况下，您在何处以及如何应用它们时也要小心。过去，[攻击者已使用标签](https:\/\/sysdig.com\/blog\/exposed-prometheus-exploit-kubernetes-kubeconeu\/)深入探索 Kubernetes 集群的架构，包括哪些节点运行单个 Pod，而不留下运行的查询的日志。\n\n同样的想法也适用于注释：虽然它们是为人类而设计的，但它们经常被用于[获取凭证](https:\/\/github.com\/kubernetes\/ingress-nginx\/issues\/8503)，进而获得访问更多秘密的权限。如果您使用注释来描述应在出现问题的情况下联系的人员，请知道您正在为社交工程攻击创建额外的软目标。\n\n### 步骤 3：迁移到受限制的 PSS\n\n虽然基线是可允许但相对安全的，但“受限制”Pod Security 标准采用了目前加固 Pod 的最佳实践。正如 Red Hat 的 Mo Khan[曾经描述](https:\/\/youtu.be\/SFtHRmPuhEw?t=1951)的那样，受限制的标准确保“您能做的最糟糕的事情是毁掉自己”，而不是您的集群。\n\n使用受限制的标准，开发人员必须编写在只读模式下运行的应用程序，仅启用 Pod 运行所需的 Linux 功能，不能在任何时候升级特权等。\n\n我建议从基线开始并稍后迁移到受限制，作为单独的里程碑，因为后者几乎总是需要对现有的 Dockerfile 和 Kubernetes 配置进行主动更改。一旦您实例化并强制执行了受限制策略，您的配置将需要遵守这些策略，否则它们将被您的验证器或接入控制器拒绝。\n\n### 步骤 3a：压制而不是忽略不可避免的误报\n\n在完成基线和受限制的里程碑时，您正在接近策略管理的更成熟（和复杂）水平。为了确保每个人都在当前策略里程碑方面保持一致，您应该开始处理虚假阳性或必须显式允许的配置，尽管违反了受限制的 PSS。\n\n在忽略规则或抑制规则之间进行选择时，始终选择抑制规则。这需要一个可审计的操作，具有日志或配置更改，以将例外情况编码为已建立的策略框架。您可以在源中添加抑制规则，直接添加到您的 K8s 配置中或在外部添加，其中开发人员请求其运维同行重新配置其验证器或接入控制器，以允许“误配置”通过。\n\n在 Monokle 中，您可以将抑制直接添加到您的配置中作为注释，使用[静态分析结果交换格式（SARIF）规范](https:\/\/docs.oasis-open.org\/sarif\/sarif\/v2.1.0\/sarif-v2.1.0.html)所称的[理由](https:\/\/docs.oasis-open.org\/sarif\/sarif\/v2.1.0\/os\/sarif-v2.1.0-os.html#_Toc34317739)：\n\n### 第 4 步：加入常见加固指南\n\n在这一步中，您已经超越了已有的 Kubernetes 安全框架，这意味着您需要更多地积极构建和努力实现自己的里程碑。\n\n美国国家安全局（NSA）和网络安全和基础设施安全局（CISA）有一份受欢迎的[Kubernetes 加固指南](https:\/\/media.defense.gov\/2022\/Aug\/29\/2003066362\/-1\/-1\/0\/CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.PDF)，其中详细介绍了不仅是 Pod 级别的改进措施，如有效地使用不可变容器文件系统，还包括网络分离、审计日志和威胁检测。\n\n### 第 5 步：插入并播放\n\n在实施了一些或所有已有的加固指南之后，每个新的策略都涉及选择、信任和权衡。花些时间在谷歌或 StackOverflow 上，你就会发现很多推荐的插入和播放策略。\n\n你可以从众包策略中受益，其中许多来自于那些有着更独特经验的人，但请记住，虽然规则可能是出于良好意图的，但你并不了解推荐者的优先事项或操作上下文。他们知道如何实现某些“高挂水果”政策，因为他们不得不这样做，而不是因为这些政策普遍有价值。\n\n目前正在进行的辩论是是否以及如何严格限制容器的资源需求。对于请求限制也是如此。不配置限制可能会引入安全风险，但如果严重限制 Pod，它们可能无法正常运行。\n\n### 第 6 步：添加自定义规则以应对未预料的特殊情况\n\n现在，你已经到了 Kubernetes 策略的远端，远离了导致生产负面影响的 20％的错误配置和漏洞。但即使现在，即使已经实施了所有的最佳实践和集体云原生知识，你仍然无法免疫不会意地引发事故或停机的错误配置 - 安全和稳定的奇妙未知未知。\n\n一个好的经验法则是，如果一个奇特的（错）配置在生产中引起了两次问题，那么就该将其编码为一条自定义规则，在开发过程中强制执行，或由准入控制器强制执行。它太重要了，不能仅在内部悄悄地记录下来，希望开发人员阅读它，在彼此的拉取请求审查中注意到它并捕获它。\n\n一旦编码到您现有的策略中，自定义规则就成为了您尽可能接近开发人员执行的防护栏杆。如果你可以在开发人员提交工作之前就用验证到达开发人员，Monokle Cloud 就可以无缝地执行这一点，使用自定义插件和您本地运行的开发服务器，那么您可以节省整个组织大量的重复工作和调整他们的拇指等待 CI\/CD 管道无可避免地失败时他们可以构建新功能或修复错误。\n\n## 总结\n\n如果您实施了以上所述的所有框架和里程碑，并对您的 Dockerfile 和 Kubernetes 配置进行了所有必要的更改以满足这些新策略，那么您可能会发现您的 90 个主要漏洞清单已经减少到了一个更易管理的数量。\n\n您正在看到我们逐步塑造和执行 Kubernetes 策略的方法的价值。您与新策略和规则的影响互动得越多，就像 Monokle 在提交之前唯一做到的那样，就越容易在不压垮自己或其他人的情况下逐步迈出步伐。\n\n您甚至可能会自豪地宣称，您的 Kubernetes 环境完全没有配置错误。这是一种胜利，毫无疑问，但这不是保证 - 总会有新的 Kubernetes 版本、新的应用程序和新的最佳实践融入到您已经完成的工作中。利用框架和加固指南的优势在于，您有更好的共同基础来谈论您在认证、合规和长期安全目标方面的影响。\n\n对于非专家来说，哪种听起来更有说服力：\n\n- 您将 CVE 数量从 90 个降至 X 个，\n- 还是您完全符合美国国家安全局的 Kubernetes 加固指南？\n\n我们越早不再担心数字，而是更多地关注共同里程碑，在应用程序生命周期的早期（理想情况下是 pre-commit！）尽早执行，我们就能找到每个云原生策略的可持续甜蜜点。\n', '\/trans\/7-steps-to-highly-effective-kubernetes-policies\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Kubernetes 策略的七个步骤，包括基线、修复标签和注释、迁移到受限制的 Pod Security 标准、压制误报、加入常见加固指南、插入并播放、添加自定义规则以应对未预料的特殊情况。通过实施这些步骤，可以逐步减少配置错误和漏洞的数量，实现认证、合规和长期安全目标。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/can-chatgpt-save-collective-kubernetes-troubleshooting/">[译] Kubernetes 故障排除智慧的演变</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/can-chatgpt-save-collective-kubernetes-troubleshooting/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 故障排除智慧的演变', '本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI\/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。', '摘要：本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI\/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。\n\n---\n\n本文译自：https:\/\/thenewstack.io\/can-chatgpt-save-collective-kubernetes-troubleshooting\/\n\n数十年前，系统管理员们开始在互联网上分享他们每天面临的技术问题。他们进行了长时间、充满活力且富有价值的讨论，探讨如何调查和解决问题的根本原因，然后详细说明最终对他们有效的解决方案。\n\n这股洪流从未停歇，只是改变了流向。如今，这些讨论仍在 Stack Overflow、Reddit 以及企业工程博客上进行。每一次讨论都是对全球 IT 系统故障排除经验的宝贵贡献。\n\n[Kubernetes](https:\/\/roadmap.sh\/kubernetes)也从根本上改变了这种流向。与几十年来困扰系统管理员和 IT 人员的虚拟机（VM）和单体应用程序相比，[微服务架构](https:\/\/thenewstack.io\/microservices\/)要复杂得多。由于 Kubernetes 缺乏数据持久性，往往无法对规模化的 K8s 错误进行本地重现。即使能够捕获，观测数据也会在多个平台上分散，而资源和依赖关系的相互关联关系也难以捕捉。\n\n现在，凭直觉并不一定足够。您需要知道如何调试集群以获得下一步的线索。\n\n这种复杂性意味着公开的故障排除讨论比以往任何时候都更为重要，但现在我们开始看到这股宝贵的洪流不是被重定向，而是完全被堵住了。你在谷歌上看到了这一点。任何与 Kubernetes 相关问题的搜索都会出现一半以上的付费广告和至少一页 SEO 驱动的文章，这些文章缺乏技术深度。[Stack Overflow](https:\/\/thenewstack.io\/stack-overflow-adds-ai-will-the-community-respond\/) 正在失去其作为技术人员首选问答资源的主导地位，Reddit 在过去几年中也陷入了争议。\n\n现在，每个 Kubernetes 的 DevOps 平台都在建立最后一个堤坝：将您的故障排除知识集中在其平台上，并用[人工智能（AI）和机器学习（ML）](https:\/\/thenewstack.io\/70-percent-of-developers-using-or-will-use-ai-says-stack-overflow-survey\/)取而代之，直到整个堆栈对于甚至是最有经验的云原生工程师来说都成为一个黑盒。当发生这种情况时，您失去了逐个探测、排除故障和修复系统的能力。这种趋势将曾经是众包故障排除技能洪流变成了过去所能提供的仅仅是一滴水。\n\n当我们依赖于平台时，故障排除技术的集体智慧就会消失。\n\n## 故障排除智慧的传承\n\n起初，系统管理员依靠实体书籍进行技术文档和整体最佳实践的实施。随着互联网在 80 年代和 90 年代的普及，这些人通常通过[Usenet](https:\/\/today.duke.edu\/2010\/05\/usenet.html)与同行进行交流，并在像 comp.lang.* 这样的新闻组中提出工作中的技术问题，这类新闻组类似于我们今天所知的论坛的简化版本。\n\n随着互联网的普及迅速，并几乎完全改变了故障排除智慧的洪流。工程师和管理员们不再聚集在新闻组中，而是涌向包括 Experts Exchange 在内的数千个论坛，该论坛于 1996 年上线。在积累了大量的问题和答案之后，Experts Exchange 团队将所有答案都放在了每年 250 美元的付费墙后面，这使得无数宝贵的讨论无法公开获取，最终导致了该网站的影响力下降。\n\n[Stack Overflow 随后出现](https:\/\/www.joelonsoftware.com\/2018\/04\/06\/the-stack-overflow-age\/)，再次向公众开放了这些讨论，并通过声望点数对讨论进行游戏化，这些声望点数可以通过提供见解和解决方案来获得。其他用户随后对“最佳”解决方案进行投票和验证，这有助于其他搜索者快速找到答案。Stack Overflow 的游戏化、自我管理和社区使其成为了洪流式故障排除知识的唯一渠道。\n\n但是，就像其他时代一样，没有什么好事能永远持续下去。近 10 年来，人们一直在预测[“Stack Overflow 的衰落”](https:\/\/johnslegers.medium.com\/the-decline-of-stack-overflow-7cb69faa575d)，并指出由于其具有攻击性的性质和由拥有最多声望点数的人进行管理的结构，它“讨厌新用户”。虽然 Stack Overflow 的影响力和流行度确实下降了，但 Reddit 的开发\/工程专注的 subreddit 填补了这个空白，它仍然是公开可访问的故障排除知识的最大存储库。\n\n特别是对于 Kubernetes 和云原生社区来说，这仍然是一个重要的资源，因为它们仍然在经历重大的增长阵痛。而这是一种宝贵的资源，因为如果您认为现在的 Kubernetes 已经很复杂了...\n\n## Kubernetes 的复杂性问题\n\n在一篇关于“直观调试”失败的精彩文章中，软件交付顾问 Pete Hodgson 认为，构建和交付软件的现代架构（如 Kubernetes 和微服务）比以往任何时候都更加复杂。他写道：“对于我们大多数人来说，为服务器命名为希腊神话角色，并通过 ssh 进入服务器运行\u0060tail\u0060和\u0060top\u0060的日子已经一去不复返了。”但是，“这种转变是有代价的……传统的理解和故障排除生产环境的方法在这个新世界中已经行不通了。”\n\n![Cynefin 模型](cynfin.jpg)\n\n*Cynefin 模型。来源：维基百科*\n\nHodgson 使用[Cynefin 模型](https:\/\/en.wikipedia.org\/wiki\/Cynefin_framework)来说明软件架构过去是复杂的，因为有足够的经验，人们可以理解故障排除和解决方案之间的因果关系。\n\n他认为，分布式微服务架构是复杂的，即使经验丰富的人对根本原因以及如何进行故障排除也只有“有限的直觉”。他们必须花更多时间通过可观测性数据提出问题和回答问题，最终假设可能出错的原因。\n\n如果我们同意 Hodgson 的前提 - Kubernetes 本质上是复杂的，并且在响应之前需要花费更多的时间分析问题，那么与 Kubernetes 一起工作的工程师学会了哪些问题最重要，然后用可观测性数据回答，以进行最佳的下一步行动，似乎是至关重要的。\n\n这正是新一代以 AI 驱动的故障排除平台所提供的智慧。\n\n## Kubernetes 故障排除的两种路径\n\n多年来，像 OpenAI 这样的公司一直在根据 Stack Overflow、Reddit 等公开数据进行抓取和训练模型，这意味着这些 AI 模型可以访问大量的系统和应用知识，包括 Kubernetes。还有一些人意识到组织的可观测性数据是训练 AI\/ML 模型分析新场景的宝贵资源。\n\n他们都在问同一个问题：我们如何利用关于 Kubernetes 的现有数据来简化搜索最佳解决方案的过程？他们正在构建的产品采取非常不同的路径。\n\n### 第一种：增强操作员的分析工作\n\n这些工具自动化和简化对公开在线发布的大量故障排除知识的访问。它们不会取代进行适当故障排除或[根本原因分析](https:\/\/aws.amazon.com\/opensearch-service\/resources\/root-cause-analysis\/)（RCA）所需的人类直觉和创造力，而是有条不紊地自动化操作员查找相关信息的方式。\n\n例如，如果一个刚接触 Kubernetes 的开发人员在运行\u0060kubectl get pods\u0060时发现\u0060CrashLoopBackOff\u0060状态导致他们无法部署应用程序，他们可以查询一个 AI 驱动的工具以获得建议，比如运行\u0060kubectl describe $POD\u0060或\u0060kubectl logs $POD\u0060。这些步骤可能会进一步引导开发人员使用\u0060kubectl describe $DEPLOYMENT\u0060来调查相关的部署情况。\n\n在[Botkube](https:\/\/botkube.io\/)，我们对使用 AI 在大量故障排除智慧的基础上自动化这个来回查询的概念非常感兴趣。用户应该能够直接在 Slack 中提问，如“我如何排除这个无法正常工作的服务？”并收到 ChatGPT 撰写的回答。在一次公司范围的黑客马拉松活动中，我们着手实施这一概念，为我们的协作故障排除平台构建了一个新的插件。\n\n通过[Doctor](https:\/\/botkube.io\/blog\/use-chatgpt-to-troubleshoot-kubernetes-errors-with-botkubes-doctor)，您可以利用大量的故障排除知识，通过 Botkube 作为您的 Kubernetes 集群和消息\/协作平台之间的桥梁，无需在 Stack Overflow 或 Google 搜索广告中漫游，这对于新手 Kubernetes 开发人员和操作员特别有用。\n\n该插件还通过生成一个带有**获取帮助**按钮的 Slack 消息进一步自动化，用于任何错误或异常，然后查询 ChatGPT 以获取可行的解决方案和下一步操作。您甚至可以将 Doctor 插件的结果导入其他操作或集成，以简化您主动使用现有广泛的 Kubernetes 故障排除知识来更直观地调试和感知问题的方式。\n\n### 第二种：将操作员从故障排除中排除\n\n这些工具不关心公开知识的泛滥。如果它们可以基于实际的可观测性数据训练通用的 AI\/ML 模型，然后根据您的特定架构进行微调，它们可以试图完全剔除人为操作员在根本原因分析和故障修复中的作用。\n\n[Causely](https:\/\/www.causely.io\/platform\/causely-for-kubernetes-applications\/)就是这样一家初创公司，他们并不回避使用 AI 来“消除人为故障排除”的愿景。该平台连接到您现有的可观测性数据，并处理它们以微调因果关系模型，理论上可直接进行修复步骤 - 无需探测或使用\u0060kubectl\u0060。\n\n如果说有时候有一个 Kubernetes 神灵听起来很诱人，那我可能会撒谎，但我对像 Causely 这样的工具夺走运维工作并不担心。我担心的是在 Causely 引领的未来中，我们宝贵的故障排除知识会发生什么。\n\n### 这两种路径之间的差距：数据\n\n我不是在为“人工智能将取代所有 DevOps 工作”发表言论。我们已经读过太多这样的末日场景，适用于每个小众和行业。我更关心这两种路径之间的差距：用于训练和回答问题或呈现结果的数据是什么？\n\n第一种路径通常使用现有的公开数据。尽管有关 AI 公司爬取这些站点进行训练数据的担忧-Reddit 和 Twitter，但这些数据的开放性仍然提供了一个激励循环，以保持开发人员和工程师继续在 Reddit、Stack Overflow 和其他平台上共享知识的持续泛滥。\n\n云原生社区通常也倾向于共享技术知识，认同共享技术知识和一个“涨潮（Kubernetes 故障排除技巧的涨潮）抬高所有船（压力巨大的 Kubernetes 工程师）”的想法。\n\n第二条路径看起来更为暗淡。随着以 AI 驱动的 DevOps 平台的兴起，越来越多的故障排除知识被锁定在这些仪表板和驱动平台的专有 AI 模型中。我们都同意，Kubernetes 基础架构将继续变得更加复杂，而不是更简单，这意味着随着时间的推移，我们对节点、Pod 和容器之间发生的情况的理解将变得更少。\n\n当我们停止互相分析问题和感知解决方案时，我们变得依赖于平台。这对每个人来说都是一条失败的道路，除了平台之外。\n\n### 我们如何不失去（或失去得更少）？\n\n我们能做的最好的事情是继续在线上发布关于我们在 Kubernetes 和其他领域的故障排除经验的惊人内容，比如“[关于故障排除 Kubernetes 部署的视觉指南](https:\/\/learnk8s.io\/troubleshooting-deployments)”；通过游戏化创造教育性应用程序，比如[SadServers](https:\/\/sadservers.com\/)；在故障排除系统时采取我们最喜欢的第一步，比如“[为什么在排除未知机器问题时我通常首先运行‘w’](https:\/\/rachelbythebay.com\/w\/2018\/03\/26\/w\/)”；并进行详细的事后分析，详细描述了探测、感知和应对潜在灾难性情况的压力故事，比如[2023 年 7 月的 Tarsnap 故障](https:\/\/mail.tarsnap.com\/tarsnap-announce\/msg00050.html)。\n\n我们还可以超越技术解决方案，比如讨论我们如何在紧张的故障排除场景中管理和支持同事，或者在组织范围内建立对可观测性的一致认识。\n\n尽管它们目前面临困境，但 Stack Overflow 和 Reddit 将继续是讨论故障排除和寻求答案的可靠渠道。如果它们最终与 Usenet 和 Experts Exchange 齐名，它们可能会被其他可公开获得的替代品所取代。\n\n无论何时何地以何种方式发生，我希望您能加入我们在 Botkube 和全新的 Doctor 插件中，为在 Kubernetes 中协作解决复杂问题构建新的渠道。\n\n无论 AI 驱动的 DevOps 平台是否继续基于抓取的公共 Kubernetes 数据训练新模型，只要我们不自愿地将好奇心、冒险精神和解决问题的能力全部放入这些黑匣子中，就会始终有一条新路径，让宝贵的故障排除知识源源不断地流动。\n', '\/trans\/can-chatgpt-save-collective-kubernetes-troubleshooting\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论了在 Kubernetes 故障排除中的两种路径：一种是增强操作员的分析工作，通过自动化和简化对故障排除知识的访问来提供帮助；另一种是将操作员从故障排除中排除，通过使用 AI/ML 模型和可观测性数据来自动化故障修复。同时强调了数据的重要性，以及继续共享故障排除经验和建立对可观测性的一致认识的必要性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/does-kubernetes-really-give-you-multicloud-portability/">[译] Kubernetes 真的能提供多云可移植性吗？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/23</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://medium.com/digital-mckinsey/does-kubernetes-really-give-you-multicloud-portability-476270a0acc7" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 真的能提供多云可移植性吗？', '本文讨论业务领导者和架构师选择使用 Kubernetes 的原因。', '\n从 2017 年起我们就开始与 Kubernetes 社区合作，将 Kubernetes 作为后端容器编排平台，将无数应用程序迁移到云端。其中有些迁移进展顺利，而另一些则颇具挑战性。同样，我们利用云服务提供商（CSP）的本地容器编排解决方案来执行相同的操作，在易于迁移的情况下获得了类似的结果。本文无意讨论这些经验，也无意说明一种技术胜过另一种技术，而是讨论业务领导者和架构师选择利用 Kubernetes 的原因。\n\n根据我们的经验，根据你的组织结构和运营模式，大规模利用 Kubernetes 比利用其他 CSP 原生解决方案，如 AWS Elastic Container Service（ECS）、AWS Batch、Lambda、Azure App Service、Azure Functions 或 Google Cloud Run 的开销更大。\n\nKubernetes 是一种开源容器编排引擎，其本质旨在在任何地方运行。它的架构在如何通过本地使用插件和扩展来实现这种可移植性方面非常出色。但是，**这是集群运维的责任**，由他们来管理和操作这些插件。我们知道，某些服务（如 EKS、GKE 和 AKS）正在努力改善这种体验。即使那样，你也必须选择你的 Kubernetes 版本，安装和配置插件，并确保你的部署清单、应用程序接口和 Kubernetes 集群公开的 API 以及这些插件之间的兼容性。我们知道这是大多数企业的“正常”维护，不会吓跑他们，但我们想问问为什么。你为什么要承担这项维护工作？当 CSP 原生解决方案保持其 API 的向后兼容性比 Kubernetes 长多年时，为什么要负担这部分开销？当我们推动这个话题时，最常见的反应是业务领导者和架构师担心供应商锁定和 \/ 或认为他们的应用程序必须在多个 CSP 中积极运行。但是，这些相同的组织中的大多数正在为其数据库利用 CSP 原生解决方案，并且在某些情况下，为其未开发的应用程序利用函数即服务（FaaS）功能。如果一家公司真的担心供应商锁定到这个水平，它应该完全依赖 Kubernetes，运行自己的数据库，并托管所有自己的工具和系统，而不是完全利用 CSP 原生解决方案。利用 FaaS 为其新建应用程序提供服务。\n\n有些行业（高科技）可能需要工程能力才能在这个级别或规模上运行 Kubernetes，但大多数行业（银行、汽车、制造等）通常没有相同的业务驱动因素。如果你发现自己身处这样的行业，并希望最大限度地发挥云所能带来的价值，那么本文适合你。\n\n我们实验的结果（详见下文）表明，给定一个应用程序设计为在一个 CSP 的托管 Kubernetes 中运行并与其他 CSP 的服务（例如 DNS、LB、数据库等）集成，它与将该应用程序迁移到另一个 CSP 管理的 Kubernetes 的努力，就像将该应用程序迁移到另一个 CSP 的原生容器编排服务一样。根据我们的调查结果，我们认为，那些仅仅为了未来的可移植性而默认使用 Kubernetes 的组织正在限制云可以为他们提供的价值，尤其是考虑到大量更广泛的技术驱动因素在起作用。对于要最大化云价值的组织，他们应该利用可用于给定工作负载的最高阶 CSP 原生云服务，\n\n![](008vxvgGgy1h8eugkjya9j30u010jmzp.jpg)\n\n## 本实验\n\n我们的工作假设托管 Kubernetes 是一个不错的选择，应用程序架构和数据引力都是云迁移的最大因素。在某些场景下，Kubernetes 是唯一的选择，例如无法在 Google Cloud Run 和 Azure App Service 中运行的应用程序。并非所有 CSP 都提供可以以与 Kubernetes 类似的方式编排容器的服务 —— 相反，这些 CSP 选择提供托管 Kubernetes。因此，我们不会分析属于此类的工作负载，因为如果确实需要多云，它们很可能默认属于 Kubernetes。\n\n对于我们的实验，我们选择了一个由 Google 发布的 12-factor 应用程序，称为 [microservices-demo](https:\/\/github.com\/GoogleCloudPlatform\/microservices-demo)。然后，我们将应用程序置于谷歌云的 GKE、Azure AKS、AWS EKS 和 AWS ECS 中，并测量了使用 Kubernetes 在所有三个 CSP 之间迁移工作负载的工作量，以及将工作负载从 Google GKE 迁移到 AWS ECS 的工作量。工程工作的结果详述如下，记录的大部分工作是在初始系统设置中。我们认为，所有三种计算解决方案的进一步迁移将大大缩短，但计算解决方案之间也没有区别。\n\n![](008vxvgGgy1h8eugophbij30s402q0sw.jpg)\n\nmicroservices-demo app 的应用架构如下：\n\n![](008vxvgGgy1h8eugu4pawj30sg0nc75f.jpg)\n\n在应用程序运行且日志中没有错误并将日志卸载到日志聚合解决方案后，我们认为“迁移”已完成。虽然我们承认需要更多的努力来准备好产品生产；应用程序本身不是生产就绪产品，因此我们省略了这个范围。我们还增加了挑战，即我们不会修改微服务演示应用程序的源代码，因为更改源代码可以使我们的工作更轻松并影响我们的发现。\n\n## GKE\n\nGoogle 在其 [microservices-demo](https:\/\/github.com\/GoogleCloudPlatform\/microservices-demo) 中提供了所需的 Kubernetes 部署配置；但是，它不提供必要基础设施的代码。我们选择使用 GKE-Autopilot 类型的集群部署，让部署和管理变得更加轻松。[Autopilot](https:\/\/cloud.google.com\/kubernetes-engine\/docs\/concepts\/autopilot-overview) 类型的部署确保了 GKE 提供和管理集群的底层基础设施，包括节点和节点池，为我们提供了一个优化的集群和一个无需干预的体验。下面是应用程序在 GKE 中运行的架构。\n\n![](008vxvgGgy1h8eugmom1pj30sg0pvdi1.jpg)\n\n在 GKE 集群中启动和运行应用程序的过程如下：\n\n1. 为 GKE 设置所需的 VPC。\n2. 设置必要的 DNS 区域。external-dns 服务将使用这些区域为应用程序创建所需的 DNS 记录。\n3. 使用 Autopilot 构建 GKE 集群\n4. 设置必要的服务帐户权限，以允许 Autopilot 配置基本的集群监控功能。\n5. 为 external-dns 创建必要的服务帐户来管理 DNS 记录。\n\nKubernetes 部署完成后，还需要为 Kubernetes 部署采取其他步骤：\n\n1. 安装外部 DNS 服务。\n2. **ManagedCertificate** 需要通过 **networking.gke.io\/v1** API 为负载均衡器上使用的 SSL 证书定义。\n3. 创建了一个使用 GKE [VPC 原生集群中](https:\/\/cloud.google.com\/kubernetes-engine\/docs\/concepts\/alias-ips)[的网络端点组 (NEG)](https:\/\/cloud.google.com\/load-balancing\/docs\/negs#zonal-neg) 的**服务**定义。Ingress 是使用容器原生负载均衡的推荐方式，因为它具有许多可简化 NEG 管理的功能。当 [NEG 与 GKE Ingress 一起使用时](https:\/\/cloud.google.com\/kubernetes-engine\/docs\/how-to\/container-native-load-balancing)，Ingress 控制器有助于创建负载均衡器的所有方面，包括创建虚拟 IP 地址、转发规则、健康检查、防火墙规则等。\n4. **FrontEndConfig** 定义是通过 networking.gke.io\/v1beta1 API 创建的，以确保存在将 HTTP 流量重定向到 HTTPS 的规则。\n5. 利用先前创建的服务和 FrontEndConfig 创建了一个新的 **Ingress 。**这个 Ingress 定义也将被 external-dns 服务利用，它将配置必要的记录以指向负载均衡器。\n\n总的来说，集群的配置和带有额外配置的微服务演示的部署大约花了两天时间。\n\n但是，必须注意定义负载均衡器配置并确保将 HTTP 重定向到 HTTPS 的 Ingress 规则使用的 API 仍处于测试阶段 (networking.gke.io\/v1beta1)；此配置的另一个关键注意事项是 FrontEndConfig 还将创建另一个负载均衡器来转发流量，如下所示。\n\n![](008vxvgGgy1h8eugqg2pej312w0dvq3o.jpg)\n\n## AKS — 两天的迁移工作\n\n对于 AKS，为了测试可移植性的易用性，我们决定使用利用 [AKS 虚拟节点](https:\/\/docs.microsoft.com\/en-us\/azure\/aks\/virtual-nodes)类型部署的 AKS 群集。使用虚拟节点，我们可以快速配置 pod，并且只需按秒为它们的执行时间付费。你无需等待 Kubernetes 集群自动缩放器部署 VM 计算节点来运行额外的 pod。但是，我们注意到微服务演示的**前端**和 **redis-cart** 部署的组件在特定负载下会间歇性地失败。因此，我们决定将这些组件部署到一个单独的节点池，并允许将剩余的服务部署到虚拟节点。下面是应用程序在 AKS 中运行的架构。\n\n![](008vxvgGgy1h8eugrzmjij30sg0m6n00.jpg)\n\n为了设置集群并部署微服务演示，我们采取了以下步骤：\n\n1. 为 AKS 设置 Azure 网络。作为这项工作的一部分，创建了三个独立的子网，一个用于虚拟节点 (ACI)，一个供网关使用，另一个用于其余集群组件。\n2. 设置必要的 DNS 区域。\n3. 为 AKS 群集设置 Log Analytics 工作区。\n4. 设置 AKS 群集。\n5. 启用了以下 Kubernetes 附加组件：\n6. 监控：Container Insights 监控集群\n7. 虚拟节点 (ACI)：在集群中使用虚拟节点\n8. ingress-appgw：带有 AKS 群集的应用程序网关入口控制器\n\n基础设施完成后，需要完成以下 Kubernetes 部署配置：\n\n1. 安装和配置**外部 DNS** 服务\n2. 安装和配置**的证书管理器**服务\n3. 更改了微服务演示提供的部署定义，以允许通过定义所需的 **nodeSelector** 和 **tolerations 在虚拟节点节点池上完成部署**\n4. 需要定义使用 ingress-appgw 附加组件和 cert-manager 服务的 Ingress **。**这个 Ingress 定义也将被 external-dns 服务利用，它将配置必要的记录以指向网关。\n\n总的来说，集群的配置和带有额外配置的微服务演示的部署大约花了两天时间。\n\n但是，必须注意的是，由于整个 Kubernetes 体验所需的附加组件和服务，维护此集群所需的工作量增加了。与 GKE Autopilot 不同，需要使用虚拟节点和应用程序网关进行监控的 AKS 附加组件。此外，AKS 需要 cert-manager 服务来自动化负载均衡器上的证书管理。所有这些组件都需要集群管理员进行维护。\n\n## EKS — 两天的迁移工作\n\n考虑到我们拥有来自 GKE 部署的 Kubernetes 清单，将工作负载转移到 EKS 并不像你想象的那么简单。我们选择不将 Fargate 用于 EKS 实施，因为当时日志记录需要一个 sidecar，我们选择了运行 DaemonSet 的 EC2 来收集日志。下面是 EKS 迁移的架构，后面是对迁移过程的描述。\n\n![](008vxvgGgy1h8euhdkejej30sg0sggol.jpg)\n\n### 环境配置\n\n1. 为 EKS 设置 VPC。\n2. 设置 Route53 域。\n3. 从 ACM 提供证书。\n4. 构建 EKS 集群。\n5. 为集群供应受管节点组。\n\n### 迁移努力\n\n1. 安装 Kubernetes 插件：\n2. 外部 DNS 插件\n3. AWS 负载均衡器控制器\n4. 使用 Fluent Bit 的 AWS Container Insights\n5. 修改 Kubernetes 清单以使用新插件：\n6. 修改了 **nodeSelector** 和 **tolerations**\n7. 为处理创建 ALB、管理 R53 记录和应用先前创建的证书的应用程序的外部公开端点创建入口定义\n\n这个过程花了我们大约两天的时间，其中大部分时间用于分析我们需要哪些插件才能通过 EKS 生态系统实现我们的目标。\n\n但是，与 AKS 配置非常相似，我们有一些插件需要安装、监控和运行，以便应用程序在 EKS 集群中成功运行。因此，组织将承担这些第三方插件的升级、维护和事件管理的负担。\n\n## ECS — 两天的迁移工作\n\n将工作负载转移到 ECS 起初似乎是一项艰巨的工作，但并不是那么具有挑战性。在让应用程序运行时，我们遇到了一个重大挑战。该应用程序使用其 GRPC 调用的不安全设置进行了硬编码。这导致了几个小时的挠头，因为我们可以直接访问容器，但无法通过 AWS Application Load Balancer 访问它们，因为 ALB 现在不支持 GRPC 的未加密流量。这不是 EKS 的问题，因为服务到服务的调用确实利用 ALB 进行东 \/ 西流量，以支持内置的 Kubernetes 服务。虽然这看起来像是一个障碍，但我们能够快速转向使用 AWS Cloud Map 来代替服务到服务的流量。解决 GRPC 问题后，ECS 解决方案的架构和步骤如下：\n\n![](008vxvgGgy1h8euhbqubij30o80sg418.jpg)\n\n### 环境配置\n\n1. 为 ECS 设置 VPC。\n2. 设置 Route53 域。\n3. 从 ACM 提供证书。\n4. 设置 Cloud Map。\n5. 设置配置了 Fargate 和 Container Insights 的 ECS 集群。\n\n### ECS 迁移工作\n\n1. 利用来自 GKE 部署的 Kubernetes 清单来编写将部署 ECS 任务、ECS 服务、Route53 记录、配置 ALB 和配置 Cloud Map 的 Terraform 脚本。\n\n这个过程花了我们大约两天的时间，我们让应用程序运行并记录日志，而实现日志记录所需的虚拟机和插件为零。\n\nECS 与所有其他基于 Kubernetes 的部署之间最大的开发工作差异在于 ECS 任务和服务部署 Terraform 脚本的创建。这些花了一个下午的时间来编写，但是一旦我们编写了一次代码，我们就能够将它重新用于所有其他服务。在这种情况下，平台升级、维护和事件管理的维护负担转移到责任共担模型的 AWS 端，从而使组织的员工腾出时间来更多地关注驱动业务价值的差异化代码。\n\n## 总结\n\n总而言之，部署到托管 Kubernetes 不能被认为是完全可移植的（或可移植性的银弹），因为你需要安装和管理附加组件或服务以确保应用程序被部署和配置为它应该是样子。你在部署拓扑的核心组件上花费的时间更少，并且当你希望拥有关键功能时，大多数依赖于云的配置都会发挥作用，例如：\n\n- 自动 DNS 记录管理\n- 自动化托管证书\n- 监控\n- 负载均衡器管理\n- 秘密整合\n- 缩放\n\n如果你使用托管节点（例如，AWS Fargate、AKS 虚拟节点、GKE Autopilot），你将遇到可能影响应用程序行为的限制，例如无法托管状态或使用守护进程集类型部署。回退到受管节点意味着，作为集群管理员，你现在负责管理升级和扩展。综上所述，Kubernetes 是企业维护性更高的解决方案，但这并不是坏事，因为它也是最灵活的解决方案。\n\n虽然肯定存在与 CSP 服务相关的云可移植性问题，但我们认为将这些问题应用于容器编排时并没有多大意义。从 GKE 迁移到 ECS Fargate 的努力类似于从 GKE 迁移到 EKS\/AKS 的努力，我们认为这证明了“可移植性”的论点并没有真正站得住脚。当你转向利用高阶计算服务并开始将你的数据也转移到 CSP 管理的服务时，云中的供应商锁定在某种程度上是不可避免的。Kubernetes 是一个强大的工具，如果你有充分的技术原因（其中有很多），或者只是需要应用程序在云内外运行，那么 Kubernetes 可能适合你。然而，如果你想了解有关容器和多云可移植性的更多信息，我们的同事最近发表了[一篇文章](https:\/\/www.mckinsey.com\/business-functions\/mckinsey-digital\/our-insights\/getting-the-most-from-cloud-services-and-containers)来讨论这一点。\n', '\/trans\/does-kubernetes-really-give-you-multicloud-portability\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讨论业务领导者和架构师选择使用 Kubernetes 的原因。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Gateway API：Kubernetes 和服务网格入口中网关的未来</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/11/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Gateway API：Kubernetes 和服务网格入口中网关的未来', '本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。', '\n本文将以 Kubernetes Ingress、Istio 和 Envoy Gateway 为例，向你介绍 Kubernetes 中的入口网关和 Gateway API，同时介绍 Gateway API 使得 Kubernetes 和服务网格入口网关融合的新趋势。\n\n## 本文观点\n\n- Ingress 作为 Kubernetes 的初代入口网关，它的资源模型过于简单以致于无法适应当今的可编程网络；\n- Gateway API 作为 Kubernetes 入口网关的最新成果，它通过角色划分将关注点分离，并提供跨 namespace 支持使其更适应多云环境，已获得大多数 API 网关的支持；\n- 入口网关（南北向）与服务网格（东西向，集群内路由）存在部分功能重叠，Gateway API 为两者的融合提供了新的参考模型；\n\n## Kubernetes 入口网关的历史\n\n2014 年 6 月 Kubernetes 开源，起初只能使用 NodePort 和 LoadBalancer 类型的 Service 对象来暴露集群内服务，后来才诞生了 [Ingress](https:\/\/kubernetes.io\/zh-cn\/docs\/concepts\/services-networking\/ingress\/)，两年后（Kubernetes 1.2）Ingress API 进入 Beta 版本，随后为了保持其轻量和可移植的特性，Ingress API 相较于 Kubernetes 其他 API 发展得比较缓慢，直到 Kubernetes 1.19 它才升级到 GA。\n\nIngress 的主要目标是用简单的、声明性的语法来暴露 HTTP 应用。你可以在 Kubernetes 中部署多种 Ingress Controller，并在创建 Ingress 的时候通过 IngressClass 指定该网关使用的控制器，或者在 Kubernetes 中设置默认的默认的 IngressClass。Kubernetes 默认只支持 AWS、GCE 和 Nginx Ingress Controller，同时还支持大量的[第三方 Ingress Controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/#additional-controllers)。\n\n下图展示了 Kubernetes Ingress 的工作流程。\n\n![Kubernetes Ingress 工作流程](ingress-flow.svg)\n\n详细流程如下：\n\n1. Kubernetes 集群管理员在 Kubernetes 中部署 Ingress Controller；\n2. Ingress Controller 会持续监视 Kubernetes  API Server 中的 IngressClass 和 Ingress 对象的变动；\n3. 管理员应用 IngressClass 和 Ingress 来部署网关；\n4. Ingress Controller 会根据管理员的配置来创建对应的入口网关并配置路由规则；\n5. 如果在云中，客户端会访问该入口网关的负载均衡器；\n6. 网关将根据 HTTP 请求中的 host 和 path 将流量路由到对应的后端服务；\n\nIstio 同时支持 Ingress 和 Gateway API，下面是一个使用 Istio 入口网关的配置示例，在后文中会使用 Gateway API 创建该配置。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: IngressClass\nmetadata:\n  name: istio\nspec:\n  controller: istio.io\/ingress-controller\n---\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: ingress\nspec:\n  ingressClassName: istio\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port: 8000\n\u0060\u0060\u0060\n\n注意：Ingress 的 spec 中必须在 \u0060ingressClassName\u0060 字段中指定使用的 \u0060IngressClass\u0060，否则将无法创建对应的入口网关。\n\n## Kubernetes Ingress 的局限性\n\n虽然 \u0060IngressClass\u0060 实现了入口网关与后台实现的解耦，但是它仍然有着巨大的局限性：\n\n- Ingress 的配置过于简单，仅支持 HTTP 协议路由；\n- HTTP 路由仅支持 host 和 path 匹配，对于高级路由功能没有通用配置，只能通过 annotation 来实现，比如[使用 Nginx Ingress Controller 实现 URL 重定向](https:\/\/help.aliyun.com\/document_detail\/86533.html#section-xsg-g5g-1uy)，需要配置 \u0060nginx.ingress.kubernetes.io\/rewrite-target\u0060 annotation，已经无法适应可编程路由的需求；\n- 不同命名空间中的服务要绑定到同一个网关中的情况在实际情况下经常出现，而入口网关无法在多个命名空间中共享；\n- 入口网关的创建和管理的职责没有划分界限，导致开发者不仅要配置网关路由，还需要自己创建和管理网关；\n\n## Kubernetes Gateway API\n\nGateway API 是一个 API 资源的集合 —— \u0060GatewayClass\u0060、\u0060Gateway\u0060、\u0060HTTPRoute\u0060、\u0060TCPRoute\u0060、\u0060ReferenceGrant\u0060 等。Gateway API 暴露了一个更通用的代理 API，可以用于更多的协议，而不仅仅是 HTTP，并为更多的基础设施组件建模，为集群运营提供更好的部署和管理选项。\n\n另外 Gateway API 通过将资源对象分离，实现配置上的解耦，可以由不同的角色的人员来管理，其中的 API 对象如下图所示。\n\n![Gateway API 及角色](gateway-api-roles.svg)\n\n下面是在 Istio 中使用 Gateway API 的示例。\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: default\n    hostname: \u0022*.example.com\u0022\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: http\n  namespace: default\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\u0022httpbin.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/\n    backendRefs:\n    - name: httpbin\n      port: 8000\n\u0060\u0060\u0060\n\n与 Ingress 类似，Gateway 使用 \u0060gatewayClassName\u0060 声明其使用的控制器，该控制器需要平台管理员创建，并允许客户端对 \u0060*.example.com\u0060 域名的请求。应用开发者可以在其服务所在的命名空间中，在此示例中是 \u0060default\u0060 创建路由规则，并通过 \u0060parentRefs\u0060 绑定到 Gateway 上，当然这必须是在 Gateway 明确允许其绑定的情况下（通过 \u0060allowRoutes\u0060 字段中的规则设置）。\n\n当你应用上面的配置后，Istio 会自动为你创建一个负载均衡网关，下图展示了 Gateway API 的工作流程。\n\n![Gateway API 工作流程](gateway-api-flow.svg)\n\n详细流程如下：\n\n1. 基础设施供应商提供了 \u0060GatewayClass\u0060 和 Gateway 控制器；\n2. 平台运维部署 Gateway（可以部署多个，或使用不同的 \u0060GatewayClass\u0060）；\n3. Gateway Controller 会持续监视 Kubernetes  API Server 中的 \u0060GatewayClass\u0060 和 \u0060Gateway\u0060 对象的变动；\n4. Gateway Controller 会根据集群运维的配置来创建对应的网关；\n5. 应用开发者应用 xRoute 并绑定服务上；\n6. 如果在云中，客户端会访问该入口网关的负载均衡器；\n7. 网关将根据流量请求中的匹配条件将路由到对应的后端服务；\n\n从以上步骤中我们可以看出 Gateway API 相比 Ingress 有了明确的角色划分，而且路由规则可以与网关配置解耦，这大大增加了管理的灵活性。\n\n下图展示了流量接入网关后经过处理的流程。\n\n![网关处理流程图](traffic-flow.svg)\n\n从图中我们可以看出路由是与网关绑定的，路由一般与其后端服务部署在同一个命名空间中，如果在不同的命名空间中时，需要在 [\u0060ReferenceGrant\u0060](https:\/\/gateway-api.sigs.k8s.io\/api-types\/referencegrant\/) 中明确赋予该路由跨命名空间的引用权限，例如下面的 \u0060foo\u0060 命名空间中的 HTTPRoute \u0060foo\u0060 可以引用 \u0060bar\u0060 命名空间中的 \u0060bar\u0060 服务。\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\nmetadata:\n  name: foo\n  namespace: foo\nspec:\n  rules:\n  - matches:\n    - path: \/bar\n    forwardTo:\n      backend:\n      - name: bar\n        namespace: bar\n---\nkind: ReferenceGrant\nmetadata:\n  name: bar\n  namespace: bar\nspec:\n  from:\n  - group: networking.gateway.k8s.io\n    kind: HTTPRoute\n    namespace: foo\n  to:\n  - group: \u0022\u0022\n    kind: Service\n\u0060\u0060\u0060\n\n目前，Gateway API 仅支持 \u0060HTTPRoute\u0060，\u0060TCPRoute\u0060、\u0060UDPRoute\u0060、\u0060TLSRoute\u0060 和 \u0060GRCPRoute\u0060 还在实验阶段。Gateway API 已经得到了大量的网关和服务网格项目的支持，请[在 Gateway 官方文档中查看支持状况](https:\/\/gateway-api.sigs.k8s.io\/implementations\/)。\n\n## 入口网关与服务网格\n\n服务网格主要关注的是东西向流量，即 Kubernetes 集群内部的流量，但是大部分服务网格同样提供了入口网关功能，例如 Istio。但是 Istio 的功能和 API 过于复杂，在本文中我们就以 SMI 为例来说明入口网关和服务网格的关系。\n\n[SMI](https:\/\/smi-spec.io\/)（Service Mesh Interface）是 CNCF 的孵化项目，开源与 2019 年，它定义了独立于供应商的在 Kubernetes 中运行的服务网格通用标准。\n\n下图说明 Gateway API 与服务网格 API 的重叠点。\n\n![Gateway API 与 SMI 有部分重合](gateway-smi-overlay.svg)\n\n从图中我们可以看到 Gateway API 与 SMI 在流量规范部分有明显的重叠。这些重叠导致同样的功能，需要在 Gateway API 和服务网格中重复实现。\n\n### Istio 服务网格\n\n当然，并不是所有的服务网格是完全符合 SMI 标准，Istio 是目前最流行的服务网格实现，它提供了丰富的流量管理功能，但是没有对这些功能制定单独的策略 API，而是耦合在 \u0060VirtualService\u0060 和 \u0060DestinationRule\u0060 中，如下所示。\n\n**VirtualService**\n\n- 路由：金丝雀发布、基于用户身、URI、Header 等匹配路由等；\n- 错误注入：HTTP 错误代码注入、HTTP 延时注入；\n- 流量切分：基于百分比的流量切分路由；\n- 流量镜像：将一定百分比的流量镜像发送到其他集群；\n- 超时：设置超时时间，超过设置的时间请求将失败；\n- 重试：设置重试策略，如触发条件、重试次数、间隔时间等；\n\n**DestinationRule**\n\n- 负载均衡：设置负载均衡策略，如简单负载均衡、区域感知负载均衡、区域权重负载均衡；\n- 熔断（Circuit Breaking）：通过异常点检测（Outlier Detection）和连接池设置将异常节点从负载均衡池中剔除；\n\n\u0060VirtualService\u0060 主要处理路由相关功能，而 \u0060DestinationRule\u0060 负责集群节点的开合和负载均衡。\n\n### Gateway API 融合 Kubernetes 和服务网格的入口网关\n\n正如上文所述，Gateway API 与服务网格之间有部分功能交集，为了减少重复开发，促成对 Gateway API 与服务网格之间共同关注点的建模，Gateway API 工作组提出了 [GAMMA](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/)（Gateway API Mesh Management and Administration）倡议。\n\n在该倡议的倡导下，那些在不同网关实现中的细节各不相同的高级流量管理功能，例如超时、重试、健康检查等，全部通过[策略附件](https:\/\/gateway-api.sigs.k8s.io\/references\/policy-attachment\/)（Policy Attachment）的方式将由各个提供商来实现。你可以通过通过 \u0060targetRef\u0060 字段指定策略附件所附加到的资源对象，例如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: networking.acme.io\/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: foo\nspec:\n  override:\n    maxRetries: 10\n  default:\n    maxRetries: 5\n  targetRef:\n    group: gateway.networking.k8s.io\/v1alpha2\n    kind: HTTPRoute\n    name: foo\n\u0060\u0060\u0060\n\n在这里例子中重试策略被附加到了名为 \u0060foo\u0060 和 \u0060HTTPRoute\u0060 上。策略附件附加到不同的资源对象上，其生效的优先级也不同，例如 GatewayClass 是集群级的资源，如果策略附件覆盖在它上面的话，将优先生效。\n\n你可以给附加策略指定 \u0060override\u0060 和 \u0060default\u0060 值，其在入口和网格内不同资源上的层次结构的优先级是如下图所示。\n\n![Kubernetes 入口与网格中的覆盖和默认值的优先级](policy-attachment-priority.svg)\n\n目前，Gateway API 正在探索用来处理网格流量，并提出了一些[设计方案](https:\/\/docs.google.com\/document\/d\/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU\/edit#heading=h.6ks49gf06yii)。\n\n## Envoy Gateway\n\n2022 年 10 月 Envoy Gateway 首个开源版本 [v0.2 发布](\/blog\/envoy-gateway-release\/)，这是一个基于 Envoy 代理的遵循 Gateway API 而创建的网关，[Tetrate](https:\/\/tetrate.io) 是该项目的核心发起者之一。Envoy Gateway 的目标是降低用户采用 Envoy 作为 API 网关的障碍，以吸引更多用户采用 Envoy。它通过入口和 L4\/L7 流量路由，表达式、可扩展、面向角色的 API 设计，使其成为供应商建立 API 网关增值产品的基础。\n\n早在 Envoy Gateway 发布之前，Envoy 作为最流行了云原生代理之一，已被大规模采用，有多款 Gateway 软件基于 Envoy 构建，Istio 服务网格使用它作为默认的 sidecar 代理，并通过 xDS 协议来配置这些分布式代理。在 Envoy Gateway 中，它同样使用 xDS 来配置 Envoy 集群，下图展示了 Envoy Gateway 的架构。\n\n![Envoy Gateway 架构图](envoy-gateway-arch.svg)\n\n基础设施供应商会为你提供 \u0060GatewayGlass\u0060，你可以通过创建一个 Gateway 声明来创建一个 Envoy Gateway，你在 Gateway 中的路由和策略附件会通过 xDS 协议发送给 Envoy 集群。\n\n关于 Envoy Gateway 的进一步介绍，请阅读：\n\n- [使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API](https:\/\/cloudnative.to\/blog\/hands-on-with-envoy-gateway\/)\n- [面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍](https:\/\/cloudnative.to\/blog\/envoy-gateway-to-the-future\/)\n\n## 总结\n\nGateway API 作为下一代 Kubernetes Ingress API，为 Kubernetes 网关供应商提供一定程度上的 API 规范，在保证其可移植性的前提下丰富了入口网关的功能，同时通过关注点分离方便不同角色的人员对网关进行管理。最后 GAMMA 倡议正在促进服务网格的入口网关与 Gateway API 的融合，策略附件可能将 Gateway API 的功能进一步扩展到东西向网关，我们拭目以待。\n\n## 参考\n\n- [Gateway API - jimmysong.io](\/book\/kubernetes-handbook\/service-discovery\/gateway\/)\n- [一文搞懂 Kubernetes Gateway API 的 Policy Attachment - atbug.com](https:\/\/atbug.com\/explore-k8s-gateway-api-policy-attachment\/)\n- [SMI 与 Gateway API 的 GAMMA 倡议意味着什么？- atbug.com](https:\/\/atbug.com\/why-smi-collaborating-in-gateway-api-gamma\/)\n- [Evolving the Kubernetes Ingress APIs to GA and Beyond - Christopher M Luciano, IBM \u0026 Bowei Du, Google](https:\/\/kccncna19.sched.com\/#)\n', '\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 Kubernetes 中的入口网关及 Gateway API，入口网关与服务网格融合的新趋势。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/evolving-kubernetes-networking-with-the-gateway-api/">[译] 利用 Gateway API 发展 Kubernetes 网络</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://kubernetes.io/blog/2021/04/22/evolving-kubernetes-networking-with-the-gateway-api/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('利用 Gateway API 发展 Kubernetes 网络', 'Gateway API 的出现解决了 Ingress 的可移植性问题，且有利于基于角色的访问设计。', '\nIngress 资源是 Kubernetes 众多成功案例中的一个。它创造了一个[多样化的 Ingress 控制器的生态系统](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/)，这些控制器以标准化和一致的方式在数十万个集群中使用。这种标准化有助于用户采用 Kubernetes。然而，在 Ingress 创建五年后，有迹象表明它被分割成不同但[惊人相似的 CRD](https:\/\/dave.cheney.net\/paste\/ingress-is-dead-long-live-ingressroute.pdf) 和 [过载的注释](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/nginx-configuration\/annotations\/)。Ingress 普遍存在的可移植性问题也限制了它的未来。\n\n那是在 2019 年圣地亚哥的 Kubecon 上，一群充满激情的贡献者聚集在一起，讨论 [Ingress 的发展](https:\/\/static.sched.com\/hosted_files\/kccncna19\/a5\/Kubecon%20San%20Diego%202019%20-%20Evolving%20the%20Kubernetes%20Ingress%20APIs%20to%20GA%20and%20Beyond%20%5BPUBLIC%5D.pdf)。拥挤的人群溢出到了街对面的酒店大堂，而讨论出来的东西后来被称为 [Gateway API](https:\/\/gateway-api.sigs.k8s.io\/)。这次讨论是基于几个关键的假设：\n\n1. 路由匹配、流量管理和服务暴露所依据的 API 标准已经商业化，对其实施者和用户提供的定制 API 的价值很小。\n2. 可以通过共同的核心 API 资源来表示 L4\/L7 的路由和流量管理。\n3. 可以在不牺牲核心 API 的用户体验的前提下，为更复杂的功能提供扩展性。\n\n## Gateway API 介绍\n\n这产出了一些设计原则，使 Gateway API 能够在 Ingress 的基础上进行改进。\n\n- **表达性**：除了 HTTP 主机 \/ 路径匹配和 TLS 之外，Gateway API 还可以表达 HTTP 头操作、流量加权和镜像、TCP\/UDP 路由等能力，以及其他只有在 Ingress 中通过自定义注释才能实现的能力。\n- **面向角色的设计**：API 资源模型反映了路由和 Kubernetes 服务网络中常见的责任分离。\n- **可扩展性**：这些资源允许在 API 的各个层面上进行任意的配置附加。这使得在最适当的地方进行细化的定制成为可能。\n- **灵活的一致性**：Gateway API 定义了不同的一致性级别 —— 核心（强制支持）、扩展（支持时可移植）和自定义（不保证可移植性），一起被称为[灵活的一致性](https:\/\/gateway-api.sigs.k8s.io\/concepts\/guidelines\/#conformance)。这促进了高度可移植的核心 API（如 Ingress），仍然为 Gateway 控制器实施者提供了灵活性。\n\n### Gateway API 是什么样子的？\n\nGateway API 引入了一些新的资源类型：\n\n- [**GatewayClasses**](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.GatewayClass) 是集群范围内的资源，作为模板，明确地定义由其衍生的网关的行为。这与 StorageClasses 的概念类似，但用于网络数据平面。\n- [**Gateway**](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.Gateway) 是 GatewayClasses 的部署实例。它们是执行路由的数据平面的逻辑表示，它可能是集群内的代理、硬件 LB 或云 LB。\n- **路由** 不是一个单一的资源，而是代表许多不同的特定协议的路由资源。[HTTPRoute](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.HTTPRoute) 有匹配、过滤和路由规则，这些规则被应用到可以处理 HTTP 和 HTTPS 流量的网关。同样，还有 [TCPRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.TCPRoute)、[UDPRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.UDPRoute) 和 [TLSRoutes](https:\/\/gateway-api.sigs.k8s.io\/references\/spec\/#networking.x-k8s.io\/v1alpha1.TLSRoute)，它们也有协议特定的语义。这种模式也允许网关 API 在未来逐步扩展其协议支持。\n\n![Gateway API 资源](008i3skNly1gpsl6ut5jlj31ed0u0jyp.jpg)\n\n### Gateway 控制器的实现\n\n好消息是，虽然 Gateway 还在 [Alpha](https:\/\/github.com\/kubernetes-sigs\/gateway-api\/releases) 阶段，但已经有几个 Gateway 控制器实现，你可以运行。由于它是一个标准化的规格，下面的例子都可以运行，而且功能应该完全相同。我们来看看如何安装和使用这些 Gateway 控制器。\n\n## 实践 Gateway API\n\n在下面的例子中，我们将展示不同的 API 资源之间的关系，并引导你完成一个常见的使用案例。\n\n- foo 团队在 foo 命名空间中部署了他们的应用程序。他们需要控制其应用程序的不同页面的路由逻辑。\n- Team bar 正在 bar 命名空间中运行。他们希望能够对他们的应用程序进行蓝绿部署以减少风险。\n- 平台团队负责管理 Kubernetes 集群中所有应用程序的负载均衡器和网络安全。\n\n下面的 foo-route 对 foo 命名空间中的各种服务进行路径匹配，并且有一个到 404 服务器的默认路由。这通过 \u0060foo.example.com\/login\u0060 和 \u0060foo.example.com\/home\u0060 分别暴露了 foo-auth 和 foo-home 服务。\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: foo-route\n  namespace: foo\n  labels:\n    gateway: external-https-prod\nspec:\n  hostnames:\n  - \u0022foo.example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: Prefix\n        value: \/login\n    forwardTo:\n    - serviceName: foo-auth\n      port: 8080\n  - matches:\n    - path:\n        type: Prefix\n        value: \/home\n    forwardTo:\n    - serviceName: foo-home\n      port: 8080\n  - matches:\n    - path:\n        type: Prefix\n        value: \/\n    forwardTo:\n    - serviceName: foo-404\n      port: 8080\n\u0060\u0060\u0060\n\n在同一个 Kubernetes 集群的 bar 命名空间中运行的 bar 团队也希望将他们的应用程序暴露在互联网上，但他们也希望控制自己的金丝雀发布和蓝绿部署。下面的 HTTPRoute 被配置为以下行为。\n\n- 对于访问 \u0060bar.example.com\u0060的流量：\n  - 将 90% 的流量发送到 bar-v1\n  - 将 10% 的流量发送到 bar-v2\n- 对于访问 \u0060bar.example.com\u0060 的流量，HTTP header 为 \u0060env: canary\u0060：\n  - 将所有的流量发送到 bar-v2\n\n\n![The routing rules configured for the bar-v1 and bar-v2 Services](008i3skNly1gpsl6via0rj31np0fxq5x.jpg)\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: bar-route\n  namespace: bar\n  labels:\n    gateway: external-https-prod\nspec:\n  hostnames:\n  - \u0022bar.example.com\u0022\n  rules:\n  - forwardTo:\n    - serviceName: bar-v1\n      port: 8080\n      weight: 90\n    - serviceName: bar-v2\n      port: 8080\n      weight: 10\n  - matches:\n    - headers:\n        values:\n          env: canary\n    forwardTo:\n    - serviceName: bar-v2\n      port: 8080\n\u0060\u0060\u0060\n\n### 路由和网关绑定\n\n因此，我们有两个 HTTPRoute 匹配并将流量路由到不同的服务。你可能想知道，这些服务在哪里可以访问？它们是通过哪些网络或 IP 暴露的？\n\n路由如何暴露给客户是由[路由绑定](https:\/\/gateway-api.sigs.k8s.io\/concepts\/api-overview\/#route-binding)管理的，它描述了路由和网关如何在彼此之间建立双向关系。当路由与网关绑定时，意味着它们的集体路由规则被配置在底层负载均衡器或代理上，并且路由可以通过网关访问。因此，网关是一个网络数据平面的逻辑表示，可以通过路由配置。\n\n![路由如何绑定到网关](008i3skNly1gpsl6w3e9aj31fo0gotay.jpg)\n\n### 行政授权\n\n网关和路由资源之间的分割允许集群管理员将一些路由配置委托给各个团队，同时仍然保留集中控制。下面的网关资源在 443 端口暴露 HTTPS，并用集群管理员控制的证书终止该端口的所有流量。\n\n\u0060\u0060\u0060yaml\nkind: Gateway\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: acme-lb\n  listeners:  \n  - protocol: HTTPS\n    port: 443\n    routes:\n      kind: HTTPRoute\n      selector:\n        matchLabels:\n          gateway: external-https-prod\n      namespaces:\n        from: All\n    tls:\n      certificateRef:\n        name: admin-controlled-cert\n\u0060\u0060\u0060\n\n下面的 HTTPRoute 显示了 Route 如何通过它的 \u0060kind\u0060（HTTPRoute）和资源标签（\u0060gateway=external-https-prod\u0060）确保它与 Gateway 的选择器相匹配。\n\n\u0060\u0060\u0060yaml\n# 匹配网关上所需的 kind 选择器\nkind: HTTPRoute\napiVersion: networking.x-k8s.io\/v1alpha1\nmetadata:\n  name: foo-route\n  namespace: foo-ns\n  labels:\n    # 匹配网关上所需的标签选择器\n    gateway: external-https-prod\n...\n\u0060\u0060\u0060\n\n### 以角色为导向的设计\n\n当你把它放在一起时，你有一个单一的负载均衡基础设施，可以被多个团队安全地共享。Gateway API 不仅是一个用于高级路由的更具表现力的 API，而且是一个面向角色的 API，为多用户基础设施而设计。它的可扩展性确保了它在保持可移植性的同时，还能为未来的使用场景而发展。最终，这些特性将使 Gateway API 在未来适应不同的组织模式和实施方式。\n\n### 尝试和参与\n有许多资源可供查阅，以了解更多。\n\n- 查阅[用户指南](https:\/\/gateway-api.sigs.k8s.io\/guides\/getting-started\/)，看看可以解决哪些用例。\n- 试用现有的网关控制器。\n- 或者[参与进来](https:\/\/gateway-api.sigs.k8s.io\/contributing\/community\/)，帮助设计并影响 Kubernetes 服务网络的未来！\n', '\/trans\/evolving-kubernetes-networking-with-the-gateway-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Gateway API 的出现解决了 Ingress 的可移植性问题，且有利于基于角色的访问设计。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/why-rbac-is-not-enough-for-kubernetes-api-security/">[译] 为什么 RBAC 不足以保障 Kubernetes 的安全？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么 RBAC 不足以保障 Kubernetes 的安全？', '所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。', '\nKubernetes 不再是（只是）好玩的游戏了。它正在被用于生产；它是关键任务；所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。 \n\n## 概述\n\n- **Kubernetes API 的设计与大多数现代 API 不同。** 它是基于意图的，这意味着使用 API 的人考虑的是他们想要 Kubernetes 做什么，而不是如何实现。其结果是一个令人难以置信的可扩展性、弹性，和一个强大而流行的系统。\n- **同时，其基于意图的 API 给安全带来了挑战。** 标准的访问控制解决方案（基于角色的访问控制、基于属性的访问控制、访问控制列表或 IAM 策略）都不够强大，无法强制执行基本的策略，比如谁可以更改 pod 上的标签，或者哪些镜像存储库是安全的。\n- **Kubernetes Admission Control 就是为了解决这个问题而设计的。** Kubernetes Admission Controller 并不能解决开箱即用的访问控制问题，但它们允许你使用 Webhook 来解决授权挑战与解耦策略。\n\n## Kubernetes 基于意图的 API\n\nKubernetes API 接受了一个与我们大家习惯的 API 范式截然不同的 API。今天的大多数 API 都是所谓的 *基于行动的（action-based）*，这意味着当你想到一个 API 调用时，你正在考虑你想要执行的行动，以改变软件的运行方式。例如，如果你想让一个应用程序暴露在互联网上，你可能会运行 API openport (443)，改变应用程序上的网络设置，使端口 443 打开。\n\n相比之下，Kubernetes 有所谓的 *基于意图的（intent-based）* API（最近在网络领域流行，例如 [SDXCentral](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.sdxcentral.com%2Fsdn%2Fdefinitions%2Fwhat-is-intent-based-networking%2F)），这意味着当你想要进行一个 API 调用时，你要考虑的是你希望该系统处于何种状态。你并不关心用什么操作来实现这种希望的状态。你只需告诉系统你想要什么（你的意图），系统就会想出如何实现它 —— 采取哪些动作将系统过渡到期望的状态。例如，你可以说你的应用程序应该运行 1.7 版本的二进制文件，应该使用带加密的持久存储，并且应该连接到互联网。系统会计算出如何升级或降级二进制文件，如何开启加密，以及如何重新配置网络以允许互联网连接。\n\n架构上的关键区别在于，*基于意图的* 系统既能理解系统当前所处的状态（有时称为 *实际状态* ），也能理解你对系统应该处于何种状态的意图（*期望状态*）。系统不断地计算两者之间的差距，并采取任何必要的行动使实际状态变成期望状态。用户可以直接通过 API 调用来改变期望状态，而依靠系统本身来改变实际状态。\n\n![](0081Kckwly1glqzp7lpo7j30l20ept9z.jpg)\n\nKubernetes 的 API 是基于意图的。每个 API 调用都允许你指定 Kubernetes 众多对象中的一个对象的期望状态：pod、service、ingress、configmap 等。例如，下面是你为一个 nginx 工作负载定义的期望状态。\n\n\u0060\u0060\u0060yaml\n# nginx-pod.yaml\nkind: Pod\napiVersion: v1\nmetadata:\n name: nginx\n labels:\n app: nginx\nspec:\n containers:\n - image: nginx\n name: nginx\t\n\u0060\u0060\u0060\n\n然后要把这个想要的状态发送到 Kubernetes，用 kubectl，把上面的 YAML 文件交给它就行了。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n假设你想改变 nginx 的版本，挂载一个外部卷，或者提供额外的配置，你更新 nginx-pod.yaml 文件到任何你想要的状态，然后再使用 kubectl apply。更新 nginx-pod.yaml 文件到任何需要的状态，然后再使用 kubectl apply。\n\n\u0060\u0060\u0060bash\nkubectl apply -f nginx-pod.yaml\n\u0060\u0060\u0060\n\n这里的关键要点是，你不是在运行像 updateVersion 或 mountVolume 这样的 API，而是在改变一些描述系统应该处于什么状态的 YAML，并通过运行 apply 来说\u0022 使之如此 \u0022。\n\nKubernetes 的 API 模型有几个优势：\n\n- **减少学习曲线**。你要学习每个对象的 YAML 格式和一系列动作，如创建、应用、获取、描述、删除。无论如何，你都需要学习每个对象的 YAML 配置格式（这样你才能读懂它）。相比之下，*基于动作的* API 还需要你学习可能是 1,000 个动作。\n- **可扩展性**。Kubernetes 支持自定义资源定义（CRD）。因此，除了所有常见的 pod、service、ingress 等，你还可以定义自己的资源。这是可能的，因为 API 表面不需要扩展来处理新的资源类型。你只需要写一些描述资源的 YAML，然后调用同样的十几个动作，例如：创建、应用、获取、描述、删除。\n- **分布式系统**。在使用商用硬件构建的云上运行大规模系统，要求在面对故障时具有难以置信的弹性。Kubernetes 基于意图的架构让它知道自己应该做什么，所以当比如说发生硬件故障时，它可以尝试进行补偿。Brian Grant（Google Kubernetes 的联合技术负责人）曾就 [声明式应用管理](https:\/\/docs.google.com\/document\/d\/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU\/edit) 和 [Kubernetes 资源管理](https:\/\/docs.google.com\/document\/d\/1RmHXdLhNbyOWPW_AtnnowaRfGejw-qlKQIuLKQWlwzs\/edit) 写过大量文章，并指出 Kubernetes API 是解决许多分布式系统问题的关键：故障、分布、自动伸缩、多所有者、可用性、性能、可逆性。\n\n## 为什么 RBAC 不足以保证 Kubernetes 的 API 安全？\n\n基于 Kubernetes 意图的 API 的挑战来自于你想要保护和保障 API 的安全时 —— 当你想要控制哪些人可以使用该 API 做什么时。想象一下，你是 Kubernetes 管理员，负责集群的运维、安全和合规性。新手 Kubernetes 开发人员需要护栏；安全团队需要控制和可见性；合规团队需要帮助将古老的规定映射到这个全新的系统；你从自己的经验中知道你需要采用哪些 Kubernetes 最佳实践。\n\n理想情况下，你会在 Kubernetes 本身内部通过设置访问控制来执行这些规则、法规和最佳实践。基于角色的访问控制（RBAC）是几十年来的解决方案，使你能够控制哪些用户可以在哪些资源上运行哪些 API。Kubernetes RBAC（自 [2017 年末](https:\/\/kubernetes.io\/blog\/2017\/10\/using-rbac-generally-available-18\/) 开始提供）是你的第一道防线。它可以让你为特定的用户组提供对资源的只读访问。它让你通过给不同的用户组分配 Kubernetes 的不同部分（也就是 *namespace*）来隔离不同的用户组（虽然不是完全隔离）。它可以让你限制 service account\n的权限。所有这些都是有价值的。\n\n但与基于动作的系统相比，RBAC 处理了绝大部分的访问控制需求，Kubernetes 中的 RBAC 由于其基于意图的 API，提供的控制 *要少得多*。从 API 的角度来看，只有十几个动作，这意味着如果 alice 可以更新一个资源，她就可以更新这个资源的任何部分。\n\n例如，SRE 需要读取集群中的大部分资源，以便在出现问题时能够诊断出问题。但当 SRE 发现某个节点上出现问题时，例如邻居有噪音，她可能需要对该节点进行排空（drain），以便将工作负载转移到不同的节点上，缓解问题。不幸的是，API 没有 drain 动作 —— 那些是 CLI 提供的宏，只是更新节点上的注释。使用 RBAC 试图达到这个级别的粒度是繁琐而复杂的，以至于不切实际。\n\n下面的基于意图的 K8s RBAC 图从概念上显示了你必须使用 RBAC 的工作内容 —— 你可以选择哪些用户 \/ 操作 \/ 资源组合是允许的。\n\n![](0081Kckwly1glr08337z4j30b908s75g.jpg)\n\n相反，想象一下，如果 Kubernetes 是基于动作的（例如，它包括 cordon、drain、setImage、mountVolume、openPort 等 API）。那么我们就可以使用 RBAC 来授予读以及 cordon 和 drain，但没有其他的功能。基于动作的 API 只是有更多的名字，你可以在编写 RBAC 策略时使用。\n\n![](0081Kckwly1glr0978kbej30bc0d5wgf.jpg)\n\n简而言之，Kubernetes API 提供了一个强大的、可扩展的、统一的资源模型，但也正是这个资源模型使得 RBAC 对于很多用例来说过于粗粒度。RBAC 所能提供的控制是非常宝贵的，但比起其他系统，RBAC 还远不能满足 Kubernetes 的需要。\n\n### 我们需要什么来保证 K8s 的 API 安全？\n\n那么如果 RBAC 不能提供足够的控制，我们该怎么做呢？我们来看一个例子。\u0022所有的 pod 必须只使用来自受信任的存储库的镜像\u0022（比如说，hooli.com）任何时候有人运行，比如说，kubectl apply，访问控制系统需要根据用户、动作 apply 和描述 pod 的 YAML 做出决定。\n\n\u0060\u0060\u0060yaml\nkind: Pod\nmetadata:\n  labels:\n    app: nginx\n  name: nginx-1493591563-bvl8q\n  namespace: production\nspec:\n  containers:\n  - image: nginx\n    name: nginx\n    securityContext:\n      privileged: true\n  - image: hooli.com\/frontend\n    name: frontend\n    securityContext:\n      privileged: true \n dnsPolicy: ClusterFirst\n restartPolicy: Always\n\u0060\u0060\u0060\n\n为了做出正确的决策，访问控制系统需要提取镜像名称列表（如\u0060nginx\u0060和\u0060hooli.com\/frontend\u0060），并进行字符串操作以提取仓库的名称（如默认的 repo 和 hooli.com）。\n\n一种方案是将一堆关于 Kubernetes 资源的知识构建到访问控制系统本身。然后管理员可以写一个策略，比如谁可以 \u0060update-labels\u0060，\u0060permitted-image-registries\u0060 是什么，等等。这就是大多数系统的做法 —— 发明一堆权限，然后在上面建立一个自定义的访问控制系统。\n\n但是构建一个自定义的访问控制系统对于 Kubernetes 来说是行不通的，因为它允许用户和厂商发明自己的 YAML 格式（自定义资源定义），并安装实现这些格式的代码。所以 Kubernetes 的资源可扩展性要求任何定制的 Kubernetes 访问控制系统本身都是可扩展的。\n\n所以，不管我们做什么，我们都需要一个访问控制系统，让管理员编写策略：\n\n- 通过 YAML 文件的层次结构进行递减。\n- 对数组中的元素进行迭代。\n- 操作字符串、IP、数字等。\n\n标准的访问控制范式都不能满足这些要求。这包括基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）、访问控制列表（ACL），甚至是 IAM 风格的策略。\n\n### 使用准许控制来应急\n\n幸运的是，Kubernetes 团队预见到了这个问题，并创建了一个 [Admission Control](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fkubernetes.io%2Fdocs%2Freference%2Faccess-authn-authz%2Fadmission-controllers%2F) 机制，在这里你可以把控制的范围远远超过 RBAC 和标准的访问控制机制。Kubernetes API 服务器提供了一条访问控制的管道，分为 Authorization（如 RBAC），和 Admission。\n\n![](0081Kckwly1glr2h345xpj30rg06rq42.jpg) \n\n授权（Authorization）发生在每次 API 调用上，而准许（Addmission）只发生在更新（创建、更新和删除）上。通过授权，你将获得以下信息以做出决定：\n\n- **用户**：用户、组、认证提供的额外属性。\n- **动作**：路径、API 动词、HTTP 动词。\n- **资源**：资源、子资源、命名空间、API 组。\n\n通过 Admission，你会得到一个 YAML 中的 AdmissionReview 对象。它包括所有关于资源被修改的信息，以做出任何你想要的决定（见下面的 \u0060request.object\u0060）。\n\n\u0060\u0060\u0060yaml\napiVersion: admission.k8s.io\/v1beta1\nkind: AdmissionReview\nrequest:\n  kind:\n    group: \u0027\u0027\n    kind: Pod\n    version: v1\n  namespace: frontend\n  object:\n    metadata:\n      creationTimestamp: \u00272018-10-27T02:12:20Z\u0027\n      labels:\n        app: nginx\n      name: nginx\n      namespace: frontend\n      uid: bbfee96d-d98d-11e8-b280-080027868e77\n    spec:\n      containers:\n      - image: nginx\n        imagePullPolicy: Always\n        name: nginx\n        resources: {}\n        terminationMessagePath: \u0022\/dev\/termination-log\u0022\n        terminationMessagePolicy: File\n        volumeMounts:\n        - mountPath: \u0022\/var\/run\/secrets\/kubernetes.io\/serviceaccount\u0022\n        name: default-token-tm9v8\n        readOnly: true\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      schedulerName: default-scheduler\n      securityContext: {}\n      serviceAccount: default\n      serviceAccountName: default\n      terminationGracePeriodSeconds: 30\n      tolerations:\n      - effect: NoExecute\n        key: node.kubernetes.io\/not-ready\n        operator: Exists\n        tolerationSeconds: 300\n      - effect: NoExecute\n        key: node.kubernetes.io\/unreachable\n        operator: Exists\n        tolerationSeconds: 300\n      volumes:\n      - name: default-token-tm9v8\n        secret:\n          secretName: default-token-tm9v8\n    status:\n      phase: Pending\n      qosClass: BestEffort\n    oldObject: \n    operation: CREATE\n    resource:\n      group: \u0027\u0027\n      resource: pods\n      version: v1\n    uid: bbfeef88-d98d-11e8-b280-080027868e77\n    userInfo:\n      groups:\n      - system:masters\n      - system:authenticated\n      username: minikube-user \n\u0060\u0060\u0060\n\n当然，你可以通过编写、部署和维护实现准入控制 webhook 协议（一个简单的 HTTP\/json API）的自定义代码，编写任何你喜欢的逻辑来保护你的 API。现在，如果你不想支持和维护自定义代码，你可以使用 [Open Policy Agent](https:\/\/medium.com\/r\/?url=https%3A%2F%2Fwww.openpolicyagent.org) 作为 Kubernetes [准入控制器](https:\/\/www.openpolicyagent.org\/docs\/latest\/kubernetes-tutorial\/)，并利用其声明式策略语言。该语言包括上述所需的表达能力：迭代、点注和 50 多个内置的可用于字符串操纵等。更多信息，请参见 [\u0022 利用 Open Policy Agent 确保 Kubernetes API 安全 \u0022 一文](https:\/\/blog.openpolicyagent.org\/securing-the-kubernetes-api-with-open-policy-agent-ce93af0552c3)。\n\n## 总结\n\n在这篇文章中，我们深入研究了 Kubernetes 所面临的 API 安全挑战，并重点介绍了以下几个关键要点：\n\n- Kubernetes 基于意图的 API 让用户专注于他们希望 Kubernetes 处于什么状态，而不是如何实现它。\n- 基于意图的方法的核心好处之一是，它使 Kubernetes 在面对故障时具有弹性。因为系统知道自己应该做什么，所以当故障发生时，Kubernetes 知道如何恢复。\n- Kubernetes 的 API 还提供了巨大的可扩展性。用户可以创建自己的自定义资源，而无需扩展 API。\n- Kubernetes 的 API 所面临的挑战是，一个访问控制决策可能需要分析一个任意的 YAML 文档，例如使用点符号、迭代和字符串操纵。标准的访问控制系统，如 RBAC、ABAC、ACLs 和 IAM，根本没有足够的表达能力。\n- Kubernetes 团队引入了准入控制（Admission Control），以赋予用户控制 API 的额外权力。你可以使用声明式授权解决方案（如 Open Policy Agent）作为 Kubernetes Admission Controller，为你提供所需的表达能力，以克服这些新的访问挑战，并提供真正有效的粒度。\n', '\/trans\/why-rbac-is-not-enough-for-kubernetes-api-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">所有旧有的安全和合规规则和法规都需要以某种方式加装到 Kubernetes 上。不幸的是，像 RBAC 这样的旧的访问控制工具根本无法应对挑战。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-amazon-eks-distro/">[译] 亚马逊 EKS 发行版（EKS-D）介绍</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('亚马逊 EKS 发行版（EKS-D）介绍', '本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。', '\n今天，我们发布了 [Amazon EKS Distro](https:\/\/distro.eks.amazonaws.com\/)（EKS-D），这是一个基于 [Amazon Elastic Kubernetes Service](https:\/\/amazonaws-china.com\/eks\/)（Amazon EKS）的 Kubernetes 发行版，并由 Amazon EKS 用于创建可靠和安全的 Kubernetes 集群。通过 EKS-D，你可以依赖 EKS 部署的相同版本的 Kubernetes 及其依赖项。这包括最新的上游更新以及扩展的安全补丁支持。EKS-D 遵循与亚马逊 EKS 相同的 Kubernetes 版本发布周期，我们以 [GitHub 上的开源项目的方式](https:\/\/github.com\/aws\/eks-distro) 提供。\n\n在这篇文章中，我们将介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。\n\n## 什么是 EKS-D？\n\n通过 EKS Distro，你现在可以在通过 EKS 提供的相同 Kubernetes 发行版上实现标准化。这意味着你现在可以手动部署可靠和安全的集群，而无需持续测试和跟踪 Kubernetes 更新、依赖性和安全补丁。每个 EKS Distro 版本都遵循 [EKS](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar) 验证新 Kubernetes 版本兼容性的 [流程](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/kubernetes-versions.html#kubernetes-release-calendar)。你还可以选择使用提供的构建环境设置、工具和我们发布的镜像的哈希值重现 EKS Distro 的构建，以确认你的下载在传输过程中没有被篡改。通过 EKS-D，我们为社区支持到期后的 Kubernetes 版本提供了扩展支持，更新了以前版本的构建，现在有了最新的安全补丁。\n\n在过去两年大规模运营 Amazon EKS 之后（我们说的是全球数百万个各种规模的集群），我们现在能够确定哪些工作、[哪些组件要运行以及如何运行](https:\/\/kccncna19.sched.com\/event\/Uaav\/living-with-the-pathology-of-the-cloud-how-aws-runs-lots-of-clusters-micah-hausler-amazon)。我们已经了解到，客户希望在企业内部和云端获得一致的体验，以便进行迁移或实现混合云设置。例如，客户有一个用例，由于数据主权的原因，部分工作负载驻留在内部的 Kubernetes 集群中，而其他部分则运行在 EKS 上。现在你手头就有了基于 EKS 的解决方案参考系。\n\n![](0081Kckwgy1glhwzwpf3fj30rs0fst9y.jpg)\n\n对于 EC2 上的 EKS，你可以 [自己](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/worker.html) 管理节点，也可以使用 [托管节点组](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/managed-node-groups.html)。\n\n为了解决一致性的要求，我们想到了 EKS Distro，我们基于 EKS 的 Kubernetes 发行版，你可以在任何环境下运行，无论是裸机还是虚拟机。EKS-D 将上游的（未修改的）Kubernetes 和包，按照一定的、特意的方式进行配置，称为 [Kubernetes 发行版](https:\/\/github.com\/cncf\/k8s-conformance\/blob\/master\/faq.md)，并将这些 [作为开源](https:\/\/github.com\/aws\/eks-distro) 提供。fork 和 distribution 之间的区别很重要：fork 是一个替代上游的代码库。另一方面，发行版是一个特定的下游代码库，比如 Linux 发行版有 Ubuntu 和 Amazon Linux 2，比如 Hadoop 发行版，EMR 中有由 Cloudera 提供的并发行版。\n\n从高层的角度来看，EKS Distro 的情况如下（考虑到一些上游的开源项目，包括 Kubernetes 和 etcd）。\n\n![](0081Kckwgy1glhwzx24n5j30sg0p1q45.jpg)\n\n通过 EKS Distro，你可以通过单一供应商安全地访问可安装、可复制的 Kubernetes 构建，以创建集群，并在社区支持到期后提供 Kubernetes 版本的扩展安全补丁支持。我们将根据 Amazon EKS 版本生命周期政策提供长达 14 个月的 Kubernetes 扩展维护支持，为你提供必要的时间窗口来更新你的基础设施，使其与你的软件生命周期保持一致。\n\n## 开始使用 EKS-D\n\n我们与一些 [合作伙伴合作](https:\/\/amazonaws-china.com\/eks\/eks-distro)，提供安装方法以及与 EKS Distro 的集成。下面，我们将重点介绍几家合作伙伴，以及他们为帮助你开始使用 EKS-D 所做的工作。\n\n### Weaveworks\n\nWeave Kubernetes Platform（WKP）为 Amazon EKS Distro（EKS-D）带来了 GitOps，并为内部安装、创建和管理 EKS-D 集群提供支持。与任何 Kubernetes 发行版一样，EKS-D 需要配置、升级以及额外的组件和附加组件，如日志、跟踪和指标。WKP 通过将 GitOps 添加到你的 Kubernetes 环境的每一层，为 EKS-D 或任何其他云端和企业内部的发行版解决了这些问题。通过利用 Cluster API 项目，GitOps 工作流可以管理整个集群生命周期，包括维护、升级和补丁，以及 Prometheus 和 Grafana 等平台组件的集群配置。通过 WKP 交付和管理 EKS-D 集群，应用开发团队可以获得最新的 GitOps 功能，从而实现更频繁的部署，缩短价值实现时间，提高可靠性和可重复性。平台团队还可以获得对内部部署 EKS-D 的全面洞察和观察能力。Weaveworks [发布的博客文章](https:\/\/weave.works\/blog\/on-prem-kubernetes-gitops-eks-distro) 进一步详细描述了 EKS-D 和 WKP 之间的关系。另外一篇文章则是 [在 EKS-D 和 EKS-D 混合场景下的 WKP 演示](https:\/\/weave.works\/blog\/multicluster-gitops-eks-d-wkp)。\n\n### Kubestack\n\nKubestack 就是要为 Terraform 和 Kubernetes 提供最佳的 GitOps 开发者体验，从本地开发，一直到生产。通过他们 [发布博文](https:\/\/dev.to\/kubestack\/localhost-eks-development-environments-with-eks-d-and-kubestack-4p6) 了解如何使用 Kubestack 管理 EKS-D 集群，你也可以找到一个 [视频 demo](https:\/\/www.youtube.com\/watch?v=TcVwtfFww4w)。\n\n### Kubermatic\n\n你可以使用 Kubermatic 的 [KubeOne](https:\/\/www.kubermatic.com\/products\/kubeone\/) 安装 EKS-D。KubeOne 是一个基础设施对等的开源 Kubernetes 集群生命周期管理工具，可以自动部署和 Day 2 操作单个 Kubernetes 集群。了解如何使用 Kubermatic 的开源集群生命周期管理工具 KubeOne 在 AWS 和 Amazon Linux 2 上 [安装 EKS-D](https:\/\/www.kubermatic.com\/blog\/run-amazon-eks-distro-with-kubeone)。\n\n### Aqua Security\n\n为了保护 EKS-D 的安全，你需要一个整体的方法来征服 Kubernetes 的复杂性。Aqua 提供 KSPM（Kubernetes 安全态势管理）来提高可观测性和补救错误配置，以及先进的、无代理的 Kubernetes 运行时保护。你还可以使用 Kubernetes 原生功能，为你的 Kubernetes 应用实现策略驱动的全生命周期保护和合规性。了解更多关于 [Aqua 的 EKS-D 集成的信息](https:\/\/blog.aquasec.com\/aws-security-eks-distro)。\n\n### Sysdig\n\nSysdig 提供安全和可视性，以检测和响应运行时威胁，验证合规性，并监控和排除 EKS-D 上的容器。查看他们的 [发布博客文章](https:\/\/sysdig.com\/blog\/security-compliance-visibility-amazon-eks-d)，了解更多关于使用 CNCF Falco 和 Sysdig Secure 管理 EKS-D 工作负载中的运行时安全的信息。\n\n### Tetrate\n\nTetrate Service Bridge（TSB）[可在 EKS 和 EKS-D 上实现跨工作负载的统一应用连接和安全](https:\/\/www.tetrate.io\/blog\/tetrate-expands-aws-partnership-to-bring-enterprise-grade-istio-for-eks-and-eks-distro\/)。TSB 为企业级（上游或符合 FIPS 标准）Istio 和 Envoy Proxy 提供了便捷的访问和操作性。多租户、流量管理、网状和应用级可观测性、端到端 mTLS（相互传输层安全）、细粒度授权和应用安全是 TSB 的关键要素。\n\n一系列合作伙伴一直在开展更多与 EKS-D 有关的活动，包括：\n\n### 供应和管理\n\n- 了解如何 使用 Rancher 的 RKE2 部署 EKS-D\n-  [看看使用 Canonical 的 MicroK8s 安装 EKS-D](https:\/\/snapcraft.io\/eks) 有多简单 [，一目了](https:\/\/snapcraft.io\/eks) 然\n- 探索如何使用 [Rafay 的托管 Kubernetes 平台（MKP）来管理 EKS-D 集群](https:\/\/rafay.co\/the-kubernetes-current\/how-to-provision-and-manage-amazons-eks-distribution-using-rafay)\n- 查看如何 [使用 Pulumi 配置 EKS-D 集群](https:\/\/pulumi.com\/blog\/amazon-eks-distro)\n- [Upbound Cloud 使 EKS-D 用户可以轻松地将集群的配置整合](https:\/\/blog.upbound.io\/eks-d-and-upbound\/) 到一个与环境无关的 Crossplane 配置库中。利用这些配置，集群就可以通过一个统一的 API 接口在企业内部、云端或边缘进行配置。\n\n### 观察性\n\n- 通过 Instana，你可以 [自动监控和可视化](https:\/\/instana.com\/blog\/instana-brings-best-in-class-observability-with-the-new-amazon-kubernetes-distribution\/) EKS-D 的工作负载\n- Sumo Logic 展示了他们如何 [与 EKS-D 一起工作](https:\/\/www.sumologic.com\/blog\/monitor-aws-kubernetes-service\/)\n- Epsagon 使你能够 [监控 EKS-D 工作负载](https:\/\/epsagon.com\/announcements\/amazon-eks-distro\/)，包括控制平面指标\n- Datadog 提供了跨内部、混合和云计算基础设施的虚拟机、容器和无服务器环境的健康状况的可视性。了解有关 [EKS-D 支持](https:\/\/www.datadoghq.com\/blog\/amazon-eks-distro-monitoring\/) 的更多信息。\n- Splunk 基础设施监控为所有 Kubernetes 环境 —— 云原生 Amazon EKS、与 Amazon Outposts 的混合 [环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 以及内部 [自我管理的 EKS-D 环境](https:\/\/www.splunk.com\/en_us\/blog\/devops\/monitor-amazon-eks-distro-eks-d-with-splunk.html) 提供了企业级监控解决方案。\n\n### 安全\n\n- 了解 [Nirmata 的 EKS 管理器与 EKS-D 的集成](https:\/\/nirmata.com\/2020\/11\/20\/nirmata-delivers-consistent-hybrid-cloud-kubernetes-with-aws\/)，以及如何使用它来加强你的安全态势\n- Alcide 为跨越 EKS、Outposts 和 [新增加的 EKS-D 的](https:\/\/blog.alcide.io\/alcide-and-amazon-eks-distro) 混合部署提供集中统一的安全覆盖\n- 查看 Tigera 围绕 Calico 和 Calico Enterprise 支持所 做的工作 ，以实现运行 EKS-D 的集群的强大安全性和合规性。\n\n你可以想象，这只是旅程的开始。你可能会问，下一步是什么？\n\n## 下一步\n\n要开始使用 EKS Distro，请访问 [https:\/\/distro.eks.amazonaws.com](https:\/\/distro.eks.amazonaws.com\/)，并使用 kops 或 kubeadm 或上述任何一个合作伙伴提供的解决方案亲自尝试。\n\n你可以通过 GitHub 提供反馈和 PR，成为 EKS-D 社区的一员。如果你喜欢更多的互动交流，可以在 Kubernetes Slack 社区通过 #eks 频道或 AWS 开发者 Slack 频道加入我们，我们在那里设置了 #eks-d 频道。\n\n我们很高兴了解你使用 EKS Distro 的情况，并听取你的反馈和建议。\n', '\/trans\/introducing-amazon-eks-distro\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍 EKS Distro，并使用合作伙伴生态系统中的例子来解释开始使用 EKS Distro 的不同方法。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/ci-cd-in-kubernetes/">Kubernetes 中的 CI/CD</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 中的 CI\/CD', 'TheNewStack 的报告解读，介绍了 Kubernetes 中 CI\/CD 的现状。', '\n众所周知 Kubernetes 并不提供代码构建、发布和部署，所有的这些工作都是由 CI\/CD 工作流完成的，最近 TheNewStack 又出了本小册子（117 页）介绍了 Kubernetes 中 CI\/CD 的现状，[下载本书的 PDF](https:\/\/thenewstack.io\/ebooks\/kubernetes\/ci-cd-with-kubernetes\/)。\n\n## 关于本书\n\n本书的作者有：\n\n- Rob Scott：ReactiveOps 公司的 SRE\n- Janakiram MSV：Janakiram \u0026 Associates 的首席分析师\n- Craig Martin：Kenzan 的高级副总裁\n- Container Solutions\n\n这本小册子里主要主要介绍了以下几点：\n\n- DevOps 模式\n- 云原生应用模式\n- 使用 Spinnaker 做持续交付\n- 云原生时代的监控\n\n## DevOps 模式\n\n这一章从一些流行的自动化运维工具讲起，比如 Chef、Puppet 等，引申出 CI\/CD 流水线，进而引出 Docker 和 DevOps，将容器如何解除开发和运维之间的隔阂，但同时也带来了一些挑战，比如频繁的发布变更如何控制，如何控制容器集群的行为，如何拆分应用到容器之中等。这是一个专门用于容器编排调度的工具呼之欲出，Kubernetes 的出现彻底改变了局面，可以说它直接改变了应用的基础架构。\n\nKubernetes 细化的应用程序的分解粒度，同时将服务发现、配置管理、负载均衡和健康检查等作为基础设施的功能，简化了应用程序的开发。\n\n而 Kubernetes 这种声明式配置尤其适合 CI\/CD 流程，况且现在还有如 Helm、Draft、Spinnaker、Skaffold 等开源工具可以帮助我们发布 Kuberentes 应用。\n\n有了基于 Kubernetes 的 CI\/CD 流程后，又诞生了 GitOps（[WeaveWorks](http:\/\/weave.works) 的博客中有很多相关文章）和 SecOps（Security Operation）。\n\n## 云原生应用模式\n\n\u003e 云原生是通过构建团队、文化和技术，利用自动化和架构来管理系统的复杂性和解放生产力。——Joe Beda，Heptio CTO，联合创始人\n\n这一章的重点是给出了云原生应用的 10 条关键属性。\n\n1. 使用轻量级的容器打包\n2. 使用最合适的语言和框架开发\n3. 以松耦合的微服务方式设计\n4. 以 API 为中心的交互和协作\n5. 无状态和有状态服务在架构上界限清晰\n6. 不依赖于底层操作系统和服务器\n7. 部署在自服务、弹性的云基础设施上\n8. 通过敏捷的 DevOps 流程管理\n9. 自动化能力\n10. 通过定义和策略驱动的资源分配\n\n作者然后将应用程序架构中的不同组件映射到云原生的工作负载中。\n\n这也是 DevOps 需要关注的部分，如何将云原生的组件映射为 Kubernetes 的原语（即 Kubernetes 里的各种资源对象和概念组合）呢？\n\n总结概括为以下 10 条：\n\n1. 不要直接部署裸的 Pod。\n2. 为工作负载选择合适的 Controller。\n3. 使用 Init 容器确保应用程序被正确的初始化。\n4. 在应用程序工作负载启动之前先启动 service。\n5. 使用 Deployment history 来回滚到历史版本。\n6. 使用 ConfigMap 和 Secret 来存储配置。\n7. 在 Pod 里增加 Readiness 和 Liveness 探针。\n8. 给 Pod 这只 CPU 和内存资源限额。\n9. 定义多个 namespace 来限制默认 service 范围的可视性。\n10. 配置 HPA 来动态扩展无状态工作负载。\n\n## 使用 Spinnaker 进行持续交付\n\n作者首先讲到了 Spinnaker 的各种特性，比如面向微服务啦，云原生的交付工具啦，可视化的交付和基础设施啦，支持多个 region，支持容器和 Kubernetes 等等，不一而足，感兴趣大家可以自己看下报告或者登陆[Spinnaker 官网](https:\/\/www.spinnaker.io)查看。\n\n总之作者就是想说 Spinnaker 很好很强大啦，足以满足您对云原生应用 CI\/CD 的需求。\n\n## 云原生时代的监控\n\n监控是为了实现系统的可观测性，不要以为监控就是简单的出个监控页面，监控其实包括以下部分：\n\n- 日志收集\n- 监控和指标度量\n- 追踪\n- 告警和可视化\n\n要把其中任何一个方面做好都不容易。作者主要讲述的 Prometheus 和 Grafana 的开源监控方案。这一章我不详述，感兴趣大家可以查看报告原文。\n', '\/blog\/ci-cd-in-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">TheNewStack 的报告解读，介绍了 Kubernetes 中 CI/CD 的现状。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/configuring-kubernetes-kube-dns/">配置 Kubernetes DNS 服务 kube-dns</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/01/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('配置 Kubernetes DNS 服务 kube-dns', '配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。', '\n在我们安装 Kubernetes 集群的时候就已经安装了 kube-dns 插件，这个插件也是官方推荐安装的。通过将 Service 注册到 DNS 中，Kuberentes 可以为我们提供一种简单的服务注册发现与负载均衡方式。\n\n[CoreDNS](https:\/\/coredns.io)作为 CNCF 中的托管的一个项目，在 Kuberentes1.9 版本中，使用 kubeadm 方式安装的集群可以通过以下命令直接安装 CoreDNS。\n\n\u0060\u0060\u0060bash\nkubeadm init --feature-gates=CoreDNS=true\n\u0060\u0060\u0060\n\n您也可以使用 CoreDNS 替换 Kubernetes 插件 kube-dns，可以使用 Pod 部署也可以独立部署，请参考[Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)，下文将介绍如何配置 kube-dns。\n\n本文已归档到[kubernetes-handbook](\/book\/kubernetes-handbook)中。\n\n## kube-dns\n\nkube-dns 是 Kubernetes 中的一个内置插件，目前作为一个独立的开源项目维护，见 https:\/\/github.com\/kubernetes\/dns。\n\n下文中给出了配置 DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。\n\n## 前提要求\n\n- Kubernetes 1.6 及以上版本。\n- 集群必须使用 \u0060kube-dns\u0060 插件进行配置。\n\n## kube-dns 介绍\n\n从 Kubernetes v1.3 版本开始，使用 [cluster add-on 插件管理器回自动启动内置的 DNS。\n\nKubernetes DNS pod 中包括 3 个容器：\n\n- \u0060kubedns\u0060：\u0060kubedns\u0060 进程监视 Kubernetes master 中的 Service 和 Endpoint 的变化，并维护内存查找结构来服务 DNS 请求。\n- \u0060dnsmasq\u0060：\u0060dnsmasq\u0060 容器添加 DNS 缓存以提高性能。\n- \u0060sidecar\u0060：\u0060sidecar\u0060 容器在执行双重健康检查（针对 \u0060dnsmasq\u0060 和 \u0060kubedns\u0060）时提供单个健康检查端点（监听在 10054 端口）。\n\nDNS  pod 具有静态 IP 并作为 Kubernetes 服务暴露出来。该静态 IP 分配后，kubelet 会将使用 \u0060--cluster-dns = \u003cdns-service-ip\u003e\u0060 标志配置的 DNS 传递给每个容器。\n\nDNS 名称也需要域名。本地域可以使用标志 \u0060--cluster-domain = \u003cdefault-local-domain\u003e\u0060 在 kubelet 中配置。\n\nKubernetes 集群 DNS 服务器基于 [SkyDNS](https:\/\/github.com\/skynetservices\/skydns) 库。它支持正向查找（A 记录），服务查找（SRV 记录）和反向 IP 地址查找（PTR 记录）\n\n## kube-dns 支持的 DNS 格式\n\nkube-dns 将分别为 service 和 pod 生成不同格式的 DNS 记录。\n\n**Service**\n\n- A 记录：生成\u0060my-svc.my-namespace.svc.cluster.local\u0060域名，解析成 IP 地址，分为两种情况：\n  - 普通 Service：解析成 ClusterIP\n  - Headless Service：解析为指定 Pod 的 IP 列表\n- SRV 记录：为命名的端口（普通 Service 或 Headless Service）生成 \u0060_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local\u0060 的域名\n\n**Pod**\n\n- A 记录：生成域名 \u0060pod-ip.my-namespace.pod.cluster.local\u0060\n\n## kube-dns 存根域名\n\n可以在 Pod 中指定 hostname 和 subdomain：\u0060hostname.custom-subdomain.default.svc.cluster.local\u0060，例如：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  labels:\n    name: busybox\nspec:\n  hostname: busybox-1\n  subdomain: busybox-subdomain\n  containers:\n  name: busybox\n  - image: busybox\n    command:\n    - sleep\n    - \u00223600\u0022\n\u0060\u0060\u0060\n\n该 Pod 的域名是 \u0060busybox-1.busybox-subdomain.default.svc.cluster.local\u0060。\n\n## 继承节点的 DNS\n\n运行 Pod 时，kubelet 将预先配置集群 DNS 服务器到 Pod 中，并搜索节点自己的 DNS 设置路径。如果节点能够解析特定于较大环境的 DNS 名称，那么 Pod 应该也能够解析。请参阅下面的[已知问题](#known-issues)以了解警告。\n\n如果您不想要这个，或者您想要为 Pod 设置不同的 DNS 配置，您可以给 kubelet 指定 \u0060--resolv-conf\u0060 标志。将该值设置为 \u0022\u0022 意味着 Pod 不继承 DNS。将其设置为有效的文件路径意味着 kubelet 将使用此文件而不是 \u0060\/etc\/resolv.conf\u0060 用于 DNS 继承。\n\n## 配置存根域和上游 DNS 服务器\n\n通过为 kube-dns（\u0060kube-system:kube-dns\u0060）提供一个 ConfigMap，集群管理员能够指定自定义存根域和上游 nameserver。\n\n例如，下面的 ConfigMap 建立了一个 DNS 配置，它具有一个单独的存根域和两个上游 nameserver：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“acme.local”: [“1.2.3.4”]}\n  upstreamNameservers: |\n    [“8.8.8.8”, “8.8.4.4”]\n\u0060\u0060\u0060\n\n如上面指定的那样，带有“.acme.local”后缀的 DNS 请求被转发到 1.2.3.4 处监听的 DNS。Google Public DNS 为上游查询提供服务。\n\n下表描述了如何将具有特定域名的查询映射到其目标 DNS 服务器：\n\n| 域名                                   | 响应查询的服务器                   |\n| ------------------------------------ | -------------------------- |\n| kubernetes.default.svc.cluster.local | kube-dns                   |\n| foo.acme.local                       | 自定义 DNS (1.2.3.4)          |\n| widget.com                           | 上游 DNS (8.8.8.8 或 8.8.4.4) |\n\n查看 [ConfigMap 选项](#configmap-options) 获取更多关于配置选项格式的详细信息。\n\n### 对 Pod 的影响\n\n自定义的上游名称服务器和存根域不会影响那些将自己的 \u0060dnsPolicy\u0060 设置为 \u0060Default\u0060 或者 \u0060None\u0060 的 Pod。\n\n如果 Pod 的 \u0060dnsPolicy\u0060 设置为“\u0060ClusterFirst\u0060”，则其名称解析将按其他方式处理，具体取决于存根域和上游 DNS 服务器的配置。\n\n**未进行自定义配置**：没有匹配上配置的集群域名后缀的任何请求，例如“www.kubernetes.io”，将会被转发到继承自节点的上游 nameserver。\n\n**进行自定义配置**：如果配置了存根域和上游 DNS 服务器（和在 [前面例子](#configuring-stub-domain-and-upstream-dns-servers) 配置的一样），DNS 查询将根据下面的流程进行路由：\n\n1. 查询首先被发送到 kube-dns 中的 DNS 缓存层。\n\n2. 从缓存层，检查请求的后缀，并转发到合适的 DNS 上，基于如下的示例：\n\n   -  *具有集群后缀的名字* （例如“.cluster.local”）：请求被发送到 kube-dns。\n   -  *具有存根域后缀的名字* （例如“.acme.local”）：请求被发送到配置的自定义 DNS 解析器（例如：监听在 1.2.3.4）。\n   -  *不具有能匹配上后缀的名字* （例如“widget.com”）：请求被转发到上游 DNS（例如：Google 公共 DNS 服务器，8.8.8.8 和 8.8.4.4）。\n\n   ![DNS lookup flow](https:\/\/d33wubrfki0l68.cloudfront.net\/340889cb80e81dcd19a16bc34697a7907e2b229a\/24ad0\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/dns.png)\n\n## ConfigMap 选项\n\nkube-dns \u0060kube-system:kube-dns\u0060 ConfigMap 的选项如下所示：\n\n| 字段                        | 格式                                       | 描述                                       |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| \u0060stubDomains\u0060（可选）         | 使用 DNS 后缀 key 的 JSON map（例如“acme.local”），以及 DNS IP 的 JSON 数组作为 value。 | 目标 nameserver 可能是一个 Kubernetes Service。例如，可以运行自己的 dnsmasq 副本，将 DNS 名字暴露到 ClusterDNS namespace 中。 |\n| \u0060upstreamNameservers\u0060（可选） | DNS IP 的 JSON 数组。                        | 注意：如果指定，则指定的值会替换掉被默认从节点的 \u0060\/etc\/resolv.conf\u0060 中获取到的 nameserver。限制：最多可以指定三个上游 nameserver。 |\n\n### 示例\n\n#### 示例：存根域\n\n在这个例子中，用户有一个 Consul DNS 服务发现系统，他们希望能够与 kube-dns 集成起来。Consul 域名服务器地址为 10.150.0.1，所有的 Consul 名字具有后缀“.consul.local”。要配置 Kubernetes，集群管理员只需要简单地创建一个 ConfigMap 对象，如下所示：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  stubDomains: |\n    {“consul.local”: [“10.150.0.1”]}\n\u0060\u0060\u0060\n\n注意，集群管理员不希望覆盖节点的上游 nameserver，所以他们不会指定可选的 \u0060upstreamNameservers\u0060 字段。\n\n#### 示例：上游 nameserver\n\n在这个示例中，集群管理员不希望显式地强制所有非集群 DNS 查询进入到他们自己的 nameserver 172.16.0.1。而且这很容易实现：他们只需要创建一个 ConfigMap，\u0060upstreamNameservers\u0060 字段指定期望的 nameserver 即可。\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kube-dns\n  namespace: kube-system\ndata:\n  upstreamNameservers: |\n    [“172.16.0.1”]\n\u0060\u0060\u0060\n\n## 调试 DNS 解析\n\n### 创建一个简单的 Pod 用作测试环境\n\n创建一个名为 busybox.yaml 的文件，其中包括以下内容：\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busybox\n  namespace: default\nspec:\n  containers:\n  - name: busybox\n    image: busybox\n    command:\n      - sleep\n      - \u00223600\u0022\n    imagePullPolicy: IfNotPresent\n  restartPolicy: Always\n\u0060\u0060\u0060\n\n使用该文件创建 Pod 并验证其状态：\n\n\u0060\u0060\u0060shell\n$ kubectl create -f busybox.yaml\npod \u0022busybox\u0022 created\n\n$ kubectl get pods busybox\nNAME      READY     STATUS    RESTARTS   AGE\nbusybox   1\/1       Running   0          \u003csome-time\u003e\n\u0060\u0060\u0060\n\n该 Pod 运行后，您可以在它的环境中执行 \u0060nslookup\u0060。如果您看到类似如下的输出，表示 DNS 正在正确工作。\n\n\u0060\u0060\u0060shell\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nName:      kubernetes.default\nAddress 1: 10.0.0.1\n\u0060\u0060\u0060\n\n如果 \u0060nslookup\u0060 命令失败，检查如下内容：\n\n### 首先检查本地 DNS 配置\n\n查看下 resolv.conf 文件。（参考[集成节点的 DNS](#inheriting-dns-from-the-node)和 下面的[已知问题](#known-issues)获取更多信息）\n\n\u0060\u0060\u0060shell\n$ kubectl exec busybox cat \/etc\/resolv.conf\n\u0060\u0060\u0060\n\n验证搜索路径和名称服务器设置如下（请注意，搜索路径可能因不同的云提供商而异）：\n\n\u0060\u0060\u0060bash\nsearch default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal\nnameserver 10.0.0.10\noptions ndots:5\n\u0060\u0060\u0060\n\n如果看到如下错误表明错误来自 kube-dns 或相关服务：\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n或者\n\n\u0060\u0060\u0060bash\n$ kubectl exec -ti busybox -- nslookup kubernetes.default\nServer:    10.0.0.10\nAddress 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local\n\nnslookup: can\u0027t resolve \u0027kubernetes.default\u0027\n\u0060\u0060\u0060\n\n### 检查 DNS pod 是否在运行\n\n使用 \u0060kubectl get pods\u0060 命令验证 DNS pod 是否正在运行。\n\n\u0060\u0060\u0060shell\n$ kubectl get pods --namespace=kube-system -l k8s-app=kube-dns\nNAME                    READY     STATUS    RESTARTS   AGE\n...\nkube-dns-v19-ezo1y      3\/3       Running   0           1h\n...\n\u0060\u0060\u0060\n\n如果您看到没有 Pod 运行或者 Pod 处于 失败\/完成 状态，DNS 插件可能没有部署到您的当前环境中，您需要手动部署。\n\n### 检查 DNS pod 中的错误\n\n使用 \u0060kubectl logs\u0060 命令查看 DNS 守护进程的日志。\n\n\u0060\u0060\u0060shell\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c kubedns\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c dnsmasq\n$ kubectl logs --namespace=kube-system $(kubectl get pods --namespace=kube-system -l k8s-app=kube-dns -o name) -c sidecar\n\u0060\u0060\u0060\n\n看看有没有可疑的日志。以字母“\u0060W\u0060”，“\u0060E\u0060”，“\u0060F\u0060”开头的代表警告、错误和失败。请搜索具有这些日志级别的条目，并使用 [kubernetes issues](https:\/\/github.com\/kubernetes\/kubernetes\/issues)来报告意外错误。\n\n### DNS 服务启动了吗？\n\n使用 \u0060kubectl get service\u0060 命令验证 DNS 服务是否启动。\n\n\u0060\u0060\u0060shell\n$ kubectl get svc --namespace=kube-system\nNAME          CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE\n...\nkube-dns      10.0.0.10      \u003cnone\u003e        53\/UDP,53\/TCP        1h\n...\n\u0060\u0060\u0060\n\n如果您已经创建了该服务或它本应该默认创建但没有出现，参考[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)获取更多信息。\n\n### DNS 端点暴露出来了吗？\n\n您可以使用\u0060kubectl get endpoints\u0060命令验证 DNS 端点是否被暴露。\n\n\u0060\u0060\u0060shell\n$ kubectl get ep kube-dns --namespace=kube-system\nNAME       ENDPOINTS                       AGE\nkube-dns   10.180.3.17:53,10.180.3.17:53    1h\n\u0060\u0060\u0060\n\n如果您没有看到端点，查看[调试服务](https:\/\/kubernetes.io\/docs\/tasks\/debug-application-cluster\/debug-service\/)文档中的端点部分。\n\n获取更多的 Kubernetes DNS 示例，请参考 Kubernetes GitHub 仓库中的[cluster-dns 示例](https:\/\/github.com\/kubernetes\/examples\/tree\/master\/staging\/cluster-dns)。\n\n## 已知问题\n\nKubernetes 安装时不会将节点的 resolv.conf 文件配置为默认使用集群 DNS，因为该过程本身是特定于发行版的。这一步应该放到最后实现。\n\nLinux 的 libc 不可思议的卡住（[查看该 2005 年起暴出来的 bug](https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=168253)）限制只能有 3 个 DNS \u0060nameserver\u0060 记录和 6 个 DNS \u0060search\u0060 记录。Kubernetes 需要消耗 1 个 \u0060nameserver\u0060 记录和 3 个 \u0060search\u0060 记录。这意味着如果本地安装已经使用 3 个 \u0060nameserver\u0060 或使用 3 个以上的 \u0060search\u0060 记录，那么其中一些设置将会丢失。有个部分解决该问题的方法，就是节点可以运行 \u0060dnsmasq\u0060，它将提供更多的 \u0060nameserver\u0060 条目，但不会有更多的 \u0060search\u0060 条目。您也可以使用 kubelet 的 \u0060--resolv-conf\u0060 标志。\n\n如果您使用的是 Alpine 3.3 或更低版本作为基础映像，由于已知的 Alpine 问题，DNS 可能无法正常工作。点击[这里](https:\/\/github.com\/kubernetes\/kubernetes\/issues\/30215)查看更多信息。\n\n## Kubernetes 集群联邦（多可用区支持）\n\nKubernetes 1.3 版本起引入了支持多站点 Kubernetes 安装的集群联邦支持。这需要对 Kubernetes 集群 DNS 服务器处理 DNS 查询的方式进行一些小的（向后兼容的）更改，以便于查找联邦服务（跨多个 Kubernetes 集群）。有关集群联邦和多站点支持的更多详细信息，请参阅集群联邦管理员指南。\n\n## 参考\n\n- [Configure DNS Service](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-custom-nameservers\/)\n- [Service 和 Pod 的 DNS](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/dns-pod-service\/)\n- [自动扩容集群中的 DNS 服务](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/dns-horizontal-autoscaling\/)\n- [Using CoreDNS for Service Discovery](https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/coredns\/)\n\n', '\/blog\/configuring-kubernetes-kube-dns\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">配置 Kubernetes DNS Pod 的提示和定义 DNS 解析过程以及诊断 DNS 问题的指南。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/kubernetes/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/kubernetes/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/kubernetes/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/kubernetes/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/kubernetes/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/categories/kubernetes/page/3/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/kubernetes/page/3/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(78)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(10)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/follow-is-review/">Follow.is 使用体验分享：高效信息管理的智能工具</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ai-ppt-to-hugo/">如何使用通义千问 AI 生成 PPT 并发布到个人网站</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/warp-modern-terminal-tool/">新一代终端工具 Warp：重新定义命令行体验</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
