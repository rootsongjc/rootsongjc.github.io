<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>其他 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="宋净超的博客">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.10cc29dc94114b03907db3131a2a0b871735964d59cce9d69637f50ea22698ae.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.10cc29dc94114b03907db3131a2a0b871735964d59cce9d69637f50ea22698ae.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/%E5%85%B6%E4%BB%96/" />
  <meta property="og:title" content="其他 | Jimmy Song" />
  <meta property="twitter:title" content="其他 | Jimmy Song" />

  
  <meta property="og:description" content="宋净超的博客" />
  <meta property="twitter:description" content="宋净超的博客" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    其他
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/application-traffic-with-ebpf/">[译] 用 eBPF 洞察应用层网络流量</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/12/08/Application-traffic-with-eBPF/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('用 eBPF 洞察应用层网络流量', '本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。', '在[先前的帖子](..\/ebpf-adventures-in-networking\/)中，我稍微谈到了建立 eBPF 知识，以开始更多地了解网络适配器的输入和输出情况。基本上，将以太网帧并剥离标头（以太网标头\u002bIP 标头\u002bTCP\/UDP 标头），最终你将得到来自应用程序或数据角度的数据包中剩余的内容。\n\n所有的代码都在“学习 eBPF”存储库中，具体的 eBPF 代码在[这里](https:\/\/github.com\/thebsdbox\/learning-ebpf\/blob\/main\/ebpf\/http\/http.c)。这篇文章的计划是逐步介绍我认为有用或可能重要的部分...\n\n**注意**：此代码确实对入口\/出口数据包进行了一些修改，因此需要 6.1\u002b 的 Linux 内核才能使用一些 eBPF 助手函数。\n\n## 映射！\n\n你可能以前遇到过这些吧？如果没有，不用担心！简而言之，eBPF 映射是在用户空间和内核中的 eBPF 程序之间通信的机制。在我看来，非常酷的一点是这些映射使用键和值...所以我不必循环比较数据并寻找匹配的内容，我传递一个键，如果有匹配的内容，我就得到相应的数据:D\n\n下面是我将要使用的映射，称为\u0060url_map\u0060，键是 20 个字符长（可以说是有界的“字符串”），分配给该键的值是我在上面定义的结构体。\n\n\u0060\u0060\u0060\n\/\/ 定义与键关联的不同URL\nstruct url_path {\n  __u8 path_len;\n  __u8 path[max_path_len]; \/\/ 这应该是一个char，但在这里和Go之间的代码生成有点不同...\n};\n\n\/\/ 定义我的URL映射\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 1024);\n  __type(key, char[max_path_len]);\n  __type(value, struct url_path);\n}\nurl_map SEC(\u0022.maps\u0022);\n\u0060\u0060\u0060\n\n## eBPF 程序！\n\n代码中定义了两个 eBPF 程序\u0060tc_egress\u0060和\u0060tc_ingress\u0060，如果你能猜到它们是如何连接的，那就加分！在这篇文章中，我们只关注\u0060tc_ingress\u0060程序。\n\n就像我们在已经存在的众多示例中看到的那样，我们需要进行标头识别的操作。\n\n1. 进行合理性检查，并将\u0060data\u0060强制转换为\u0060ethhdr\u0060类型（[以太网标头](https:\/\/en.wikipedia.org\/wiki\/Ethernet_frame)）。\n2. 通过读取以太网标头内部的\u0060h_proto\u0060（也称为\u0060Ethertype\u0060）来查找以太网帧内部的协议。\n3. 将以太网标头后的数据强制转换为\u0060iphdr\u0060类型（[IP 标头](https:\/\/en.wikipedia.org\/wiki\/Internet_Protocol_version_4#Header)）。\n4. 在 IP 标头内查找协议，我们还需要确定 IP 标头的大小（原来它们可以有不同的大小！\u0060¯\\_(ツ)_\/¯\u0060）。\n5. 为了确定标头的大小，我们将其值乘以四，你可能会问为什么！好吧，这个值乘以 32 位以确定标头的大小，所以如果值为 6，那么标头将是 192 位（或 24 字节）。所以，为了简单地确定 IP 标头的字节数，我们可以将这个值乘以 4！\n6. 将以 IP 标头后的数据强制转换为\u0060tcphdr\u0060类型（[TCP 标头](https:\/\/en.wikipedia.org\/wiki\/Transmission_Control_Protocol#TCP_segment_structure)）。\n7. 像步骤（5）一样，我们需要确定 TCP 标头的大小（它也可以是动态的），在这里的步骤也是一样的，我们只需要将值\u0060doff\u0060乘以四来确定标头的大小（以字节为单位）。\n8. 通过计算所有这些，我们现在可以推断出数据位于以太网标头大小、IP 标头大小和 TCP 标头大小的末尾。\n9. 最后，我们可以通过从 IP 标头中减去 IP 和 TCP 标头的大小来确定应用程序数据的大小，使用\u0060tot_len\u0060（总长度）。\n\n### 应用数据！！\n\n为了读取这些数据，我们将需要上面提到的一些东西！\n\n首先，我们需要数据偏移量（数据起始位置），它位于以太网标头\u002bIP 标头大小（一旦计算出来）和 TCP 标头（再次，一旦计算出来）之后。我们还需要一个缓冲区来存储我们将从套接字缓冲区中读取的数据。\n\n\u0060\u0060\u0060c\n\/\/ 用于存储我们应用程序数据的数据缓冲区\nchar pdata[60];\n\n\/\/ 计算数据实际位置的偏移量\npoffset = ETH_HLEN \u002b ip_hlen \u002b tcp_hlen;\n\n\/\/ 从套接字缓冲区加载数据，poffset 从 TCP 标头的末尾开始\nint ret = bpf_skb_load_bytes(skb, poffset, pdata, 60);\nif (ret != 0) {\n   return 0;\n}\n\u0060\u0060\u0060\n\n我们使用\u0060bpf_skb_load_bytes\u0060从套接字缓冲区（\u0060skb\u0060）中读取一定量的数据（60 个字节）到我们的缓冲区（\u0060pdata\u0060），起始位置是我们知道数据位于的偏移量（\u0060poffset\u0060）！\n\n此时，我们有了 60 字节的数据，应该足够让我们编写一些代码来理解它。\n\n### HTTP 数据 :-)\n\n让我们看看当我们尝试进行 HTTP 请求时会发生什么！\n\n\u0060\u0060\u0060plaintext\n ~ curl code\/test -vvv\n*   Trying 192.168.0.22:80...\n* Connected to code (192.168.0.22) port 80 (#0)\n\u003e GET \/test HTTP\/1.1\n\u003e Host: code\n\u003e User-Agent: curl\/7.87.0\n\u003e Accept: *\/*\n\n...\n\u0060\u0060\u0060\n\n我正在使用\u0060curl\u0060从主机\u0060code\u0060（code 是我的开发 VM，运行 code-server）请求 URL \u0060\/test\u0060。我们可以看到发送到服务器的数据（每行以\u0060\u003e\u0060开头，用于确定通信的方向）。HTTP 请求中的第一行数据通常是一个*动词*，后面是我们希望与之交互的资源，然后是 HTTP 规范和回车符，如[HTTP 标准](https:\/\/en.wikipedia.org\/wiki\/HTTP#HTTP\/1.1_request_messages)中定义。因此，我们可以看到我们关心的行是\u0060GET \/test\u0060（在这一点上，我们\/我不太关心 HTTP 规范:D）。\n\n第一步是读取\u0060pdata\u0060的前三个字符，查找\u0060pdata[0] == G\u0060，\u0060pdata[1] == E\u0060和\u0060pdata[2] == T\u0060，这将有效地帮助我们确定首先是否是 HTTP 请求，特别是是否是 HTTP 请求！\n\n一旦我们验证了这前 3 个字节，我们将想要从第 4 个字节（请求的前三个字节加上一个用于分隔的空格）开始读取更多数据！\n\n\u0060\u0060\u0060c\nchar path[max_path_len];\nmemset(\u0026path, 0, sizeof(path));\n\nint path_len = 0;\n\n\/\/ 查找请求 URI（从偏移量 4 开始），以空格结束\nfor (int i = 4; i \u003c sizeof(pdata) ; i\u002b\u002b)\n{\n    if (pdata[i] != \u0027 \u0027) {\n        path[i-4] = pdata[i];\n    } else {\n        path[i-4] = \u0027\\0\u0027;\n        path_len = i-4;\n        break;\n    }\n}\n\u0060\u0060\u0060\n\n上面的函数将从 HTTP 数据的第 4 个字节开始（从第 4 个字节开始）读取其余的数据，直到遇到空格为止，留下我们要\u0060GET\u0060的 URL！我们可以通过一个调试打印语句来验证这一点：\n\n\u0060\u0060\u0060c\nbpf_printk(\u0022\u003c- incoming path [%s], length [%d]\u0022, path, path_len);\n\u0060\u0060\u0060\n\n这将在日志中显示如下：\n\n\u0060\u0060\u0060plaintext\n\u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n\u0060\u0060\u0060\n\n### 对 HTTP 应用程序请求采取行动\n\n上述解释详细说明了我们如何读取数据以及如何读取数据，但如果我们想要“动态”查找 HTTP 请求，我们将需要使用 eBPF 映射。\n\n在我们的 Go 用户空间代码中，我们执行以下操作：\n\n\u0060\u0060\u0060go\npath := flag.String(\u0022path\u0022, \u0022\u0022, \u0022The URL Path to watch for\u0022)\nflag.Parse()\n\n\/\/ ...\n\n\/\/ 创建一个 uint8 数组\nvar urlPath [20]uint8\n\/\/ 将我们的字节复制到 uint8 数组中（我们可以进行类型转换）\ncopy(urlPath[:], *path)\n\n\/\/ 将我们的 urlPath 作为键\nerr = objs.UrlMap.Put(urlPath,\n  bpfUrlPath{\n    Path:    urlPath,\n    PathLen: uint8(len(urlPath)),\n  })\nif err != nil {\n  panic(err)\n}\n\u0060\u0060\u0060\n\n正如我们在上面的代码中看到的，当我们启动 Go 程序时，它将从标志\u0060-path\u0060中读取，并将其用作我们 eBPF 映射中的**键**，可以暂时忽略值。\n\n\u0060\u0060\u0060c\nstruct url_path *found_path = bpf_map_lookup_elem(\u0026url_map, path);\nif (found_path \u003e 0) {\n    bpf_printk(\u0022Looks like we\u0027ve found your path [%s]\u0022, path);\n    \/\/ 可能进行更多操作，阻止流量或重定向？\n}\n\u0060\u0060\u0060\n\n在我们的 eBPF 程序中，我们将对 HTTP 请求进行映射查找，如果该请求作为 char 数组存在于**键**中，那么我们就可以对其进行操作！\n\n现在启动我们的 Go 程序 \u0060sudo .\/http -interface ens160 -path \/test\u0060 将得到以下结果：\n\n\u0060\u0060\u0060plaintext\nINFO[0000] Starting 🐝 the eBPF HTTP watcher, on interface [ens160] for path [\/test]\nINFO[0000] Loaded TC QDisc\nINFO[0000] Press Ctrl-C to exit and remove the program\n          \u003cidle\u003e-0       [001] d.s3. 2252901.015575: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] D.s3\n\n. 2252901.015642: bpf_trace_printk: -\u003e 192.168.0.22:80 -\u003e 192.168.0.180:56345\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017552: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] d.s3. 2252901.017793: bpf_trace_printk: \u003c- 0.0.0.0:56345 -\u003e 0.0.0.0:80\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017812: bpf_trace_printk: \u003c- incoming path [\/test], length [5]\n          \u003cidle\u003e-0       [001] dNs3. 2252901.017814: bpf_trace_printk: Looks like we\u0027ve found your path [\/test]\n\u0060\u0060\u0060\n\n## 结论\n\n解析 HTTP 并不太困难，因为它是一个相对简单的协议，它使用简单的动词和结构的简单方法，使用空格和回车符来区分。这种方法可能也适用于其他协议，如 DNS、POP3 或 SMTP。当数据加密时，我们需要一种解密的方法，然后才能解析数据（这超出了我的能力...）。但是，我希望这会激发你更多地尝试使用 eBPF 来解析和操作应用程序的想法！\n\n我一直想写一些有希望有用的关于 eBPF 的帖子，尽管通常在我想出可能有用的东西之后，别人已经抢先一步。鉴于我已经在一段时间里以某种方式关注网络，这基本上是我关注的领域，尽管我确实为最近的 eBPF 峰会 2023 编写了一些有趣的内容。如上所述，有很多人开始撰写 eBPF 内容，所以我可能会参考他们的帖子，而不是重复内容。\n', '\/trans\/application-traffic-with-ebpf\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/ebpf-adventures-in-networking/">[译] 如何用 eBPF 改变网络编程的游戏规则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thebsdbox.co.uk/2023/11/18/eBPF-adventures-in-networking/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何用 eBPF 改变网络编程的游戏规则', '这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。', '\n我一直想写一些关于 eBPF 的帖子，希望它们能有所帮助，尽管通常在我想到可能有用的东西时，其他人已经先我一步了。鉴于我已经在网络方面集中精力一段时间，这基本上是我专注的领域，尽管我确实设法为最近的 eBPF 峰会 2023 准备了一些我认为很有趣的东西。正如我之前提到的，有很多人开始撰写关于 eBPF 的内容，因此我可能会参考他们的帖子，而不是重复内容。\n\n我将从一些在 Linux 内核中可能或可能不会遇到的首字母缩写或技术开始。但基本上从我的角度来看，这些是你修改正在运行的系统以与网络数据交互的主要选项。\n\n### XDP\n\n关于 eXpress Data Plane 已经存在大量信息，因此我不会深入探讨太多细节。\u0060tl;dr\u0060是 XDP eBPF 程序挂钩到 XDP 将使其能够访问由内核自身处理之前的传入网络帧。在某些情况下，eBPF 程序将加载到 NIC 驱动程序本身中，这将有效地将程序卸载到 NIC 本身。\n\n### 优点\n\n- 最佳性能\n- 非常适用于防火墙、DDoS 防护或负载均衡等用例\n- 在任何其他内容进行修改之前看到传入的流量\n\n### 缺点\n\n- 仅支持入站流量，使用 XDP 程序看到的任何流量都只是传入流量，目前无法看到出站流量\n- 使用\u0060XDP\u0060数据结构，与大多数套接字编程的默认数据结构\u0060SKB\u0060有一些不同。\n\n### TC（Traffic Control）或流量控制\n\nTraffic Control 是内核网络结构的一个重要组成部分，主要包括添加诸如 qdisc 和过滤器之类的功能到接口的能力。qdisc 主要集中在为 TBD（待定）提供服务，而过滤器通常在底层实际上是一个 eBPF 程序。\n\n常见的工作流程是：\n\n1. 创建一个关注入口或出口的 qdisc，或者替换一个现有的 qdisc。qdisc 将附加到接口上。\n2. 加载你的 eBPF 程序。\n3. 创建一个过滤器，将其附加到通过接口上的 qdisc 上的入口或出口之一。该过滤器将与 eBPF 程序相关联，这意味着所有传入或传出的流量现在都会通过一个程序运行（如果连接）。\n4. 获利 💰\n\n### 优点\n\n- 提供入口和出口的挂钩点\n- 使用传统的\u0060SKB\u0060数据结构\n\n### 缺点\n\n- 将 TC 程序附加到入口或出口队列稍微复杂一些。用户需要使用 qdisc 来做到这一点，某些 eBPF SDK 不会原生支持 TC 程序的使用。\n- TC eBPF 程序看到的流量可能已经被之前的 XDP 程序或内核本身修改。\n\n### 系统调用\n\n与其他两种专门设计用于处理网络的方法相比，这可能会显得有些奇怪，因为它是将一些 eBPF 代码附加到内核中的系统调用的一种替代方法，具体来说是\u0060tcp4_connect()\u0060 \/ \u0060tcp6_connect()\u0060等调用。这在协议栈中略微靠后，因为在此时，传入数据包已经经过了很多内核逻辑，而 eBPF 内省点是当流量即将与应用程序本身交互时。\n\n## 编写网络程序！\n\n所以在这一点上，我们（希望）意识到我们有许多不同的入口点，允许我们在“传送带”上注入我们的代码，这个传送带从 NIC 开始，一直到应用程序（以及在出站的情况下）。\n\n### 回顾\n\n在我们所谓的“传送带”的开头，我们可以附加我们的 XDP 程序并获得未经触碰的原始网络数据。在“传送带”的中间，我们的 TC 程序将成为通过内核的路径的一部分，并接收可能被修改的网络数据。在传送带的末端，我们可以将代码附加到应用程序将在它被运行之前获取网络数据的函数，这些函数可以在传送带的末端进行附加。\n\n### 数据表示\n\n你的程序附加到的位置决定了两个主要事物，一个是潜在的流量修改的相对级别，另一个是流量的表示方式。\n\n### XDP 结构\n\n我会写关于它的内容，但是 DataDog 已经做了，你可以在[这里](https:\/\/www.datadoghq.com\/blog\/xdp-intro\/#the-flow-of-an-xdp-program)阅读。\n\n### SKB（套接字缓冲区）\n\nSKB 是在 eBPF 添加到内核之前就存在于内核中的数据类型，它已经具备了一些使与 SKB 对象交互变得稍微容易一些的辅助功能。有关更深入的 SKB 介绍，你可以阅读此文 -\u003e http:\/\/vger.kernel.org\/~davem\/skb_data.html\n\n### 解析数据\n\n无论与哪个结构进行交互，它们都共享一些共同之处，这主要是两个变量，对于这两种数据类型来说是相同的。\n\n这些变量是：\n\n- \u0060data\u0060，它是 eBPF 程序接收到的数据的指针\n\n- \u0060data_len\u0060，它是一个整数，指定了有多少数据可用（以帮助确保你永远不会访问\u0060data\u0060超过\u0060data_len\u0060（显而易见的真理 🤓））\n\n所以这一切似乎很简单，但等等... \u0060*data\u0060中实际上有什么？（这取决于你的发现）\n\n通过不断“转换”\u0060*data\u0060并沿着它移动以剥离各种标头，我们可以了解和查找底层数据！\n\n### 转换？\n\n如果你愿意，你可以跳过此部分，但这是一个快速（且糟糕）的示例，说明了我们通常如何将一些原始数据转换为有意义的东西。目前，\u0060*data\u0060将只是一串随机数据，毫无意义，我们需要有效地为其添加“格式”以便我们可以理解其外观。\n\n考虑一下随机数据行：“Bobby0004500100.503 Harvard Drive90210”，其中一些对裸眼来说是有意义的，但有些是不清楚的。\n\n想象一下名为“person”的数据结构：\n\n\u0060\u0060\u0060bash\nName: string\nAge: number\nBalance: float\nStreet: string\nZipCode: number\n\u0060\u0060\u0060\n\n如果我们要将我们的随机数据“转换”为上面的“person”结构，它将突然变成：\n\n\u0060\u0060\u0060bash\nName: Bobby\nAge: 45\nBalance: 100.50\nStreet: 3 Harvard Drive\nZipCode: 90210\n\u0060\u0060\u0060\n\n现在突然间，我能够理解并访问结构中的底层变量，因为它们现在是有意义的，即 person-\u003eName，并且发现此特定的 person 类型对象具有名称变量“Bobby”！\n\n这正是我们将对我们的\u0060*data\u0060所做的！\n\n### 数据中包含什么？\n\n因此，第一步是确定数据是否以以太网帧开头！几乎所有传输的数据都以以太网帧开头，这相当简单，但其作用是具有源和目标硬件地址（无论虚拟化\/容器化\/有线网络还是 WiFi 如何）。因此，我们的第一步是将我们的\u0060*data\u0060转换为类型\u0060ETHHDR\u0060，如果成功，我们现在将能够了解组成以太网头数据类型的变量。这些包括源和目标 MAC 地址，但更重要的是剩余数据的内容是什么。再次，在大多数情况下，以太网头之后的\u0060*data\u0060内容通常是 IP 头，但我们将通过检查以太网帧的 TBD 变量来验证。\n\n一旦我们验证下一组数据是 IP 头，我们将需要将以太网头之后的数据转换为 IPHDR 类型。一旦我们这样做，我们将能够访问 IP 特定的数据，例如源 IP（\u0060saddr\u0060）或目标地址（\u0060daddr\u0060），再次重要的是 IP 头包含一个变量，详细说明了 IP 头之后的数据是什么。这通常是 TCP 头或 UDP 头，但还有其他选择，例如 sctp 等。\n\n一旦我们查看了 IP 头的内部并确定数据类型是 TCP（也可能是 UDP 或其他内容），我们将把以太网头和 IP 头之后的数据都转换为 TCP 头类型！（几乎完成了）。通过访问 TCP 头的内容，我们可以获得 TCP 特定的数据，例如源端口或目标端口，用于验证数据的有效性的校验和以及其他有用的变量。\n\n现在我们几乎拥有一切，但是 TCP 头的长度可能是可变的，因此我们需要通过查看 tcl_len 变量来确定这一点，我们需要将其乘以 4。现在我们拥有了访问最终数据所需的一切！\n\n因此，\u0060*data\u0060指向数据的开头！我们已经确定了以太网头之后是 IP 头，最后是 TCP 头，这意味着\u0060*data \u002b 以太网头 \u002b IP 头 \u002b TCP 头 = 实际应用程序数据！\n\n### 我们可以用这些信息做什么？\n\n当我们解析各种标头时，实际上在 OSI 模型的不同层次上解锁了越来越多的信息！\n\n**[第 2 层]** 以太网头为我们提供了源和目标硬件地址，我们可以使用此信息来潜在地阻止从我们知道危险的源 MAC 地址处理的帧。\n\n**[第 3 层]** IP 头包含源和目标 IP 地址，再次，我们可以像防火墙一样运作，通过使用 eBPF 程序丢弃特定 IP 地址的所有流量。或者，我们可以根据 IP 地址重定向流量，或者甚至在这一层实施负载均衡逻辑，以将流量重定向到其他底层 IP 地址集合。\n\n**[第 4 层]** TCP 或 UDP 标头定义了目标端口号，我们可以使用这些信息来确定应用程序协议是什么（即端口 80 通常意味着剩余的*data 可能是 HTTP 数据）。在这一层，我们通常会执行负载均衡等操作，基于目标（即在多个其他负载均衡器地址之间平衡）。\n\n**[第 7 层]** 正如前面提到的，各种标头集合的末尾的数据是实际的应用程序数据，只要我们知道格式，我们也可以解析它。例如，如果外部 Web 浏览器尝试访问我的计算机上的\u0060\/index.html\u0060并附加了 eBPF 程序，我会解析到 TCP，然后确定它是端口 80，然后应用程序数据应该是 HTTP 格式。我可以通过查看应用程序数据的前三个字符（在所有标头之后）来验证这一点，使用以下伪代码：\n\n\u0060\u0060\u0060bash\nApplicationData = EthernetHDR \u002b IPHDR \u002b TCPHDR \/\/ 将所有标头长度相加以找到数据\nIf ( data[ApplicationData] = \u0022G\u0022 \u0026\u0026 data[ApplicationData\u002b1] = \u0022E\u0022 \u0026\u0026 data[ApplicationData\u002b2] = \u0022T\u0022 ) {\n\t\/\/ 这是一个HTTP GET请求\n\t\/\/ 做一些令人兴奋的事情\n}\n\u0060\u0060\u0060\n\n## 总结\n\n现在我们“有点”理解了这个逻辑，也许我们应该考虑实施一些代码来完成所有这些...但这将是另一天的事情。\n', '\/trans\/ebpf-adventures-in-networking\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/cilium-gateway-api/">[译] 使用 Cilium 实现 Gateway API 指南</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/01/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.ogenki.io/post/cilium-gateway-api/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Cilium 实现 Gateway API 指南', '这篇文章介绍了如何使用 Cilium 部署和配置 Gateway API，一个新的服务网格 API，用于管理 Kubernetes 中的服务间通信。文章详细说明了 Gateway API 的概念和组件，以及如何使用 Cilium 的特性和工具，实现高效和灵活的路由策略。', '\n在 Kubernetes 上部署应用程序后，通常的下一步是让用户可以访问它。我们通常使用[**Ingress 控制器**](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/)，例如 Nginx、Haproxy、Traefik 或来自云提供商的控制器，来引导传入的流量到应用程序，管理负载平衡、TLS 终止等等。\n\n然后，我们必须从众多[可用的选项](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/) 中进行选择。Cilium 是其中一个相对较新的选项，旨在处理所有这些网络方面的问题。\n\n[**Cilium**](https:\/\/cilium.io\/) 是一个基于 eBPF 的开源网络和安全解决方案，其采用速度增长迅猛。它可能是提供最多功能的网络插件之一。我们不会涵盖所有功能，但其中一个功能涉及使用[**Gateway API**](https:\/\/gateway-api.sigs.k8s.io\/) (\u0060GAPI\u0060) 管理传入流量。\n\n## 我们的目标\n\n- 准确了解 **Gateway API** 是什么，以及它如何代表从 \u0060Ingress\u0060 API 进化而来。\n- 演示以 GitOps 方式部署的真实场景。\n- 当前的限制和即将推出的新功能。\n\n{{\u003ccallout note 提示\u003e}}\n\n本文中执行的所有步骤都来自这个[**git 存储库**](https:\/\/github.com\/Smana\/cilium-gateway-api)。\n\n我鼓励你探索它，因为它远远超出了本文的范围：\n\n- 使用启用了 kube-proxy 替代并具有专用 Daemonset 用于 \u0060Envoy\u0060 的 \u0060Cilium\u0060 配置的 **EKS** 集群的安装。\n- 提出了具有依赖关系管理和我认为非常高效的 DRY 代码的 \u0060Flux\u0060 结构。\n- 简化了用于平台组件的 IAM 权限管理的 \u0060Crossplane\u0060 和 [IRSA](https:\/\/docs.aws.amazon.com\/eks\/latest\/userguide\/iam-roles-for-service-accounts.html) 组合。\n- 使用 \u0060External-DNS\u0060 和 \u0060Let\u0027s Encrypt\u0060 自动管理域名和证书。\n\n这个想法是只需几分钟内设置好一切，只需一个命令行。\n\n{{\u003c\/callout\u003e}}\n\n## 介绍 Gateway API\n\n正如前面提到的，有许多**Ingress 控制器**选项，每个都有其特定性和特殊功能，有时会使它们的使用变得复杂。此外，Kubernetes 中传统的 \u0060Ingress\u0060 API 具有非常有限的参数。一些解决方案甚至创建了自己的[CRDs](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/api-extension\/custom-resources\/)（Kubernetes 自定义资源），而其他解决方案则使用 \u0060annotations\u0060 来克服这些限制。\n\n这就是**Gateway API**的用武之地！实际上，这是一种**标准**，允许声明高级网络功能，而无需对底层控制器进行特定扩展。而且，由于所有控制器都使用相同的 API，因此可以在不改变配置的情况下从一个解决方案切换到另一个解决方案（Kubernetes 清单描述了如何路由传入流量）。\n\n在我们将要探讨的概念中，GAPI 引入了一个精细的授权模型，定义了具有不同权限的**显式角色**（有关 GAPI 安全模型的更多信息，请参阅[这里](https:\/\/gateway-api.sigs.k8s.io\/concepts\/security-model\/#roles-and-personas)）。\n\n值得注意的是，该项目由[sig-network-kubernetes](https:\/\/github.com\/kubernetes\/community\/tree\/master\/sig-network)工作组推动，还有一个 Slack [频道](https:\/\/kubernetes.slack.com\/archives\/CR0H13KGA)，你可以在需要时联系他们。\n\n让我们看看在实践中如何使用 GAPI 与 Cilium！\n\n## 先决条件\n\n在本文的其余部分，我们假设已部署了一个 EKS 集群。如果你没有使用[演示存储库中建议的方法](https:\/\/github.com\/Smana\/cilium-gateway-api\/tree\/main\/terraform\/eks)作为本文的基础，那么有一些**要检查的要点**，以便使用 GAPI。\n\n此处描述的安装方法基于 \u0060Helm\u0060，所有的 \u0060values\u0060 可以在[这里](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/terraform\/eks\/helm_values\/cilium.yaml)查看。\n\n- 在[Gateway API](https:\/\/github.com\/kubernetes-sigs\/gateway-api\/tree\/main\/config\/crd)存储库中**安装**可用的 \u0060CRDs\u0060。\n\n  {{\u003ccallout note 注意\u003e}}\n\n  如果 Cilium 设置为支持 \u0060GAPI\u0060（见下文），并且缺少 CRDs，则它将无法启动。在[演示存储库](https:\/\/github.com\/Smana\/cilium-gateway-api)中，**GAPI CRDs**在集群创建期间安装一次，以便 Cilium 可以启动，然后由 Flux 管理。\n\n  {{\u003c\/callout\u003e}}\n\n- 使用 Cilium 和 \u0060eBPF\u0060 的网络转发功能**替换** \u0060kube-proxy\u0060。\n\n  \u0060\u0060\u0060yaml\n  kubeProxyReplacement: true\n  \u0060\u0060\u0060\n\n- **启用** Gateway API 支持。\n\n  \u0060\u0060\u0060yaml\n  gatewayAPI:\n    enabled: true\n  \u0060\u0060\u0060\n\n- **检查**安装。为此，你需要安装名为 \u0060cilium\u0060 的命令行工具。我个人使用 [asdf](https:\/\/blog.ogenki.io\/post\/asdf\/asdf\/)：\n\n  \u0060\u0060\u0060console\n  asdf plugin-add cilium-cli\n  asdf install cilium-cli 0.15.7\n  asdf global cilium 0.15.7\n  \u0060\u0060\u0060\n\n  以下命令允许确保所有组件都正常运行：\n\n  \u0060\u0060\u0060console\n  cilium status --wait\n     \/¯¯\\\n  \/¯¯\\__\/¯¯\\    Cilium:             OK\n  \\__\/¯¯\\__\/    Operator:           OK\n  \/¯¯\\__\/¯¯\\    Envoy DaemonSet:    OK\n  \\__\/¯¯\\__\/    Hubble Relay:       disabled\n     \\__\/       ClusterMesh:        disabled\n  \n  Deployment             cilium-operator    Desired: 2, Ready: 2\/2, Available: 2\/2\n  DaemonSet              cilium             Desired: 2, Ready: 2\/2, Available: 2\/2\n  DaemonSet              cilium-envoy       Desired: 2, Ready: 2\/2, Available: 2\/2\n  Containers:            cilium             Running: 2\n                        cilium-operator    Running: 2\n                        cilium-envoy       Running: 2\n  Cluster Pods:          33\/33 managed by Cilium\n  Helm chart version:    1.14.2\n  Image versions         cilium             quay.io\/cilium\/cilium:v1.14.2@sha256:6263f3a3d5d63b267b538298dbeb5ae87da3efacf09a2c620446c873ba807d35: 2\n                        cilium-operator    quay.io\/cilium\/operator-aws:v1.14.2@sha256:8d514a9eaa06b7a704d1ccead8c7e663334975e6584a815efe2b8c15244493f1: 2\n                        cilium-envoy       quay.io\/cilium\/cilium-envoy:v1.25.9-e198a2824d309024cb91fb6a984445e73033291d@sha256:52541e1726041b050c5d475b3c527ca4b8da487a0bbb0309f72247e8127af0ec: 2\n  \u0060\u0060\u0060\n\n  最后，你可以通过运行以下命令来检查是否启用了 Gateway API 支持：\n\n  \u0060\u0060\u0060console\n  cilium config view | grep -w \u0022enable-gateway-api\u0022\n  enable-gateway-api                                true\n  enable-gateway-api-secrets-sync                   true\n  \u0060\u0060\u0060\n\n  你还可以运行以下端到端测试：\n\n  \u0060\u0060\u0060console\n  cilium connectivity test\n  \u0060\u0060\u0060\n\n  但是，此命令（\u0060connectivity test\u0060）当前在启用 Envoy 作为 DaemonSet 时会抛出错误。([Github Issue](https:\/\/github.com\/cilium\/cilium\/issues\/28057))。\n\n{{\u003ccallout note 提示\u003e}}\n  **Envoy 作为 DaemonSet**\n\n  默认情况下，Cilium 代理还在同一 Pod 中运行 \u0060Envoy\u0060，并委托给它级别 7 的网络操作。从版本 \u0060v1.14\u0060 开始，可以将 Envoy 单独部署，这带来了一些好处：\n\n  - 如果修改\/重新启动一个组件（无论是 Cilium 还是 Envoy），都不会影响另一个组件。\n  - 更好地分配资源给每个组件以优化性能。\n  - 在某个 Pod 被攻击的情况下限制攻击面。\n  - Envoy 日志和 Cilium 代理日志不会混合在一起。\n\n  你可以使用以下命令来检查此功能是否已启用：\n\n  \u0060\u0060\u0060console\n  cilium status\n      \/¯¯\\\n   \/¯¯\\__\/¯¯\\    Cilium:             OK\n   \\__\/¯¯\\__\/    Operator:           OK\n   \/¯¯\\__\/¯¯\\    Envoy DaemonSet:    OK\n   \\__\/¯¯\\__\/    Hubble Relay:       disabled\n      \\__\/       ClusterMesh:        disabled\n  \u0060\u0060\u0060\n\n  [更多信息](https:\/\/isovalent.com\/blog\/post\/cilium-release-114\/#h-envoy-daemonset)。\n{{\u003c\/callout\u003e}}\n\n## 入口点：GatewayClass 和 Gateway\n\n![网关](gateway.jpg)\n\n一旦满足先决条件，我们就可以访问多个元素。我们可以利用 Gateway API CRDs 定义的自定义资源。而且，在安装 Cilium 后，一个 \u0060GatewayClass\u0060 立即可用。\n\n\u0060\u0060\u0060console\nkubectl get gatewayclasses.gateway.networking.k8s.io\nNAME     CONTROLLER                     ACCEPTED   AGE\ncilium   io.cilium\/gateway-controller   True       7m59s\n\u0060\u0060\u0060\n\n在 Kubernetes 集群上，你可以配置多个 \u0060GatewayClasses\u0060，从而能够使用不同的实现。例如，我们可以通过在 \u0060Gateway\u0060 配置中引用 GatewayClass 来使用 \u0060Linkerd\u0060。\n\n\u0060Gateway\u0060 是允许触发在云提供商中创建负载均衡组件的资源。\n\n这是一个简单的示例：[apps\/base\/echo\/gateway.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/apps\/base\/echo\/gateway.yaml)\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: echo-gateway\n  namespace: echo\nspec:\n  gatewayClassName: cilium\n  listeners:\n    - protocol: HTTP\n      port: 80\n      name: echo-1-echo-server\n      allowedRoutes:\n        namespaces:\n          from: Same\n\u0060\u0060\u0060\n\n在 AWS（EKS）上，配置 \u0060Gateway\u0060 时，Cilium 会创建一个类型为 \u0060LoadBalancer\u0060 的 \u0060Service\u0060。然后，另一个控制器（[AWS Load Balancer Controller](https:\/\/kubernetes-sigs.github.io\/aws-load-balancer-controller)）处理云负载均衡器（[NLB](https:\/\/docs.aws.amazon.com\/elasticloadbalancing\/latest\/network\/introduction.html)）的创建。\n\n\u0060\u0060\u0060console\nkubectl get svc -n echo cilium-gateway-echo\nNAME                  TYPE           CLUSTER-IP     EXTERNAL-IP                                                                 PORT(S)        AGE\ncilium-gateway-echo   LoadBalancer   172.20.19.82   k8s-echo-ciliumga-64708ec85c-fcb7661f1ae4e4a4.elb.eu-west-3.amazonaws.com   80:30395\/TCP   2m58s\n\u0060\u0060\u0060\n\n值得注意的是，负载均衡器地址也与 \u0060Gateway\u0060 相关联。\n\n\u0060\u0060\u0060console\nkubectl get gateway -n echo echo\nNAME   CLASS    ADDRESS                                                                     PROGRAMMED   AGE\necho   cilium   k8s-echo-ciliumga-64708ec85c-fcb7661f1ae4e4a4.elb.eu-west-3.amazonaws.com   True         16m\n\u0060\u0060\u0060\n\n## 路由规则：HTTPRoute\n\n### 基本规则\n\n![HTTPRoute](httproute.jpg)\n\n简而言之，上面的图表可总结为几句话：\u0060HTTPRoute\u0060 允许通过引用 Gateway 并定义所需的路由参数来配置到服务的路由。\n\n{{\u003ccallout note 提示\u003e}}\n**Kyverno**\n\n截止目前，无法配置由 \u0060Gateways\u0060 生成的服务的注释（[Github Issue](https:\/\/github.com\/cilium\/cilium\/issues\/25357)）。已提出一种解决方法，即在创建 \u0060Gateway\u0060 后立即修改由 \u0060Gateway\u0060 创建的服务。\n\nKyverno 是一种确保配置符合最佳实践和安全要求的工具。我们在这里仅仅使用它来轻松描述[突变](https:\/\/kyverno.io\/docs\/writing-policies\/mutate\/)规则。\n\n[security\/mycluster-0\/echo-gw-clusterpolicy.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/security\/mycluster-0\/echo-gw-clusterpolicy.yaml)\n\n\u0060\u0060\u0060yaml\nspec:\n  rules:\n    - name: mutate-svc-annotations\n      match:\n        any:\n          - resources:\n              kinds:\n                - Service\n              namespaces:\n                - echo\n              name: cilium-gateway-echo\n      mutate:\n        patchStrategicMerge:\n          metadata:\n            annotations:\n              external-dns.alpha.kubernetes.io\/hostname: echo.${domain_name}\n              service.beta.kubernetes.io\/aws-load-balancer-scheme: \u0022internet-facing\u0022\n              service.beta.kubernetes.io\/aws-load-balancer-backend-protocol: tcp\n          spec:\n            loadBalancerClass: service.k8s.aws\/nlb\n\u0060\u0060\u0060\n\n因此，服务 \u0060cilium-gateway-echo\u0060 将添加 AWS 控制器的注释，以及一个允许自动 DNS 记录配置的注释。\n{{\u003c\/callout\u003e}}\n\n[apps\/base\/echo\/httproute.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/apps\/base\/echo\/httproute.yaml)\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: echo-1\n  namespace: echo\nspec:\n  parentRefs:\n    - name: echo\n      namespace: echo\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \/\n      backendRefs:\n        - name: echo-1-echo-server\n          port: 80\n\u0060\u0060\u0060\n\n上面使用的示例非常简单：所有请求都会转发到 \u0060echo-1-echo-server\u0060 服务。\n\n\u0060parentRefs\u0060 指示使用哪个 \u0060Gateway\u0060，然后在 \u0060rules\u0060 部分定义了路由规则。\n\n路由规则还可以基于 \u0060path\u0060。\n\n\u0060\u0060\u0060yaml\n...\nspec:\n  hostnames:\n  - foo.bar.com\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/login\n\u0060\u0060\u0060\n\n或者基于 HTTP 标头\n\n\u0060\u0060\u0060yaml\n...\nspec:\n  rules:\n  - matches:\n      headers:\n      - name: \u0022version\u0022\n        value: \u00222\u0022\n...\n\u0060\u0060\u0060\n\n让我们检查服务是否可访问。\n\n\u0060\u0060\u0060console\ncurl -s http:\/\/echo.cloud.ogenki.io | jq -rc \u0027.environment.HOSTNAME\u0027\necho-1-echo-server-fd88497d-w6sgn\n\u0060\u0060\u0060\n\n正如你所看到的，该服务以 HTTP 方式暴露，没有证书。让我们尝试解决这个问题。\n\n### 配置 TLS 证书\n\n有多种方法可以使用 GAPI 配置 TLS。在这里，我们将使用最常见的情况：HTTPS 协议和在 Gateway 上终止 TLS。\n\n假设我们想要配置之前使用的域名 \u0060echo.cloud.ogenki.io\u0060。配置主要通过配置 \u0060Gateway\u0060 来完成。\n\n[apps\/base\/echo\/tls-gateway.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/apps\/base\/echo\/tls-gateway.yaml)\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: echo\n  namespace: echo\n  annotations:\n    cert-manager.io\/cluster-issuer: letsencrypt-prod\nspec:\n  gatewayClassName: cilium\n  listeners:\n    - name: http\n      hostname: \u0022echo.${domain_name}\u0022\n      port: 443\n      protocol: HTTPS\n      allowedRoutes:\n        namespaces:\n          from: Same\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: echo-tls\n\u0060\u0060\u0060\n\n这里的关键点是引用一个包含名称为 \u0060echo-tls\u0060 的证书的密钥。这个证书可以手动创建，但是为了本文，我选择使用 **Let\u0027s Encrypt** 和 \u0060cert-manager\u0060 来自动化这个过程。\n\n{{\u003ccallout note 提示\u003e}}}\n**cert-manager**\n\n使用 \u0060cert-manager\u0060，自动创建和更新由 \u0060Gateway\u0060 暴露的证书非常简单。为此，你需要允许控制器访问 [route53](https:\/\/aws.amazon.com\/route53\/)，以解决 DNS01 挑战（这是一种确保客户端只能为自己拥有的域请求证书的机制）。\n\n[ClusterIssuer](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/security\/base\/cert-manager\/cluster-issuer-staging.yaml) 资源描述了使用 cert-manager 生成证书所需的配置。\n\n接下来，我们只需要添加一个注释 \u0060cert-manager.io\/cluster-issuer\u0060 并设置存储证书的 Kubernetes 密钥。\n\n[更多信息](https:\/\/cert-manager.io\/docs\/usage\/gateway\/)\n\n在演示存储库中，权限是使用 \u0060Crossplane\u0060 分配的，它负责在 AWS 中配置这些 IAM 权限。\n{{\u003c\/callout\u003e}}\n\n为了使路由正常工作，你还需要将 \u0060HTTPRoute\u0060 附加到正确的 \u0060Gateway\u0060 并指定域名。\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: echo-1\n  namespace: echo\nspec:\n  parentRefs:\n    - name: echo\n      namespace: echo\n  hostnames:\n    - \u0022echo.${domain_name}\u0022\n...\n\u0060\u0060\u0060\n\n几秒钟后，证书将被创建。\n\n\u0060\u0060\u0060console\nkubectl get cert -n echo\nNAME       READY   SECRET     AGE\necho-tls   True    echo-tls   43m\n\u0060\u0060\u0060\n\n最后，我们可以检查证书确实来自 Let\u0027s Encrypt，如下所示：\n\n\u0060\u0060\u0060console\ncurl https:\/\/echo.cloud.ogenki.io -v 2\u003e\u00261 | grep -A 6 \u0027Server certificate\u0027\n* Server certificate:\n*  subject: CN=echo.cloud.ogenki.io\n*  start date: Sep 15 14:43:00 2023 GMT\n*  expire date: Dec 14 14:42:59 2023 GMT\n*  subjectAltName: host \u0022echo.cloud.ogenki.io\u0022 matched cert\u0027s \u0022echo.cloud.ogenki.io\u0022\n*  issuer: C=US; O=Let\u0027s Encrypt; CN=R3\n*  SSL certificate verify ok.\n\u0060\u0060\u0060\n\n{{\u003ccallout note 提示\u003e}}\nGAPI 还允许你配置 **端到端的 TLS**，一直到容器。这是通过配置 \u0060Gateway\u0060 为 \u0060Passthrough\u0060 模式并使用 \u0060TLSRoute\u0060 资源来完成的。证书也必须由执行 TLS 终止的 pod 携带。\n{{\u003c\/callout\u003e}}\n\n### 在多个命名空间中共享 Gateway\n\n![共享网关](shared-gateway.jpg)\n\n使用 \u0060GAPI\u0060，你可以在 \u0060命名空间\u0060 之间路由流量。这得益于每个功能的不同资源：一个 \u0060Gateway\u0060 允许配置基础设施，以及 \u0060*Routes\u0060。这些路由可以附加到位于另一个命名空间中的 Gateway。因此，不同的团队\/项目可以共享相同的基础设施组件。\n\n但是，这需要指定哪个路由允许引用该 Gateway。在这里，我们假设我们有一个专门用于内部工具的 Gateway，名为 \u0060platform\u0060。通过使用 \u0060allowedRoutes\u0060 参数，我们明确指定了哪些命名空间允许附加到此 Gateway。\n\n[infrastructure\/base\/gapi\/platform-gateway.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/infrastructure\/base\/gapi\/platform-gateway.yaml)\n\n\u0060\u0060\u0060yaml\n...\n      allowedRoutes:\n        namespaces:\n          from: Selector\n          selector:\n            matchExpressions:\n              - key: kubernetes.io\/metadata.name\n                operator: In\n                values:\n                  - observability\n                  - flux-system\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: platform-tls\n\u0060\u0060\u0060\n\n在命名空间 \u0060observability\u0060 和 \u0060flux-system\u0060 中配置的 \u0060HTTPRoutes\u0060 附加到此唯一的 \u0060Gateway\u0060。\n\n\u0060\u0060\u0060yaml\n...\nspec:\n  parentRefs:\n    - name: platform\n      namespace: infrastructure\n\u0060\u0060\u0060\n\n因此，使用来自云提供商的相同负载均衡器。\n\n\u0060\u0060\u0060console\nNLB_DOMAIN=$(kubectl get svc -n infrastructure cilium-gateway-platform -o jsonpath={.status.loadBalancer.ingress[0].hostname})\n\ndig \u002bshort ${NLB_DOMAIN}\n13.36.89.108\n\ndig \u002bshort grafana-mycluster-0.cloud.ogenki.io\n13.36.89.108\n\ndig \u002bshort gitops-mycluster-0.cloud.ogenki.io\n13.36.89.108\n\u0060\u0060\u0060\n\n{{\u003ccallout note 注意\u003e}}\n这些内部工具不应该暴露在互联网上，但是你知道：这只是一个演示。例如，我们可以使用内部 Gateway（私有 IP）通过调整注释并使用私有连接系统（VPN、隧道等）来实现。\n{{\u003c\/callout\u003e}}\n\n### 流量分流\n\n![分流](split.jpg)\n\n由服务网格常常提供的一个功能是在有新版本可用时（A\/B 测试或金丝雀部署）对部分流量测试应用程序的能力。\u0060GAPI\u0060通过使用权重来实现这一点，使其变得非常简单。\n\n以下是一个将 5% 的流量转发到服务 \u0060echo-2-echo-server\u0060 的示例：\n\n[apps\/base\/echo\/httproute-split.yaml](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/apps\/base\/echo\/httproute-split.yaml)\n\n\u0060\u0060\u0060yaml\n...\n  hostnames:\n    - \u0022split-echo.${domain_name}\u0022\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \/\n      backendRefs:\n        - name: echo-1-echo-server\n          port: 80\n          weight: 95\n        - name: echo-2-echo-server\n          port: 80\n          weight: 5\n\u0060\u0060\u0060\n\n让我们检查分发是否按预期进行：\n\n[scripts\/check-split.sh](https:\/\/github.com\/Smana\/cilium-gateway-api\/blob\/main\/scripts\/check-split.sh)\n\n\u0060\u0060\u0060console\n.\/scripts\/check-split.sh https:\/\/split-echo.cloud.ogenki.io\necho-1 的请求次数：95\necho-2 的请求次数：5\n\u0060\u0060\u0060\n\n### 修改标头\n\n还可以更改 HTTP **标头**：添加、修改或删除它们。这些修改可以通过在 \u0060HTTPRoute\u0060 清单中使用 [filters](https:\/\/gateway-api.sigs.k8s.io\/api-types\/httproute#filters-optional) 应用于请求标头或响应标头。\n\n例如，我们将在 **请求** 中添加一个标头。\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: echo-1\n  namespace: echo\nspec:\n...\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \/req-header-add\n      filters:\n        - type: RequestHeaderModifier\n          requestHeaderModifier:\n            add:\n              - name: foo\n                value: bar\n      backendRefs:\n        - name: echo-1-echo-server\n          port: 80\n...\n\u0060\u0060\u0060\n\n此命令允许查看标头是否确实已添加：\n\n\u0060\u0060\u0060console\ncurl -s https:\/\/echo.cloud.ogenki.io\/req-header-add | jq \u0027.request.headers\u0027\n{\n  \u0022host\u0022: \u0022echo.cloud.ogenki.io\u0022,\n  \u0022user-agent\u0022: \u0022curl\/8.2.1\u0022,\n  \u0022accept\u0022: \u0022*\/*\u0022,\n  \u0022x-forwarded-for\u0022: \u002281.220.234.254\u0022,\n  \u0022x-forwarded-proto\u0022: \u0022https\u0022,\n  \u0022x-envoy-external-address\u0022: \u002281.220.234.254\u0022,\n  \u0022x-request-id\u0022: \u0022320ba4d2-3bd6-4c2f-8a97-74296a9f3f26\u0022,\n  \u0022foo\u0022: \u0022bar\u0022\n}\n\u0060\u0060\u0060\n\n## 分配适当的权限\n\n\u0060GAPI\u0060 提供了一种清晰的权限共享模型，用于管理流量路由基础设施（由集群管理员管理）和应用程序（由开发人员管理）之间的关系。\n\n多个自定义资源的可用性允许使用 Kubernetes 的 **RBAC** 配置以声明性方式分配权限。我已经添加了一些示例，这些示例在我的演示集群中没有效果，但可能会给你一个想法。\n\n下面的配置授予 \u0060developers\u0060 组的成员在 echo 命名空间内管理 \u0060HTTPRoutes\u0060 的能力，同时仅提供对 \u0060Gateways\u0060 的读取权限。\n\n\u0060\u0060\u0060yaml\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: Role\nmetadata:\n  namespace: echo\n  name: gapi-developer\nrules:\n  - apiGroups: [\u0022gateway.networking.k8s.io\u0022]\n    resources: [\u0022httproutes\u0022]\n    verbs: [\u0022*\u0022]\n  - apiGroups: [\u0022gateway.networking.k8s.io\u0022]\n    resources: [\u0022gateways\u0022]\n    verbs: [\u0022get\u0022, \u0022list\u0022]\n---\napiVersion: rbac.authorization.k8s.io\/v1\nkind: RoleBinding\nmetadata:\n  name: gapi-developer\n  namespace: echo\nsubjects:\n  - kind: Group\n    name: \u0022developers\u0022\n    apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: gapi-developer\n  apiGroup: rbac.authorization.k8s.io\n\u0060\u0060\u0060\n\n## 乍一看有点模糊\n\n人们可能会对通常称为 \u0060API 网关\u0060 的东西感到困惑。已经创建了 [FAQ](https:\/\/gateway-api.sigs.k8s.io\/faq\/) 的一个部分，以澄清它与 \u0060Gateway API\u0060 的不同之处。尽管 GAPI 提供了通常在 API 网关中找到的功能，但它主要是 Kubernetes 的一个特定实现。然而，选择这个名称确实可能引起 **混淆**。\n\n此外，请注意，本文仅关注入站流量，通常由 *Ingress Controllers* 管理，称为 [南北](https:\/\/gateway-api.sigs.k8s.io\/concepts\/glossary\/#northsouth-traffic)，这实际上是 GAPI 的初始范围。最近的一个名为 [**GAMMA**](https:\/\/gateway-api.sigs.k8s.io\/concepts\/gamma\/) 的倡议旨在处理 [东西流量](https:\/\/gateway-api.sigs.k8s.io\/concepts\/glossary\/#eastwest-traffic) 路由，这将在将来标准化某些常见的功能，通常由 \u0060Service Meshes\u0060 解决方案提供。（有关更多详细信息，请参阅 [此文章](https:\/\/kubernetes.io\/blog\/2023\/08\/29\/gateway-api-v0-8\/)）。\n\n## 最后的想法\n\n老实说，我已经知道 **Gateway API** 有一段时间了。尽管我读了一些文章，但我并没有真正深入研究过。我会想：“为什么要麻烦呢？我的 *Ingress Controller* 可以工作，而且这需要学习曲线。”\n\nGAPI 正在崭露头角，即将发布 GA 版本。多个 [项目](https:\/\/gateway-api.sigs.k8s.io\/implementations\/) 已经拥抱它，这个用于管理 Kubernetes 内流量的 API 将迅速成为标准。\n\n我必须说，配置 GAPI 感觉直观而明确。它的安全模型取得了平衡，赋予开发人员权力而不会损害安全性。而且无缝的基础设施管理？你可以在不触及 \u0060*Routes\u0060 的情况下在不同的实现之间切换。\n\n现在就用 \u0060Cilium\u0060 交换我的 Ingress Controller 吗？**还没有，但它即将到来**。\n\n值得强调的是，Cilium 的功能非常广泛：在 Kubernetes 周围有大量的工具，Cilium 脱颖而出，承诺提供指标、跟踪、服务网格、安全性，以及 *Ingress Controller* 与 GAPI。\n\n然而，需要注意一些挑战：\n\n- [TCP 和 UDP 支持](https:\/\/github.com\/cilium\/cilium\/issues\/21929)\n- [GRPC 支持](https:\/\/github.com\/cilium\/cilium\/issues\/21928)\n- 需要使用变异规则来配置云组件（[Github Issue](https:\/\/github.com\/cilium\/cilium\/issues\/25357)）。\n- 本文讨论的许多功能仍处于实验阶段。例如，最新版本（我写作时的 \u0060v1.14.2\u0060）支持的 [扩展功能](https:\/\/github.com\/cilium\/cilium\/pull\/27472)。我尝试设置一个简单的 HTTP\u003eHTTPS 重定向，但遇到了 [这个问题](https:\/\/github.com\/kubernetes-sigs\/gateway-api\/issues\/1185)。因此，我预计 API 将来会有一些修改。\n\n虽然我只是涉及了 Cilium 的 GAPI 能够提供的一小部分内容（老实说，这篇文章已经相当长了），但我希望我们可以很快在生产中使用它。但考虑到前面提到的几点，我建议等待一段时间。不过，如果你想为未来做准备，那么现在是时候了！\n\n## 参考资料\n\n- https:\/\/gateway-api.sigs.k8s.io\/\n- https:\/\/docs.cilium.io\/en\/latest\/network\/servicemesh\/gateway-api\/gateway-api\/#gs-gateway-api\n- https:\/\/isovalent.com\/blog\/post\/cilium-gateway-api\/\n- https:\/\/isovalent.com\/blog\/post\/tutorial-getting-started-with-the-cilium-gateway-api\/\n- Isovalent 的 [labs](https:\/\/isovalent.com\/resource-library\/labs\/) 是开始使用 Gateway API 并且你将获得新的徽章以添加到你的收藏中的好方法\n', '\/trans\/cilium-gateway-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章介绍了如何使用 Cilium 部署和配置 Gateway API，一个新的服务网格 API，用于管理 Kubernetes 中的服务间通信。文章详细说明了 Gateway API 的概念和组件，以及如何使用 Cilium 的特性和工具，实现高效和灵活的路由策略。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/jwts-authenticate-services-api-gateways/">[译] JWT 在 API 网关中的角色：服务间认证的新视角</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/12/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.solo.io/blog/jwts-authenticate-services-api-gateways/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('JWT 在 API 网关中的角色：服务间认证的新视角', '这篇博客探讨了在云原生架构中使用 JSON Web Tokens（JWT）进行服务间通信的复杂性。它详细讨论了通过 API 网关和服务网格实现安全认证的两种方法，强调了使用 JWT 的挑战，包括安全性、密钥管理和性能问题。', '\n云原生架构中的 API 网关组件至关重要，因为它将关键的 API 安全性和策略功能卸载到一个公共位置，使后端 API 和服务能够专注于业务逻辑。API 身份验证、授权、审计、限流等任务可能会非常复杂且难以正确实现，因此许多组织选择使用 API 网关来处理它们。\n\n那么对于服务与服务（S2S）或内部东\/西流量呢？强制 S2S 流量“回头”通过 API 网关会引入额外的跳跃、更多的延迟、增加的流量以及效率降低。\n\n![通过 API 网关的 S2S 流量“回头”示意图](hairpin-api-gateway-calls.png)\n\n但是，如果您跳过 API 网关直接调用服务，如何确保流量的安全性？接收服务如何进行身份验证并知道是谁在调用它？\n\n![显示 Service B 需要对 Service A 进行身份验证的示意图](service-a-b.png)\n\n保障 S2S 通信的两种常见方式是：\n\n1. 使用传输层安全性（TLS）和客户端证书（双向 TLS 或 mTLS）。\n2. 使用签名的 JSON Web Tokens（JWT）。\n\n[服务网格](https:\/\/www.solo.io\/topics\/service-mesh\/)通过使用第一种方法自动化了许多最佳实践并减轻了与之相关的[问题](https:\/\/istio.io\/latest\/blog\/2023\/secure-apps-with-istio\/)。\n\n开发人员可以选择使用 JWT 进行 S2S 身份验证，但这会“削弱”API 网关的预期功能。也就是说，您曾期望 API 网关处理的所有安全性复杂性和脆弱性必须在每个 S2S 通信的微服务中重新创建和复制。这是一个重大问题，因为使用 JWT 进行 S2S 身份验证会引入复杂性和对细节的严格要求。（有关此主题和下面的场景的更多信息，请观看 Hoot 第 59 集：“[JWT 与 Service-to-Service 身份验证的比较](https:\/\/youtu.be\/Q2KfNUBfnjo)”。所有演示都可以在我们的[GitHub 仓库](https:\/\/github.com\/peterj\/jwts-for-services\/tree\/main)中找到。）\n\n虽然有一些出色的处理 JWT 的框架和库，而 JWT 确实有其用武之地，但将 JWT 用于 S2S 流量的身份验证是复杂且繁重的，并且需要开发人员非常准确地完成工作。这种复杂性（或缺乏意识）可能会降低总体安全性，如果开发人员采取捷径或忽视关键属性，可能会降低总体安全性。开发人员还需要以特定于语言和框架的方式执行此操作（例如，使用 Java 解决此问题与使用 Go 或 Node.js 不同）。在所有代码库中维护、打补丁和审核每个实现都需要付出成本。\n\n## 如何使用 JWT 进行 S2S 通信身份验证\n\n有两种方法可以创建 JWT 以进行 S2S 通信身份验证：使用身份提供者（IdP）（也称为安全令牌服务或 STS）或允许各个服务自行签署 JWT。（如果您对 JWT 概念不熟悉或需要复习，请查看 Auth0 提供的[JWT 概述](https:\/\/auth0.com\/docs\/secure\/tokens\/json-web-tokens)。）\n\n### 选项 1：使用 STS 发放令牌\n\n第一种方法涉及使用安全令牌服务（STS），这是一个可信任的身份或令牌提供者，例如[Keycloak](https:\/\/www.keycloak.org\/)、[Okta](https:\/\/www.okta.com\/)或[Auth0](https:\/\/auth0.com\/)，用于发放代表特定服务的令牌。\n\n在此方法中，服务使用长期凭据（例如用户名和密码或 OAuth2.0 客户端凭据）与 STS 交换 JWT，表明“我是 Service A”。\n\n注意：长期凭据应安全存储并有限使用。例如，您可以在启动时使用它一次来引导身份，并且以后不再使用。此外，这些凭据应仅存储在内存中。\n\nSTS 使用其私钥签署 JWT，可以使用其公钥验证 JWT。然后，Service A 将 JWT 附加到发送给 Service B 的请求中。从这里，Service B 可以通过使用 STS 的公钥验证 JWT 的签名来验证 JWT 是由 STS 签发的。\n\n![显示服务如何相互验证的示意图](authentication.png)\n\n为了使此工作正常运行：\n\n1. 流量必须加密。\n2. 服务 B 必须检查 JWT 的\u0060aud\u0060声明、过期时间、颁发时间以及不早于时间。\n3. 当 STS 签发的 JWT 签名密钥轮换时，服务 B 必须准备好更新 STS 的公钥。\n\n加密流量至关重要，因为在这种情况下使用 JWT 时，它们代表了一个“承载令牌”，因此拥有令牌的任何人都可以冒充 Service A。在 Service A 和 Service B 之间加密流量（例如使用单向服务器 TLS）有助于减轻这个问题。\n\nService B 还必须检查 JWT 的过期时间（\u0060exp\u0060）、颁发时间（\u0060iat\u0060）、不早于时间（\u0060nbf\u0060）以及特别是\u0060aud\u0060声明，以验证令牌是否有效（未过期，位于其时间窗口内并用于 Service B 的使用）。JWT 使用这个约定来防范重放攻击，其中攻击者冒充 Service B，从 Service A 获取令牌，然后冒充 Service A 来调用 Service C。有效的 Service C 会检查\u0060aud\u0060声明，看到代表 Service A 的 JWT 是为 Service B 而设计的，然后拒绝它。\n\n每次调用服务 A 都必须使用不同的 JWT，因为\u0060aud\u0060声明会不同。尝试使用没有\u0060aud\u0060声明的 JWT 或使用通配符\u0060aud\u0060声明会增加 JWT 被破坏的风险。避免这样做。\n\n最后，常常被忽略的是轮换 STS 的公钥。在计划的密钥轮换或计划的撤销 STS 用于签署 JWT 的密钥时，Service B（或任何依赖 STS 进行验证的服务）必须能够处理更新的签名公钥。\n\n### 选项 2：让服务自行签署其令牌\n\n第二种方法使用服务特定的密钥来签署 JWT。可以使用对称密钥或非对称密钥。\n\n![使用特定于服务的密钥进行 S2S 身份验证的示意图](authentication-service-specific-keys.png)\n\n在这种情况下，Service A 使用自己的密钥来签署发送给 Service B（或任何其他服务）的 JWT。Service B 将需要 Service A 的公钥（或对称密钥，由于密钥交换和冒充问题更加危险）来验证 Service A 发送的 JWT。实际上，Service B 将需要每个调用它的服务的公钥，这些服务使用 JWT 作为身份验证主体。\n\n与 STS 签发的 JWT 示例一样，服务之间的流量必须加密，Service B 还必须检查\u0060aud\u0060声明，并且您需要一种签署公钥轮换的方法。您还必须为每个调用的服务使用不同的 JWT。\n\n![服务 B 检查 aud 声明](different-jwt-dependent-services.png)\n\n开发人员必须采取措施并跟踪许多内容，以确保一切正确。证书还必须至少分发给一半的服务（接收端的服务）以提供至少单向 TLS。此外，整个过程的关键是密钥管理、轮换和安全保管密钥。\n\n## JWT 可能出现问题的地方\n\n我们已经介绍了 JWT 可用于表示服务身份的一些方式，并提出了关注的领域。在服务架构中，有几个需要密切关注的领域，以避免安全漏洞。如果这些不是牢不可破的，您将为攻击者提供机会来破坏您的系统。\n\n在使用客户端证书\/mTLS（例如服务网格）和 JWT 进行身份验证之间最重要的区别之一是：JWT 通过网络发送敏感的承载令牌材料，而 mTLS 不会。使用 mTLS 时，只会发送公钥，而不会发送私钥，会协商会话密钥。如果 JWT 泄露，JWT 是私密材料，可以被重放。对于证书，只有公共证书被共享。\n\n为防止重播承载令牌，您必须通过设置短暂的到期时间，理想情况下只有几分钟，来限制其暴露。这会增加服务刷新其 JWT 以进行请求的责任。设置数小时、数天或数月的到期时间发生得太频繁。这是一个严重的安全隐患。\n\n另一个重大的安全漏洞是，在使用 STS 获取 JWT 材料时，您会多次通过网络发送长期凭据（例如客户端凭证流程）。这些长期凭据非常敏感，应谨慎使用（例如，在启动时使用），而不应连续使用。\n\n此外，使用通配符\u0060aud\u0060声明或完全省略\u0060aud\u0060声明也是一个重大问题。未能在服务之间一致使用这些约定以进行身份验证会导致严重问题。确保为*每个*调用的服务创建具有正确\u0060aud\u0060声明的 JWT。\n\n最后，密钥轮换与短暂到期时间和 aud 声明检查同样重要。在发生违规事件时，使密钥无效是最后的努力，应尽快且高效地处理。\n\n## JWT 的复杂性是服务网格简化事物的地方\n\n服务网格简化了服务之间的身份验证，并允许开发人员专注于业务逻辑，而不是正确地处理 JWT 和秘密材料（希望如此）。就像 API 网关应用于处理北\/南和入口流量的安全性一样，服务网格应用于处理东\/西和 S2S 流量的安全性。保持服务和 API 专注于它们可以提供的不同 iating 业务价值，而不是模板（但极其重要的）的安全性代码。\n', '\/trans\/jwts-authenticate-services-api-gateways\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇博客探讨了在云原生架构中使用 JSON Web Tokens（JWT）进行服务间通信的复杂性。它详细讨论了通过 API 网关和服务网格实现安全认证的两种方法，强调了使用 JWT 的挑战，包括安全性、密钥管理和性能问题。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/is-it-too-early-to-leverage-ai-for-webassembly/">[译] 将 AI 应用于 WebAssembly 还为时过早吗？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/09/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/is-it-too-early-to-leverage-ai-for-webassembly/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('将 AI 应用于 WebAssembly 还为时过早吗？', 'Fermyon Technologies 认为，将 AI 应用于 WebAssembly 并不为时过早。', '\n摘要：Fermyon Technologies 认为，将 AI 应用于 WebAssembly 并不为时过早。WebAssembly 为在服务器上运行推理提供了坚实的基础，而且在许多不同的环境中，如浏览器和物联网设备等，通过将这些工作负载移动到终端用户设备上，可以消除延迟并避免将数据发送到集中式服务器，同时能够在边缘发现的多种异构设备上运行。Fermyon Serverless AI 通过提供超过 100 倍于其他按需 AI 基础设施服务的亚秒冷启动时间来解决了企业级 AI 应用程序成本高的问题。这是一种共生关系。\n\n---\n\n人工智能及其在 IT、软件开发和运营方面的应用刚开始发挥作用，预示着人类角色将如何在近期和长期内演变，特别是在较小的规模上，WebAssembly 代表着一种正在引起重大关注的技术，同时证明了其可行性，但成功的商业模型尚未实现，主要是由于最终端点的缺乏标准化。与此同时，至少有一家供应商 Fermyon 认为，在这个阶段应用 AI 于 WebAssembly 并不为时过早。\n\n那么，AI 如何潜在地帮助 Wasm 的开发和采用，这是否为时过早？正如 VMware CTO 办公室的高级工程师 Angel M De Miguel Meana 所指出的那样，自从 ChatGPT 推出以来，AI 生态系统已经发生了巨大的变化，WebAssembly 为在服务器上运行推理提供了坚实的基础，而且在许多不同的环境中，如浏览器和物联网设备等，通过将这些工作负载移动到终端用户设备上，可以消除延迟并避免将数据发送到集中式服务器，同时能够在边缘发现的多种异构设备上运行。由于 Wasm 生态系统仍在兴起，因此在早期阶段集成 AI 将有助于推动新的和现有的与 AI 相关的标准。这是一种共生关系。\n\n## 完美的匹配\n\nFermyon Technologies 的联合创始人兼首席执行官 Matt Butcher 告诉 The New Stack：“我们成立 Fermyon 的目标是打造下一代无服务器平台。AI 显然是这一下一代的一部分。在我们的行业中，我们经常看到革命性的技术一起成长：Java 和 Web、云和微服务、Docker 和 Kubernetes。WebAssembly 和 AI 是一对完美的组合。我看到它们一起成长（并变老）。”\n\n“烘焙”AI 模型，如 LLM（大型语言模型）或转换器，到 WebAssembly 运行时中，是加速采用 WebAssembly 的逻辑下一步，Enterprise Management Associates (EMA) 的分析师 Torsten Volk 告诉 The New Stack。与调用诸如通过 API 的数据库服务类似，编译 WebAssembly 应用程序（二进制文件）可以将其 API 请求发送到 WebAssembly 运行时，该运行时将该调用中继到 AI 模型并将模型响应返回给发起者，Volk 说。\n\n“一旦我们有一个提供开发人员一个标准 API 的通用组件模型（CCM），访问数据库、AI 模型、GPU、消息传递、身份验证等，这些 API 请求将变得非常强大。CCM 将让开发人员编写相同的代码，在数据中心、云甚至边缘位置的任何类型的服务器上与 AI 模型（例如 GPT 或 Llama）进行通信，只要该服务器拥有足够的硬件资源可用，”Volk 说。“这一切都归结为关键问题，即产业参与者何时会就 CCM 达成一致。同时，WebAssembly 云（如 Fermyon）可以利用 WebAssembly 使 AI 模型在其自己的云基础设施中具有可移植性和可扩展性，无需 CCM，并将一些节省成本传递给客户。”\n\n## 解决问题\n\n同时，Fermyon 认为，在这个阶段应用 AI 于 WebAssembly 并不为时过早。正如 Butcher 所指出的那样，负责在 LLM（如 LLaMA2）上构建和运行企业 AI 应用程序的开发人员面临着 100 倍计算成本的挑战，即每小时 32 美元及以上的 GPU 访问费用。或者，他们可以使用按需服务，但是启动时间却非常慢。这使得以实惠的方式提供企业级 AI 应用程序变得不切实际。\n\nFermyon Serverless AI 通过提供超过 100 倍于其他按需 AI 基础设施服务的亚秒冷启动时间来解决了这个问题，Butcher 说。这一“突破”得益于驱动 Fermyon Cloud 的服务器 WebAssembly 技术，该技术被架构为亚毫秒冷启动和高容量时间分片的计算实例，已被证明可以将计算密度提高 30 倍。“将此运行时配置文件扩展到 GPU 将使 Fermyon Cloud 成为最快的 AI 推理基础设施服务，”Butcher 说。\n\nVolk 说，这样的推理服务“非常有趣”，因为典型的 WebAssembly 应用程序仅包含几兆字节，而 AI 模型的大小要大得多。这意味着它们不会像传统的 WebAssembly 应用程序那样启动得那么快。“我认为 Fermyon 已经想出了如何使用时间分片为 WebAssembly 应用程序提供 GPU 访问的方法，以便所有这些应用程序都可以通过其 WebAssembly 运行时保留一些时间片来获取所需的 GPU 资源”，Volk 说。“这意味着很多应用程序可以共享一小部分昂贵的 GPU，以按需为其用户提供服务。这有点像分时共享，但不需要强制参加午餐时间的演示。”\n\n使用 Spin 入门。\n\n!https:\/\/prod-files-secure.s3.us-west-2.amazonaws.com\/86575c70-5cc9-4b3e-bee7-d1bb14ba20e3\/6bf78916-e34c-4051-86a7-52145cdc372a\/4a27b287-capture-decran-2023-09-05-192118.png\n\n那么，用户如何与 Serverless AI 交互？Fermyon 的 Serverless AI 没有 REST API 或外部服务，它仅构建在 Fermyon 的 Spin 本地和 Fermyon Cloud 中，Butcher 解释说。“在您的代码的任何位置，您都可以将提示传递到 Serverless AI 并获得响应。在这个第一个测试版中，我们包括 LLaMa2 的聊天模型和最近宣布的 Code Llama 代码生成模型，”Butcher 说。“因此，无论您是在总结文本、实现自己的聊天机器人还是编写后端代码生成器，Serverless AI 都可以满足您的需求。我们的目标是使 AI 变得简单，使开发人员可以立即开始利用它来构建新的令人瞩目的无服务器应用程序。”\n\n## 重要意义\n\n使用 WebAssembly 来运行工作负载，可以使用 Fermyon Serverless AI 将“GPU 的一小部分”分配给用户应用程序，以“及时”执行 AI 操作，Fermyon CTO 和联合创始人 Radu Matei 在一篇博客文章中写道。 “当操作完成时，我们将该 GPU 的一小部分分配给队列中的另一个应用程序，”Matei 写道。“由于 Fermyon Cloud 中的启动时间为毫秒级，因此我们可以在分配给 GPU 的用户应用程序之间快速切换。如果所有 GPU 分数都在忙于计算数据，我们将在下一个可用的应用程序之前将传入的应用程序排队。”\n\n这有两个重大的影响，Matei 写道。首先，用户不必等待虚拟机或容器启动并附加到 GPU 上。此外，“我们可以实现更高的资源利用率和效率，”Matei 写道。\n\nFermyon 传达的 Serverless AI 的具体特点包括：\n\n- 这是一款开发人员工具和托管服务，专为使用开源 LLM 进行 AI 推理的无服务器应用程序而设计。\n- 由于我们的核心 WebAssembly 技术，我们的冷启动时间比竞争对手快 100 倍，从几分钟缩短到不到一秒。这使我们能够在相同的时间内（并且使用相同的硬件）执行数百个应用程序（二进制文件），而今天的服务用于运行一个。\n- 我们为使用 Spin 构建和运行 AI 应用程序提供了本地开发体验，然后将其部署到 Fermyon Cloud 中，以高性能的方式以其他解决方案的一小部分成本提供服务。\n- Fermyon Cloud 使用 AI 级别的 GPU 处理每个请求。由于我们的快速启动和高效的时间共享，我们可以在数百个应用程序之间共享单个 GPU。\n- 我们正在推出免费的私人测试版。\n\n## 大希望\n\n然而，在 Wasm 和 AI 同时达到潜力之前，还有很长的路要走。在 WasmCon 2023 上，Second State 的 CEO 兼联合创始人 Michael Yuan 和 Wasm 的运行时项目以及 WasmEdge 的讨论了一些正在进行的工作。他在与 De Miguel Meana 的谈话中涵盖了这个话题，“开始使用 AI 和 WebAssembly”在 WasmCon 2023 上。\n\n“在这个领域（AI 和 Wasm）需要做很多生态系统工作。例如，仅拥有推理是不够的，”Yuan 说。“现在的百万美元问题是，当您拥有图像和文本时，如何将其转换为一系列数字，然后在推理之后如何将这些数字转换回可用的格式？”\n\n预处理和后处理是 Python 今天最大的优势之一，这得益于为这些任务提供的众多库，Yuan 说。将这些预处理和后处理函数合并到 Rust 函数中将是有益的，但需要社区更多的努力来支持其他模块。“这个生态系统有很大的增长潜力，”Yuan 说。\n', '\/trans\/is-it-too-early-to-leverage-ai-for-webassembly\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Fermyon Technologies 认为，将 AI 应用于 WebAssembly 并不为时过早。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-to-add-bpf-observability/">[译] 如何在产品中引入 eBPF 以增加可观测性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在产品中引入 eBPF 以增加可观测性', '本文是给想要在产品中引入 eBPF 增加可观测性人员的忠告。', '\n## 编者按\n\n本文译自 [How To Add eBPF Observability To Your Product](https:\/\/www.brendangregg.com\/blog\/2021-07-03\/how-to-add-bpf-observability.html)，原文发布于 2021 年 7 月 3 日。本文作者 Brendan Gregg 是 eBPF 领域的专家，出版过多本相关书籍，本文是他给想要在产品中引入 eBPF 增加可观测性人员的忠告。\n\n## 正文\n\n现在有一场军备竞赛，即增加 eBPF 的军备竞赛，在这篇文章中，我将介绍如何快速做到这一点。这也适用于人们将其添加到自己的内部监测系统中。\n\n人们喜欢在他们建立了原型或构建了产品之后向我展示他们的 BPF 可观测性产品，但我常常在他们开始之前给出建议。作为 BPF 可观测性的领导者，这是我在最近的谈话中一直包含的建议，现在我把它纳入这篇文章中。\n\n首先，我知道你很忙。你甚至可能不喜欢 BPF。为了务实起见，我将描述如何花最少的精力来获得最大的价值。把这看成是“第一版”。一个相当有用的出发点。无论你是否遵循这个建议，至少请你理解它，以避免以后的遗憾和痛苦。\n\n如果你正在使用开源监控平台，首先检查它是否已经有一个 BPF 代理。这篇文章假设它没有，而且你将首次添加一些东西。\n\n## 1. 运行第一个工具\n\n首先安装 [bcc](https:\/\/github.com\/iovisor\/bcc) 或 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 工具。例如，Ubuntu 上的 bcc。\n\n\u0060\u0060\u0060sh\n# apt-get install bpfcc-tools\n\u0060\u0060\u0060\n\n然后尝试运行一个工具。例如，使用 execsnoop (8) 查看带有时间戳的进程执行情况。\n\n\u0060\u0060\u0060sh\n# execsnoop-bpfcc -T\nTIME     PCOMM            PID    PPID   RET ARGS\n19:36:15 service          828567 6009     0 \/usr\/sbin\/service --status-all\n19:36:15 basename         828568 828567   0 \n19:36:15 basename         828569 828567   0 \/usr\/bin\/basename \/usr\/sbin\/service\n19:36:15 env              828570 828567   0 \/usr\/bin\/env -i LANG=en_AU.UTF-8 LANGUAGE=en_AU:en LC_CTYPE= LC_NUMERIC= LC_TIME= LC_COLLATE= LC_MONETARY= LC_MESSAGES= LC_PAPER= LC_NAME= LC_ADDRESS= LC_TELEPHONE= LC_MEASUREMENT= LC_IDENTIFICATION= LC_ALL= PATH=\/opt\/local\/bin:\/opt\/local\/sbin:\/usr\/local\/git\/bin:\/home\/bgregg\/.local\/bin:\/home\/bgregg\/bin:\/opt\/local\/bin:\/opt\/local\/sbin:\/ TERM=xterm-256color \/etc\/init.d\/acpid \n19:36:15 acpid            828570 828567   0 \/etc\/init.d\/acpid status\n19:36:15 run-parts        828571 828570   0 \/usr\/bin\/run-parts --lsbsysinit --list \/lib\/lsb\/init-functions.d\n19:36:15 systemctl        828572 828570   0 \/usr\/bin\/systemctl -p LoadState --value show acpid.service\n19:36:15 readlink         828573 828570   0 \/usr\/bin\/readlink -f \/etc\/init.d\/acpid\n[...]\n\u0060\u0060\u0060\n\n虽然很基本，但我仅用这个工具就解决了很多 perf 问题，包括针对配置错误的系统，其中一个 shell 脚本正在循环启动失败的进程，以及当一些小程序崩溃并每隔几分钟就重启但还没有被注意到时。\n\n## 2. 为你的产品添加一个工具\n\n现在想象一下将 execsnoop (8) 添加到你的产品中。你可能已经在你所有的客户系统上运行了代理。他们是否有办法运行一个命令并返回文本输出？或者运行一个命令并将输出发送到其他地方进行聚合（S3、Hive、Druid 等）？有很多选择，这实际上是你自己基于现有系统和客户环境的偏好。\n\n当你把第一个工具添加到你的产品中时，让它在短时间内运行，比如 10 到 60 秒。我刚刚注意到 execsnoop (8) 还没有持续时间选项，所以在这期间你可以用 \u0060watch -s2 60 execsnoop-bpfcc\u0060 来包装它。如果你想 24 小时运行这些工具，首先要研究开销以了解成本。低频率的事件，如进程的执行，捕捉起来应该是可以忽略不计的。\n\n不使用 bcc，你也可以使用 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 版本。这些通常没有封装选项（-v、-l 等），但有一个 json 输出模式。例如：\n\n\u0060\u0060\u0060sh\n# bpftrace -f json execsnoop.bt \n{\u0022type\u0022: \u0022attached_probes\u0022, \u0022data\u0022: {\u0022probes\u0022: 2}}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u0022TIME(ms)   PID   ARGS\\n\u0022}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u00222737       849176 \u0022}\n{\u0022type\u0022: \u0022join\u0022, \u0022data\u0022: \u0022ls -F\u0022}\n{\u0022type\u0022: \u0022printf\u0022, \u0022data\u0022: \u00225641       849178 \u0022}\n{\u0022type\u0022: \u0022join\u0022, \u0022data\u0022: \u0022date\u0022}\n\u0060\u0060\u0060\n\n添加这种模式是为了使 BPF 的可观测性产品可以建立在 bpftrace 之上。\n\n## 3. 不要担心依赖性问题\n\n我建议你在客户系统上安装 bcc 或 bpftrace，它们目前有 llvm 依赖。这可能会增加到几十 MB，这对一些资源有限的环境（嵌入式）是个问题。我们一直在做大量的工作，以便在未来解决这个问题。 [BTF and CO-RE](https:\/\/www.brendangregg.com\/blog\/2020-11-04\/bpf-co-re-btf-libbpf.html)（而不是 Python），最终将意味着你可以安装 100KB 的无依赖性的工具二进制版本。bpftrace 也有一个类似的计划，使用较新的内核特性生成一个小的无依赖性的二进制版本。\n\n这确实需要至少 Linux 5.8 才能很好地工作，而你的客户可能几年都不会运行这个系统。在这期间，我建议暂时不要担心 llvm 的依赖关系，因为它以后会被修复。\n\n请注意，并不是所有的 Linux 发行版都启用了 \u0060CONFIG_DEBUG_INFO_BTF=y\u0060，这对于 BTF 和 CO-RE 的未来是必要的。主要的发行版已经设置了它，比如在 Ubuntu 20.10、Fedora 30 和 RHEL 8.2。但如果你知道你的一些客户正在运行一些不常见的东西，请检查并鼓励他们或发行商设置 \u0060CONFIG_DEBUG_INFO_BTF=y\u0060 和 \u0060CONFIG_DEBUG_INFO_BTF_MODULES=y\u0060，以避免未来的痛苦。\n\n## 4. 第 1 版仪表板\n\n现在你的产品中有了一个 BPF 可观测性工具，是时候增加更多的工具了。下面是你可以运行的十大工具，并作为一个通用的 BPF 可观测性仪表盘来展示，同时还有建议的可视化。\n\n| 编号 | 工具       | 展示                    | 可视化           |\n| ---- | ---------- | ----------------------- | ---------------- |\n| 1.   | execsnoop  | 新进程（通过 exec (2)） | 表格             |\n| 2.   | opensnoop  | 打开的文件              | 表格             |\n| 3.   | ext4slower | 慢速文件系统 I\/O        | 表格             |\n| 4.   | biolatency | 磁盘 I\/O 延迟柱状图     | 热力图           |\n| 5.   | biosnoop   | 每个事件的磁盘 I\/O 细节 | 表格，偏移热图   |\n| 6.   | cachestat  | 文件系统高速缓存统计    | 线状图           |\n| 7.   | tcplife    | TCP 连接                | 表格，分布式图表 |\n| 8.   | tcpretrans | TCP 重传                | 表格             |\n| 9.   | runqlat    | CPU 调度器的延迟        | 热力图           |\n| 10.  | profile    | CPU 堆栈跟踪样本        | 火焰图           |\n\n这是在我的 [bcc Tutorial](https:\/\/github.com\/iovisor\/bcc\/blob\/master\/docs\/tutorial.md) 的，而且很多也存在于 bpftrace 中。我选择这些是为了用最少的工具找到最大的性能优势。\n\n请注意，runqlat 和 profile 会有明显的开销，所以我只运行这些工具 10 到 60 秒，然后生成一份报告。有些工具的开销很低，如果需要的话可以 24 小时运行（例如 execsnoop、biolatency、tcplife、tcpretrans）。\n\n在 bcc 和 bpftrace 资源库中，已经有以手册和实例文件形式存在的文档，你可以链接到这些文档，以帮助你的客户了解工具的输出。例如，在 [bcc](https:\/\/github.com\/iovisor\/bcc\/blob\/master\/tools\/execsnoop_example.txt) 和 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace\/blob\/master\/tools\/execsnoop_example.txt) 有 execsnoop (8) 的示例文件。\n\n完成这些后，你就有了第一版的仪表板。\n\n## bcc 与 bpftrace\n\nbcc 工具是最容易使用的，因为它们通常有很多命令行选项。bpftrace 工具更容易编辑和定制，而且 bpftrace 有一个 json 输出模式。\n\n如果你是追踪的新手，就用 bcc 吧。如果你想做一些黑客和定制的工具，就用 bpftrace。最后，它们都是不错的选择。\n\n## 案例研究：Netflix\n\nNetflix 正在建立一个新的 GUI，在这些工具的 bpftrace 版本的基础上，做这个工具仪表盘和更多的工作。架构如图。\n\n![](008i3skNly1gys3a6aaa2j31310u0tcj.jpg) \n\n虽然 bpftrace 二进制文件安装在所有目标系统上，但 bpftrace 工具（文本文件）却在网络服务器上，并在需要时被推送出去。这意味着我们可以通过在一个地方更新工具来确保我们一直在运行最新版本的工具。\n\n这是目前我们 FlameCommander 用户界面的一部分，它也在云端运行火焰图。我们以前的 BPF GUI 是 [Vector](https:\/\/github.com\/Netflix\/vector) 的一部分，并使用了 bcc，但我们后来废弃了它。我们可能会在某个时候开源新的 GUI，并在 Netflix 技术博客上发表相关文章。\n\n## 案例研究：Facebook\n\nFacebook 是 BPF 的高级用户，但他们如何在整个集群中运行工具的深层细节并没有完全公开。根据 bcc 的活动，以及他们对 BTF 和 CO-RE 技术的开发，我十分怀疑他们的解决方案是基于 bcc 的 libbpf-tool 版本。\n\n## 移植的陷阱\n\nBPF 追踪工具就像应用程序和内核的补丁。它们需要不断的更新以保持在不同的软件版本中工作。把它们移植到不同的语言，然后不维护它们，可能就像试图把 Linux 4.15 的补丁应用于 Linux 5.12。如果你运气好，它就会工作！如果你不走运，补丁就会应用，但会以一种微妙的方式破坏一些东西，直到后来你才注意到。这取决于工具。\n\n作为一个极端的例子，我在 2014 年休假时写了 cachestat (8)，用于 Netflix cloud，当时是 Linux 3.2 和 3.13 的混合版本。BPF 在这些版本上并不存在，所以我使用了 Linux 3.2 上的基本 Ftrace 功能。我把这种方法描述为 [brittle](https:\/\/www.brendangregg.com\/blog\/2014-12-31\/linux-page-cache-hit-ratio.html)， [sandcastle](https:\/\/github.com\/brendangregg\/perf-tools\/blob\/master\/fs\/cachestat) 需要随着内核的变化而进行维护。后来，它被移植到了带有 kprobes 的 BPF 上，现在已经被重写并包含在商业可观测性产品中。我听说它在较新的内核上有问题，打印的输出没有意义。它真的需要一次大修。当我（或某人）做了这个工作，任何从 bcc 上拉取更新的人都会自动得到固定的版本，不需要费力。那些重写的人将需要重写自己的版本。我担心他们不会这样做，而客户将在多年来一直运行一个错误的 cachestat (8) 版本。\n\n请注意，如果在我写 cachestat (8) 的时候，BPF 在我的目标环境中是可用的，我的编码方式就会完全不同。人们正在移植为 Linux 3.2 编写的东西，并在 Linux 5.x 上运行它。\n\n在以前的一篇博文 [An Unbelievable Demo](https:\/\/www.brendangregg.com\/blog\/2021-06-04\/an-unbelievable-demo.html) 中，谈到了很多年前发生的类似情况，即在没有更新的情况下使用旧的追踪工具版本。\n\n我所描述的问题是针对 BPF 软件和内核追踪的。作为一个不同的例子，我的火焰图软件已经被重写了十几次，由于它是一个简单而完备的算法，我不认为这有什么大问题。我更喜欢人们帮助更新 [d3 version](https:\/\/github.com\/spiermar\/d3-flame-graph) 但如果人们自己做，那也没什么大不了的。你可以给它编码，它将永远工作。基于 uprobe 和 kprobe 的 BPF 工具就不是这样了，因为它们确实需要维护。\n\n## 像系统管理员一样思考，而不是像程序员一样思考\n\n总之，首先检查你的监控系统是否已经有一个 BPF 代理，如果没有，就在现有的基础上构建一个 [bcc](https:\/\/github.com\/iovisor\/bcc) 或 [bpftrace](https:\/\/github.com\/iovisor\/bpftrace) 工具，而不是从头开始重写一切。这是像一个安装和维护软件的系统管理员那样思考，而不是像一个编码所有东西的程序员那样思考。安装 bcc 或 bpftrace 工具，把它们添加到你的可观测性产品中，并根据需要拉取包的更新。这将是一个快速而有用的版本。BPF 启动和运行了！\n\n我看到人们反而像程序员一样思考，觉得他们必须从深入学习 bcc 和 BPF 编程。然后，在发现所有的东西都是 C 语言或 Python 写的之后，有些人就用不同的语言重写了。\n\n首先，学好 bcc 和 BPF 需要几周时间；学习系统跟踪的微妙之处和陷阱可能需要几个月或几年。为了让你了解你所面临的情况，请看我的 [BPF Internals](https:\/\/www.brendangregg.com\/blog\/2021-06-15\/bpf-internals.html) 讲座。如果你真的想做这个，并且有时间，你当然可以（你可能会在 Tracing 会议上遇到我。在 Linux Plumber’s 或追 Tracing 会上见！）但是，如果你在某个期限内要增加 BPF 的可观测性，那就试着像一个系统管理员那样思考，并在现有的工具基础上进行构建。这是快速的方法。以后再像程序员那样思考，如果你有时间的话。\n\n第二，BPF 软件，特别是某些基于 kprobe 的工具，需要持续的维护。一个工具可能在 Linux 5.3 上工作，但在 5.4 上就会坏掉，因为一个被追踪的函数被重新命名或增加了一个新的代码路径。BPF 库和框架也在变化和发展，最近的一次是 BTF 和 CO-RE 支持。这是我希望人们在选择重写它们之前要考虑的问题。你是否也有计划重写所有的更新，或者你最终会被困在一个旧的库的端口上？拉取所有的更新比维护你自己的版本更容易。\n\n最后，如果你有一个比我们在 bcc 和 bpftrace 中使用的更好的 BPF 库或框架的好主意呢？和我们谈谈，试试，创新一下。我们正处于 BPF 时代的开端，还有很多东西需要探索。但请先了解现有的情况以及你所承担的维护负担。你的精力可能会被用来在现有的基础上创造新的东西，而不是移植旧的东西。\n', '\/trans\/how-to-add-bpf-observability\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是给想要在产品中引入 eBPF 增加可观测性人员的忠告。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/are-cloud-based-ides-the-future-of-software-engineering/">[译] 云端 IDE 是软件工程的未来吗？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/are-cloud-based-ides-the-future-of-software-engineering" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云端 IDE 是软件工程的未来吗？', '本文主要对比了云端 IDE 的优缺点，就像云端 Office 一样，云端 IDE 迟早也会变得流行起来。', '\n**编者按**\n\n\u003e 本文主要对比了云端 IDE 的优缺点，就像云端 Office 一样，云端 IDE 迟早也会变得流行起来。\n\n传统上，[软件开发](https:\/\/thenewstack.io\/category\/development\/)是（而且在很大程度上仍然是）在个人机器上使用集成开发环境（IDE）工具，如 VSCode、JetBrains、Eclipse 等完成。虽然这种 \u0022离线\u0022 开发的模式在早期运作得非常好，但人们很快就注意到，这种方法并非完美。\n\n首先，合作起来很麻烦，因为写好的代码必须上传到网上供进一步审查。这样写出来的代码的可移植性也并不总是有保证，因为有各种各样的操作系统和其他限制条件，需要它来实现最佳的功能。\n\n正如开发者和技术记者 [Owen Williams](https:\/\/char.gd\/blog\/author\/owen) 去年 [在他的博客 Charged 上](https:\/\/char.gd\/blog\/2020\/github-codespaces-means-your-computer-doesnt-matter-anymore)写道：“在设备之间同步你的文档和照片是微不足道的…… 这样你就可以在任何地方把它们调出来，但开发者工具仍然停留在过去 —— 每台笔记本电脑或 PC 都要单独配置，使你的环境设置得恰到好处。”\n\n随着大流行期间越来越多的分布式团队和更多的敏捷工作方式，引入能够让开发人员在任何地方保持生产力的工具变得至关重要。这为什么会有 [Gitpod](https:\/\/thenewstack.io\/gitpod-open-sources-a-holistic-ide\/)、[GitHub Codespaces](https:\/\/thenewstack.io\/this-week-in-programming-github-codespaces-portable-dev-environment\/)、Replit 等基于云端 IDE 出现。\n\n## 云端 IDE 的优点\n\n这些新的 IDE 工具具有大量的功能，包括 GitHub 集成，支持多语言的编写和编译，提供了一个整体的环境，以提高开发人员的生产力。\n\n在他们的其他优势中：\n\n### 使用云端 IDE 无需担心配置\n\n由于开发环境完全在浏览器上运行，因此不再需要梳理安装页面和弄清楚需要安装哪个软件包。\n\n### 硬件的选择并不重要\n\n基于云的集成开发环境消除了（好吧，几乎是！）开始进行网络开发的障碍。在任何支持现代网络浏览器都可以运行，你甚至不需要在不同的机器上从头开始重新配置一切。\n\n### 在任何地方工作和协作都很容易\n\n这些工具具有高度可定制的工作空间，可以在团队 \/ 个人层面上进行优化，它们不仅促进了更好的合作，而且完全消除了“在我的机器上可以运行 \u0022 这种太过普遍的情况。鉴于这些主要的优点，很明显基于云的 IDE 已经获得了发展势头。\n\n但云端 IDE 也有一些局限性。\n\n## 云端 IDE 的缺点\n\n基于云的 IDE 的许多缺点都与扩展问题有关，因为这些工具仍然处于成熟的早期阶段。以下是早期采用者可能会遇到的一些关键问题。\n\n### 性能可能是不平衡的\n\n由于云上的资源是由需求不稳定的消费者共享的，因此肯定有机会出现性能不一致的情况，特别是在对网络延迟、容量或整体产品的故障造成问题的情况下，更是如此。\n\n### 故障的来源可能很难识别和解决\n\n当你不知道根本原因时，很难修复一个问题，总的来说，这可能会导致此类产品的早期采用者有一个令人沮丧的体验。\n\n### 大项目可能更适合使用离线 IDE\n\n到今天为止，已经观察到一些初期问题，用户[抱怨平均负载过高](https:\/\/github.com\/gitpod-io\/gitpod\/issues\/5992)。对于大型开发项目，所需的数据传输和处理量将是巨大的。虽然它可能不会扼杀基于云的 IDE 的资源，但由于其实用性，在这种情况下，离线替代方案肯定是更佳选择。\n\n### 供应商锁定会限制工具的可用性\n\n另一个需要考虑的方面是当涉及到基于云端 IDE 时，工具包的可用性。大量的工具可以在本地与 IDE 配对使用。但是，对于基于云端 IDE，开发者被限制在供应商提供的集成选择上，这对于那些需要更广泛工具包的人来说可能是限制性的。\n\n### 云端 IDE 需要 WiFi\n\n最后一点往往被忽略，基于云的 IDE 在与真正强大的桌面 IDE 相媲美之前还有很长的路要走，这些 IDE 允许降低对 WiFi 等外部因素的依赖性。即使正在实施各种变通办法，其可靠性水平也远远不能与桌面 IDE 提供的离线体验相比。\n\n## 下一代集成开发环境\n\n虽然基于桌面的集成开发环境仍是非常规范的，并将继续流行，但基于云的集成开发环境正在发展势头正猛。这些工具也在迅速发展，并可能越来越多地与基于桌面的 IDE 一起使用。\n\n为了类比这一切可能的走向，请考虑微软 Office 的情况。\n\n笔记本电脑 \/ 计算机刚问世时，我们只有微软 Office 作为任何形式的合作的默认套件。它的大部分工作都是离线的。但是，随着 Zoho Office 和 Google Workspace 等基于浏览器的协作工具将很大一部分工作带到了网上，我们现在看到它们比 MS Office 更重要的使用情况。\n\n集成开发环境也会走同样的路。桌面 IDE 仍将被使用（就像现在使用的微软 Office 一样），但基于云的 IDE 将看到一些非常有趣的用例出现，并可能对这些特定用例变得更加重要。\n\n在写这篇文章时，JetBrains 已经发布了其下一代 IDE——Fleet 的早期预览。由于更加关注分布式和协作式开发以及降低入门门槛，JetBrains 的解决方案承诺 Fleet 不会取代该公司现有的工具，而是旨在增加进一步的选择。\n\nGitpod 的社区经理 [Pauline Narvas](https:\/\/www.linkedin.com\/in\/pnarvas\/) 告诉 The New Stack，她对未来的远程、云、开发环境有可能改善开发者的日常生活感到非常兴奋。\n\n她说：“例如，有了标准化的开发者环境，我们可以轻松地加入新的工程师，你可以审查同事的代码，提出 Pull request，甚至为开源做出贡献，“她补充说，“不再有’它在我的机器上工作’的痛苦，也不再有因为依赖关系不工作而破坏预览环境。\n\n“开发人员甚至不需要一台高规格的机器也能开始工作，“Narvas 说。“只要有一个可以联网的浏览器你就可以在任何地方编码！\u0022。这真的是软件工程的未来，我迫不及待地想看看五年后的景象。”\n', '\/trans\/are-cloud-based-ides-the-future-of-software-engineering\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要对比了云端 IDE 的优缺点，就像云端 Office 一样，云端 IDE 迟早也会变得流行起来。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-future-of-microservices/">[译] 微服务的未来——更多层抽象</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/08/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/the-future-of-microservices-more-abstractions/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('微服务的未来——更多层抽象', '在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。', '\n[微服务](https:\/\/thenewstack.io\/category\/microservices\/)是在 10 年前出现的，是软件融合进化的例子之一。虽然这个词可以归功于软件咨询公司 [ThoughtWorks](https:\/\/www.thoughtworks.com\/) 的 [James Lewis](https:\/\/twitter.com\/boicy) 和 Martin Fowler，[Adrian Cockcroft](https:\/\/www.linkedin.com\/in\/adriancockcroft\/) 也曾提出类似的想法。但当时在 Netflix 和许多硅谷的其他公司，如亚马逊、Google 和 eBay 等公司大致在相同的时间内独立搭建了或多或少相同的架构模式。\n\n在这个词诞生后的十年里，我们看到了 Kubernetes、服务网格和无服务器的兴起，我们也开始看到微服务被应用到了前端。除了可以横向扩展，微服务还可以让开发人员更快地部署代码，有利于组件的可替换性而不是可维护性。\n\n无论好坏，对许多人来说，微服务已经成为默认的架构选择。对于拥有自主团队和松散耦合系统的组织来说，微服务可以很好地工作，但它们带来了所有分布式系统都无法逃避的复杂性。\n\n“我坚决认为公共云比私有云和数据中心更好，这些好处是一目了然的。在许多情况下，是恐惧让人们畏缩不前。“独立技术顾问 [Sam Newman](https:\/\/www.linkedin.com\/in\/samnewman\/) 告诉 The New Stack，他的 [Building Microservices](https:\/\/samnewman.io\/books\/building_microservices_2nd_edition\/) 一书的第二版将在今年 8 月出版。“但是对于微服务，事情将比这复杂得多的多。”\n\n考虑到这一点，在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。\n\n## 盘点：部署和运行时间\n\n现在有各种各样成熟的、设计良好的微服务框架，涵盖了大多数语言的基础知识，在 JVM 上有大量的选择，包括 [Spring Boot](https:\/\/spring.io\/projects\/spring-boot)、[Dropwizard](https:\/\/www.dropwizard.io\/en\/latest\/)、[Helidon](https:\/\/helidon.io\/#\/)、[Lagom](https:\/\/www.lagomframework.com\/)、[Micronaut](https:\/\/micronaut.io\/) 和 [Quarkus](https:\/\/quarkus.io\/)，同时还有 [Go kit](https:\/\/github.com\/go-kit\/kit)（Go）、[Flask](https:\/\/flask.palletsprojects.com\/en\/2.0.x\/) 和 [Falcon](https:\/\/falconframework.org\/)（Python）、[Node.js](https:\/\/nodejs.org\/en\/)（JavaScript）等选择。\n\n同样地，好的监控工具也比比皆是。[OpenTelemetry](https:\/\/thenewstack.io\/getting-started-with-opentelemetry-for-java\/) 的出现尤其重要。它由 OpenTracing 和 OpenCensus 合并而成，拥有广泛的供应商和语言支持，为分布式遥测数据提供标准化。这意味着开发人员只需要对他们的代码进行一次检测，然后就可以交换和改变监控工具，比较相互竞争的解决方案，甚至在生产中为不同的需求运行多个不同的监控解决方案。\n\n然而，当我们看向部署和运行时，情况就变得有点模糊了。Kubernetes 已经或多或少地成为微服务的代名词，它的复杂性不断增加，促使云原生咨询公司 [Container Solutions](https:\/\/www.container-solutions.com\/) 的首席科学家 [Adrian Mouat](https:\/\/twitter.com\/adrianmouat) [猜测](https:\/\/blog.container-solutions.com\/10-predictions-for-the-future-of-computing)我们将看到它的竞争对手出现。\n\n“值得注意的是，这种复杂性不仅仅是隐藏在引擎盖下。“Mouat 说：“它正在溢出到界面上，影响到用户。“黑进 kubectl 运行并得到一个演示并运行仍然相当容易。但是，运行生产应用程序并弄清楚如何安全地暴露它们需要了解大量不同的功能，这不可避免地导致 YAML 文件比大多数微服务源代码还要长。”\n\nNewman 总结了一个基本挑战：“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 [Heroku](https:\/\/www.heroku.com\/) 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。”\n\n[Spotify](https:\/\/www.spotify.com\/) 的工程总监 [Pia Nilsson](https:\/\/www.linkedin.com\/in\/pia-nilsson-02b47b1\/) 曾 [谈到](https:\/\/engineering.atspotify.com\/2021\/05\/18\/a-product-story-the-lessons-of-backstage-and-spotifys-autonomous-culture\/)，这家快速扩张的公司的新工程师平均需要 60 天才能合并他们的第 10 个 pull request。作为回应，该公司建立了一个[开发者门户网站](https:\/\/thenewstack.io\/design-a-better-kubernetes-experience-for-developers\/) [Backstage](https:\/\/engineering.atspotify.com\/2020\/09\/24\/cloud-native-computing-foundation-accepts-backstage-as-a-sandbox-project\/)，现在是 [云原生计算基金会](https:\/\/cncf.io\/?utm_content=inline-mention)的一个[沙盒项目](https:\/\/backstage.io\/)。\n\n[Netflix](https:\/\/about.netflix.com\/) 非常重视 DevEx—— 该公司为开发者铺设的“道路”—— 利用它来帮助 [加速](https:\/\/www.infoq.com\/presentations\/devex-netflix-graphql\/) [GraphQL](https:\/\/graphql.org\/) 等新技术的 [采用](https:\/\/www.infoq.com\/presentations\/devex-netflix-graphql\/)。同样，我们已经看到了内部建设和通过 [Humanitec](https:\/\/humanitec.com\/) 等供应商建设的 [开发者平台](https:\/\/info.container-solutions.com\/the-rise-of-the-internal-developer-platform)的崛起。 [Ambassador Labs](https:\/\/www.getambassador.io\/) 有一个相关的 [开发者控制平面](https:\/\/www.getambassador.io\/developer-control-plane\/)的概念 —— 它的网站声称，“使开发者能够控制和配置整个云开发循环，以便更快地发布软件”。\n\n\u003e “Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 [Heroku](https:\/\/www.heroku.com\/) 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。” ——Sam Newman，Building Microservices 作者\n\nAmbassador Labs 的开发者关系总监 [Daniel Bryant](https:\/\/www.linkedin.com\/in\/danielbryantuk) 告诉 The New Stack：“如果你看看 [Airbnb](https:\/\/www.airbnb.com\/)、[Shopify](https:\/\/www.shopify.com\/) 和 [Lunar](https:\/\/tech.lunar.app\/) 等公司正在做什么，它们之间有一个明显的共同点。他们正在为他们的开发者创建一个类似于 Heroku 的 CLI，这样，像’创建新的微服务’这样的命令就会产生一些支架，插入 CI，插入管道，插入可观测性。问题是，你向开发者展示的抽象是什么，以便他们获得所需的可见性，同时也使他们所需的要求变得清晰？”\n\nBryant 特继续说：“开发者需要指定某些操作特性：这是一个内存大的服务；这个服务需要低延迟；这个服务需要非常接近那个服务。目前，你通过启动 Kubernetes 和编写大量的 YAML 来做到这一点。那里的抽象并不完全正确，特别是当你引入其他部署机制时，如[无服务器](https:\/\/thenewstack.io\/category\/serverless\/)和[低代码 \/ 无代码](https:\/\/thenewstack.io\/how-low-code-can-help-enterprise-software-development\/)。\n\n“我想知道谁能通过平台暴露出正确的抽象概念，然后让工程师决定如何打包他们的代码 —— 但他们打包的方式是一样的，而平台暴露出一些传统上属于运维的属性。”\n\n## 开放应用模型（OAM）\n\n其他几个关于 Kubernetes 的倡议也值得跟踪。由[微软和阿里云](https:\/\/thenewstack.io\/open-application-model-build-the-next-generation-of-cloud-native-applications\/)联合创建的[开放应用模型](https:\/\/oam.dev\/)（OAM）是一个描述应用的规范，将应用定义与集群的操作细节分开。因此，它使应用程序开发人员能够专注于其应用程序的关键要素，而不是其部署地点的操作细节。\n\n[Crossplane](https:\/\/crossplane.io\/) 是 [OAM](https:\/\/thenewstack.io\/oam-the-kubernetes-application-model-bridging-development-and-deployment\/) 的 Kubernetes 特定实现。它可以被企业用来在各种基础设施和云供应商之间建立和运维一个内部平台即服务（PaaS），这使得它在多云环境中特别有用，比如在那些兼并和收购越来越常见的大型企业中。\n\n虽然 OAM 试图将部署细节的责任从编写服务代码中分离出来，但服务网格旨在通过一个专门的基础设施层将服务间通信的责任从个人开发者那里转移出来，该层侧重于使用代理管理服务间的通信。不幸的是，它们也有复杂性的问题，而且还可能引入相当大的性能开销。\n\n因此，到目前为止，许多在生产中成功实施服务网格的案例都是在那些非常精通技术的初创公司。在 [2020 年与 InfoQ 的 Wes Reisz 的播客中](https:\/\/www.infoq.com\/podcasts\/monolith-microservices\/?)，Newman 建议在选择之前等待 6 个月，他告诉 The New Stack，他仍然给出同样的建议。\n\n“就该技术栈的权重、管理、影响以及性能带来的影响而言，它们的现实情况是非常可怕的，“Newman 说。“对有一些组织说，如果没有它们，有些事情是不可能完成的，[Monzo 就是一个很好的例子](https:\/\/monzo.com\/blog\/2019\/04\/03\/deploying-envoy-proxy) —— 在一个组织中，你有一个异构的技术栈，你需要做大规模的双向 TLS，我可以看到它的价值。但在我看来，它仍然是“概念很好，执行不力”。我想，我们可能会在很长时间内仍这样说。”\n\n## 隐藏服务网格\n\n有一件事可能会发生，至少对企业客户来说，性能问题往往不是那么尖锐，那就是服务网格被推到平台的更深处，并在很大程度上对开发者隐藏。例如，[红帽 OpenShift](https:\/\/www.openshift.com\/try?utm_content=inline-mention) [将 Istio 整合到平台层](https:\/\/www.openshift.com\/blog\/istio-on-openshift-in-2020)，还有多个类似的计划，将服务网格与公有云平台更紧密地整合在一起，如 [AWS App Mesh](https:\/\/aws.amazon.com\/app-mesh\/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate\u0026aws-app-mesh-blogs.sort-order=desc\u0026whats-new-cards.sort-by=item.additionalFields.postDateTime\u0026whats-new-cards.sort-order=desc) 和 [Google Cloud Platform Traffic Director](https:\/\/cloud.google.com\/traffic-director)。\n\n关于服务网格的工作还在继续，以减少其所带来的网络开销。[Cilium](https:\/\/cilium.io\/) 团队的工作很有希望，它利用 Linux 内核中的 [eBPF](https:\/\/ebpf.io\/) 功能来实现它所说的“非常有效的网络、策略执行和负载均衡功能”。\n\n\u003e 我认为现在我们需要为其他人提供领域驱动设计（DDD）。因为即使是普通的开发者而不是架构师，也需要对如何确定实体的范围和边界有一定的了解，这其中有很多是回到了良好的 API 设计上。——Daniel Bryant，开发者关系总监，Ambassador Labs\n\n但另一种可能性是，我们可能完全转向不同的运行时。[Leading Edge Forum](https:\/\/leadingedgeforum.com\/) 的顾问 [Simon Wardley](https:\/\/www.linkedin.com\/in\/simonwardley\/) [认为](https:\/\/acloudguru.com\/blog\/engineering\/simon-wardley-is-a-big-fan-of-containers-despite-what-you-might-think)，函数即服务（Faas）\/ 无服务器将最终取代 Kubernetes，成为分布式应用事实上的标准运行时，我们也看到了一些真实的生产实例，比如 [BBC](https:\/\/www.bbc.com\/)，它的大部分在线架构已经从之前的 LAMP 堆栈 [直接转向了 AWS 上的 Lambda](https:\/\/www.infoq.com\/podcasts\/bbc-aws-lambda-react-cicd\/)。\n\n“我认为 FaaS 是一个管理部署的伟大抽象，“Newman 说。“作为一个对开发者友好的部署软件的抽象，它是自 Heroku 以来我们拥有的最好的东西。我确实认为目前的实现方式很差，但他们会改进。但他们只处理了在一次在一个地方执行一件任务。这并没有解决更大的网络系统的抽象问题”。\n\n作为一个例子，Newman 引用了[微软 Azure](https:\/\/azure.microsoft.com\/) 的 [Durable Functions](https:\/\/docs.microsoft.com\/en-us\/azure\/azure-functions\/durable\/durable-functions-overview?tabs=csharp)，它通过响应式扩展提供了类似于连续性的东西，允许开发者在无服务器环境中建立有状态的工作流和函数。但是，虽然部署抽象可能会有所改善，但如果想象你可以完全抽象出编写分布式系统的复杂性，那就太天真了。\n\n“你不能假设你说的东西就在那里，“Newman 说。“你不能假设数据会神奇地从一个时间点瞬时传送到另一个时间点。因为它不是这样的。而且，再多的抽象也无法解决这个基本问题。”\n\n## 自主团队的架构\n\n另一个仍然具有挑战性的领域与整个系统架构有关，以及围绕团队组织和结构的相关问题。正如 [IBM](https:\/\/www.ibm.com\/cloud?utm_content=logo-sponsorpage\u0026utm_source=thenewstack\u0026utm_medium=website\u0026utm_campaign=platform) 的全球开发者 leader [Holly Cummins](https:\/\/www.linkedin.com\/in\/holly-k-cummins) 在 云原生是关于文化而不是容器 一文中指出的，“即使有适当的自主团队，系统级的考虑也不会消失”。\n\nEric Evans 的《[领域驱动设计》](https:\/\/www.amazon.com\/gp\/product\/0321125215\/ref=as_li_tl?ie=UTF8\u0026camp=1789\u0026creative=9325\u0026creativeASIN=0321125215\u0026linkCode=as2\u0026tag=martinfowlerc-20)是微服务运动的基石，任何软件架构师都应该阅读，Bryant 说。但他更进一步说：\n\n“我认为现在我们需要为我们其他人提供 DDD，“他告诉 The New Stack。“因为即使是普通的开发者而不是架构师，也需要对如何确定实体和边界的范围有一定的了解，其中很多都要回到良好的 API 设计。一旦你理解了耦合和内聚的重要性，关注点和边界的分离，无论你处理的是什么抽象（模块、类、服务、应用），你都会自然而然地跳到这个齿轮上。”\n\nNewman 的 Building Microservices 一书的第二版即将推出，该书介绍了很多这些概念，并考虑到了下一代服务。\n\n在更新这本书时，Newman 告诉 The New Stack，“我想多谈一点耦合性。我想多谈一点内聚力。我想更多地谈论信息隐藏，这对我来说是现在最重要的事情。\n\n“我认为，即使人们掌握了分布式系统方面的知识，他们也没有掌握一个事实，即从根本上说，微服务只是模块化架构的一种形式。然而，很多创建微服务的人对什么是模块化架构或如何进行模块化毫无概念。”\n\nNewman 在新书中还引入了自 2014 年第一版出版以来出现的一些组织思维的变化。他特别引用了马修・斯凯尔顿（Matthew Skelton）和曼努埃尔・派斯（Manuel Pais）关于如何组织业务和技术团队以实现快速流动的极具影响力的作品[《团队拓扑（Team Topologies）》](https:\/\/teamtopologies.com\/book)，以及尼科尔・福斯格伦（Nicole Forsgren）、杰兹・汉伯（Jez Humble）和吉恩・金（Gene Kim）的[《加速（Accelerate）》](https:\/\/itrevolution.com\/accelerate-book\/)一书，该书探讨了精益管理和 DevOps 原则背后的科学。\n\n修订过程不仅揭示了有多少关于微服务的新知识可以分享，而且这些知识是如何不断积累的。\n\n“这本书可以让你广泛了解什么是微服务以及它对软件开发的影响，“Newman 说。“我发现我在向人们推荐，哦，你应该读那本书的第四章。现在我会说这个，而不是那个。我不想在推荐自己的书上一直含糊其辞。这就是为什么我写了第二版：因为我希望它是好的、准确的。”\n', '\/trans\/the-future-of-microservices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-policy-as-code-the-open-policy-agent-opa/">[译] 策略即代码——Open Policy Agent（开放策略代理 OPA）简介</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/06/29</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('策略即代码——Open Policy Agent（开放策略代理 OPA）简介', '本文将带你初步了解开放策略代理 OPA，一个平台无关的策略执行工具。', '\n## 什么是 OPA？\n\n这是一个始于 2016 年的项目，旨在统一不同技术和系统的策略执行。今天，OPA 被科技行业内的巨头们所使用。例如，Netflix 使用 OPA 来控制对其内部 API 资源的访问。Chef 用它来为他们的终端用户产品提供 IAM 功能。此外，许多其他公司，如 Cloudflare、Pinterest 等，都使用 OPA 在他们的平台上执行策略（如 Kubernetes 集群）。目前，OPA 已从 CNCF 中毕业。\n\n## OPA 有什么用？\n\n你可能想知道 OPA 是怎样诞生的？它试图解决什么问题？事实上，API 和微服务的策略执行就如同微服务本身一样古老。没有一个生产级别的应用程序不执行访问控制、授权和策略。为了理解 OPA 的作用，考虑以下用例：你的公司通过一个在线门户销售笔记本电脑。像所有其他类似的应用程序一样，该门户由一个首页组成，客户在这里看到最新的产品，也许还有一些限时促销活动。如果客户想买东西，他们需要登录或创建一个账户。接下来，使用信用卡或其他方法付款。为了确保客户会反复访问，需要支持客户订阅，其中可能包含特别折扣信息。另外，他们可以选择在新产品公布后立即接收浏览器通知。一个非常典型的网上购物应用程序，对吗？现在，让我们用一张图来描述一下这个工作流程是什么样子的，以使这个过程可视化。\n\n![](008i3skNly1gryvk70h04j30wm0u0x2v.jpg)\n\n上图显示了我们系统内部可能的样子。我们有一些微服务，它们相互沟通，为我们的客户提供服务。现在，显然，Bob 不应该看到系统的任何内部运作。例如，他不能查看（或甚至不知道）归档付款的 S3 Bucket，或通知 API 可以与哪些服务联络。但是，John 呢？他是应用开发者，他需要访问所有的微服务，以便在问题发生时能够进行故障排除和调试。要是他不小心（或故意）对数据库服务进行了一个 API 调用，把客户的送货地址改到了别的地方，怎么办？更糟糕的是，如果他对客户的信用卡号码有读取权限怎么办？为了解决这些风险，我们在每个微服务的之前放置了一个授权控制。该控件检查认证用户是否有必要的权限来执行请求的操作。这样的授权系统可以是内部的、自制的程序，也可以是 AWS IAM 提供的外部程序。这就是一个典型的微服务应用程序的构建和安全。但是，看看使用几种不同的授权系统的缺点，特别是随着应用程序的增长而带来的麻烦。\n\n- 修改现有的策略，或引入新的策略，是一场噩梦。试想一下，你需要访问多少地方才能让 Alice 拥有对所有存储相关系统的读取权限。这意味着 S3、MySQL、MongoDB，也许还有一个外部 API，仅此而已。\n- 开发者没有办法在他们自己的系统上执行策略。他们显然可以在应用程序中硬编码他们的授权逻辑，但这使事情变得错综复杂：试图在不同的微服务中统一策略是非常复杂的。\n- 补充前一点，为本地服务引入一个新的策略可能需要改变代码，从而引入所有微服务的新版本。\n- 如果你想将策略与现有的用户数据库集成，该怎么办？例如，与人力资源数据库整合。\n- 我们需要将策略可视化，以确保它正在做它应该做的事情。随着你的策略变得越来越复杂，这一点变得越来越重要。\n- 现代系统由多种技术和服务组成，这些技术和服务是用不同的语言编写的。例如，你可能有运行在 Kubernetes 上的系统核心，以及一堆不属于集群的用 Java、Ruby 和 PHP 编写的传统 API。每个平台都有自己的授权机制。\n\n让我们以 Kubernetes 为例来看看。如果所有用户都被授权访问整个集群，很多讨厌的事情就会发生，比如：\n\n- 给所有的 pod 提供无限的请求和限制，可能会导致随机的 pod 被从节点上驱逐。\n- 拉取和使用未经测试的、杂乱无章的镜像，可能包含安全漏洞或恶意内容。\n- 使用没有 TLS 的 Ingress 控制器，允许未加密的、不安全的流量进入应用程序。\n- 由于整体的复杂性，还有许多其他不可预见的风险。\n- 你肯定可以使用 RBAC 和 Pod 安全策略来对集群进行细粒度的控制。但同样，这只适用于集群。在 Kubernetes 集群之外，Kubernetes RBAC 是没有用的。\n\n这就是开放策略代理（OPA）发挥作用的地方。引入 OPA 是为了创建一个统一的方法来执行堆栈中的安全策略。\n\n## OPA 如何工作？\n\n上文中，我们探讨了策略执行和 OPA 试图解决的问题，现在，让我们来看看它是如何工作的。\n\n假设你正在实现我们示例应用程序的支付服务。这个服务负责处理客户的付款。它暴露了一个 API，接受客户的付款。它还允许用户查询特定客户的付款情况。因此，为了获得一个包含 Jane 所做购买的数组，她是公司的一个客户，你向 API 发送一个 GET 请求，路径为 \u0060\/payment\/jane\u0060。你在授权头中提供你的证书信息并发送请求。响应将是一个 JSON 数组，包含你所要求的数据。然而，由于你不希望所有有网络访问权限的人都能够访问支付 API，看到这样的敏感数据，你需要执行一个授权策略。OPA 以如下方式解决这个问题：\n\n1. 支付 API 向 OPA 查询一个 decision。它伴随着这个查询的一些属性，如请求中使用的 HTTP 方法，路径，用户，等等。\n2. OPA 根据已经提供给它的数据来验证这些属性。\n3. 在验证之后，OPA 向请求的 API 发送一个 decision，要么允许，要么拒绝。\n\n这里需要注意的是，OPA 将我们的策略决策与执行解耦。OPA 的工作流程可以用下面的图来描述。\n\n![OPAd 的工作流程](008i3skNly1gryw7x0q6gj30u00xt7td.jpg)\n\nOPA 是一个通用的、与领域无关的策略执行工具。它可以与 API、Linux SSH 守护程序、像 CEPH 这样的对象存储等集成。OPA 的设计者有意避免将其建立在任何其他项目的基础上。因此，策略查询和决定不遵循特定的格式。也就是说，你可以使用任何有效的 JSON 数据作为请求属性，只要它提供所需的数据。同样地，来自 OPA 的策略决策也可以是任何有效的 JSON 数据。你选择什么被输入，什么被输出。例如，你可以选择让 OPA 返回一个 TRUE 或 FALSE 的 JSON 对象，一个数字，一个字符串，甚至是一个复杂的数据对象。\n\n## OPA 内部\n\n为了充分理解 OPA 并开始在自己的项目中实施它，你必须熟悉它的功能和组件。让我们从如何定义你的策略开始。\n\n### 策略语言 Rego\n\nRego 是一种高级的声明性语言，是专门为 OPA 建立的。它使定义策略和解决以下问题变得非常容易：Bob 是否被允许对 \u0060\/api\/v1\/products\u0060 执行 GET 请求？他实际上被允许查看哪些记录？\n\n### 部署\n\n当涉及到部署 OPA 时，你有多个选择，这取决于你的具体场景。\n\n- **作为 Go 库**：如果你的应用程序是用 Golang 写的，你可以把 OPA 作为应用程序中的第三方库来实现。\n- **作为守护程序**：如果你不使用 Go，那么你可以像其他服务一样，把 OPA 作为一个守护程序来部署。在这种情况下，建议你使用一个 sidecar 容器或在主机上运行。原因是，这种设计可以提高性能和可用性。想象一下，你把 OPA 部署在 Kubernetes 的一个单独的 pod 中，而这个 pod 恰好位于一个单独的节点上，而你的应用 pod 正在那里运行。现在，每当你的服务需要咨询 OPA 的策略决策时，它必须通过网络进行调用，以达到 OPA 运行的 pod。这引入了不必要的延迟，并可能在高峰期导致应用程序的迟滞。\n\n![](008i3skNly1grywfo32k9j30u01drtl3.jpg)\n\n### 如何管理和控制 OPA？\n\n为了进一步减少延迟，设计者决定 OPA 应该把所有的策略数据保存在内存中。这确保了 OPA 不会去查询另一个服务来请求数据。为了处理 OPA，你有一组 API，用于不同的目的。\n\n- **捆绑服务 API**：用于向 OPA 发送策略数据。OPA 不断轮询 Bundle 服务 API，搜索新版本的策略。一旦发现，它就拉取并应用新的版本。\n- **状态服务 API**：用于确定服务的状态。它告诉你当前在 OPA 上激活的策略版本。\n- **决策日志服务 API**：每当 OPA 做出一个策略决策，它都会记录下来。后来，它把这些日志的批次发送到日志服务 API。这对于审计和故障排除特别有用。\n- **构建、测试和调试策略的工具** ：一组命令行工具，你可以使用，如 opa test、opa run、opa check 等。还有一个 [VS Code 插件](https:\/\/marketplace.visualstudio.com\/items?itemName=tsandall.opa)，可以方便开发。\n\n## 初试 OPA 策略\n\n到现在为止，你应该对 OPA 诞生的原因，它试图解决的问题，以及它的设计和管理方式有了相当清晰的认识。现在是试水的时候了，看看用 Rego 语言创建一个策略是什么样子。第一步是用简单的英语定义你的策略。比如说：“客户应该能够查看自己的付款。财务部门的工作人员应该能够查看任何客户的付款。”\n\n下一步是将策略转换为 Rego 代码。我们可以使用 [Rego playground](https:\/\/play.openpolicyagent.org\/) 来做这件事。因此，在主面板中，清除那里已经添加的代码，并添加以下内容。\n\n\u0060\u0060\u0060\npackage play\n\n# Customers should be able to view their own payments\nallow = true {\n\tinput.method = \u0022GET\u0022\n      input.path = [\u0022payments\u0022, customer_id]\n      input.user = customer_id\n}\n\u0060\u0060\u0060\n\n让我们逐行回顾这个片段。\n\n1. 任何以哈希符号（#）开头的行都是注释。把你的策略应该做的事情写成连贯的、可供人类阅读的注释，总是一个好的做法。\n2. allow = true 意味着如果以下的“评估“为真，决策将被允许。\n3. 输入方法是 GET。任何其他 HTTP 方法（POST、PUT 等）都会违反策略。\n4. 路径是 \u0060\/payments\/customer_id\u0060。注意，customer_id 没有加引号，这意味着它是一个变量，需要在调用时被替换。\n5. 用户也应该是 customer_id。\n\n如果我们把这段代码翻译成普通英语，它看起来就像这样。\n\n“如果请求使用的方法是 GET，路径是 \u0060\/payments\/customer_id\u0060，并且用户是同一个 customer_id，则允许该请求。这实际上允许客户查看自己的支付数据。”\n\nRego playground 还允许你评估你的代码，并确保该策略将按预期工作。在 INPUT 面板中，我们可以通过添加以下代码来伪造一个合法请求。\n\n\u0060\u0060\u0060json\n{\n    \u0022method\u0022: \u0022GET\u0022,\n    \u0022path\u0022: [\u0022payments\u0022,\u0022bob\u0022],\n    \u0022user\u0022: \u0022bob\u0022\n}\n\u0060\u0060\u0060\n\n注意，INPUT 使用的是任意的 JSON。在提供请求时，没有特定的规则可以遵循。现在，让我们看看 OPA 将如何通过按下 Evaluate 按钮来响应这个决策请求。OUTPUT 面板应该显示如下内容。\n\n\u0060\u0060\u0060json\n{\n    \u0022allow\u0022: true\n}\n\u0060\u0060\u0060\n\n下面是执行上述步骤后的 playground 截图。\n\n![](008i3skNly1gryelon0ufj318g0epabz.jpg)\n\n现在，让我们试着把请求中的用户改为 alice，这意味着一个客户正试图查看另一个客户的付款。如果我们按 Evaluate 键，你会发现输出显示一个空的 JSON 对象 {}。原因是，OPA 不知道当策略不匹配时应该发送什么。要改变这种行为，在策略的主体前添加以下语句。\n\n\u0060\u0060\u0060\ndefault allow = false\n\u0060\u0060\u0060\n\n因此，整个策略应该是这样的。\n\n\u0060\u0060\u0060\npackage play\n\n# Customers should be able to view their own payments\ndefault allow = false\nallow = true {\n\tinput.method = \u0022GET\u0022\n      input.path = [\u0022payments\u0022, customer_id]\n      input.user = customer_id\n}\n\u0060\u0060\u0060\n\n现在，如果你按下 Evaluate，你会看到预期的输出。\n\n\u0060\u0060\u0060json\n{\n    \u0022allow\u0022: false\n}\n\u0060\u0060\u0060\n\n请注意，这个 playground 非常强大，你可以选择策略的一部分，并独立于策略的其他部分进行评估。当你有一个复杂的策略，当它不应该被评估为假时，这可能是超级有用的。在这种情况下，你可以选择策略的部分内容，看看到底哪里出现了缺陷。\n\n好了，现在我们已经执行了策略的第一部分，让我们继续第二部分：财务部门的工作人员应该能够查看任何客户的付款。\n\n在我们之前定义的策略后面添加以下几行。\n\n财务部门的工作人员可以查看任何客户的付款。\n\n\u0060\u0060\u0060\nallow = true {\n    input.method = \u0022GET\u0022\n    input.path = [\u0022payments\u0022, customer_id]\n    finance[input.user]\n}\n\nfinance = {\u0022john\u0022,\u0022mary\u0022,\u0022peter\u0022,\u0022vivian\u0022}\n\u0060\u0060\u0060\n\n这个策略的大部分内容与之前的相似，除了第 4 行。我们不是评估用户 ID 是否与客户 ID 相同，而是评估用户是否是财务 JSON 对象的一部分。Rego 有很多内置结构，允许你做很多有用的事情，包括查找。最后，我们定义财务对象并添加在该组中工作的员工的用户名。在现实世界中，这个 JSON 对象将作为 INPUT 请求的一部分或作为一个标记传递。现在，让我们通过将用户和客户设置为相同的名字（例如，Bob）来测试该策略。该策略应该返回 true。将用户改为 john（他是财务部门的一部分），并测试该策略。同样，它应该返回真。最后，将用户改为不在财务部门工作的任何名字（比方说，jane），该策略应该返回错误。\n\n你可以参考[官方文档](https:\/\/www.openpolicyagent.org\/docs\/latest\/policy-language\/)，阅读更多关于 Rego 语言和你能用它做什么。\n\n## 将 OPA 与其他系统集成\n\n如前所述，OPA 可以与当今的许多平台集成。让我们来看看 OPA 可以为你做什么的几个例子。\n\n**Kubernetes**\n\n- 确保入口主机名只由前端团队改变。\n- 拒绝拉取任何镜像，除了来自企业 Docker 注册中心的镜像。\n- 对集群上创建的任何 pod 强制使用请求和限制。\n\n**API 授权**\n\n你可以将 OPA 与 Envoy、Istio 和其他平台一起使用，强制执行 IAM 控制。例如，你可以轻松控制安全人员对敏感数据的访问。\n\n**Linux PAM**\n\n可插拔认证模块（PAM）长期以来一直被用于 Linux，为包括 SSH 和 sudo 在内的多种服务提供细粒度的控制。OPA 有一个 PAM 插件，使其能够与 PAM 集成并执行策略。例如，你可以限制 SSH 对你的生产机器的访问，除非在非工作时间，或者除非用户有一个支持工单。\n\n还有许多其他产品可以与 OPA 集成，提供无穷的可能性。例如，Kafka、ElasticSearch、SQLite 和 CEPH，仅举几例。\n\n## 概要总结\n\n- 对授权的需求和软件本身一样古老。\n- 由于缺乏一个可以在不同系统和平台之间使用的中央授权系统，导致了许多问题。例如，API 可能有自己的授权逻辑内置于代码中，其他微服务可能依赖于一个或多个外部授权系统。这使得推出新的策略，检查现有策略的版本，甚至引入小的变化都是非常具有挑战性的操作。\n- OPA 就像一个服务顾问，为需要的服务做出授权决策。服务向 OPA 提出决策查询，然后 OPA 根据已经存储在其中的策略审查查询，并作出决策回应。\n- OPA 的设计是通用的，与平台无关。因此，在发送查询或定义输出的样子时，你不需要遵循任何规则。请求和响应是以 JSON 格式发送的。\n- 策略可以用 Rego 编写，这是一种专门为 OPA 设计的语言。类似于 JavaScript，OPA 使其非常容易将纯英语规则转换为有效的 OPA 策略。\n- Rego playground 工具是一个很好的方法，可以在实施策略之前尝试你的策略。\n- OPA 可以作为 Go 库部署，成为应用程序二进制的一部分，也可以作为独立的守护程序。\n- 由于策略决策发生在每个 API 请求中，强烈建议将 OPA 守护程序尽可能紧密地放在应用程序中。例如，作为 Kubernetes pod 中的一个 sidecar 容器，或者作为一个运行在节点上的守护程序。这种做法有助于减少延迟和减少网络流量。\n- OPA 使用了许多 API，可以很容易地注入新策略，检查现有策略的版本和状态，或收集审计和日志数据。\n- 在这篇文章中，我们看了一个简单的演示，即如何使用 Rego 语言来执行一个策略。在这个例子中，我们展示了通过 Rego 语言和 playground 工具来执行一个复杂的策略并对其进行测试是多么容易。\n- OPA 可以与许多现代的系统和平台集成，如 Kubernetes、Kafka、SQLite、CEPH 和 Terraform。通过 PAM 插件，它还可以与 Linux PAM 集成，对使用 PAM 的 Linux 守护进程（如 sshd 和 sudo）实施高级策略控制。\n', '\/trans\/introducing-policy-as-code-the-open-policy-agent-opa\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将带你初步了解开放策略代理 OPA，一个平台无关的策略执行工具。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/rbac-vs-abac/">[译] RBAC vs ABAC，两者有何异同？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%85%b6%e4%bb%96"> 
             其他
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('RBAC vs ABAC，两者有何异同？', '本文主要研究了 RBAC 和 ABAC 这两种访问能控制之间的异同。', '\n在任何公司，网络用户必须经过认证和授权，才能访问系统中可能导致安全漏洞的部分。获得授权的过程称为访问控制。在本指南中，我将讨论管理系统访问控制的两种主要方法 —— 基于角色的访问控制（RBAC）和基于属性的存取控制（ABAC）它们的差异，以及使用访问权限管理工具的重要性。\n\n## 认证和授权\n\n安全的两个基本方面是认证和授权。在您输入凭证登录电脑或登录应用程序或软件后，设备或应用程序会进行身份验证，以确定您的授权级别。授权可能包括您可以使用哪些账户，您可以访问哪些资源，以及允许您执行哪些功能。\n\n## 基于角色的访问控制（RBAC）与基于属性的访问控制（ABAC）\n\n基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）是控制认证过程和授权用户的两种方法。RBAC 和 ABAC 之间的主要区别是 RBAC 基于用户角色提供对资源或信息的访问，而 ABAC 基于用户、环境或资源属性提供访问权限。从本质上讲，当考虑 RBAC 与 ABAC 时，RBAC 控制整个组织的广泛访问，而 ABAC 则采取细粒度的方法。\n\n### 什么是 RBAC？\n\n![](0081Kckwly1gm04pyv4mtj30sg0ewgmd.jpg)\n\nRBAC 是基于角色的，所以根据你在组织中的角色而拥有不同的访问权限。这是由管理员决定的，管理员会设置一个角色应该拥有的访问权限，以及用户与角色的对应关系。例如，有的用户可能被分配到一个角色，可以编辑特定的文件，而其他用户可能被限制在一个角色中，只能读取该文件而不能编辑。\n\n用户与角色是一对多的关系，这使得用户拥有可以访问许多不同的文件或能力。比如说有一个团队在做一个大型项目。项目经理可以访问和编辑所有的文件，而开发团队可能只被允许访问代码文件，而无法看到或编辑项目的财务和员工信息。人力资源或管理团队可以访问所有的员工和财务信息，而不能访问编程文件。\n\n组织可能会将 RBAC 用于这样的项目，因为有了 RBAC，不需要在每次一有人离职或更换岗位时都进行更改：他们可以简单地从角色组中删除或分配一个新的角色。这也意味着新员工可以根据他们所履行的组织角色，相对快速地被授予访问权限。\n\n### 什么是 ABAC？\n\n![](0081Kckwly1gm04qu9t1ej30sg0ewq3m.jpg)\n\n基于属性的访问控制利用了一组称为“属性“的特征。这包括**用户属性**、**环境属性**和**资源属性**。\n\n- 用户属性包括用户的姓名、角色、组织、ID 和安全许可等内容。\n- 环境属性包括访问时间、数据的位置和当前组织的威胁等级。\n- 资源属性包括诸如创建日期、资源所有者、文件名和数据敏感性。\n\n基本上，ABAC 比 RBAC 有更多可能的控制变量。ABAC 的实施是为了降低因未经授权的访问而产生的风险，因为它可以在更细粒度地控制安全和访问。例如，ABAC 可以对他们的访问进行进一步的限制，比如只允许在特定的时间或与相关员工相关的某些分支机构进行访问，而不是让人力资源部门的人员总是能够访问员工和工资信息。这样可以减少安全问题，也可以帮助以后的审计过程。\n\n### RBAC 与 ABAC 的比较\n\n一般来说，有 RBAC 就足够了，应该在设置 ABAC 优先考虑使用它。这两个访问控制过程都是过滤器，ABAC 是两个过程中比较复杂的，需要更多的处理能力和时间。如果你不需要，就没有必要使用这种更强大的过滤器 —— 这会产生相应的资源成本。\n\n无论哪种方式，使用最少数量的 RBAC 和 ABAC 过滤器来构建你的访问和安全环境是很重要的。它可以帮助仔细规划你的目录数据和访问方法，以确保你没有使用不必要的过滤器或使事情过于复杂。在许多情况下，RBAC 和 ABAC 可以分级地一起使用，广泛的访问由 RBAC 协议执行，更复杂的访问由 ABAC 管理。这意味着系统将首先使用 RBAC 来确定谁可以访问一个资源，然后由 ABAC 来确定他们可以对资源做什么以及何时可以访问。\n\n## 使用访问管理工具\n\n无论你是使用 RBAC 还是 ABAC，或者是两者的结合，我都强烈建议使用访问权限管理工具。一个好的工具可以简化设置并减少设置和管理过滤器所涉及的管理费用。当涉及到安全问题时，认真规划和监控您的访问控制流程是至关重要的。使用强大的访问管理工具来帮助您设置访问控制，并定期审查您的设置，以确保它仍然符合您的组织需求。\n', '\/trans\/rbac-vs-abac\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文主要研究了 RBAC 和 ABAC 这两种访问能控制之间的异同。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/%E5%85%B6%E4%BB%96/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/%E5%85%B6%E4%BB%96/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/categories/%E5%85%B6%E4%BB%96/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/%E5%85%B6%E4%BB%96/page/2/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(68)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(23)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
