<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song - 云原生 – 云原生</title>
    <link>https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    <description>Recent content in 云原生 on Jimmy Song - 云原生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2017-2022 Jimmy Song 保留所有权利</copyright>
    <lastBuildDate>Thu, 28 Jan 2021 08:34:40 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>“寒武纪大爆发” 之后的云原生，2021 年走向何处？</title>
      <link>https://jimmysong.io/blog/cloud-native-2021/</link>
      <pubDate>Thu, 28 Jan 2021 08:34:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cloud-native-2021/</guid>
      <description>
        
        
        &lt;p&gt;很荣幸收到 CSDN 的邀请，接受” 云原生人物志 “专栏采访，其实我从 2017 年起就已经在撰写 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34;&gt;Kubernetes 和云原生年度总结和新年展望&lt;/a&gt;，今天在此聊抒己见，欢迎大家讨论和指正。&lt;/p&gt;
&lt;h2 id=&#34;云原生在演进&#34;&gt;云原生在演进&lt;/h2&gt;
&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生 1.0 的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得&lt;strong&gt;云原生从基础设施层不断向应用架构层挺进&lt;/strong&gt;，我们正处于一个云原生 2.0 的新时代。&lt;/p&gt;
&lt;h2 id=&#34;业界动向&#34;&gt;业界动向&lt;/h2&gt;
&lt;p&gt;最近国内的一些云厂商，如阿里云、腾讯云、华为云陆续发布了各自的云原生相关的架构和实践白皮书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020 年 7，中国信通院发布了《云原生产业白皮书（2020）》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 20 日，在腾讯 2020 Techo Park 开发者大会上，腾讯云正式发布了《云原生最佳实践路线图》，同时发布的还有一份 3 万多字的《腾讯云原生路线图手册》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 23 日，阿里云原生实战峰会上发布了《云原生架构白皮书》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 30 日，华为云在深圳的 TechWave 云原生 2.0 技术峰会上联合 Forrester 发布了《云原生白皮书：拥抱云原生优先战略》。&lt;/li&gt;
&lt;li&gt;2021 年初，阿里巴巴达摩院发布 2021 十大科技趋势，其中将 “云原生重塑 IT 技术体系” 作为 2021 年技术预测之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生项目的-寒武纪大爆发&#34;&gt;云原生项目的 “寒武纪大爆发”&lt;/h2&gt;
&lt;p&gt;云原生已历经” 寒武纪大爆发 “，标志是从 2018 年 Kubernetes 毕业 后走向深耕路线。云原生领域的开源项目层出不穷，令人眼花缭乱，见我收集的 Awesome Cloud Native。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://tva1.sinaimg.cn/large/008eGmZEly1gn37vq5g81j30q906dmyk.jpg&#34; alt=&#34;&#34;&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;2020 年 CNCF 共接纳了 35 个项目加入基金会，并且有多个项目毕业或晋级，CNCF 托管的项目总数达到了 80 多个。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://tva1.sinaimg.cn/large/008eGmZEly1gn37weeu5lj30q90ivalh.jpg&#34; alt=&#34;&#34;&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;图片来自 CNCF 年度报告 2020&lt;/p&gt;
&lt;h2 id=&#34;云原生之争实际上是标准之争&#34;&gt;云原生之争实际上是标准之争&lt;/h2&gt;
&lt;p&gt;PC 端操作系统 Windows 占据上风，移动端是 iOS 和 Android，服务器端是 Linux，而云计算商用分布式操作系统呢？答案是 Kubernetes。&lt;/p&gt;
&lt;p&gt;2020 年 Kubernete 宣布将&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110520682&#34;&gt;在 v1.20 版本之后弃用 Docker&lt;/a&gt;，实际上 Docker 本来就不是 Kubernetes 中默认和唯一的的容器运行时了，实际上只要是支持 CRI（Container Runtime Interface）或 OCI（Open Container Initiative）标准的容器运行时都可以在 Kubernetes 中运行。如下图所示，容器，英文是 container，也是集装箱的意思，其实集装箱不止一种型号，根据运送的货物的不同特性可以制定了多种集装箱类型。而这个容器类型是标准只能是由 Kubernetes 来定，否则只能是削足适履。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://tva1.sinaimg.cn/large/008eGmZEly1gn37vqbb2lj30q90enwpl.jpg&#34; alt=&#34;&#34;&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;Kubernetes 统一了云上的资源对象制定和调度的标准，只要在其标准之上开发 CRD 和 Operator 即可。但是这也仅限于单个应用的管理，如何管理复杂的多集群和混合云环境，如何管理应用间流量，如何如何保证调用链的安全？以 Istio 为代表的服务网格就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;云原生趋势云上应用管理&#34;&gt;云原生趋势：云上应用管理&lt;/h2&gt;
&lt;p&gt;Kubernetes 奠定了云原生基础设施的基础，随着而来的监控、存储、AI、大数据等技术的迁移，从单个应用层面来说已经日趋成熟，而在&lt;strong&gt;使用云原生架构尤其是对云上应用的管理&lt;/strong&gt;，而在异构环境、多集群、混合云等已成为常态的情况下，&lt;strong&gt;如何对云上的应用进行管理，成为棘手的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 以其开创新的声明式 API 和调节器模式，奠定了云原生的基础。我们看到 Google 的项目 Anthos，Azure 的 Arc，AWS 最近开源的 EKS-D，它们都是着重在混合云管理，让云无处不在。另外，服务网格（Service Mesh）经过两年的推广和发酵，将会看到越来越多的应用。&lt;/p&gt;
&lt;h2 id=&#34;云原生与开源社区&#34;&gt;云原生与开源社区&lt;/h2&gt;
&lt;p&gt;目前&lt;strong&gt;企业云原生化转型最缺乏的东西 —— 套路和组合拳&lt;/strong&gt;。对于基础软件，企业往往会选择开源项目并根据自身需求进行改造，而云原生的开源项目又有很多，企业不是没有选择，而是选择太多，以致于无从下手。就像下面教你如何画猫头鹰的示例。我们可以将企业的云原生化的愿景想象成是这只猫头鹰，这些开源项目就像步骤一中圆，你可能想当然的认为只要用了 Kubernetes 就是云原生了，这就像画了两个圆，而剩余部分没有人教你如何完成。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://tva1.sinaimg.cn/large/008eGmZEly1gn37vqshfnj30q90hh44y.jpg&#34; alt=&#34;&#34;&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;开源社区的核心是面向开发者，就是向开发者灌输如何来画好这只 “猫头鹰” 的。开源不意味着免费和做慈善，使用开源也是有代价的。&lt;strong&gt;开源社区存在的意义是平衡开发者、终端用户及供应商之间的共同利益&lt;/strong&gt;，而一个中立的开源社区有利于发挥开源的生态优势。&lt;/p&gt;
&lt;p&gt;近年来随着云原生大热，在美国诞生了大量该领域的初创公司，他们基于 AWS、谷歌云、Azure 等提供各种云原生的解决方案，从每次 KubeCon 的赞助商规模上就可以窥知一二。国内该领域的公司目前还不多，而云原生终端用户社区的公司规模上依然跟国外的公司数量有不小的差距。&lt;/p&gt;
&lt;p&gt;云原生社区就是在这样的背景下于 2020 年初由我发起，开始筹备并在 5 月 12 号正式成立，致力于推广云原生技术，构建开发者生态。云原生社区采取 SIG（特别兴趣小组）和 WG（工作组）的组织形式，基于开源项目和不同的专业领域构建研讨组，与厂商合作定期举办线下 meetup，并邀请社区的专家们定期在 B 站的云原生学院进行直播。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;开源应该关注的是终端用户和开发者生态，用 Apache Way 来说就是 “社区大于代码”，没有社区的项目是难以长久的。因此我们可以看到国内一些云厂商开源项目之后也会积极投入运营，举行各种各样的活动。我们看到在云原生的推广过程中，CNCF 起到的相当大的作用，2020 年国内也有类似的基金会成立，我们希望看到更多中立的基金会和社区的成立，更多的厂商参与其中，为终端用户提供更佳的解决方案。&lt;/p&gt;
&lt;p&gt;最后感谢 CSDN 宋慧编辑和 「CSDN 云计算」的邀请。&lt;/p&gt;
&lt;p&gt;往期报道见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/112293560&#34;&gt;梁胜：做开源项目的贡献者没有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/FL63Zv9Zou86950w/article/details/110433443&#34;&gt;华为云 CTO 张宇昕：云原生已经进入深水区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110508201&#34;&gt;APISIX 温铭：开源的本质是要拿开发者的杠杆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人介绍&#34;&gt;个人介绍&lt;/h2&gt;
&lt;p&gt;在我的职业生涯里先后从事过 Java 开发、大数据运维、DevOps、开源管理等工作，个人爱好是研究并推广开源技术及理念，摄影和旅行。目前在企业级服务网格初创公司 Tetrate 担任 Developer Advocate，同时作为中立的云原生终端用户社区 —— 云原生社区（Cloud Native Community）的负责人。&lt;/p&gt;
&lt;p&gt;我的整个职业生涯都是与开源息息相关的，渊源可以追溯到大学时期。大学时我就开始使用 Linux 系统（Ubuntu）学习，刚进入职场的时候面向的也是 Hadoop 的开源生态及各种开源中间件，2015 起开始接触 Docker，2016 年开始进入云原生领域，2017 年开始写 Kubernetes 领域的第一本开源中文电子书《&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&lt;/a&gt;》，本书直到如今仍在更新，2018 年在蚂蚁集团做开源管理及服务网格社区 ServiceMesher，2020 年加入基于 Istio、Envoy 和 Apache SkyWalking 等开源项目而构建企业级服务网格的初创公司 Tetrate。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Sun, 18 Oct 2020 14:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</guid>
      <description>
        
        
        &lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是 “物理” 结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。 Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34;&gt;Istio Handbook——Istio 服务网格进阶实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多&lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读&lt;a href=&#34;https://kubernetes.io&#34;&gt;官方文档&lt;/a&gt;和实践来学习，也可以参考我编写的&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的&lt;a href=&#34;https://cloudnative.to&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的&lt;a href=&#34;https://github.com/cloudnativeto/academy&#34;&gt;云原生学院&lt;/a&gt;定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes 次世代的云原生应用</title>
      <link>https://jimmysong.io/blog/post-kubernetes-era/</link>
      <pubDate>Mon, 01 Jun 2020 18:13:19 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/post-kubernetes-era/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 自开源至今已经走过六个年头了，&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34;&gt;云原生时代&lt;/a&gt;也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为&lt;a href=&#34;https://jimmysong.io/guide-to-cloud-native-app&#34;&gt;《云原生应用白皮书》&lt;/a&gt;的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。&lt;/p&gt;
&lt;h2 id=&#34;重点&#34;&gt;重点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。&lt;/li&gt;
&lt;li&gt;Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。&lt;/li&gt;
&lt;li&gt;Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。&lt;/li&gt;
&lt;li&gt;OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。&lt;/li&gt;
&lt;li&gt;“Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生&lt;strong&gt;应用&lt;/strong&gt;架构的时代即将到来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。&lt;/p&gt;
&lt;h2 id=&#34;云原生的不同发展阶段&#34;&gt;云原生的不同发展阶段&lt;/h2&gt;
&lt;p&gt;Kubernetes 从开源至今已经走过快&lt;a href=&#34;https://jimmysong.io/cloud-native/memo/open-source/&#34;&gt;六个年头&lt;/a&gt;（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;cloud-native-stages.png&#34; alt=&#34;云原生的发展阶段&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生的发展阶段&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：孵化期（2014 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：高速发展期（2015 年 - 2016 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：野蛮生长期（2017 年 - 2018 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是&lt;a href=&#34;https://jimmysong.io/blog/service-mesh-the-microservices-in-post-kubernetes-era/&#34;&gt;后 Kubernetes 时代的微服务&lt;/a&gt;，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF &lt;a href=&#34;https://www.cncf.io/blog/2018/03/06/kubernetes-first-cncf-project-graduate/&#34;&gt;毕业&lt;/a&gt;，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34;&gt;2017 年&lt;/a&gt;和 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html&#34;&gt;2018 年&lt;/a&gt;的预测和总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四阶段：普及推广期（2019 年至今）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-开辟了云原生时代&#34;&gt;Kubernetes 开辟了云原生时代&lt;/h2&gt;
&lt;p&gt;Kubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。&lt;/p&gt;
&lt;p&gt;下图是Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;kubernetes-concepts.png&#34; alt=&#34;Kubernetes 概念&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kubernetes 概念&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;图片来自图书 &lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34;&gt;Kubernetes Patterns（O’Reilly）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 作为云原生基础设施设计之初遵循了以下原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础设施即代码（声明式 API）&lt;/li&gt;
&lt;li&gt;不可变基础设施&lt;/li&gt;
&lt;li&gt;幂等性&lt;/li&gt;
&lt;li&gt;调节器模式（Operator 的原理）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他&lt;a href=&#34;https://jimmysong.io/cloud-native-infra/evolution-of-cloud-native-developments.html&#34;&gt;云部署形式&lt;/a&gt;的主要区别之一，这也为后来的 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34;&gt;Operator 框架的诞生&lt;/a&gt;打下了基础。&lt;/p&gt;
&lt;h3 id=&#34;声明式-api&#34;&gt;声明式 API&lt;/h3&gt;
&lt;p&gt;根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？&lt;/p&gt;
&lt;p&gt;我们在创建 &lt;code&gt;Deployment&lt;/code&gt; 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用&lt;a href=&#34;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#monitoring-admission-webhooks&#34;&gt;动态准入控制&lt;/a&gt;来达到这一点。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-原生应用&#34;&gt;Kubernetes 原生应用&lt;/h3&gt;
&lt;p&gt;我们都知道要想运行一个应用至少需要以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。&lt;/li&gt;
&lt;li&gt;应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。&lt;/li&gt;
&lt;li&gt;应用的生命周期管理（各种 Controller 登场）。&lt;/li&gt;
&lt;li&gt;可观察性、可运维、网络和资源及环境依赖、隔离性等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;kubernetes-native-application-motion.gif&#34; alt=&#34;Kubernetes 原生应用&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kubernetes 原生应用&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;我们都知道 Kubernetes 提供了大量的&lt;a href=&#34;https://kubernetes.io/docs/concepts/&#34;&gt;原语&lt;/a&gt;，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 &lt;a href=&#34;https://github.com/openkruise/kruise&#34;&gt;OpenKruise&lt;/a&gt;、Istio），实际上 &lt;a href=&#34;https://operatorhub.io/&#34;&gt;Operator&lt;/a&gt; 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。&lt;/p&gt;
&lt;p&gt;Kubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。&lt;/p&gt;
&lt;p&gt;我将 Kubernetes 原生应用所需要的定义和资源进行了分层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心层&lt;/strong&gt;：应用逻辑、服务定义、生命周期控制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离与服务访问层&lt;/strong&gt;：资源限制与隔离、配置、身份、路由规则等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度层&lt;/strong&gt;：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源层&lt;/strong&gt;：提供网络、存储和其他平台资源；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。&lt;/p&gt;
&lt;p&gt;云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。&lt;/p&gt;
&lt;p&gt;同一个资源对象又有多种实现方式，比如 Ingress 就有 &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k/edit#gid=0&#34;&gt;10 多种实现&lt;/a&gt;，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;resources-motion.gif&#34; alt=&#34;资源交集动画&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;资源交集动画&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。&lt;/p&gt;
&lt;p&gt;为了管理这些应用诞生出了众多的 &lt;a href=&#34;https://github.com/operator-framework/awesome-operators&#34;&gt;Operator&lt;/a&gt;。Kubernetes 1.7 版本以来就引入了&lt;a href=&#34;https://kubernetes.io/docs/concepts/api-extension/custom-resources/&#34;&gt;自定义控制器&lt;/a&gt;的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods/Services、对正在运行的应用进行扩缩容。&lt;/p&gt;
&lt;p&gt;Operator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式的四个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的输入和输出都使用数据结构。&lt;/li&gt;
&lt;li&gt;确保数据结构是不可变的。&lt;/li&gt;
&lt;li&gt;保持资源映射简单。&lt;/li&gt;
&lt;li&gt;使实际状态符合预期状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;云原生应用走向碎片化&#34;&gt;云原生应用走向碎片化&lt;/h2&gt;
&lt;p&gt;利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生应用碎片化的体现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 模式将运维人员的反应式经验转化成基于 &lt;code&gt;Reconcile&lt;/code&gt; 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。&lt;/li&gt;
&lt;li&gt;开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。&lt;/li&gt;
&lt;li&gt;Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有状态应用管理难题&#34;&gt;有状态应用管理难题&lt;/h3&gt;
&lt;p&gt;Kubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。&lt;/p&gt;
&lt;p&gt;例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 &lt;code&gt;ConfigMap&lt;/code&gt;、复杂的启动脚本才能&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/migrating-hadoop-yarn-to-kubernetes.html&#34;&gt;在 Kubernetes 上定义 Hadoop YARN&lt;/a&gt; 和&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/usecases/running-spark-with-kubernetes-native-scheduler.html&#34;&gt;运行 Spark&lt;/a&gt;。虽然 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/&#34;&gt;&lt;code&gt;StatefulSet&lt;/code&gt;&lt;/a&gt; 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 &lt;code&gt;ConfigMap&lt;/code&gt; 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。&lt;/p&gt;
&lt;h3 id=&#34;operator-统一了-kubernetes-应用运维框架&#34;&gt;Operator 统一了 Kubernetes 应用运维框架&lt;/h3&gt;
&lt;p&gt;Operator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34;&gt;构建自己的 Operator&lt;/a&gt; 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 &lt;a href=&#34;https://istio.io&#34;&gt;Istio&lt;/a&gt;、&lt;a href=&#34;https://knative.dev&#34;&gt;Knative&lt;/a&gt;），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。&lt;/p&gt;
&lt;p&gt;Operator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立&lt;/strong&gt;：互不干涉，比如 Controller 与服务发现之间就不存在冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合&lt;/strong&gt;：例如 &lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt; 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有冲突&lt;/strong&gt;：例如图中的 &lt;code&gt;CronHorizontalPodAutoscaler&lt;/code&gt;（CRD）、&lt;code&gt;HorizontalPodAutoscaler&lt;/code&gt;（Kubernetes 内置），同时使用可能导致无法意料的情况发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34;&gt;应用交付领域&lt;/a&gt;的系列开源项目。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用管理工具-helm&#34;&gt;云原生应用管理工具 Helm&lt;/h2&gt;
&lt;p&gt;Kubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序启动时加载的配置文件；&lt;/li&gt;
&lt;li&gt;应用程序的运维配置，如资源申请限额；&lt;/li&gt;
&lt;li&gt;应用程序的服务发现配置；&lt;/li&gt;
&lt;li&gt;应用程序的工作负载、发布策略、依赖等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些配置可以存在于 &lt;code&gt;ConfigMap&lt;/code&gt;、&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt; 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。&lt;/p&gt;
&lt;p&gt;云原生应用打包和发布管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；&lt;/li&gt;
&lt;li&gt;Chart 仓库提供了云原生应用程序的统一管控视图；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release&lt;/code&gt; 概念的引入，使得云原生应用版本化管理进一步加强；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helm 主要关注的是 &lt;a href=&#34;https://12factor.net/zh_cn/&#34;&gt;12 因素应用&lt;/a&gt;法则&lt;a href=&#34;https://12factor.net/zh_cn/build-release-run&#34;&gt;构建、发布、运行&lt;/a&gt;这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;helm-chart.png&#34; alt=&#34;Helm3 架构&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Helm3 架构&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;Helm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 &lt;code&gt;helm upgrade&lt;/code&gt;， release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。&lt;/p&gt;
&lt;h3 id=&#34;打包配置和发布&#34;&gt;打包、配置和发布&lt;/h3&gt;
&lt;p&gt;Helm 和 chart 的主要作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序封装&lt;/li&gt;
&lt;li&gt;版本管理&lt;/li&gt;
&lt;li&gt;依赖检查&lt;/li&gt;
&lt;li&gt;便于应用程序分发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;打包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Helm 采用 &lt;a href=&#34;https://helm.sh/docs/topics/charts/&#34;&gt;Chart&lt;/a&gt; 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用配置参数，在 Chart 中由 &lt;code&gt;values.yaml&lt;/code&gt; 和命令行参数组成。Chart 采用 Go Template 的特性和 &lt;code&gt;values.yaml&lt;/code&gt; 对部署的模板文件进行参数渲染，也可以通过 &lt;code&gt;helm&lt;/code&gt; 命令 &lt;code&gt;--set key=value&lt;/code&gt; 的方式进行参数赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用&#34;&gt;云原生应用&lt;/h2&gt;
&lt;p&gt;以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时：ECS、Docker、KataContainer、gVisor 等；&lt;/li&gt;
&lt;li&gt;资源隔离性：多租户、VPC、Namespace、防火墙；&lt;/li&gt;
&lt;li&gt;资源调度：各种类型的 controller；&lt;/li&gt;
&lt;li&gt;网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；&lt;/li&gt;
&lt;li&gt;可观测性：日志、分布式追踪、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；&lt;/li&gt;
&lt;li&gt;平台资源申请：数据库、存储等；&lt;/li&gt;
&lt;li&gt;运行与隔离：ECS、Docker、KataContainer 等；&lt;/li&gt;
&lt;li&gt;资源分配和调度：各种控制器；&lt;/li&gt;
&lt;li&gt;环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；&lt;/li&gt;
&lt;li&gt;可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；&lt;/li&gt;
&lt;li&gt;状态管理：Operator；&lt;/li&gt;
&lt;li&gt;可观察性：日志、监控、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、ServiceAccount；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云原生应用分层模型&#34;&gt;云原生应用分层模型&lt;/h3&gt;
&lt;p&gt;那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34;&gt;应用交付领域&lt;/a&gt;的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;cloud-native-app.png&#34; alt=&#34;云原生应用的分层模型&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生应用的分层模型&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用定义和包装&lt;/strong&gt;：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载定义&lt;/strong&gt;：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。&lt;a href=&#34;https://istio.io&#34;&gt;Istio&lt;/a&gt; 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观察性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用发布和上线&lt;/strong&gt;：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes 原语&lt;/strong&gt;：Kubernetes 本身提供的原语，Operator 基于此构建；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34;&gt;The Dictionary of Cloud-Native App Delivery&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Platform/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。&lt;/p&gt;
&lt;h3 id=&#34;oam开放应用模型&#34;&gt;OAM（开放应用模型）&lt;/h3&gt;
&lt;p&gt;那么以上这么多应用有哪些共性，能不能再进一步抽象呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；&lt;/li&gt;
&lt;li&gt;在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；&lt;/li&gt;
&lt;li&gt;要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 &lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt;，二者同时使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 的 Runtime 的正常流程应该是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用开发者创建自己的 &lt;code&gt;Component&lt;/code&gt;，在 &lt;code&gt;Component&lt;/code&gt; 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；&lt;/li&gt;
&lt;li&gt;运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 &lt;code&gt;Component&lt;/code&gt; 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 &lt;code&gt;ApplicationConfiguration&lt;/code&gt;的下发，生成 &lt;code&gt;Component&lt;/code&gt; 对应的 &lt;code&gt;Workload&lt;/code&gt; 和 &lt;code&gt;Trait&lt;/code&gt;，&lt;code&gt;Trait&lt;/code&gt; controller 将本次的 &lt;code&gt;Trait&lt;/code&gt; 策略应用到本次要管理的 &lt;code&gt;Workload&lt;/code&gt; 当中，最终到达终态，完成一次发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；&lt;/li&gt;
&lt;li&gt;Trait：各种运维规则，比如扩缩容、流量控制、安全性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生态&#34;&gt;生态&lt;/h3&gt;
&lt;p&gt;以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34;&gt;CNCF 宣布成立 SIG App Delivery&lt;/a&gt; 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34;&gt;应用交付 SIG&lt;/a&gt; 的使命是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。&lt;/li&gt;
&lt;li&gt;发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。&lt;/li&gt;
&lt;li&gt;识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 OAM 定义的云原生应用模型已有以下项目支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://crossplane.io/&#34;&gt;Crossplane&lt;/a&gt;：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 &lt;code&gt;kubectl&lt;/code&gt; 配置和管理基础架构、服务和应用。对于 OAM 的支持详见&lt;a href=&#34;https://crossplane.io/docs/v0.11/getting-started/run-applications.html&#34;&gt;运行应用程序&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://googlecontainertools.github.io/kpt/&#34;&gt;KPT&lt;/a&gt;：Kpt（发音为 &amp;ldquo;keep&amp;rdquo;）是一个在资源配置之上构建声明性工作流的开源工具。它的 git + YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 &lt;a href=&#34;https://googlecontainertools.github.io/kpt/guides/ecosystem/oam/&#34;&gt;使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用交付领域相关的开源项目还有很多，详见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34;&gt;Awesome Cloud Native&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 &lt;a href=&#34;https://oam.dev/&#34;&gt;OAM 社区&lt;/a&gt;，一起参与进来，把国人参与指定的标准推向世界。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.ibm.com/technologies/containers/blogs/kubernetes-helm-3/&#34;&gt;Do you know what’s in Helm 3? - developer.ibm.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34;&gt;O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34;&gt;The Dictionary of Cloud-Native App Delivery - docs.google.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34;&gt;CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/c7A8lOdAKkW25GoqmwOgWg&#34;&gt;OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34;&gt;Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34;&gt;云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>OAM（开放应用模型）——定义云原生应用标准的野望</title>
      <link>https://jimmysong.io/blog/oam-intro/</link>
      <pubDate>Wed, 22 Apr 2020 14:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/oam-intro/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://oam.dev/&#34;&gt;OAM（Open Application Model）&lt;/a&gt;是阿里巴巴和微软共同开源的云原生应用规范模型，同时开源了基于 OAM 的实现 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34;&gt;Rudr&lt;/a&gt;，自 2019 年 10 月宣布开源以来截止本文发稿已经有快半年时间了。&lt;/p&gt;
&lt;p&gt;当前可能大部分人才刚刚开始了解 OAM，所以这篇文章将从最基础出发，为大家介绍 OAM 的诞生背景和要解决的问题，以及它在云原生生态中的作用。&lt;/p&gt;
&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;如果你没有兴趣或者时间阅读下面的全文，那么建议阅读下面这些核心观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAM 的本质是根据软件设计的“兴趣点分离”原则对负责的 DevOps 流程的高度抽象和封装，这背后还是“&lt;strong&gt;康威定律&lt;/strong&gt;”在起作用。&lt;/li&gt;
&lt;li&gt;OAM 仅定义云原生应用的规范，目前推出的 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34;&gt;Rudr&lt;/a&gt; 可以看做是 OAM 规范的 Kubernetes 解释器（实验实现），将云原生应用定义翻译成 Kubernetes 的资源对象。&lt;/li&gt;
&lt;li&gt;OAM 与 &lt;a href=&#34;https://crossplane.io/&#34;&gt;Crossplane&lt;/a&gt; 将展开合作，就 Kubernetes 式以 API 为中心的应用定义发扬光大，并深度参与 &lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34;&gt;CNCF SIG App Delivery&lt;/a&gt;，以共同定义云原生应用标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;康威定律（Conway’s Law）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B&#34;&gt;康威定律&lt;/a&gt;是马尔文·康威（Melvin Conway）1967年提出的： &amp;ldquo;设计系统的架构受制于产生这些设计的组织的沟通结构。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;oam-简介&#34;&gt;OAM 简介&lt;/h2&gt;
&lt;p&gt;OAM 全称是 Open Application Model，从名称上来看它所定义的就是一种模型，同时也实现了基于 OAM 的我认为这种模型旨在定义了云原生应用的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放（Open）：支持异构的平台、容器运行时、调度系统、云供应商、硬件配置等，总之与底层无关&lt;/li&gt;
&lt;li&gt;应用（Application）：云原生应用&lt;/li&gt;
&lt;li&gt;模型（Model）：定义标准，以使其与底层平台无关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺便说下 CNCF 中的也有几个定义标准的「开源项目」，其中有的项目都已经毕业。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34;&gt;SMI（Service Mesh Interface）&lt;/a&gt;：服务网格接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34;&gt;Cloud Events&lt;/a&gt;：Serverless 中的事件标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theupdateframework/specification&#34;&gt;TUF&lt;/a&gt;：更新框架标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe&#34;&gt;SPIFFE&lt;/a&gt;：身份安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其中唯独没有应用标准的定义，&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34;&gt;CNCF SIG App delivery&lt;/a&gt; 即是要做这个的。当然既然要制定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。本文将默认底层平台为 Kubernetes。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是从管理大量 CRD 中汲取的经验。&lt;/li&gt;
&lt;li&gt;业务和研发的沟通成本，比如 YAML 配置中很多字段是开发人员不关心的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-基本对象&#34;&gt;OAM 基本对象&lt;/h3&gt;
&lt;p&gt;OAM 模型中包含以下基本对象，以本文发稿时的最新 API 版本 &lt;code&gt;core.oam.dev/v1alpha2&lt;/code&gt; 为准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/4.component.md&#34;&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/a&gt;：OAM 中最基础的对象，该配置与基础设施无关，定义负载实例的运维特性。例如一个微服务 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/3.workload.md&#34;&gt;workload&lt;/a&gt; 的定义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/6.traits.md&#34;&gt;&lt;strong&gt;TraitDefinition&lt;/strong&gt;&lt;/a&gt;：一个组件所需的&lt;strong&gt;运维策略与配置&lt;/strong&gt;，例如环境变量、Ingress、AutoScaler、Volume 等。（注意：该对象在 &lt;code&gt;apiVersion: core.oam.dev/v1alpha1&lt;/code&gt; 中的名称为 &lt;code&gt;Trait&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/5.application_scopes.md&#34;&gt;&lt;strong&gt;ScopeDefinition&lt;/strong&gt;&lt;/a&gt;：多个 Component 的共同边界。可以根据组件的特性或者作用域来划分 Scope，一个 Component 可能同时属于多个 Scope。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/7.application_configuration.md&#34;&gt;&lt;strong&gt;ApplicationConfiguration&lt;/strong&gt;&lt;/a&gt;：将 Component（必须）、Trait（必须）、Scope（非必须）等组合到一起形成一个完整的应用配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-api-的演变&#34;&gt;OAM API 的演变&lt;/h3&gt;
&lt;p&gt;因为 OAM 还处在发展早起，API 变化较快，以上四个对象在不同的 API 版本中的 &lt;code&gt;kind&lt;/code&gt; 名称不同，请大家使用时注意区别。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;core.oam.dev/v1alpha1&lt;/th&gt;
&lt;th&gt;core.oam.dev/v1alpha2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Component&lt;/td&gt;
&lt;td&gt;ComponentSchematic&lt;/td&gt;
&lt;td&gt;Component&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trait&lt;/td&gt;
&lt;td&gt;Trait&lt;/td&gt;
&lt;td&gt;TraitDefinition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scope&lt;/td&gt;
&lt;td&gt;Scope&lt;/td&gt;
&lt;td&gt;ScopeDefinition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Application configuration&lt;/td&gt;
&lt;td&gt;ApplicationConfiguration&lt;/td&gt;
&lt;td&gt;ApplicationConfiguration&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总的来说，OAM 模型对象的定义格式与 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields&#34;&gt;Kubernetes 对象的类型字段&lt;/a&gt;相似。关于 OAM 的基本概念模型的更多信息请访问 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/2.overview_and_terminology.md&#34;&gt;Overview and Terminology&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;oam-工作原理&#34;&gt;OAM 工作原理&lt;/h3&gt;
&lt;p&gt;下图来自阿里云原生应用平台团队孙健波在 &lt;strong&gt;《OAM:云原生时代的应用模型与 下一代 DevOps 技术》&lt;/strong&gt; 中的分享，OAM 的工作原理如下图所示，OAM Spec 定义了云原生应用的规范（使用一些列 CRD 定义）， Rudr 可以看做是 OAM 规范的解析器，将应用定义翻译为 Kubernetes 中的资源对象。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;oam-principle.png&#34; alt=&#34;OAM 的原理&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;OAM 的原理&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;可以将上图分为三个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;汇编层&lt;/strong&gt;：即人工或者使用工具来根据 OAM 规范定义汇编出一个云原生应用的定义，其中包含了该应用的工作负载和运维能力配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转义层&lt;/strong&gt;：汇编好的文件将打包为 YAML 文件，由 Rudr 或其他 OAM 的实现将其转义为 Kubernetes 或其他云服务（例如 Istio）上可运行的资源对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行层&lt;/strong&gt;：执行经过转义好的云平台上的资源对象并执行资源配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rudr&#34;&gt;Rudr&lt;/h2&gt;
&lt;p&gt;Rudr 是对  &lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.1&#34;&gt;OAM v1alpha1&lt;/a&gt; 在 Kubernetes 环境下的实现，OAM 正在与 &lt;a href=&#34;https://github.com/crossplane/&#34;&gt;Crossplane&lt;/a&gt; 合作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Crossplane&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Kubernetes 社区开创的以 API 为中心的声明式配置和自动化方法，使基础设施和应用管理标准化。官方网站：&lt;a href=&#34;https://crossplane.io/&#34;&gt;https://crossplane.io/&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安装-rudr&#34;&gt;安装 Rudr&lt;/h3&gt;
&lt;p&gt;请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/setup/install.md&#34;&gt;Rudr 文档&lt;/a&gt;安装，主要依赖以下组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;li&gt;helm 3&lt;/li&gt;
&lt;li&gt;Kubernetes 1.15+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行下面的命令安装 Rudr 和需要的 trait。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 克隆项目&lt;/span&gt;
git clone https://github.com/oam-dev/rudr.git
&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rudr
&lt;span class=&#34;c1&#34;&gt;# 创建一个名为 oam 的 namespace&lt;/span&gt;
kubectl create namespace oam
&lt;span class=&#34;c1&#34;&gt;# 安装 Rudr&lt;/span&gt;
helm install rudr ./charts/rudr --wait -n oam
&lt;span class=&#34;c1&#34;&gt;# 要使用 ingress trait，推荐安装 Nginx ingress&lt;/span&gt;
helm repo add stable https://kubernetes-charts.storage.googleapis.com/
helm install nginx-ingress stable/nginx-ingress
&lt;span class=&#34;c1&#34;&gt;# 要使用 autoscaler trait，安装 HorizontalPodAutoscaler&lt;/span&gt;
helm repo add kedacore https://kedacore.github.io/charts
helm repo update
helm install keda kedacore/keda -n oam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看当前 oam namespace 下的所有 pod，你会发现已创建了以下 pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get pod -n oam
NAME                                              READY   STATUS    RESTARTS   AGE
keda-operator-b6466c989-pn25n                     1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
keda-operator-metrics-apiserver-6cf88c468-k5wd8   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
nginx-ingress-controller-787bd69d8-n6v8c          1/1     Running   &lt;span class=&#34;m&#34;&gt;15&lt;/span&gt;         7d
nginx-ingress-default-backend-7c868597f4-vvddn    1/1     Running   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;          7d
rudr-c648c9b7b-knj9b                              1/1     Running   &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;          7d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;部署示例&#34;&gt;部署示例&lt;/h2&gt;
&lt;p&gt;我们使用 OAM 官方提供的教程 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_and_update.md&#34;&gt;Tutorial: Deploy, inspect, and update a Rudr application and its components&lt;/a&gt; 中的 Python &lt;a href=&#34;https://palletsprojects.com/p/flask/&#34;&gt;flask&lt;/a&gt; 示例，该示例基于 OAM v1alpha1 API，最新版 API 的示例可以参考 &lt;a href=&#34;https://github.com/oam-dev/crossplane-oam-sample&#34;&gt;crossplane-oam-sample&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 部署 Component&lt;/span&gt;

kubectl apply -f examples/helloworld-python-component.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时 get pod 会发现并没有创建任何新的 pod，因为 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/helloworld-python-component.yaml&#34;&gt;examples/helloworld-python-component.yaml&lt;/a&gt; 文件中只定义了一个名为 &lt;code&gt;helloworld-python-v1&lt;/code&gt; 的 &lt;code&gt;ComponentSchematic&lt;/code&gt;，但是 &lt;code&gt;ComponentSchematic&lt;/code&gt; 是仅仅是定义了一个组件而已，还无法直接创建 pod 的，还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 绑定才可以创建应用的 pod。&lt;/p&gt;
&lt;p&gt;关于该示例的详细信息请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/how-to/create_component_from_scratch.md&#34;&gt;Python flask 示例&lt;/a&gt;的创建步骤。&lt;/p&gt;
&lt;h3 id=&#34;创建应用配置&#34;&gt;创建应用配置&lt;/h3&gt;
&lt;p&gt;在部署了 &lt;code&gt;ComponentSchematic&lt;/code&gt; 之后我们还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 资源绑定才可以创建应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前已有的 Trait&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装 Rudr 时已在 oam namespace 中部署了一些 trait，使用下面的命令查看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get trait -n oam
NAME             AGE
auto-scaler      7d1h
empty            7d1h
ingress          7d1h
manual-scaler    7d1h
volume-mounter   7d1h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34;&gt;examples/first-app-config.yaml&lt;/a&gt; 中将 &lt;code&gt;ComponentSchematic&lt;/code&gt; 与 ingress &lt;code&gt;Trait&lt;/code&gt; 联系起来。一个完整的可部署的应用配置 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34;&gt;examples/first-app-config.yaml&lt;/a&gt; 的内容如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;apiVersion&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;core.oam.dev/v1alpha1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;kind&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;ApplicationConfiguration&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;metadata&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;first-app&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;spec&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;components&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;componentName&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;helloworld-python-v1&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 引用了上文中的 Component&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;instanceName&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;first-app-helloworld-python-v1&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;parameterValues&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;target&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;value&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Rudr&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;port&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;value&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;9999&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;traits&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;name&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;ingress&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Ingress 引用，Rudr 已默认创建&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;properties&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;hostname&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;example.com&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;path&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;/&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;servicePort&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行下面的命令部署应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl apply -f examples/first-app-config.yaml -n oam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若此时查看 oam namespace 下的 pod 将发现有一个新的 pod 创建。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get pod -o oam
NAME                                              READY   STATUS    RESTARTS   AGE
first-app-helloworld-python-v1-69945684c7-wfd82   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          16m
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;p&gt;执行下面的命令可以测试刚安装的应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将 Python flask 应用的 pod 暴露到本机&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;POD_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get pods -l &lt;span class=&#34;s2&#34;&gt;&amp;#34;oam.dev/instance-name=first-app-helloworld-python-v1,app.kubernetes.io/name=first-app&amp;#34;&lt;/span&gt; -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].metadata.name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
kubectl port-forward &lt;span class=&#34;nv&#34;&gt;$POD_NAME&lt;/span&gt; 9999:9999
Forwarding from 127.0.0.1:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
Forwarding from &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;::1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器中访问 &lt;a href=&#34;http://127.0.0.1:9999&#34;&gt;http://127.0.0.1:9999&lt;/a&gt; 将看到 &lt;code&gt;Hello Rudr!&lt;/code&gt; 的输出，这表示测试成功。&lt;/p&gt;
&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;
&lt;p&gt;从以上描述中可以看出 OAM 对于定义云原生应用标准的野望，其目标不仅限于 Kubernetes 之上的又一上层抽象，而是对于一切云服务，在基于资源对象的基础上，Trait 来控制 Kubernetes 中的一众高层次非可调度的资源对象，如 AutoScaler、Volume、Ingress，Istio 中的流量配置对象 VirtualService、DestinationRule 等，还可容纳更多的云服务，对于 Serverless 时代的去基础设施化的思想不谋而合，OAM 与 Crossplane 的合作及 CNCF SIG App Delivery 的未来可期。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://oam.dev&#34;&gt;OAM 官方网站 - oam.dev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>TheNewStack 云原生 Devops 报告解读</title>
      <link>https://jimmysong.io/blog/cloud-native-devops-book/</link>
      <pubDate>Sun, 02 Jun 2019 18:13:19 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cloud-native-devops-book/</guid>
      <description>
        
        
        &lt;p&gt;本书的主旨是：如果没有成熟的 DevOps 实践，云原生是玩转不起来的。DevOps 已经不是什么新鲜的话题，但到底什么是 &amp;ldquo;Cloud Native DevOps” 及如何实践 Cloud Native DevOps，这正是本书要探讨的内容。&lt;/p&gt;
&lt;p&gt;DevOps 正在经历一次转型，从自动化构建到声明式基础设施、微服务和 Serverless。大部分人对云原生存在误解，以为&lt;code&gt;云原生&lt;/code&gt;就是&lt;code&gt;运行在云上&lt;/code&gt;，其实云原生更偏向于一种理念，即应用的定义及架构方式，而不是将应用运行在哪里。而云上的 DevOps 与传统的 DevOps 有什么区别，开发者和运维人员在云原生时代如何转型？也许本书会给你答案。&lt;/p&gt;
&lt;h2 id=&#34;关于本书&#34;&gt;关于本书&lt;/h2&gt;
&lt;p&gt;本书是由 &lt;a href=&#34;https://thenewstack.com&#34;&gt;TheNewStack&lt;/a&gt; 出品的免费电子书，可以在 &lt;a href=&#34;https://thenewstack.io/ebooks/devops/cloud-native-devops-2019/&#34;&gt;TheNewStack 网站&lt;/a&gt; 上获取本书的电子版，同时推荐 &lt;a href=&#34;https://thenewstack.io/ebooks&#34;&gt;TheNewStack 的电子书系列&lt;/a&gt;，囊括了容器、微服务、Kubernetes、云原生诸多主题，可以作为企业决策的参考读物。&lt;/p&gt;
&lt;p&gt;本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲，有很多观点引用，并结合了一些调查问卷数据展示了一幅云原生 DevOps 的趋势与全景图，下文中我会找一些代表性的观点和图表来说明。&lt;/p&gt;
&lt;p&gt;下面是本书目录，一共分为三大部分：构建、部署和管理，其中前两个部分还给出了参考书目、示例研究等。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;a.jpg&#34; alt=&#34;云原生 DevOps 目录&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生 DevOps 目录&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;h2 id=&#34;谁适合读这本书&#34;&gt;谁适合读这本书&lt;/h2&gt;
&lt;p&gt;IT 经理、CIO、团队领导者，希望规划自己公司或团队的云原生化 DevOps 的实践路径以面对大规模场景。&lt;/p&gt;
&lt;h2 id=&#34;云原生化的-devops&#34;&gt;云原生化的 DevOps&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;云原生是对业务价值和团队功能的重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生化的 DevOps 在应用的管理上与原始的 DevOps 最大的区别就是——使用 YAML 文件配置的声明式基础设施（Declarative infrastructure）与应用程序的代码本身放在同一个存储库中，这些 &lt;code&gt;代码&lt;/code&gt; 将由开发团队来维护，而运维团队的职能将转变为基础设施的构建者，服务安全性、健壮性、可见性及耐用性的守护者。&lt;/p&gt;
&lt;p&gt;AWS 的 Serverless 布道师 Chris Munns 早已甚至预测到 2025 年非云供应商的运维人员将不复存在，虽然听上去有点危言耸听，但这也是为传统 IT 运维人员的职业生涯敲响的警钟。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;b.jpg&#34; alt=&#34;云原生 DevOps 高亮部分&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生 DevOps 高亮部分&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;开发接手了原来传统运维的一些职责，如配置和发布，减少了每次发布的成本，而运维的职责向管理整个系统的复杂性转变，例如转变为 SRE（Site Reliability Engineer）。&lt;/p&gt;
&lt;h2 id=&#34;工作流自动化的价值&#34;&gt;工作流自动化的价值&lt;/h2&gt;
&lt;p&gt;DevOps 的原始教义：DevOps 不是一种工具或流程，而是一种重视整个组织的持续沟通、协作、集成和自动化的实践。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;c.jpg&#34; alt=&#34;工作流自动化的五个案例&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;工作流自动化的五个案例&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;根据自动化的驱动力及持续时间的长短，将 Workflow Automation 划分为五个类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务流程自动化&lt;/li&gt;
&lt;li&gt;分布式系统通信&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;编排&lt;/li&gt;
&lt;li&gt;决策自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运维需要做出的转变&#34;&gt;运维需要做出的转变&lt;/h2&gt;
&lt;p&gt;Damon Edwards 提出于运维需要面对的四个灾难（&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%90%AF%E7%A4%BA%E5%BD%95%E4%B8%AD%E7%9A%84%E5%9B%9B%E9%AA%91%E5%A3%AB&#34;&gt;圣经启示录中的四骑士&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silos（孤岛）&lt;/li&gt;
&lt;li&gt;Ticket queues（无尽的低效的工单）&lt;/li&gt;
&lt;li&gt;Toil（干脏活累活的辛勤）&lt;/li&gt;
&lt;li&gt;Low trust（低信任度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要向云原生 DevOps 转变就要克服以上几个问题。&lt;/p&gt;
&lt;h2 id=&#34;devops-领域的扩展&#34;&gt;DevOps 领域的扩展&lt;/h2&gt;
&lt;p&gt;本书第三章中提到 DevOps 的领域扩展到 Security 和 Networking。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了维持合规的编程语言&lt;/li&gt;
&lt;li&gt;容器镜像扫描&lt;/li&gt;
&lt;li&gt;基于策略的网络安全&lt;/li&gt;
&lt;li&gt;金丝雀测试&lt;/li&gt;
&lt;li&gt;运行时的威胁检测&lt;/li&gt;
&lt;li&gt;日志分析&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>CNCF年度报告解读（2018年）</title>
      <link>https://jimmysong.io/blog/cncf-annual-report-2018-review/</link>
      <pubDate>Wed, 13 Feb 2019 17:23:01 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cncf-annual-report-2018-review/</guid>
      <description>
        
        
        &lt;p&gt;2019年2月初，CNCF 发布了2018年的年度报告，这是 CNCF 继2017年度报告之后，第二次发布年度报告，2017年度的报告只有区区14页，今年的报告长度增长了一倍达31页。下面我将带大家一起来深度解读下这份2018年的年度报告，一窥 CNCF 过去一年里在推广云原生的道路上取得的进展。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文最后附上了2017年和2018年度的报告下载地址。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;cncf-年度报告涵盖的范围&#34;&gt;CNCF 年度报告涵盖的范围&lt;/h2&gt;
&lt;p&gt;在解读 CNCF 的2018年度报告之前，我们先简单回顾下&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34;&gt;2017年度的报告&lt;/a&gt;，因为2017年度报告是 CNCF 的首份年度报告，这样我们也能更好的了解 CNCF 的来龙去脉。&lt;/p&gt;
&lt;p&gt;2017年度报告已经基本确定了 CNCF 每个年度报告所包含的主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我定位&lt;/li&gt;
&lt;li&gt;会员参与情况&lt;/li&gt;
&lt;li&gt;终端用户社区&lt;/li&gt;
&lt;li&gt;项目更新&lt;/li&gt;
&lt;li&gt;会议和活动&lt;/li&gt;
&lt;li&gt;社区&lt;/li&gt;
&lt;li&gt;培训和认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为 CNCF 主要的市场活动，2017年时其成立的第二年，经过一年时间的筹备，这一年里各种市场活动都已经开始确立并有声有色的开展了起来，包括 KubeCon、成员单位、终端用户都已经发展起来了，以后历年里只是对其不断的发展和完善。&lt;/p&gt;
&lt;p&gt;2018年度报告中又新增了一些主题，这些主题是从2018年开始开展的，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;项目更新与满意度调查&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;给 CNCF 项目的维护者发调查问卷询问满意度&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34;&gt;CNCF charter&lt;/a&gt; 的修订（2018年11月）&lt;/li&gt;
&lt;li&gt;项目更新与发布&lt;/li&gt;
&lt;li&gt;项目服务与支援&lt;/li&gt;
&lt;li&gt;专项活动、文档、网站与博客支持&lt;/li&gt;
&lt;li&gt;本地化、IT 支持和培训&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社区拓展&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;社区奖项&lt;/li&gt;
&lt;li&gt;CNCF Meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34;&gt;CNCF Ambassador 计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;卡通吉祥物 Phippy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态系统工具&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devstats.cncf.io/&#34;&gt;devstats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34;&gt;CNCF Landscape&lt;/a&gt; 和路线图&lt;/li&gt;
&lt;li&gt;项目 logo 物料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试一致性项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国际化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进入中国&lt;/li&gt;
&lt;li&gt;本地化网站&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请大家从本文最后的链接下载报告原文以查看详情。&lt;/p&gt;
&lt;h2 id=&#34;cncf-的定位&#34;&gt;CNCF 的定位&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）成立于2015年12月11日，每届年度报告的开篇都会阐明 CNCF 的定位，CNCF 的自我定位在2018年发生了一次变动，这也说明基金会是跟随市场形势而动，其定位不是一成不变的，其中的变化暗含着 CNCF 战略的转变。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的2017年度定位&#34;&gt;CNCF 的2017年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34;&gt;2017年度报告&lt;/a&gt;中是这样正式介绍自己的：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud-native computing universal and sustainable. Cloud-native computing uses an &lt;strong&gt;open source&lt;/strong&gt; software stack to deploy applications as &lt;strong&gt;microservices&lt;/strong&gt;, packaging each part into its own &lt;strong&gt;container&lt;/strong&gt;, and &lt;strong&gt;dynamically orchestrating&lt;/strong&gt; those containers to optimize resource utilization. Cloud-native technologies enable software developers to build great products faster.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Envoy and Prometheus. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;可以看到介绍中的重点技术是：微服务、容器、动态编排。而在2018年 CNCF 对自己进行了重新的定位和包装，增加了新的内容。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的2018年度定位&#34;&gt;CNCF 的2018年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34;&gt;2018年度报告&lt;/a&gt;中 CNCF 对自己的定位是：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. &lt;strong&gt;Containers&lt;/strong&gt;, &lt;strong&gt;service meshes&lt;/strong&gt;, &lt;strong&gt;microservices&lt;/strong&gt;, &lt;strong&gt;immutable infrastructure&lt;/strong&gt;, and &lt;strong&gt;declarative APIs&lt;/strong&gt; exemplify this approach.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Prometheus, Envoy, and many others. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;我们可以看到其表述中更加注重多云环境，主要涉及的技术比2017年多了Service Mesh（服务网格）、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;h2 id=&#34;数读报告&#34;&gt;数读报告&lt;/h2&gt;
&lt;p&gt;CNCF 年度报告的原文主要是汇报了 CNCF 一年来的所展开的活动和进展，下表示根据 CNCF 2017和2018年度报告整理了关键数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Year&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;170&lt;/td&gt;
&lt;td&gt;365&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Contributors&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;18687&lt;/td&gt;
&lt;td&gt;47358&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CNCF Meetup Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;53925&lt;/td&gt;
&lt;td&gt;89112&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Projects&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;End User Community Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Conference and Events Participants&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4085&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Certified Kubernetes Partners&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Certified Kubernetes Service Providers&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CNCF Ambassador&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Kubernetes Training Partners&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：其中2016年是 CNCF 正式开始工作的第一年，大部分数据因为活动尚未开展而缺失。&lt;/p&gt;
&lt;p&gt;从上表中我们可以看到 CNCF 诞生三年来基金会成员规模、托管项目的贡献者、参加 CNCF 名义的 Meetup 的人数取得较大范围的增长，尤其是2018年，因为基金会成员的爆发式增长（+130%），CNCF 开始给成员分级，会员级别、费用和权益也在 &lt;a href=&#34;https://www.cncf.io/about/join/&#34;&gt;CNCF 官网&lt;/a&gt;上明码标价。&lt;/p&gt;
&lt;p&gt;2018年 CNCF 组织的 KubeCon&amp;amp;CloudNativeCon 开始固定每年在西欧、北美和中国举行，且2018年是首次进入中国；原来的 Certified Kubernetes Partners 也取消了变成了 Certified Kubernetes Service Providers；CNCF 的 &lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34;&gt;Ambassador&lt;/a&gt; 计划拥有了来自15个国家的65位 Ambassador，在世界各地为云原生布道；CNCF 还首次引入了 Kubernetes Training Partner。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 又推出了一系列新的认证（CKA 为2017年推出），包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/cka/&#34;&gt;CKA&lt;/a&gt;（Kubernetes 管理员认证）：这是 CNCF 最早制定的一个证书，顾名思义，通过该认证证明用户具有管理 Kubernetes 集群的技能、知识和能力。虽然该证书在2017年即推出，但2018年对考试做了更细致的指导。KCSP 要求企业必须有至少三人通过 CKA。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/ckad/&#34;&gt;CKAD&lt;/a&gt;（Kubernetes 应用开发者认证）：该认证证明用户可以为 Kubernetes 设计、构建、配置和发布云原生应用程序。经过认证的 Kubernetes Application Developer 可以定义应用程序资源并使用核心原语来构建、监控 Kubernetes 中可伸缩应用程序和排除故障。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34;&gt;KCSP&lt;/a&gt;（Kubernetes 服务提供商认证）：截止本文发稿时共有74家企业通过该认证。该认证的主体是企业或组织，通过 KCSP 的企业意味着可以为其他组织提供 Kubernetes 支持、咨询、专业服务和培训。通过该认证的中国企业有：灵雀云、阿里云、博云、才云、DaoCloud、EasyStack、易建科技、精灵云、谐云科技、华为、时速云、星号科技、睿云智合、沃趣、元鼎科技、ZTE。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34;&gt;Certified Kubernetes Conformance&lt;/a&gt;（Kubernetes 一致性认证）：通过该认证的 Kubernetes 提供商所提供的服务，意味着其可以保证 Kubernetes API 的可移植性及跨云的互操作性；及时更新到最新的 Kubernetes 版本；是否一致是可以通过&lt;a href=&#34;https://github.com/cncf/k8s-conformance/blob/master/instructions.md&#34;&gt;运行开源脚本&lt;/a&gt;验证的。截止本文发稿通过该认证的中国企业的发行版有：灵雀云（ACE、ACP、AKS）、才云 Compass、华为 FusionStage、酷栈科技 CStack MiaoYun、Daocloud Enterprise、新智认知新氦云、浪潮云、京东 TIG、网易云、七牛云、同方有云、睿云智合 WiseCloud；通过认证的中国企业托管平台有：阿里云、百度云、博云、EasyStack、易建科技、谐云科技、华为云 CCE、腾讯云 TKE、时速云、ZTE TECS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 提供的主要证书，一般通过 KCSP 的企业都要先通过 Kubernetes 一致性认证，而通过 Kubernetes 一致性认证不一定要同时通过 KCSP，所以我们看到很多通过 Kubernetes 一致性认证的企业就不一定会通过 KCSP，因为 KCSP 的要求更多，至少要成为 CNCF 会员才可以。&lt;/p&gt;
&lt;p&gt;下面将就 CNCF 会员、托管项目的成熟度等级划分、Kubernetes 服务提供商认证和 Kubernetes 提供商认证做详细说明。&lt;/p&gt;
&lt;h2 id=&#34;cncf-会员&#34;&gt;CNCF 会员&lt;/h2&gt;
&lt;p&gt;2018年 CNCF 的会员单位经历了爆发式增长，从170家增长到365家。CNCF 制定了如下的会员等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silver Member&lt;/li&gt;
&lt;li&gt;Gold Member&lt;/li&gt;
&lt;li&gt;Platinum Member&lt;/li&gt;
&lt;li&gt;Academic/Nonprofit Member&lt;/li&gt;
&lt;li&gt;End User Member&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同等级的会员需要交纳的年费与权益不同，详情请见 &lt;a href=&#34;https://www.cncf.io/about/join/&#34;&gt;https://www.cncf.io/about/join/&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;成为-cncf-会员的好处&#34;&gt;成为 CNCF 会员的好处&lt;/h3&gt;
&lt;p&gt;成为 CNCF 会员包括但不限于如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将可以参与 CNCF 市场委员会、CNCF Webinar、在 CNCF 和 Kubernetes 官网发表博客、博客被 KubeWeekly 收录、&lt;/li&gt;
&lt;li&gt;获得 KubeCon + CloudNativeCon 的门票折扣和参与大会的市场活动&lt;/li&gt;
&lt;li&gt;对于 Kubernetes 系列认证如 KCSP、入选 TOC 也要求必须成为 CNCF 会员才可以获得&lt;/li&gt;
&lt;li&gt;End User Case Study&lt;/li&gt;
&lt;li&gt;有机会加入 Ambassador 计划&lt;/li&gt;
&lt;li&gt;在社区里具有更多的话语权，例如 CNCF 在全球范围内组织的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;项目成熟度等级&#34;&gt;项目成熟度等级&lt;/h2&gt;
&lt;p&gt;自2015年底 CNCF 创立之初 Kubernetes 成为其首个托管项目以来，截止到2018年底，CNCF 已经托管了&lt;a href=&#34;https://www.cncf.io/projects/&#34;&gt;32个开源项目&lt;/a&gt;，随着越来越多的项目加入到 CNCF，为了更好的管理这些项目，为这些项目划分不同的成熟度等级就成了迫在眉睫的事情。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;cncf-graduation-criteria-v2.jpg&#34; alt=&#34;CNCF 项目成熟度级别&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;CNCF 项目成熟度级别&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;根据《Crossing the Chasm》一书中的技术采用生命周期理论，CNCF 将其托管的项目划分为三个等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graduated：对应于早期成熟项目。截止到本文发稿时只有 &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;、&lt;a href=&#34;https://www.envoyproxy.io/&#34;&gt;Envoy&lt;/a&gt; 和 &lt;a href=&#34;https://coredns.io/&#34;&gt;https://coredns.io/&lt;/a&gt; 毕业。&lt;/li&gt;
&lt;li&gt;Incubating：对应于早期采用者阶段。截止到本文发稿时有 16 个项目。&lt;/li&gt;
&lt;li&gt;Sandbox：对应于创新者阶段。截止到本文发稿时有 12 个项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看 CNCF 托管的项目列表请访问：https://www.cncf.io/projects/&lt;/p&gt;
&lt;p&gt;CNCF 通过为项目设置成熟度水平是来建议企业应该采用哪些项目。CNCF 中托管的项目通过向 CNCF 的技术监督委员会（TOC）展示其可持续发展性来提高其成熟度：项目的采用率，健康的变化率，有来自多个组织的提交者，采用了 &lt;a href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34;&gt;CNCF 行为准则&lt;/a&gt;，实现并维护了核心基础设施倡议（Core Infrastructure Initiative）&lt;a href=&#34;https://bestpractices.coreinfrastructure.org/&#34;&gt;最佳实践证书&lt;/a&gt;。详细信息在 &lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&#34;&gt;毕业标准v1.1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-service-provider&#34;&gt;Certified Kubernetes Service Provider&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34;&gt;KCSP&lt;/a&gt; 意味着企业具有为其他企业或组织提供 Kubernetes 支持、咨询、专业服务和培训的资质。 2018年又有46家企业通过了&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34;&gt;KCSP&lt;/a&gt;，通过该认证的企业累计达到76家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何通过 KCSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想通过 KCSP 必须满足以下三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三名或更多工程师通过认证Kubernetes管理员（CKA）考试。&lt;em&gt;（CKAD考试不计入此要求）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;支持企业最终用户的商业模式，包括为客户提供驻场工程师&lt;/li&gt;
&lt;li&gt;成为 CNCF 会员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 KCSP 有如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业的 logo 会出现在 &lt;a href=&#34;https://kubernetes.io/partners/&#34;&gt;Kubernetes Partners&lt;/a&gt; 页面&lt;/li&gt;
&lt;li&gt;参加与云原生项目 leader、TOC 成员、CNCF Governing Board 的月度会议&lt;/li&gt;
&lt;li&gt;向终端用户的 leader 寻求帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为有如上这些好处，为了获得 Kubernetes 项目实施的资质，同时保持与基金会至今的交流，Kubernetes 厂商对该认证都趋之若鹜。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-offering&#34;&gt;Certified Kubernetes offering&lt;/h2&gt;
&lt;p&gt;通过 KCSP 认证只代表企业有为他人实施 Kubernetes 项目的资质，而企业自身可能并不对外提供 Kubernetes 平台或服务，这些企业可能只是系统集成商或 ISV，这时候 CNCF 又推出了 Kubernetes 提供商认证。&lt;/p&gt;
&lt;p&gt;Kubernetes 认证的提供商包括 Kubernetes 发行版、托管平台和安装器，通过认证的工具或平台将允许使用 Kubernetes 认证的 Logo，并保证 Kubernetes 一致性认证。&lt;/p&gt;
&lt;h2 id=&#34;展望-2019&#34;&gt;展望 2019&lt;/h2&gt;
&lt;p&gt;2018年 Kubernetes 成为 CNCF 孵化的首个毕业项目，根据 CNCF 打造的项目成熟度模型，Prometheus、Envoy、CoreDNS 相继毕业，CNCF 的眼光早已不再仅盯着 Kubernetes 了，&lt;a href=&#34;https://landscape.cncf.io&#34;&gt;CNCF Landscape&lt;/a&gt; 几乎包揽了所有云计算相关开源项目。可以说 CNCF 早已超出了 Kubernetes 的范畴，而是旨在一个建立在 Kubernetes 为底层资源调度和应用生命周期管理之上的生态系统，CNCF 中还演进出了如 Service Mesh 和 Serverless 之类的分支。&lt;/p&gt;
&lt;p&gt;从 CNCF 2017和2018年度的变化来看，其中已经去掉了”dynamically orchestrating“的字眼，也就意味着 Kubernetes 在容器编排领域已经胜出，进而强调多云环境，同时 CNCF 推动的 Kubernetes 一致性认证也受到众多云厂商的支持，这也意味着 Kubernetes 将成为多云环境 API 一致性的保证。&lt;/p&gt;
&lt;p&gt;CNCF 在2019年的战略将更聚焦于开发者社区，协助尤其是来自终端用户的开发者成为项目的 contributor 和 maintainer，保证终端用户的意见能够在社区里被正确地传达和并最终成功地采纳云原生。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34;&gt;CNCF Annual Report 2017 pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34;&gt;CNCF Annual Report 2018 pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/projects/&#34;&gt;CNCF  Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34;&gt;CNCF Landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34;&gt;CNCF Ambassadors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34;&gt;Kubernetes Certified Service Providers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>云原生编程语言Pulumi开源宣言</title>
      <link>https://jimmysong.io/blog/hello-pulumi-from-jeo-duffy/</link>
      <pubDate>Sun, 24 Jun 2018 11:38:30 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/hello-pulumi-from-jeo-duffy/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;2018年6月18日 Joe Duffy在&lt;a href=&#34;http://joeduffyblog.com/2018/06/18/hello-pulumi/&#34;&gt;他的博客&lt;/a&gt;中宣布开源了云原生编程语言&lt;a href=&#34;https://pulumi.io&#34;&gt;Pulumi&lt;/a&gt;。这是继&lt;a href=&#34;https://ballerina.io&#34;&gt;Ballerina&lt;/a&gt;之后我看到的另一款云原生编程语言，他们之间有一些共同的特点，例如都是为了支持多种云环境，基于不可变基础设施和基础设施即代码的理念构建，使云原生应用的集成更加方便，但也有一些不同，Ballerina是直接创建了一个基于JVM的语言，而Pulumi是为不同编程语言构建了SDK。&lt;/p&gt;
&lt;p&gt;下文是对	&lt;a href=&#34;http://joeduffyblog.com/2018/06/18/hello-pulumi/&#34;&gt;Hello, Pulumi!&lt;/a&gt;一文的翻译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们发布了Pulumi，这是一款开源的云开发平台。有了Pulumi，您可以使用自己最喜欢的编程语言来开发云应用程序，可以直接跨过底层的基础设施即代码直接开发更高效更具生产力的现代容器和serverless应用。一年多前我们发起了Pulumi，我们都为自己在这一年多取得的成绩感到惊讶。这是我们开源的第一步，也是我们做出的一步重大跨越，我们期望与您分享我们的成就。&lt;/p&gt;
&lt;p&gt;Pulumi支持多语言、混合云环境、完全可扩展。初期支持JavaScript、TypeScript、Python和Go语言，支持AWS、Azure、GCP云平台，另外还支持所有兼容Kubernetes的公有云、私有云和混合云。Pulumi实现了一种单一、一致的编程模型，一组编程工具，可管理所有以上环境，丰富的生态系统支持大量可复用的包。使用真实的语言来改变一切。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL;DR 有了Pulumi，38页的手动操作说明将变成了38行代码。25000行YAML配置变成了使用真实编程语言的500行语句。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Pulumi的整个运行时、CLI、支持的库都可以在GitHub上免费下载。我们的团队正急切的等待您的反馈。与此同时，我需要告诉您一些关于Pulumi的事情，为什么我们会创造它。&lt;/p&gt;
&lt;h2 id=&#34;为什么创造pulumi&#34;&gt;为什么创造Pulumi？&lt;/h2&gt;
&lt;p&gt;我的背景是100%在开发者工具上。我是.NET的早期工程师，设计了其中的并发和异构部分，领导的分布式操作系统的变成平台，管理微软语言小组，包括开源和使.NET Core跨平台。因为这些背景，进入云领域我有自己的见解。&lt;/p&gt;
&lt;p&gt;我发现的东西显然无法吸引我。&lt;/p&gt;
&lt;p&gt;2016年年末的时候我就开始跟我的朋友也是共同创始人Eric Rudder开始构思Pulumi，那时候容器和serverless已经甚嚣尘上，但是距离落地还为时尚早。云的能力十分惊人，但是至今将使用它还是十分困难。&lt;/p&gt;
&lt;p&gt;对于每一个serverless函数来说，我都要写几十行的JSON或者YAML配置。要链接到一个API端点，我还要学习晦涩的概念，执行一系列复制-粘贴的低级工作。如果我想在本机上运行一个小的集群的话，那么Docker还是很棒的，但是如果要在生产上使用的话，那么就要手动管理etcd集群，配置网络和iptables路由表，还有一系列与我的应用程序本身不相干的事情。不过Kubernetes的出现至少让我可以配置一次下次就可以跨云平台重用，但这还是会分散开发人员的精力。&lt;/p&gt;
&lt;p&gt;我认为我还算一个经验丰富的工程师，已经在软件行业从业20年了，但是当我想要将自己的代码部署到云中的时候，我感觉自己就像是个傻子。真是太令人悲哀了！如果我掌握了这些能力，那么是世界就会出触手可及。我总是在淌这浑水，处理云的复杂性，而我真正想做的是花时间来创造业务价值。&lt;/p&gt;
&lt;p&gt;关于编程的许多方面都经历了类似的转变过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在80年代初，我们使用汇编语言对微处理器进行了编程。最终，编译器技术进步了，我们可以同时处理多种常见的架构。像FORTRAN和C这样的Low-level的编程语言开始兴起。&lt;/li&gt;
&lt;li&gt;在90年代初期，我们直接针对低级别操作系统原语进行编程，无论是POSIX系统调用还是Win32 API，并进行手动内存和资源管理。最终，语言运行时技术和处理器速度提升到了可以使用更高级别语言的状态，如Java。除了动态语言之外，这种趋势已经加速，如JavaScript统治了Web。&lt;/li&gt;
&lt;li&gt;在21世纪初期，我们的编程模型中的共享内存并发性最好是原始的（&lt;a href=&#34;http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/&#34;&gt;我花了很多时间在这个问题上&lt;/a&gt;）。现在，我们简单地假设OS具有高级线程共享、调度和异步IO功能，以及编程到更高级别的API，例如任务和承诺。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我相信云软件也在进行类似的转变。从构建单一应用程序到构建真正的云优先分布式系统，我们正处在一场巨变中。然而，当海啸发生之前，人们几乎不知道它正在发生。&lt;/p&gt;
&lt;p&gt;从上面的角度来看，使用“配置”情况是有道理的。在虚拟机的早期，我们利用现有的应用程序并将它们扔在栅栏上，以便有人添加一点INI或XML粘合剂，让它们在虚拟机内部运行，以实现更灵活的管理。随着我们将这些相同的虚拟机“提升并转移到云中”，这种配置方法一直伴随着我们。这将我们带到了大致正确的边界。&lt;/p&gt;
&lt;p&gt;使用这种相同类型的配置表示基于容器的微服务、serverless和细粒度托管服务之间的关系导致了异常的复杂性。将应用程序转变为分布式系统应该是事后的想法。事实证明，云覆盖了您的架构和设计。表达架构和设计的最好的方式是使用代码，使用真正的编程语言编写抽象，重用和优秀的工具。&lt;/p&gt;
&lt;p&gt;早些时候，Eric和我采访了几十个客户。我们发现，开发人员和DevOps工程师都普遍感到幻灭。我们发现了极端的专业化，即使在同一个团队中，工程师也不会使用同一种语言。最近几周我已经听到了这个消息，我期待有一天会出现NoYAML运动。&lt;/p&gt;
&lt;p&gt;专业化是一件好事，我们希望我们最优秀和最聪明的云计算架构师晋升到DevOps和SRE的高级职位，但团队必须能够在合作时使用相同的语言。因为没有共同的通用语言导致了团队之间的物理隔离，而不是根据策略和环境分工。Pulumi的目标是为人们提供解决这个问题所需的工具。&lt;/p&gt;
&lt;h2 id=&#34;pulumi是什么&#34;&gt;Pulumi是什么？&lt;/h2&gt;
&lt;p&gt;Pulumi是一个支持多语言和混合云开发平台。它可以让您使用真实语言和真实代码创建云计算的各个方面，从基础设施到应用程序本身。只需编写程序并运行它们，Pulumi就能帮你完成出其余部分。&lt;/p&gt;
&lt;p&gt;Pulumi的中心是一个云对象模型，与运行时相结合以了解如何以任何语言编写程序，理解执行它们所需的云资源，然后以强大的方式规划和管理您的云资源。这种云运行时和对象模型本质上是与语言、云中立的，这就是为什么我们能够支持如此多的语言和云平台。更多支持正在路上。&lt;/p&gt;
&lt;p&gt;Pulumi采用了基础设施即代码以及不可变基础设施的概念，并可让您从您最喜欢的语言（而不是YAML或DSL）中获得自动化和可重复性优势。在部署它们之前，您可以对变更进行区分，并且我们会对谁更改了什么以及何时更改进行完善的审计追踪。核心模型因此是陈述性的。&lt;/p&gt;
&lt;p&gt;使用真正的语言可以带来巨大的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;熟悉&lt;/strong&gt;：不需要学习新的定制DSL或基于YAML的模板语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象&lt;/strong&gt;：正如我们喜爱的编程语言那样，我们可以用更小的东西来构建更大的东西&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享和重用&lt;/strong&gt;：利用现有的语言包管理器共享和重用这些抽象，无论是与社区、团队内部共享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表现力&lt;/strong&gt;：充分利用您的编程语言，包括异步、循环和条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工具&lt;/strong&gt;：通过使用真正的语言，我们可以即时访问IDE、重构、测试、静态分析和编排等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生产力&lt;/strong&gt;：将以上所有好处加在一起，一起将变得更快，我们也会变得更快乐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当提供原始云资源时，这些好处当然最重要，但是我们在团队中发现，您只能使用抽象。这包括在函数中包装事物以消除样板并创建引入更高级别概念的自定义类，通常将它们打包并重复使用。&lt;/p&gt;
&lt;p&gt;例如，此代码在AWS中创建一个DynamoDB数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;@pulumi/aws&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;music&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dynamodb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;music&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;Album&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;Artist&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hashKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;Album&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rangeKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;Artist&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此代码创建一个基于容器的任务和无服务器功能，由一个存储桶触发：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;@pulumi/cloud&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;ffmpegThumbTask&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;./path_to_dockerfile/&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onPut&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;onNewVideo&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucketArgs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucketArgs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;S3_BUCKET&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;INPUT_VIDEO&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;TIME_OFFSET&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;replace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;OUTPUT_FILE&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;.jpg&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更好的是，这些代码可以根据您的需求部署到任何公共或私有云中。&lt;/p&gt;
&lt;p&gt;最后，这个例子创建了一个Redis缓存。我们怎么知道？我们不需要。缓存组件是一个抽象，它封装了我们可以安全忽略的不重要的细节：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;./cache&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;url-cache&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在使用Pulumi之后，你不会再以同样的方式考虑基础设施。你的大脑将不再是一个独立于应用程序的独特“事物”，而是开始将分布式云系统看作是你的程序架构的核心部分，而不是事后的想法。&lt;/p&gt;
&lt;p&gt;由于抽象，我们已经能够提供一些强大的库。该库是提炼和执行最佳实践的绝佳方式。当然，对于我们自己的库来说没有什么特别的，因为它们只是功能、类和代码，我们期待着看到你为自己、你的团队或者社区建立的那些库。&lt;/p&gt;
&lt;p&gt;我们最复杂的库——Pulumi云框架——提供了一些令人兴奋的正在进行的工作的早期预览，展示如何创建跨越云提供商自己对诸如容器、无服务器功能和存储桶等核心概念的抽象。以同样的方式，您可以用Node.js、Python、Java、.NET等语言编写功能强大的应用程序，利用进程、线程和文件系统，无论是在macOS、Linux还是Windows上，这种方法都可以让您创建针对任何云提供商的现代混合云应用程序。像Kubernetes和其他CNCF产品组合这样的技术正在帮助推动这一不可避免的结果，因为它们在整个云基板上实现了对基本计算抽象的民主化和共识。&lt;/p&gt;
&lt;p&gt;Pulumi不是PaaS，尽管它提供类似PaaS的生产力；您的程序总是直接针对您选择的云运行，并且始终可以访问该基础云的全部功能。即使您选择使用更高级别的组件，它也会向下兼容，并且您可以随时直接使用原始资源。它就像任何复杂的现代软件：有时，整个事情必须用C++编写，以便访问底层平台的全部功能，但对于大多数常见情况，70%到100％可以是平台独立代码，而只有不到30%的专业化才能真正需要直接与操作系统交互。&lt;/p&gt;
&lt;p&gt;接下来我还将发布十几篇博客文章来介绍Pulumi所有方面的更多细节。然而，为了保持这篇文章尽量简短，我将首先介绍下Pulumi的一些我最喜欢的方面。&lt;/p&gt;
&lt;h2 id=&#34;我最喜欢的东西&#34;&gt;我最喜欢的东西&lt;/h2&gt;
&lt;p&gt;这很难选择，但这里有一些关于Pulumi我最喜欢的东西：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源&lt;/strong&gt;。我坚信所有开发人员工具都应该是开源的。当然，Pulumi也是一家公司，但是有充足的机会通过增加便利性以建立商业模式。（可以认为是​​Git与GitHub的关系）我们从以前的工作中受益匪浅，其中包括Docker、Terraform、Kubernetes、TypeScript以及其他许多明确提及的工作。我们期待成为生态系统的一部分。因为我们在开放源代码方面下了很大功夫，所以我很高兴看到社区给我们带来什么，特别是在更高级别的软件包领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多语言&lt;/strong&gt;。就像使用Java和.NET一样，Pulumi运行时的架构可以支持多种语言，并以目标语言的所有方面（风格、语法、软件包等）的惯用方式来实现。因为我们是开源的，任何人都可以贡献自己的力量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合云&lt;/strong&gt;。我们的云对象模型是一个强大的基础，可以支持任何云提供商。这提供了一个统一的编程模型，工具和控制平面，用于在任何地方管理云软件。如果仅仅是为了让一个简单的基于容器的应用程序在生产中运行起来，没有必要学习三种不同的YAML方言和五种不同的CLI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云对象模型&lt;/strong&gt;。这个底层云对象模型为您的云计算构建方式提供了丰富的视图。所得到的对象使用程序中的依赖关系组成一个DAG，系统可以分析和理解这些依赖关系以提供洞察力，这是我们打算随着时间的推移解锁复杂的静态分析和可视化的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重复使用的组件&lt;/strong&gt;。由于拥有真正的语言，我们可以构建更高层次的抽象。我最喜欢的例子之一是帮助我们的客户定期从部署中排除1000行YAML，这是我们的AWS基础架构软件包。它采用AWS最佳实践来设置虚拟私有云，并提供专用子网和多可用区域支持，并将其转变为几行代码以配置整个网络：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;awsinfra&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;@pulumi/aws-infra&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;network&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;awsinfra&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`${prefix}-net`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;numberOfAvailabilityZones&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Create&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subnets&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;many&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AZs&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;usePrivateSubnets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Run&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inside&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;per&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AZ&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subnets&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;迄今为止，我最喜欢的成功案例是将客户的25,000行AWS CloudFormation YAML文件（其中使用无服务器、容器、基础设施和三个自定义部署管道）使用500行TypeScript和一个Pulumi的持续部署架构来替换。这不仅仅使得公司所有工程师都可以理解的代码变得少得多，这样他们可以将过去需要花费数周时间才能完成的事情现在用一个下午就可以搞定，而且现在可以在任何云或原生的Kubernetes上运行，而不仅是在AWS。管理团队的CloudFormation堆栈，而不是一个工作量过饱和的工程师，整个团队可以更加高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统一的容器构建/发布管道&lt;/strong&gt;。尝试将容器投入生产时有个问题让我早就感到很沮丧，就是同步我的应用程序、容器和基础架构管理，因为每个容器都倾向于使用不同的工具。我们的云框架演示了一个集成的工作流程，在这个工作流程中，只需简单地运行Pulumi构建、diff、推送和拉取新的容器镜像，所有这些都经过精心安排，以消除停机时间。&lt;/p&gt;
&lt;p&gt;**Lambda无服务器功能 **。 AWS的取了个好名字：Lambda。在Pulumi中，我现在可以用我最喜欢的语言使用lambda表达式来编写我的无服务器函数，而不需要一行YAML：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;@pulumi/aws&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverless&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;@pulumi/aws-serverless&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topic&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Topic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;topic&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;serverless&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cloudwatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;hourly&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;rate(60 minutes)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;aws-sdk&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SNS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;publish&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JSON&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringify&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;TopicArn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此功能允许您捕获对变量的引用：常量、配置设置或加密，甚至可以引用其他资源，以便与它们进行通信。当你第一次这样做的时候，我保证你会有一个“哇塞”的时刻，将无服务器连接到你写过的每一个事件驱动的代码片段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用API的资源&lt;/strong&gt;。因为我可以捕获对其他云资源的引用，所以我可以在其上创建API以使它们更易于在我的运行时代码中使用。这使得“演员般的”编程模型无需处理配置和服务发现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆栈&lt;/strong&gt;。 Pulumi的核心是“堆栈”的概念。堆栈是您的云计算的独立实例，其资源和配置与所有其他堆栈不同。您可能有一堆用于生产、暂存和测试的堆栈，或者可能是每个单一租户的环境。Pulumi的CLI使得启动和卸载大量堆栈变得轻而易举。这会打开以前可能没有尝试过的工作流，例如每个开发人员都拥有自己的堆栈，将新堆叠起来（并拆除）以测试每个Pull请求，甚至将服务的层拆分成多个链接在一起的堆栈。&lt;/p&gt;
&lt;p&gt;我将在未来的博客文章介绍如何做。现在Pulumi已经公开，期望在接下来的几天和几周内听到更多的消息。我希望这能让您更好地了解整体平台，其方法和独特优势。&lt;/p&gt;
&lt;h2 id=&#34;下一步是什么&#34;&gt;下一步是什么？&lt;/h2&gt;
&lt;p&gt;我们希望通过Pulumi，开发人员和DevOps团队都将体验到云的复兴。构建强大的云软件将更加愉快、更高效、更具协作性。现代云计算软件将从代码孤岛转变为等量的配置胶水，成为优雅的分布式系统。&lt;/p&gt;
&lt;p&gt;这是一个难题。我绝不会说我们已经解决了它。我确实相信Pulumi是我亲身见过并希望最接近我心目中的云开发平台。在这个激动人心的时刻，投注于语言将使我们所有人“站在巨人的肩膀上”，这让我感到乐观；语言总是一个安全的赌注。&lt;/p&gt;
&lt;p&gt;今天很可能是我职业生涯中最激动人心的一天。我想感谢我们的团队和所有帮助过我们的人，放纵我们的疯狂想法并相信我们。&lt;/p&gt;
&lt;p&gt;现在访问&lt;a href=&#34;https://pulumi.io/&#34;&gt;https://pulumi.io&lt;/a&gt;，或者直接运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -fsSL https://get.pulumi.com &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我迫不及待想看看你将使用Pulumi构建的所有令人难以置信的东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;P.S 我要感谢我已故的导师，最好的朋友Chris Brumme。虽然Chris没办法和我们一起庆祝这一刻，但我清楚“Chris每一步会做些什么”。Pulumi是夏威夷语，是“扫帚”的意思，尽管这完全是他名字的错误发音，但为了纪念Chirs我还是用了它。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生编程语言Ballerina介绍</title>
      <link>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</link>
      <pubDate>Sat, 12 May 2018 23:27:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</guid>
      <description>
        
        
        &lt;p&gt;当我第一眼看到 &lt;a href=&#34;https://ballerina.io&#34;&gt;Ballerina&lt;/a&gt; 还真有点惊艳的感觉。Ballerina 这个单词的意思是“芭蕾舞女演员”。我想他们之所以给公司和这们语言起这个名字，可能是希望它成为云原生这个大舞台中，Ballerina 能像一个灵活的芭蕾舞者一样轻松自如吧！&lt;/p&gt;
&lt;p&gt;Ballerina 是一款开源的编译式的强类型语言，该语言本身的代码可以通过 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-lang&#34;&gt;GitHub&lt;/a&gt; 上获取。我们可以通过 Ballerina 官网上的&lt;a href=&#34;https://ballerina.io/philosophy/&#34;&gt;设计哲学&lt;/a&gt;页面来对这门云原生编程语言一探究竟。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg&#34; alt=&#34;云原生编程语言 Ballerina&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言 Ballerina&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;未来的应用程序应该是基于 API 的，而众多 API 之间的通讯和集成就成了关键问题。Ballerina 是一款使用文本和图形语法编译的、事务的、静态和强类型编程语言。Ballerina 包含分布式系统集成到语言的基本概念，并提供类型安全，并发环境下实现的分布式事务，可靠的消息传递，流处理和工作流。&lt;/p&gt;
&lt;h2 id=&#34;为什么创建-ballerina&#34;&gt;为什么创建 Ballerina？&lt;/h2&gt;
&lt;p&gt;与 ESB 集成仍然是瀑布式开发。你必须部署服务器，配置连接器，使用 XML 编程服务逻辑以及使用 XPath 查询和转换数据。这不是开发者友好的。&lt;/p&gt;
&lt;p&gt;带有 Spring 和 Node.js 等框架的编程语言提供了灵活性，但是它没有使适合于序列并行化、并发模型编程的分布式系统结构变得简单。&lt;/p&gt;
&lt;p&gt;ESB、EAI、BPM 和 DSL 需要 XML 和配置来中断迭代开发流程：编辑、构建、运行和测试。这与运行实际应用之间是有一条鸿沟的，而云原生编程语言 Ballerina 的出现就是为了解决这条“集成鸿沟”的。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-设计理念&#34;&gt;Ballerina 设计理念&lt;/h2&gt;
&lt;h3 id=&#34;序列图&#34;&gt;序列图&lt;/h3&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg&#34; alt=&#34;云原生编程语言Ballerina的序列图设计理念&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言Ballerina的序列图设计理念&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言灵感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列图反映了设计开发人员记录的互联的系统。Ballerina 的语法和高效的编码模式要求开发人员使用强大的交互最佳实践来编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列图可视化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的语言语义模型旨在定义独立的各方如何通过结构化的交互沟通。接着，每个 Ballerina 程序都可以显示为其流程的序列图。IntelliJ 和 VS Code 的插件中提供了这些可视化。Ballerina Composer 是一款通过序列图创建 Ballerina 服务的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actor 与 action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端、worker 和远程系统在 Ballerina 的序列图中以不同的 actor 表示。在代码中，远程端点通过连接器进行连接，连接器提供类型安全操作。在图形上，每个连接器在序列图中表示为一个 actor（即一条垂直线），action 表示为与这些actor 的交互。&lt;/p&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88c99h584j30u00ww752.jpg&#34; alt=&#34;云原生编程语言Ballerina的并发理念&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言Ballerina的并发理念&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列图和并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的并发模型是并行优先的，因为与远程方的交互总是涉及多个 worker。Worker 之间的交互作为消息传递进行处理，它们之间没有共享状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worker 语义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的执行模型由称为 woker 的轻量级并行执行单元组成。Worker 使用非阻塞策略来确保没有函数锁定正在执行的线程，例如等待响应的 HTTP I/O调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Worker 和 fork/join 语义抽象了底层非阻塞方法，以启用更简单的并发编程模型。&lt;/p&gt;
&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;
&lt;p&gt;下面是 Ballerina 中支持的类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;any&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anything&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;integer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;floatingPoint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;blob&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toBlob&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jsonNative&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;XML&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;natively&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
             &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringArray&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;there&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arrayOfArrays&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unionType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// the empty tuple acts as &amp;#34;null&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringOrInt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;this is a union type&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;intOrNull&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inferred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ballerina&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myRecord&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myObject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;   
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;类型安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 有一个结构化的类型系统，包括 primitive、recored、object、tuple 和 union 类型。该类型安全模型在赋值时包含了类型推断，并为连接器、逻辑和网络绑定的有效负载提供了大量的编译时完整性检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Union 类型和显式 Null&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;各个网络端点通常会根据其输入和逻辑返回具有不同有效负载类型消息或 error。Ballerina 的类型系统采用了基于 union 类型的方法。Union 类型明确地采用了这种语义，不需要开发人员创建不必要的“包装”类型。这种方法也增强了对 null 值的处理。默认情况下，类型不支持 null 值。开发人员必须明确创建 union 类型来处理 null 值。结果是 null 的异常不会发生，并且语言语法和编译器会识别是否需要 null 处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异构数据处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 类型系统内置丰富的对 JSON、XML、流和表格的支持以及对 ProtoBuf 和 gRPC 的直接支持。这样做的结果是可以获得处理网络负载、SQL 编程和流处理的干净可读的代码。数据转换逻辑不受复杂的生成类型、第三方库代码或其他混淆因素的影响——简单明了的可读代码捕捉与异构数据和转换逻辑的交互。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-如何工作&#34;&gt;Ballerina 如何工作？&lt;/h2&gt;
&lt;p&gt;Ballerina 的语法、代码和编译器创建了运行时服务和部署构件，这些工件都是云原生就绪的，您可以选择将其部署在 IaaS、编排系统或 service mesh 中的。开发人员的体验旨在维护流程，包括快速的编辑、构建、调试周期并集成到团队的生命周期工具链中。&lt;/p&gt;
&lt;h3 id=&#34;运行时架构&#34;&gt;运行时架构&lt;/h3&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg&#34; alt=&#34;云原生编程语言ballerina运行时架构&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言ballerina运行时架构&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina API 网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强制执行身份策略并保证性能。通过代码注解（类似于 Spring 中的注解）进行配置和部署。可以运行嵌入式服务、作为管理多个服务的容器代理或者使用 API 管理解决方案（如 WSO2 API Manager）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示您的 API 和执行逻辑。服务通过不同的协议运行，内部代码结构被编译为支持 OpenAPI 和 Swagger 的API接口。服务与端点进行通信，无论它们是调用客户端还是其他服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina bridge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许传统代码和服务参与分布式事务中的 Ballerina 服务。Bridge 将您现有服务与本地代理包装起来，通过调用 Ballerina 服务参与和代理分布式事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息代理、事务协调者和身份代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为参与事务、事件驱动的通信和为认证流程的 Ballerina 服务提供代理基础设施功能。这些组件可以嵌入到单个服务部署中或者进行单独部署和扩展以管理多个服务。&lt;/p&gt;
&lt;h3 id=&#34;部署架构&#34;&gt;部署架构&lt;/h3&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88cbr5hquj30u00wxq46.jpg&#34; alt=&#34;云原生编程语言ballerina部署架构图&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言ballerina部署架构图&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IaaS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用代码注解和构建系统，可以打包 Ballerina 服务和其他运行时组件（如 API 网关）以部署到任何云原生环境中。在 IaaS 环境中，Ballerina 服务可以以虚拟机或容器的方式运行，也可以在构建期间将镜像推送到 registry 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码注解会触发编译器扩展，从而为不同的编排器（如 Kubernetes 或 Cloud Foundry）生成 Ballerina 组件的工件包。供应商或 DevOps 可以添加自定义代码注解以生成特定于环境的部署，例如自定义蓝色部署算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 可以选择断路器和事务流程逻辑委托给像 Istio 或 Envoy 这样的 service mesh（如果有的话）。如果没有 service mesh 的话，Ballerina 服务将嵌入相应的功能。&lt;/p&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;006y8mN6ly1g88cck2s8xj30u00wtgni.jpg&#34; alt=&#34;云原生编程语言ballerina生命周期架构图&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;云原生编程语言ballerina生命周期架构图&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用我们的语言服务器可以在 VS Code 和 IntelliJ 中获取自动补全和调试等智能感知。Ballerina 的关键字和语法结构可以用序列图的方式来表示。使用 Ballerina Composer 可以可视化的编辑 Ballerina 代码。另外它也可以做可视化得运行时和开发环境追踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 构建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将服务编译为经过优化的字节码，以便使用内存调优后的 BVM 运行。提供了使用Testerina 的项目结构、依赖管理、包管理和单元测试。构建锁可以轻松地重新创建服务和部署。生成可执行文件（.balx）或库（.balo）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署代码注解会触发构建扩展，从而为持续集成、持续交付或编排器环境生成工件。将构建工件推送到您的 CI/CD 系统或完全跳过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Registry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将端点连接器、自定义注解和代码功能作为可共享软件包组合在一起。可以在全球共享资源库——Ballerina Central 中 pull 或 push 版本化的软件包。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-的语言特性&#34;&gt;Ballerina 的语言特性&lt;/h2&gt;
&lt;p&gt;Ballerina 设计为云优先，内置对现代 Web 协议和数据格式的支持，完全支持图灵完备编程语言，以及对微服务架构的原生支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 构造&lt;/li&gt;
&lt;li&gt;逻辑语言&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;Json 和 XML&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;稳定和强大的类型&lt;/li&gt;
&lt;li&gt;stream&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ballerina-中集成了哪些内容&#34;&gt;Ballerina 中集成了哪些内容？&lt;/h2&gt;
&lt;p&gt;Ballerina 是一种旨在&lt;strong&gt;集成简化&lt;/strong&gt;的语言。基于顺序图的交互，Ballerina 内置了对通用集成模式和连接器的支持，包括分布式事务、补偿和断路器。凭借对 JSON 和 XML 的一流支持，Ballerina 能够简单有效地构建跨网络终端的强大集成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型安全端点集成&lt;/li&gt;
&lt;li&gt;类型安全连接器&lt;/li&gt;
&lt;li&gt;可靠的消息传递&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;断路器&lt;/li&gt;
&lt;li&gt;注入攻击防护&lt;/li&gt;
&lt;li&gt;Docker 和 Kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 Ballerina 中各个功能的示例代码请查阅 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-examples&#34;&gt;ballerina-example&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io&#34;&gt;Ballerina官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/microservices-docker-kubernetes-serverless-service&#34;&gt;Microservices, Docker, Kubernetes, Serverless, Service Mesh, and Beyond&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>CNCF - 云原生计算基金会简介</title>
      <link>https://jimmysong.io/blog/cncf-introduction/</link>
      <pubDate>Sun, 04 Mar 2018 18:03:39 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cncf-introduction/</guid>
      <description>
        
        
        &lt;p&gt;CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），口号是&lt;strong&gt;坚持和整合开源技术来编排容器作为微服务架构的一部分&lt;/strong&gt;，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。&lt;/p&gt;
&lt;p&gt;CNCF作为一个厂商中立的基金会，致力于Github上的快速成长的开源技术的推广，如Kubernetes、Prometheus、Envoy等，帮助开发人员更快更好的构建出色的产品。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://github.com/cncf/landscape&#34;&gt;http://github.com/cncf/landscape&lt;/a&gt; 中维护了一幅CNCF的全景图。&lt;/p&gt;
&lt;p&gt;其中包含了CNCF中托管的项目，还有很多是非CNCF项目，还有个交互式的浏览CNCF涵盖的所有的项目的页面：https://i.cncf.io&lt;/p&gt;
&lt;p&gt;关于CNCF的使命与组织方式请参考&lt;a href=&#34;https://www.cncf.io/about/charter/&#34;&gt;CNCF章程&lt;/a&gt;，概括的讲CNCF的使命宝库以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装。&lt;/li&gt;
&lt;li&gt;通过中心编排系统的动态资源管理。&lt;/li&gt;
&lt;li&gt;面向微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是CNCF最初对云原生特征的定义。&lt;/p&gt;
&lt;p&gt;CNCF这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。&lt;/p&gt;
&lt;p&gt;另外CNCF组织由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会员&lt;/strong&gt;：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理事会&lt;/strong&gt;：负责事务管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TOC（技术监督委员会）&lt;/strong&gt;：技术管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户社区&lt;/strong&gt;：推动CNCF技术的采纳并选举最终用户技术咨询委员会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户技术咨询委员会&lt;/strong&gt;：为最终用户会议或向理事会提供咨询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;营销委员会&lt;/strong&gt;：市场推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是我根据CNCF章程绘制的组织架构图。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcgy1ft5pe433f6j31kw0s3nnl.jpg&#34; alt=&#34;CNCF组织架构图&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;CNCF组织架构图&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;h2 id=&#34;cncf项目成熟度分级与毕业条件&#34;&gt;CNCF项目成熟度分级与毕业条件&lt;/h2&gt;
&lt;p&gt;每个CNCF项目都需要有个成熟度等级，申请成为CNCF项目的时候需要确定项目的成熟度级别。&lt;/p&gt;
&lt;p&gt;成熟度级别（Maturity Level）包括以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sandbox（初级）一开始是叫inception&lt;/li&gt;
&lt;li&gt;incubating（孵化中）&lt;/li&gt;
&lt;li&gt;graduated（毕业）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否可以成为CNCF项目需要通过Technical Oversight Committee （技术监督委员会）简称&lt;a href=&#34;https://github.com/cncf/toc&#34;&gt;TOC&lt;/a&gt;，投票采取fallback策略，即&lt;strong&gt;回退策略&lt;/strong&gt;，先从最高级别（graduated，目前是从incubating）开始，如果2/3多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到inception级别都没得到2/3多数投票通过的话，则拒绝其进入CNCF项目。一般一个项目处于孵化阶段不会超过2年。&lt;/p&gt;
&lt;p&gt;当前所有的CNCF项目可以访问 &lt;a href=&#34;https://www.cncf.io/projects/&#34;&gt;https://www.cncf.io/projects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在太平洋时间3月6日，Kubernetes成为了CNCF的第一个毕业项目！&lt;/p&gt;
&lt;h2 id=&#34;toc技术监督委员会&#34;&gt;TOC（技术监督委员会）&lt;/h2&gt;
&lt;p&gt;TOC（Technical Oversight Committee）作为CNCF中的一个重要组织，它的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义和维护技术视野&lt;/li&gt;
&lt;li&gt;审批新项目加入组织，为项目设定概念架构&lt;/li&gt;
&lt;li&gt;接受最终用户的反馈并映射到项目中&lt;/li&gt;
&lt;li&gt;调整组件见的访问接口，协调组件之间兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TOC成员通过选举产生，见&lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/election-schedule.md&#34;&gt;选举时间表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考CNCF TOC：https://github.com/cncf/toc&lt;/p&gt;
&lt;h2 id=&#34;cncf章程&#34;&gt;CNCF章程&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）是Linux基金会旗下的一个基金会，加入CNCF等于同时加入Linux基金会（也意味着你还要交Linux基金会的份子钱），对于想加入CNCF基金会的企业或者组织首先要做的事情就是要了解CNCF的章程（charter），就像是作为一个国家的公民，必须遵守该国家的宪法一样。CNCF之所以能在短短三年的时间内发展壮大到如此规模，很大程度上是与它出色的社区治理和运作模式有关。了解该章程可以帮助我们理解CNCF是如何运作的，也可以当我们自己进行开源项目治理时派上用场。&lt;/p&gt;
&lt;p&gt;该章程最后更新于2018年5月15日，详见&lt;a href=&#34;https://www.cncf.io/about/charter/&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;。下文中关于CNCF章程的介绍部分引用自&lt;a href=&#34;http://www.ocselected.org/posts/foundation_introduce/how_cncf_works/&#34;&gt;CNCF 是如何工作的&lt;/a&gt;，有改动。&lt;/p&gt;
&lt;h3 id=&#34;1-cncf的使命&#34;&gt;1. CNCF的使命&lt;/h3&gt;
&lt;p&gt;CNCF 没有偏离自己的主题，核心是解决技术问题：基金会的使命是创建并推动采用新的计算模式，该模式针对现代分布式系统环境进行了优化，能够扩展至数万个自愈式多租户节点。&lt;/p&gt;
&lt;p&gt;所谓的云原生系统须具备下面这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用容器化&lt;/strong&gt;：将软件容器中的应用程序和进程作为独立的应用程序部署单元运行，并作为实现高级别资源隔离的机制。从总体上改进开发者的体验、促进代码和组件重用，而且要为云元是国内应用简化运维工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态管理&lt;/strong&gt;：由中心化的编排来进行活跃的调度和频繁的管理，从根本上提高机器效率和资源利用率，同时降低与运维相关的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向微服务&lt;/strong&gt;：与显式描述的依赖性松散耦合（例如通过服务端点），可以提高应用程序的整体敏捷性和可维护性。CNCF 将塑造技术的发展，推动应用管理的先进技术发展，并通过可靠的接口使技术无处不在，并且易于使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-cncf扮演的角色&#34;&gt;2. CNCF扮演的角色&lt;/h3&gt;
&lt;p&gt;CNCF 其实是在开源社区的基础上发挥着作用，应负责：&lt;/p&gt;
&lt;p&gt;a) 项目管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保技术可用于社区并且没有杂七杂八的影响&lt;/li&gt;
&lt;li&gt;确保技术的品牌（商标和标识）得到社区成员的关注和使用，特别强调统一的用户体验和高水平的应用程序兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;b) 促进生态系统的发展和演进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;评估哪些技术可以纳入云原生计算应用的愿景，鼓励社区交付这样的技术，以及集成它们，且要积极的推进总结进度。&lt;/li&gt;
&lt;li&gt;提供一种方法来培养各个部分的通用技术标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;c) 推广底层技术和应用定义和管理方法，途径包括：活动和会议、营销（SEM、直接营销）、培训课程和开发人员认证。&lt;/p&gt;
&lt;p&gt;d) 通过使技术可访问和可靠来为社区服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旨在通过对参考架构进行明确定义的节奏，为每个组成部分提供完全集成和合格的构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-cncf的价值观&#34;&gt;3. CNCF的价值观&lt;/h3&gt;
&lt;p&gt;CNCF 会极力遵循以下一些原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;快速胜过磨叽&lt;/strong&gt;，基金会的初衷之一就是让项目快速的发展，从而支持用户能够积极的使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放！&lt;/strong&gt; CNCF 是以开放和高度透明为最高准则的，而且是独立于任何的其它团体进行运作的。CNCF根据贡献的内容和优点接受所有的贡献者，且遵循开源的价值观，CNCF输出的技术是可以让所有人使用和受益的，技术社区及其决策应保持高度透明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公平&lt;/strong&gt;：CNCF 会极力避免那些不好的影响、不良行为、以及“按需付费”的决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的技术身份&lt;/strong&gt;：CNCF 会实现并保持高度的自身技术认同，并将之同步到所有的共享项目中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清晰的边界&lt;/strong&gt;：CNCF 制定明确的目标，并在某些情况下，要确定什么不是基金会的目标，并会帮助整个生态系统的运转，让人们理解新创新的重点所在。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展&lt;/strong&gt;：能够支持从小型开发人员中心环境到企业和服务提供商规模的所有部署规模。这意味着在某些部署中可能不会部署某些可选组件，但总体设计和体系结构仍应适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平台中立&lt;/strong&gt;：CNCF 所开发的项目并不针对某个特定平台，而是旨在支持各种体系结构和操作系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-会员制&#34;&gt;4. 会员制&lt;/h3&gt;
&lt;p&gt;CNCF中的会员包括白金、金牌、银牌、最终用户、学术和非赢利成员等级别，不同级别的会员在理事会中的投票权不同。&lt;/p&gt;
&lt;p&gt;a) &lt;strong&gt;白金会员&lt;/strong&gt;：在CNCF理事会中任命1名代表，在理事会的每个次级委员会和活动中任命1名有投票权的代表，在网站可以突出显示；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;b) &lt;strong&gt;金牌会员&lt;/strong&gt;：基金会中每有5个金牌会员，该级别的会员就可以任命1名代表，最多任命3个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;c) &lt;strong&gt;银牌会员&lt;/strong&gt;：基金会中每有10个银牌会员，该级别的会员就可以任命1名代表，最多任命3个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;d) &lt;strong&gt;终端用户&lt;/strong&gt;：参加终端用户咨询社区；向终端用户技术咨询委员会中提名1名代表&lt;/p&gt;
&lt;p&gt;e) &lt;strong&gt;学术和非赢利会员&lt;/strong&gt;：学术和非营利会员分别限于学术和非营利机构，需要理事会批准。学术成员和非营利成员有权将其组织认定为支持CNCF使命的成员以及理事会确定的任何其他权利或利益。&lt;/p&gt;
&lt;h3 id=&#34;5-理事会&#34;&gt;5. 理事会&lt;/h3&gt;
&lt;p&gt;a) CNCF理事会负责市场营销、业务监督和预算审批，不负责技术方面，除了与TOC配合确定CNCF工作范围、完成时间表a)、更新CNCF网站&lt;/p&gt;
&lt;p&gt;b) 负责日常事务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与TOC协商CNCF的整体范围&lt;/li&gt;
&lt;li&gt;商标和版权保护&lt;/li&gt;
&lt;li&gt;市场营销、布道和生态系统建设&lt;/li&gt;
&lt;li&gt;创建和执行品牌承诺项目，如果需要的话&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;募资和财务管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;c) 理事会投票成员由会员代表和社区代表组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员代表包括：
&lt;ul&gt;
&lt;li&gt;每名白金会员任命1名代表&lt;/li&gt;
&lt;li&gt;黄金和银牌成员当选代表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术社区代表包括：
&lt;ul&gt;
&lt;li&gt;技术监督委员会主席&lt;/li&gt;
&lt;li&gt;根据当时在任的理事会批准的程序从CNCF项目中选出两名提交者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理事会可能会以白金会员比例的价格扩展白金会员资格，对年收入低于5000万美元的创业公司进行长达5年的逐年审计，这些公司被视为理事会的战略技术贡献者。&lt;/li&gt;
&lt;li&gt;只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任会员代表。只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任技术社区代表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;d) 职责&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;批准预算，指导将所有收入来源筹集的资金用于技术、市场或社区投资，以推动 CNCF 基金的使命；&lt;/li&gt;
&lt;li&gt;选举理事会主席主持会议，批准预算批准的支出并管理日常运作；&lt;/li&gt;
&lt;li&gt;对理事会的决定或事项进行投票；&lt;/li&gt;
&lt;li&gt;界定和执行基金会的知识产权（版权，专利或商标）政策；&lt;/li&gt;
&lt;li&gt;通过活动、新闻和分析师宣传、网络、社交媒体以及其他营销活动进行直接营销和布道；&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;建立并监督为推动CNCF的使命而创建的任何委员会；&lt;/li&gt;
&lt;li&gt;根据CNCF要求（可能包括认证测试）建立并执行品牌合规计划（如有），以使用TOC建立的品牌标志；&lt;/li&gt;
&lt;li&gt;采用商标使用准则或政策；&lt;/li&gt;
&lt;li&gt;提供整体财务管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;e) 基金会的收入用途&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;市场营销，用户扩展CNCF中的项目的采用&lt;/li&gt;
&lt;li&gt;关键设施建设、运行和管理项目的基础设施&lt;/li&gt;
&lt;li&gt;促进基于容器的计算使用CNCF中的项目实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-技术监督委员会toc&#34;&gt;6. 技术监督委员会（TOC）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) 要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNCF 技术监督委员会，为了保持中立，则达成了以下共识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义和维护CNCF的技术愿景。&lt;/li&gt;
&lt;li&gt;批准由理事会制定的CNCF范围内的新项目，并为项目创建一个概念架构。&lt;/li&gt;
&lt;li&gt;纠正项目的发展方向，决策删除或存档项目。&lt;/li&gt;
&lt;li&gt;接受最终用户委员会的反馈并反映在项目中。&lt;/li&gt;
&lt;li&gt;在科学管理的情况下调整组件的接口（在代码标准化之前实现参考）&lt;/li&gt;
&lt;li&gt;定义在CNCF项目中实施的常用做法（如果有的话）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;b) 技术监督委员会的构成&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC最多由9名成员组成。&lt;/li&gt;
&lt;li&gt;选出的TOC成员将涵盖关键的技术领域：容器技术、操作系统、技术运维、分布式系统、用户级应用程序设计等。&lt;/li&gt;
&lt;li&gt;理事会将选举6名TOC成员，最终用户TAB将选出1名TOC成员，最初的7名TOC成员应另选两名TOC成员。&lt;/li&gt;
&lt;li&gt;如果超过两名TOC成员来自同一组关联公司，无论是在选举时还是来自后来的工作变更，他们将共同决定谁应该下台，或如果没有协商的依据，则应抽签决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;c) 运营模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 会选举出TOC的主席来，此角色主要负责 TOC 的议程和召集会议。&lt;/li&gt;
&lt;li&gt;TOC 每个季度会面对面讨论重要的热点问题。&lt;/li&gt;
&lt;li&gt;TOC 可能会根据需要开会讨论新出现的问题。 TOC审核可能会提出以下问题：
&lt;ul&gt;
&lt;li&gt;任何的 TOC 成员&lt;/li&gt;
&lt;li&gt;任何的理事会成员&lt;/li&gt;
&lt;li&gt;建立的CNCF项目的维护者或顶级项目负责人&lt;/li&gt;
&lt;li&gt;CNCF 执行董事&lt;/li&gt;
&lt;li&gt;最终用户技术咨询委员会获得多数票&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持透明：TOC会议、邮件列表、以及会议记录等均是公开可访问的。&lt;/li&gt;
&lt;li&gt;简单的TOC问题可以通过简短的讨论和简单的多数表决来解决。TOC讨论可通过电子邮件或TOC会议进行。&lt;/li&gt;
&lt;li&gt;在对意见和可选虚拟讨论/辩论选项进行审查后，寻求共识并在必要时进行投票。&lt;/li&gt;
&lt;li&gt;目的是让TOC在TOC和社区内寻找达成共识的途径。满足法定人数要求的会议的TOC决定应以超过TOC成员出席率的50％的方式通过。&lt;/li&gt;
&lt;li&gt;TOC会议需要TOC总人数的三分之二法定人数进行表决或作出任何决定。如果TOC会议未能达到法定人数要求，可以进行讨论，但不应有任何投票或决定。&lt;/li&gt;
&lt;li&gt;TOC决定可以在没有会议的情况下以电子方式提出，但要通过表决则需要多少票数才能达到会议法定人数。在电子投票中，如果任何两名TOC成员要求召开会议讨论决定，则电子投票结束时无效，并且在会议结束后可以启动新的投票，以讨论决定已经完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;d) 提名标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得 TOC 提名的开源贡献者应该具备下面条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;承诺有足够的可用可用时间参与CNCF TOC的活动，包括在CNCF成立时相当早期的投入，然后需持续投入时间，而且在季度的 TOC 会议之前要进行充分的准备和审查事宜。&lt;/li&gt;
&lt;li&gt;在CNCF范围内展示了高水准的专业经验。&lt;/li&gt;
&lt;li&gt;证明其有资格能够获得额外的工作人员或社区成员协助其在 TOC 的工作。&lt;/li&gt;
&lt;li&gt;在讨论中保持中立，并提出CNCF的目标和成功与公司目标或CNCF中的任何特定项目保持平衡。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;e) TOC成员提名和选举程序&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC由9位TOC成员组成：由理事会选出的6位，由最终用户TAB选出的1位和由最初的7位TOC成员选出的2位。&lt;/li&gt;
&lt;li&gt;提名：每个有资格提名TOC成员的个人（实体或成员）可以提名至多2名技术代表（来自供应商、最终用户或任何其他领域），其中至多一个可能来自其各自公司。被提名者必须提前同意加入到候选人名单中。
&lt;ul&gt;
&lt;li&gt;最初的7名TOC成员（理事会选出的6名成员加上由最终用户TAB选出的1名成员）应使用提名程序提名并选举2名TOC成员。&lt;/li&gt;
&lt;li&gt;提名者需要提供最多一页纸的介绍，其中包括被提名者的姓名，联系信息和支持性陈述，确定了在CNCF领域提名的经验。&lt;/li&gt;
&lt;li&gt;理事会、最终用户TAB和TOC应确定提名、投票和关于TOC选举提名和选举过程的任何其他细节的时间表和日期。&lt;/li&gt;
&lt;li&gt;评估期间最少保留14个日历日，TOC 提名者可以联系和/或评估候选人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举：评估期结束后，理事会、最终用户标签和最初的7位TOC成员应分别对每位被候选人进行表决。有效投票需要满足会议法定人数所需的选票数量。每名被候选人均需要支持超过50％的投票人数，以确认被提名者符合资格标准。以多数票通过的候选人应为合格的 TOC 成员。&lt;/li&gt;
&lt;li&gt;如果合格的被提名者的人数等于或少于可选 TOC 席位的数量，则此被提名者应在提名期结束后获得批准。如果有更多的合格被候选人比理事会，最终用户TAB或TOC可选的开放TOC席位多，那么该组应通过Condorcet投票选出TOC成员。Condorcet投票应通过康奈尔在线服务（http://civs.cs.cornell.edu/）使用Condorcet-IRV方法运行。&lt;/li&gt;
&lt;li&gt;如果理事会，最终用户TAB或TOC可供选举的公开TOC席位的合格被候选人数较少，该小组将启动另一轮提名，每名成员或个人有资格提名至多提名1名候选人。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;f) 约束条件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 的成员任期为两年，来自理事会选举的最初六名当选TOC成员的任期为3年。由最终用户TAB和TOC选出的TOC成员的初始任期为2年。&lt;/li&gt;
&lt;li&gt;TOC成员可能会被其他TOC成员的三分之二投票撤除，受影响的个人不能参加投票。&lt;/li&gt;
&lt;li&gt;任何TOC成员连续3次连续会议都将被自动暂停投票资格，直至连续参加两次会议。为避免疑义，暂停的TOC成员有资格在连续第二次会议中投票。&lt;/li&gt;
&lt;li&gt;TOC章程、模式、方法、组成等可以由整个理事会的三分之二票通过修改。&lt;/li&gt;
&lt;li&gt;TOC议程将由TOC制定。但是，预计最初的TOC讨论和决定将包括：
&lt;ul&gt;
&lt;li&gt;评估包含在CNCF中的技术&lt;/li&gt;
&lt;li&gt;确定新技术纳入CNCF的接受标准&lt;/li&gt;
&lt;li&gt;定义批准作为标准API的贡献技术的流程&lt;/li&gt;
&lt;li&gt;找出需要进一步调查的直接差距&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-最终用户社区&#34;&gt;7. 最终用户社区&lt;/h3&gt;
&lt;p&gt;a) CNCF的最终用户成员有权协调和推动CNCF用户作为CNCF设计的消费者的重要活动。任何作为最终用户的成员或非成员，每个“最终用户参与者”均可被邀请参加。最终用户参与者将帮助向技术咨询委员会和CNCF社区就与用户有关的主题提供意见。&lt;/p&gt;
&lt;p&gt;b) 	最终用户技术咨询委员会是由最终用户社区成员选举所产生。&lt;/p&gt;
&lt;p&gt;c) 最终用户社区成员将获得CNCF执行董事的批准，或者 CNCF 执行董事缺席的话，则由 Linux 基金会执行董事来批准。&lt;/p&gt;
&lt;h3 id=&#34;8-最终用户技术咨询委员会最终用户-tab&#34;&gt;8. 最终用户技术咨询委员会（“最终用户 TAB”）&lt;/h3&gt;
&lt;p&gt;a) 构成：最终用户TAB应由来自最终用户参与者的7名代表加上TOC的1名成员组成，以便于从最终用户TAB到TOC的晋级。&lt;/p&gt;
&lt;p&gt;b) 选举：为了鼓励最终用户参与CNCF，前7名最终用户会员可以委任1名代表参加初始最终用户TAB，并将CNCF董事分配给任何最终用户参与者的任何剩余席位。在第一年之后，所有最终用户参与者可以提名1名代表并且最终用户社区应该投票选择使用当前最终用户 TAB 批准流程的最终用户TAB成员。&lt;/p&gt;
&lt;p&gt;c) 经过三分之二投票通过后最终用户 TAB 可以更改最终用户社区的大小，前提是至少有7名可能的代表。&lt;/p&gt;
&lt;p&gt;d) 最终用户代表应当基于业务和技术敏锐度提名。候选人应该具备建设和运营体现CNCF原则的基础设施和应用方面的重要实践经验。&lt;/p&gt;
&lt;p&gt;e) 最终用户 TAB 将讨论和推进主题，重点是找出TOC和CNCF开发者社区的差距并提出优先事项。&lt;/p&gt;
&lt;p&gt;f) 也会侧重于主动推进最终用户关心的话题，促进CNCF的市场采用，为最终用户举办会议或向理事会提供咨询。&lt;/p&gt;
&lt;p&gt;g) 如果最终用户 TAB 有意愿的话，它可以批准小组委员会特别兴趣小组 （“SIG”）来解决行业或专业话题。&lt;/p&gt;
&lt;p&gt;h) 最终用户 TAB 是技术监督委员会的主要输入方，应与技术监督委员会的其他输入方和反馈一起作出决策和计划。这些建议只是建议性的，在任何时候，最终用户TAB的建议都不能用于命令或指导任何TOC或项目参与者采取任何行动或结果。&lt;/p&gt;
&lt;p&gt;i) 为促进与TOC的双边互动，最终用户技术咨询委员会应选出1名TOC代表。最终用户 TAB 可邀请任何人参加最终用户会议、SIG或其他讨论。&lt;/p&gt;
&lt;h3 id=&#34;9-cncf项目&#34;&gt;9. CNCF项目&lt;/h3&gt;
&lt;p&gt;通常情况下，是由CNCF的成员公司、开源社区的成员将项目先是带到CNCF 的技术监督委员会来进行讨论，然后决定是否被CNCF接纳。要贡献给CNCF的项目必须是经过技术监督委员会制定的标准的，之后当然还要经过理事会的批准。CNCF 的目标是希望捐赠给CNCF的项目和CNCF已有的项目在一定程度上是有关联的，而且是可集成的。&lt;/p&gt;
&lt;p&gt;和CNCF 关联起来有以下三种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 已经在CNCF的纳管之下，毕竟CNCF是中立的，致力于成为大家的协作的归属地。&lt;/p&gt;
&lt;p&gt;a) 项目的方方面面都交由CNCF来打理
b) 项目是由CNCF 来进行市场推广的
c) 项目是解决云原生计算问题的核心组件，如Kubernetes、Mesos、etcd等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 通过API或规范与CNCF相关联XM&lt;/p&gt;
&lt;p&gt;a) 包括CNCF可能提供或启用多个选项的组件
b) 该项目被称为CNCF集成的一个组成部分，而不是由CNCF主办的项目
c) 集成和合规性由API或规范定义
d) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; CNCF 使用到的&lt;/p&gt;
&lt;p&gt;a) 项目或组件完全根据OSI批准的开源许可证进行授权，并且管理良好，并在CNCF中被用作组件。&lt;/p&gt;
&lt;p&gt;b) 项目并没有由CNCF 来进行市场推广&lt;/p&gt;
&lt;p&gt;c) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;现有的开源项目应该继续保持其现有的技术治理结构，以保持凝聚力和速度。但是由技术监督委员会批准之后，则会适当的进行一些适应。&lt;/p&gt;
&lt;p&gt;应根据个人的水平和贡献期限在项目间建立一个达到提交者地位的标准协议。因为提交者是维护者的选拔人才池，有了一定程度的贡献，且经过同行们的认可，提交者就可晋升为维护者。&lt;/p&gt;
&lt;p&gt;CNCF启动的新开源项目应完成TOC采纳的项目建议模板，并由TOC批准纳入CNCF。TOC成员应有充足的时间讨论和审查新的项目建议书。新的项目建议书应包括项目中的角色细节，为项目提出的治理，并确定与CNCF的角色和价值观保持一致。&lt;/p&gt;
&lt;h3 id=&#34;10-市场委员会&#34;&gt;10. 市场委员会&lt;/h3&gt;
&lt;p&gt;a) 构成，市场委员会将向所有成员开放参与，应选举市场委员会主席制定会议议程，进行一般的讨论，并帮助委员会实现其目标。市场委员会应尽可能寻求共识。在市场委员会中无法达成共识的任何问题应提交给理事会。&lt;/p&gt;
&lt;p&gt;b) 职责，市场委员会代表理事会负责设计，开发和执行相关的市场工作。&lt;/p&gt;
&lt;p&gt;c) 如果市场委员会变得太大而无法有效运作，市场委员会可以选择选举市场董事，并将决策权委托给市场董事。&lt;/p&gt;
&lt;h3 id=&#34;11-知识产权政策&#34;&gt;11. 知识产权政策&lt;/h3&gt;
&lt;p&gt;a) 任何加入到CNCF的项目都必须将其拥有的商标和徽标资产转让给Linux基金会的所有权。&lt;/p&gt;
&lt;p&gt;b) 每个项目应确定是否需要使用经批准的CNCF CLA。对于选择使用CLA的项目，所有代码贡献者将承担Apache贡献者许可协议中规定的义务，只有在必要时才作出修改，以确定CNCF是捐赠的接受者，并且应由理事会批准。请参阅 &lt;a href=&#34;https://github.com/cncf/cla&#34;&gt;https://github.com/cncf/cla&lt;/a&gt; 上提供的CNCF参与者许可协议。&lt;/p&gt;
&lt;p&gt;c) 所有向CNCF提交的新入站代码应当（i）附有开发者原始证书签名（&lt;a href=&#34;http://developercertificate.org&#34;&gt;http://developercertificate.org&lt;/a&gt;和（ii）根据Apache许可证2.0版（可从&lt;a href=&#34;http://developercertificate.org&#34;&gt;http://developercertificate.org&lt;/a&gt;和&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt; 获得）该许可证除了并且不得取代根据上文（b）规定的供款许可协议所承担的义务。&lt;/p&gt;
&lt;p&gt;d) 所有出站代码将在Apache许可证2.0版下提供。&lt;/p&gt;
&lt;p&gt;e) 所有评估纳入CNCF的项目都必须获得OSI批准的开源许可证的完全许可，如果CNCF中包含的项目的许可证不是Apache许可证2.0版，则需要获得理事会的批准。&lt;/p&gt;
&lt;p&gt;f) 所有文档将由CNCF根据知识共享署名4.0国际许可证来提供。&lt;/p&gt;
&lt;p&gt;g) 如果需要替代入站或出站许可证以符合杠杆式开放源代码项目的许可证或为实现CNCF的使命而需要其他许可证，理事会可以批准使用替代许可证 对于例外情况下的接受或提供的项目捐赠。&lt;/p&gt;
&lt;h3 id=&#34;12-反托拉斯指南&#34;&gt;12. 反托拉斯指南&lt;/h3&gt;
&lt;p&gt;a) 所有成员均应遵守&lt;a href=&#34;http://www.linuxfoundation.org/antitrust-policy&#34;&gt;http://www.linuxfoundation.org/antitrust-policy&lt;/a&gt;上提供的Linux基金会反托拉斯政策中规定的Linux基金会的要求。&lt;/p&gt;
&lt;p&gt;b) 所有成员都应鼓励任何能够满足成员要求的组织的公开参与，而不论其竞争利益如何。换言之，理事会不应根据除用于所有成员的标准，要求或原因之外的任何标准，要求或理由寻求排除成员。&lt;/p&gt;
&lt;h3 id=&#34;13-行为准则&#34;&gt;13. 行为准则&lt;/h3&gt;
&lt;p&gt;所有参与者都须同意遵守 &lt;a href=&#34;http://events.linuxfoundation.org/code-of-conduct&#34;&gt;Linux基金会行为准则&lt;/a&gt;。 TSC可以投票通过自己的CNCF行为准则。&lt;/p&gt;
&lt;h3 id=&#34;14-关联公司&#34;&gt;14. 关联公司&lt;/h3&gt;
&lt;p&gt;a) 定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“子公司”是指会员直接或间接拥有所涉实体超过百分之五十有投票权的证券或会员权益的任何实体；&lt;/li&gt;
&lt;li&gt;“关联公司”是指任何控制或由成员控制的实体，或者与成员一起受第三方共同控制的实体，在所有情况下，直接或间接拥有多于所有权的控制权；&lt;/li&gt;
&lt;li&gt;“关联公司”是指各成员的关联公司。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b) 只有执行了参与协议的法人实体及其子公司才有权享有该会员的权利和特权；但条件是该成员及其子公司应作为单一成员共同对待。&lt;/p&gt;
&lt;p&gt;c) 只有一名属于一组关联公司的成员有权一次性任命或提名理事会代表参加类别选举。&lt;/p&gt;
&lt;p&gt;d) 如果会员本身是会员或赞助商的基金会，联盟，开源项目，会员组织，用户组或其他实体，那么授予该成员的权利和特权只能扩展到该成员的员工代表，而不能扩展到其成员或发起人，除非理事会不时在特定情况下另行批准。&lt;/p&gt;
&lt;p&gt;e) 会员资格不得转让，不可转让、也不能转让，除非现有会员将其现有的会员利益和义务转让给其大部分业务和/或资产的继任者，无论是通过合并，出售还是其他方式；只要受让人同意遵守 CNCF 的章程以及Linux Foundation成员所需的章程和政策。&lt;/p&gt;
&lt;h3 id=&#34;15-预算&#34;&gt;15. 预算&lt;/h3&gt;
&lt;p&gt;a) 理事会应批准年度预算，绝不会承诺超出筹集的资金。预算应与Linux基金会的非营利性使命相一致。&lt;/p&gt;
&lt;p&gt;b) Linux基金会应定期报告预算支出。&lt;/p&gt;
&lt;h3 id=&#34;16-常规和管理费用&#34;&gt;16. 常规和管理费用&lt;/h3&gt;
&lt;p&gt;a) Linux基金会应保管任何费用，资金和其他现金收据。&lt;/p&gt;
&lt;p&gt;b) 一般和行政（G＆A）费用将用于筹集资金以支付财务、会计和运营费用。 G＆A费用应等于CNCF首期总收入1,000,000美元的9％以及CNCF总收入超过1,000,000美元的6％。&lt;/p&gt;
&lt;h3 id=&#34;17-一般规则和操作&#34;&gt;17. 一般规则和操作&lt;/h3&gt;
&lt;p&gt;参与CNCF 应做到：&lt;/p&gt;
&lt;p&gt;a) 展示与开源项目开发人员社区进行协调的计划和方法，包括关于代表社区的品牌、徽标和其它标志性的主题；&lt;/p&gt;
&lt;p&gt;b) 以专业的方式体现维持社区的凝聚力为目标，同时还要保持Linux基金会在开放源代码软件社区的善意和尊重；&lt;/p&gt;
&lt;p&gt;c) 尊重所有商标所有人的权利，包括任何品牌和使用准则；&lt;/p&gt;
&lt;p&gt;d) 参与Linux基金会的所有新闻和分析师关系活动；&lt;/p&gt;
&lt;p&gt;e) 根据要求，向Linux基金会提供关于项目参与的信息，包括参加项目赞助活动的信息；&lt;/p&gt;
&lt;p&gt;f) 直接参与到基金会旗下的任何站点。&lt;/p&gt;
&lt;p&gt;g) 根据理事会批准的规则和程序进行运营，前提是这些规则和程序不得与Linux基金会的宗旨和政策不一致，并且不得损害Linux基金会。&lt;/p&gt;
&lt;h3 id=&#34;18-修正案&#34;&gt;18. 修正案&lt;/h3&gt;
&lt;p&gt;本章程可以通过所有理事会成员的三分之二票数（不包括弃权）进行修改，前提是任何此类修改不得与Linux基金会的目的或政策不一致，并且不得对Linux基金会产生不利影响。&lt;/p&gt;
&lt;h3 id=&#34;时间表a提出cncf范围愿景&#34;&gt;时间表A：提出CNCF范围愿景&lt;/h3&gt;
&lt;p&gt;CNCF背后的首要目标是支持和加速“云原生计算”的采用。以下内容是初步范围，旨在阐明CNCF将努力实施的“云原生计算”的核心概念。该初始范围应成为发布在CNCF网站上的文档。&lt;/p&gt;
&lt;p&gt;CNCF社区坚信云原生计算包含三个核心属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装和分发&lt;/li&gt;
&lt;li&gt;动态调度&lt;/li&gt;
&lt;li&gt;面向微服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：关于云原生的定义正在重新设定中，已经与上述不同了。&lt;/p&gt;
&lt;p&gt;云原生计算系统支持基于这些核心属性的计算，并包含以下理想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放性和可扩展性&lt;/li&gt;
&lt;li&gt;在标准化子系统的边界处定义良好的API&lt;/li&gt;
&lt;li&gt;应用程序生命周期管理的最小障碍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为上述时间表已经有些过时了，CNCF成立已经有三年时间了，正在规划新的方案。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/&#34;&gt;https://www.cncf.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/landscape&#34;&gt;https://github.com/cncf/landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/toc&#34;&gt;https://github.com/cncf/toc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ocselected.org/posts/foundation_introduce/how_cncf_works/&#34;&gt;CNCF 是如何工作的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>云原生应用之路</title>
      <link>https://jimmysong.io/blog/from-kubernetes-to-cloud-native/</link>
      <pubDate>Wed, 20 Dec 2017 15:08:02 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/from-kubernetes-to-cloud-native/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;从Kubernetes到Cloud Native——云原生应用之路&lt;/strong&gt;，这是我最近在 &lt;a href=&#34;http://bj2017.archsummit.com/presentation/306&#34;&gt;ArchSummit2017北京站&lt;/a&gt; 和 &lt;a href=&#34;https://www.kubernetes.org.cn/3211.html&#34;&gt;数人云&amp;amp;TalkingData合办的Service Mesh is comming meetup&lt;/a&gt; 中分享的话题。&lt;/p&gt;
&lt;p&gt;本文简要介绍了容器技术发展的路径，为何Kubernetes的出现是容器技术发展到这一步的必然选择，而为何Kuberentes又将成为云原生应用的基石。&lt;/p&gt;
&lt;p&gt;我的分享按照这样的主线展开：容器-&amp;gt;Kubernetes-&amp;gt;微服务-&amp;gt;Cloud Native（云原生）-&amp;gt;Service Mesh（服务网格）-&amp;gt;使用场景-&amp;gt;Open Source（开源）。&lt;/p&gt;
&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;容器——Cloud Native的基石&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器最初是通过开发者工具而流行，可以使用它来做隔离的开发测试环境和持续集成环境，这些都是因为容器轻量级，易于配置和使用带来的优势，docker和docker-compose这样的工具极大的方便的了应用开发环境的搭建，开发者就像是化学家一样在其中小心翼翼的进行各种调试和开发。&lt;/p&gt;
&lt;p&gt;随着容器的在开发者中的普及，已经大家对CI流程的熟悉，容器周边的各种工具蓬勃发展，俨然形成了一个小生态，在2016年达到顶峰，下面这张是我画的容器生态图：&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/container-ecosystem.png&#34; alt=&#34;容器生态图 Container ecosystem&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;容器生态图 Container ecosystem&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;该生态涵盖了容器应用中从镜像仓库、服务编排、安全管理、持续集成与发布、存储和网络管理等各个方面，随着在单主机中运行容器的成熟，集群管理和容器编排成为容器技术亟待解决的问题。譬如化学家在实验室中研究出来的新产品，如何推向市场，进行大规模生产，成了新的议题。&lt;/p&gt;
&lt;h2 id=&#34;为什么使用kubernetes&#34;&gt;为什么使用Kubernetes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes——让容器应用进入大规模工业生产。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes是容器编排系统的事实标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在单机上运行容器，无法发挥它的最大效能，只有形成集群，才能最大程度发挥容器的良好隔离、资源分配与编排管理的优势，而对于容器的编排管理，Swarm、Mesos和Kubernetes的大战已经基本宣告结束，kubernetes成为了无可争议的赢家。&lt;/p&gt;
&lt;p&gt;下面这张图是Kubernetes的架构图（图片来自网络），其中显示了组件之间交互的接口CNI、CRI、OCI等，这些将Kubernetes与某款具体产品解耦，给用户最大的定制程度，使得Kubernetes有机会成为跨云的真正的云原生应用的操作系统。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/kubernetes-high-level-component-archtecture.jpg&#34; alt=&#34;Kuberentes架构&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kuberentes架构&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;随着Kubernetes的日趋成熟，“Kubernetes is becoming boring”，基于该“操作系统”之上构建的适用于不同场景的应用将成为新的发展方向，就像我们将石油开采出来后，提炼出汽油、柴油、沥青等等，所有的材料都将找到自己的用途，Kubernetes也是，毕竟我们谁也不是为了部署和管理容器而用Kubernetes，承载其上的应用才是价值之所在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生的核心目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/cloud-native-core-target.jpg&#34; alt=&#34;Cloud Native Core target&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Cloud Native Core target&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;云已经可以为我们提供稳定可以唾手可得的基础设施，但是业务上云成了一个难题，Kubernetes的出现与其说是从最初的容器编排解决方案，倒不如说是为了解决应用上云（即云原生应用）这个难题。&lt;/p&gt;
&lt;p&gt;包括微服务和FaaS/Serverless架构，都可以作为云原生应用的架构。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/redpoint-faas-landscape.jpg&#34; alt=&#34;FaaS Landscape&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;FaaS Landscape&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;但就2017年为止，kubernetes的主要使用场景也主要作为应用开发测试环境、CI/CD和运行Web应用这几个领域，如下图&lt;a href=&#34;http://thenewstack.io&#34;&gt;TheNewStack&lt;/a&gt;的Kubernetes生态状况调查报告所示。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/0069RVTdgy1fv5mxr6fxtj31kw11q484.jpg&#34; alt=&#34;Workloads running on Kubernetes&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Workloads running on Kubernetes&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;另外基于Kubernetes的构建PaaS平台和Serverless也处于爆发的准备的阶段，如下图中Gartner的报告中所示：&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/0069RVTdgy1fv5my2jtxzj315o0z8dkr.jpg&#34; alt=&#34;Gartner技术爆发趋势图2017&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Gartner技术爆发趋势图2017&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;当前各大公有云如Google GKE、微软Azure ACS、亚马逊EKS（2018年上线）、VmWare、Pivotal、腾讯云、阿里云等都提供了Kuberentes服务。&lt;/p&gt;
&lt;h2 id=&#34;微服务&#34;&gt;微服务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务——Cloud Native的应用架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图是&lt;a href=&#34;https://developers.redhat.com/blog/author/bibryam/&#34;&gt;Bilgin Ibryam&lt;/a&gt;给出的微服务中应该关心的主题，图片来自&lt;a href=&#34;https://developers.redhat.com/blog/2016/12/09/spring-cloud-for-microservices-compared-to-kubernetes/&#34;&gt;RedHat Developers&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/microservices-concerns.jpg&#34; alt=&#34;Microservices concerns&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Microservices concerns&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;微服务带给我们很多开发和部署上的灵活性和技术多样性，但是也增加了服务调用的开销、分布式系统管理、调试与服务治理方面的难题。&lt;/p&gt;
&lt;p&gt;当前最成熟最完整的微服务框架可以说非&lt;a href=&#34;https://spring.io/&#34;&gt;Spring&lt;/a&gt;莫属，而Spring又仅限于Java语言开发，其架构本身又跟Kubernetes存在很多重合的部分，如何探索将Kubernetes作为微服务架构平台就成为一个热点话题。&lt;/p&gt;
&lt;p&gt;就拿微服务中最基础的&lt;strong&gt;服务注册发现&lt;/strong&gt;功能来说，其方式分为&lt;strong&gt;客户端服务发现&lt;/strong&gt;和&lt;strong&gt;服务端服务发现&lt;/strong&gt;两种，Java应用中常用的方式是使用Eureka和Ribbon做服务注册发现和负载均衡，这属于客户端服务发现，而在Kubernetes中则可以使用DNS、Service和Ingress来实现，不需要修改应用代码，直接从网络层面来实现。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/service-discovery-in-microservices.png&#34; alt=&#34;两种服务发现方式&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;两种服务发现方式&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;h2 id=&#34;cloud-native&#34;&gt;Cloud Native&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps——通向云原生的云梯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CNCF（云原生计算基金会）给出了云原生应用的三大特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器化包装&lt;/strong&gt;：软件应用的进程应该包装在容器中独立运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态管理&lt;/strong&gt;：通过集中式的编排调度系统来动态的管理和调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微服务化&lt;/strong&gt;：明确服务间的依赖，互相解耦。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是我整理的关于云原生所需要的能力和特征。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/cloud-native-architecutre-mindnode.jpg&#34; alt=&#34;Cloud Native Features&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Cloud Native Features&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cncf.io&#34;&gt;CNCF&lt;/a&gt;所托管的应用（目前已达12个），即朝着这个目标发展，其公布的&lt;a href=&#34;https://github.com/cncf/landscape&#34;&gt;Cloud Native Landscape&lt;/a&gt;，给出了云原生生态的参考体系。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/0069RVTdgy1fv5myp6ednj31kw0w0u0x.jpg&#34; alt=&#34;Cloud Native Landscape v1.0&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Cloud Native Landscape v1.0&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Kubernetes构建云原生应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都是知道Heroku推出了适用于PaaS的&lt;a href=&#34;https://12factor.net/&#34;&gt;12 factor app&lt;/a&gt;的规范，包括如下要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基准代码&lt;/li&gt;
&lt;li&gt;依赖管理&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;li&gt;后端服务&lt;/li&gt;
&lt;li&gt;构建，发布，运行&lt;/li&gt;
&lt;li&gt;无状态进程&lt;/li&gt;
&lt;li&gt;端口绑定&lt;/li&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;li&gt;易处理&lt;/li&gt;
&lt;li&gt;开发环境与线上环境等价&lt;/li&gt;
&lt;li&gt;日志作为事件流&lt;/li&gt;
&lt;li&gt;管理进程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外还有补充的三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API声明管理&lt;/li&gt;
&lt;li&gt;认证和授权&lt;/li&gt;
&lt;li&gt;监控与告警&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果落实的具体的工具，请看下图，使用Kubernetes构建云原生架构：&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/building-cloud-native-architecture-with-kubernetes.png&#34; alt=&#34;Building a Cloud Native Architecture with Kubernetes followed 12 factor app&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Building a Cloud Native Architecture with Kubernetes followed 12 factor app&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;结合这12因素对开发或者改造后的应用适合部署到Kubernetes之上，基本流程如下图所示：&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/creating-kubernetes-native-app.jpg&#34; alt=&#34;Creating Kubernetes native app&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Creating Kubernetes native app&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迁移到云架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迁移到云端架构，相对单体架构来说会带来很多挑战。比如自动的持续集成与发布、服务监控的变革、服务暴露、权限的管控等。这些具体细节请参考&lt;strong&gt;Kubernetes-handbook&lt;/strong&gt;中的说明：&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34;&gt;https://jimmysong.io/kubernetes-handbook&lt;/a&gt;，在此就不细节展开，另外推荐一本我翻译的由Pivotal出品的电子书——&lt;a href=&#34;https://content.pivotal.io/ebooks/migrating-to-cloud-native-application-architectures&#34;&gt;Migrating to Cloud Native Application Architectures&lt;/a&gt;，地址：&lt;a href=&#34;https://jimmysong.io/migrating-to-cloud-native-application-architectures/&#34;&gt;https://jimmysong.io/migrating-to-cloud-native-application-architectures/&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh&#34;&gt;Service Mesh&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Services for show, meshes for a pro.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kubernetes中的应用将作为微服务运行，但是Kuberentes本身并没有给出微服务治理的解决方案，比如服务的限流、熔断、良好的灰度发布支持等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service mesh可以用来做什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Management：API网关&lt;/li&gt;
&lt;li&gt;Observability：服务调用和性能分析&lt;/li&gt;
&lt;li&gt;Policy Enforcement：控制服务访问策略&lt;/li&gt;
&lt;li&gt;Service Identity and Security：安全保护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Service mesh的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;专用的基础设施层&lt;/li&gt;
&lt;li&gt;轻量级高性能网络代理&lt;/li&gt;
&lt;li&gt;提供安全的、快速的、可靠地服务间通讯&lt;/li&gt;
&lt;li&gt;扩展kubernetes的应用负载均衡机制，实现灰度发布&lt;/li&gt;
&lt;li&gt;完全解耦于应用，应用可以无感知，加速应用的微服务和云原生转型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用Service Mesh将可以有效的治理Kuberentes中运行的服务，当前开源的Service Mesh有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linkderd：&lt;a href=&#34;https://linkerd.io&#34;&gt;https://linkerd.io&lt;/a&gt;，由最早提出Service Mesh的公司&lt;a href=&#34;https://buoyant.io&#34;&gt;Buoyant&lt;/a&gt;开源，创始人来自Twitter&lt;/li&gt;
&lt;li&gt;Envoy：&lt;a href=&#34;https://www.envoyproxy.io/&#34;&gt;https://www.envoyproxy.io/&lt;/a&gt;，Lyft开源的，可以在Istio中使用Sidecar模式运行&lt;/li&gt;
&lt;li&gt;Istio：&lt;a href=&#34;https://istio.io&#34;&gt;https://istio.io&lt;/a&gt;，由Google、IBM、Lyft联合开发并开源&lt;/li&gt;
&lt;li&gt;Conduit：&lt;a href=&#34;https://conduit.io&#34;&gt;https://conduit.io&lt;/a&gt;，同样由Buoyant开源的轻量级的基于Kubernetes的Service Mesh&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外还有很多其它的Service Mesh鱼贯而出，请参考&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34;&gt;awesome-cloud-native&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Istio VS Linkerd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linkerd和Istio是最早开源的Service Mesh，它们都支持Kubernetes，下面是它们之间的一些特性对比。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Feature&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Istio&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Linkerd&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;部署架构&lt;/td&gt;
&lt;td&gt;Envoy/Sidecar&lt;/td&gt;
&lt;td&gt;DaemonSets&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;易用性&lt;/td&gt;
&lt;td&gt;复杂&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持平台&lt;/td&gt;
&lt;td&gt;kuberentes&lt;/td&gt;
&lt;td&gt;kubernetes/mesos/Istio/local&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当前版本&lt;/td&gt;
&lt;td&gt;0.3.0&lt;/td&gt;
&lt;td&gt;1.3.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是否已有生产部署&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于两者的架构可以参考各自的官方文档，我只从其在kubernetes上的部署结构来说明其区别。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/istio-vs-linkerd.jpg&#34; alt=&#34;istio vs linkerd&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;istio vs linkerd&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;Istio的组件复杂，可以分别部署的kubernetes集群中，但是作为核心路由组件&lt;strong&gt;Envoy&lt;/strong&gt;是以&lt;strong&gt;Sidecar&lt;/strong&gt;形式与应用运行在同一个Pod中的，所有进入该Pod中的流量都需要先经过Envoy。&lt;/p&gt;
&lt;p&gt;Linker的部署十分简单，本身就是一个镜像，使用Kubernetes的&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/daemonset.html&#34;&gt;DaemonSet&lt;/a&gt;方式在每个node节点上运行。&lt;/p&gt;
&lt;p&gt;更多信息请参考&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34;&gt;kubernetes-handbook&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Cloud Native的大规模工业生产&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;GitOps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给开发者带来最大配置和上线的灵活性，践行DevOps流程，改善研发效率，下图这样的情况将更少发生。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/0069RVTdgy1fv5mzj8rj6j318g1ewtfc.jpg&#34; alt=&#34;Deployment pipeline&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Deployment pipeline&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;我们知道Kubernetes中的所有应用的部署都是基于YAML文件的，这实际上就是一种&lt;strong&gt;Infrastructure as code&lt;/strong&gt;，完全可以通过Git来管控基础设施和部署环境的变更。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big Data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark现在已经非官方支持了基于Kuberentes的原生调度，其具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes原生调度：与yarn、mesos同级&lt;/li&gt;
&lt;li&gt;资源隔离，粒度更细：以namespace来划分用户&lt;/li&gt;
&lt;li&gt;监控的变革：单次任务资源计量&lt;/li&gt;
&lt;li&gt;日志的变革：pod的日志收集&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Feature&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Yarn&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;queue&lt;/td&gt;
&lt;td&gt;queue&lt;/td&gt;
&lt;td&gt;namespace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;instance&lt;/td&gt;
&lt;td&gt;ExcutorContainer&lt;/td&gt;
&lt;td&gt;Executor Pod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;network&lt;/td&gt;
&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;heterogeneous&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;security&lt;/td&gt;
&lt;td&gt;RBAC&lt;/td&gt;
&lt;td&gt;ACL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下图是在Kubernetes上运行三种调度方式的spark的单个节点的应用部分对比：&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/spark-on-kubernetes-with-different-schedulers.jpg&#34; alt=&#34;Spark on Kubernetes with different schedulers&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Spark on Kubernetes with different schedulers&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;从上图中可以看到在Kubernetes上使用YARN调度、standalone调度和kubernetes原生调度的方式，每个node节点上的Pod内的spark Executor分布，毫无疑问，使用kubernetes原生调度的spark任务才是最节省资源的。&lt;/p&gt;
&lt;p&gt;提交任务的语句看起来会像是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./spark-submit &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --deploy-mode cluster &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --class com.talkingdata.alluxio.hadooptest &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --master k8s://https://172.20.0.113:6443 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --kubernetes-namespace spark-cluster &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.driverEnv.SPARK_USER&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;hadoop &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.driverEnv.HADOOP_USER_NAME&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;hadoop &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.executorEnv.HADOOP_USER_NAME&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;hadoop &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.executorEnv.SPARK_USER&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;hadoop &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.authenticate.driver.serviceAccountName&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;spark &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.driver.memory&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;100G &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.executor.memory&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10G &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.driver.cores&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;30&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.executor.cores&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.driver.maxResultSize&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10240m &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.driver.limit.cores&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.executor.limit.cores&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.executor.memoryOverhead&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;2g &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.executor.instances&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.app.name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;spark-pi &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.driver.docker.image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;spark-driver:v2.1.0-kubernetes-0.3.1-1 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.executor.docker.image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;spark-executor:v2.1.0-kubernetes-0.3.1-1 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.initcontainer.docker.image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;spark-init:v2.1.0-kubernetes-0.3.1-1 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  --conf spark.kubernetes.resourceStagingServer.uri&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;http://172.20.0.114:31000 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;~/Downloads/tendcloud_2.10-1.0.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于支持Kubernetes原生调度的Spark请参考：https://jimmysong.io/spark-on-k8s/&lt;/p&gt;
&lt;h2 id=&#34;open-source&#34;&gt;Open Source&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Contributing is Not only about code, it is about helping a community.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图是我们刚调研准备使用Kubernetes时候的调研方案选择。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/0069RVTdgy1fv5mzywc83j31fk1i8qg4.jpg&#34; alt=&#34;Kubernetes solutions&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kubernetes solutions&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;对于一个初次接触Kubernetes的人来说，看到这样一个庞大的架构选型时会望而生畏，但是Kubernetes的开源社区帮助了我们很多。&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/kubernetes-sigs.jpg&#34; alt=&#34;Kubernetes SIG&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kubernetes SIG&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;我组建了&lt;strong&gt;K8S&amp;amp;Cloud Native实战&lt;/strong&gt;微信群，参与了k8smeetup、KEUC2017、Kubernetes 官方文档的翻译工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有用的资料和链接&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to&#34;&gt;云原生社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34;&gt;Kubernetes Handbook - Kubernetes 和云原生应用架构实践手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/&#34;&gt;Cloud native开源生态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/book/migrating-to-cloud-native-application-architectures/&#34;&gt;迁移到云原生应用架构|电子书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>High Level Cloud Native From Kevin Hoffman</title>
      <link>https://jimmysong.io/blog/high-level-cloud-native-from-kevin-hoffman/</link>
      <pubDate>Fri, 15 Sep 2017 20:32:47 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/high-level-cloud-native-from-kevin-hoffman/</guid>
      <description>
        
        
        &lt;p&gt;Kevin Hoffman(From Capital One, twitter &lt;a href=&#34;https://twitter.com/KevinHoffman&#34;&gt;@KevinHoffman&lt;/a&gt;) was making a speech on &lt;em&gt;TalkingData T11 Smart Data Summit&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;kevin-hoffman-talking-on-t11.jpg&#34; alt=&#34;Kevin Hoffman Talking on T11&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;Kevin Hoffman Talking on T11&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;He addressed that &lt;strong&gt;15 Factors of Cloud Native&lt;/strong&gt; which based on Heroku&#39;s original &lt;a href=&#34;https://12factor.net&#34;&gt;Twelve-Factor App&lt;/a&gt;, but he add more 3 another factors on it.&lt;/p&gt;
&lt;p&gt;Let&#39;s have a look at the 15 factors of Cloud Native.&lt;/p&gt;
&lt;h2 id=&#34;1-one-codebase-one-app&#34;&gt;1. One codebase, one App&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Single version-controlled codebase, many deploys&lt;/li&gt;
&lt;li&gt;Multiple apps should not share code
&lt;ul&gt;
&lt;li&gt;Microservices need separate release schedules&lt;/li&gt;
&lt;li&gt;Upgrade, deploy one without impacting others&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tie build and deploy pipelines to single codebase&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-api-first&#34;&gt;2. API first&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Service ecosystem requires a contract
&lt;ul&gt;
&lt;li&gt;Public API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multiple teams on different schedulers
&lt;ul&gt;
&lt;li&gt;Code to contract/API, not code dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use well-documented contract standards
&lt;ul&gt;
&lt;li&gt;Protobuf IDL, Swagger, Apiary, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API First != REST first
&lt;ul&gt;
&lt;li&gt;RPC can be more appropriate in some situations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-dependency-management&#34;&gt;3. Dependency Management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Explicitly declare dependencies&lt;/li&gt;
&lt;li&gt;Include all dependencies with app release&lt;/li&gt;
&lt;li&gt;Create immutable build artifact (e.g. docker image)&lt;/li&gt;
&lt;li&gt;Rely on smallest docker image
&lt;ul&gt;
&lt;li&gt;Base on scratch if possible&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;App cannot rely on host for system tools or libraries&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-design-build-release-run&#34;&gt;4. Design, Build, Release, Run&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Design part of iterative cycle
&lt;ul&gt;
&lt;li&gt;Agile doesn’t mean random or undesigned&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mature CI/CD pipeline and teams
&lt;ul&gt;
&lt;li&gt;Design to production in days not months&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build immutable artifacts&lt;/li&gt;
&lt;li&gt;Release automatically deploys to environment
&lt;ul&gt;
&lt;li&gt;Environments contains config, not release artifact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-configuration-credentials-code&#34;&gt;5. Configuration, Credentials, Code&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;3 Cs&amp;rdquo; volatile substances that explode when combinded&lt;/li&gt;
&lt;li&gt;Password in a config file is as bad as password in code&lt;/li&gt;
&lt;li&gt;App must accept &amp;ldquo;3 Cs&amp;rdquo; from &lt;strong&gt;environment&lt;/strong&gt; and only use harmless defaults&lt;/li&gt;
&lt;li&gt;Test - Could you expose code on Github and not reveal passwords, URLs, credentials?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-logs&#34;&gt;6. Logs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Emit formatted logs to stdout&lt;/li&gt;
&lt;li&gt;Code should not know about destination or purpose of log emissions&lt;/li&gt;
&lt;li&gt;Use downstream log aggregator
&lt;ul&gt;
&lt;li&gt;collect, store, process, expose logs&lt;/li&gt;
&lt;li&gt;ELK, Splunk, Sumo, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;structured&lt;/strong&gt; logs to allow query and analysis
&lt;ul&gt;
&lt;li&gt;JSON, csv, KV, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logs are not metrics&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-disposability&#34;&gt;7. Disposability&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;App must start as quickly as possible&lt;/li&gt;
&lt;li&gt;App must stop quickly and gracefully&lt;/li&gt;
&lt;li&gt;Processes start and stop all the time in the cloud&lt;/li&gt;
&lt;li&gt;Every scale up/down disposes of processes&lt;/li&gt;
&lt;li&gt;Slow dispose == slow scale&lt;/li&gt;
&lt;li&gt;Slow dispose or startup can cause availability gaps&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-backing-services&#34;&gt;8. Backing Services&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Assume all resources supplied by backingservices&lt;/li&gt;
&lt;li&gt;Cannotassume mutable file system
&lt;ul&gt;
&lt;li&gt;“Disk as a Service” (e.g. S3, virtual mounts, etc)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every backing service is bound resource
&lt;ul&gt;
&lt;li&gt;URL, credentials, etc-&amp;gt; environment config&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Host does not satisfy NFRs
&lt;ul&gt;
&lt;li&gt;Backing services and cloud infrastructure&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-environment-parity&#34;&gt;9. Environment Parity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“Works on my machine”
&lt;ul&gt;
&lt;li&gt;Cloud-native anti-pattern. Must &lt;strong&gt;work everywhere&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every commit is candidate for deployment&lt;/li&gt;
&lt;li&gt;Automated acceptance tests
&lt;ul&gt;
&lt;li&gt;Provide no confidence if environments don’t match&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-administrative-processes&#34;&gt;10. Administrative Processes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Database migrations&lt;/li&gt;
&lt;li&gt;Run-once scripts or jobs&lt;/li&gt;
&lt;li&gt;Avoid using for batch operations, consider instead:
&lt;ul&gt;
&lt;li&gt;Event sourcing&lt;/li&gt;
&lt;li&gt;Schedulers&lt;/li&gt;
&lt;li&gt;Triggers from queues, etc&lt;/li&gt;
&lt;li&gt;Lambdas/functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-port-binding&#34;&gt;11. Port Binding&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In cloud, infrastructure determines port&lt;/li&gt;
&lt;li&gt;App must accept port assigned by platform&lt;/li&gt;
&lt;li&gt;Containers have internal/external ports
&lt;ul&gt;
&lt;li&gt;App design must embrace this&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Never use reserved ports&lt;/li&gt;
&lt;li&gt;Beware of container “host mode” networking&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-stateless-processes&#34;&gt;12. Stateless Processes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What is stateless?&lt;/li&gt;
&lt;li&gt;Long-term state handled by a backing service&lt;/li&gt;
&lt;li&gt;In-memory state lives onlyas long as request&lt;/li&gt;
&lt;li&gt;Requests from same client routed to different instances
&lt;ul&gt;
&lt;li&gt;“Sticky sessions” cloud native anti-pattern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-concurency&#34;&gt;13. Concurency&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scale horizontally using the process model&lt;/li&gt;
&lt;li&gt;Build disposable, stateless, share-nothing processes&lt;/li&gt;
&lt;li&gt;Avoid adding CPU/RAM to increase scale/throughput&lt;/li&gt;
&lt;li&gt;Where possible, let platform/libraries do threading
&lt;ul&gt;
&lt;li&gt;Many single-threaded services &amp;gt; 1 multi-threaded monolith&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14-telemetry&#34;&gt;14. Telemetry&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Monitor apps in the cloud like satellite in orbit&lt;/li&gt;
&lt;li&gt;No tether, no live debugger&lt;/li&gt;
&lt;li&gt;Application Perf Monitoring (APM)&lt;/li&gt;
&lt;li&gt;Domain Telemetry&lt;/li&gt;
&lt;li&gt;Health and system logs&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15-authentication--authorization&#34;&gt;15. Authentication &amp;amp; Authorization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Security should never be an afterthought&lt;/li&gt;
&lt;li&gt;Auth should be explicit, documented decision
&lt;ul&gt;
&lt;li&gt;Even if anonymous access is allowed&lt;/li&gt;
&lt;li&gt;Don’t allow anonymous access&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bearer tokens/OAuth/OIDC best practices&lt;/li&gt;
&lt;li&gt;Audit all attempts to access&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;migrating-monoliths-to-the-cloud&#34;&gt;Migrating Monoliths to the Cloud&lt;/h2&gt;
&lt;p&gt;After this 15 factors, he also gave us some tips about how to &lt;strong&gt;migrate monoliths to the Cloud&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make a rule - stop adding to the monolith
&lt;ul&gt;
&lt;li&gt;All new code must be cloud native&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Prioritize features
&lt;ul&gt;
&lt;li&gt;Where will you get most benefit from cloud native?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Come up with a plan
&lt;ul&gt;
&lt;li&gt;Decompose monolith over time&lt;/li&gt;
&lt;li&gt;Fast, agile iterations toward ultimate goal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use multiple strategies and patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;go---the-best-language-for-building-cloud-native-app&#34;&gt;Go - the Best Language for Building Cloud Native App&lt;/h2&gt;
&lt;p&gt;At last, he advise us the programming language Go is the best language to build Cloud Native applications for these reasons below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lightweight&lt;/li&gt;
&lt;li&gt;Easily learning curve&lt;/li&gt;
&lt;li&gt;Compiles to native binaries&lt;/li&gt;
&lt;li&gt;Very fast&lt;/li&gt;
&lt;li&gt;Large, thriving, engaged community
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gopherize.me&#34;&gt;http://gopherize.me&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kevin also wrote a book &lt;strong&gt;Cloud Native Go&lt;/strong&gt; to show how to &lt;strong&gt;Building Web Applications and Microservices for the Cloud with Go and React&lt;/strong&gt;. This book has been translated to Chinese by four guys from TalkingData with ❤️. 《Cloud Native Go 构建基于Go和React的云原生Web应用与微服务》published by PHEI publisher house. See the website I built for this book &lt;a href=&#34;https://jimmysong.io/cloud-native-go/&#34;&gt;https://jimmysong.io/cloud-native-go/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kevin was signing his name on the book&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;kevin-hoffman-siging-on-the-book.jpg&#34; alt=&#34;kevin siging on the book&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;kevin siging on the book&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;This is his first visit to China, as a main translator of this book I an honored to be with him to take this photo.&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
  &lt;img src=&#34;kevin-hoffman-with-me.jpg&#34; alt=&#34;kevin Hoffman with Jimmy Song&#34;&gt;
  
  &lt;figcaption class=&#34;text-center&#34;&gt;kevin Hoffman with Jimmy Song&lt;/figcaption&gt;
  
  &lt;/figure&gt;

&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
