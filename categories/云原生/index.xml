
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 云原生专栏</title>
    <link>https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    <description>Recent content in 云原生专栏 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    
      <follow_challenge>
        <feedId>51621818828612637</feedId>
        <userId>59800919738273792</userId>
      </follow_challenge>
    
    
    <lastBuildDate>Tue, 27 Aug 2024 10:23:48 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>KubeCon China 2024 回顾：引领云原生技术的前沿动态</title>
      <link>https://jimmysong.io/blog/kubecon-china-2024-recap/</link>
      <pubDate>Tue, 27 Aug 2024 10:23:48 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/kubecon-china-2024-recap/</guid>
      <description>
        
        
        &lt;p&gt;今年的&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-open-source-summit-ai-dev-china/&#34; title=&#34;KubeCon China&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon China&lt;/a&gt;是首次在香港举办的盛会，持续了三天。作为会议的参与者及一个论坛的主持人，我在这篇文章中将分享会议的精彩内容和对服务网格及网关技术的深入讨论。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    &lt;img src=&#34;https://jimmysong.io/img/blog/kubecon-china-2024-recap/kubecon-china-2024-hall.webp&#34; data-img=&#34;https://jimmysong.io/img/blog/kubecon-china-2024-recap/kubecon-china-2024-hall.webp&#34; alt=&#34;image&#34; data-caption=&#34;KubeCon China 现场画面&#34;&gt;
  
  
  &lt;figcaption&gt;KubeCon China 现场画面&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;主题焦点&#34;&gt;主题焦点&lt;/h2&gt;
&lt;p&gt;本次 KubeCon 新增了 AI 与开发者主题，以下是部分重点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云原生技术在行业中的实际应用&lt;/strong&gt;：特别是电动汽车和网络安全领域，如 Huawei 和 NIO 的共同探讨云原生技术如何加速电动汽车创新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 社区的力量&lt;/strong&gt;：详细讨论了中国 Kubernetes 社区的影响力及其在推动区域云原生活动中的角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开源技术与人工智能的融合&lt;/strong&gt;：探讨了中国及香港在开源与 AI 技术领域的先进地位及对区域技术创新的推动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务网格与 API 网关的最新进展&lt;/strong&gt;：包括服务网格的最新技术更新及其与 Kubernetes 调度器的协同工作提高系统吞吐量的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;供应链安全的新策略&lt;/strong&gt;：关注保障供应链安全的最新动态，特别是 SLSA 合规性的实践指南。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多集群管理与边缘计算&lt;/strong&gt;：探讨了在不同架构下进行有效管理与创新的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AI 大模型的推理性能优化&lt;/strong&gt;：讨论了无服务器架构下的 AI 大模型推理性能优化及相关技术进展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;istio-与现代-api-网关探索服务网格的未来&#34;&gt;Istio 与现代 API 网关：探索服务网格的未来&lt;/h2&gt;
&lt;p&gt;我与来自 Tetrate、阿里云和 Kong Inc.的行业领袖共同参与的&lt;a href=&#34;https://kccncossaidevchn2024.sched.com/event/1eYY6/istio-and-modern-api-gateways-navigating-the-future-of-service-meshes-istiorejiong-apijie-daepqiu-jie-zha-jimmy-song-jianpeng-he-tetrate-jiaqi-zhang-alibaba-cloud-jintao-zhang-kong-inc-xunzhuo-liu-tencent&#34; title=&#34;圆桌讨论&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;圆桌讨论&lt;/a&gt;，深入探讨了 Istio 和 API 网关的最新进展及其融合带来的革新。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    &lt;img src=&#34;https://jimmysong.io/img/blog/kubecon-china-2024-recap/kubecon-china-2024-panel.webp&#34; data-img=&#34;https://jimmysong.io/img/blog/kubecon-china-2024-recap/kubecon-china-2024-panel.webp&#34; alt=&#34;image&#34; data-caption=&#34;KubeCon China 2024 Istio 和现代 API 网关的圆桌论坛&#34;&gt;
  
  
  &lt;figcaption&gt;KubeCon China 2024 Istio 和现代 API 网关的圆桌论坛&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Istio 的革新&lt;/strong&gt;：介绍了 Istio 1.123 版本中的 Ambient 模式优化，此模式作为新的架构选择，减少资源消耗同时提升性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ambient 模式与 Sidecar 模式的实用对比&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;何时选择 Sidecar&lt;/strong&gt;：需要高度隔离与详尽流量管理时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;何时选择 Ambient&lt;/strong&gt;：追求极致性能与资源效率时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ambient 模式的发展挑战&lt;/strong&gt;：尽管有诸多优势，Ambient 模式在复杂流量管理与多租户环境中仍面临挑战。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务网格优化策略&lt;/strong&gt;：讨论了服务网格的优化方法，如何提升云应用的性能与效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务网格与 API 网关的整合&lt;/strong&gt;：展示了这两大技术如何共同作用，支持更复杂的部署与运维模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;istio-的未来展望&#34;&gt;Istio 的未来展望&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://kccncossaidevchn2024.sched.com/event/1eYcG/what-is-the-future-of-service-mesh-sidecar-or-sidecarless-jie-zha-dyagsyi-wu-pi-yi-wu-zhonghu-xu-huawei&#34; title=&#34;徐中虎和何建鹏的分享&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;徐中虎和何建鹏的分享&lt;/a&gt;中，我们了解到了 Istio 未来的可能发展方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双模驱动&lt;/strong&gt;：Istio 将同时支持 Ambient 模式和传统的 Sidecar 模式。Ambient 模式适合追求性能和资源成本优化的用户，而 Sidecar 模式将为需要更全面功能的用户长期支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gateway API 的支持&lt;/strong&gt;：Istio 对 Gateway API 的支持，为用户提供了更灵活的路由与策略配置选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Waypoints 的策略应用&lt;/strong&gt;：Waypoints 不必局限于 Istio 或 Envoy。通过使用 Gateway API 和 GAMMA，任何符合标准的实现都可以作为 Waypoint，这为服务网格提供了更大的灵活性和扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sandwich-waypoint&#34;&gt;Sandwich Waypoint&lt;/h3&gt;
&lt;p&gt;他们着重介绍了 Sandwich Waypoint，这是一种在 Istio 内管理和引导流量的复杂方法，特别是在环境模式下。这种 Waypoint 代理模式旨在通过充当处理、转换和转发客户端和服务器之间流量的中介层来简化和提高流量路由的效率。它利用了双 zTunnel 设置，其中位于通信通道两端的每个 zTunnel 协作封装和解码流量。Waypoint 本身负责执行额外的功能，如流量整形、安全检查和协议转换，从而在没有传统边车开销的情况下丰富服务网格功能。这种方法允许 Istio 保持强大的流量管理和安全功能，同时优化资源利用率并减少延迟。&lt;/p&gt;
&lt;p&gt;Sandwich Waypoint 支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流量重定向&lt;/strong&gt;：可通过设置  &lt;code&gt;istio.io/use-waypoint: {namespace}/{gateway-name}&lt;/code&gt; 注解，将目标服务、Pod 或命名空间内的流量重定向到同一个 Waypoint。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waypoint 部署&lt;/strong&gt;：用户可以通过创建一个 Gateway 对象来部署 Waypoint。与原始的 Waypoint 实现不同，新的部署方式将包括相关联的服务和服务账户，不仅仅是 Waypoint 实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由与政策配置&lt;/strong&gt;：使用 Gateway API 进行路由和政策配置，这为用户和供应商提供了更多的自定义选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一种 Istio Ambient 模式中捕获七层流量模式，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/kubecon-china-2024-recap/istio-ambient-traffic-capture.svg&#34; data-img=&#34;/blog/kubecon-china-2024-recap/istio-ambient-traffic-capture.svg&#34; alt=&#34;image&#34; data-caption=&#34;Sandwich Waypoint 捕获流量&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Sandwich Waypoint 捕获流量&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Istio Sandwich Waypoint 捕获七层流量的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 zTunnel 终止 HBONE 连接，到达 Waypoint，zTunnel 负责解码 HBONE 协议。&lt;/li&gt;
&lt;li&gt;Waypoint 提取目的地地址、源地址等信息用于处理流量及确定转发位置。&lt;/li&gt;
&lt;li&gt;Waypoint 扩展或解析传输层封装（TLV）数据，代理支持处理 TLV 以提供更多上下文。&lt;/li&gt;
&lt;li&gt;Waypoint 与同位 zTunnel 通信，与服务端 zTunnel 协调确保流量正确转移。&lt;/li&gt;
&lt;li&gt;封装 HBONE，由服务端 zTunnel 发送到最终服务器目的地。实现 Istio 环境中服务的细粒度流量管理和路由并保持与现有网络协议兼容性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;envoy-gateway-的前沿扩展&#34;&gt;Envoy Gateway 的前沿扩展&lt;/h2&gt;
&lt;p&gt;赵化冰在 KubeCon 上介绍了 Envoy Gateway 如何通过扩展 Kubernetes Gateway API 来增强功能与灵活性的&lt;a href=&#34;https://kccncossaidevchn2024.sched.com/event/1eYcX/gateway-api-and-beyond-introducing-envoy-gateways-gateway-api-extensions-jie-api-daeptao-envoyjie-zha-jie-api-huabing-zhao-tetrate&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;，涵盖了多种匹配与路由能力的扩展、新的资源和策略模型以及安全策略的细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网关 API 兼容性&lt;/strong&gt;：Envoy 网关完全兼容网关 API，并提供了广泛的匹配和路由选项。这些包括 HTTP 主机和路径匹配、基于 HTTP 头的操作、权重负载均衡，以及对 gRPC、UDP 和 TCP 路由的支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级流量管理策略&lt;/strong&gt;：引入的 &lt;code&gt;ClientTrafficPolicy&lt;/code&gt; 和 &lt;code&gt;BackendTrafficPolicy&lt;/code&gt; 为用户提供了更细粒度的流量管理控制，适用于上游和下游连接，包括如限速、重试、负载均衡、断路器等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全与认证增强&lt;/strong&gt;：新引入的 &lt;code&gt;SecurityPolicy&lt;/code&gt; 支持 CORS、HTTP 基础认证、OIDC、JWT 认证，并能与各种身份提供商集成。它还提供了详细的访问控制，允许根据请求者的原始 IP、JWT 声明等进行授权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义扩展功能&lt;/strong&gt;：Envoy 网关支持通过 WASM（WebAssembly）和外部进程扩展来支持自定义扩展。这允许用户通过集成他们自己为特定用例和操作需求量身定制的扩展来增强网关的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未来探索&lt;/strong&gt;：未来版本预计将支持非 Kubernetes 环境部署，优化控制平面的内存使用，并扩展授权能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过本次会议我们了解了 Istio 的 Ambient 模式和 Envoy Gateway 的进展。这些技术的讨论不仅展望了未来趋势，也提供了实用的洞察，助力技术实施与创新。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>微服务中常见的认证方式详解</title>
      <link>https://jimmysong.io/blog/microservice-auth-methods/</link>
      <pubDate>Wed, 22 May 2024 13:54:49 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/microservice-auth-methods/</guid>
      <description>
        
        
        &lt;p&gt;在现代微服务架构中，安全性是一个至关重要的方面。随着微服务数量的增加，如何确保服务间的安全通信成为了一个挑战。本文将介绍几种常见的微服务认证方式，帮助你在设计和实现微服务系统时选择合适的认证方案。&lt;/p&gt;
&lt;h2 id=&#34;comparation&#34;&gt;微服务中常用的认证方式&lt;/h2&gt;
&lt;p&gt;下表列出了几种微服务中常用的认证方式，并从优点、缺点、适用场景和现实示例等维度进行比较。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;认证方式&lt;/th&gt;
          &lt;th&gt;优点&lt;/th&gt;
          &lt;th&gt;缺点&lt;/th&gt;
          &lt;th&gt;运行位置&lt;/th&gt;
          &lt;th&gt;适用场景&lt;/th&gt;
          &lt;th&gt;典型用途&lt;/th&gt;
          &lt;th&gt;现实使用场景&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;JWT&lt;/td&gt;
          &lt;td&gt;自包含令牌，减少服务器负担&lt;/td&gt;
          &lt;td&gt;令牌较大，可能会增加带宽开销&lt;/td&gt;
          &lt;td&gt;API 网关、服务间&lt;/td&gt;
          &lt;td&gt;微服务之间无状态通信&lt;/td&gt;
          &lt;td&gt;用户认证和授权&lt;/td&gt;
          &lt;td&gt;在微服务架构中，用户认证（如 Auth0、Firebase）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;OAuth 2.0&lt;/td&gt;
          &lt;td&gt;广泛支持，灵活性高&lt;/td&gt;
          &lt;td&gt;实现复杂，需要额外的交互&lt;/td&gt;
          &lt;td&gt;API 网关&lt;/td&gt;
          &lt;td&gt;第三方应用授权&lt;/td&gt;
          &lt;td&gt;第三方应用访问用户数据&lt;/td&gt;
          &lt;td&gt;Github OAuth，用于第三方应用访问 Github 数据和 API&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;mTLS&lt;/td&gt;
          &lt;td&gt;高安全性，防止中间人攻击&lt;/td&gt;
          &lt;td&gt;证书管理复杂，性能开销较大&lt;/td&gt;
          &lt;td&gt;服务间&lt;/td&gt;
          &lt;td&gt;高安全性要求的通信&lt;/td&gt;
          &lt;td&gt;安全敏感的服务通信&lt;/td&gt;
          &lt;td&gt;银行系统中的服务通信&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Basic 认证&lt;/td&gt;
          &lt;td&gt;简单易实现&lt;/td&gt;
          &lt;td&gt;不安全，容易被拦截&lt;/td&gt;
          &lt;td&gt;API 网关、服务间&lt;/td&gt;
          &lt;td&gt;简单的 API 保护&lt;/td&gt;
          &lt;td&gt;简单的内部服务&lt;/td&gt;
          &lt;td&gt;Kubernetes API Server 的基本认证&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;API Key 认证&lt;/td&gt;
          &lt;td&gt;简单易用&lt;/td&gt;
          &lt;td&gt;安全性低，容易被滥用&lt;/td&gt;
          &lt;td&gt;API 网关、服务间&lt;/td&gt;
          &lt;td&gt;低安全性要求的场景&lt;/td&gt;
          &lt;td&gt;简单的服务访问控制&lt;/td&gt;
          &lt;td&gt;各种公共 API，如 OpenAI API&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面我们将详细介绍这几种常见的认证方式。&lt;/p&gt;
&lt;h2 id=&#34;jwt&#34;&gt;JWT 认证&lt;/h2&gt;
&lt;p&gt;JWT（JSON Web Token）最早由 IETF JSON Web Token (JWT) 工作组提出，并在 2015 年作为 RFC 7519 标准正式发布。JWT 的设计目标是提供一种紧凑且自包含的方式，用于在各方之间安全地传递信息。由于其易于使用和无状态的特性，JWT 迅速被广泛采用，成为身份验证和信息交换的标准之一，特别是在微服务和现代 Web 应用中。&lt;/p&gt;
&lt;p&gt;下图展示的是 JWT 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/5dbe313ba5e9704fe2669e7a1ea556a4.svg&#34; data-img=&#34;/blog/microservice-auth-methods/5dbe313ba5e9704fe2669e7a1ea556a4.svg&#34; alt=&#34;image&#34; data-caption=&#34;JWT 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;JWT 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;JWT 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户提供凭证&lt;/li&gt;
&lt;li&gt;客户端请求访问令牌&lt;/li&gt;
&lt;li&gt;认证服务器返回 JWT 令牌&lt;/li&gt;
&lt;li&gt;客户端带 JWT 令牌请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证 JWT&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;jwt-的格式说明及示例&#34;&gt;JWT 的格式说明及示例&lt;/h3&gt;
&lt;p&gt;JWT（JSON Web Token）由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature），分别通过 Base64 编码后用点（.）连接在一起组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;头部（Header）&lt;/strong&gt;：头部包含令牌类型和签名算法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;alg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HS256&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;typ&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;JWT&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;载荷（Payload）&lt;/strong&gt;：载荷包含声明（claims），即关于用户或其他数据的断言。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;sub&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1234567890&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;iat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1516239022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;签名（Signature）&lt;/strong&gt;：签名由编码后的头部、编码后的载荷以及一个密钥通过头部中指定的算法生成。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HMACSHA256(
  base64UrlEncode(header) + &amp;#34;.&amp;#34; +
  base64UrlEncode(payload),
  secret
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个 JWT 令牌示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-jwt&#34; data-lang=&#34;jwt&#34;&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;oauth-20&#34;&gt;OAuth 2.0&lt;/h2&gt;
&lt;p&gt;OAuth（Open Authorization）协议最早由 Blaine Cook 和 Chris Messina 在 2006 年提出。最初的目标是为 Twitter 提供一个开放的授权标准。OAuth 1.0 于 2007 年发布，提供了一个允许用户授权第三方应用访问其资源的标准化方式，但由于其复杂的签名机制和其他安全问题，受到了一些限制。&lt;/p&gt;
&lt;p&gt;为了克服这些缺点，IETF（Internet Engineering Task Force）成立了 OAuth 工作组，旨在开发一个更简化、更灵活的授权协议。2012 年，&lt;a href=&#34;https://oauth.net/2/&#34; title=&#34;OAuth 2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAuth 2.0&lt;/a&gt; 正式发布（RFC 6749 和 RFC 6750）。OAuth 2.0 简化了授权流程，增加了多种授权模式，如授权码模式、简化模式、资源所有者密码凭证模式和客户端凭证模式。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 迅速成为行业标准，广泛应用于各种网络服务和应用程序，如 Google、Facebook、GitHub 等。在此基础上，出现了多个扩展和补充协议（如 OpenID Connect），进一步增强了 OAuth 2.0 的功能和安全性。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 的发展和扩展使其成为现代互联网身份验证和授权的重要基石，提供了灵活和安全的解决方案，满足了不断变化的网络应用需求。&lt;/p&gt;
&lt;p&gt;下图展示的是 OAuth 2.0 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/d79d70a5b27686dbaf8eee2e825f3d6c.svg&#34; data-img=&#34;/blog/microservice-auth-methods/d79d70a5b27686dbaf8eee2e825f3d6c.svg&#34; alt=&#34;image&#34; data-caption=&#34;OAuth 2.0 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;OAuth 2.0 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;OAuth 2.0 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户请求访问资源&lt;/li&gt;
&lt;li&gt;客户端请求认证&lt;/li&gt;
&lt;li&gt;用户登录并授权&lt;/li&gt;
&lt;li&gt;认证服务器返回授权码&lt;/li&gt;
&lt;li&gt;客户端交换授权码获取访问令牌&lt;/li&gt;
&lt;li&gt;客户端带访问令牌请求资源服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;oauth-20-授权码&#34;&gt;OAuth 2.0 授权码&lt;/h3&gt;
&lt;p&gt;在 OAuth 2.0 授权码模式中，授权码是客户端在用户授权后从授权服务器获取的短期凭证，用于交换访问令牌。授权码是一个临时的字符串，可以在授权服务器和客户端之间传递以获得更安全的访问令牌。&lt;/p&gt;
&lt;h3 id=&#34;oauth-20-扩展&#34;&gt;OAuth 2.0 扩展&lt;/h3&gt;
&lt;p&gt;OAuth 2.0 在发展过程中，为了适应不同的场景，发展出了众多的扩展，下表罗列出一些常用的扩展名称、主要功能及适用场景。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;扩展名称&lt;/th&gt;
          &lt;th&gt;主要功能&lt;/th&gt;
          &lt;th&gt;适用场景&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;授权码 PKCE 扩展&lt;/td&gt;
          &lt;td&gt;提高授权码模式的安全性，防止授权码拦截攻击&lt;/td&gt;
          &lt;td&gt;公共客户端（如移动应用、单页应用）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;动态客户端注册协议&lt;/td&gt;
          &lt;td&gt;允许客户端动态注册和更新客户端信息&lt;/td&gt;
          &lt;td&gt;自动化和灵活性要求高的系统&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Token Introspection&lt;/td&gt;
          &lt;td&gt;允许资源服务器验证和获取访问令牌的详细信息&lt;/td&gt;
          &lt;td&gt;需要验证令牌有效性和获取令牌详细信息的场景&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Token Revocation&lt;/td&gt;
          &lt;td&gt;提供令牌撤销的标准接口&lt;/td&gt;
          &lt;td&gt;提高系统安全性和控制能力&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Device Authorization Grant&lt;/td&gt;
          &lt;td&gt;允许输入受限的设备通过其他设备完成身份验证&lt;/td&gt;
          &lt;td&gt;智能电视、游戏机等输入能力有限的设备&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Mutual TLS Client Authentication&lt;/td&gt;
          &lt;td&gt;基于双向 TLS 的客户端认证&lt;/td&gt;
          &lt;td&gt;高安全性要求的应用场景&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Resource Indicators&lt;/td&gt;
          &lt;td&gt;允许客户端在授权请求中指定访问的资源服务器&lt;/td&gt;
          &lt;td&gt;多资源服务器的支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Step-up Authentication Challenge Protocol&lt;/td&gt;
          &lt;td&gt;允许资源服务器按需请求更强的身份验证（如多因素认证）&lt;/td&gt;
          &lt;td&gt;高风险操作的高级认证&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;oauth-20-授权流程以-github-为例&#34;&gt;OAuth 2.0 授权流程（以 Github 为例）&lt;/h3&gt;
&lt;p&gt;GitHub 使用 OAuth 2.0 来授权第三方应用访问用户的 GitHub 数据。OAuth 2.0 令牌在 GitHub 上被称为 &amp;ldquo;access tokens&amp;rdquo;，用于验证和授权访问 GitHub API。它提供了一种安全、标准化的方法，允许第三方应用在用户授权的情况下访问 GitHub 资源。通过使用访问令牌，应用程序可以代表用户执行各种操作，如读取用户信息、访问仓库、创建 gists 等。这个过程确保了用户的安全和隐私，同时简化了应用程序的认证和授权流程。&lt;/p&gt;
&lt;p&gt;以下是使用 GitHub OAuth 2.0 令牌的详细流程和示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户授权&lt;/strong&gt;：用户在第三方应用程序的界面上点击“Login with GitHub”按钮。应用程序将用户重定向到 GitHub 的授权页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取授权码&lt;/strong&gt;：用户在 GitHub 授权页面上登录并同意授权，GitHub 会将用户重定向回应用程序，并在 URL 参数中附带一个授权码（authorization code）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://yourapp.com/callback?code=AUTHORIZATION_CODE
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交换访问令牌&lt;/strong&gt;：应用程序服务器使用授权码向 GitHub 的授权服务器请求访问令牌。&lt;/p&gt;
&lt;p&gt;请求示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;POST https://github.com/login/oauth/access_token
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;client_id&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_CLIENT_ID&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;client_secret&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_CLIENT_SECRET&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;code&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;AUTHORIZATION_CODE&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;redirect_uri&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://yourapp.com/callback&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GitHub 返回访问令牌&lt;/strong&gt;：GitHub 验证请求并返回访问令牌。&lt;/p&gt;
&lt;p&gt;响应示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;access_token&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;YOUR_ACCESS_TOKEN&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;token_type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;bearer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;scope&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;repo,gist&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用访问令牌访问资源&lt;/strong&gt;：应用程序使用获取的访问令牌访问 GitHub API。&lt;/p&gt;
&lt;p&gt;请求示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Authorization: token YOUR_ACCESS_TOKEN&amp;#34;&lt;/span&gt; https://api.github.com/user
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;响应示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;login&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;github-user&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;node_id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;MDQ6VXNlcjE=&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;avatar_url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://github.com/images/avatar.jpg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Github User&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;company&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GitHub&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;blog&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Earth&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;github-user@example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;访问令牌的特点和使用&#34;&gt;访问令牌的特点和使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;权限范围（Scopes）&lt;/strong&gt;：访问令牌的权限范围由用户在授权时指定，可以包括读取用户资料、访问用户仓库、管理 gists 等。例如，在上述示例中，&lt;code&gt;scope&lt;/code&gt; 包含 &lt;code&gt;repo&lt;/code&gt; 和 &lt;code&gt;gist&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有效期和刷新&lt;/strong&gt;：访问令牌的有效期可以是长期的也可以设置时间范围，直到用户主动撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全传输&lt;/strong&gt;：访问令牌应通过 HTTPS 传输，以确保其不被截获。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mtls&#34;&gt;mTLS&lt;/h2&gt;
&lt;p&gt;mTLS（Mutual TLS）是一种在客户端和服务器之间进行双向身份验证的技术，最早起源于 TLS（传输层安全协议），TLS 的前身 SSL（安全套接层）协议于 1995 年由 Netscape 开发。随着互联网安全需求的增加，TLS 逐步发展为一个高度安全的通信标准，而 mTLS 则在此基础上进一步提升了安全性，通过要求双方互相验证身份，广泛应用于金融、医疗等对安全性要求极高的领域。&lt;/p&gt;
&lt;p&gt;下图展示的是 mTLS 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/6a1cea6c141bda005fd183e0200b0f15.svg&#34; data-img=&#34;/blog/microservice-auth-methods/6a1cea6c141bda005fd183e0200b0f15.svg&#34; alt=&#34;image&#34; data-caption=&#34;mTLS 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;mTLS 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;mTLS 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端与服务器互相发送证书&lt;/li&gt;
&lt;li&gt;双方验证对方证书&lt;/li&gt;
&lt;li&gt;建立安全连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多关于 TLS 和 mTLS 的内容请参考博客 &lt;a href=&#34;https://jimmysong.io/blog/understanding-the-tls-encryption-in-istio/#what-is-tls-and-mtls&#34; title=&#34;如何理解 Istio 中的 mTLS 流量加密&#34;&gt;如何理解 Istio 中的 mTLS 流量加密&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic 认证&lt;/h2&gt;
&lt;p&gt;Basic 认证是一种最早由 HTTP/1.0 规范（RFC 1945）定义的简单认证机制，它通过将用户名和密码进行 Base64 编码后附加到 HTTP 请求头中进行身份验证。由于实现简单且易于使用，Basic 认证在早期的 Web 应用中被广泛采用。然而，由于其固有的安全性问题（如明文传输容易被截获），它在现代应用中通常与 HTTPS 一起使用，或被更安全的认证方式所替代。&lt;/p&gt;
&lt;p&gt;下图展示的是 Basic 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/e6f9bd871c5b59988c0f251e4cc3af64.svg&#34; data-img=&#34;/blog/microservice-auth-methods/e6f9bd871c5b59988c0f251e4cc3af64.svg&#34; alt=&#34;image&#34; data-caption=&#34;Basic 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Basic 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Basic 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户提供用户名和密码&lt;/li&gt;
&lt;li&gt;客户端带用户名和密码请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;basic-示例&#34;&gt;Basic 示例&lt;/h3&gt;
&lt;p&gt;Basic 认证使用 Base64 编码的用户名和密码进行认证。下面是使用 &lt;code&gt;curl&lt;/code&gt; 命令进行 Basic 认证请求的示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -u &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果用户名为 &lt;code&gt;admin&lt;/code&gt;，密码为 &lt;code&gt;password123&lt;/code&gt;，请求示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -u admin:password123 https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;api-key&#34;&gt;API Key 认证&lt;/h2&gt;
&lt;p&gt;API Key 认证是一种通过在请求中包含预先分配的唯一密钥来进行身份验证的方法，最早在 2000 年代初随着 Web API 的兴起而流行。API Key 认证由于其简单易用和便于管理的特性，被广泛应用于各种公共和私有 API 中。尽管它的安全性较低，容易被滥用，但在许多场景中仍然是控制访问的一种有效手段，特别是对于不需要高度安全保护的应用。&lt;/p&gt;
&lt;p&gt;下图展示的是 API Key 认证流程。&lt;/p&gt;

&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/microservice-auth-methods/8865798e8d7aea6c02e9913b925b0b2b.svg&#34; data-img=&#34;/blog/microservice-auth-methods/8865798e8d7aea6c02e9913b925b0b2b.svg&#34; alt=&#34;image&#34; data-caption=&#34;API Key 认证流程&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;API Key 认证流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;API Key 认证流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端带 API Key 请求资源服务器&lt;/li&gt;
&lt;li&gt;资源服务器验证 API Key&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;api-key-示例&#34;&gt;API Key 示例&lt;/h3&gt;
&lt;p&gt;API Key 是在请求中传递的一个唯一标识符，用于验证客户端身份。API Key 通常通过 HTTP 请求头或 URL 参数传递。&lt;/p&gt;
&lt;p&gt;HTTP 请求头中的 API Key 示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Authorization: ApiKey YOUR_API_KEY&amp;#34;&lt;/span&gt; https://api.example.com/data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;URL 参数中的 API Key 示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl https://api.example.com/data?api_key&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;YOUR_API_KEY
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;API Key 格式通常是一个字符串，包含字母和数字，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1234567890abcdef1234567890abcdef
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在微服务架构中选择合适的认证方式至关重要。不同的认证方式在安全性、复杂性和适用场景上各有优劣。本文介绍了 JWT、OAuth 2.0、mTLS、Basic 认证和 API Key 认证五种常见的认证方式，并提供了它们的优缺点和适用场景。此外，其他常见的认证方式如 SAML、LDAP、Kerberos 和 OpenID Connect 也广泛应用于不同的互联网应用场景，特别是在单点登录和跨域认证方面。希望这些信息能帮助你在设计和实现微服务系统时选择最合适的认证方案。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>深入解读 CNCF 推出的云原生 AI 白皮书</title>
      <link>https://jimmysong.io/blog/cloud-native-ai-whitepaper/</link>
      <pubDate>Tue, 16 Apr 2024 12:54:49 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cloud-native-ai-whitepaper/</guid>
      <description>
        
        
        &lt;p&gt;2024 年 3 月，在 KubeCon EU 期间，云原生计算基金会（CNCF）发布了首份关于云原生人工智能（CNAI）的详细&lt;a href=&#34;https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/&#34; title=&#34;白皮书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;白皮书&lt;/a&gt;。这份报告详尽地探讨了将云原生技术与人工智能融合的当前状态、面临的挑战、以及未来的发展方向。本文将对这份白皮书的核心内容进行深入解读。&lt;/p&gt;
&lt;h2 id=&#34;什么是云原生-ai&#34;&gt;什么是云原生 AI？&lt;/h2&gt;
&lt;p&gt;云原生 AI 指的是利用云原生技术原则来构建和部署人工智能应用和工作负载的方法。这包括利用微服务、容器化、声明式 API 和持续集成/持续部署（CI/CD）等云原生技术来增强 AI 应用的可扩展性、可复用性和可操作性。&lt;/p&gt;
&lt;p&gt;下图展示了云原生 AI 的架构，图片根据该白皮书重新绘制。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-ai-whitepaper/cloud-native-ai.svg&#34; data-img=&#34;/blog/cloud-native-ai-whitepaper/cloud-native-ai.svg&#34; alt=&#34;image&#34; data-caption=&#34;云原生 AI 架构&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生 AI 架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;云原生-ai-与云原生技术之间的关系&#34;&gt;云原生 AI 与云原生技术之间的关系&lt;/h2&gt;
&lt;p&gt;云原生技术提供了一个灵活、可扩展的平台，使得开发和运行 AI 应用变得更加高效。通过容器化和微服务架构，开发人员可以快速迭代和部署 AI 模型，同时保证系统的高可用性和可扩展性。Kubernetes 和其他云原生工具提供了必要的支持，例如资源调度、自动扩缩容和服务发现等。&lt;/p&gt;
&lt;p&gt;白皮书中给出了两个例子说明云原生 AI 与云原生技术的关系，即在云原生基础架构上运行 AI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://huggingface.co/blog/hugging-face-endpoints-on-azure&#34; title=&#34;Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openai.com/research/scaling-kubernetes-to-7500-nodes&#34; title=&#34;OpenAI Scaling Kubernetes to 7,500 nodes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAI Scaling Kubernetes to 7,500 nodes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生-ai-的挑战&#34;&gt;云原生 AI 的挑战&lt;/h2&gt;
&lt;p&gt;尽管云原生技术为 AI 应用提供了坚实的基础，但在将 AI 工作负载与云原生平台整合时，仍然存在一些挑战。这些挑战包括数据准备的复杂性、模型训练的资源需求、以及在多租户环境中保持模型的安全性和隔离性。此外，云原生环境中的资源管理和调度对于大规模 AI 应用尤其关键，需要进一步优化以支持高效的模型训练和推理。&lt;/p&gt;
&lt;h2 id=&#34;云原生-ai-的发展路径&#34;&gt;云原生 AI 的发展路径&lt;/h2&gt;
&lt;p&gt;白皮书中提出了几条云原生 AI 的发展路径，包括改进资源调度算法以更好地支持 AI 负载、开发新的服务网格技术以提高 AI 应用的性能和安全性，以及通过开源项目和社区合作来推动云原生 AI 技术的创新和标准化。&lt;/p&gt;
&lt;h2 id=&#34;云原生-ai-技术景观图&#34;&gt;云原生 AI 技术景观图&lt;/h2&gt;
&lt;p&gt;云原生 AI 涉及到多种技术，从容器和微服务到服务网格和无服务器计算。Kubernetes 是部署和管理 AI 应用的关键平台，而 Istio、Envoy 等服务网格技术则提供了强大的流量管理和安全功能。此外，Prometheus 和 Grafana 等监控工具对于维护 AI 应用的性能和可靠性至关重要。&lt;/p&gt;
&lt;p&gt;下面是白皮书中给出的云原生 AI 景观图。&lt;/p&gt;
&lt;h3 id=&#34;general-orchestration&#34;&gt;General Orchestration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;Volcano&lt;/li&gt;
&lt;li&gt;Armada&lt;/li&gt;
&lt;li&gt;Kuberay&lt;/li&gt;
&lt;li&gt;Nvidia NeMo&lt;/li&gt;
&lt;li&gt;Yunikorn&lt;/li&gt;
&lt;li&gt;Kueue&lt;/li&gt;
&lt;li&gt;Flame&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;distributed-training&#34;&gt;Distributed Training&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubeflow Training Operator&lt;/li&gt;
&lt;li&gt;Pytorch DDP&lt;/li&gt;
&lt;li&gt;TensorFlow Distributed&lt;/li&gt;
&lt;li&gt;Open MPI&lt;/li&gt;
&lt;li&gt;DeepSpeed&lt;/li&gt;
&lt;li&gt;Megatron&lt;/li&gt;
&lt;li&gt;Horovod&lt;/li&gt;
&lt;li&gt;Apla&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ml-serving&#34;&gt;ML Serving&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kserve&lt;/li&gt;
&lt;li&gt;Seldon&lt;/li&gt;
&lt;li&gt;VLLM&lt;/li&gt;
&lt;li&gt;TGT&lt;/li&gt;
&lt;li&gt;Skypilot&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cicd---delivery&#34;&gt;CI/CD - Delivery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubeflow Pipelines&lt;/li&gt;
&lt;li&gt;Mlflow&lt;/li&gt;
&lt;li&gt;TFX&lt;/li&gt;
&lt;li&gt;BentoML&lt;/li&gt;
&lt;li&gt;MLRun&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-science&#34;&gt;Data Science&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Jupyter&lt;/li&gt;
&lt;li&gt;Kubeflow Notebooks&lt;/li&gt;
&lt;li&gt;PyTorch&lt;/li&gt;
&lt;li&gt;TensorFlow&lt;/li&gt;
&lt;li&gt;Apache Zeppelin&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;workload-observability&#34;&gt;Workload Observability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Influxdb&lt;/li&gt;
&lt;li&gt;Grafana&lt;/li&gt;
&lt;li&gt;Weights and Biases (wandb)&lt;/li&gt;
&lt;li&gt;OpenTelemetry&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;automl&#34;&gt;AutoML&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hyperopt&lt;/li&gt;
&lt;li&gt;Optuna&lt;/li&gt;
&lt;li&gt;Kubeflow Katib&lt;/li&gt;
&lt;li&gt;NNI&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;governance--policy&#34;&gt;Governance &amp;amp; Policy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kyverno&lt;/li&gt;
&lt;li&gt;Kyverno-JSON&lt;/li&gt;
&lt;li&gt;OPA/Gatekeeper&lt;/li&gt;
&lt;li&gt;StackRox Minder&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-architecture&#34;&gt;Data Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ClickHouse&lt;/li&gt;
&lt;li&gt;Apache Pinot&lt;/li&gt;
&lt;li&gt;Apache Druid&lt;/li&gt;
&lt;li&gt;Cassandra&lt;/li&gt;
&lt;li&gt;ScyllaDB&lt;/li&gt;
&lt;li&gt;Hadoop HDFS&lt;/li&gt;
&lt;li&gt;Apache HBase&lt;/li&gt;
&lt;li&gt;Presto&lt;/li&gt;
&lt;li&gt;Trino&lt;/li&gt;
&lt;li&gt;Apache Spark&lt;/li&gt;
&lt;li&gt;Apache Flink&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Pulsar&lt;/li&gt;
&lt;li&gt;Fluid&lt;/li&gt;
&lt;li&gt;Memcached&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Alluxio&lt;/li&gt;
&lt;li&gt;Apache Superset&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vector-databases&#34;&gt;Vector Databases&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Milvus&lt;/li&gt;
&lt;li&gt;Chroma&lt;/li&gt;
&lt;li&gt;Weaviate&lt;/li&gt;
&lt;li&gt;Quadrant&lt;/li&gt;
&lt;li&gt;Pinecone&lt;/li&gt;
&lt;li&gt;Extensions
&lt;ul&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Postgres SQL&lt;/li&gt;
&lt;li&gt;ElasticSearch&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modelllm-observability&#34;&gt;Model/LLM Observability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Trulens&lt;/li&gt;
&lt;li&gt;Langfuse&lt;/li&gt;
&lt;li&gt;Deepchecks&lt;/li&gt;
&lt;li&gt;OpenLLMetry&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后，笔者梳理了以下关键观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开源社区的推动作用&lt;/strong&gt;：白皮书明确指出开源社区对云原生 AI 进步的推动作用，其中包括通过开源项目和广泛的合作来加速创新和降低成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云原生技术的重要性&lt;/strong&gt;：云原生 AI 是按照云原生原则构建和部署的，突出了可重复性和可扩展性的重要性。云原生技术为 AI 应用提供了高效的开发和运行环境，特别是在资源调度和服务可伸缩性方面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存在的挑战&lt;/strong&gt;：尽管云原生 AI 带来了诸多优势，但在数据准备、模型训练资源需求以及模型安全性和隔离性方面，仍面临不少挑战。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;未来发展方向&lt;/strong&gt;：白皮书提出的发展路径包括优化资源调度算法以支持 AI 负载，开发新的服务网格技术以提升性能和安全性，以及利用开源项目和社区合作进一步促进技术创新和标准化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键技术组件&lt;/strong&gt;：云原生 AI 涉及的关键技术包括容器、微服务、服务网格和无服务器计算等，其中 Kubernetes 扮演着 AI 应用部署和管理的中心角色，Istio 和 Envoy 等服务网格技术提供了必要的流量管理和安全保障。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关详情，请下载 &lt;a href=&#34;https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/&#34; title=&#34;云原生 AI 白皮书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生 AI 白皮书&lt;/a&gt;。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>后 Serverless 时代的云计算趋势分析</title>
      <link>https://jimmysong.io/trans/cloud-computing-post-serverless-trends/</link>
      <pubDate>Fri, 02 Feb 2024 13:05:42 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/cloud-computing-post-serverless-trends/</guid>
      <description>
        
        
        &lt;h2 id=&#34;主要观点&#34;&gt;主要观点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无服务器计算正在超越其最初的范围，函数部分或完全被多才多艺的云构件取代，标志着云架构的新时代。&lt;/li&gt;
&lt;li&gt;云市场正朝着高度专业化的垂直多云服务转变，提供独特的、精细粒度的功能，专门满足开发人员的需求。&lt;/li&gt;
&lt;li&gt;即将推出的云服务将充满构件，改变开发人员处理路由、过滤和事件触发等任务的方式，使其更高效和用户友好。&lt;/li&gt;
&lt;li&gt;从基础设施即代码转向构件即代码的趋势显著，开发人员使用熟悉的编程语言进行更直观的云服务配置。&lt;/li&gt;
&lt;li&gt;微服务正在云景观中重新定义，从仅仅是架构边界演变为组织边界，在统一的开发者语言下整合各种云构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS Lambda 将在今年迎来其 10 周年之际，无服务器计算不再仅限于“函数即服务”（FaaS）。今天，无服务器描述了不需要手动配置、提供按需自动扩展和使用基于消耗的定价的云服务。这一转变是云计算中更广泛演变的一部分，无服务器技术不断变革。本文关注无服务器之后的未来，探讨云景观将如何发展超越当前的超级扩展模型以及对开发人员和运营团队的影响。我将探讨塑造这一演变的前三大趋势。&lt;/p&gt;
&lt;h2 id=&#34;从基本构件到构件即服务&#34;&gt;从基本构件到构件即服务&lt;/h2&gt;
&lt;p&gt;在软件开发中，“模块”或“组件”通常指的是执行一组协同操作的自包含软件单元。这个概念与通常在长时间运行的计算服务（如虚拟机（VM）或容器服务）上运行的微服务架构相对应。AWS EC2 是第一个广泛可访问的云计算服务之一，提供可扩展的 VM。引入这样的可扩展、可访问的云资源为微服务架构变得实用和普及提供了基础。这种转变导致将庞大的应用程序分解成可独立部署的微服务单元。&lt;/p&gt;
&lt;p&gt;让我们继续使用软件单元的这个类比。函数是一个代码块，封装了一系列具有定义的输入和输出的单一任务的语句序列。这个代码单元与 FaaS 执行模型非常匹配。在事件触发无需管理基础架构的情况下执行代码的 FaaS 概念在 AWS Lambda 之前已经存在，但缺乏广泛的实施和认可。&lt;/p&gt;
&lt;p&gt;在 AWS Lambda 将 FaaS 带入主流之前，已经有了执行代码以响应事件而无需管理基础架构的 FaaS 概念，如 Google App Engine、Azure WebJobs、IronWorker 和 AWS Elastic Beanstalk 等服务。Lambda 作为 FaaS 的首个重大商业实施，通过简化开发人员的部署流程，成为其流行的催化剂。这一进步导致将微服务转变为更小的、可单独扩展的、事件驱动的操作。&lt;/p&gt;
&lt;p&gt;在向作为服务提供的更小软件单元的演进中，人们可能会想知道我们是否会看到基本的编程元素，如表达式或语句作为服务（例如 int x = a + b;）。然而，演进的方向与此不同。相反，我们正在见证函数的最小化和最终由可配置的云构件替代。在软件开发中，构件涵盖了诸如条件语句（if-else、switch 语句）、循环（for、while）、异常处理（try-catch-finally）或用户定义的数据结构等元素，这些元素在控制程序流程或管理复杂数据类型方面发挥着重要作用。在云服务中，构件与能够组成分布式应用程序的能力相一致，它们互相链接软件模块，如微服务和函数，并管理它们之间的数据流。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f1_hu8972661869961468882.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f1.jpg&#34; data-img=&#34;/trans/cloud-computing-post-serverless-trends/f1.jpg&#34; data-width=&#34;1231&#34; data-height=&#34;480&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;云构件取代函数，取代微服务，取代庞大的应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然以前可能使用函数来过滤、路由、批量处理、拆分事件，或调用另一个云服务或函数，但现在这些操作以及更多操作都可以在你的函数中使用更少的代码，或者在许多情况下根本不需要函数代码。它们可以被可配置的云构件替代，这些构件是云服务的一部分。让我们看一些 AWS 的具体示例，以演示从 Lambda 函数代码到云构件的过渡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求路由&lt;/strong&gt; - 不再使用 Lambda 来解析请求并将其路由到正确的后端端点，而是可以使用&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-routes.html&#34; title=&#34;API Gateway 路由&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 路由&lt;/a&gt;进行路由。而且，API Gateway 还可以与其他 AWS 服务集成，直接调用它们，消除了对函数的需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求验证&lt;/strong&gt; - API Gateway 可以使用 OpenAPI 验证请求的主体、查询字符串参数和标头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据转换&lt;/strong&gt; - API Gateway 可以使用 Apache Velocity 模板来&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html&#34; title=&#34;转换&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;转换&lt;/a&gt;请求和响应数据，以覆盖有效载荷、参数、标头和状态代码，而无需使用 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流式数据库更改&lt;/strong&gt; - &lt;a href=&#34;https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/&#34; title=&#34;DynamoDB Streams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DynamoDB Streams&lt;/a&gt;会发出所有数据更改。这对于任何数据存储来说都是一个必要的构件，消除了应用程序代码的双重写入和任何数据轮询代码，通过&lt;a href=&#34;https://www.infoq.com/articles/microservices-inside-out/&#34; title=&#34;将微服务内外颠倒&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将微服务内外颠倒&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件触发&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html&#34; title=&#34;AWS 事件源映射&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS 事件源映射&lt;/a&gt;允许通过从事件源读取并调用 Lambda 函数来触发 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件过滤&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html&#34; title=&#34;事件源映射&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;事件源映射&lt;/a&gt;可以执行事件过滤，以控制从流或队列中调用 Lambda 函数的哪些记录。这消除了在函数内编写过滤逻辑的需要，并大大减小了函数的大小和成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件批处理&lt;/strong&gt; - 类似地，事件源映射会将记录批处理成单个有效载荷，然后发送给你的函数。不需要手动循环聚合事件或在处理之前拆分它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件转换&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-input-transformation.html&#34; title=&#34;EventBridge Pipes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EventBridge Pipes&lt;/a&gt;可以在将数据发送到目标之前使用 JSON 路径语法来转换源数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件丰富化&lt;/strong&gt; - EventBridge Pipes 还可以调用另一个端点来丰富请求，然后进一步处理它。这提供了可以完全声明性使用的&lt;a href=&#34;https://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html&#34; title=&#34;内容丰富器模式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;内容丰富器模式&lt;/a&gt;的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件路由&lt;/strong&gt; - 与请求路由类似，EventBridge &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html&#34; title=&#34;规则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;规则&lt;/a&gt;可以执行事件路由，允许你从应用程序代码中卸载此责任，并消除 Lambda 函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于结果的路由&lt;/strong&gt; - Lambda &lt;a href=&#34;https://aws.amazon.com/blogs/compute/introducing-aws-lambda-destinations/&#34; title=&#34;Destination&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Destination&lt;/a&gt;允许异步调用将执行结果路由到其他 AWS 服务，以配置代码替换 Lambda 调用代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用其他服务&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-services.html&#34; title=&#34;StepFunction&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StepFunction&lt;/a&gt; 任务不需要 Lambda 函数来调用其他服务或外部 HTTP 端点。通过这种方式，StepFunction 任务定义可以执行例如&lt;a href=&#34;https://aws.amazon.com/blogs/aws/external-endpoints-and-testing-of-task-states-now-available-in-aws-step-functions/&#34; title=&#34;执行 HTTP 调用&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;执行 HTTP 调用&lt;/a&gt;或读取、更新和删除数据库记录等操作，而无需 Lambda 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是应用程序代码构件变成无服务器云构件的一些示例。你可以通过配置验证输入值，而不是在函数中使用 if-else 逻辑。你可以在函数之外声明性地定义路由逻辑，而不是使用 case 或 switch 语句从函数内调用其他代码。事件可以在数据更改时触发，批处理或拆分，无需重复构造，例如 for 或 while 循环。&lt;/p&gt;
&lt;p&gt;事件可以在没有函数的情况下进行验证、转换、批处理、路由、过滤和丰富。故障可以在没有 try-catch 代码的情况下进行处理和定向到 &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2023/06/amazon-sqs-dead-letter-queue-redrive-aws-sdk-cli/&#34; title=&#34;DLQs 和回退&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DLQs 和回退&lt;/a&gt;，而成功完成可以定向到其他函数和服务端点。将这些构件从应用程序代码移到构件配置中减少了应用程序代码的大小，或者将其移除，消除了安全修补和任何维护的需要。&lt;/p&gt;
&lt;p&gt;在编程中，原语和构件具有不同的含义和作用。原语是编程语言固有的基本数据类型。它包含了基本值，例如整数、浮点数、布尔值或字符，不包含其他类型。与此概念类似，云 - 就像一个巨大的编程运行时 - 正在从基础设施原语（如网络负载均衡器、虚拟机、文件存储和数据库）进化为更精致和可配置的云构件。&lt;/p&gt;
&lt;p&gt;与编程构件类似，这些云构件编排分布式应用程序交互并管理复杂的数据流。然而，这些构件不是孤立的云服务；没有独立的“过滤器服务”或“事件发射器服务”。没有“构件作为服务”，但它们越来越成为核心云原语（如网关、数据存储、消息代理和函数运行时）的重要功能。&lt;/p&gt;
&lt;p&gt;这种演进降低了应用程序代码的复杂性，并在许多情况下消除了自定义函数的需求。这从 FaaS 到 NoFaaS（无麻烦，意味着简单）的转变刚刚开始，有深入的&lt;a href=&#34;https://www.youtube.com/watch?v=sdCA0Y7QDrM&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;和 GitHub 上的代码示例。接下来，我将探讨垂直多云服务中构件丰富的云服务的出现。&lt;/p&gt;
&lt;h2 id=&#34;从超大规模到超专业化&#34;&gt;从超大规模到超专业化&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.diagrid.io/blog/evolution-of-cloud-computing&#34; title=&#34;无服务器后云时代&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器后云时代&lt;/a&gt;，仅提供高度可扩展的云原语（如容器和函数的计算，或诸如键/值存储、事件存储、关系数据库或网络原语等存储服务）已经不再足够。无服务器后云服务必须富含开发者构件，并卸载应用程序的大部分基础设施。这超越了为广泛用户群体进行通用云服务的超大规模；它涉及深度专业化，并向更具要求的用户公开高级构件。&lt;/p&gt;
&lt;p&gt;像 AWS、Azure、GCP 等超大规模云服务提供商，凭借其广泛的服务范围和庞大的用户群体，很好地把握了新用户需求和构件。然而，提供这些更细粒度的开发者构件会增加复杂性。每个服务中的每个新构件都需要深入学习曲线以了解其有效利用的特定内容。因此，在无服务器后时代，我们将看到垂直多云服务的兴起，这些服务在一个领域表现出色。这代表了云服务的超专业化。&lt;/p&gt;
&lt;p&gt;以 Confluent Cloud 为例。虽然所有主要的超大规模云服务提供商（AWS、Azure、GCP 等）都提供 Kafka 服务，但没有一家能够与 Confluent Cloud 提供的开发者体验和构件相匹配。通过其 Kafka 代理、众多的 Kafka 连接器、集成的模式注册表、Flink 处理、数据治理、跟踪和消息浏览器，Confluent Cloud 提供了最丰富和专业化的 Kafka 服务，超越了超大规模云服务提供商的提供。&lt;/p&gt;
&lt;p&gt;这种趋势并不孤立；许多例子包括 MongoDB Atlas 与 DocumentDB、GitLab 与 CodeCommit、DataBricks 与 EMR、RedisLabs 与 ElasticCache 等。除了已建立的云公司外，新一波初创公司正在崭露头角，专注于一个多云原语（如专业化的计算、存储、网络、构件流水线、监控等）并通过开发者构件来丰富它，以提供独特的价值主张。以下是一些专门化于单一开源技术的云服务，旨在提供丰富的构件体验，并吸引用户远离超大规模云服务提供商：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://vercel.com/&#34; title=&#34;Vercel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vercel&lt;/a&gt;：以其出色的前端开发者体验而闻名，简化了 Web 应用程序的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://railway.app/&#34; title=&#34;Railway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Railway&lt;/a&gt;：以增强后端开发者体验以及简单的部署和扩展管理而著名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://supabase.com/&#34; title=&#34;Supabase&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Supabase&lt;/a&gt;：是 Firebase 的开源替代方案，提供更灵活的相似功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://fauna.com/&#34; title=&#34;Fauna&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fauna&lt;/a&gt;：以声明性关系查询和强一致性事务中的功能业务逻辑而闻名的无服务器数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://neon.tech/&#34; title=&#34;Neon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Neon&lt;/a&gt;：提供最简单的无服务器 PostgreSQL，具有数据库分支和最小管理开销等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://planetscale.com/&#34; title=&#34;PlanetScale&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PlanetScale&lt;/a&gt;：以高级 MySQL 云服务而闻名，侧重于开发友好的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://polyscale.ai/&#34; title=&#34;PolyScale&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PolyScale&lt;/a&gt;：专注于通过智能缓存优化数据性能的 AI 驱动缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://upstash.com/&#34; title=&#34;Upstash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstash&lt;/a&gt;：提供全托管的低延迟无服务器 Kafka 解决方案，适用于事件流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.diagrid.io/catalyst&#34; title=&#34;Diagrid Catalyst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diagrid Catalyst&lt;/a&gt;：提供用于消息、数据和工作流的无服务器 Dapr API，充当云服务之间的连接纽带。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://temporal.io/&#34; title=&#34;Temporal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Temporal&lt;/a&gt;：提供持久的执行，为可靠管理复杂工作流程提供平台。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个列表代表了一个不断增长的生态系统的一部分，这个生态系统是建立在超大规模云服务提供商提供的核心云原语之上的垂直多云服务。它们通过提供一套全面的可编程构件和增强的开发者体验来竞争。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f2_hu4870722511835164064.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f2.jpg&#34; data-img=&#34;/trans/cloud-computing-post-serverless-trends/f2.jpg&#34; data-width=&#34;1188&#34; data-height=&#34;669&#34; alt=&#34;image&#34; data-caption=&#34;无服务器云服务通过丰富的开发人员构造，超专业地处理一件事&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;无服务器云服务通过丰富的开发人员构造，超专业地处理一件事&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;一旦完成了这个过渡，缺乏丰富构件的基本云服务，甚至是无服务器的云服务，都会显得像过时的本地软件。存储服务必须像 DynamoDB 一样流式传输更改；消息代理应包括类似于 EventBridge 的构件，用于事件驱动的路由、过滤和终端点调用，包括重试和 DLQs；发布/订阅系统应提供消息批处理、拆分、过滤、转换和丰富功能。&lt;/p&gt;
&lt;p&gt;最终，虽然超大规模云服务提供商通过不断增加的服务数组在水平方向扩展，但超专业化服务提供商在垂直方向增长，提供一个丰富构件的最佳服务，形成一个&lt;a href=&#34;https://www.infoq.com/articles/cloud-bound-applications/&#34; title=&#34;生态系统&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生态系统&lt;/a&gt;的垂直多云服务。云服务竞争的未来将从基础设施原语转向核心云原语和面向开发者的构件的组合。&lt;/p&gt;
&lt;h2 id=&#34;从基础设施到组合即代码cac&#34;&gt;从基础设施到组合即代码（CaC）&lt;/h2&gt;
&lt;p&gt;云构件越来越模糊了应用程序和基础设施职责之间的界限。下一个演进是云自动化的“左移”，将应用程序和自动化代码集成为工具和责任的一部分。让我们看看这个过渡是如何展开的。&lt;/p&gt;
&lt;p&gt;云基础设施管理的第一代是由基础设施即代码（IaC）定义的，这是一种旨在简化基础设施的供应和管理的模式。这种方法建立在云计算中虚拟化的商品化趋势的基础上。&lt;/p&gt;
&lt;p&gt;最初的 IaC 工具引入了专门用于以可重复的方式创建、配置和管理云资源的领域特定语言（DSL）。像 Chef、Ansible、Puppet 和 Terraform 这样的工具引领了这个阶段。这些工具利用了声明性语言，允许运维团队以代码定义基础设施的期望状态，抽象出底层的复杂性。&lt;/p&gt;
&lt;p&gt;然而，随着云计算从低级粗粒度基础设施过渡到更面向开发者的可编程细粒度构件，使用现有通用编程语言来定义这些构件的趋势正在兴起。新的参与者，如 Pulumi 和 AWS Cloud Development Kit（CDK），处于这一浪潮的前沿，支持诸如 TypeScript、Python、C#、Go 和 Java 等语言。&lt;/p&gt;
&lt;p&gt;采用通用编程语言的转变是由于需要克服声明性语言的局限性，后者在以编程方式定义云构件方面缺乏表现力和灵活性，并且由于云构件配置的责任从运维转向开发者。与适用于低级静态基础设施的声明性语言的静态性质不同，通用编程语言使开发者能够定义动态、逻辑驱动的云构件，实现与应用程序代码更紧密的对齐。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f3_hu12704838490734470684.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-computing-post-serverless-trends/f3.jpg&#34; data-img=&#34;/trans/cloud-computing-post-serverless-trends/f3.jpg&#34; data-width=&#34;1060&#34; data-height=&#34;602&#34; alt=&#34;image&#34; data-caption=&#34;将应用程序的组成从基础设施转移到开发人员团队&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;将应用程序的组成从基础设施转移到开发人员团队&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;无服务器后云开发人员需要通过创建函数和微服务来实现业务逻辑，但还需要使用可编程云构件将它们组合在一起。这塑造了更广泛的开发者责任集，用于开发和组合云应用程序。例如，具有 Lambda 函数中的业务逻辑的代码还需要 API Gateway 中的路由、过滤和请求转换配置。&lt;/p&gt;
&lt;p&gt;另一个 Lambda 函数可能需要 DynamoDB 流配置来流式传输特定数据更改，EventBridge 路由、过滤和丰富配置。&lt;/p&gt;
&lt;p&gt;第三个应用程序可能将其大部分编排逻辑表达为 StepFunction，其中 Lambda 代码只是一个小任务。开发者，而不是平台工程师或运维成员，可以将这些代码单元组合在一起。工具，如 Pulumi、AWS CDK 和其他工具，允许开发者使用他们选择的语言来实现函数，并使用相同的语言来组合它与云环境的交互，最适合这个时代。&lt;/p&gt;
&lt;p&gt;平台团队仍然可以使用声明性语言，比如 Terraform，来管理、保护、监视和启用云环境中的团队，但以开发者为重点的构件，结合以开发者为重点的云自动化语言，将云构件向左移动，并使开发者能够自助使用云服务成为现实。&lt;/p&gt;
&lt;p&gt;从 DSL 到通用编程语言的过渡标志着 IaC 演进的重要里程碑。它承认了应用程序代码向云构件的过渡，这些构件通常需要开发者更深入地控制资源以满足应用程序需求。这个转变代表了 IaC 工具的成熟，现在需要满足更广泛的基础设施编排需求，为更复杂、更高级的抽象和工具铺平了道路。&lt;/p&gt;
&lt;p&gt;基础设施管理的过程将从静态配置转向更加动态、基于代码的方法。这一演进不仅仅止步于基础设施即代码，它正在超越到一个更加微妙的领域，被称为组合即代码。这一范式进一步模糊了应用程序代码和基础设施之间的界限，导致更加流畅、高效和开发者友好的实践。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结趋势及其加强效应，我们观察到编程构件逐渐整合到云服务中。每个计算服务都将集成 CI/CD 流水线；数据库将提供来自边缘的 HTTP 访问并发出更改事件；消息代理将通过过滤、路由、幂等性、转换、DLQ 等功能增强能力。&lt;/p&gt;
&lt;p&gt;基础设施服务正在演变为无服务器 API、从代码中推断的基础设施 (&lt;a href=&#34;https://klo.dev/state-of-infrastructure-from-code-2023/&#34; title=&#34;IfC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IfC&lt;/a&gt;)、&lt;a href=&#34;https://vercel.com/blog/framework-defined-infrastructure&#34; title=&#34;框架定义的基础设施&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;框架定义的基础设施&lt;/a&gt;，或由开发者明确组合 (CaC)。这一演进导致了更小的函数，有时甚至是 NoFaaS 模式，为超专业化、以开发者为先的垂直多云服务铺平了道路。这些服务将提供&lt;a href=&#34;https://thenewstack.io/raising-the-serverless-bar-infrastructure-apis-unleash-more-value-for-enterprises/&#34; title=&#34;可编程 API 的基础设施&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可编程 API 的基础设施&lt;/a&gt;，使开发者能够无缝地使用他们喜欢的编程语言合并其应用程序。&lt;/p&gt;
&lt;p&gt;使用云服务进行应用程序构件的左移将与应用程序编程越来越融合，将微服务从一种架构风格转变为一种组织风格。一个微服务将不再只是一个单一的部署单元或过程边界，而是由开发者选择的单一语言中实现和粘合的函数、容器和云构件组成。未来正在成为超专业化，并专注于以开发者为先的云。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>云原生关乎文化，而不是容器</title>
      <link>https://jimmysong.io/trans/cloud-native-culture-not-container/</link>
      <pubDate>Thu, 18 Mar 2021 11:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/cloud-native-culture-not-container/</guid>
      <description>
        
        
        &lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/cloud-native-culture/&#34; title=&#34;Cloud-Native Is about Culture, Not Containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Native Is about Culture, Not Containers&lt;/a&gt;，文章洋洋洒洒上万字，作者总结了她见过的云原生失败的各种经验教训，还用生动的示例说明了什么不是云原生。译者是在周末闲暇时间仓促间翻译的，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要一味的微服务，就可以做到非常的云原生。&lt;/li&gt;
&lt;li&gt;在开始云原生转型之前，必须明确云原生对你的团队意味着什么，以及要解决的真正问题是什么。&lt;/li&gt;
&lt;li&gt;如果发布涉及繁琐的仪式，不经常发布，而且所有的微服务都必须同时发布，那么微服务架构的好处将无法得到落实。&lt;/li&gt;
&lt;li&gt;持续集成和部署是你要做的事情，而不是你买的工具。&lt;/li&gt;
&lt;li&gt;过度的治理扼杀了云的效率，但如果你对消耗的东西不够重视，就会造成严重的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在去年的伦敦 QCon 大会上，我提供了一个关于文化而非容器的云原生会议。让我开始思考文化在云原生中的作用的是 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; title=&#34;Bilgin Ibryam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilgin Ibryam&lt;/a&gt; 一篇很棒的 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; title=&#34;InfoQ 文章&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 文章&lt;/a&gt;。Bilgin 做的其中一件事是将云原生架构定义为很多微服务，通过智能管道连接。我看了之后，觉得它看起来完全不像我写的应用，尽管我认为我在写云原生应用。我是 IBM Garage 的一员，帮助客户实现云原生，然而我很少在我的应用中使用微服务。我创建的应用大多看起来和 Bilgin 的图完全不一样。这是否意味着我做错了，或者说云原生的定义可能有点复杂？&lt;/p&gt;
&lt;p&gt;我不想把 Bilgin 单列出来，因为 Bilgin 的文章叫《后 Kubernetes 时代的微服务》，所以如果他在那篇文章中不是经常说到微服务，那就有点可笑了。事实也是如此，几乎所有关于云原生的定义都把它等同于微服务。无论在哪里，我都不断看到这样的假设：微服务等于云原生，云原生等于微服务。就连云原生计算基金会（CNCF）也曾经把云原生定义为：都是微服务，都是容器，还有一点动态编排在里面。说云原生并不总是涉及微服务，这让我陷入了这个特殊的境地，因为我不仅说 Bilgin 错了，我还说云原生计算基金会错了 —— 他们对云原生了解过什么？我相信我知道的比他们多得多吧？&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu1775834249164848466.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;671&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;显然我不知道在这个问题上，我站在了历史的错误一边。我承认这一点。虽然我站错了历史的一边，但我注意到 CNCF 已经更新了他们对云原生的定义，虽然微服务和容器仍然存在，但它们似乎不像以前那样必须，所以这一点历史可能在我这边！）。不管对不对，我还是要死在我的小山头上，那个 Cloud Native 是关于比微服务更大的东西。微服务是一种方式。它们不是唯一的方式。&lt;/p&gt;
&lt;p&gt;事实上，在我们的社区中，你确实看到了一系列的定义。如果你问一堆人 Cloud Native 是什么意思，有些人会说 &amp;ldquo;生长在云上&amp;rdquo;。这是非常原始的 Cloud Native 定义，早在微服务还没有出现的时候就已经有了。有人会说这是微服务。&lt;/p&gt;
&lt;p&gt;有人会说，&amp;ldquo;哦，不对，不只是微服务，是 Kubernetes 上的微服务，这样才有 Cloud Native&amp;rdquo;。这个我不喜欢，因为在我看来，Cloud Native 不应该是一个技术选择的问题。有时候我看到 Cloud Native 被当做 DevOps 的同义词，因为很多云原生的原则和实践和 DevOps 教的东西很相似。&lt;/p&gt;
&lt;p&gt;有时，我看到云原生的用法只是作为一种说 &amp;ldquo;我们正在开发现代软件&amp;rdquo; 的方式。&amp;ldquo;我们将使用最佳实践；它将是可观察的；它将是健壮的；我们将经常发布，并使一切自动化；简而言之，我们将采用过去 20 年所学到的一切，并以这种方式开发软件，这就是云原生的原因&amp;rdquo;。在这个定义中，云只是一种必然 —— 当然是在云上，因为我们是在 2021 年开发的。&lt;/p&gt;
&lt;p&gt;有时候我看到 Cloud Native 只是用来指云。我们听惯了 Cloud Native，以至于每次说到 Cloud 的时候，都觉得要在后面加上一个 &amp;ldquo;Native&amp;rdquo;，但其实我们只是在说 Cloud。最后，当人们说 Cloud Native 的时候，有时候他们的意思是 idempotent（幂等的）。这个问题是，如果你说 Cloud Native 的意思是 idempotent，其他人就会说：&amp;quot; 什么？我们说的 idempotent 真正的意思是可复用？如果我把它拿去，把它关了，然后再启动，运行结果跟之前也是一样的。这是对云上服务的一个基本要求。”&lt;/p&gt;
&lt;p&gt;有了这些不同的定义，难怪我们在做 Cloud Native 的时候，并不能完全确定我们要做的是什么。&lt;/p&gt;
&lt;h2 id=&#34;为什么&#34;&gt;为什么？&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;我们到底想实现什么？&amp;rdquo; 这是一个非常重要的问题。当我们在思考技术选择和技术风格的时候，我们要从 &amp;ldquo;我做 Cloud Native 是因为别人都在做退到思考我到底想解决什么问题？&amp;rdquo; 为了公平对待 CNCF，他们在对云原生的定义前面就有这个 &amp;ldquo;为什么&amp;rdquo;。他们说：&amp;quot; 云原生就是使用微服务来更快地构建伟大的产品。我们使用微服务不仅仅是因为我们想使用，我们使用微服务是因为微服务帮助我们更快地构建伟大的产品。”&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hu4579786315492663414.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3.jpg&#34; data-width=&#34;932&#34; data-height=&#34;827&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;我们退一步确保我们理解要解决的问题。为什么我们之前不能更快地打造出优秀的产品？很容易跳过这一步，我想我们所有人有时候都会犯这样的毛病。有时候我们真正要解决的问题是，别人都在做，所以我们害怕错过，除非我们开始做。一旦我们这样说，FOMO（错失恐惧症）就不是一个很好的决策标准。更糟糕的是，&amp;ldquo;我的简历看起来很沉闷&amp;rdquo; 绝对不是选择技术的正确理由。&lt;/p&gt;
&lt;h2 id=&#34;为什么是云&#34;&gt;为什么是云？&lt;/h2&gt;
&lt;p&gt;我认为要想知道为什么我们应该以云原生的方式来做事情；我们要退一步说：&amp;ldquo;为什么我们在云上做事情？&amp;rdquo; 以下是原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt;：当我们刚开始把东西放在云上的时候，价格是主要的动机。我们说：&amp;ldquo;我有这个数据中心，我必须支付电费，我必须支付人员维护它。而且我必须购买所有的硬件。当我可以使用别人的数据中心时，我为什么要这么做呢？&amp;rdquo; 在自己的数据中心和别人的数据中心之间形成成本节约的原因是，自己的数据中心必须为最大需求储备足够的硬件。这有可能是大量的容量，而这些容量在大部分时间是没有使用的。如果是别人的数据中心，你可以集中资源。当需求低迷时，你不会为额外的容量付费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弹性&lt;/strong&gt;。云计算为你省钱的原因就是因为它的弹性。你可以扩大规模；你可以缩小规模。当然，这已经是旧闻了。我们都认为弹性是理所当然的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;：我们现在之所以对云感兴趣，是因为速度。不一定是硬件的速度，虽然有些云硬件的速度可以快得让人眼花缭乱。云是使用 GPU 的一个很好的方式，这多少也是使用量子计算机的唯一方式。不过，更普遍的是，我们可以通过云端将一些东西以某种方式、某种方式更快地推向市场，这比我们不得不将软件打印到光盘上，然后邮寄给人们，甚至比我们不得不在自己的数据中心站立实例的时候还要快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-因素&#34;&gt;12 因素&lt;/h2&gt;
&lt;p&gt;节约成本、弹性和交付速度都很好，但我们只要在云端就能得到这些。为什么我们需要云原生？我们需要云原生的原因是，很多公司发现他们试图上云，结果被电死了。&lt;/p&gt;
&lt;p&gt;事实证明，云上的东西需要用不同的方式来编写和管理。把这些不同的地方阐述出来，就形成了 12 因素。这 12 个因素是对你应该如何编写云应用的一系列规定，这样你就不会被电死。&lt;/p&gt;
&lt;p&gt;你可以说这 12 个因素描述了如何编写云原生应用 —— 但这 12 个因素与微服务完全没有关系。它们都是关于你如何管理应用的状态。它们是关于如何管理你的日志。12 个因素帮助应用程序变得幂等化，但 &amp;ldquo;12 因素&amp;rdquo; 比 &amp;ldquo;幂等化因素&amp;rdquo; 更吸引人。&lt;/p&gt;
&lt;p&gt;这 12 个因素是在 Docker 进入市场前两年发布的。Docker 容器彻底改变了云的使用方式。容器如此之好，很难夸大其重要性。它们解决了很多问题，创造了新的架构可能性。因为容器是如此的简单，所以可以将一个应用分布在许多容器上。有些公司在 100、200、300、400 或 500 个不同的容器上运行单个应用。与这样的工程实力相比，一个应用如果仅仅分布在 6 个容器上，似乎有点不够用。面对如此少的复杂性，人们很容易想到 &amp;ldquo;我一定是做错了。我还不如那边的开发者呢&amp;rdquo;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hu1129105341698603180.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;703&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;事实上，这不是比拼你能拥有多少个容器。容器是很好的，但你拥有的容器数量应该根据你的需求进行调整。&lt;/p&gt;
&lt;h2 id=&#34;速度&#34;&gt;速度&lt;/h2&gt;
&lt;p&gt;让我们试着回忆一下 —— 你的需求又是什么？当我们想到云的时候，我们通常要考虑的是速度。我们之所以想要大量的容器，是因为我们想要更快地将新的东西推向市场。如果我们有很多容器，我们要么把完全一样的东西推向市场，要么以同样的速度推向市场，那么突然之间，这些容器只是一种成本。它们并没有帮助我们，我们正在消耗周期来管理将应用分散在基础设施上的小块应用所带来的复杂性。如果我们有这个神奇的架构，可以让我们对市场做出反应，但我们没有做出反应，那就是一种浪费。如果我们有这个架构，意味着我们可以快速发展，但是我们没有快速发展，那么这也是一种浪费。&lt;/p&gt;
&lt;h2 id=&#34;如何在云原生中失败&#34;&gt;如何在云原生中失败&lt;/h2&gt;
&lt;p&gt;这让我想到了如何在云原生中失败。关于我的背景，我是一个顾问。我是 IBM Garage 的全栈开发人员。我们与初创公司和大公司合作，帮助他们上云，并从云中获得最大的好处。作为其中的一部分，我们帮助他们解决有趣的、艰难的问题，我们帮助他们以比以前更快的速度做软件。为了确保我们真的能从云端获得最大的收益，我们做了精益创业、极限编程、设计思维、DevOps；以及云原生。因为我是一个顾问，所以我看到很多客户都在云计算的旅程中。有时候很顺利，有时候也会有这些陷阱。以下是我看到聪明的客户掉进的一些陷阱。那么，什么是云原生？&lt;/p&gt;
&lt;p&gt;最早的一个陷阱就是关于云原生的意思。如果我说云原生，我是一个意思，而你说云原生，又是另一个意思，我们的沟通就会有问题&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;有时候这并不重要，但有时候却有很大的不同。如果一个人认为目标是微服务，然后另一个人觉得目标是拥有一个幂等的系统，呃哦。或者说，如果一个组织的一部分人想上云，因为他们认为云可以让他们更快地进入市场，但另一部分人上云只是为了和以前完全一样的速度，但更具成本效益，那么我们可能会在以后的道路上发生一些冲突。&lt;/p&gt;
&lt;h2 id=&#34;微服务环境&#34;&gt;微服务环境&lt;/h2&gt;
&lt;p&gt;通常情况下，促使人们对目标产生一些困惑的原因之一是，我们有一种自然的倾向，即看到其他人做着奇妙的事情，并想效仿他们。我们想自己去做那些奇妙的事情，而没有真正思考我们的环境和它们是否适合。我们的一位 IBM 研究员在去和客户谈微服务的时候，有一个启发式的方法。他说：&amp;ldquo;如果他们开始谈论 Netflix，而他们只是一直在谈论 Netflix，他们从来没有提到连贯性，也没有提到耦合，那么可能他们做这件事的原因并不正确。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;有时候我们和客户聊天，他们说：&amp;ldquo;对，我想现代化到微服务。&amp;rdquo; 好吧，微服务不是目标。没有客户会看着你的网站说，&amp;ldquo;哦，微服务。这很好。&amp;rdquo; 客户会看你的网站，并根据它是否满足他们的需求，是否简单和令人愉快，以及，所有这些其他事情来判断它。微服务可以是达到这个目的的一个很好的手段，但它们本身并不是一个目标。我还应该说：微服务是一种手段。它们不一定是实现这一目标的唯一手段。&lt;/p&gt;
&lt;p&gt;我在 IBM Garage 的一位同事与亚太地区的一家银行进行了一些对话。这家银行在响应客户时遇到了问题，因为他们的软件都很老旧、沉重和钙化。他们也遇到了人员问题，因为他们所有的 COBOL 开发人员都老了，而且都要离开工作岗位。因此，银行知道他们必须进行现代化改造。在这个案例中，主要的驱动力不是劳动力的老化，而是竞争力和灵活性。他们被竞争对手打败了，因为他们拥有大量的 COBOL 代码，而每次改变都是昂贵而缓慢的。他们说：&amp;ldquo;好吧，为了解决这个问题，我们需要摆脱所有的 COBOL，我们需要切换到现代微服务架构。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;到目前为止，还不错。我们正准备跳进一些云原生的好东西时，银行又说他们的发布板一年只开两次会。这时，我们又收手了。不管银行的新架构会有多少微服务，这些微服务都会被组装成一个大的单体发布包，每年部署两次。这就是拿了微服务的开销，却没有好处。因为这不是一场看你有多少容器的比赛，大量的容器和缓慢的发布将是一个绝对没有人赢的堆栈。&lt;/p&gt;
&lt;p&gt;大量的微服务被锁定在一个迟缓的发布节奏中，不仅不会是一种胜利，还可能是一种糟糕的损失。当组织尝试微服务时，他们并不总是像图片中的那样，最终得到一个美丽的解耦微服务架构。相反，他们最终得到的是一个分布式单体。这就像一个普通的单体，但要糟糕得多。之所以说这是格外可怕的坏事，是因为一个正常的、非分布式的单体有诸如编译时检查类型和同步的、有保证的内部通信。在单进程中运行会损害你的可扩展性，但这意味着你不能被分布式计算的谬误所困扰。如果你把同样的应用程序，然后只是在互联网上涂抹，不投入任何类型检查或投资于网络问题的错误处理，你不会有更好的客户体验，你会有更糟糕的客户体验。&lt;/p&gt;
&lt;p&gt;在很多情况下，微服务是错误的答案。如果你是一个小团队，你不需要有很多自主的团队，因为每个独立的团队会有大约四分之一的人。假设你没有任何计划，也不希望独立发布部分应用，那么你不会从微服务的独立性中获益。&lt;/p&gt;
&lt;p&gt;为了在你的应用程序的所有这些组件之间提供安全和可靠的通信和可发现性，你刚刚抹过云的一部分，你将需要类似服务网格的东西。你可能在技术曲线上很先进，或者对这个技术曲线有点陌生。你要么不知道服务网格是什么，要么你说：&amp;ldquo;我都知道服务网格是什么。那么复杂，那么夸张。我不需要服务网格。我只想自己搞一个服务网格。&amp;rdquo; 这不一定会给你带来你所希望的结果。你最终还是会得到一个服务网格，但你必须维护它，因为它是你写的！不做微服务的另一个很好的理由是，有时候领域模型就是没有那些天然的断裂点，让你得到漂亮整洁的微服务。在这种情况下，完全有理由说：&amp;ldquo;你知道吗？我就不做了。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;云原生面条&#34;&gt;云原生面条&lt;/h2&gt;
&lt;p&gt;如果你不从杂乱中走出来，那么你最终会遇到下一个问题，那就是云原生面条。当我看 Netflix 微服务的通信图时，我总觉得有些恐慌。我确信他们知道自己在做什么，而且他们已经想好了，但在我眼里，它看起来完全像意大利面条。让它发挥作用需要很多真正扎实的工程和专门的技能。如果你不具备这种专业性，那么你最终会陷入混乱的局面。&lt;/p&gt;
&lt;p&gt;我被邀请去给一个正在苦苦挣扎的客户做一些支持工作。他们正在开发一个绿地应用，所以他们当然选择了微服务，以尽可能的现代化。他们对我说的第一句话就是：&amp;ldquo;只要我们修改任何代码，其他的东西就会坏掉。&amp;rdquo; 这不是微服务应该发生的事情。事实上，这与我们都被告知如果我们实现微服务会发生的情况完全相反。微服务的梦想是它们是解耦的。遗憾的是，解耦并不是免费的。它当然不会因为你分布式的东西而神奇地发生。当你分布式的东西时，所发生的是你有两个问题而不是一个问题。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hu4961726468971929667.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;723&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;云原生面条还是面条。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的客户的代码之所以这么脆弱，耦合性这么强，其中一个原因是他们的对象模型相当复杂，大约有 20 个类，部分类中有 70 个字段。在微服务系统中处理这种复杂的对象模型是很难的。在这种情况下，他们看了看他们复杂的对象模型，决定：&amp;ldquo;我们知道在我们的微服务之间有共同的代码是非常不好的，因为这样我们就没有解耦。相反，我们要在我们所有的六个微服务中复制和粘贴这个共同的对象模型。因为我们剪切和粘贴它，而不是链接到它，所以我们是解耦的。&amp;rdquo; 嗯，不，你不是解耦的。如果当一件事情发生变化的时候，不管是链接还是复制代码，事情就会中断，这就是耦合。&lt;/p&gt;
&lt;p&gt;在这种情况下，什么是 &amp;ldquo;正确&amp;rdquo; 的做法？在理想的情况下，每个微服务都会整齐地映射到一个域上，而且它们很有区别。如果你有一个大域和很多微小的微服务，那就会有问题了。解决的办法是，要么决定领域真的很大，然后合并微服务，要么做更深层次的领域建模，尝试把对象模型解开，变成不同的边界上下文。&lt;/p&gt;
&lt;p&gt;即使是最干净的域分离，在任何系统中，组件之间总会有一些接触点 —— 这才是系统的本质。这些接触点很容易出错，即使它们是最小的，尤其是当它们是隐藏的。你还记得 &amp;ldquo;火星气候轨道器&amp;rdquo; 吗？与 &amp;ldquo;毅力号&amp;rdquo; 不同的是，它被设计为在安全距离内绕着火星运行，而不是在火星上着陆。遗憾的是，它离火星太近了，被火星的引力拉了进去，然后坠毁了。探测器的失利令人惋惜，根本原因就是个悲剧。轨道器由两个模块控制，一个是探测器，一个是地球上的模块。探测模块是半自主的，因为从地球上大部分时间看不到轨道器。大约每隔三天，行星就会对准，它就会出现在视野中，地球上的团队就会微调它的运行轨迹我猜想当时的指令是这样的：&amp;ldquo;哦，我想你需要向左移动一点，哦，如果你不向右移动一点，你就会错过火星。&amp;rdquo; 除了数字。&lt;/p&gt;
&lt;p&gt;数字是导致问题的原因。地球模块和探测模块是由两个不同的团队建造的两个不同的系统。探测器使用的是英制单位，而 JPL 地面团队使用的是公制单位。尽管这两个系统看起来是独立的，但它们之间有一个非常重要的耦合点。每次地面团队传送指令时，他们发送的指令都会以一种谁也想不到的方式进行解释。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu5327888880384522127.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;747&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;这个故事的寓意是，分布式系统没有帮助。一部分系统在火星上，一部分系统在地球上，你不能比这更分散。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服务需要消费者驱动的接触测试&#34;&gt;微服务需要消费者驱动的接触测试&lt;/h2&gt;
&lt;p&gt;在这种情况下，解决方案，正确的做法是真正明确耦合点是什么，双方各自的期望值是什么。一个很好的方法就是消费者协议驱动的测试（Contract-driven Test）。尽管接触测试（Contract Test）是解决一个大问题的干净利落的办法，但在我们这个行业还没有被广泛使用。我认为部分问题是，它们可能有点棘手，难以学习，这减缓了采用的速度。关于测试的跨团队谈判也会很复杂 —— 尽管如果关于测试的谈判太难，关于实际交互参数的谈判会更难。如果你正在考虑探索接触测试，Spring Contract 或 Pact 是不错的起点。哪一个适合你，取决于你的环境。Spring Contract 很好地集成到了 Spring 生态系统中，而 Pact 是框架无关的，并且支持大量的语言，包括 Java 和 Javascript。&lt;/p&gt;
&lt;p&gt;接触测试远远超出了 OpenAPI 验证的作用，因为它检查的是 API 的语义，而不仅仅是语法。它比 &amp;ldquo;好吧，两边的字段都有相同的名字，所以我们很好。&amp;rdquo; 这是个更有用的检查，它允许你检查，&amp;ldquo;当我得到这些输入时，我的行为是否是预期的行为？我在那边命名的关于那个 API 的假设是否仍然有效？&amp;rdquo; 这些都是你需要检查的东西，因为如果它们不是真的，事情就会变得非常糟糕。&lt;/p&gt;
&lt;p&gt;很多公司都意识到了这个风险，也意识到做微服务的时候系统有不稳定的地方。为了有信心这些东西能一起工作，他们在发布之前会施加一个 UAT 阶段。在任何微服务发布之前，需要有人花几周时间测试它在更广泛的系统中是否正常工作。有了这样的开销，发布不会经常发生。那么这就引出了经典的反模式，那就是不连续的持续集成和持续部署，或者说 I/D。&lt;/p&gt;
&lt;h3 id=&#34;为什么持续集成而不持续部署&#34;&gt;为什么持续集成而不持续部署&lt;/h3&gt;
&lt;p&gt;我和很多客户交流，他们会说：&amp;ldquo;我们有一个 CI/CD。&amp;rdquo; 这给我们敲响了警钟，因为 CI/CD，不应该是你买了一个工具，放在服务器上，然后欣赏，说 &amp;ldquo;有 CI/CD。&amp;ldquo;CD/CD 是你必须要做的事情。这两个字母分别代表持续集成和持续部署或交付。连续在这里意味着 &amp;ldquo;真的经常集成&amp;rdquo; 和 &amp;ldquo;真的经常部署&amp;rdquo;，如果你没有做到这一点，那么根本就不是连续。&lt;/p&gt;
&lt;p&gt;有时候我会无意中听到这样的评论：&amp;ldquo;下周我就把我的分支合并到我们的 CI 系统中&amp;rdquo;。这完全忽略了 &amp;ldquo;CI&amp;rdquo; 中的 &amp;ldquo;C&amp;rdquo;，它代表的是持续。如果你每周合并一次，那就不是连续。这几乎是连续的反义词。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;D&amp;rdquo; 部分可能会更加困难。如果软件每半年才部署一次，CI/CD 服务器可能很有用，但是没有人做 CD。可能有 &amp;ldquo;D&amp;rdquo;，但大家都忘记了 &amp;ldquo;C&amp;rdquo; 的部分。&lt;/p&gt;
&lt;p&gt;到底多长时间推送一次才是合理的？连续性得有多连续？甚至我也承认，一些严格定义的连续会是一个团队中写软件的可笑方式。如果你把每一个角色都推到 main，这在技术上是连续的，但它会在团队中造成混乱。如果你每次提交都集成，并且目标是每小时提交几次，这可能是一个很好的节奏。如果你经常提交，每隔几次提交就集成一次，那么你每天推送几次，这样也是很好的。如果你做的是测试驱动的开发，那么当你得到一个合格的测试时，集成是一个很好的模式。我很提倡基于主干的开发（TBD）。TBD 在调试、实现机会主义重构、避免同事出现大的意外等方面有很多好处。基于主干的开发的技术定义是，你需要每天至少集成一次才算。我有时会听到 &amp;ldquo;每天一次&amp;rdquo; 被描述为 &amp;ldquo;还好&amp;rdquo; 和 &amp;ldquo;就是不连续&amp;rdquo; 之类的。一周一次就真的很成问题了。&lt;/p&gt;
&lt;p&gt;一旦你每个月一次，那就太可怕了。当我加入 IBM 的时候，我们用的是一个构建系统和一个代码仓库，叫 CMVC。对于背景来说，这大概是二十年前的事情，我们整个行业都比较年轻，比较愚蠢。我在 IBM 的第一份工作是帮助构建 WebSphere 应用服务器。我们有一个大型的多站点构建，团队每周有六天开会，包括周六，讨论任何构建失败的问题。那个电话有很多重点，你不希望在 WebSphere 构建电话中被叫起来。我刚从大学毕业，对团队中的软件开发一窍不通，所以一些资深的开发人员把我收在了他们的手下。我至今还记得的一个建议是，避免被 WebSphere 构建调用的方法是将你所有的修改在本地机器上保存半年，然后全部批量推送。&lt;/p&gt;
&lt;p&gt;在这个项目上，我还小，我想，好吧，这似乎不是很正确的建议，但我想你最清楚。事后看来，我意识到 WebSphere 的构建破坏得很严重，因为人们将他们的变化保存了六个月，然后才试图与他们的同事进行整合。很明显，那是行不通的，我们改变了做事的方式。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu10370175428266049858.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;631&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;你应该多久整合一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个更难的问题是，你应该多久发布一次？和集成一样，有一个合理的选择范围。你可以每次推送都发布。许多技术公司都这样做。如果你每次迭代部署一次，你还是很有优势的。一个季度发布一次就有点悲哀了。你可以每两年发布一次。现在看来慢得荒唐，但在糟糕的过去，这是我们行业的标准模式。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu5188933177799260295.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;516&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;多久应该部署到生产中一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以每次推送都能部署到生产中，是因为部署不等于发布。如果我们的新代码太不完整或者太吓人，无法真正展示给用户，我们仍然可以部署它，但要把它隐藏起来。我们可以让代码实际存在于生产代码库中，但没有任何东西与之相连。这样就很安全了。如果我们已经有点太纠结了，我们可以使用功能标志来翻开和关闭功能。如果我们感觉更冒险，我们可以做 A/B 或亲朋好友测试，这样只有一小部分用户看到我们可怕的代码。金丝雀部署是另一种变化，用于预先检测噩梦，在它们进入主流使用之前。&lt;/p&gt;
&lt;p&gt;不发布有两个不好的后果。它延长了反馈周期，这会影响决策，并使工程师感到悲伤。从经济上讲，这也意味着有库存（工作软件）坐在货架上，而不是送到客户手中。精益原则告诉我们，有库存放在那里，不产生退货，就是浪费。&lt;/p&gt;
&lt;p&gt;那么话题就是，为什么我们不能发布这个？是什么阻止了更频繁的部署？很多组织害怕他们的微服务，他们希望对整个组件进行集成测试，通常是手动集成测试。有一个客户，有大约 60 个微服务，他们希望确保不存在某个聪明的工程师火花可以发布一个微服务而不发布其他 59 个微服务的可能性。为了强制执行这一点，他们为所有的微服务大批量地设置了一个单一的管道。这显然不是微服务的价值取向，即微服务是可以独立部署的。可悲的是，这是他们觉得最安全的方式。&lt;/p&gt;
&lt;p&gt;我们也看到了因为对质量和完整性的担忧，实际上不愿意交付。当然，这些并不荒唐。你不想激怒你的客户。另一方面，就像里德・霍夫曼所说的那样，如果你没有因为第一次发布而感到尴尬，那就太晚了。持续改进是有价值的，让东西被使用也是有价值的。&lt;/p&gt;
&lt;p&gt;如果发布的频率不高，而且是单体的，你就有了这些漂亮的微服务架构，可以让你走得更快，然而你走得很慢。这是坏的业务，也是坏的工程。&lt;/p&gt;
&lt;p&gt;假设你选择了频繁部署。所有保护你的用户不受半成品功能影响的东西，比如自动测试、功能标志、A/B 测试、SRE，都需要大量的自动化。通常当我开始与客户合作时，我们有一个关于测试的问题，他们说：&amp;ldquo;哦，我们的测试不是自动化的。&amp;rdquo; 这意味着他们实际上不知道代码是否在任何特定的点上工作。他们希望它能工作，而且上次检查时可能已经工作了，但我们没有任何办法在不运行手动测试的情况下知道它现在是否工作。&lt;/p&gt;
&lt;p&gt;问题是，退步是会发生的。即使所有的工程师都是最完美的工程师，也有一个不那么完美的外部世界。他们所依赖的系统可能会有意想不到的行为。如果一个依赖更新改变了行为，即使没有人做错任何事情，也会有一些东西被破坏。这就回到了 &amp;ldquo;我们不能交付是因为我们对质量没有信心&amp;rdquo; 的问题上。好吧，让我们解决对质量的信心问题，然后我们就可以交付了。&lt;/p&gt;
&lt;p&gt;我谈到了合同测试。这很便宜，也很简单，可以在单元测试层面进行，当然，你也需要自动化集成测试。你不希望依赖手动集成测试，否则它们会成为瓶颈。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;CI/CD&amp;rdquo; 似乎已经取代了我们词汇中的 &amp;ldquo;构建&amp;rdquo;，但在这两种情况下，它都是你作为一个工程组织所拥有的最有价值的东西之一。它应该是你的朋友，它应该是这种无处不在的存在。有时候构建的方式是，它在某个地方的 Jenkins 系统上被关闭了。稍微勤快一点的人时不时去检查一下网页，发现是红色的，就去告诉同事，最后有人把问题解决了。更好的是只是一个被动的构建指标，大家都可以看到，而不需要单独打开一个页面来查看。如果显示器红了，真的很明显，那就是有变化了，而且很容易看最近的变化。如果你有一个项目，红绿灯就可以用。如果你有微服务，你可能会需要类似一组磁贴的东西。即使你没有微服务，你可能会有好几个项目，所以你需要比红绿灯更完整一点的东西，尽管红绿灯很可爱。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu16877492534438684657.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;753&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;我们不知道什么时候构建好了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你投资你的构建监控，那么你最终会出现破窗的情况。我到了客户那里，第一件事就是看了一下构建，我说：&amp;ldquo;哦，这个构建好像坏了。&amp;rdquo; 他们说：&amp;ldquo;是啊，已经坏了几个星期了。&amp;rdquo; 这时，我就知道我有很多工作要做了！&lt;/p&gt;
&lt;p&gt;为什么一个“破窗”的构建是不好的？这意味着你无法进行自动化集成测试，因为没有任何东西能从构建中做出来。事实上，你甚至无法进行手动集成测试，所以服务间的兼容性可能会恶化，而且没有人会知道。&lt;/p&gt;
&lt;p&gt;新的回归没有被发现，因为这个构建已经红了。也许最糟糕的是，它创造了一种文化，所以当其他构建中的一个红色时，人们并不那么担心，因为它更多的是相同的：&amp;ldquo;现在我们有两个红色。也许我们可以弄到整套的，然后如果我们把它们都弄红了，就能匹配了。&amp;rdquo; 嗯，不，不应该是这样的。&lt;/p&gt;
&lt;h2 id=&#34;锁定的完全僵化的不灵活的云雾缭绕的云端&#34;&gt;锁定的完全僵化的、不灵活的、云雾缭绕的云端&lt;/h2&gt;
&lt;p&gt;这些都是发生在团队层面的挑战。它们是关于我们作为工程师如何管理自己和我们的代码。但当然，尤其是当你到了一定规模的组织，你最终会面临另一系列的挑战，那就是组织如何使用云。我注意到，有些组织喜欢把云，变成一个锁定的、完全僵化的、灵活的、没有云的云。&lt;/p&gt;
&lt;p&gt;如何让一个云端不云端？你说：&amp;ldquo;好吧，我知道你可以走得很快，我知道你所有的自动化支持都走得很快，但是我们有一个流程。我们有一个架构评审委员会，它的会议相当不频繁。&amp;rdquo; 它将在项目准备交付后一个月开会，或者在最坏的情况下，它将在项目已经交付后一个月开会。虽然东西已经交付了，但我们还是在走流程。架构将在已经在现场验证后进行纸面审查，这是愚蠢的。&lt;/p&gt;
&lt;p&gt;有人曾经给我讲过一个故事。一个客户向他们抱怨说，IBM 卖给他们的一些配置软件不能用。当时我们承诺我们的精巧的配置软件可以让他们在十分钟内创建虚拟机。这是几年前的事了，当时 &amp;ldquo;10 分钟创建一个虚拟机&amp;rdquo; 是很先进很酷的。我们向他们承诺，这将是美好的。&lt;/p&gt;
&lt;p&gt;当客户安装好它并开始使用时，他们并没有发现它的美妙。他们以为他们会得到 10 分钟的供应时间，但他们看到的是，他们花了三个月的时间来供应一个云实例。他们回来找我们，他们说：&amp;ldquo;你们的软件完全坏了。你卖错了。你看，花了三个月的时间。&amp;rdquo; 我们对此感到疑惑，于是我们进去做了一些调查。事实证明，发生了什么事，他们创建了一个 84 步的预批准程序，以获得其中的一个实例。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu7915683902544711385.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;805&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;这款供应软件已经坏了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术有了，但文化没有，所以技术没有用。这是可悲的。我们把这个云，这是一个美丽的云，它有所有这些神奇的属性，它让一切都变得非常简单，然后组织的另一部分人说，&amp;ldquo;哦，这有点可怕。我们不会希望人们真的能够做事情。让我们把它关进笼子里吧！&amp;rdquo; 那种老式的重文案的治理方式是行不通的 —— 同时也是真的让大家很烦。它不会给出结果。更糟糕的是，它实际上不会让事情变得更安全。它可能会使他们更不安全。它肯定会让事情变得更慢，而且要花钱。我们不应该这样做。&lt;/p&gt;
&lt;p&gt;我和另一个客户聊过，那是一家大型汽车公司，他们在云计算供应方面遇到了真正的问题。他们花了很长的时间来获得实例。他们认为，&amp;ldquo;我们要解决这个问题的方法是我们要从供应商 A 转移到供应商 B。&amp;rdquo; 这可能会奏效，但实际上缓慢的问题是他们的内部采购。切换供应商会绕过他们既定的采购流程，所以可能会加快一段时间，但最终，他们的治理团队会注意到新的供应商，并实施控制。一旦发生这种情况，他们就会将监管落实到位，然后恢复现状。他们所有的成本会改变，但实际上没有任何的好处。这有点像，我很抱歉地说，我有时会受到这样的诱惑 —— 如果你看着你的炉子，你决定，&amp;ldquo;哦，那个烤箱很脏。清理很困难，所以我要搬家，所以我没有清洁烤箱。&amp;rdquo; 但后来，当然，同样的事情发生在其他房子，和新的烤箱变得肮脏。你需要一个更可持续的过程，而不是仅仅更换供应商来试图超越自己的采购。&lt;/p&gt;
&lt;p&gt;如果只有开发者在改变，如果只有开发者在走 Cloud Native 的道路，那么就是行不通的。这并不意味着开发者驱动的自由竞争是正确的模式。如果周围没有一些治理，那么云就会变成一个神秘的钱坑。我们很多人都遇到过这样的问题：看着云账单，觉得 &amp;ldquo;嗯。是啊，这么多，我也不明白钱都花到了哪里，也不明白是谁花的。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;用云端配置硬件是如此简单，但这并不意味着硬件是免费的。还是要有人为它付费。硬件很容易配置，也不能保证硬件有用。&lt;/p&gt;
&lt;p&gt;当我刚开始学习 Kubernetes 的时候，我当然也尝试过。我创建了一个集群，但后来我就偏离了轨道，因为我有太多的工作在进行。过了两个月，我又回到我的集群，发现这个集群一个月大约 1000 英镑&amp;hellip;&amp;hellip; 而且是完全没有价值的。太浪费了，我现在想起来还觉得恶心。&lt;/p&gt;
&lt;p&gt;我们的技术使我们能够做的很多事情都是为了提高效率。伟大的管理顾问彼得・德鲁克说过：&amp;ldquo;没有什么比高效地做那些根本不应该做的事情更无用的了。&amp;rdquo; 高效地创建没有价值的 Kubernetes 集群，这不是好事。除了成本高，还有对生态环境的影响。让一个 Kubernetes 集群消耗价值 1000 英镑的电力，什么都不做，对地球不是很好。&lt;/p&gt;
&lt;p&gt;对于我说的很多问题，最初看起来是技术问题，其实是人的问题。我觉得这个有点不一样，因为这个看似是人的问题，其实是技术问题。这个领域其实工具可以帮助我们。比如说，工具可以帮助我们管理浪费，可以检测到闲置的服务器，帮助我们把服务器追溯到发起人。这方面的工具还没有，但已经越来越成熟了。&lt;/p&gt;
&lt;h2 id=&#34;云管理你的云&#34;&gt;云管理你的云&lt;/h2&gt;
&lt;p&gt;这个云管理的工具化最后是在云上，所以你最后是在递归的情况下，要有一些云来管理你的云。我的公司有一个多云管理器，它会看你的工作负载，找出工作负载的形状，从财务上来说，你能让它上的最优化的供应商是什么，然后自动进行这种迁移。我预计我们可能会开始看到越来越多这样的软件，它在看它，然后说：&amp;ldquo;顺便说一下，我可以告诉他的 Kubernetes 集群其实没有流量，它已经在那里待了两个月了。你为什么不去和 Holly 说几句话呢？&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;微服务运维混乱&#34;&gt;微服务运维混乱&lt;/h2&gt;
&lt;p&gt;管理云成本越来越复杂，这反映了一个更普遍的事情，就是云运维越来越复杂。我们正在使用越来越多的云供应商。有越来越多的云实例涌现出来。我们到处都有集群，那么我们到底该如何为这些集群做运维呢？这就是 SRE (Site Reliability Engineering) 的作用。&lt;/p&gt;
&lt;p&gt;网站可靠性工程的目的是使操作更加可重复，减少繁琐，以使服务更加可靠。它实现这一目标的方法之一是将一切自动化，我认为这是一个令人钦佩的目标。像发布这样的事情，我们越是自动化，我们就越能做到，这对工程师和消费者来说都是好事。最终的目标应该是，发布不是一个事件，而是一切照旧。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu8920005715120833991.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;936&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;使发布深感无聊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以能够有这种无聊的感觉，是我们对可回收性有信心，是 SRE 让我们对可回收性有信心。&lt;/p&gt;
&lt;p&gt;我有另一个悲伤的太空故事，这次是来自苏联。在 80 年代，一位工程师想对苏联一个叫 &amp;ldquo;Phobos&amp;rdquo; 的太空探测器的代码进行更新。当时，它是机器代码，都是 0 和 1，而且都是手写的。很显然，你不想用手写的机器代码对一个绕着地球飞驰的航天器进行实时更新，而不进行一些检查。在任何推送之前，代码都会经过验证器，验证器相当于机器代码的 linter。&lt;/p&gt;
&lt;p&gt;这样做很好，直到自动检查器坏了，这时需要进行更改。一位工程师说：&amp;ldquo;哦，但我真的想做这个改动。我就绕过自动检查器，直接把我的代码推送给空间探测器，因为，我的代码当然是完美的。&amp;rdquo; 于是，他们用手写的机器代码，在没有检查的情况下，对绕着地球飞驰的航天器进行了实时更新。能出什么问题呢？&lt;/p&gt;
&lt;p&gt;发生的是一个非常微妙的 bug。一切似乎都在正常工作。不幸的是，工程师忘记了其中一个指令的零点。这就改变了指令，从原来的指令变成了停止探测器的充电鳍旋转的指令。Phobos 号的翅片会转向太阳方向，这样无论它朝向哪个方向，都能收集太阳能。两天来一切都很好，直到电池没电了。一旦探测器没电了，他们就没办法恢复它，因为整个东西都死了。&lt;/p&gt;
&lt;p&gt;这就是一个完全无法恢复的系统的例子。一旦它死了，你就再也找不回来了。你不能只是做一些事情，然后把它恢复到一个干净的空间探测代码副本，因为它在太空中。&lt;/p&gt;
&lt;p&gt;这样的系统是真正无法恢复的。我们很多人认为，我们所有的系统几乎都和空间探测器一样无法恢复，但事实上，只有极少数系统可以恢复。&lt;/p&gt;
&lt;p&gt;我们真正想做的是在这个频谱的顶端，我们可以在几毫秒内恢复，没有数据丢失。如果有任何问题，只是，&amp;ldquo;ping，它被修复&amp;rdquo;。如果有什么问题，它只是，&amp;ldquo;ping，它的固定&amp;rdquo;。这真的很难达到，但有一大堆中间点是现实的目标。&lt;/p&gt;
&lt;p&gt;如果我们恢复的速度很快，但是数据丢失了，那就不太好了，但是我们可以接受。如果我们有交接和人工干预，那对于恢复的速度会慢很多。当我们在考虑频繁部署和部署的时候，非常无聊 —— 我们要有信心，我们在那个上端。我们到达那里的方式，交接不好，自动化，好。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu2732659888055949288.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;802&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;云原生成功的方法&#34;&gt;云原生成功的方法&lt;/h2&gt;
&lt;p&gt;这篇文章包含了一大堆关于我所看到的可能出错的事情的悲惨故事。我不想给你留下一个印象，即所有的事情都会出错，因为很多时候，事情确实非常正确。云原生是一种奇妙的软件开发方式，它可以让团队感觉更好，降低成本，让用户更快乐。作为工程师，我们可以把更少的时间花在辛苦和繁琐的事情上，而把更多的时间花在真正想做的事情上&amp;hellip;&amp;hellip; 我们可以更快地进入市场。&lt;/p&gt;
&lt;p&gt;要想达到这种快乐的状态，我们必须在整个组织中保持一致。我们不能让一群人说微服务，一群人说快，一群人说老式治理。这几乎肯定是行不通的，会有很多脾气暴躁的工程师和委屈的财务人员。相反，一个组织应该在整体层面上达成共识，它要实现的目标是什么。一旦同意了这个目标，就应该对反馈进行优化，确保反馈回路尽可能短，因为这才是合理的工程。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu18332011089532744322.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb.jpg&#34; data-img=&#34;/trans/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb.jpg&#34; data-width=&#34;177&#34; data-height=&#34;208&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>“寒武纪大爆发”之后的云原生，2021 年走向何处？</title>
      <link>https://jimmysong.io/blog/cloud-native-2021/</link>
      <pubDate>Thu, 28 Jan 2021 08:34:40 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cloud-native-2021/</guid>
      <description>
        
        
        &lt;p&gt;很荣幸收到 CSDN 的邀请，接受”云原生人物志“专栏采访，其实我从 2017 年起就已经在撰写 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; title=&#34;Kubernetes 和云原生年度总结和新年展望&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 和云原生年度总结和新年展望&lt;/a&gt;，今天在此聊抒己见，欢迎大家讨论和指正。&lt;/p&gt;
&lt;h2 id=&#34;云原生在演进&#34;&gt;云原生在演进&lt;/h2&gt;
&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生 1.0 的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得&lt;strong&gt;云原生从基础设施层不断向应用架构层挺进&lt;/strong&gt;，我们正处于一个云原生 2.0 的新时代。&lt;/p&gt;
&lt;h2 id=&#34;业界动向&#34;&gt;业界动向&lt;/h2&gt;
&lt;p&gt;最近国内的一些云厂商，如阿里云、腾讯云、华为云陆续发布了各自的云原生相关的架构和实践白皮书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020 年 7，中国信通院发布了《云原生产业白皮书（2020）》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 20 日，在腾讯 2020 Techo Park 开发者大会上，腾讯云正式发布了《云原生最佳实践路线图》，同时发布的还有一份 3 万多字的《腾讯云原生路线图手册》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 23 日，阿里云原生实战峰会上发布了《云原生架构白皮书》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 30 日，华为云在深圳的 TechWave 云原生 2.0 技术峰会上联合 Forrester 发布了《云原生白皮书：拥抱云原生优先战略》。&lt;/li&gt;
&lt;li&gt;2021 年初，阿里巴巴达摩院发布 2021 十大科技趋势，其中将“云原生重塑 IT 技术体系”作为 2021 年技术预测之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生项目的寒武纪大爆发&#34;&gt;云原生项目的“寒武纪大爆发”&lt;/h2&gt;
&lt;p&gt;云原生已历经”寒武纪大爆发“，标志是从 2018 年 Kubernetes 毕业 后走向深耕路线。云原生领域的开源项目层出不穷，令人眼花缭乱，见我收集的 Awesome Cloud Native。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu16126431682930808006.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk.jpg&#34; data-width=&#34;945&#34; data-height=&#34;229&#34; alt=&#34;image&#34; data-caption=&#34;云原生发展阶段&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生发展阶段&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;2020 年 CNCF 共接纳了 35 个项目加入基金会，并且有多个项目毕业或晋级，CNCF 托管的项目总数达到了 80 多个。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_hu4509324518130977485.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh.jpg&#34; data-width=&#34;945&#34; data-height=&#34;679&#34; alt=&#34;image&#34; data-caption=&#34;图片来自 CNCF 年度报告 2020&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图片来自 CNCF 年度报告 2020&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;云原生之争实际上是标准之争&#34;&gt;云原生之争实际上是标准之争&lt;/h2&gt;
&lt;p&gt;PC 端操作系统 Windows 占据上风，移动端是 iOS 和 Android，服务器端是 Linux，而云计算商用分布式操作系统呢？答案是 Kubernetes。&lt;/p&gt;
&lt;p&gt;2020 年 Kubernete 宣布将&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110520682&#34; title=&#34;在 v1.20 版本之后弃用 Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 v1.20 版本之后弃用 Docker&lt;/a&gt;，实际上 Docker 本来就不是 Kubernetes 中默认和唯一的的容器运行时了，实际上只要是支持 CRI（Container Runtime Interface）或 OCI（Open Container Initiative）标准的容器运行时都可以在 Kubernetes 中运行。如下图所示，容器，英文是 container，也是集装箱的意思，其实集装箱不止一种型号，根据运送的货物的不同特性可以制定了多种集装箱类型。而这个容器类型是标准只能是由 Kubernetes 来定，否则只能是削足适履。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqbb2lj30q90enwpl_hu14303326112604340642.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqbb2lj30q90enwpl.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vqbb2lj30q90enwpl.jpg&#34; data-width=&#34;945&#34; data-height=&#34;527&#34; alt=&#34;image&#34; data-caption=&#34;各种容器类型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;各种容器类型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Kubernetes 统一了云上的资源对象制定和调度的标准，只要在其标准之上开发 CRD 和 Operator 即可。但是这也仅限于单个应用的管理，如何管理复杂的多集群和混合云环境，如何管理应用间流量，如何如何保证调用链的安全？以 Istio 为代表的服务网格就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;云原生趋势云上应用管理&#34;&gt;云原生趋势：云上应用管理&lt;/h2&gt;
&lt;p&gt;Kubernetes 奠定了云原生基础设施的基础，随着而来的监控、存储、AI、大数据等技术的迁移，从单个应用层面来说已经日趋成熟，而在&lt;strong&gt;使用云原生架构尤其是对云上应用的管理&lt;/strong&gt;，而在异构环境、多集群、混合云等已成为常态的情况下，&lt;strong&gt;如何对云上的应用进行管理，成为棘手的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 以其开创新的声明式 API 和调节器模式，奠定了云原生的基础。我们看到 Google 的项目 Anthos，Azure 的 Arc，AWS 最近开源的 EKS-D，它们都是着重在混合云管理，让云无处不在。另外，服务网格（Service Mesh）经过两年的推广和发酵，将会看到越来越多的应用。&lt;/p&gt;
&lt;h2 id=&#34;云原生与开源社区&#34;&gt;云原生与开源社区&lt;/h2&gt;
&lt;p&gt;目前&lt;strong&gt;企业云原生化转型最缺乏的东西 —— 套路和组合拳&lt;/strong&gt;。对于基础软件，企业往往会选择开源项目并根据自身需求进行改造，而云原生的开源项目又有很多，企业不是没有选择，而是选择太多，以致于无从下手。就像下面教你如何画猫头鹰的示例。我们可以将企业的云原生化的愿景想象成是这只猫头鹰，这些开源项目就像步骤一中圆，你可能想当然的认为只要用了 Kubernetes 就是云原生了，这就像画了两个圆，而剩余部分没有人教你如何完成。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu17053021916841653795.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y.jpg&#34; data-width=&#34;945&#34; data-height=&#34;629&#34; alt=&#34;image&#34; data-caption=&#34;如何画猫头鹰&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;如何画猫头鹰&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;开源社区的核心是面向开发者，就是向开发者灌输如何来画好这只“猫头鹰”的。开源不意味着免费和做慈善，使用开源也是有代价的。&lt;strong&gt;开源社区存在的意义是平衡开发者、终端用户及供应商之间的共同利益&lt;/strong&gt;，而一个中立的开源社区有利于发挥开源的生态优势。&lt;/p&gt;
&lt;p&gt;近年来随着云原生大热，在美国诞生了大量该领域的初创公司，他们基于 AWS、谷歌云、Azure 等提供各种云原生的解决方案，从每次 KubeCon 的赞助商规模上就可以窥知一二。国内该领域的公司目前还不多，而云原生终端用户社区的公司规模上依然跟国外的公司数量有不小的差距。&lt;/p&gt;
&lt;p&gt;云原生社区就是在这样的背景下于 2020 年初由我发起，开始筹备并在 5 月 12 号正式成立，致力于推广云原生技术，构建开发者生态。云原生社区采取 SIG（特别兴趣小组）和 WG（工作组）的组织形式，基于开源项目和不同的专业领域构建研讨组，与厂商合作定期举办线下 meetup，并邀请社区的专家们定期在 B 站的云原生学院进行直播。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;开源应该关注的是终端用户和开发者生态，用 Apache Way 来说就是“社区大于代码”，没有社区的项目是难以长久的。因此我们可以看到国内一些云厂商开源项目之后也会积极投入运营，举行各种各样的活动。我们看到在云原生的推广过程中，CNCF 起到的相当大的作用，2020 年国内也有类似的基金会成立，我们希望看到更多中立的基金会和社区的成立，更多的厂商参与其中，为终端用户提供更佳的解决方案。&lt;/p&gt;
&lt;p&gt;最后感谢 CSDN 宋慧编辑和「CSDN 云计算」的邀请。&lt;/p&gt;
&lt;p&gt;往期报道见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/112293560&#34; title=&#34;梁胜：做开源项目的贡献者没有意义&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;梁胜：做开源项目的贡献者没有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/FL63Zv9Zou86950w/article/details/110433443&#34; title=&#34;华为云 CTO 张宇昕：云原生已经进入深水区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;华为云 CTO 张宇昕：云原生已经进入深水区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110508201&#34; title=&#34;APISIX 温铭：开源的本质是要拿开发者的杠杆&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX 温铭：开源的本质是要拿开发者的杠杆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人介绍&#34;&gt;个人介绍&lt;/h2&gt;
&lt;p&gt;在我的职业生涯里先后从事过 Java 开发、大数据运维、DevOps、开源管理等工作，个人爱好是研究并推广开源技术及理念，摄影和旅行。目前在企业级服务网格初创公司 Tetrate 担任 Developer Advocate，同时作为中立的云原生终端用户社区 —— 云原生社区（Cloud Native Community）的负责人。&lt;/p&gt;
&lt;p&gt;我的整个职业生涯都是与开源息息相关的，渊源可以追溯到大学时期。大学时我就开始使用 Linux 系统（Ubuntu）学习，刚进入职场的时候面向的也是 Hadoop 的开源生态及各种开源中间件，2015 起开始接触 Docker，2016 年开始进入云原生领域，2017 年开始写 Kubernetes 领域的第一本开源中文电子书《&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&lt;/a&gt;》，本书直到如今仍在更新，2018 年在蚂蚁集团做开源管理及服务网格社区 ServiceMesher，2020 年加入基于 Istio、Envoy 和 Apache SkyWalking 等开源项目而构建企业级服务网格的初创公司 Tetrate。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Sun, 18 Oct 2020 14:18:40 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</guid>
      <description>
        
        
        &lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; title=&#34;Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; title=&#34;CoreOS rkt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; title=&#34;Mesos Containerizer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; title=&#34;LXC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; title=&#34;服务网格 (Service Mesh)&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; title=&#34;Kubernetes 次世代的云原生应用&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; title=&#34;Minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; title=&#34;MicroK8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; title=&#34;Docker Desktop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; title=&#34;Kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; title=&#34;Katacoda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; title=&#34;Microsoft Bridge to Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; title=&#34;telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; title=&#34;资源管道和全度量管道&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; title=&#34;Nagios&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; title=&#34;Prometheus Alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; title=&#34;Awesome Cloud Native/云原生开源项目大全&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读&lt;a href=&#34;https://kubernetes.io&#34; title=&#34;官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;和实践来学习，也可以参考我编写的&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的&lt;a href=&#34;https://cloudnative.to&#34; title=&#34;云原生社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的&lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; title=&#34;云原生学院&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt;定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>Kubernetes 次世代的云原生应用</title>
      <link>https://jimmysong.io/blog/post-kubernetes-era/</link>
      <pubDate>Mon, 01 Jun 2020 18:13:19 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/post-kubernetes-era/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 自开源至今已经走过六个年头了，&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34; title=&#34;云原生时代&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代&lt;/a&gt;也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为&lt;a href=&#34;https://jimmysong.io/guide-to-cloud-native-app&#34; title=&#34;《云原生应用白皮书》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《云原生应用白皮书》&lt;/a&gt;的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。&lt;/p&gt;
&lt;h2 id=&#34;重点&#34;&gt;重点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。&lt;/li&gt;
&lt;li&gt;Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。&lt;/li&gt;
&lt;li&gt;Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。&lt;/li&gt;
&lt;li&gt;OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。&lt;/li&gt;
&lt;li&gt;“Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生&lt;strong&gt;应用&lt;/strong&gt;架构的时代即将到来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。&lt;/p&gt;
&lt;h2 id=&#34;云原生的不同发展阶段&#34;&gt;云原生的不同发展阶段&lt;/h2&gt;
&lt;p&gt;Kubernetes 从开源至今已经走过快&lt;a href=&#34;https://jimmysong.io/cloud-native/memo/open-source/&#34; title=&#34;六个年头&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;六个年头&lt;/a&gt;（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-stages_hu4384996722894030006.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-stages.png&#34; data-img=&#34;/blog/post-kubernetes-era/cloud-native-stages.png&#34; data-width=&#34;2096&#34; data-height=&#34;508&#34; alt=&#34;image&#34; data-caption=&#34;云原生的发展阶段&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生的发展阶段&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：孵化期（2014 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：高速发展期（2015 年 - 2016 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：野蛮生长期（2017 年 - 2018 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是&lt;a href=&#34;https://jimmysong.io/blog/service-mesh-the-microservices-in-post-kubernetes-era/&#34; title=&#34;后 Kubernetes 时代的微服务&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;后 Kubernetes 时代的微服务&lt;/a&gt;，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF &lt;a href=&#34;https://www.cncf.io/blog/2018/03/06/kubernetes-first-cncf-project-graduate/&#34; title=&#34;毕业&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;毕业&lt;/a&gt;，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; title=&#34;2017 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年&lt;/a&gt;和 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html&#34; title=&#34;2018 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2018 年&lt;/a&gt;的预测和总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四阶段：普及推广期（2019 年至今）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-开辟了云原生时代&#34;&gt;Kubernetes 开辟了云原生时代&lt;/h2&gt;
&lt;p&gt;Kubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。&lt;/p&gt;
&lt;p&gt;下图是 Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/post-kubernetes-era/kubernetes-concepts_hu1453962404286550081.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/kubernetes-concepts.png&#34; data-img=&#34;/blog/post-kubernetes-era/kubernetes-concepts.png&#34; data-width=&#34;800&#34; data-height=&#34;596&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 概念&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes 概念&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;图片来自图书 &lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34; title=&#34;Kubernetes Patterns（O’Reilly）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Patterns（O’Reilly）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 作为云原生基础设施设计之初遵循了以下原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础设施即代码（声明式 API）&lt;/li&gt;
&lt;li&gt;不可变基础设施&lt;/li&gt;
&lt;li&gt;幂等性&lt;/li&gt;
&lt;li&gt;调节器模式（Operator 的原理）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他&lt;a href=&#34;https://jimmysong.io/cloud-native-infra/evolution-of-cloud-native-developments.html&#34; title=&#34;云部署形式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云部署形式&lt;/a&gt;的主要区别之一，这也为后来的 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;Operator 框架的诞生&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator 框架的诞生&lt;/a&gt;打下了基础。&lt;/p&gt;
&lt;h3 id=&#34;声明式-api&#34;&gt;声明式 API&lt;/h3&gt;
&lt;p&gt;根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？&lt;/p&gt;
&lt;p&gt;我们在创建 &lt;code&gt;Deployment&lt;/code&gt; 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用&lt;a href=&#34;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#monitoring-admission-webhooks&#34; title=&#34;动态准入控制&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;动态准入控制&lt;/a&gt;来达到这一点。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-原生应用&#34;&gt;Kubernetes 原生应用&lt;/h3&gt;
&lt;p&gt;我们都知道要想运行一个应用至少需要以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。&lt;/li&gt;
&lt;li&gt;应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。&lt;/li&gt;
&lt;li&gt;应用的生命周期管理（各种 Controller 登场）。&lt;/li&gt;
&lt;li&gt;可观测性、可运维、网络和资源及环境依赖、隔离性等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/kubernetes-native-application-motion.gif&#34; data-img=&#34;/blog/post-kubernetes-era/kubernetes-native-application-motion.gif&#34; data-width=&#34;600&#34; data-height=&#34;334&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 原生应用&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes 原生应用&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;我们都知道 Kubernetes 提供了大量的&lt;a href=&#34;https://kubernetes.io/docs/concepts/&#34; title=&#34;原语&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原语&lt;/a&gt;，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 &lt;a href=&#34;https://github.com/openkruise/kruise&#34; title=&#34;OpenKruise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenKruise&lt;/a&gt;、Istio），实际上 &lt;a href=&#34;https://operatorhub.io/&#34; title=&#34;Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator&lt;/a&gt; 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。&lt;/p&gt;
&lt;p&gt;Kubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。&lt;/p&gt;
&lt;p&gt;我将 Kubernetes 原生应用所需要的定义和资源进行了分层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心层&lt;/strong&gt;：应用逻辑、服务定义、生命周期控制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离与服务访问层&lt;/strong&gt;：资源限制与隔离、配置、身份、路由规则等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度层&lt;/strong&gt;：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源层&lt;/strong&gt;：提供网络、存储和其他平台资源；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。&lt;/p&gt;
&lt;p&gt;云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。&lt;/p&gt;
&lt;p&gt;同一个资源对象又有多种实现方式，比如 Ingress 就有 &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k/edit#gid=0&#34; title=&#34;10 多种实现&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10 多种实现&lt;/a&gt;，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/resources-motion.gif&#34; data-img=&#34;/blog/post-kubernetes-era/resources-motion.gif&#34; data-width=&#34;600&#34; data-height=&#34;363&#34; alt=&#34;image&#34; data-caption=&#34;资源交集动画&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;资源交集动画&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。&lt;/p&gt;
&lt;p&gt;为了管理这些应用诞生出了众多的 &lt;a href=&#34;https://github.com/operator-framework/awesome-operators&#34; title=&#34;Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator&lt;/a&gt;。Kubernetes 1.7 版本以来就引入了&lt;a href=&#34;https://kubernetes.io/docs/concepts/api-extension/custom-resources/&#34; title=&#34;自定义控制器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义控制器&lt;/a&gt;的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API 进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods/Services、对正在运行的应用进行扩缩容。&lt;/p&gt;
&lt;p&gt;Operator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式的四个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的输入和输出都使用数据结构。&lt;/li&gt;
&lt;li&gt;确保数据结构是不可变的。&lt;/li&gt;
&lt;li&gt;保持资源映射简单。&lt;/li&gt;
&lt;li&gt;使实际状态符合预期状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;云原生应用走向碎片化&#34;&gt;云原生应用走向碎片化&lt;/h2&gt;
&lt;p&gt;利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生应用碎片化的体现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 模式将运维人员的反应式经验转化成基于 &lt;code&gt;Reconcile&lt;/code&gt; 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。&lt;/li&gt;
&lt;li&gt;开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。&lt;/li&gt;
&lt;li&gt;Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有状态应用管理难题&#34;&gt;有状态应用管理难题&lt;/h3&gt;
&lt;p&gt;Kubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。&lt;/p&gt;
&lt;p&gt;例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 &lt;code&gt;ConfigMap&lt;/code&gt;、复杂的启动脚本才能&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/migrating-hadoop-yarn-to-kubernetes.html&#34; title=&#34;在 Kubernetes 上定义 Hadoop YARN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Kubernetes 上定义 Hadoop YARN&lt;/a&gt; 和&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/usecases/running-spark-with-kubernetes-native-scheduler.html&#34; title=&#34;运行 Spark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行 Spark&lt;/a&gt;。虽然 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/&#34; title=&#34;StatefulSet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;StatefulSet&lt;/code&gt;&lt;/a&gt; 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 &lt;code&gt;ConfigMap&lt;/code&gt; 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。&lt;/p&gt;
&lt;h3 id=&#34;operator-统一了-kubernetes-应用运维框架&#34;&gt;Operator 统一了 Kubernetes 应用运维框架&lt;/h3&gt;
&lt;p&gt;Operator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;构建自己的 Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建自己的 Operator&lt;/a&gt; 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 &lt;a href=&#34;https://istio.io&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;、&lt;a href=&#34;https://knative.dev&#34; title=&#34;Knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。&lt;/p&gt;
&lt;p&gt;Operator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立&lt;/strong&gt;：互不干涉，比如 Controller 与服务发现之间就不存在冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合&lt;/strong&gt;：例如 &lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt; 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有冲突&lt;/strong&gt;：例如图中的 &lt;code&gt;CronHorizontalPodAutoscaler&lt;/code&gt;（CRD）、&lt;code&gt;HorizontalPodAutoscaler&lt;/code&gt;（Kubernetes 内置），同时使用可能导致无法意料的情况发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;应用交付领域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付领域&lt;/a&gt;的系列开源项目。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用管理工具-helm&#34;&gt;云原生应用管理工具 Helm&lt;/h2&gt;
&lt;p&gt;Kubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序启动时加载的配置文件；&lt;/li&gt;
&lt;li&gt;应用程序的运维配置，如资源申请限额；&lt;/li&gt;
&lt;li&gt;应用程序的服务发现配置；&lt;/li&gt;
&lt;li&gt;应用程序的工作负载、发布策略、依赖等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些配置可以存在于 &lt;code&gt;ConfigMap&lt;/code&gt;、&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt; 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。&lt;/p&gt;
&lt;p&gt;云原生应用打包和发布管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；&lt;/li&gt;
&lt;li&gt;Chart 仓库提供了云原生应用程序的统一管控视图；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release&lt;/code&gt; 概念的引入，使得云原生应用版本化管理进一步加强；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helm 主要关注的是 &lt;a href=&#34;https://12factor.net/zh_cn/&#34; title=&#34;12 因素应用&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;12 因素应用&lt;/a&gt;法则&lt;a href=&#34;https://12factor.net/zh_cn/build-release-run&#34; title=&#34;构建、发布、运行&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建、发布、运行&lt;/a&gt;这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/post-kubernetes-era/helm-chart_hu9750749335371226848.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/helm-chart.png&#34; data-img=&#34;/blog/post-kubernetes-era/helm-chart.png&#34; data-width=&#34;600&#34; data-height=&#34;429&#34; alt=&#34;image&#34; data-caption=&#34;Helm3 架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Helm3 架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Helm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 &lt;code&gt;helm upgrade&lt;/code&gt;，release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。&lt;/p&gt;
&lt;h3 id=&#34;打包配置和发布&#34;&gt;打包、配置和发布&lt;/h3&gt;
&lt;p&gt;Helm 和 chart 的主要作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序封装&lt;/li&gt;
&lt;li&gt;版本管理&lt;/li&gt;
&lt;li&gt;依赖检查&lt;/li&gt;
&lt;li&gt;便于应用程序分发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;打包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Helm 采用 &lt;a href=&#34;https://helm.sh/docs/topics/charts/&#34; title=&#34;Chart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chart&lt;/a&gt; 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用配置参数，在 Chart 中由 &lt;code&gt;values.yaml&lt;/code&gt; 和命令行参数组成。Chart 采用 Go Template 的特性和 &lt;code&gt;values.yaml&lt;/code&gt; 对部署的模板文件进行参数渲染，也可以通过 &lt;code&gt;helm&lt;/code&gt; 命令 &lt;code&gt;--set key=value&lt;/code&gt; 的方式进行参数赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用&#34;&gt;云原生应用&lt;/h2&gt;
&lt;p&gt;以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时：ECS、Docker、KataContainer、gVisor 等；&lt;/li&gt;
&lt;li&gt;资源隔离性：多租户、VPC、Namespace、防火墙；&lt;/li&gt;
&lt;li&gt;资源调度：各种类型的 controller；&lt;/li&gt;
&lt;li&gt;网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；&lt;/li&gt;
&lt;li&gt;可观测性：日志、分布式追踪、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；&lt;/li&gt;
&lt;li&gt;平台资源申请：数据库、存储等；&lt;/li&gt;
&lt;li&gt;运行与隔离：ECS、Docker、KataContainer 等；&lt;/li&gt;
&lt;li&gt;资源分配和调度：各种控制器；&lt;/li&gt;
&lt;li&gt;环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；&lt;/li&gt;
&lt;li&gt;可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；&lt;/li&gt;
&lt;li&gt;状态管理：Operator；&lt;/li&gt;
&lt;li&gt;可观测性：日志、监控、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、ServiceAccount；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云原生应用分层模型&#34;&gt;云原生应用分层模型&lt;/h3&gt;
&lt;p&gt;那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;应用交付领域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付领域&lt;/a&gt;的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-app_hu12593863262187937015.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-app.png&#34; data-img=&#34;/blog/post-kubernetes-era/cloud-native-app.png&#34; data-width=&#34;1054&#34; data-height=&#34;514&#34; alt=&#34;image&#34; data-caption=&#34;云原生应用的分层模型&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生应用的分层模型&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用定义和包装&lt;/strong&gt;：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载定义&lt;/strong&gt;：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。&lt;a href=&#34;https://istio.io&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观测性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用发布和上线&lt;/strong&gt;：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes 原语&lt;/strong&gt;：Kubernetes 本身提供的原语，Operator 基于此构建；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34; title=&#34;The Dictionary of Cloud-Native App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Dictionary of Cloud-Native App Delivery&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Platform/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。&lt;/p&gt;
&lt;h3 id=&#34;oam开放应用模型&#34;&gt;OAM（开放应用模型）&lt;/h3&gt;
&lt;p&gt;那么以上这么多应用有哪些共性，能不能再进一步抽象呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；&lt;/li&gt;
&lt;li&gt;在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；&lt;/li&gt;
&lt;li&gt;要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 &lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt;，二者同时使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 的 Runtime 的正常流程应该是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用开发者创建自己的 &lt;code&gt;Component&lt;/code&gt;，在 &lt;code&gt;Component&lt;/code&gt; 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；&lt;/li&gt;
&lt;li&gt;运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 &lt;code&gt;Component&lt;/code&gt; 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 &lt;code&gt;ApplicationConfiguration&lt;/code&gt;的下发，生成 &lt;code&gt;Component&lt;/code&gt; 对应的 &lt;code&gt;Workload&lt;/code&gt; 和 &lt;code&gt;Trait&lt;/code&gt;，&lt;code&gt;Trait&lt;/code&gt; controller 将本次的 &lt;code&gt;Trait&lt;/code&gt; 策略应用到本次要管理的 &lt;code&gt;Workload&lt;/code&gt; 当中，最终到达终态，完成一次发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；&lt;/li&gt;
&lt;li&gt;Trait：各种运维规则，比如扩缩容、流量控制、安全性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生态&#34;&gt;生态&lt;/h3&gt;
&lt;p&gt;以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34; title=&#34;CNCF 宣布成立 SIG App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 宣布成立 SIG App Delivery&lt;/a&gt; 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;应用交付 SIG&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付 SIG&lt;/a&gt; 的使命是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。&lt;/li&gt;
&lt;li&gt;发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。&lt;/li&gt;
&lt;li&gt;识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 OAM 定义的云原生应用模型已有以下项目支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://crossplane.io/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt;：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 &lt;code&gt;kubectl&lt;/code&gt; 配置和管理基础架构、服务和应用。对于 OAM 的支持详见运行应用程序。&lt;/li&gt;
&lt;li&gt;KPT：Kpt（发音为 &amp;ldquo;keep&amp;rdquo;）是一个在资源配置之上构建声明性工作流的开源工具。它的 git + YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用交付领域相关的开源项目还有很多，详见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;Awesome Cloud Native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 &lt;a href=&#34;https://oam.dev/&#34; title=&#34;OAM 社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM 社区&lt;/a&gt;，一起参与进来，把国人参与指定的标准推向世界。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.ibm.com/technologies/containers/blogs/kubernetes-helm-3/&#34; title=&#34;Do you know what’s in Helm 3? - developer.ibm.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do you know what’s in Helm 3? - developer.ibm.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34; title=&#34;O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34; title=&#34;The Dictionary of Cloud-Native App Delivery - docs.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Dictionary of Cloud-Native App Delivery - docs.google.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34; title=&#34;CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/c7A8lOdAKkW25GoqmwOgWg&#34; title=&#34;OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34; title=&#34;云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>OAM（开放应用模型）——定义云原生应用标准的野望</title>
      <link>https://jimmysong.io/blog/oam-intro/</link>
      <pubDate>Wed, 22 Apr 2020 14:18:40 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/oam-intro/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://oam.dev/&#34; title=&#34;OAM（Open Application Model）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM（Open Application Model）&lt;/a&gt;是阿里巴巴和微软共同开源的云原生应用规范模型，同时开源了基于 OAM 的实现 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34; title=&#34;Rudr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr&lt;/a&gt;，自 2019 年 10 月宣布开源以来截止本文发稿已经有快半年时间了。&lt;/p&gt;
&lt;p&gt;当前可能大部分人才刚刚开始了解 OAM，所以这篇文章将从最基础出发，为大家介绍 OAM 的诞生背景和要解决的问题，以及它在云原生生态中的作用。&lt;/p&gt;
&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;如果你没有兴趣或者时间阅读下面的全文，那么建议阅读下面这些核心观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAM 的本质是根据软件设计的“兴趣点分离”原则对负责的 DevOps 流程的高度抽象和封装，这背后还是“&lt;strong&gt;康威定律&lt;/strong&gt;”在起作用。&lt;/li&gt;
&lt;li&gt;OAM 仅定义云原生应用的规范，目前推出的 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34; title=&#34;Rudr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr&lt;/a&gt; 可以看做是 OAM 规范的 Kubernetes 解释器（实验实现），将云原生应用定义翻译成 Kubernetes 的资源对象。&lt;/li&gt;
&lt;li&gt;OAM 与 &lt;a href=&#34;https://crossplane.io/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt; 将展开合作，就 Kubernetes 式以 API 为中心的应用定义发扬光大，并深度参与 &lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;CNCF SIG App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF SIG App Delivery&lt;/a&gt;，以共同定义云原生应用标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;康威定律（Conway’s Law）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B&#34; title=&#34;康威定律&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;康威定律&lt;/a&gt;是马尔文·康威（Melvin Conway）1967 年提出的： &amp;ldquo;设计系统的架构受制于产生这些设计的组织的沟通结构。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;oam-简介&#34;&gt;OAM 简介&lt;/h2&gt;
&lt;p&gt;OAM 全称是 Open Application Model，从名称上来看它所定义的就是一种模型，同时也实现了基于 OAM 的我认为这种模型旨在定义了云原生应用的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放（Open）：支持异构的平台、容器运行时、调度系统、云供应商、硬件配置等，总之与底层无关&lt;/li&gt;
&lt;li&gt;应用（Application）：云原生应用&lt;/li&gt;
&lt;li&gt;模型（Model）：定义标准，以使其与底层平台无关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺便说下 CNCF 中的也有几个定义标准的「开源项目」，其中有的项目都已经毕业。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34; title=&#34;SMI（Service Mesh Interface）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SMI（Service Mesh Interface）&lt;/a&gt;：服务网格接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34; title=&#34;Cloud Events&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Events&lt;/a&gt;：Serverless 中的事件标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theupdateframework/specification&#34; title=&#34;TUF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TUF&lt;/a&gt;：更新框架标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe&#34; title=&#34;SPIFFE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE&lt;/a&gt;：身份安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其中唯独没有应用标准的定义，&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;CNCF SIG App delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF SIG App delivery&lt;/a&gt; 即是要做这个的。当然既然要制定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。本文将默认底层平台为 Kubernetes。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是从管理大量 CRD 中汲取的经验。&lt;/li&gt;
&lt;li&gt;业务和研发的沟通成本，比如 YAML 配置中很多字段是开发人员不关心的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-基本对象&#34;&gt;OAM 基本对象&lt;/h3&gt;
&lt;p&gt;OAM 模型中包含以下基本对象，以本文发稿时的最新 API 版本 &lt;code&gt;core.oam.dev/v1alpha2&lt;/code&gt; 为准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/4.component.md&#34; title=&#34;Component&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/a&gt;：OAM 中最基础的对象，该配置与基础设施无关，定义负载实例的运维特性。例如一个微服务 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/3.workload.md&#34; title=&#34;workload&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;workload&lt;/a&gt; 的定义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/6.traits.md&#34; title=&#34;TraitDefinition&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;TraitDefinition&lt;/strong&gt;&lt;/a&gt;：一个组件所需的&lt;strong&gt;运维策略与配置&lt;/strong&gt;，例如环境变量、Ingress、AutoScaler、Volume 等。（注意：该对象在 &lt;code&gt;apiVersion: core.oam.dev/v1alpha1&lt;/code&gt; 中的名称为 &lt;code&gt;Trait&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/5.application_scopes.md&#34; title=&#34;ScopeDefinition&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ScopeDefinition&lt;/strong&gt;&lt;/a&gt;：多个 Component 的共同边界。可以根据组件的特性或者作用域来划分 Scope，一个 Component 可能同时属于多个 Scope。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/7.application_configuration.md&#34; title=&#34;ApplicationConfiguration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ApplicationConfiguration&lt;/strong&gt;&lt;/a&gt;：将 Component（必须）、Trait（必须）、Scope（非必须）等组合到一起形成一个完整的应用配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-api-的演变&#34;&gt;OAM API 的演变&lt;/h3&gt;
&lt;p&gt;因为 OAM 还处在发展早起，API 变化较快，以上四个对象在不同的 API 版本中的 &lt;code&gt;kind&lt;/code&gt; 名称不同，请大家使用时注意区别。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;core.oam.dev/v1alpha1&lt;/th&gt;
          &lt;th&gt;core.oam.dev/v1alpha2&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Component&lt;/td&gt;
          &lt;td&gt;ComponentSchematic&lt;/td&gt;
          &lt;td&gt;Component&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Trait&lt;/td&gt;
          &lt;td&gt;Trait&lt;/td&gt;
          &lt;td&gt;TraitDefinition&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Scope&lt;/td&gt;
          &lt;td&gt;Scope&lt;/td&gt;
          &lt;td&gt;ScopeDefinition&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Application configuration&lt;/td&gt;
          &lt;td&gt;ApplicationConfiguration&lt;/td&gt;
          &lt;td&gt;ApplicationConfiguration&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总的来说，OAM 模型对象的定义格式与 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields&#34; title=&#34;Kubernetes 对象的类型字段&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 对象的类型字段&lt;/a&gt;相似。关于 OAM 的基本概念模型的更多信息请访问 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/2.overview_and_terminology.md&#34; title=&#34;Overview and Terminology&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Overview and Terminology&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;oam-工作原理&#34;&gt;OAM 工作原理&lt;/h3&gt;
&lt;p&gt;下图来自阿里云原生应用平台团队孙健波在 &lt;strong&gt;《OAM:云原生时代的应用模型与 下一代 DevOps 技术》&lt;/strong&gt; 中的分享，OAM 的工作原理如下图所示，OAM Spec 定义了云原生应用的规范（使用一些列 CRD 定义），Rudr 可以看做是 OAM 规范的解析器，将应用定义翻译为 Kubernetes 中的资源对象。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/oam-intro/oam-principle_hu6662517656341360807.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/oam-intro/oam-principle.png&#34; data-img=&#34;/blog/oam-intro/oam-principle.png&#34; data-width=&#34;2568&#34; data-height=&#34;1388&#34; alt=&#34;image&#34; data-caption=&#34;OAM 的原理&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;OAM 的原理&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;可以将上图分为三个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;汇编层&lt;/strong&gt;：即人工或者使用工具来根据 OAM 规范定义汇编出一个云原生应用的定义，其中包含了该应用的工作负载和运维能力配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转义层&lt;/strong&gt;：汇编好的文件将打包为 YAML 文件，由 Rudr 或其他 OAM 的实现将其转义为 Kubernetes 或其他云服务（例如 Istio）上可运行的资源对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行层&lt;/strong&gt;：执行经过转义好的云平台上的资源对象并执行资源配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rudr&#34;&gt;Rudr&lt;/h2&gt;
&lt;p&gt;Rudr 是对  &lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.1&#34; title=&#34;OAM v1alpha1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM v1alpha1&lt;/a&gt; 在 Kubernetes 环境下的实现，OAM 正在与 &lt;a href=&#34;https://github.com/crossplane/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt; 合作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Crossplane&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Kubernetes 社区开创的以 API 为中心的声明式配置和自动化方法，使基础设施和应用管理标准化。官方网站：&lt;a href=&#34;https://crossplane.io/&#34; title=&#34;https://crossplane.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://crossplane.io/&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安装-rudr&#34;&gt;安装 Rudr&lt;/h3&gt;
&lt;p&gt;请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/setup/install.md&#34; title=&#34;Rudr 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr 文档&lt;/a&gt;安装，主要依赖以下组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;li&gt;helm 3&lt;/li&gt;
&lt;li&gt;Kubernetes 1.15+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行下面的命令安装 Rudr 和需要的 trait。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 克隆项目&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/oam-dev/rudr.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rudr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建一个名为 oam 的 namespace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create namespace oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 Rudr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install rudr ./charts/rudr --wait -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 要使用 ingress trait，推荐安装 Nginx ingress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install nginx-ingress stable/nginx-ingress
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 要使用 autoscaler trait，安装 HorizontalPodAutoscaler&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add kedacore https://kedacore.github.io/charts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install keda kedacore/keda -n oam
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看当前 oam namespace 下的所有 pod，你会发现已创建了以下 pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pod -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                              READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;keda-operator-b6466c989-pn25n                     1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;keda-operator-metrics-apiserver-6cf88c468-k5wd8   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nginx-ingress-controller-787bd69d8-n6v8c          1/1     Running   &lt;span class=&#34;m&#34;&gt;15&lt;/span&gt;         7d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nginx-ingress-default-backend-7c868597f4-vvddn    1/1     Running   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;          7d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rudr-c648c9b7b-knj9b                              1/1     Running   &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;          7d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;部署示例&#34;&gt;部署示例&lt;/h2&gt;
&lt;p&gt;我们使用 OAM 官方提供的教程 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_and_update.md&#34; title=&#34;Tutorial: Deploy, inspect, and update a Rudr application and its components&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tutorial: Deploy, inspect, and update a Rudr application and its components&lt;/a&gt; 中的 Python &lt;a href=&#34;https://palletsprojects.com/p/flask/&#34; title=&#34;flask&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flask&lt;/a&gt; 示例，该示例基于 OAM v1alpha1 API，最新版 API 的示例可以参考 &lt;a href=&#34;https://github.com/oam-dev/crossplane-oam-sample&#34; title=&#34;crossplane-oam-sample&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;crossplane-oam-sample&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 部署 Component&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f examples/helloworld-python-component.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时 get pod 会发现并没有创建任何新的 pod，因为 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/helloworld-python-component.yaml&#34; title=&#34;examples/helloworld-python-component.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/helloworld-python-component.yaml&lt;/a&gt; 文件中只定义了一个名为 &lt;code&gt;helloworld-python-v1&lt;/code&gt; 的 &lt;code&gt;ComponentSchematic&lt;/code&gt;，但是 &lt;code&gt;ComponentSchematic&lt;/code&gt; 是仅仅是定义了一个组件而已，还无法直接创建 pod 的，还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 绑定才可以创建应用的 pod。&lt;/p&gt;
&lt;p&gt;关于该示例的详细信息请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/how-to/create_component_from_scratch.md&#34; title=&#34;Python flask 示例&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python flask 示例&lt;/a&gt;的创建步骤。&lt;/p&gt;
&lt;h3 id=&#34;创建应用配置&#34;&gt;创建应用配置&lt;/h3&gt;
&lt;p&gt;在部署了 &lt;code&gt;ComponentSchematic&lt;/code&gt; 之后我们还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 资源绑定才可以创建应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前已有的 Trait&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装 Rudr 时已在 oam namespace 中部署了一些 trait，使用下面的命令查看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get trait -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME             AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto-scaler      7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;empty            7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ingress          7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;manual-scaler    7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;volume-mounter   7d1h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34; title=&#34;examples/first-app-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/first-app-config.yaml&lt;/a&gt; 中将 &lt;code&gt;ComponentSchematic&lt;/code&gt; 与 ingress &lt;code&gt;Trait&lt;/code&gt; 联系起来。一个完整的可部署的应用配置 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34; title=&#34;examples/first-app-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/first-app-config.yaml&lt;/a&gt; 的内容如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;core.oam.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ApplicationConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;first-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;components&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;componentName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-python-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 引用了上文中的 Component&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;instanceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;first-app-helloworld-python-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parameterValues&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Rudr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;9999&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;traits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Ingress 引用，Rudr 已默认创建&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;properties&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行下面的命令部署应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f examples/first-app-config.yaml -n oam
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若此时查看 oam namespace 下的 pod 将发现有一个新的 pod 创建。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pod -o oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                              READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;first-app-helloworld-python-v1-69945684c7-wfd82   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          16m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;p&gt;执行下面的命令可以测试刚安装的应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将 Python flask 应用的 pod 暴露到本机&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;POD_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get pods -l &lt;span class=&#34;s2&#34;&gt;&amp;#34;oam.dev/instance-name=first-app-helloworld-python-v1,app.kubernetes.io/name=first-app&amp;#34;&lt;/span&gt; -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].metadata.name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward &lt;span class=&#34;nv&#34;&gt;$POD_NAME&lt;/span&gt; 9999:9999
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Forwarding from 127.0.0.1:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Forwarding from &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;::1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器中访问 &lt;a href=&#34;http://127.0.0.1:9999&#34; title=&#34;http://127.0.0.1:9999&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://127.0.0.1:9999&lt;/a&gt; 将看到 &lt;code&gt;Hello Rudr!&lt;/code&gt; 的输出，这表示测试成功。&lt;/p&gt;
&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;
&lt;p&gt;从以上描述中可以看出 OAM 对于定义云原生应用标准的野望，其目标不仅限于 Kubernetes 之上的又一上层抽象，而是对于一切云服务，在基于资源对象的基础上，Trait 来控制 Kubernetes 中的一众高层次非可调度的资源对象，如 AutoScaler、Volume、Ingress，Istio 中的流量配置对象 VirtualService、DestinationRule 等，还可容纳更多的云服务，对于 Serverless 时代的去基础设施化的思想不谋而合，OAM 与 Crossplane 的合作及 CNCF SIG App Delivery 的未来可期。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://oam.dev&#34; title=&#34;OAM 官方网站 - oam.dev&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM 官方网站 - oam.dev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>利用 OAM 和 Dapr 的云原生应用的未来</title>
      <link>https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/</link>
      <pubDate>Sun, 26 Jan 2020 10:03:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/</guid>
      <description>
        
        
        &lt;p&gt;在 2019 年 11 月 4 日至 8 日于佛罗里达州奥兰多举办的&lt;a href=&#34;https://www.microsoft.com/en-us/ignite&#34; title=&#34;2019 年微软 Ignite 大会上&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2019 年微软 Ignite 大会上&lt;/a&gt;，Azure 首席技术官 Mark Russinovich 介绍了微软开发的两个创新和革命性的项目，旨在解决当今 IT 专业人士和开发人员在试图构建基于微服务的应用程序时的一系列现有问题。这场会议被命名为《基于开放应用模型（OAM）和分布式应用运行时（Dapr）的云原生应用的未来》。&lt;/p&gt;
&lt;h2 id=&#34;开放式应用模型oam&#34;&gt;开放式应用模型（OAM）&lt;/h2&gt;
&lt;p&gt;因此，其中一个项目与开放应用模型（OAM）有关。它代表了一个开放的标准，允许我们建立云原生应用程序，与平台无关，并遵循关注点分离的原则，通过将应用程序的定义与应用程序的部署和托管基础设施的细节分离，为我们提供一些好处。&lt;/p&gt;
&lt;p&gt;将应用程序的定义与操作细节分开，使应用程序开发人员能够专注于其应用程序的关键要素，并将其从部署地点和方式的操作细节中抽象出来。另外，关注点的分离允许平台架构师开发可重复使用的组件，而应用开发者则专注于将这些组件与他们的代码集成，以快速、轻松地构建可靠的应用。在所有这些方面，OAM 在那些有不同角色的场景中特别有用，比如在下面的图片中，构建和管理应用程序，因为它允许你有一个关注点的分离，所以开发和管理你的应用程序的不同角色可以专注于他们任务的关键因素。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu12103945481839864550.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q.jpg&#34; data-img=&#34;/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;557&#34; alt=&#34;image&#34; data-caption=&#34;应用程序开发和部署生命周期中的角色&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;应用程序开发和部署生命周期中的角色&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;OAM 引入了几个概念，组成了你的应用程序。其中一个概念是代表你的应用程序的 Component（组件）。这些组件可能是服务，如 SQL 数据库或带有相应负载均衡器的.NET WebAPI。开发人员可以创建代码，将其打包成一个组件，然后创建清单，描述不同组件和其他应用程序之间的关系。有了这个，你就把组件的实现和这些组件如何在一个完整的分布式应用架构中结合起来的描述分开了。&lt;/p&gt;
&lt;p&gt;为了将这些组件转化为具体的应用程序，应用程序运维使用这些组件的配置来形成一个可以被部署的应用程序的具体实例。配置资源是使应用程序运维能够从开发人员提供的组件中运行一个真正的应用程序。&lt;/p&gt;
&lt;p&gt;最后一个概念是 Trait（特征），而你使用它们的集合来描述你的应用环境的特征和它的能力，如自动扩展和入口等等。这些特征允许你根据要求和背景，将你的应用程序部署到具有不同特征的不同环境。然后，这些特征可以由基础设施运维进行配置，以满足其环境的独特操作要求。&lt;/p&gt;
&lt;p&gt;最后但同样重要的是，该规范在设计上是可扩展的。同样，OAM 使平台提供者能够通过 Trait（特征）系统公开其平台的独特特征，这种方式使应用开发者能够在支持必要特征的地方建立跨平台的应用。&lt;/p&gt;
&lt;h2 id=&#34;分布式应用程序运行时dapr&#34;&gt;分布式应用程序运行时（Dapr）&lt;/h2&gt;
&lt;p&gt;Dapr 是一个可移植的、事件驱动的运行时，它使开发人员能够轻松地建立弹性的、无状态和有状态的微服务应用程序，并在云和边缘上运行，并拥抱语言和开发人员框架的多样性。它遵循&lt;strong&gt;Sidecar 架构&lt;/strong&gt;，所以它使用一个连接到你的每个组件的 Sidecar 节点，所以它可以扩展和增强你的应用程序的功能，如服务发现、负载均衡、流量管理等。&lt;/p&gt;
&lt;p&gt;使用这种编程模型，开发人员能够创建微服务应用程序，而不需要携带那么多在构建分布式应用程序过程中引入复杂性的因素，如弹性、可扩展性、服务身份和发现、负载均衡、状态管理等等。Dapr 将这些复杂的因素从开发人员那里抽象出来，这样他们就可以专注于他们正在编写的代码。&lt;/p&gt;
&lt;p&gt;Dapr 的另一个重要方面是与托管我们应用程序的平台有关。Dapr 使我们能够在云端、企业内部、甚至是边缘的多种环境中运行我们的应用程序，包括任何可用于托管应用程序的 Kubernetes 集群。&lt;/p&gt;
&lt;p&gt;最后，同样重要的是，Dapr 允许你利用你最喜欢的编程语言来构建你的分布式应用，并克服你在现今的一些服务中可能面临的编程语言和版本的限制，以构建基于微服务的应用。&lt;/p&gt;
&lt;p&gt;下面的图片提供了一个使用 Dapr 的微服务应用架构的概述。基本上，你使用你喜欢的编程语言或框架，如 Java、Node.js、Python、.NET Core 等，构建构成你的应用程序的服务，然后你的服务使用其可用的标准 API，并使用 HTTP 或 gRPC 协议与 Dapr 通信。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu14079312460610502327.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c.jpg&#34; data-img=&#34;/trans/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c.jpg&#34; data-width=&#34;1000&#34; data-height=&#34;473&#34; alt=&#34;image&#34; data-caption=&#34;使用 Dapr 的微服务应用架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;使用 Dapr 的微服务应用架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;因此，我们有 OAM，它代表了一种规范，允许你定义和建立跨平台的应用程序，在云和边缘上运行，为你提供关注点的分离，让你的团队专注于他们任务和责任的关键要素。&lt;/p&gt;
&lt;p&gt;然后，我们把 Dapr 作为一个运行时，通过提供关注点的分离和促进一些影响构建这种应用的复杂性的因素，降低了构建基于微服务的分布式应用的复杂性。此外，Dapr 允许应用程序在 &amp;ldquo;云和边缘 &amp;ldquo;计算基础设施之间进行移植，并克服目前开发人员在构建此类应用程序时面临的移植问题。&lt;/p&gt;
&lt;p&gt;如果你想获得与这些项目有关的更多细节，请看以下资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-au/resources/videos/ignite-2019-mark-russinovich-presents-the-future-of-cloud-native-applications-with-oam-and-dapr/&#34; title=&#34;Mark Russinovich 介绍 OAM 和 Dapr 的云原生应用的未来&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mark Russinovich 介绍 OAM 和 Dapr 的云原生应用的未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开放应用模式（OAM）官方网站 - &lt;a href=&#34;https://oam.dev/&#34; title=&#34;https://oam.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oam.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分布式应用程序运行时（Dapr）官方网站 - &lt;a href=&#34;https://dapr.io/&#34; title=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dapr.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>TheNewStack 云原生 Devops 报告解读</title>
      <link>https://jimmysong.io/blog/cloud-native-devops-book/</link>
      <pubDate>Sun, 02 Jun 2019 18:13:19 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cloud-native-devops-book/</guid>
      <description>
        
        
        &lt;p&gt;本书的主旨是：如果没有成熟的 DevOps 实践，云原生是玩转不起来的。DevOps 已经不是什么新鲜的话题，但到底什么是 &amp;ldquo;Cloud Native DevOps”及如何实践 Cloud Native DevOps，这正是本书要探讨的内容。&lt;/p&gt;
&lt;p&gt;DevOps 正在经历一次转型，从自动化构建到声明式基础设施、微服务和 Serverless。大部分人对云原生存在误解，以为&lt;code&gt;云原生&lt;/code&gt;就是&lt;code&gt;运行在云上&lt;/code&gt;，其实云原生更偏向于一种理念，即应用的定义及架构方式，而不是将应用运行在哪里。而云上的 DevOps 与传统的 DevOps 有什么区别，开发者和运维人员在云原生时代如何转型？也许本书会给你答案。&lt;/p&gt;
&lt;h2 id=&#34;关于本书&#34;&gt;关于本书&lt;/h2&gt;
&lt;p&gt;本书是由 &lt;a href=&#34;https://thenewstack.com&#34; title=&#34;TheNewStack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack&lt;/a&gt; 出品的免费电子书，可以在 &lt;a href=&#34;https://thenewstack.io/ebooks/devops/cloud-native-devops-2019/&#34; title=&#34;TheNewStack 网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack 网站&lt;/a&gt; 上获取本书的电子版，同时推荐 &lt;a href=&#34;https://thenewstack.io/ebooks&#34; title=&#34;TheNewStack 的电子书系列&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack 的电子书系列&lt;/a&gt;，囊括了容器、微服务、Kubernetes、云原生诸多主题，可以作为企业决策的参考读物。&lt;/p&gt;
&lt;p&gt;本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲，有很多观点引用，并结合了一些调查问卷数据展示了一幅云原生 DevOps 的趋势与全景图，下文中我会找一些代表性的观点和图表来说明。&lt;/p&gt;
&lt;p&gt;下面是本书目录，一共分为三大部分：构建、部署和管理，其中前两个部分还给出了参考书目、示例研究等。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-devops-book/a_hu8907847663367157021.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/a.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/a.jpg&#34; data-width=&#34;770&#34; data-height=&#34;1058&#34; alt=&#34;image&#34; data-caption=&#34;云原生 DevOps 目录&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生 DevOps 目录&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;谁适合读这本书&#34;&gt;谁适合读这本书&lt;/h2&gt;
&lt;p&gt;IT 经理、CIO、团队领导者，希望规划自己公司或团队的云原生化 DevOps 的实践路径以面对大规模场景。&lt;/p&gt;
&lt;h2 id=&#34;云原生化的-devops&#34;&gt;云原生化的 DevOps&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;云原生是对业务价值和团队功能的重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生化的 DevOps 在应用的管理上与原始的 DevOps 最大的区别就是——使用 YAML 文件配置的声明式基础设施（Declarative infrastructure）与应用程序的代码本身放在同一个存储库中，这些 &lt;code&gt;代码&lt;/code&gt; 将由开发团队来维护，而运维团队的职能将转变为基础设施的构建者，服务安全性、健壮性、可见性及耐用性的守护者。&lt;/p&gt;
&lt;p&gt;AWS 的 Serverless 布道师 Chris Munns 早已甚至预测到 2025 年非云供应商的运维人员将不复存在，虽然听上去有点危言耸听，但这也是为传统 IT 运维人员的职业生涯敲响的警钟。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-devops-book/b_hu15591818870773538779.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/b.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/b.jpg&#34; data-width=&#34;1682&#34; data-height=&#34;974&#34; alt=&#34;image&#34; data-caption=&#34;云原生 DevOps 高亮部分&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生 DevOps 高亮部分&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;开发接手了原来传统运维的一些职责，如配置和发布，减少了每次发布的成本，而运维的职责向管理整个系统的复杂性转变，例如转变为 SRE（Site Reliability Engineer）。&lt;/p&gt;
&lt;h2 id=&#34;工作流自动化的价值&#34;&gt;工作流自动化的价值&lt;/h2&gt;
&lt;p&gt;DevOps 的原始教义：DevOps 不是一种工具或流程，而是一种重视整个组织的持续沟通、协作、集成和自动化的实践。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cloud-native-devops-book/c_hu4550066822708422048.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/c.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/c.jpg&#34; data-width=&#34;1968&#34; data-height=&#34;1300&#34; alt=&#34;image&#34; data-caption=&#34;工作流自动化的五个案例&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;工作流自动化的五个案例&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;根据自动化的驱动力及持续时间的长短，将 Workflow Automation 划分为五个类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务流程自动化&lt;/li&gt;
&lt;li&gt;分布式系统通信&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;编排&lt;/li&gt;
&lt;li&gt;决策自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运维需要做出的转变&#34;&gt;运维需要做出的转变&lt;/h2&gt;
&lt;p&gt;Damon Edwards 提出于运维需要面对的四个灾难（&lt;a href=&#34;https://zh.wikipedia.org/wiki/%e5%90%af%e7%a4%ba%e5%bd%95%e4%b8%ad%e7%9a%84%e5%9b%9b%e9%aa%91%e5%a3%ab&#34; title=&#34;圣经启示录中的四骑士&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;圣经启示录中的四骑士&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silos（孤岛）&lt;/li&gt;
&lt;li&gt;Ticket queues（无尽的低效的工单）&lt;/li&gt;
&lt;li&gt;Toil（干脏活累活的辛勤）&lt;/li&gt;
&lt;li&gt;Low trust（低信任度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要向云原生 DevOps 转变就要克服以上几个问题。&lt;/p&gt;
&lt;h2 id=&#34;devops-领域的扩展&#34;&gt;DevOps 领域的扩展&lt;/h2&gt;
&lt;p&gt;本书第三章中提到 DevOps 的领域扩展到 Security 和 Networking。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了维持合规的编程语言&lt;/li&gt;
&lt;li&gt;容器镜像扫描&lt;/li&gt;
&lt;li&gt;基于策略的网络安全&lt;/li&gt;
&lt;li&gt;金丝雀测试&lt;/li&gt;
&lt;li&gt;运行时的威胁检测&lt;/li&gt;
&lt;li&gt;日志分析&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>CNCF 年度报告解读（2018 年）</title>
      <link>https://jimmysong.io/blog/cncf-annual-report-2018-review/</link>
      <pubDate>Wed, 13 Feb 2019 17:23:01 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cncf-annual-report-2018-review/</guid>
      <description>
        
        
        &lt;p&gt;2019 年 2 月初，CNCF 发布了 2018 年的年度报告，这是 CNCF 继 2017 年度报告之后，第二次发布年度报告，2017 年度的报告只有区区 14 页，今年的报告长度增长了一倍达 31 页。下面我将带大家一起来深度解读下这份 2018 年的年度报告，一窥 CNCF 过去一年里在推广云原生的道路上取得的进展。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文最后附上了 2017 年和 2018 年度的报告下载地址。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;cncf-年度报告涵盖的范围&#34;&gt;CNCF 年度报告涵盖的范围&lt;/h2&gt;
&lt;p&gt;在解读 CNCF 的 2018 年度报告之前，我们先简单回顾下2017 年度的报告，因为 2017 年度报告是 CNCF 的首份年度报告，这样我们也能更好的了解 CNCF 的来龙去脉。&lt;/p&gt;
&lt;p&gt;2017 年度报告已经基本确定了 CNCF 每个年度报告所包含的主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我定位&lt;/li&gt;
&lt;li&gt;会员参与情况&lt;/li&gt;
&lt;li&gt;终端用户社区&lt;/li&gt;
&lt;li&gt;项目更新&lt;/li&gt;
&lt;li&gt;会议和活动&lt;/li&gt;
&lt;li&gt;社区&lt;/li&gt;
&lt;li&gt;培训和认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为 CNCF 主要的市场活动，2017 年时其成立的第二年，经过一年时间的筹备，这一年里各种市场活动都已经开始确立并有声有色的开展了起来，包括 KubeCon、成员单位、终端用户都已经发展起来了，以后历年里只是对其不断的发展和完善。&lt;/p&gt;
&lt;p&gt;2018 年度报告中又新增了一些主题，这些主题是从 2018 年开始开展的，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;项目更新与满意度调查&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;给 CNCF 项目的维护者发调查问卷询问满意度&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;CNCF charter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF charter&lt;/a&gt; 的修订（2018 年 11 月）&lt;/li&gt;
&lt;li&gt;项目更新与发布&lt;/li&gt;
&lt;li&gt;项目服务与支援&lt;/li&gt;
&lt;li&gt;专项活动、文档、网站与博客支持&lt;/li&gt;
&lt;li&gt;本地化、IT 支持和培训&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社区拓展&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;社区奖项&lt;/li&gt;
&lt;li&gt;CNCF Meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;CNCF Ambassador 计划&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassador 计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;卡通吉祥物 Phippy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态系统工具&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devstats.cncf.io/&#34; title=&#34;devstats&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;devstats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt; 和路线图&lt;/li&gt;
&lt;li&gt;项目 logo 物料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试一致性项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国际化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进入中国&lt;/li&gt;
&lt;li&gt;本地化网站&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请大家从本文最后的链接下载报告原文以查看详情。&lt;/p&gt;
&lt;h2 id=&#34;cncf-的定位&#34;&gt;CNCF 的定位&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）成立于 2015 年 12 月 11 日，每届年度报告的开篇都会阐明 CNCF 的定位，CNCF 的自我定位在 2018 年发生了一次变动，这也说明基金会是跟随市场形势而动，其定位不是一成不变的，其中的变化暗含着 CNCF 战略的转变。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2017-年度定位&#34;&gt;CNCF 的 2017 年度定位&lt;/h3&gt;
&lt;p&gt;2017 年度报告中是这样正式介绍自己的：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud-native computing universal and sustainable. Cloud-native computing uses an &lt;strong&gt;open source&lt;/strong&gt; software stack to deploy applications as &lt;strong&gt;microservices&lt;/strong&gt;, packaging each part into its own &lt;strong&gt;container&lt;/strong&gt;, and &lt;strong&gt;dynamically orchestrating&lt;/strong&gt; those containers to optimize resource utilization. Cloud-native technologies enable software developers to build great products faster.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Envoy and Prometheus. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;可以看到介绍中的重点技术是：微服务、容器、动态编排。而在 2018 年 CNCF 对自己进行了重新的定位和包装，增加了新的内容。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2018-年度定位&#34;&gt;CNCF 的 2018 年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; title=&#34;2018 年度报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2018 年度报告&lt;/a&gt;中 CNCF 对自己的定位是：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. &lt;strong&gt;Containers&lt;/strong&gt;, &lt;strong&gt;service meshes&lt;/strong&gt;, &lt;strong&gt;microservices&lt;/strong&gt;, &lt;strong&gt;immutable infrastructure&lt;/strong&gt;, and &lt;strong&gt;declarative APIs&lt;/strong&gt; exemplify this approach.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Prometheus, Envoy, and many others. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;我们可以看到其表述中更加注重多云环境，主要涉及的技术比 2017 年多了 Service Mesh（服务网格）、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;h2 id=&#34;数读报告&#34;&gt;数读报告&lt;/h2&gt;
&lt;p&gt;CNCF 年度报告的原文主要是汇报了 CNCF 一年来的所展开的活动和进展，下表示根据 CNCF 2017 和 2018 年度报告整理了关键数据。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Year&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;63&lt;/td&gt;
          &lt;td&gt;170&lt;/td&gt;
          &lt;td&gt;365&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Contributors&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;18687&lt;/td&gt;
          &lt;td&gt;47358&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;CNCF Meetup Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;53925&lt;/td&gt;
          &lt;td&gt;89112&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Projects&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;14&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;End User Community Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
          &lt;td&gt;69&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Conference and Events Participants&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;4085&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Certified Kubernetes Partners&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;44&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Certified Kubernetes Service Providers&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
          &lt;td&gt;74&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;CNCF Ambassador&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;65&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Kubernetes Training Partners&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;18&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：其中 2016 年是 CNCF 正式开始工作的第一年，大部分数据因为活动尚未开展而缺失。&lt;/p&gt;
&lt;p&gt;从上表中我们可以看到 CNCF 诞生三年来基金会成员规模、托管项目的贡献者、参加 CNCF 名义的 Meetup 的人数取得较大范围的增长，尤其是 2018 年，因为基金会成员的爆发式增长（+130%），CNCF 开始给成员分级，会员级别、费用和权益也在 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; title=&#34;CNCF 官网&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 官网&lt;/a&gt;上明码标价。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 组织的 KubeCon&amp;amp;CloudNativeCon 开始固定每年在西欧、北美和中国举行，且 2018 年是首次进入中国；原来的 Certified Kubernetes Partners 也取消了变成了 Certified Kubernetes Service Providers；CNCF 的 &lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;Ambassador&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador&lt;/a&gt; 计划拥有了来自 15 个国家的 65 位 Ambassador，在世界各地为云原生布道；CNCF 还首次引入了 Kubernetes Training Partner。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 又推出了一系列新的认证（CKA 为 2017 年推出），包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/cka/&#34; title=&#34;CKA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKA&lt;/a&gt;（Kubernetes 管理员认证）：这是 CNCF 最早制定的一个证书，顾名思义，通过该认证证明用户具有管理 Kubernetes 集群的技能、知识和能力。虽然该证书在 2017 年即推出，但 2018 年对考试做了更细致的指导。KCSP 要求企业必须有至少三人通过 CKA。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/ckad/&#34; title=&#34;CKAD&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKAD&lt;/a&gt;（Kubernetes 应用开发者认证）：该认证证明用户可以为 Kubernetes 设计、构建、配置和发布云原生应用程序。经过认证的 Kubernetes Application Developer 可以定义应用程序资源并使用核心原语来构建、监控 Kubernetes 中可伸缩应用程序和排除故障。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;（Kubernetes 服务提供商认证）：截止本文发稿时共有 74 家企业通过该认证。该认证的主体是企业或组织，通过 KCSP 的企业意味着可以为其他组织提供 Kubernetes 支持、咨询、专业服务和培训。通过该认证的中国企业有：灵雀云、阿里云、博云、才云、DaoCloud、EasyStack、易建科技、精灵云、谐云科技、华为、时速云、星号科技、睿云智合、沃趣、元鼎科技、ZTE。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34; title=&#34;Certified Kubernetes Conformance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Kubernetes Conformance&lt;/a&gt;（Kubernetes 一致性认证）：通过该认证的 Kubernetes 提供商所提供的服务，意味着其可以保证 Kubernetes API 的可移植性及跨云的互操作性；及时更新到最新的 Kubernetes 版本；是否一致是可以通过&lt;a href=&#34;https://github.com/cncf/k8s-conformance/blob/master/instructions.md&#34; title=&#34;运行开源脚本&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行开源脚本&lt;/a&gt;验证的。截止本文发稿通过该认证的中国企业的发行版有：灵雀云（ACE、ACP、AKS）、才云 Compass、华为 FusionStage、酷栈科技 CStack MiaoYun、Daocloud Enterprise、新智认知新氦云、浪潮云、京东 TIG、网易云、七牛云、同方有云、睿云智合 WiseCloud；通过认证的中国企业托管平台有：阿里云、百度云、博云、EasyStack、易建科技、谐云科技、华为云 CCE、腾讯云 TKE、时速云、ZTE TECS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 提供的主要证书，一般通过 KCSP 的企业都要先通过 Kubernetes 一致性认证，而通过 Kubernetes 一致性认证不一定要同时通过 KCSP，所以我们看到很多通过 Kubernetes 一致性认证的企业就不一定会通过 KCSP，因为 KCSP 的要求更多，至少要成为 CNCF 会员才可以。&lt;/p&gt;
&lt;p&gt;下面将就 CNCF 会员、托管项目的成熟度等级划分、Kubernetes 服务提供商认证和 Kubernetes 提供商认证做详细说明。&lt;/p&gt;
&lt;h2 id=&#34;cncf-会员&#34;&gt;CNCF 会员&lt;/h2&gt;
&lt;p&gt;2018 年 CNCF 的会员单位经历了爆发式增长，从 170 家增长到 365 家。CNCF 制定了如下的会员等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silver Member&lt;/li&gt;
&lt;li&gt;Gold Member&lt;/li&gt;
&lt;li&gt;Platinum Member&lt;/li&gt;
&lt;li&gt;Academic/Nonprofit Member&lt;/li&gt;
&lt;li&gt;End User Member&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同等级的会员需要交纳的年费与权益不同，详情请见 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; title=&#34;https://www.cncf.io/about/join/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/join/&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;成为-cncf-会员的好处&#34;&gt;成为 CNCF 会员的好处&lt;/h3&gt;
&lt;p&gt;成为 CNCF 会员包括但不限于如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将可以参与 CNCF 市场委员会、CNCF Webinar、在 CNCF 和 Kubernetes 官网发表博客、博客被 KubeWeekly 收录、&lt;/li&gt;
&lt;li&gt;获得 KubeCon + CloudNativeCon 的门票折扣和参与大会的市场活动&lt;/li&gt;
&lt;li&gt;对于 Kubernetes 系列认证如 KCSP、入选 TOC 也要求必须成为 CNCF 会员才可以获得&lt;/li&gt;
&lt;li&gt;End User Case Study&lt;/li&gt;
&lt;li&gt;有机会加入 Ambassador 计划&lt;/li&gt;
&lt;li&gt;在社区里具有更多的话语权，例如 CNCF 在全球范围内组织的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;项目成熟度等级&#34;&gt;项目成熟度等级&lt;/h2&gt;
&lt;p&gt;自 2015 年底 CNCF 创立之初 Kubernetes 成为其首个托管项目以来，截止到 2018 年底，CNCF 已经托管了&lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;32 个开源项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;32 个开源项目&lt;/a&gt;，随着越来越多的项目加入到 CNCF，为了更好的管理这些项目，为这些项目划分不同的成熟度等级就成了迫在眉睫的事情。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/cncf-annual-report-2018-review/cncf-graduation-criteria-v2_hu15608232502539535029.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/cncf-annual-report-2018-review/cncf-graduation-criteria-v2.jpg&#34; data-img=&#34;/blog/cncf-annual-report-2018-review/cncf-graduation-criteria-v2.jpg&#34; data-width=&#34;1056&#34; data-height=&#34;714&#34; alt=&#34;image&#34; data-caption=&#34;CNCF 项目成熟度级别&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;CNCF 项目成熟度级别&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;根据《Crossing the Chasm》一书中的技术采用生命周期理论，CNCF 将其托管的项目划分为三个等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graduated：对应于早期成熟项目。截止到本文发稿时只有 &lt;a href=&#34;https://kubernetes.io/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&#34;https://prometheus.io/&#34; title=&#34;Prometheus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、&lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 和 &lt;a href=&#34;https://coredns.io/&#34; title=&#34;https://coredns.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://coredns.io/&lt;/a&gt; 毕业。&lt;/li&gt;
&lt;li&gt;Incubating：对应于早期采用者阶段。截止到本文发稿时有 16 个项目。&lt;/li&gt;
&lt;li&gt;Sandbox：对应于创新者阶段。截止到本文发稿时有 12 个项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看 CNCF 托管的项目列表请访问：https://www.cncf.io/projects/&lt;/p&gt;
&lt;p&gt;CNCF 通过为项目设置成熟度水平是来建议企业应该采用哪些项目。CNCF 中托管的项目通过向 CNCF 的技术监督委员会（TOC）展示其可持续发展性来提高其成熟度：项目的采用率，健康的变化率，有来自多个组织的提交者，采用了 &lt;a href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34; title=&#34;CNCF 行为准则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 行为准则&lt;/a&gt;，实现并维护了核心基础设施倡议（Core Infrastructure Initiative）&lt;a href=&#34;https://bestpractices.coreinfrastructure.org/&#34; title=&#34;最佳实践证书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最佳实践证书&lt;/a&gt;。详细信息在 &lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&#34; title=&#34;毕业标准 v1.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;毕业标准 v1.1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-service-provider&#34;&gt;Certified Kubernetes Service Provider&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt; 意味着企业具有为其他企业或组织提供 Kubernetes 支持、咨询、专业服务和培训的资质。2018 年又有 46 家企业通过了&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;，通过该认证的企业累计达到 76 家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何通过 KCSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想通过 KCSP 必须满足以下三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三名或更多工程师通过认证 Kubernetes 管理员（CKA）考试。&lt;em&gt;（CKAD 考试不计入此要求）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;支持企业最终用户的商业模式，包括为客户提供驻场工程师&lt;/li&gt;
&lt;li&gt;成为 CNCF 会员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 KCSP 有如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业的 logo 会出现在 &lt;a href=&#34;https://kubernetes.io/partners/&#34; title=&#34;Kubernetes Partners&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Partners&lt;/a&gt; 页面&lt;/li&gt;
&lt;li&gt;参加与云原生项目 leader、TOC 成员、CNCF Governing Board 的月度会议&lt;/li&gt;
&lt;li&gt;向终端用户的 leader 寻求帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为有如上这些好处，为了获得 Kubernetes 项目实施的资质，同时保持与基金会至今的交流，Kubernetes 厂商对该认证都趋之若鹜。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-offering&#34;&gt;Certified Kubernetes offering&lt;/h2&gt;
&lt;p&gt;通过 KCSP 认证只代表企业有为他人实施 Kubernetes 项目的资质，而企业自身可能并不对外提供 Kubernetes 平台或服务，这些企业可能只是系统集成商或 ISV，这时候 CNCF 又推出了 Kubernetes 提供商认证。&lt;/p&gt;
&lt;p&gt;Kubernetes 认证的提供商包括 Kubernetes 发行版、托管平台和安装器，通过认证的工具或平台将允许使用 Kubernetes 认证的 Logo，并保证 Kubernetes 一致性认证。&lt;/p&gt;
&lt;h2 id=&#34;展望-2019&#34;&gt;展望 2019&lt;/h2&gt;
&lt;p&gt;2018 年 Kubernetes 成为 CNCF 孵化的首个毕业项目，根据 CNCF 打造的项目成熟度模型，Prometheus、Envoy、CoreDNS 相继毕业，CNCF 的眼光早已不再仅盯着 Kubernetes 了，&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt; 几乎包揽了所有云计算相关开源项目。可以说 CNCF 早已超出了 Kubernetes 的范畴，而是旨在一个建立在 Kubernetes 为底层资源调度和应用生命周期管理之上的生态系统，CNCF 中还演进出了如 Service Mesh 和 Serverless 之类的分支。&lt;/p&gt;
&lt;p&gt;从 CNCF 2017 和 2018 年度的变化来看，其中已经去掉了”dynamically orchestrating“的字眼，也就意味着 Kubernetes 在容器编排领域已经胜出，进而强调多云环境，同时 CNCF 推动的 Kubernetes 一致性认证也受到众多云厂商的支持，这也意味着 Kubernetes 将成为多云环境 API 一致性的保证。&lt;/p&gt;
&lt;p&gt;CNCF 在 2019 年的战略将更聚焦于开发者社区，协助尤其是来自终端用户的开发者成为项目的 contributor 和 maintainer，保证终端用户的意见能够在社区里被正确地传达和并最终成功地采纳云原生。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CNCF Annual Report 2017 pdf&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; title=&#34;CNCF Annual Report 2018 pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Annual Report 2018 pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;CNCF  Projects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF  Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;CNCF Ambassadors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassadors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;Kubernetes Certified Service Providers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Certified Service Providers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>云原生编程语言 Ballerina 介绍</title>
      <link>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</link>
      <pubDate>Sat, 12 May 2018 23:27:49 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</guid>
      <description>
        
        
        &lt;p&gt;当我第一眼看到 &lt;a href=&#34;https://ballerina.io&#34; title=&#34;Ballerina&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina&lt;/a&gt; 还真有点惊艳的感觉。Ballerina 这个单词的意思是“芭蕾舞女演员”。我想他们之所以给公司和这们语言起这个名字，可能是希望它成为云原生这个大舞台中，Ballerina 能像一个灵活的芭蕾舞者一样轻松自如吧！&lt;/p&gt;
&lt;p&gt;Ballerina 是一款开源的编译式的强类型语言，该语言本身的代码可以通过 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-lang&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。我们可以通过 Ballerina 官网上的设计哲学页面来对这门云原生编程语言一探究竟。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8tj7gxj30ws0u0774_hu5776011509422541662.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg&#34; data-width=&#34;800&#34; data-height=&#34;732&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 Ballerina&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;未来的应用程序应该是基于 API 的，而众多 API 之间的通讯和集成就成了关键问题。Ballerina 是一款使用文本和图形语法编译的、事务的、静态和强类型编程语言。Ballerina 包含分布式系统集成到语言的基本概念，并提供类型安全，并发环境下实现的分布式事务，可靠的消息传递，流处理和工作流。&lt;/p&gt;
&lt;h2 id=&#34;为什么创建-ballerina&#34;&gt;为什么创建 Ballerina？&lt;/h2&gt;
&lt;p&gt;与 ESB 集成仍然是瀑布式开发。你必须部署服务器，配置连接器，使用 XML 编程服务逻辑以及使用 XPath 查询和转换数据。这不是开发者友好的。&lt;/p&gt;
&lt;p&gt;带有 Spring 和 Node.js 等框架的编程语言提供了灵活性，但是它没有使适合于序列并行化、并发模型编程的分布式系统结构变得简单。&lt;/p&gt;
&lt;p&gt;ESB、EAI、BPM 和 DSL 需要 XML 和配置来中断迭代开发流程：编辑、构建、运行和测试。这与运行实际应用之间是有一条鸿沟的，而云原生编程语言 Ballerina 的出现就是为了解决这条“集成鸿沟”的。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-设计理念&#34;&gt;Ballerina 设计理念&lt;/h2&gt;
&lt;h3 id=&#34;序列图&#34;&gt;序列图&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8ji2zdj30u00wwdgm_hu2516002175411293476.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina 的序列图设计理念&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 Ballerina 的序列图设计理念&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;语言灵感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列图反映了设计开发人员记录的互联的系统。Ballerina 的语法和高效的编码模式要求开发人员使用强大的交互最佳实践来编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列图可视化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的语言语义模型旨在定义独立的各方如何通过结构化的交互沟通。接着，每个 Ballerina 程序都可以显示为其流程的序列图。IntelliJ 和 VS Code 的插件中提供了这些可视化。Ballerina Composer 是一款通过序列图创建 Ballerina 服务的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actor 与 action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端、worker 和远程系统在 Ballerina 的序列图中以不同的 actor 表示。在代码中，远程端点通过连接器进行连接，连接器提供类型安全操作。在图形上，每个连接器在序列图中表示为一个 actor（即一条垂直线），action 表示为与这些 actor 的交互。&lt;/p&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c99h584j30u00ww752_hu3579561761672957594.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c99h584j30u00ww752.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c99h584j30u00ww752.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina 的并发理念&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 Ballerina 的并发理念&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;序列图和并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的并发模型是并行优先的，因为与远程方的交互总是涉及多个 worker。Worker 之间的交互作为消息传递进行处理，它们之间没有共享状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worker 语义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的执行模型由称为 woker 的轻量级并行执行单元组成。Worker 使用非阻塞策略来确保没有函数锁定正在执行的线程，例如等待响应的 HTTP I/O 调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Worker 和 fork/join 语义抽象了底层非阻塞方法，以启用更简单的并发编程模型。&lt;/p&gt;
&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;
&lt;p&gt;下面是 Ballerina 中支持的类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anything&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;floatingPoint&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blob&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toBlob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsonNative&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;XML&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;natively&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;             &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringArray&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;there&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[][]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arrayOfArrays&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unionType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// the empty tuple acts as &amp;#34;null&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringOrInt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;this is a union type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intOrNull&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inferred&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myMap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ballerina&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myRecord&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myObject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;returns&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;类型安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 有一个结构化的类型系统，包括 primitive、recored、object、tuple 和 union 类型。该类型安全模型在赋值时包含了类型推断，并为连接器、逻辑和网络绑定的有效负载提供了大量的编译时完整性检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Union 类型和显式 Null&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;各个网络端点通常会根据其输入和逻辑返回具有不同有效负载类型消息或 error。Ballerina 的类型系统采用了基于 union 类型的方法。Union 类型明确地采用了这种语义，不需要开发人员创建不必要的“包装”类型。这种方法也增强了对 null 值的处理。默认情况下，类型不支持 null 值。开发人员必须明确创建 union 类型来处理 null 值。结果是 null 的异常不会发生，并且语言语法和编译器会识别是否需要 null 处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异构数据处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 类型系统内置丰富的对 JSON、XML、流和表格的支持以及对 ProtoBuf 和 gRPC 的直接支持。这样做的结果是可以获得处理网络负载、SQL 编程和流处理的干净可读的代码。数据转换逻辑不受复杂的生成类型、第三方库代码或其他混淆因素的影响——简单明了的可读代码捕捉与异构数据和转换逻辑的交互。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-如何工作&#34;&gt;Ballerina 如何工作？&lt;/h2&gt;
&lt;p&gt;Ballerina 的语法、代码和编译器创建了运行时服务和部署构件，这些工件都是云原生就绪的，您可以选择将其部署在 IaaS、编排系统或 service mesh 中的。开发人员的体验旨在维护流程，包括快速的编辑、构建、调试周期并集成到团队的生命周期工具链中。&lt;/p&gt;
&lt;h3 id=&#34;运行时架构&#34;&gt;运行时架构&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cazdfcnj30u00wxjsr_hu5412704454339718249.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 运行时架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 ballerina 运行时架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Ballerina API 网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强制执行身份策略并保证性能。通过代码注解（类似于 Spring 中的注解）进行配置和部署。可以运行嵌入式服务、作为管理多个服务的容器代理或者使用 API 管理解决方案（如 WSO2 API Manager）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示您的 API 和执行逻辑。服务通过不同的协议运行，内部代码结构被编译为支持 OpenAPI 和 Swagger 的 API 接口。服务与端点进行通信，无论它们是调用客户端还是其他服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina bridge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许传统代码和服务参与分布式事务中的 Ballerina 服务。Bridge 将您现有服务与本地代理包装起来，通过调用 Ballerina 服务参与和代理分布式事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息代理、事务协调者和身份代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为参与事务、事件驱动的通信和为认证流程的 Ballerina 服务提供代理基础设施功能。这些组件可以嵌入到单个服务部署中或者进行单独部署和扩展以管理多个服务。&lt;/p&gt;
&lt;h3 id=&#34;部署架构&#34;&gt;部署架构&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cbr5hquj30u00wxq46_hu2366988694324227263.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cbr5hquj30u00wxq46.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cbr5hquj30u00wxq46.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 部署架构图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 ballerina 部署架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;IaaS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用代码注解和构建系统，可以打包 Ballerina 服务和其他运行时组件（如 API 网关）以部署到任何云原生环境中。在 IaaS 环境中，Ballerina 服务可以以虚拟机或容器的方式运行，也可以在构建期间将镜像推送到 registry 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码注解会触发编译器扩展，从而为不同的编排器（如 Kubernetes 或 Cloud Foundry）生成 Ballerina 组件的工件包。供应商或 DevOps 可以添加自定义代码注解以生成特定于环境的部署，例如自定义蓝色部署算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 可以选择断路器和事务流程逻辑委托给像 Istio 或 Envoy 这样的 service mesh（如果有的话）。如果没有 service mesh 的话，Ballerina 服务将嵌入相应的功能。&lt;/p&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cck2s8xj30u00wtgni_hu14302281236815112453.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cck2s8xj30u00wtgni.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cck2s8xj30u00wtgni.jpg&#34; data-width=&#34;600&#34; data-height=&#34;656&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 生命周期架构图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;云原生编程语言 ballerina 生命周期架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用我们的语言服务器可以在 VS Code 和 IntelliJ 中获取自动补全和调试等智能感知。Ballerina 的关键字和语法结构可以用序列图的方式来表示。使用 Ballerina Composer 可以可视化的编辑 Ballerina 代码。另外它也可以做可视化得运行时和开发环境追踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 构建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将服务编译为经过优化的字节码，以便使用内存调优后的 BVM 运行。提供了使用 Testerina 的项目结构、依赖管理、包管理和单元测试。构建锁可以轻松地重新创建服务和部署。生成可执行文件（.balx）或库（.balo）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署代码注解会触发构建扩展，从而为持续集成、持续交付或编排器环境生成工件。将构建工件推送到您的 CI/CD 系统或完全跳过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Registry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将端点连接器、自定义注解和代码功能作为可共享软件包组合在一起。可以在全球共享资源库——Ballerina Central 中 pull 或 push 版本化的软件包。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-的语言特性&#34;&gt;Ballerina 的语言特性&lt;/h2&gt;
&lt;p&gt;Ballerina 设计为云优先，内置对现代 Web 协议和数据格式的支持，完全支持图灵完备编程语言，以及对微服务架构的原生支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 构造&lt;/li&gt;
&lt;li&gt;逻辑语言&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;Json 和 XML&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;稳定和强大的类型&lt;/li&gt;
&lt;li&gt;stream&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ballerina-中集成了哪些内容&#34;&gt;Ballerina 中集成了哪些内容？&lt;/h2&gt;
&lt;p&gt;Ballerina 是一种旨在&lt;strong&gt;集成简化&lt;/strong&gt;的语言。基于顺序图的交互，Ballerina 内置了对通用集成模式和连接器的支持，包括分布式事务、补偿和断路器。凭借对 JSON 和 XML 的一流支持，Ballerina 能够简单有效地构建跨网络终端的强大集成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型安全端点集成&lt;/li&gt;
&lt;li&gt;类型安全连接器&lt;/li&gt;
&lt;li&gt;可靠的消息传递&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;断路器&lt;/li&gt;
&lt;li&gt;注入攻击防护&lt;/li&gt;
&lt;li&gt;Docker 和 Kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 Ballerina 中各个功能的示例代码请查阅 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-examples&#34; title=&#34;ballerina-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ballerina-example&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io&#34; title=&#34;Ballerina 官网&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Microservices, Docker, Kubernetes, Serverless, Service Mesh, and Beyond&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>CNCF - 云原生计算基金会简介</title>
      <link>https://jimmysong.io/blog/cncf-introduction/</link>
      <pubDate>Sun, 04 Mar 2018 18:03:39 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/blog/cncf-introduction/</guid>
      <description>
        
        
        &lt;p&gt;CNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），口号是&lt;strong&gt;坚持和整合开源技术来编排容器作为微服务架构的一部分&lt;/strong&gt;，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。&lt;/p&gt;
&lt;p&gt;CNCF 作为一个厂商中立的基金会，致力于 Github 上的快速成长的开源技术的推广，如 Kubernetes、Prometheus、Envoy 等，帮助开发人员更快更好的构建出色的产品。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://github.com/cncf/landscape&#34; title=&#34;http://github.com/cncf/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://github.com/cncf/landscape&lt;/a&gt; 中维护了一幅 CNCF 的全景图。&lt;/p&gt;
&lt;p&gt;其中包含了 CNCF 中托管的项目，还有很多是非 CNCF 项目，还有个交互式的浏览 CNCF 涵盖的所有的项目的页面：https://i.cncf.io&lt;/p&gt;
&lt;p&gt;关于 CNCF 的使命与组织方式请参考&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;CNCF 章程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 章程&lt;/a&gt;，概括的讲 CNCF 的使命宝库以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装。&lt;/li&gt;
&lt;li&gt;通过中心编排系统的动态资源管理。&lt;/li&gt;
&lt;li&gt;面向微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 最初对云原生特征的定义。&lt;/p&gt;
&lt;p&gt;CNCF 这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。&lt;/p&gt;
&lt;p&gt;另外 CNCF 组织由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会员&lt;/strong&gt;：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理事会&lt;/strong&gt;：负责事务管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TOC（技术监督委员会）&lt;/strong&gt;：技术管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户社区&lt;/strong&gt;：推动 CNCF 技术的采纳并选举最终用户技术咨询委员会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户技术咨询委员会&lt;/strong&gt;：为最终用户会议或向理事会提供咨询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;营销委员会&lt;/strong&gt;：市场推广&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cncf-项目成熟度分级与毕业条件&#34;&gt;CNCF 项目成熟度分级与毕业条件&lt;/h2&gt;
&lt;p&gt;每个 CNCF 项目都需要有个成熟度等级，申请成为 CNCF 项目的时候需要确定项目的成熟度级别。&lt;/p&gt;
&lt;p&gt;成熟度级别（Maturity Level）包括以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sandbox（初级）一开始是叫 inception&lt;/li&gt;
&lt;li&gt;incubating（孵化中）&lt;/li&gt;
&lt;li&gt;graduated（毕业）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否可以成为 CNCF 项目需要通过 Technical Oversight Committee（技术监督委员会）简称&lt;a href=&#34;https://github.com/cncf/toc&#34; title=&#34;TOC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOC&lt;/a&gt;，投票采取 fallback 策略，即&lt;strong&gt;回退策略&lt;/strong&gt;，先从最高级别（graduated，目前是从 incubating）开始，如果 2/3 多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到 inception 级别都没得到 2/3 多数投票通过的话，则拒绝其进入 CNCF 项目。一般一个项目处于孵化阶段不会超过 2 年。&lt;/p&gt;
&lt;p&gt;当前所有的 CNCF 项目可以访问 &lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/projects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在太平洋时间 3 月 6 日，Kubernetes 成为了 CNCF 的第一个毕业项目！&lt;/p&gt;
&lt;h2 id=&#34;toc技术监督委员会&#34;&gt;TOC（技术监督委员会）&lt;/h2&gt;
&lt;p&gt;TOC（Technical Oversight Committee）作为 CNCF 中的一个重要组织，它的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义和维护技术视野&lt;/li&gt;
&lt;li&gt;审批新项目加入组织，为项目设定概念架构&lt;/li&gt;
&lt;li&gt;接受最终用户的反馈并映射到项目中&lt;/li&gt;
&lt;li&gt;调整组件见的访问接口，协调组件之间兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TOC 成员通过选举产生，见&lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/election-schedule.md&#34; title=&#34;选举时间表&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;选举时间表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考 CNCF TOC：https://github.com/cncf/toc&lt;/p&gt;
&lt;h2 id=&#34;cncf-章程&#34;&gt;CNCF 章程&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）是 Linux 基金会旗下的一个基金会，加入 CNCF 等于同时加入 Linux 基金会（也意味着你还要交 Linux 基金会的份子钱），对于想加入 CNCF 基金会的企业或者组织首先要做的事情就是要了解 CNCF 的章程（charter），就像是作为一个国家的公民，必须遵守该国家的宪法一样。CNCF 之所以能在短短三年的时间内发展壮大到如此规模，很大程度上是与它出色的社区治理和运作模式有关。了解该章程可以帮助我们理解 CNCF 是如何运作的，也可以当我们自己进行开源项目治理时派上用场。&lt;/p&gt;
&lt;p&gt;该章程最后更新于 2018 年 5 月 15 日，详见 &lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-cncf-的使命&#34;&gt;1. CNCF 的使命&lt;/h3&gt;
&lt;p&gt;CNCF 没有偏离自己的主题，核心是解决技术问题：基金会的使命是创建并推动采用新的计算模式，该模式针对现代分布式系统环境进行了优化，能够扩展至数万个自愈式多租户节点。&lt;/p&gt;
&lt;p&gt;所谓的云原生系统须具备下面这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用容器化&lt;/strong&gt;：将软件容器中的应用程序和进程作为独立的应用程序部署单元运行，并作为实现高级别资源隔离的机制。从总体上改进开发者的体验、促进代码和组件重用，而且要为云元是国内应用简化运维工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态管理&lt;/strong&gt;：由中心化的编排来进行活跃的调度和频繁的管理，从根本上提高机器效率和资源利用率，同时降低与运维相关的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向微服务&lt;/strong&gt;：与显式描述的依赖性松散耦合（例如通过服务端点），可以提高应用程序的整体敏捷性和可维护性。CNCF 将塑造技术的发展，推动应用管理的先进技术发展，并通过可靠的接口使技术无处不在，并且易于使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-cncf-扮演的角色&#34;&gt;2. CNCF 扮演的角色&lt;/h3&gt;
&lt;p&gt;CNCF 其实是在开源社区的基础上发挥着作用，应负责：&lt;/p&gt;
&lt;p&gt;a) 项目管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保技术可用于社区并且没有杂七杂八的影响&lt;/li&gt;
&lt;li&gt;确保技术的品牌（商标和标识）得到社区成员的关注和使用，特别强调统一的用户体验和高水平的应用程序兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;b) 促进生态系统的发展和演进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;评估哪些技术可以纳入云原生计算应用的愿景，鼓励社区交付这样的技术，以及集成它们，且要积极的推进总结进度。&lt;/li&gt;
&lt;li&gt;提供一种方法来培养各个部分的通用技术标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;c) 推广底层技术和应用定义和管理方法，途径包括：活动和会议、营销（SEM、直接营销）、培训课程和开发人员认证。&lt;/p&gt;
&lt;p&gt;d) 通过使技术可访问和可靠来为社区服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旨在通过对参考架构进行明确定义的节奏，为每个组成部分提供完全集成和合格的构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-cncf-的价值观&#34;&gt;3. CNCF 的价值观&lt;/h3&gt;
&lt;p&gt;CNCF 会极力遵循以下一些原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;快速胜过磨叽&lt;/strong&gt;，基金会的初衷之一就是让项目快速的发展，从而支持用户能够积极的使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放！&lt;/strong&gt; CNCF 是以开放和高度透明为最高准则的，而且是独立于任何的其它团体进行运作的。CNCF 根据贡献的内容和优点接受所有的贡献者，且遵循开源的价值观，CNCF 输出的技术是可以让所有人使用和受益的，技术社区及其决策应保持高度透明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公平&lt;/strong&gt;：CNCF 会极力避免那些不好的影响、不良行为、以及“按需付费”的决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的技术身份&lt;/strong&gt;：CNCF 会实现并保持高度的自身技术认同，并将之同步到所有的共享项目中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清晰的边界&lt;/strong&gt;：CNCF 制定明确的目标，并在某些情况下，要确定什么不是基金会的目标，并会帮助整个生态系统的运转，让人们理解新创新的重点所在。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展&lt;/strong&gt;：能够支持从小型开发人员中心环境到企业和服务提供商规模的所有部署规模。这意味着在某些部署中可能不会部署某些可选组件，但总体设计和体系结构仍应适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平台中立&lt;/strong&gt;：CNCF 所开发的项目并不针对某个特定平台，而是旨在支持各种体系结构和操作系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-会员制&#34;&gt;4. 会员制&lt;/h3&gt;
&lt;p&gt;CNCF 中的会员包括白金、金牌、银牌、最终用户、学术和非赢利成员等级别，不同级别的会员在理事会中的投票权不同。&lt;/p&gt;
&lt;p&gt;a) &lt;strong&gt;白金会员&lt;/strong&gt;：在 CNCF 理事会中任命 1 名代表，在理事会的每个次级委员会和活动中任命 1 名有投票权的代表，在网站可以突出显示；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;b) &lt;strong&gt;金牌会员&lt;/strong&gt;：基金会中每有 5 个金牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;c) &lt;strong&gt;银牌会员&lt;/strong&gt;：基金会中每有 10 个银牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;d) &lt;strong&gt;终端用户&lt;/strong&gt;：参加终端用户咨询社区；向终端用户技术咨询委员会中提名 1 名代表&lt;/p&gt;
&lt;p&gt;e) &lt;strong&gt;学术和非赢利会员&lt;/strong&gt;：学术和非营利会员分别限于学术和非营利机构，需要理事会批准。学术成员和非营利成员有权将其组织认定为支持 CNCF 使命的成员以及理事会确定的任何其他权利或利益。&lt;/p&gt;
&lt;h3 id=&#34;5-理事会&#34;&gt;5. 理事会&lt;/h3&gt;
&lt;p&gt;a) CNCF 理事会负责市场营销、业务监督和预算审批，不负责技术方面，除了与 TOC 配合确定 CNCF 工作范围、完成时间表 a)、更新 CNCF 网站&lt;/p&gt;
&lt;p&gt;b) 负责日常事务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与 TOC 协商 CNCF 的整体范围&lt;/li&gt;
&lt;li&gt;商标和版权保护&lt;/li&gt;
&lt;li&gt;市场营销、布道和生态系统建设&lt;/li&gt;
&lt;li&gt;创建和执行品牌承诺项目，如果需要的话&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;募资和财务管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;c) 理事会投票成员由会员代表和社区代表组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员代表包括：
&lt;ul&gt;
&lt;li&gt;每名白金会员任命 1 名代表&lt;/li&gt;
&lt;li&gt;黄金和银牌成员当选代表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术社区代表包括：
&lt;ul&gt;
&lt;li&gt;技术监督委员会主席&lt;/li&gt;
&lt;li&gt;根据当时在任的理事会批准的程序从 CNCF 项目中选出两名提交者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理事会可能会以白金会员比例的价格扩展白金会员资格，对年收入低于 5000 万美元的创业公司进行长达 5 年的逐年审计，这些公司被视为理事会的战略技术贡献者。&lt;/li&gt;
&lt;li&gt;只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任会员代表。只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任技术社区代表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;d) 职责&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;批准预算，指导将所有收入来源筹集的资金用于技术、市场或社区投资，以推动 CNCF 基金的使命；&lt;/li&gt;
&lt;li&gt;选举理事会主席主持会议，批准预算批准的支出并管理日常运作；&lt;/li&gt;
&lt;li&gt;对理事会的决定或事项进行投票；&lt;/li&gt;
&lt;li&gt;界定和执行基金会的知识产权（版权，专利或商标）政策；&lt;/li&gt;
&lt;li&gt;通过活动、新闻和分析师宣传、网络、社交媒体以及其他营销活动进行直接营销和布道；&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;建立并监督为推动 CNCF 的使命而创建的任何委员会；&lt;/li&gt;
&lt;li&gt;根据 CNCF 要求（可能包括认证测试）建立并执行品牌合规计划（如有），以使用 TOC 建立的品牌标志；&lt;/li&gt;
&lt;li&gt;采用商标使用准则或政策；&lt;/li&gt;
&lt;li&gt;提供整体财务管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;e) 基金会的收入用途&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;市场营销，用户扩展 CNCF 中的项目的采用&lt;/li&gt;
&lt;li&gt;关键设施建设、运行和管理项目的基础设施&lt;/li&gt;
&lt;li&gt;促进基于容器的计算使用 CNCF 中的项目实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-技术监督委员会toc&#34;&gt;6. 技术监督委员会（TOC）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) 要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNCF 技术监督委员会，为了保持中立，则达成了以下共识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义和维护 CNCF 的技术愿景。&lt;/li&gt;
&lt;li&gt;批准由理事会制定的 CNCF 范围内的新项目，并为项目创建一个概念架构。&lt;/li&gt;
&lt;li&gt;纠正项目的发展方向，决策删除或存档项目。&lt;/li&gt;
&lt;li&gt;接受最终用户委员会的反馈并反映在项目中。&lt;/li&gt;
&lt;li&gt;在科学管理的情况下调整组件的接口（在代码标准化之前实现参考）&lt;/li&gt;
&lt;li&gt;定义在 CNCF 项目中实施的常用做法（如果有的话）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;b) 技术监督委员会的构成&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 最多由 9 名成员组成。&lt;/li&gt;
&lt;li&gt;选出的 TOC 成员将涵盖关键的技术领域：容器技术、操作系统、技术运维、分布式系统、用户级应用程序设计等。&lt;/li&gt;
&lt;li&gt;理事会将选举 6 名 TOC 成员，最终用户 TAB 将选出 1 名 TOC 成员，最初的 7 名 TOC 成员应另选两名 TOC 成员。&lt;/li&gt;
&lt;li&gt;如果超过两名 TOC 成员来自同一组关联公司，无论是在选举时还是来自后来的工作变更，他们将共同决定谁应该下台，或如果没有协商的依据，则应抽签决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;c) 运营模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 会选举出 TOC 的主席来，此角色主要负责 TOC 的议程和召集会议。&lt;/li&gt;
&lt;li&gt;TOC 每个季度会面对面讨论重要的热点问题。&lt;/li&gt;
&lt;li&gt;TOC 可能会根据需要开会讨论新出现的问题。TOC 审核可能会提出以下问题：
&lt;ul&gt;
&lt;li&gt;任何的 TOC 成员&lt;/li&gt;
&lt;li&gt;任何的理事会成员&lt;/li&gt;
&lt;li&gt;建立的 CNCF 项目的维护者或顶级项目负责人&lt;/li&gt;
&lt;li&gt;CNCF 执行董事&lt;/li&gt;
&lt;li&gt;最终用户技术咨询委员会获得多数票&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持透明：TOC 会议、邮件列表、以及会议记录等均是公开可访问的。&lt;/li&gt;
&lt;li&gt;简单的 TOC 问题可以通过简短的讨论和简单的多数表决来解决。TOC 讨论可通过电子邮件或 TOC 会议进行。&lt;/li&gt;
&lt;li&gt;在对意见和可选虚拟讨论/辩论选项进行审查后，寻求共识并在必要时进行投票。&lt;/li&gt;
&lt;li&gt;目的是让 TOC 在 TOC 和社区内寻找达成共识的途径。满足法定人数要求的会议的 TOC 决定应以超过 TOC 成员出席率的 50％的方式通过。&lt;/li&gt;
&lt;li&gt;TOC 会议需要 TOC 总人数的三分之二法定人数进行表决或作出任何决定。如果 TOC 会议未能达到法定人数要求，可以进行讨论，但不应有任何投票或决定。&lt;/li&gt;
&lt;li&gt;TOC 决定可以在没有会议的情况下以电子方式提出，但要通过表决则需要多少票数才能达到会议法定人数。在电子投票中，如果任何两名 TOC 成员要求召开会议讨论决定，则电子投票结束时无效，并且在会议结束后可以启动新的投票，以讨论决定已经完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;d) 提名标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得 TOC 提名的开源贡献者应该具备下面条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;承诺有足够的可用可用时间参与 CNCF TOC 的活动，包括在 CNCF 成立时相当早期的投入，然后需持续投入时间，而且在季度的 TOC 会议之前要进行充分的准备和审查事宜。&lt;/li&gt;
&lt;li&gt;在 CNCF 范围内展示了高水准的专业经验。&lt;/li&gt;
&lt;li&gt;证明其有资格能够获得额外的工作人员或社区成员协助其在 TOC 的工作。&lt;/li&gt;
&lt;li&gt;在讨论中保持中立，并提出 CNCF 的目标和成功与公司目标或 CNCF 中的任何特定项目保持平衡。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;e) TOC 成员提名和选举程序&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 由 9 位 TOC 成员组成：由理事会选出的 6 位，由最终用户 TAB 选出的 1 位和由最初的 7 位 TOC 成员选出的 2 位。&lt;/li&gt;
&lt;li&gt;提名：每个有资格提名 TOC 成员的个人（实体或成员）可以提名至多 2 名技术代表（来自供应商、最终用户或任何其他领域），其中至多一个可能来自其各自公司。被提名者必须提前同意加入到候选人名单中。
&lt;ul&gt;
&lt;li&gt;最初的 7 名 TOC 成员（理事会选出的 6 名成员加上由最终用户 TAB 选出的 1 名成员）应使用提名程序提名并选举 2 名 TOC 成员。&lt;/li&gt;
&lt;li&gt;提名者需要提供最多一页纸的介绍，其中包括被提名者的姓名，联系信息和支持性陈述，确定了在 CNCF 领域提名的经验。&lt;/li&gt;
&lt;li&gt;理事会、最终用户 TAB 和 TOC 应确定提名、投票和关于 TOC 选举提名和选举过程的任何其他细节的时间表和日期。&lt;/li&gt;
&lt;li&gt;评估期间最少保留 14 个日历日，TOC 提名者可以联系和/或评估候选人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举：评估期结束后，理事会、最终用户标签和最初的 7 位 TOC 成员应分别对每位被候选人进行表决。有效投票需要满足会议法定人数所需的选票数量。每名被候选人均需要支持超过 50％的投票人数，以确认被提名者符合资格标准。以多数票通过的候选人应为合格的 TOC 成员。&lt;/li&gt;
&lt;li&gt;如果合格的被提名者的人数等于或少于可选 TOC 席位的数量，则此被提名者应在提名期结束后获得批准。如果有更多的合格被候选人比理事会，最终用户 TAB 或 TOC 可选的开放 TOC 席位多，那么该组应通过 Condorcet 投票选出 TOC 成员。Condorcet 投票应通过康奈尔在线服务（http://civs.cs.cornell.edu/）使用 Condorcet-IRV 方法运行。&lt;/li&gt;
&lt;li&gt;如果理事会，最终用户 TAB 或 TOC 可供选举的公开 TOC 席位的合格被候选人数较少，该小组将启动另一轮提名，每名成员或个人有资格提名至多提名 1 名候选人。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;f) 约束条件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 的成员任期为两年，来自理事会选举的最初六名当选 TOC 成员的任期为 3 年。由最终用户 TAB 和 TOC 选出的 TOC 成员的初始任期为 2 年。&lt;/li&gt;
&lt;li&gt;TOC 成员可能会被其他 TOC 成员的三分之二投票撤除，受影响的个人不能参加投票。&lt;/li&gt;
&lt;li&gt;任何 TOC 成员连续 3 次连续会议都将被自动暂停投票资格，直至连续参加两次会议。为避免疑义，暂停的 TOC 成员有资格在连续第二次会议中投票。&lt;/li&gt;
&lt;li&gt;TOC 章程、模式、方法、组成等可以由整个理事会的三分之二票通过修改。&lt;/li&gt;
&lt;li&gt;TOC 议程将由 TOC 制定。但是，预计最初的 TOC 讨论和决定将包括：
&lt;ul&gt;
&lt;li&gt;评估包含在 CNCF 中的技术&lt;/li&gt;
&lt;li&gt;确定新技术纳入 CNCF 的接受标准&lt;/li&gt;
&lt;li&gt;定义批准作为标准 API 的贡献技术的流程&lt;/li&gt;
&lt;li&gt;找出需要进一步调查的直接差距&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-最终用户社区&#34;&gt;7. 最终用户社区&lt;/h3&gt;
&lt;p&gt;a) CNCF 的最终用户成员有权协调和推动 CNCF 用户作为 CNCF 设计的消费者的重要活动。任何作为最终用户的成员或非成员，每个“最终用户参与者”均可被邀请参加。最终用户参与者将帮助向技术咨询委员会和 CNCF 社区就与用户有关的主题提供意见。&lt;/p&gt;
&lt;p&gt;b) 	最终用户技术咨询委员会是由最终用户社区成员选举所产生。&lt;/p&gt;
&lt;p&gt;c) 最终用户社区成员将获得 CNCF 执行董事的批准，或者 CNCF 执行董事缺席的话，则由 Linux 基金会执行董事来批准。&lt;/p&gt;
&lt;h3 id=&#34;8-最终用户技术咨询委员会最终用户-tab&#34;&gt;8. 最终用户技术咨询委员会（“最终用户 TAB”）&lt;/h3&gt;
&lt;p&gt;a) 构成：最终用户 TAB 应由来自最终用户参与者的 7 名代表加上 TOC 的 1 名成员组成，以便于从最终用户 TAB 到 TOC 的晋级。&lt;/p&gt;
&lt;p&gt;b) 选举：为了鼓励最终用户参与 CNCF，前 7 名最终用户会员可以委任 1 名代表参加初始最终用户 TAB，并将 CNCF 董事分配给任何最终用户参与者的任何剩余席位。在第一年之后，所有最终用户参与者可以提名 1 名代表并且最终用户社区应该投票选择使用当前最终用户 TAB 批准流程的最终用户 TAB 成员。&lt;/p&gt;
&lt;p&gt;c) 经过三分之二投票通过后最终用户 TAB 可以更改最终用户社区的大小，前提是至少有 7 名可能的代表。&lt;/p&gt;
&lt;p&gt;d) 最终用户代表应当基于业务和技术敏锐度提名。候选人应该具备建设和运营体现 CNCF 原则的基础设施和应用方面的重要实践经验。&lt;/p&gt;
&lt;p&gt;e) 最终用户 TAB 将讨论和推进主题，重点是找出 TOC 和 CNCF 开发者社区的差距并提出优先事项。&lt;/p&gt;
&lt;p&gt;f) 也会侧重于主动推进最终用户关心的话题，促进 CNCF 的市场采用，为最终用户举办会议或向理事会提供咨询。&lt;/p&gt;
&lt;p&gt;g) 如果最终用户 TAB 有意愿的话，它可以批准小组委员会特别兴趣小组（“SIG”）来解决行业或专业话题。&lt;/p&gt;
&lt;p&gt;h) 最终用户 TAB 是技术监督委员会的主要输入方，应与技术监督委员会的其他输入方和反馈一起作出决策和计划。这些建议只是建议性的，在任何时候，最终用户 TAB 的建议都不能用于命令或指导任何 TOC 或项目参与者采取任何行动或结果。&lt;/p&gt;
&lt;p&gt;i) 为促进与 TOC 的双边互动，最终用户技术咨询委员会应选出 1 名 TOC 代表。最终用户 TAB 可邀请任何人参加最终用户会议、SIG 或其他讨论。&lt;/p&gt;
&lt;h3 id=&#34;9-cncf-项目&#34;&gt;9. CNCF 项目&lt;/h3&gt;
&lt;p&gt;通常情况下，是由 CNCF 的成员公司、开源社区的成员将项目先是带到 CNCF 的技术监督委员会来进行讨论，然后决定是否被 CNCF 接纳。要贡献给 CNCF 的项目必须是经过技术监督委员会制定的标准的，之后当然还要经过理事会的批准。CNCF 的目标是希望捐赠给 CNCF 的项目和 CNCF 已有的项目在一定程度上是有关联的，而且是可集成的。&lt;/p&gt;
&lt;p&gt;和 CNCF 关联起来有以下三种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 已经在 CNCF 的纳管之下，毕竟 CNCF 是中立的，致力于成为大家的协作的归属地。&lt;/p&gt;
&lt;p&gt;a) 项目的方方面面都交由 CNCF 来打理
b) 项目是由 CNCF 来进行市场推广的
c) 项目是解决云原生计算问题的核心组件，如 Kubernetes、Mesos、etcd 等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 通过 API 或规范与 CNCF 相关联 XM&lt;/p&gt;
&lt;p&gt;a) 包括 CNCF 可能提供或启用多个选项的组件
b) 该项目被称为 CNCF 集成的一个组成部分，而不是由 CNCF 主办的项目
c) 集成和合规性由 API 或规范定义
d) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; CNCF 使用到的&lt;/p&gt;
&lt;p&gt;a) 项目或组件完全根据 OSI 批准的开源许可证进行授权，并且管理良好，并在 CNCF 中被用作组件。&lt;/p&gt;
&lt;p&gt;b) 项目并没有由 CNCF 来进行市场推广&lt;/p&gt;
&lt;p&gt;c) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;现有的开源项目应该继续保持其现有的技术治理结构，以保持凝聚力和速度。但是由技术监督委员会批准之后，则会适当的进行一些适应。&lt;/p&gt;
&lt;p&gt;应根据个人的水平和贡献期限在项目间建立一个达到提交者地位的标准协议。因为提交者是维护者的选拔人才池，有了一定程度的贡献，且经过同行们的认可，提交者就可晋升为维护者。&lt;/p&gt;
&lt;p&gt;CNCF 启动的新开源项目应完成 TOC 采纳的项目建议模板，并由 TOC 批准纳入 CNCF。TOC 成员应有充足的时间讨论和审查新的项目建议书。新的项目建议书应包括项目中的角色细节，为项目提出的治理，并确定与 CNCF 的角色和价值观保持一致。&lt;/p&gt;
&lt;h3 id=&#34;10-市场委员会&#34;&gt;10. 市场委员会&lt;/h3&gt;
&lt;p&gt;a) 构成，市场委员会将向所有成员开放参与，应选举市场委员会主席制定会议议程，进行一般的讨论，并帮助委员会实现其目标。市场委员会应尽可能寻求共识。在市场委员会中无法达成共识的任何问题应提交给理事会。&lt;/p&gt;
&lt;p&gt;b) 职责，市场委员会代表理事会负责设计，开发和执行相关的市场工作。&lt;/p&gt;
&lt;p&gt;c) 如果市场委员会变得太大而无法有效运作，市场委员会可以选择选举市场董事，并将决策权委托给市场董事。&lt;/p&gt;
&lt;h3 id=&#34;11-知识产权政策&#34;&gt;11. 知识产权政策&lt;/h3&gt;
&lt;p&gt;a) 任何加入到 CNCF 的项目都必须将其拥有的商标和徽标资产转让给 Linux 基金会的所有权。&lt;/p&gt;
&lt;p&gt;b) 每个项目应确定是否需要使用经批准的 CNCF CLA。对于选择使用 CLA 的项目，所有代码贡献者将承担 Apache 贡献者许可协议中规定的义务，只有在必要时才作出修改，以确定 CNCF 是捐赠的接受者，并且应由理事会批准。请参阅 &lt;a href=&#34;https://github.com/cncf/cla&#34; title=&#34;https://github.com/cncf/cla&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/cla&lt;/a&gt; 上提供的 CNCF 参与者许可协议。&lt;/p&gt;
&lt;p&gt;c) 所有向 CNCF 提交的新入站代码应当（i）附有开发者原始证书签名（&lt;a href=&#34;https://developercertificate.org&#34; title=&#34;https://developercertificate.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developercertificate.org&lt;/a&gt;和（ii）根据 Apache 许可证 2.0 版（可从&lt;a href=&#34;https://developercertificate.org&#34; title=&#34;https://developercertificate.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developercertificate.org&lt;/a&gt;和&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34; title=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt; 获得）该许可证除了并且不得取代根据上文（b）规定的供款许可协议所承担的义务。&lt;/p&gt;
&lt;p&gt;d) 所有出站代码将在 Apache 许可证 2.0 版下提供。&lt;/p&gt;
&lt;p&gt;e) 所有评估纳入 CNCF 的项目都必须获得 OSI 批准的开源许可证的完全许可，如果 CNCF 中包含的项目的许可证不是 Apache 许可证 2.0 版，则需要获得理事会的批准。&lt;/p&gt;
&lt;p&gt;f) 所有文档将由 CNCF 根据知识共享署名 4.0 国际许可证来提供。&lt;/p&gt;
&lt;p&gt;g) 如果需要替代入站或出站许可证以符合杠杆式开放源代码项目的许可证或为实现 CNCF 的使命而需要其他许可证，理事会可以批准使用替代许可证 对于例外情况下的接受或提供的项目捐赠。&lt;/p&gt;
&lt;h3 id=&#34;12-反托拉斯指南&#34;&gt;12. 反托拉斯指南&lt;/h3&gt;
&lt;p&gt;a) 所有成员均应遵守&lt;a href=&#34;http://www.linuxfoundation.org/antitrust-policy&#34; title=&#34;http://www.linuxfoundation.org/antitrust-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.linuxfoundation.org/antitrust-policy&lt;/a&gt;上提供的 Linux 基金会反托拉斯政策中规定的 Linux 基金会的要求。&lt;/p&gt;
&lt;p&gt;b) 所有成员都应鼓励任何能够满足成员要求的组织的公开参与，而不论其竞争利益如何。换言之，理事会不应根据除用于所有成员的标准，要求或原因之外的任何标准，要求或理由寻求排除成员。&lt;/p&gt;
&lt;h3 id=&#34;13-行为准则&#34;&gt;13. 行为准则&lt;/h3&gt;
&lt;p&gt;所有参与者都须同意遵守 &lt;a href=&#34;http://events.linuxfoundation.org/code-of-conduct&#34; title=&#34;Linux 基金会行为准则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 基金会行为准则&lt;/a&gt;。TSC 可以投票通过自己的 CNCF 行为准则。&lt;/p&gt;
&lt;h3 id=&#34;14-关联公司&#34;&gt;14. 关联公司&lt;/h3&gt;
&lt;p&gt;a) 定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“子公司”是指会员直接或间接拥有所涉实体超过百分之五十有投票权的证券或会员权益的任何实体；&lt;/li&gt;
&lt;li&gt;“关联公司”是指任何控制或由成员控制的实体，或者与成员一起受第三方共同控制的实体，在所有情况下，直接或间接拥有多于所有权的控制权；&lt;/li&gt;
&lt;li&gt;“关联公司”是指各成员的关联公司。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b) 只有执行了参与协议的法人实体及其子公司才有权享有该会员的权利和特权；但条件是该成员及其子公司应作为单一成员共同对待。&lt;/p&gt;
&lt;p&gt;c) 只有一名属于一组关联公司的成员有权一次性任命或提名理事会代表参加类别选举。&lt;/p&gt;
&lt;p&gt;d) 如果会员本身是会员或赞助商的基金会，联盟，开源项目，会员组织，用户组或其他实体，那么授予该成员的权利和特权只能扩展到该成员的员工代表，而不能扩展到其成员或发起人，除非理事会不时在特定情况下另行批准。&lt;/p&gt;
&lt;p&gt;e) 会员资格不得转让，不可转让、也不能转让，除非现有会员将其现有的会员利益和义务转让给其大部分业务和/或资产的继任者，无论是通过合并，出售还是其他方式；只要受让人同意遵守 CNCF 的章程以及 Linux Foundation 成员所需的章程和政策。&lt;/p&gt;
&lt;h3 id=&#34;15-预算&#34;&gt;15. 预算&lt;/h3&gt;
&lt;p&gt;a) 理事会应批准年度预算，绝不会承诺超出筹集的资金。预算应与 Linux 基金会的非营利性使命相一致。&lt;/p&gt;
&lt;p&gt;b) Linux 基金会应定期报告预算支出。&lt;/p&gt;
&lt;h3 id=&#34;16-常规和管理费用&#34;&gt;16. 常规和管理费用&lt;/h3&gt;
&lt;p&gt;a) Linux 基金会应保管任何费用，资金和其他现金收据。&lt;/p&gt;
&lt;p&gt;b) 一般和行政（G＆A）费用将用于筹集资金以支付财务、会计和运营费用。G＆A 费用应等于 CNCF 首期总收入 1,000,000 美元的 9％以及 CNCF 总收入超过 1,000,000 美元的 6％。&lt;/p&gt;
&lt;h3 id=&#34;17-一般规则和操作&#34;&gt;17. 一般规则和操作&lt;/h3&gt;
&lt;p&gt;参与 CNCF 应做到：&lt;/p&gt;
&lt;p&gt;a) 展示与开源项目开发人员社区进行协调的计划和方法，包括关于代表社区的品牌、徽标和其它标志性的主题；&lt;/p&gt;
&lt;p&gt;b) 以专业的方式体现维持社区的凝聚力为目标，同时还要保持 Linux 基金会在开放源代码软件社区的善意和尊重；&lt;/p&gt;
&lt;p&gt;c) 尊重所有商标所有人的权利，包括任何品牌和使用准则；&lt;/p&gt;
&lt;p&gt;d) 参与 Linux 基金会的所有新闻和分析师关系活动；&lt;/p&gt;
&lt;p&gt;e) 根据要求，向 Linux 基金会提供关于项目参与的信息，包括参加项目赞助活动的信息；&lt;/p&gt;
&lt;p&gt;f) 直接参与到基金会旗下的任何站点。&lt;/p&gt;
&lt;p&gt;g) 根据理事会批准的规则和程序进行运营，前提是这些规则和程序不得与 Linux 基金会的宗旨和政策不一致，并且不得损害 Linux 基金会。&lt;/p&gt;
&lt;h3 id=&#34;18-修正案&#34;&gt;18. 修正案&lt;/h3&gt;
&lt;p&gt;本章程可以通过所有理事会成员的三分之二票数（不包括弃权）进行修改，前提是任何此类修改不得与 Linux 基金会的目的或政策不一致，并且不得对 Linux 基金会产生不利影响。&lt;/p&gt;
&lt;h3 id=&#34;时间表-a提出-cncf-范围愿景&#34;&gt;时间表 A：提出 CNCF 范围愿景&lt;/h3&gt;
&lt;p&gt;CNCF 背后的首要目标是支持和加速“云原生计算”的采用。以下内容是初步范围，旨在阐明 CNCF 将努力实施的“云原生计算”的核心概念。该初始范围应成为发布在 CNCF 网站上的文档。&lt;/p&gt;
&lt;p&gt;CNCF 社区坚信云原生计算包含三个核心属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装和分发&lt;/li&gt;
&lt;li&gt;动态调度&lt;/li&gt;
&lt;li&gt;面向微服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：关于云原生的定义正在重新设定中，已经与上述不同了。&lt;/p&gt;
&lt;p&gt;云原生计算系统支持基于这些核心属性的计算，并包含以下理想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放性和可扩展性&lt;/li&gt;
&lt;li&gt;在标准化子系统的边界处定义良好的 API&lt;/li&gt;
&lt;li&gt;应用程序生命周期管理的最小障碍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为上述时间表已经有些过时了，CNCF 成立已经有三年时间了，正在规划新的方案。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/&#34; title=&#34;https://www.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/landscape&#34; title=&#34;https://github.com/cncf/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/toc&#34; title=&#34;https://github.com/cncf/toc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/toc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
