<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song&#39;s Blog – 云原生</title>
    <link>https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    <description>Recent content in 云原生 on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 16 Apr 2024 12:54:49 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>前言</title>
      <link>https://jimmysong.io/book/cloud-native-infra/forward/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/forward/</guid>
      <description>
        
        
        &lt;p&gt;还记得有一次告警电话半夜把我吵醒，发现是生产环境离线了。原来是系统瘫痪了，我们不得不要赔钱，这是我的错。&lt;/p&gt;
&lt;p&gt;从那一刻起，我就一直痴迷于构建坚如磐石的基础架构和基础架构管理系统，这样我就不会重蹈覆辙了。在我的职业生涯中，我为 Terraform、Kubernetes，一些编程语言和 Kops 做出过贡献，并创建了 Kubicorn。我不仅见证了系统基础架构的发展，而且我也帮助它完善。随着基础架构行业的发展，我们发现企业基础架构现在正以新的、令人兴奋的方式通过应用层管理。到目前为止，Kubernetes 是这种管理基础架构的新范例的最成熟的例子。&lt;/p&gt;
&lt;p&gt;我与人合著了这本书，部分地介绍了将基础架构作为云原生软件的新范例。此外，我希望鼓励基础架构工程师开始编写云原生应用程序。在这本书中，我们探讨了管理基础架构的丰富历史，并为云原生技术的未来定义了管理基础架构的模式。我们解释了基础架构由软件化 API 驱动的重要性。我们还探索了创建复杂系统的第一个基础架构组件的引导问题，并教授了扩展和测试基础架构的重要性。&lt;/p&gt;
&lt;p&gt;我于 2017 年加入 Heptio，担任资深布道师，并且很高兴能与行业中最聪明的系统工程师密切合作。构建纯粹的开源技术对我来说一直都很重要，Heptio 也拥有这种激情。我很荣幸能在这样一个环境中工作，让我更热爱这个行业。我希望你喜欢这本书，就像 Justin 和我喜欢写这本书一样。&lt;/p&gt;
&lt;p&gt;——Kris Nova&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生基础架构</title>
      <link>https://jimmysong.io/book/cloud-native-infra/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/</guid>
      <description>
        
        
        &lt;p&gt;本书为 &lt;em&gt;Cloud Native Infrastructure&lt;/em&gt; 中文版，作者 &lt;em&gt;Justin Garrison&lt;/em&gt; 和 &lt;em&gt;Kris Nova&lt;/em&gt;，英文版发行于 2017 年 11 月，已可以在网上免费获得，本书是关于创建和管理基础架构，以适用于云原生应用全生命周期管理的模式和实践。&lt;/p&gt;
&lt;p&gt;阅读完这本书后，您将会有如下收获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解为什么说云原生基础架构是高效运行云原生应用所必须的&lt;/li&gt;
&lt;li&gt;根据准则来决定您的业务何时以及是否应该采用云原生&lt;/li&gt;
&lt;li&gt;了解部署和管理基础架构和应用程序的模式&lt;/li&gt;
&lt;li&gt;设计测试以证明您的基础架构可以按预期工作，即使在各种边缘情况下也是如此&lt;/li&gt;
&lt;li&gt;了解如何以策略即代码的方式保护基础架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本书大纲&#34;&gt;本书大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/forward/&#34;&gt;前言&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/introduction/&#34;&gt;介绍&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/what-is-cloud-native-infrastructure/&#34;&gt;第 1 章：什么是云原生基础架构？&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/when-to-adopt-cloud-native/&#34;&gt;第 2 章：采纳云原生基础架构的时机&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/evolution-of-cloud-native-developments/&#34;&gt;第 3 章：云原生部署的演变&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/designing-infrastructure-applicaitons/&#34;&gt;第 4 章：设计基础架构应用程序&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/developing-infrastructure-applications/&#34;&gt;第 5 章：开发基础架构应用程序&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/&#34;&gt;第 6 章：测试云原生基础架构&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/managing-cloud-native-applications/&#34;&gt;第 7 章：管理云原生应用程序&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/securing-applications/&#34;&gt;第 8 章：保护应用程序&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/implementing-cloud-native-infrasctructure/&#34;&gt;第 9 章：实施云原生基础架构&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/appendix-a-patterns-for-network-resiilency/&#34;&gt;附录 A：网络弹性模式&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/appendix-b-lock-in/&#34;&gt;附录 B：锁定&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/cloud-native-infra/appendix-c-box-case-study/&#34;&gt;附录 C Box：案例研究&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;


&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;p&gt;本书英文版版权属于 O’Reilly，中文版版权归属于机械工业出版，基于&lt;a href=&#34;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&#34; title=&#34;署名 - 非商业性使用 - 相同方式共享 4.0（CC BY-NC-SA 4.0）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;署名 - 非商业性使用 - 相同方式共享 4.0（CC BY-NC-SA 4.0）&lt;/a&gt;
分享，本书为云原生爱好者翻译，仅可用于学习和交流目的，请勿私自印制贩卖，如有需要请&lt;a href=&#34;https://item.jd.com/12432007.html&#34; title=&#34;购买纸质书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;购买纸质书&lt;/a&gt;
。&lt;/p&gt;
&lt;ul class=&#34;cta-group&#34;&gt;
  
  &lt;li&gt;
    &lt;a href=&#34;foreword&#34;  class=&#34;btn btn-sm btn-primary&#34;&gt;开始阅读&lt;/a&gt;
  &lt;/li&gt;
  
  
&lt;/ul&gt;


      </description>
    </item>
    
    <item>
      <title>介绍</title>
      <link>https://jimmysong.io/book/cloud-native-infra/introduction/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/introduction/</guid>
      <description>
        
        
        &lt;p&gt;基础设施技术的历史向来引人入胜。由于基础设施的规模巨大，它已经经历了一次快速的颠覆性变革。除了计算机和互联网的早期，基础设施可谓日新月异。这些创新使基础架构更快，更可靠，更有价值。&lt;/p&gt;
&lt;p&gt;有些公司的人将基础设施推到了极限，他们已经找到了自动化和抽象的方法，提取基础设施更多商业价值。通过提供灵活的可用资源，他们将曾经是昂贵的成本中心转变为所需的商业公用事业。&lt;/p&gt;
&lt;p&gt;然而，公共事业公司很少为企业提供财务价值，这意味着基础设施往往被忽略并被视为不必要的成本。这使得投入创新或改进的时间和金钱很少。&lt;/p&gt;
&lt;p&gt;这样一个如此简单且令人着迷的业务栈怎么可以被轻易忽略？当基础设施出现故障时，业务显然会受到重视，那么为什么基础设施很难改善呢？&lt;/p&gt;
&lt;p&gt;基础设施已经达到了使消费者都感到无聊的成熟度。然而，它的潜力和新挑战又激发了实施者和工程师们新的激情。&lt;/p&gt;
&lt;p&gt;扩展基础设施并使用新的业务方式让来自不同行业的工程师都能找到解决方案。开源软件（OSS）和社区间的互相协作，这股力量又促使了创新的激增。&lt;/p&gt;
&lt;p&gt;如果管理得当，今天基础设施和应用方面的挑战将会不一样。这使得基础设施建设者和维护人员可以取得进展并开展新的有意义的工作。&lt;/p&gt;
&lt;p&gt;有些公司克服了诸如可扩展性、可靠性和灵活性等挑战。他们创建并封装了一些项目，封装了可供他人遵循的模式。这些模式有时很容易被实现者发现，但在其他情况下，它们不太明显。&lt;/p&gt;
&lt;p&gt;在本书中，我们将分享来自云原生技术前沿的公司的经验教训，使您能够有效解决可靠运行可伸缩应用程序的问题。现代商业发展非常迅速。本书中的模式将使您的基础设施能够跟上业务的速度和敏捷性需求。更重要的是，我们会让您自行决定何时采用这些模式。&lt;/p&gt;
&lt;p&gt;这些模式中有很多都已经在开源项目中得到了体现。其中一些项目由云原生计算基金会（CNCF）维护。这些项目和基金会并不是模式的唯一体现，但忽视它们会让你失去理智。以它们为例，但要自己进行尽职调查，以审核您所采用的每个解决方案。&lt;/p&gt;
&lt;p&gt;我们将向您展示云原生基础设施的益处以及可扩展系统和应用程序的基本模式。我们将向您展示如何测试您的基础设施，以及如何创建一个可以适应您需求的灵活的基础设施。您将了一些重要方面和未来发展。&lt;/p&gt;
&lt;p&gt;这本书可以激励你继续前进并自由分享你在社区中学到的知识。&lt;/p&gt;
&lt;h2 id=&#34;谁应该读这本书&#34;&gt;谁应该读这本书&lt;/h2&gt;
&lt;p&gt;如果您是开发基础设施或基础设施管理工具的工程师，那么本书就是为您准备的。本书将帮助您了解创建旨在在云环境中运行的基础设施的模式、流程和实践。通过了解应该怎么做，您可以更好地了解应用程序的作用，以及应该何时构建基础设施或使用云服务。&lt;/p&gt;
&lt;p&gt;应用程序工程师从本书中还可以发现哪些服务应该是其应用程序的一部分，哪些服务应该由基础设施提供。通过本书了解应用开发者和管理基础设施的工程师应该共同承担的责任。&lt;/p&gt;
&lt;p&gt;希望提升技能并系统地在设计基础设施和维护云网关基础设施方面发挥更大作用的系统管理员也可以从本书中学到很多。&lt;/p&gt;
&lt;p&gt;你是否在公有云中运行所有的基础设施？本书将帮助您了解何时使用云服务以及何时构建自己的抽象或服务。&lt;/p&gt;
&lt;p&gt;运行在数据中心还是本地云？我们将概述现代应用对基础设施的期望，并将帮助您了解利用当前投资的必要服务。&lt;/p&gt;
&lt;p&gt;这本书不是一本教程，除了给出实现示例之外，我们没有指出特定的产品。对于经理、董事和高管来说，这可能太过技术性，但可能会有所帮助，具体取决于该角色的参与和技术专长。&lt;/p&gt;
&lt;p&gt;最重要的是，如果您想了解基础设施如何影响业务，请阅读本书，以及如何创建经证实可为具备全球互联网运营规模的企业服务的基础设施。即使您的应用程序不需要扩展到这种规模，如果您的基础设施是使用此处描述的模式构建的，并且考虑到灵活性和可操作性，这本书仍然值得一读。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们写了这本书&#34;&gt;为什么我们写了这本书&lt;/h2&gt;
&lt;p&gt;我们希望通过专注于模式和实践而不是特定产品和供应商来帮助您了解。当前存在太多的解决方案而人们不了解它们本身到底要解决什么问题。&lt;/p&gt;
&lt;p&gt;我们相信通过云原生应用程序管理云原生基础设施的好处，并且我们希望所有人都具有这种意识。&lt;/p&gt;
&lt;p&gt;我们希望回馈社区，推动行业向前发展。我们发现这样做的最好方式是解释业务和基础设施之间的关系，阐明问题并解释发现它们的工程师和组织所做的解决方案。&lt;/p&gt;
&lt;p&gt;以不涉及产品的方式解释模式并不总是很容易，但了解产品存在的原因很重要。我们经常使用产品作为模式的例子，但只有当它们会帮助您提供解决方案的实施示例时才会提到。&lt;/p&gt;
&lt;p&gt;如果没有无数人数万小时的自愿编写代码，帮助他人以及投资社区，我们就不会走到这里。我们非常感谢那些帮助我们了解这些模式的人们，我们希望能够回馈并帮助下一代工程师。这本书就是我们表达谢意的方式。&lt;/p&gt;
&lt;h2 id=&#34;浏览本书&#34;&gt;浏览本书&lt;/h2&gt;
&lt;p&gt;本书的组织结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 章介绍云原生基础设施是什么以及我们如何走到当前这一步。&lt;/li&gt;
&lt;li&gt;第 2 章可以帮助您决定是否以及何时采用后面章节中预先描述的模式。&lt;/li&gt;
&lt;li&gt;第 3 章和第 4 章展示了应该如何部署基础设施以及如何编写应用程序来管理它。&lt;/li&gt;
&lt;li&gt;第 5 章将教你如何从测试开始就设计可靠的基础设施。&lt;/li&gt;
&lt;li&gt;第 6 章和第 7 章展示了如何管理基础设施和应用程序。&lt;/li&gt;
&lt;li&gt;第 8 章总结并提供了一些有关未来发展的见解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你像我们一样，不会从前到后完整看完本书。以下是关于本书主题的一些建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果您是一位专注于创建和维护基础设施的工程师，您应该至少阅读第 3 章至第 6 章。&lt;/li&gt;
&lt;li&gt;应用程序开发人员可以专注于第 4、5 和 7 章关于将基础架构工具开发为云原生应用程序。&lt;/li&gt;
&lt;li&gt;所有不构建云原生基础设施的人都将从第 1、2、8 章中受益匪浅。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在线资源&#34;&gt;在线资源&lt;/h2&gt;
&lt;p&gt;您应该通过访问 CNCF 网站熟悉云原生计算基金会（CNCF）及其托管项目。本书中的许多项目都被用作示例。&lt;/p&gt;
&lt;p&gt;您还可以通过查看 CNCF 景观项目（参见图 P-1），了解项目这些项目的全局视图。&lt;/p&gt;
&lt;p&gt;云原生应用程序是从 Heroku 的 12 因素的定义开始的。我们会解释它们之间的相似之处，但你应该熟悉下 12 因素是什么（参见 &lt;a href=&#34;http://12factor.net/&#34; title=&#34;http://12factor.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://12factor.net&lt;/a&gt;
）。&lt;/p&gt;
&lt;p&gt;还有许多关于 DevOps 的书籍、文章和演讲。尽管本书不关注 DevOps 实践，但是在实现云原生基础设施时，如果没有 DevOps 规定的工具、实践和文化，将很难实现。&lt;/p&gt;
&lt;h2 id=&#34;致谢&#34;&gt;致谢&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Justin Garrison&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢 Beth、Logan、我的朋友、家人以及在此过程中支持我们的同事。感谢那些帮助我们的社区和社区领袖以及给予宝贵反馈的评论者。感谢 Kris 让这本书变得更好，感谢读者花点时间阅读本书并提高你的技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kris Nova&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢 Allison、Bryan、Charlie、Justin、Kjersti、Meghann 和 Patrick 为我写这本书所作出的帮助。我爱你们，永远感激你们为我所做的一切。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>什么是云原生基础架构？</title>
      <link>https://jimmysong.io/book/cloud-native-infra/what-is-cloud-native-infrastructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/what-is-cloud-native-infrastructure/</guid>
      <description>
        
        
        &lt;p&gt;基础架构是指支持应用程序的所有软件和硬件，包括数据中心、操作系统、部署流水线、配置管理以及支持应用程序生命周期所需的任何系统或软件。&lt;/p&gt;
&lt;p&gt;已经有无数的时间和金钱花在了基础架构上。通过多年来不断的技术演化和实践提炼，有些公司已经能够运行大规模的基础架构和应用程序，并且拥有卓越的敏捷性。高效运行的基础架构可以使得迭代更快，缩短投向市场的时间，从而加速业务发展。&lt;/p&gt;
&lt;p&gt;使用云原生基础架构是有效运行云原生应用程序的要求。如果没有正确的设计和实践来管理基础架构，即使是最好的云原生应用程序也会浪费。本书中的实践并不一定需要有巨大的基础架构规模，但如果您想从云计算中获取回报，您应该听从开创了这些模式的人的经验。&lt;/p&gt;
&lt;p&gt;在我们探索如何构建云中运行的应用程序的基础架构之前，我们需要了解我们是如何走到这一步。首先，我们将讨论采用云原生实践的好处。接下来，我们将看一下基础架构的简历，然后讨论下一阶段的功能，称为“云原生”，以及它与您的应用程序、运行的平台及业务之间的关系。&lt;/p&gt;
&lt;p&gt;在明白了这一点后，我们将向您展示解决方案及实现。&lt;/p&gt;
&lt;h2 id=&#34;云原生的优势&#34;&gt;云原生的优势&lt;/h2&gt;
&lt;p&gt;采用本书中的模式有很多好处。它们仿照谷歌、Netflix 和亚马逊这些成功的公司 —— 不是单靠模式保证它们的成功，而是它们提供了这些公司成功所需的可扩展性和敏捷性。&lt;/p&gt;
&lt;p&gt;通过选择在公有云中运行基础架构，您可以更快地创造价值并专注于业务目标。只需构建您的产品所需的内容，并从其他提供商那里获得服务，就可以缩短交付时间，提高灵活性。有些人可能因为“供应商锁定”而犹豫不决，但最糟糕的锁定是您自己建立的锁定。有关不同类型的锁定，以及您应该如何处理的更多信息，请参阅附录 B。&lt;/p&gt;
&lt;p&gt;消费服务还可让您使用所需服务构建定制平台（有时称为服务即平台 [SaaP]）。当您使用云托管的服务时无需精专于管理应用程序所需要的每项服务。这极大地加强了业务变更和业务增值的能力。&lt;/p&gt;
&lt;p&gt;当您无法使用服务时，您应该构建应用程序来管理基础架构。当您这样做时，规模瓶颈不再取决于每个运维工程师可以管理多少台服务器。相反，您可以像扩展应用程序一样来扩展您的基础架构。换句话说，如果您能够运行可扩展的应用程序，则可以使用应用程序扩展您的基础架构。&lt;/p&gt;
&lt;p&gt;同样的好处适用于构建灵活且易于调试的基础架构。您可以使用与管理业务应用程序相同的工具来洞察您的基础架构。&lt;/p&gt;
&lt;p&gt;云原生实践还可以缩小传统工程角色之间的差距（DevOps 的共同目标）。系统工程师将能够从应用程序中学习最佳实践，开发工程师可以拥有应用程序运行所在的基础架构的所有权。&lt;/p&gt;
&lt;p&gt;云原生基础架构的解决方案不一定适用于所有问题，您有责任了解它是否适合您的环境（参见第 2 章）。然而，在创造了这些实践的公司以及采用以该模式创建的工具的公司中，云原生基础架构的成功可以说显而易见。请参见附录 C 的一个例子。&lt;/p&gt;
&lt;p&gt;在深入了解解决方案之前，先让我是探究一下是什么问题导致这些模式的出现。&lt;/p&gt;
&lt;h2 id=&#34;服务器&#34;&gt;服务器&lt;/h2&gt;
&lt;p&gt;在互联网早期，Web 基础架构始于物理服务器。服务器庞大，吵闹且昂贵，需要大量的电力和人员投入以保持它们的运行。需要细心照料，尽可能保持长时间运行。与云基础架构相比，购买这些设备让应用程序运行在上面会更困难。&lt;/p&gt;
&lt;p&gt;一旦您买了服务器，它就是您的了，无论好坏，都要维护。使用物理服务器适合已确定成本的业务。持有物理服务器并运行的时间越长，您花费的钱越多。做适当的产能规划并确保您获得最佳的投资回报是很重要的。&lt;/p&gt;
&lt;p&gt;物理服务器非常棒，因为它们功能强大，可以根据需要进行配置。故障率相对较低，使用冗余电源供应，风扇和 RAID 控制器来避免出现故障。也可以持续运行很长时间。企业可以通过延长保修和更换零部件，从购买的硬件中挤出额外的价值。&lt;/p&gt;
&lt;p&gt;但是，物理服务器会导致浪费。服务器不仅没有被充分利用，而且还带来了很多开销。在同一台服务器上运行多个应用程序是很困难的。当在同一台服务器上最大限度得部署多个应用程序时，软件冲突，网络路由和用户访问都变得更加复杂。&lt;/p&gt;
&lt;p&gt;硬件虚拟化承诺可以解决其中的一些问题。&lt;/p&gt;
&lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h2&gt;
&lt;p&gt;虚拟化使用软件来模拟物理服务器的硬件。虚拟服务器可以按需创建，完全可以通过软件编程，只要您可以模拟硬件，就永远不会出现损耗。&lt;/p&gt;
&lt;p&gt;使用 hypervisor 可以增加这些优势，因为您可以在物理服务器上运行多个虚拟机（VM）。它还使得应用程序可移植，因为您可以将虚拟机从一台物理服务器移动到另一台物理服务器。&lt;/p&gt;
&lt;p&gt;然而，运行自己的虚拟化平台的一个问题是虚拟机仍然需要硬件来运行。公司仍然需要拥有运行物理服务器所需的所有人员和流程，但是现在容量规划变得更加困难，因为他们还必须考虑到虚拟机的开销。至少，公有云出现之前就是如此。&lt;/p&gt;
&lt;h2 id=&#34;基础架构即服务&#34;&gt;基础架构即服务&lt;/h2&gt;
&lt;p&gt;基础架构即服务（IaaS）是云提供商的众多产品之一。它提供了原始的网络、存储和计算能力，客户可以根据需要使用它们。它还包括一些支持服务，如身份和访问管理（IAM）、供应和库存系统。&lt;/p&gt;
&lt;p&gt;IaaS 允许公司摆脱他们的所有硬件，并从别人那里租用虚拟机或物理服务器。这释放了大量人力资源，摆脱了购买、维护以及在某些情况下容量规划所需的流程。&lt;/p&gt;
&lt;p&gt;IaaS 从根本上改变了基础架构与业务的关系。不是随着时间的推移受益的资本支出，而是运营业务的运营支出。企业可以像支付电力和人们的时间一样支付基础架构。通过基于消费的计费，您越早摆脱基础架构，运营成本就越低。&lt;/p&gt;
&lt;p&gt;托管的基础架构还为客户提供了可消费的 HTTP 应用编程接口（API），以便按需创建和管理基础架构。工程师不需要购买订单并等待物品出货，就可以进行 API 调用，并创建服务器。服务器可以轻松删除和丢弃。&lt;/p&gt;
&lt;p&gt;在云中运行基础架构不会使您的基础架构成为云原生。IaaS 仍然需要基础架构管理。在购买和管理物理资源之外，您可以（也有许多公司）认为 IaaS 与过去购买服务器在自己的数据中心架设的传统基础架构一模一样。&lt;/p&gt;
&lt;p&gt;即使没有“货架和堆叠”，仍然有大量的操作系统、监控软件和支持工具。自动化工具帮助减少了运行应用程序所需的时间，但通常根深蒂固的流程会削弱 IaaS 的优势。&lt;/p&gt;
&lt;h2 id=&#34;平台即服务&#34;&gt;平台即服务&lt;/h2&gt;
&lt;p&gt;就像 IaaS 对 VM 消费者隐藏了物理服务器一样，平台即服务（PaaS）也对应用程序隐藏了操作系统。开发人员编写应用程序代码并定义应用程序的依赖关系，平台负责创建运行，管理和暴露它所必要的基础架构。与需要基础架构管理的 IaaS 不同，PaaS 中的基础架构由平台提供商管理。&lt;/p&gt;
&lt;p&gt;事实证明，PaaS 限制要求开发人员以不同的方式编写应用程序，以便平台可以有效管理。应用程序必须包含允许由平台管理而不访问底层操作系统的功能。工程师不能再依赖 SSH 登入到服务器来读取磁盘上的日志文件。现在应用程序的生命周期和管理由 PaaS 控制，工程师和应用程序需要适应这个流程。&lt;/p&gt;
&lt;p&gt;这些限制带来了很大的好处。应用程序开发周期变短了，因为工程师不需要花时间管理基础架构。在平台上运行的应用程序是我们现在称为“云原生应用程序”的开始。利用代码中的平台限制，已经一定程度上改变了当今编写应用程序的方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;12 因素应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heroku 是提供公有 PaaS 的早期先驱之一。通过自己平台的多年扩展，该公司能够确定帮助应用程序在其环境中更好运行的模式。Heroku 定义了应用程序时应实现的 12 个主要因素。&lt;/p&gt;
&lt;p&gt;这 12 个因素是通过将代码逻辑与数据分离来使开发人员更高效，尽可能自动化，独立的构建、传输和运行阶段过程；并声明所有的应用程序的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您使用 PaaS 提供商所提供的基础架构，恭喜您已拥有云原生基础架构的诸多优势。这包括 Google App Engine、AWS Lambda 和 Azure Cloud Services 等平台。任何成功的云原生基础架构都将向应用工程师展示自助服务平台，以部署和管理代码。&lt;/p&gt;
&lt;p&gt;但是，许多 PaaS 平台不足以满足业务需求。它们通常会限制平台运行的语言、库和功能以实现从应用程序中抽离基础架构的承诺。公有 PaaS 提供商还将限制哪些服务可以与应用程序集成以及这些应用程序可以在哪里运行。&lt;/p&gt;
&lt;p&gt;公有平台牺牲了应用程序的灵活性，使基础架构成为别人的问题。图 1-1 是如果您运行自己的数据中心，在 IaaS 中创建基础架构，在 PaaS 上运行应用程序或通过软件即服务（SaaS）运行应用程序时需要管理的组件的直观表示。&lt;/p&gt;
&lt;p&gt;您需要运行的基础架构组件越少越好；但是在公有 PaaS 提供商中运行所有应用程序可能不是一种选择。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/what-is-cloud-native-infrastructure/f-1-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/what-is-cloud-native-infrastructure/f-1-1.jpg&#34; data-width=&#34;1286&#34; data-height=&#34;876&#34; alt=&#34;image&#34; data-caption=&#34;图 1-1. 基础架构层&#34;&gt;
    
  
  &lt;figcaption&gt;图 1-1. 基础架构层&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生基础架构&#34;&gt;云原生基础架构&lt;/h2&gt;
&lt;p&gt;“云原生”是一个过度使用的术语。尽管它已被市场所劫持，但仍具有工程和管理上的意义。对我们来说，它意味着在这个公有云提供商的世界中正发生的技术变革。&lt;/p&gt;
&lt;p&gt;云原生基础架构是隐藏在有用的抽象背后的基础架构，由 API 控制，由软件管理并具有运行应用程序的目的。利用这些特征运行基础架构，能以可扩展高效的方式管理该基础架构。&lt;/p&gt;
&lt;p&gt;当它们成功地向消费者隐藏复杂性时，抽象是有用的。它们可以实现技术的更复杂的使用，但是它们也限制了技术的使用方式。它们适用于底层技术，例如 TCP 如何提取 IP 或更高级别的技术，如虚拟机如何抽象物理服务器。抽象应该总是允许消费者“向上移动堆栈”而不是重新实现底层。&lt;/p&gt;
&lt;p&gt;云原生基础架构需要抽象基础 IaaS 产品以提供自己的抽象。新层负责控制它下面的 IaaS，并将自己的 API 暴露给消费者控制。&lt;/p&gt;
&lt;p&gt;由软件管理的基础架构是云中的一个关键区别点。软件控制的基础架构使基础架构能够扩展，并且在弹性、供应和可维护性方面也发挥着重要作用。软件需要了解基础架构的抽象概念，并知道如何获取抽象资源并相应地在可消费的 IaaS 组件中实现它。&lt;/p&gt;
&lt;p&gt;这些模式不仅影响基础架构的运行方式，而且在云原生基础架构上运行的应用程序类型、在其上工作的人员类型与传统基础架构中是不同的。&lt;/p&gt;
&lt;p&gt;如果云原生基础架构看起来很像 PaaS 产品，那么我们如何才能知道构建自己的产品时需要注意什么？我将快速描述一些领域，它们可能看起来像是云原生解决方案，但不提供云原生基础架构的所有方面。&lt;/p&gt;
&lt;h2 id=&#34;什么不是云原生基础架构&#34;&gt;什么不是云原生基础架构？&lt;/h2&gt;
&lt;p&gt;云原生基础架构不等于在公有云上运行基础架构。仅租用服务器并不会使您的基础架构云原生化。管理 IaaS 的流程与运行物理数据中心通常没有什么不同，许多将现有基础架构迁移到云的公司都未能获得回报。&lt;/p&gt;
&lt;p&gt;云原生不等于在容器中运行应用程序。Netflix 最先推出云原生基础架构时，几乎所有应用程序都部署在虚拟机中，而不是在容器中。使用容器的方式打包应用程序并不能意味着拥有了自治系统的可扩展性和优势。即使应用程序是通过持续集成和持续交付渠道自动构建和部署的，也不等于就可以从 API 驱动部署的基础架构中受益。&lt;/p&gt;
&lt;p&gt;也不是说只要您运行了容器编排器（例如 Kubernetes 和 Mesos）就是云原生架构。容器编排器提供了云原生基础架构所需的平台功能，但如果未按预期方式使用这些功能的话，那也只是将应用程序会动态调度到一组服务器上而已。这是一个非常好的起步，但仍有很多工作要做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;调度器与编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“调度器”和“编排器”这两个术语通常可以互换使用。&lt;/p&gt;
&lt;p&gt;在大多数情况下，编排器负责集群中的所有资源使用（例如：存储，网络和 CPU）。该术语通常用于描述执行许多任务的产品，如健康检查和云自动化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调度器是编排平台的一个子集，仅负责为进程和服务选择所运行的服务器。&lt;/p&gt;
&lt;p&gt;云原生不等于微服务或基础架构即代码。微服务意味着更快的开发周期和更小的独立功能，但是单体应用程序可以具有相同的功能，使其能够通过软件有效管理，并且还可以从云原生基础架构中受益。&lt;/p&gt;
&lt;p&gt;基础架构即代码以机器可解析的语言或领域特定语言（DSL）定义、使基础架构自动化。使用代码管理基础架构的传统工具包括配置管理工具，例如 Chef 和 Puppet。这些工具在自动执行任务和提供一致性方面很有用，但是对于为超出单个服务器的基础架构提供必要的抽象描述方面存在缺陷。&lt;/p&gt;
&lt;p&gt;配置管理工具一次只自动化一台服务器，并靠人将服务器提供的功能绑定在一起。人成了管理大规模基础架构的潜在瓶颈。这些工具也不会使构建完整系统所需的云基础架构（例如存储和网络）的额外部分自动化。&lt;/p&gt;
&lt;p&gt;尽管配置管理工具为操作系统的资源（例如软件包管理器）提供了一些抽象，但它们对底层操作系统的抽象还不足以轻松管理软件包。如果有工程师想要管理系统中的所有软件包和文件，这将是一个非常痛苦的过程，因为软件包对于每个配置变体来说都是独一无二的。同样，定义不存在或不正确的资源配置管理只会白白的消耗系统资源而不能给我们提供任何价值。&lt;/p&gt;
&lt;p&gt;虽然配置管理工具可以帮助自动化部分基础架构，但它们无法更好地管理应用程序。我们将在后面的章节中通过查看部署、管理、测试和操作基础架构的流程，探讨云原生基础架构与配置管理工具的不同之处，但在此之前我们将了解何为成功的应用以及使用云原生基础架构的时机。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用程序&#34;&gt;云原生应用程序&lt;/h2&gt;
&lt;p&gt;就像云改变了业务和基础架构之间的关系一样，云原生应用程序也改变了应用程序和基础架构之间的关系。我们需要了解与传统应用程序相比，云本身有什么不同，因此我们需要了解它们与基础架构的新关系。&lt;/p&gt;
&lt;p&gt;为了写好本书，也为了有一个共享词汇表，我们需要定义“云原生应用程序”是什么意思。云原生与 12 因素应用程序不同，即使它们可能共享一些类似的特征。如果您想了解更多细节，请阅读 Kevin Hoffman 撰写的 &lt;em&gt;Beyond the Twelve-Factor App&lt;/em&gt;（O&amp;rsquo;Reilly，2012）。&lt;/p&gt;
&lt;p&gt;云原生应用程序被设计为在平台上运行，具有弹性、敏捷性、可操作性和可观测性。弹性能够容忍故障而不是试图阻止故障，利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观测性提供信息来回答有关应用程序状态的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;云原生定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生应用程序的定义仍在发展中。还有像 CNCF 这样的组织可以提供其他的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生应用程序的这些特征是通过各种方式获取的。它通常取决于应用程序的运行位置以及企业流程和文化。以下是实现云原生应用程序所需特性的常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;健康报告&lt;/li&gt;
&lt;li&gt;遥测数据&lt;/li&gt;
&lt;li&gt;弹性&lt;/li&gt;
&lt;li&gt;声明式的，而不是反应式的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;微服务&#34;&gt;微服务&lt;/h3&gt;
&lt;p&gt;作为单个实体进行管理和部署的应用程序通常称为单体应用。最开始开发应用程序时，单体有很多好处。它们更易于理解，并允许您在不影响其他服务的情况下更改主要功能。&lt;/p&gt;
&lt;p&gt;随着应用程序复杂性的增长，单体应用的优势也在逐渐减小。它们变得更难理解，而且失去了敏捷性，因为工程师很难推断和修改代码。&lt;/p&gt;
&lt;p&gt;对付复杂性的最好方法之一是将明确定义的功能分成更小的服务，并让每个服务独立迭代。这增加了应用程序的灵活性，允许根据需要更轻松地更改部分应用程序。每个微服务可以由单独的团队进行管理，使用适当的语言编写，并根据需要进行独立扩缩容。&lt;/p&gt;
&lt;p&gt;只要每项服务都遵守强有力的合约，应用程序就可以快速改进和改变。当然，转向微服务架构还有许多其他的考虑因素。最后才考虑的是弹性通信，我们在附录 A 中有讨论。&lt;/p&gt;
&lt;p&gt;我们无法考虑到迁移到微服务的所有考虑因素。使用微服务并不意味着就是云原生基础架构。如果您想拓展阅读，我们推荐 Sam Newman 的 Building Microservices（O&amp;rsquo;Reilly，2015）。虽然微服务是实现应用程序灵活性的一种方式，但正如我们之前所说的，它们不是云原生应用程序的必需条件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;健康报告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;停止逆向工程并开始从应用内部进行监控。&lt;/p&gt;
&lt;p&gt;——Kelsey Hightower，Monitorama PDX 2016：healthz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有人能比开发者更了解应用程序需要哪些条件才能健康运行了。曾经基础架构管理员都试图为自己负责运行的应用程序定义“健康”状态。在不了解是什么因素真正使应用程序的健康的情况下，监控和告警应用程序的不健康时状态往往是脆弱和不完整的。&lt;/p&gt;
&lt;p&gt;为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以以命令或过程信号的方式实现，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供 Web 服务，返回 HTTP 状态码来检查健康状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google Borg 示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google 的 Borg 报告中列出了一个健康报告的例子：&lt;/p&gt;
&lt;p&gt;几乎每个在 Borg 下运行的任务都包含一个内置的 HTTP 服务器，该服务器发布有关任务运行状况和数千个性能指标（如 RPC 延迟）的信息。Borg 会监控运行状况检查 URL 并重新启动不及时响应或返回 HTTP 错误代码的任务。其他数据由监控工具跟踪，用于仪表板和服务级别目标（SLO）的告警。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将监控应用健康的责任转移到应用程序内部，这使得应用程序更容易管理和自动化。应用程序应该知道自己是否在正常运行以及自己的依赖（例如，访问数据库）。开发人员需要与产品经理合作来定义应用服务的业务功能并相应地编写测试。&lt;/p&gt;
&lt;p&gt;提供健康检查的应用程序示例例如 Zookeeper 的 ruok 命令和 etcd 的 HTTP 健康端点。&lt;/p&gt;
&lt;p&gt;应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作。&lt;/p&gt;
&lt;p&gt;平台需要知道应用程序何时可以接收流量，这就是一个很好的例子。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。此额外状态将防止应用程序过早终止，因为如果运行状况检查故障，平台可能会认为应用程序不健康，并且会反复重启它。&lt;/p&gt;
&lt;p&gt;应用程序健康只是自动化应用程序生命周期的一部分。除了知道应用程序是否健康之外，您还需要知道应用程序正在进行哪些工作。这些信息来自遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;遥测数据&#34;&gt;遥测数据&lt;/h3&gt;
&lt;p&gt;我们使用遥测数据（telemetry）来进行决策。遥测数据可能与健康报告重叠，但它们用途不同。健康报告汇报应用程序的生命周期状态，而遥测数据汇报应用程序的业务目标。&lt;/p&gt;
&lt;p&gt;我们测量的指标有服务等级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。如果您需要更多关于这些术语的信息以及与应用程序、业务需求的关系，我们推荐您阅读来自 Site Reliability Engineering（O&amp;rsquo;Reilly）的第 4 章。&lt;/p&gt;
&lt;p&gt;遥测和度量标准用于解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序每分钟收到多少请求？&lt;/li&gt;
&lt;li&gt;有没有错误？&lt;/li&gt;
&lt;li&gt;应用程序延迟怎么样？&lt;/li&gt;
&lt;li&gt;下单需要多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常会将数据抽取或推送到时间序列数据库（例如 Prometheus 或 InfluxDB）进行聚合。遥测数据需要被收集数据的系统格式化。&lt;/p&gt;
&lt;p&gt;至少需要实施度量标准的 RED（Rate、Error、Duration）方法，该方法收集应用程序的到达率、错误和执行时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到达率（Rate）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收到了多少个请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误（Error）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序有多少错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续时间（Duration）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多久才能收到回复&lt;/p&gt;
&lt;p&gt;遥测数据应该用于告警而不是健康监测。在能够动态自我修复的环境中，我们不关注应用程序单个实例的生命周期，更关注的是应用程序的整体 SLO。健康报告对于自动应用程序管理仍然很重要，但不应该用于站点工程师。&lt;/p&gt;
&lt;p&gt;不管应用程序是 1 个实例还是 50 个实例不健康，只要满足应用程序的业务需求，我们就可能不会收到警报。Metric 会告诉您是否满足 SLO，应用程序的使用方式以应用程序是否是“正常”。告警有助于您将系统恢复到已知的良好状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它移动，我们就追踪。如果没有移动我们就也会画一些图形，以防它突然开始运动。&lt;/p&gt;
&lt;p&gt;——Ian Malpass，Measure Anything, Measure Everything&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;警报（Alert）不应该与日志记录混淆。记录（Logging）用于调试、开发和观察。记录暴露了应用程序的内部功能。Metric 有时可以根据日志（例如错误率）计算，但需要额外的聚合服务（例如 ElasticSearch）和处理。&lt;/p&gt;
&lt;h3 id=&#34;弹性&#34;&gt;弹性&lt;/h3&gt;
&lt;p&gt;有了遥测和监控数据后，还要确保应用程序有故障自适应能力。弹性是基础架构的责任，但云原生应用程序也需要承担部分工作。&lt;/p&gt;
&lt;p&gt;基础架构设计之初就是要抵御故障（failure）。硬件通常需要有多个硬盘驱动器、电源以及全天候监控和可更换的部件以保持应用程序可用。云原生应用程序应当正视故障而不是避免故障。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在任何平台上，尤其是云上，可靠性都是其最重要的特性。&lt;/p&gt;
&lt;p&gt;——David Rensin，e ARCHITECT Show：来自 Google 的关于云计算的速成课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;光是讲如何设计弹性的应用程序可能就可以写一本书了。我们将在云原生应用程序中考虑弹性的两个主要方面：面向故障设计和优雅降级。&lt;/p&gt;
&lt;h3 id=&#34;面向故障设计&#34;&gt;面向故障设计&lt;/h3&gt;
&lt;p&gt;唯一永远不会故障的系统是那些与您的生命安全息息相关的系统（例如心脏植入物和刹车系统）。如果想要让服务永远运行，您需要花费太多时间设计服务来抵御故障，那样就没有足够的时间增加业务价值。SLO 确定服务需要运行多长时间。您花费在工程设计上超出 SLO 的正常运行时间的任何资源都将被浪费掉。&lt;/p&gt;
&lt;p&gt;每项服务您可以测量两个值，平均无故障时间（MTBF，Mean Time Between Failure）和平均恢复时间（MTTR，Mean Time To Recovery）。通过监控和 metric 可以知道是否达到 SLO，但运行应用程序的平台是保持高 MTBF 和低 MTTR 的关键。&lt;/p&gt;
&lt;p&gt;在任何复杂的系统中，都会有故障。您可以管理硬件中的某些故障（例如，RAID 和冗余电源），以及某些基础架构中的故障（例如负载平衡器）。但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的故障。&lt;/p&gt;
&lt;p&gt;设计一个以故障期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。&lt;/p&gt;
&lt;p&gt;没人可以预料应用程序所有可能的故障。假设所有东西都可能会故障，这是一种云原生应用程序的模式。&lt;/p&gt;
&lt;p&gt;应用程序的最佳状态是健康状态。第二好的状态是故障状态。其他一切都是非二元的，难以监控和排除故障。Honeycomb 首席执行官 Charity Majors 在她的一篇题为“Ops: It’s Everyone’s Job Now”的文章中指出：“分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受故障，面向设计设计，保护和缩小关键路径。“&lt;/p&gt;
&lt;p&gt;无论发生什么故障，云原生应用程序都应该是可适应的。它们预期故障，所以他们在检测到时进行调整。&lt;/p&gt;
&lt;p&gt;有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）。该平台应自主处理未集成到应用程序中的故障域。&lt;/p&gt;
&lt;h3 id=&#34;优雅降级&#34;&gt;优雅降级&lt;/h3&gt;
&lt;p&gt;云原生应用程序需要有一种方法来处理过载，无论是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级。 “站点可靠性工程”一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下“不如正常响应准确或含有较少数据的响应，但计算更容易”。&lt;/p&gt;
&lt;p&gt;减少应用程序负载的某些方面由基础架构处理。智能负载均衡和动态扩展有助于减轻应用程序的负载，但有的时候，应用程序可以承受的负载比它可以处理的负载更多。云原生应用程序应知道这种必然性并作出相应的反应。&lt;/p&gt;
&lt;p&gt;优雅降级的重点是允许应用程序始终返回请求的响应。如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的。如果一个服务依赖于一个或多个其他服务，即使依赖的服务无应答，该应用程序也应该可以应答。还有种解决方案是，当服务降级时，返回部分应答或使用本地缓存中的旧信息应答。&lt;/p&gt;
&lt;p&gt;尽管优雅的降级和故障处理都应该在应用程序中实现，但是平台的多个层面也应该提供帮助。如果采用微服务，则网络基础架构将是在提供应用弹性方面发挥积极作用的关键组件。有关构建弹性网络层的更多信息，请参阅附录 A。&lt;/p&gt;
&lt;h3 id=&#34;可用性数学&#34;&gt;可用性数学&lt;/h3&gt;
&lt;p&gt;云原生应用程序需要在基础架构之上建立一个平台，以使基础架构更具弹性。如果您希望将现有应用程序“提升并转移”到云中，则应检查云提供商的服务级别协议（SLA），并考虑在使用多个服务时会发生什么情况。&lt;/p&gt;
&lt;p&gt;如果在云上运行应用程序，我们来看下可用性会是怎样。&lt;/p&gt;
&lt;p&gt;计算基础架构的典型可用性是每月 99.95％的正常运行时间。这意味着您的实例每天可能会停机 43.2 秒，这仍在您的云服务提供商的 SLA 中。&lt;/p&gt;
&lt;p&gt;另外，实例的本地存储（例如 EBS 卷）也具有 99.95％的正常可用时间。如果幸运的话，他们都会同时出现故障，但最糟糕的情况是他们可能会在不同的时间停机，让您的实例只有 99.9％的可用性。&lt;/p&gt;
&lt;p&gt;您的应用程序可能还需要一个数据库，而不是自己安装数据库，可能的停机时间为 1 分 26 秒（99.9％可用性）的情况下，选择可靠性为 99.95％的更可靠的托管数据库。这使您的应用程序的可靠性达到 99.85％，或者每天可能发生 2 分钟 9 秒的停机时间。&lt;/p&gt;
&lt;p&gt;将可用性乘到一起可以快速了解为什么应以不同方式处理云。如果云提供商不符合其 SLA，会退还您账单中一定比例的费用。&lt;/p&gt;
&lt;p&gt;虽然您不必为停机支付费用，但您的业务必须能够容忍云计算的信用保证。如果云平台的可用性保证无法满足您的应用程序的可用性需求，那么您应该考虑是否该在云上运行这个应用程序。&lt;/p&gt;
&lt;h3 id=&#34;声明式非反应式&#34;&gt;声明式，非反应式&lt;/h3&gt;
&lt;p&gt;由于云原生应用程序设计为在云环境中运行，因此它们与基础架构和支持应用程序的交互方式与传统应用程序不同。在云原生应用程序中，与任何事物进行通信都是通过网络进行的。很多时候，网络通信都是通过 RESTful HTTP 调用完成的，也可以通过其他接口，如远程过程调用（RPC）来实现。&lt;/p&gt;
&lt;p&gt;传统的应用程序会通过消息队列，写在共享存储上的文件或触发 shell 命令的本地脚本来自动执行任务。通信方法对发生的事件作出反应（例如，如果用户单击提交，运行提交脚本）并且通常需要存在于同一物理或虚拟服务器上的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Serverless&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serverless 平台是云原生化的，面向事件响应而设计。通过 HTTP API 进行通信使得它们在云中工作得很好，是单用途函数，在它们的函数调用中声明。该平台还可以通过在云中进行扩展和访问来提供帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传统应用程序中的反应性通信常常是通过增强弹性。如果应用程序在磁盘或消息队列中写入文件，然后应用程序崩溃，则消息或文件的结果仍可能完成。&lt;/p&gt;
&lt;p&gt;这并不是说不应该使用像消息队列这样的技术，而是说不应该将它们作为动态和不断发生故障的系统中的唯一弹性层。从根本上讲，应用程序之间的通信应该在云原生环境中改变 —— 不仅因为还有其他方法来构建通信弹性（请参阅附录 A），还因为在云中复制传统通信方法往往需要更多工作。&lt;/p&gt;
&lt;p&gt;当应用程序可以信任通信的弹性时，应该停止使用反应式并开始使用声明式。声明式通信相信网络将传递消息，也相信应用程序将返回成功或错误。这并不是说应用程序监视变化并不重要。Kubernetes 的控制器正是这样做到 API Server。但是，一旦发现变更，它们就会声明一个新的状态，并相信 API Server 和 kubelet 会做必要的事情。&lt;/p&gt;
&lt;p&gt;声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将功能实现从应用程序转移到远程 API 或服务端点，从而让实现某种状态到达期望状态。这有助于简化应用程序，并使它们彼此的行为更具可预测性。&lt;/p&gt;
&lt;h3 id=&#34;云原生应用程序如何影响基础架构&#34;&gt;云原生应用程序如何影响基础架构？&lt;/h3&gt;
&lt;p&gt;希望您已经了解云原生应用程序与传统应用程序不同。云原生应用程序不能直接在 PaaS 上运行或与服务器的操作系统紧密耦合。它们期望在一个拥有大多数自治系统的动态环境中运行。&lt;/p&gt;
&lt;p&gt;云原生基础架构在提供自主应用管理的 IaaS 之上创建了一个平台。该平台建立在动态创建的基础架构之上，以抽象出单个服务器并促进动态资源分配调度。&lt;/p&gt;
&lt;p&gt;自动化与自治不一样。自动化允许人类对控制系统采取更多行动。&lt;/p&gt;
&lt;p&gt;云原生是关于不需要人类做出决定的自治系统。它仍然使用自动化，但只有在决定了所需的操作之后。只有在系统不能自动确定正确的事情时才应该通知人。&lt;/p&gt;
&lt;p&gt;具有这些特征的应用程序需要一个能够实际监控，收集度量标准并在发生故障时做出反应的平台。云原生应用程序不依赖于人为设置 ping 检查或创建 Syslog 规则。它们需要从选择基本操作系统或软件包管理器的过程中提取自助服务资源，并依靠服务发现和强大的网络通信来提供丰富的功能体验。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;运行云原生应用程序所需的基础架构与传统应用程序不同。基础架构的许多责任已经转移到应用程序中。&lt;/p&gt;
&lt;p&gt;云原生应用程序通过分解为更小的服务来简化其代码复杂性。这些服务提供直接构建到应用程序中的监控、指标和弹性。需要新的工具来自动管理服务数量的激增和应用的生命周期。&lt;/p&gt;
&lt;p&gt;现在基础架构负责整体资源管理、动态协调、服务发现等等。需要提供一个平台，使服务不依赖于单个组件，而是依赖于 API 和自治系统。第 2 章将更详细地讨论云原生基础架构功能。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>采纳云原生基础架构的时机</title>
      <link>https://jimmysong.io/book/cloud-native-infra/when-to-adopt-cloud-native/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/when-to-adopt-cloud-native/</guid>
      <description>
        
        
        &lt;p&gt;云原生基础架构并不适合所有人。任何架构设计都经过了一系列的权衡。您只有熟悉自己的需求才能决定哪些权衡是有益的，哪些是有害的。&lt;/p&gt;
&lt;p&gt;不要在不了解架构的影响和限制的情况下采用工具或设计。我们相信云原生基础架构有很多好处，但需要意识到不应该盲目的采用。我们不愿意引导大家通过错误的方式来满足需求。&lt;/p&gt;
&lt;p&gt;怎么知道是否应该使用云原生基础架构设计？确定云原生基础架构是否适合您，下面是一些需要了解的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;您有云原生应用程序吗？(有关可从云原生基础架构中受益的应用程序功能，请参阅第 1 章)&lt;/li&gt;
&lt;li&gt;您的工程团队是否愿意且能够编写出体现其作业功能的生产质量代码？&lt;/li&gt;
&lt;li&gt;您在本地或公有云是否拥有基于 API 驱动的基础架构（IaaS）？&lt;/li&gt;
&lt;li&gt;您的业务是否需要更快的开发迭代或非线性人员 / 系统缩放比例？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您对所有这些问题都回答“yes”，那么您可能会从本书其余部分介绍的基础架构中受益。如果您对这些问题中的某个问题回答是“no”，这并不意味着您无法从某些云原生实践中受益，但是您可能需要做更多工作，然后才能从此类基础架构中充分受益。&lt;/p&gt;
&lt;p&gt;在业务准备好之前武断地采用云原生基础架构效果会很糟糕，因为这会强制使用一个不正确的解决方案。在没有充分调查的情况下可能会失败，您可以能会把云原生架构看做是有缺陷或毫无用处的。鉴于之前尝试的云原生方案的失败，今后该方案也可能很难再次采用，无论它是否是正确的解决方案。&lt;/p&gt;
&lt;p&gt;在您准备将组织和技术转变为云原生时，我们将讨论一些需要关注的领域。要考虑的事情有很多，关键领域是您的应用程序、组织中的人员、基础架构系统和您的业务。&lt;/p&gt;
&lt;h2 id=&#34;应用程序&#34;&gt;应用程序&lt;/h2&gt;
&lt;p&gt;应用程序是准备工作中最简单的部分。设计模式已经很完善，自公共云出现以来，工具性能得到了显着提升。如果您无法构建云原生应用程序并通过自动部署管道来验证它们的话，则不应继续采用云原生基础架构。&lt;/p&gt;
&lt;p&gt;构建云原生应用程序并不一定需要微服务。这并不意味着您必须用最流行的语言开发所有软件。您必须编写可以由软件管理的软件。&lt;/p&gt;
&lt;p&gt;在开发过程中，人只会与云原生应用程序进行交互。其他一切都应该由基础架构或其他应用程序来管理。&lt;/p&gt;
&lt;p&gt;应用程序应该可以动态地扩展出多个实例。扩展通常意味着负载均衡器后运行着同一个应用程序有多个副本。假定应用程序将状态存储在存储服务（即数据库）中，并且不需要运行实例之间的复杂协调。&lt;/p&gt;
&lt;p&gt;动态应用程序管理意味着不需要人参与这项工作。应用程序度量触发了基础架构操作扩展应用程序。这是大多数云环境的基本特征。运行动态伸缩的资源组并不意味着您拥有云原生基础架构；但如果您的应用程序可以自动伸缩，它可能表明您的应用程序已准备就绪了。&lt;/p&gt;
&lt;p&gt;为了使应用程序受益，编写应用程序和配置基础架构的人员需要支持这种工作方法。如果没有人愿意放弃对软件的控制，您将永远无法实现它的好处。&lt;/p&gt;
&lt;h2 id=&#34;人&#34;&gt;人&lt;/h2&gt;
&lt;p&gt;人是云原生基础架构中最难的部分。&lt;/p&gt;
&lt;p&gt;如果您想建立一个能够用软件取代人们职能和决策的架构，那么您需要确保人们了解您有最大的诉求。不仅需要人们接受变化，还需要他们自己主动寻求改变。&lt;/p&gt;
&lt;p&gt;开发应用程序很困难，运维基础架构很难。应用程序开发人员经常相信他们可以用工具和自动化取代基础架构运维，运维人员希望应用程序开发人员能够编写更可靠的代码，并提供自动调试和恢复。这些紧张关系是 DevOps 的基础，DevOps 有许多其他书籍，包括由 Jennifer Davis 和 Katherine Daniels 撰写的 &lt;em&gt;Effective DevOps&lt;/em&gt;（O’Reilly，2016）。&lt;/p&gt;
&lt;p&gt;人们不会扩大规模，也不擅长重复无聊的工作。&lt;/p&gt;
&lt;p&gt;应用程序和系统工程师的目标应该是消除无聊和重复的任务，以便他们可以专注于更有趣的问题。他们需要具备开发可以包含业务逻辑和决策的软件的技能。需要有足够的工程师来编写所需的软件，更重要的是维护它。&lt;/p&gt;
&lt;p&gt;最关键的方面是他们需要一起工作。如果没有其他方面的支持，工程的一方无法迁移到运行和管理应用程序的新方式。团队组织和沟通结构非常重要。&lt;/p&gt;
&lt;p&gt;我们会尽快将团队准备好，但首先，我们必须确定基础架构迁移到云原生的时机。&lt;/p&gt;
&lt;h2 id=&#34;系统&#34;&gt;系统&lt;/h2&gt;
&lt;p&gt;云原生应用程序需要系统抽象。应用程序不应该关注单个硬编码主机名。如果您的应用程序无法在个别主机上运行，那就说明您的系统尚未准备好使用于云原生基础架构。&lt;/p&gt;
&lt;p&gt;使用单个服务器（虚拟机或物理机）运行操作系统，并将其转换为访问资源的方法，这就是我们所说的“抽象”。单个系统不应该是应用程序部署的目标。资源（CPU、内存和磁盘）应该集中在所有可用的机器上，然后由平台根据应用程序的请求进行分配。&lt;/p&gt;
&lt;p&gt;在云原生基础架构中，您必须隐藏底层系统以提高可靠性。云计算基础架构（如应用程序）会预期基础组件故障，并且可以优雅地处理此类故障。这是必要的，因为基础架构工程师不再控制堆栈中的所有内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 云原生基础架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 是一个框架，它使云的方式管理应用程序变得更加容易。但是，您也可以用一种非云原生的方式使用 Kubernetes。&lt;/p&gt;
&lt;p&gt;Kubernetes 公开了基于其核心功能的扩展，但这不是您的基础架构的最终目标。其他项目 (例如，OpenShift) 建立在它之上，将 Kubernetes 从开发人员和应用程序中抽象出来。&lt;/p&gt;
&lt;p&gt;应用程序应该运行在平台上。云原生基础架构并且鼓励这样运行基础架构的方式。&lt;/p&gt;
&lt;p&gt;如果您的应用程序是动态的，但基础架构是静态的，那么您很快就会陷入单靠 Kubernetes 无法解决的僵局。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当这不再是一个挑战时，基础架构已经准备好成为云原生的了。一旦基础架构变得简单，自动化、自助服务和动态，就有可能被忽略。当系统可以被忽略，并且技术变得单调时，是时候向上移动堆栈了。&lt;/p&gt;
&lt;p&gt;如果您的系统管理依赖于硬件定制或在“混合云”中运行，则您的系统可能还没有准备好。可能需要管理一个数据中心，并且私有化。您需要保持警惕，将建立数据中心的责任与管理基础架构的责任分开。&lt;/p&gt;
&lt;p&gt;谷歌、Facebook、亚马逊和微软都发现通过开放的计算项目从头开始创建硬件是有好处的。之所以创建自己的硬件是因为有性能和成本的限制。因为硬件设计和基础架构构建者之间存在明确的责任分离，这些公司能够在创建定制硬件的同时运行云原生基础架构。它们不会受到“内部部署”的阻碍。相反，他们可以共同优化其硬件和软件，以获得更高的效率和性能。&lt;/p&gt;
&lt;p&gt;管理自己的数据中心需要大量时间和金钱的投入。创建私有云也是如此。两者都需要建立和管理数据中心团队、创建和维护 API 的团队以及在 IaaS API 之上创建抽象的团队。&lt;/p&gt;
&lt;p&gt;所有这些都可以完成，决定管理整个堆栈是否有价值取决于您的业务。&lt;/p&gt;
&lt;p&gt;现在，我们看看业务领域需要做哪些准备才能迁移到云原生。&lt;/p&gt;
&lt;h2 id=&#34;业务&#34;&gt;业务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果系统的架构和组织的架构不一致，则组织的架构会胜出。&lt;/p&gt;
&lt;p&gt;—— 鲁斯马兰，“康威定律”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;企业变革速度非常缓慢。当通过扩展人员来管理扩展系统不再有效时，以及产品开发需要更多灵活性时，他们可能已经准备好采用云原生实践了。&lt;/p&gt;
&lt;p&gt;人无法无限扩展。对于增加管理更多服务器或开发更多代码的每个人来说，支持他们的人力基础架构（例如办公室空间）都有一定的压力。因为需要更多的沟通和协调，还会有更多额外的开销。&lt;/p&gt;
&lt;p&gt;正如我们在第 1 章中讨论的那样，通过使用公有云，您可以通过租用服务器来减少一些流程和人员开销。即使使用公有云，您仍然会需要管理基础架构详细信息的人员（例如服务器，服务和用户帐户）。&lt;/p&gt;
&lt;p&gt;当沟通结构反映业务需要创建的基础架构和应用程序时，业务已准备好采用云原生实践。这包括反映像微服务这样架构的沟通结构。他们可能是小型的独立团队，无需通过层层管理与其他团队交流或合作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DevOps 和 Cloud Native&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DevOps 可以补充团队合作的方式，并影响使用的工具类型。公司采用后有很多好处，包括快速原型化和提高部署速度。它也非常注重组织的文化。&lt;/p&gt;
&lt;p&gt;云原生需要高性能组织，但更注重于设计、架构和健康度，而不是团队工作流程和文化。如果您原以为必须解决应用程序开发人员、基础架构运维以及技术部门中任何人员之间的交互问题，才可以成功地实现云原生模式的话，那么您可能会对此感到意外。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;迫使业务变化的另一个限制因素是应用程序对敏捷性的要求更高了。企业不仅需要快速部署，还需要彻底改变部署的内容。&lt;/p&gt;
&lt;p&gt;部署的原始数量无关紧要。重要的是尽可能快地提供客户价值。相信部署的软件将第一次，甚至是第 100 次，满足所有客户的需求，这是一个谬论。&lt;/p&gt;
&lt;p&gt;当业务意识到需要频繁迭代和更改时，它可能已经准备好采用云原生应用程序了。只要在人员效率和流程方面遇到限制，且可以随时更改它，就可以准备迁移到云原生基础架构了。&lt;/p&gt;
&lt;p&gt;所有那些表明何时采用云原生的因素都不能说明全部情况。任何设计都需要权衡折衷。因此，在某些情况下，云原生基础架构不是正确的选择。&lt;/p&gt;
&lt;h2 id=&#34;什么情况下不需要云原生基础架构&#34;&gt;什么情况下不需要云原生基础架构&lt;/h2&gt;
&lt;p&gt;只有了解了系统有哪些限制，再清楚系统可以带来的好处才有用。也就是说，是否采用一个系统的决定性因素是它的限制而使用它可以带来的利益。&lt;/p&gt;
&lt;p&gt;记住需求随时间变化也很重要。现在的关键功能可能在未来并不是。同样，如果下面的情况目前并不理想，那么您可以不采用云原生。&lt;/p&gt;
&lt;h3 id=&#34;技术限制&#34;&gt;技术限制&lt;/h3&gt;
&lt;p&gt;就像应用程序一样，在基础架构中，最简单的是技术性限制。如果您知道什么时候应该采用有技术优势的云原生基础架构，那么您可以思考下何时不应该采用云原生基础架构。&lt;/p&gt;
&lt;p&gt;第一个限制是没有云原生应用程序。正如在第一章中讨论的那样，如果您的应用程序需要人工交互，无论是调度、重新启动还是搜索日志，云原生基础架构都没有多大好处。&lt;/p&gt;
&lt;p&gt;即使您有一个可以动态调度的应用程序，也不会使其成为云原生。如果您的应用程序在 Kubernetes 上运行，但仍需要人工设置监控、日志收集和负载均衡，则它不是云原生。只是将应用程序部署在 Kubernetes 运行并不意味着云原生。&lt;/p&gt;
&lt;p&gt;如果您有一个编排调度器，重要的是看看它是如何运行的。您是否需要下订单、创建工单或发送电子邮件以获取服务器？&lt;/p&gt;
&lt;p&gt;这些是您没有自助服务基础架构的指标，这是云计算的一项要求。&lt;/p&gt;
&lt;p&gt;在云中，您只需提供帐单信息并调用 API。即使您在内部运行服务器，您也应该有一个可以构建 IaaS 的团队，然后将云原生基础架构分层布局。&lt;/p&gt;
&lt;p&gt;如果您要在自己的数据中心中构建云环境，图 2-1 显示了您的基础架构组件适合的示例。所有原始组件（例如，计算、存储、网络）都应该可以从自助式 IaaS API 中获得。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/when-to-adopt-cloud-native/f-2-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/when-to-adopt-cloud-native/f-2-1.jpg&#34; data-width=&#34;1286&#34; data-height=&#34;430&#34; alt=&#34;image&#34; data-caption=&#34;图 2-1. 云原生基础架构的示例图层&#34;&gt;
    
  
  &lt;figcaption&gt;图 2-1. 云原生基础架构的示例图层&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在公有云中，您拥有 IaaS 和托管服务，但这并不意味着您的业务已准备好使用公有云。&lt;/p&gt;
&lt;p&gt;当您构建运行应用程序的平台时，了解您正在进行的操作非常重要。最初的开发只是构建和维护平台所需花费的一小部分，特别是对业务至关重要的平台。&lt;/p&gt;
&lt;p&gt;维护通常会消耗大约 40％到 80％（平均 60％）的软件成本。因此，这可能是最重要的生命周期阶段，发现业务需求和建立开发所需的技能可能对于一个小团队来说太过分了。一旦您掌握了开发所需平台的技能，您仍然需要投入时间来改进和维护系统。这需要比初始开发更长的时间。&lt;/p&gt;
&lt;p&gt;公有云提供商的产品为企业提供绝佳的运行环境。如果您不能或者不愿意让您的平台成为业务，那么您不应该自己创建一个平台。&lt;/p&gt;
&lt;p&gt;请记住，您不必自己构建一切。您可以使用可以组装到所需平台的服务或产品。&lt;/p&gt;
&lt;p&gt;可靠性仍然是基础架构的关键特性。如果您还没有准备好放弃对底层基础架构堆栈的控制，并且仍然通过接受故障来制造可靠的产品，那么云原生基础架构并不是正确的选择。&lt;/p&gt;
&lt;p&gt;非技术限制同样重要，可能超出您的控制范围。&lt;/p&gt;
&lt;h3 id=&#34;业务限制&#34;&gt;业务限制&lt;/h3&gt;
&lt;p&gt;如果现有流程不支持更改基础架构，则需要首先克服该障碍。幸运的是，您不必一个人做。&lt;/p&gt;
&lt;p&gt;本书希望有助于向需要说服力的人清楚地解释云原生的好处和流程。还有许多案例研究和公司分享他们采用这些做法的经验。本书附录 C 中将提供一个案例研究，您还可以找到相关示例并与同行和管理层分享。&lt;/p&gt;
&lt;p&gt;如果企业还没有实验的途径和支持尝试新事物的文化（以及伴随失败而来的后果），那么改变流程可能是不可能的。在这种情况下，您的需要等待达到必须改变的临界点，或者说服管理层认为改变是必要的。&lt;/p&gt;
&lt;p&gt;以一个外部的视角准确辨别一个企业是否准备好采用云原生是不可能的。不过，下面这些流程可以明确指示一个公司未准备接纳云原生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要人工干预的资源请求&lt;/li&gt;
&lt;li&gt;定期安排需要人工操作的维护窗口&lt;/li&gt;
&lt;li&gt;手动库存跟踪和资源分配&lt;/li&gt;
&lt;li&gt;电子表格清单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果调度、部署、升级或监控服务，这些流程除了负责服务的团队以外还有其他人员参与的话，则可能需要在迁移到云原生基础架构之前或迁移期间解决这些流程。&lt;/p&gt;
&lt;p&gt;有时也有业务无法控制的过程，例如行业法规。可悲的是，这些变化甚至比内部流程更难和更慢。&lt;/p&gt;
&lt;p&gt;如果行业法规限制了发展的速度或敏捷性，我们就没有任何建议，只能尽您所能。如果法规不允许业务在公有云中运行，请尽量使用技术来运行内部部署。管理层将需要为任何管理机构制定的法规制定一个案例。&lt;/p&gt;
&lt;p&gt;云原生基础架构还有另一个非技术障碍。在一些公司中，有一种不使用第三方服务的文化&lt;/p&gt;
&lt;p&gt;如果您的公司不愿意或无法通过使用第三方托管服务的流程，则可能不适合采用云原生基础架构。我们将在附录 B 中更详细地讨论何时使用托管服务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要成功，单靠计划是不够的。还需要即兴发挥。&lt;/p&gt;
&lt;p&gt;——Isaac Asimov&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本章中，我们讨论了何时采用云原生基础架构的注意事项。有许多需要记住的领域，每种情况都是独一无二的。希望这些指导原则可以帮助您发现变革的适当时机。&lt;/p&gt;
&lt;p&gt;如果您的公司已经采用了一些云原生实践，这些问题可以帮助确定可以采用这种架构的其他领域。当您在权衡云原生是否为正确的解决方案，以及如何开始时，了解这一点非常重要。&lt;/p&gt;
&lt;p&gt;如果您尚未将云原生实践应用于工作，则没有捷径。企业和员工需要共同决定云原生是否是正确的解决方案，并共同取得进展。没有人独自成功。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生部署的演变</title>
      <link>https://jimmysong.io/book/cloud-native-infra/evolution-of-cloud-native-developments/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/evolution-of-cloud-native-developments/</guid>
      <description>
        
        
        &lt;p&gt;我们在前一章中讨论了在采用云原生基础架构的前提。在部署之前，需要有由 API 驱动的基础架构（IaaS）供给。&lt;/p&gt;
&lt;p&gt;在本章中，我们将探讨云原生基础架构拓扑的概念，并在云中实现它们。我们将学习可以帮助运维人员控制其基础架构的常用工具和模式。&lt;/p&gt;
&lt;p&gt;部署基础架构的第一步应该是能够将其表述出来。传统上，可以在白板上处理，或者如果幸运的话，可以在公司 wiki 上存储的文档中处理。今天，一切都变得更加程序化，基础架构表述通常以便于应用程序解释的方式记录。无论如何表述，全面的表述基础架构的需求是不变的。&lt;/p&gt;
&lt;p&gt;正如人们所期望的那样，精巧的云基础架构可以从简单的设计到非常复杂的设计。无论复杂性如何，必须对基础架构的表现给予高度的重视，以确保设计的可重复性。能够清晰地传递想法更为重要。因此，明确、准确和易于理解的基础架构级资源表述势在必行。&lt;/p&gt;
&lt;p&gt;我们也将从制作精良的表述中获得很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着时间的推移，基础架构设计可以共享和版本化。&lt;/li&gt;
&lt;li&gt;基础架构设计可以被 fork 和修改以适应特殊情况。&lt;/li&gt;
&lt;li&gt;表述隐含的是文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着本章向前推进，我们将看到基础架构表述是如何成为基础架构部署的第一步。我们将以不同的方式探索表述基础架构的能力和潜在缺陷。&lt;/p&gt;
&lt;h2 id=&#34;表述基础架构&#34;&gt;表述基础架构&lt;/h2&gt;
&lt;p&gt;首先，我们需要理解表述基础架构的两个角色：作者和观众。&lt;/p&gt;
&lt;p&gt;作者将定义基础架构，通常是人类运维人员或管理员。观众将负责解释基础架构表述。有时候，这是一个运维人员执行手动步骤，但希望它是一个可以自动分析和创建基础架构的部署工具。作者在准确表达基础架构方面表现得越好，我们就可以在听众解释表达的能力中获得更多的信心。&lt;/p&gt;
&lt;p&gt;创作基础架构表述时主要关心的是要让观众了解它。如果目标受众是人，则表述可能以技术图或抽象代码的形式出现。如果目标受众是一个程序，那么表示可能需要更详细的信息和具体的实施步骤。&lt;/p&gt;
&lt;p&gt;尽管有观众，作者应该让观众更容易使用。随着复杂性的增加以及人与程序共同使用基础架构，这将变得非常困难。&lt;/p&gt;
&lt;p&gt;表示法需要易于理解，以便能够对其进行准确分析。易于阅读但分析不准确的表述否定了整个工作。观众应该总是努力去解释他们的表述，而不是做出假设。&lt;/p&gt;
&lt;p&gt;为了使表达成功，解释需要可预测。如果作者忽略了一个重要的细节，那么最好的观众就会很快失败。具有可预测性将在应用变更时减少错误的发生，并有助于在作者和受众之间建立信任。&lt;/p&gt;
&lt;h3 id=&#34;基础架构即图&#34;&gt;基础架构即图&lt;/h3&gt;
&lt;p&gt;我们用到了白板，开始绘制一张基础架构图。通常情况下，这个过程始于在角落上代表互联网的云形状，以及一些指向方框的箭头。每个框代表系统中的一个组件，箭头表示它们之间的交互。图 3-1 是基础架构图的一个例子。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/evolution-of-cloud-native-developments/f-3-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/evolution-of-cloud-native-developments/f-3-1.jpg&#34; data-width=&#34;1288&#34; data-height=&#34;1010&#34; alt=&#34;image&#34; data-caption=&#34;图 3-1. 简单的基础架构图&#34;&gt;
    
  
  &lt;figcaption&gt;图 3-1. 简单的基础架构图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是一个非常有效的头脑风暴和将想法传达给其他人的方法。它允许对复杂的基础架构设计进行快速而强大的表示。&lt;/p&gt;
&lt;p&gt;图片适用于人类，大量人群和 CEO。这些图也适用，因为它们使用常用语来表示关系。例如，此框可能会将数据发送到那个框，但不会将数据发送到其他框。&lt;/p&gt;
&lt;p&gt;不幸的是，图表对于计算机来说几乎是不可能理解的。在计算机视觉迎头赶上之前，基础架构图仍然是一个代表，可以用眼球来解释，而不是代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从图中进行部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在例 3-1 中，我们看一个来自 bash_history 文件的熟悉的代码片段。它代表一个基础架构运营商，作为描述基础服务器与网络、存储和转租服务运行的图表的受众。&lt;/p&gt;
&lt;p&gt;运维人员已经手动部署了一台新的虚拟机，并通过 SSH 连接到了该机器并开始配置它。在这种情况下，人类充当图解释者，然后在基础架构环境中采取行动。&lt;/p&gt;
&lt;p&gt;大多数基础架构工程师在他们的职业生涯中都这样做了，而且这些步骤对于某些系统管理员来说应该是非常熟悉的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-1. bash_history&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo emacs /etc/networking/interfaces
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ifdown eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ifup eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo fdisk -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo emacs /etc/fstab
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo mount -a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; kubelet
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即脚本&#34;&gt;基础架构即脚本&lt;/h3&gt;
&lt;p&gt;如果您是一个系统管理员，您工作的一部分是在复杂系统中进行更改；确保这些更改是正确的也是您的责任。需要将这些变化传播到广阔的系统中是非常现实的。不幸的是，人为错误也是如此。管理员为这项工作编写便利脚本并不奇怪。&lt;/p&gt;
&lt;p&gt;脚本可以帮助减少重复任务中人为错误的数量，但自动化是一把双刃剑。这并不意味着准确性或成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 SRE，自动化可以让你力量倍增，单它不是万能药。当然，加倍的力量并不会自然地改变应用力的准确性：不经意地进行自动化可能会产生很多的问题。&lt;/p&gt;
&lt;p&gt;——Niall Murphy、John Looney 和 Kacirek，自动化在谷歌的演变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写脚本是自动执行步骤以产生所需结果的好方法。该脚本可以执行各种任务，例如安装 HTTP 服务器，配置并运行它。但是，脚本中的步骤在调用时很少考虑到它们的结果或系统的状态。&lt;/p&gt;
&lt;p&gt;在这种情况下，脚本是编码数据，表示创建所需基础架构应该发生的情况。另一位运维人员或管理员可以评估您的脚本，并希望了解脚本正在做什么。换句话说，他们会解释你的基础架构表示。了解所需的基础架构需要了解步骤如何影响系统。&lt;/p&gt;
&lt;p&gt;脚本的运行时会按照它们定义的顺序执行这些步骤，但运行时不知道它正在生成什么。脚本是代码，脚本的执行结果希望是所需的基础架构。&lt;/p&gt;
&lt;p&gt;这适用于普遍的场景，但这种方法存在一些缺陷。最明显的缺陷是运行相同的脚本可能获得两个不同的结果。&lt;/p&gt;
&lt;p&gt;如果脚本第一次运行的环境与第二次运行的环境大不相同？从科学的角度来说，这将类似于程序中的缺陷，并会使实验数据无效。&lt;/p&gt;
&lt;p&gt;使用脚本来表示基础架构的另一个缺陷是缺少声明状态。脚本的运行时不理解结束状态，因为它只提供了执行步骤。人类需要从步骤中解释理想的结果，以了解如何进行改变。&lt;/p&gt;
&lt;p&gt;我们看到过很多人类难以理解的代码。随着配置脚本复杂性的增长，我们解释脚本的能力就会减弱。此外，您的基础架构页需要随时间而变化，脚本将不可避免地需要更改。&lt;/p&gt;
&lt;p&gt;如果不将步骤抽象为声明性状态，为了给每个可能的初始状态创建过程，脚本将不断增长。这包括抽象出操作系统（例如 apt 和 DNF）之间的步骤和差异，以及验证可以安全地跳过哪些步骤。&lt;/p&gt;
&lt;p&gt;基础架构即代码带来了一些工具，这些工具提供了一些抽象，以帮助减轻使用脚本管理基础架构的负担。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从脚本部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建基础架构的下一个发展是开始采用先前手动管理基础架构的流程，并通过将工作封装在脚本中来简化它。想象一下，我们有一个名为 createVm.sh 的 bash 脚本，它将在我们的本地工作站中创建一台虚拟机。&lt;/p&gt;
&lt;p&gt;该脚本需要两个参数。第一个是分配给虚拟机上的网络接口的静态 IP 地址。第二个是以千兆字节为单位的大小，用于创建卷并将其挂载到虚拟机。&lt;/p&gt;
&lt;p&gt;示例 3-2 将基础架构的基本表示形式显示为脚本。该脚本将提供新的基础架构，并在新创建的基础架构上运行任意配置脚本。该脚本可能演变为高度可定制的，并且可能是（危险地）自动化的，只需点击一下按钮即可运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-2. 基础架构即脚本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Create a VM with a NIC on 10.0.0.17 and a 100gb volume&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;createVm.sh 10.0.0.17 &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Transfer the bootstrapping script&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scp ~/vm_provision.sh user@10.0.0.17:vm_provision.sh -v
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Run the bootstrap script&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh user@10.0.0.17 sh ~/vm_provision.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即代码&#34;&gt;基础架构即代码&lt;/h3&gt;
&lt;p&gt;配置管理曾经是代表基础架构的主要角色。我们可以将配置管理视为抽象脚本，自动考虑初始状态以执行正确的过程。最重要的是，配置管理允许作者声明节点的期望状态，而不是实现它所需的每一步。&lt;/p&gt;
&lt;p&gt;配置管理是基础架构即代码的第一步，但相关工具很少超出单个服务器的范围。配置管理工具在定义特定资源和他们的状态方面做得非常出色，但由于基础架构需要资源之间的协调，所以出现了复杂性。&lt;/p&gt;
&lt;p&gt;例如，服务的 DNS 条目在提供服务之前不可用。在主机可用之前不应该提供该服务。如果不能在独立节点之间协调多个资源，则配置管理提供的抽象化是不足的。有些工具增加了协调资源之间配置的能力，但协调通常是程序性的，责任落到了人们的协调资源和理解所需状态上。&lt;/p&gt;
&lt;p&gt;您的基础架构不包含没有通信的独立实体。代表基础架构的工具需要考虑到这一点。因此，需要另一种表示来管理低级别抽象（例如操作系统）以及供应和协调。&lt;/p&gt;
&lt;p&gt;2014 年 7 月，有个开源工具在代码发布的时候采用了更高级别的基础架构抽象概念。这个名为 Terraform 的工具非常成功。它在配置管理完善并且公有云的采用呈上升趋势的时间节点发布。用户看到了新环境中工具的局限性，Terraform 很好的满足了他们的需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 2011 年时，我们最初将基础架构视代码。我们注意到我们正在编写工具来解决许多项目的基础架构问题，并希望将流程标准化。&lt;/p&gt;
&lt;p&gt;——Hashicorp 首席执行官兼 Terraform 创始人 Mitchell Hashimoto&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Terraform 使用专门的领域特定语言（DSL）表示基础架构，它在人类可理解的图像和机器可分析的代码之间做了良好的折衷。Terraform 最成功的部分是抽象的基础架构视图，资源协调以及应用时利用现有工具的能力。Terraform 与云 API 进行通信以配置基础架构，并可在必要时使用配置管理来配置节点。&lt;/p&gt;
&lt;p&gt;这是该行业的根本性转变，因为我们看到一次性配置脚本正在消失。越来越多的运营商开始在新的 DSL 中开发基础架构表示。过去在基础架构上手动操作的工程师现在正在开发代码。&lt;/p&gt;
&lt;p&gt;新的 DSL 解决了将基础架构表示为脚本的问题，并成为表示基础架构的标准。工程师发现他们正在开发更好的基础架构代码，并允许 Terraform 对其进行解释。与配置管理代码一样，工程师们开始将他们的基础架构表述存储在版本控制系统中，并将基础架构与软件等同看待。&lt;/p&gt;
&lt;p&gt;通过表述基础架构的标准化方式，我们摆脱了学习各种专有云 API 的痛苦。尽管并非所有云资源都可以用单一表示抽象出来，但大多数用户可以接受其代码中的云锁定。拥有人类可读并且机器可解析的基础架构表示，而不仅仅是独立的资源声明，这一点永远得改变了行业。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从代码部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面临将基础架构部署为脚本的挑战之后，我们已经创建了一个程序来解析输入并针对我们的基础架构采取行动。&lt;/p&gt;
&lt;p&gt;例 3-3 显示了从 Terraform 开源库中获取的 Terraform 配置。注意代码中有变量，需要在运行时解析。&lt;/p&gt;
&lt;p&gt;基础架构的声明性表示很重要，因为它没有定义创建基础架构的各个步骤。这使我们能够分离需要调配的部分和调配的部分。这就是使这种基础架构代表成为新范例的原因；这也是向软件基础架构演进的第一步。&lt;/p&gt;
&lt;p&gt;以这种方式来表示基础架构对于工程师来说是一种常见的强大做法。用户可以使用 Terraform 来应用基础架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-3. example.tf&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Create our DNSimple record&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;resource &lt;span class=&#34;s2&#34;&gt;&amp;#34;dnsimple_record&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;web&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.dnsimple_domain&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;terraform&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;CNAME&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即软件&#34;&gt;基础架构即软件&lt;/h3&gt;
&lt;p&gt;基础架构即代码是朝着正确方向发展的强大举措。但是代码是基础架构的静态表示，并且有其局限性。您可以自动执行部署代码更改的过程，但除非部署工具持续运行，否则仍会出现配置漂移。传统上，部署工具只能在一个方向上工作：它只能创建新对象，并且不能轻易删除或修改现有对象。&lt;/p&gt;
&lt;p&gt;为了掌握基础架构，我们的部署工具需要根据基础架构的初始表示进行工作，并对数据进行变更以创建更灵活的系统。当我们开始将基础架构表示视为一个可持续执行所需状态的可版本化数据体时，下一步就是将基础架构视为软件。&lt;/p&gt;
&lt;p&gt;Terraform 从配置管理中吸取教训并改进了这一概念，以更好地配置基础架构和协调资源。应用程序需要一个抽象层来更有效地利用资源。正如我们在第 1 章中所解释的那样，应用程序不能直接在 IaaS 上运行，而需要在可以管理资源和运行应用程序的平台上运行。&lt;/p&gt;
&lt;p&gt;IaaS 将原始组件作为临时 API 端点呈现，平台呈现更容易被应用程序使用的资源的 API。其中一些资源可能提供 IaaS 组件（例如，负载均衡器或磁盘卷），但其中许多资源将由平台管理（例如，计算资源）。&lt;/p&gt;
&lt;p&gt;平台揭示了一个新的基础架构层，并不断强化所需的状态。平台的组件也是应用程序本身，可以使用相同的期望状态声明进行管理。&lt;/p&gt;
&lt;p&gt;API 机制允许用户获得将基础架构标准化为代码的好处，并增加了随着时间的推移版本化和更改表示的能力。API 允许通过标准实践（如 API 版本控制）消费资源的新方式。API 的使用者可以将其应用程序构建到特定的版本，并相信在使用新的 API 版本之前，它们的使用不会中断。其中有些做法是以前基础架构即代码工具所缺少的重要功能。&lt;/p&gt;
&lt;p&gt;通过持续强化表示的软件，我们现在可以保证我们系统的当前状态。通过提供正确的抽象，平台层变得更加易于使用。&lt;/p&gt;
&lt;p&gt;您可能正在绘制基础架构演变与软件演进之间的相似之处。堆栈中的这两层以非常相似的方式进化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件正在吞噬世界。&lt;/p&gt;
&lt;p&gt;——Marc Andreessen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;封装基础架构并将其视为版本化的 API 将会非常强大。这极大地提高了负责解释表示的软件项目的速度。由平台提供的抽象是跟上快速增长的云所必需的。这种新模式是当今的模式，并且已经被证明可以扩展到难以估量的基础架构和应用程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从软件部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基础架构即代码和基础架构与软件之间的根本区别在于，软件能够改变数据存储，从而改变基础架构的表示。这是由软件来管理基础架构，代表是运营商和软件之间的交换。&lt;/p&gt;
&lt;p&gt;在例 3-4 中，我们看看使用 YAML 表示的基础架构。我们可以信任该软件来解释这种表示，并为呈现 YAML 的结果。&lt;/p&gt;
&lt;p&gt;就像与我们开发基础架构代码时一样，我们从基础架构的表示开始。但在这个例子中，软件会持续运行，并确保表示会随时间的推移。从某种意义上说，这仍然是只读的，但是软件可以扩展这个定义来添加自己的元信息，比如标记和资源创建时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-4. infrastructure.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;New York 1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;172.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/home/user/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;40gb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;minCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;centos-amd64-7&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;172.0.100.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;部署工具&#34;&gt;部署工具&lt;/h2&gt;
&lt;p&gt;我们现在了解部署基础架构的两个角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义基础架构的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观众&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署工具解释表示并采取行动&lt;/p&gt;
&lt;p&gt;我们可以通过很多途径来表述基础架构，采取行动的组成部分是对最初表示的逻辑反映。准确地表示适当的基础架构层并尽可能消除该层的复杂性非常重要。通过简单、有针对性的发布，我们将能够更加准确地应用所需的更改。&lt;/p&gt;
&lt;p&gt;《站点可靠性工程》（O&amp;rsquo;Reilly，2016）总结说：“简单版本通常比复杂版本更好。衡量和理解单一变更的影响，而不是同时发布的一批变更要容易得多。“&lt;/p&gt;
&lt;p&gt;随着我们对基础架构的表示随着时间的推移而变化，以便从底层组件中抽象出来，我们的部署工具已经发生变化，以匹配新的抽象目标。&lt;/p&gt;
&lt;p&gt;我们正在将基础架构视为软件边界，并且可以注意到基础架构部署工具新时代的早期迹象。互联网上的开源项目正在出现，声称能够随着时间的推移管理基础架构。工程师的工作是了解项目管理的基础架构层以及它如何影响其现有工具和其他基础架构层。&lt;/p&gt;
&lt;p&gt;云原生基础架构方向的第一步是采用配置脚本并安排它们持续运行。有些工程师会故意设计这些脚本，以便随着时间的推移安排好。我们开始看到精心设计的全局锁定机制、高级调度策略和分布式调度方法。&lt;/p&gt;
&lt;p&gt;这基本上是配置管理承诺的，尽管在更具资源特定的抽象中。感谢云计算，管理基础架构的自动化脚本的日子已经过去了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自动化已死。&lt;/p&gt;
&lt;p&gt;——Honeycomb 首席执行官 Charity Majors&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们正在想象一个我们开始以完全不同的方式看待基础架构工具的世界。如果您的基础架构旨在运行在云上，那么 IaaS 不是您应该解决的问题。使用云提供的 API，并构建可直接由应用程序使用的新基础架构层。&lt;/p&gt;
&lt;p&gt;我们在基础架构发展方面处于特殊地位，我们从第一天开始就将基础架构部署工具设计为优雅的应用程序。&lt;/p&gt;
&lt;p&gt;良好的部署工具是可以快速从基础架构的人性化表示到可工作基础架构的工具。更好的部署工具是撤销任何与初始表示不一致的变更的工具。最好的部署工具可以完成所有这些工作，而无需人工参与。&lt;/p&gt;
&lt;p&gt;在我们构建这些应用程序时，我们不能忘记从处理复杂系统至关重要的专业工具和软件实践中学到的重要经验。&lt;/p&gt;
&lt;p&gt;我们将看到的部署工具的一些关键方面是幂等性和处理失败。&lt;/p&gt;
&lt;h3 id=&#34;幂等性&#34;&gt;幂等性&lt;/h3&gt;
&lt;p&gt;软件应该是幂等的，这意味着持续输入相同的输入，必须并始终获得相同的输出。&lt;/p&gt;
&lt;p&gt;在技术上，这个想法被超文本传输协议（HTTP）通过像 PUT 和 DELETE 这样的幂等方法而著名。这个想法飞非常强大，并且在软件中宣传幂等性的保证可以塑造出更佳复杂的软件应用程序。&lt;/p&gt;
&lt;p&gt;我们从早期的配置管理工具中学到的经验之一就是幂等性。我们需要记住这个功能为基础架构工程师提供的价值，并且继续将这种模式构建到我们的工具中。&lt;/p&gt;
&lt;p&gt;能够自动创建、更新或删除基础架构，保证无论您运行任务的频率如何，始终都会输出相同的结果，这非常令人兴奋。它允许运维人员开始自动化任务和杂事。过去对于运维人员来说，过去相当大量的工作现在可以像在网页中点击按钮一样简单。&lt;/p&gt;
&lt;p&gt;幂等保证也有助于运营商在其基础架构上执行质量科学。运营商可以在许多物理位置开始复制基础架构，并知道别人重复他们的程序会得到同样的结果。&lt;/p&gt;
&lt;p&gt;我们开始注意到围绕这种自动执行任意任务以实现可重复性的思想构建的整个框架和工具链。&lt;/p&gt;
&lt;p&gt;就像软件一样，基础架构也是如此。运营商开始使用这些表示和部署工具自动管理整个管理基础架构的流水线。现在，运维人员的工作变成了开发自动执行这些任务的工具，而不再是自己执行任务。&lt;/p&gt;
&lt;h3 id=&#34;处理失败&#34;&gt;处理失败&lt;/h3&gt;
&lt;p&gt;任何软件工程师都可以告诉你在代码中处理故障和边缘案例的重要性。作为基础架构管理员我们自然而然就要考虑这些问题。&lt;/p&gt;
&lt;p&gt;如果部署作业在执行过程中失败，更重要的是在这种情况下会发生什么，会发生什么情况？&lt;/p&gt;
&lt;p&gt;在考虑失败的情况下设计我们的部署工具是朝着正确方向迈出的又一步。失败时发送消息或在监控系统中注册警报。我们保存了自动化任务的详细日志。在失败的情况下，我们甚至将逻辑连接在一起。&lt;/p&gt;
&lt;p&gt;我们沉迷于失败。我们在失败的情况下开始采取行动，并在事件发生时采取行动。&lt;/p&gt;
&lt;p&gt;但围绕单个组件可能出现故障的想法来构建系统与构建组件以使其更容易出故障完全不同。根据故障重试组件或调整其方法是将系统的弹性进一步深入到软件中。这允许更稳定的系统并减少系统本身所需的整体支持。&lt;/p&gt;
&lt;p&gt;面向故障而设计组件，而不是系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以设计失败的组件为名，我们需要学习一个描述处理失败的常用方法的术语。&lt;/p&gt;
&lt;p&gt;最终的一致性意味着企图随着时间的推移调和一个系统。较大的系统和较小的组件都可以遵循这种随时间推移重试失败过程的理念。&lt;/p&gt;
&lt;p&gt;最终一致的系统的好处之一是运维人员可以确信它最终会达到预期的状态。这些系统的一个担忧是，有时他们可能花费不恰当的时间来达到所需的状态。&lt;/p&gt;
&lt;p&gt;知道什么时候选择一个稳定但缓慢的系统与一个不可靠但快速的系统是管理员必须做出的技术决策。在这个决定中要注意的重要关系是系统交换速度的可靠性。这并不容易，但如果有疑问，请始终选择可靠的系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与最终一致的系统相反的是原子系统，这是一项保证交易，决定了整个工作的成功。如果作业无法完成，则会恢复所做的更改并完全失败。&lt;/p&gt;
&lt;p&gt;想象一下需要创建 10 个虚拟机的工作。工作到达第七台虚拟机，出现问题。根据最终的一致性方法，我们只会反复尝试这项工作，希望最终获得 10 个虚拟机。&lt;/p&gt;
&lt;p&gt;了解我们只能创建 7 个虚拟机的原因非常重要。想象一下，云计算允许我们创建多少个虚拟机是有限制的。最终一致性模型将继续尝试创建另外三台机器，并且不可避免地会失败每次。&lt;/p&gt;
&lt;p&gt;如果这项工作是设计成原子的，那么它将在第七台机器上达到极限，并意识到这是一场灾难性的失败。这项工作将负责删除部分系统。&lt;/p&gt;
&lt;p&gt;因此，运维人员可以放心，他们或者完全按照预期建立系统，或者根本不会创建任何东西。这是一个很有意义的想法，因为为了能让系统正常工作，基础架构中的许多组件都依赖于系统中的其他部分。&lt;/p&gt;
&lt;p&gt;我们可以引入信心来换取不便。也就是说，管理员会相信他们的系统状态永远不会改变，除非可以应用完美的改变。为了交换这个完美的系统，运维人员可能会面临很大的不便，因为系统可能需要很多工作才能保持平稳运行。&lt;/p&gt;
&lt;p&gt;选择一个原子系统是安全的，但可能不是我们想要的。工程师需要知道他们想要什么系统，以及何时选择原子性与最终一致性。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;部署基础架构的模式很简单，并且在云可用之前一直保持不变。我们代表基础架构，然后使用一些设备，将基础架构变为现实。&lt;/p&gt;
&lt;p&gt;基础架构层与软件应用层具有惊人的类似历史。云原生基础架构也不例外。我们开始发现自己在重复历史，并以新的方式学习古老的教训。&lt;/p&gt;
&lt;p&gt;如果我们已经知道其软件对手的未来，那么对于预测基础架构行业未来的能力还有什么要说的？&lt;/p&gt;
&lt;p&gt;云原生基础架构是基础架构演变的一种自然而可能预期的结果。能够以可靠和可重复的方式部署、表示和管理它是必要的。随着时间的推移，我们能够部署我们的部署工具，并转移我们的工作方式，这对于将我们的基础架构保持在一个能够支持其应用层的空间中至关重要。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>设计基础架构应用程序</title>
      <link>https://jimmysong.io/book/cloud-native-infra/designing-infrastructure-applicaitons/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/designing-infrastructure-applicaitons/</guid>
      <description>
        
        
        &lt;p&gt;在前一章中，我们了解了基础架构的各种表示以及围绕其部署工具的各种方法。在本章中，我们将看看如何设计部署和管理基础架构的应用程序。在上一章中我们重点关注基础架构即软件的开放世界，有时称为基础架构即应用。&lt;/p&gt;
&lt;p&gt;在云原生环境中，传统的基础架构运维人员需要转变为基础架构软件工程师。与过去的其他运维角色不同，这仍然是一种新兴的做法。我们迫切需要开始探索这种模式和制定标准。&lt;/p&gt;
&lt;p&gt;基础架构即软件与基础架构即代码之间的根本区别在于，软件会持续运行，并会根据调节器模式创建或改变基础架构，我们将在本章后面对其进行解释。此外，基础架构即软件的新范例是，软件现在与数据存储具有更传统的关系，并公开用于定义所需状态的 API。例如，该软件可能会根据数据存储中的需要改变基础架构的表示形式，并且可以很好地管理数据存储本身！希望进行协调的状态更改通过 API 发送到软件，而不是通过运行静态代码库中的程序。&lt;/p&gt;
&lt;p&gt;迈向基础架构即软件的第一步是让基础架构的运维人员意识到自己是软件工程师。我们热烈欢迎您来到这个领域！先前的工具（例如配置管理）也有类似的改变基础架构运维人员的工作职能的目标，但是运维人员通常只会在狭窄的应用范围内编写有限的 DSL（即单一节点抽象）。&lt;/p&gt;
&lt;p&gt;作为一名基础架构工程师，您的任务不仅是掌握设计、管理和运维基础架构的基本原则，还需要具有将您的专业知识封装成坚如磐石的应用程序的能力。这些应用程序代表了我们将要管理和改变的基础架构。&lt;/p&gt;
&lt;p&gt;构建管理基础架构软件工程不是一件容易的事情。我们有管理传统应用的所有问题和担忧，而且我们正处于一个尴尬的境地。基础架构软件工程看上去似乎很荒谬，构建软件来部署基础架构，这样就可以在新创建的基础架构之上运行相同的软件，这很尴尬。&lt;/p&gt;
&lt;p&gt;首先，我们需要了解这个新领域中工程软件的细微差别。我们将研究在云原生社区中得到验证的模式，以了解在应用程序中编写干净和逻辑代码的重要性。但首先，基础架构从哪里来？&lt;/p&gt;
&lt;h2 id=&#34;自举问题&#34;&gt;自举问题&lt;/h2&gt;
&lt;p&gt;1987 年 3 月 22 日，周日，Richard M. Stallman 发送了一封电子邮件到 GCC 邮件列表，报告成功使用 C 编译器完成了自行编译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该编译器在 68020 上编译正确，最近又在 vax 上进行了编译。最近在 68020 上正确编译了 Emacs，并且还编译了 tex-in-C 和 Kyoto Common Lisp。但是，可能仍然有许多错误，希望你能帮我找到。&lt;/p&gt;
&lt;p&gt;我将离开一个月，所以现在报告的错误将得不到处理。——Richard M. Stallman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是软件历史上的一个重要转折点，因为工程软件首次完成了自举（Bootstrap）。Stallman 开创了一个可以自行编译的编译器。即使在哲学上接受这个表述可能也是困难的。&lt;/p&gt;
&lt;p&gt;今天我们正在解决与基础架构相同的问题。工程师必须想办法解决几乎不可能的系统自举问题，并在运行时生效。&lt;/p&gt;
&lt;p&gt;有一种方法是手动创建云计算和基础架构应用程序中的第一个基础架构。尽管这种方法确实有效，但它通常伴随着警告，即运维人员应该在部署更合适的基础架构后销毁初始引导基础架构。这种方法乏味、难以重复且容易出现人为错误。&lt;/p&gt;
&lt;p&gt;解决这个问题的更优雅和云原生方法是做出（通常是正确的）假设，即试图引导基础架构软件的任何人都有本地机器，我们可以利用这个本地机器。现有机器（您的计算机）可作为第一个部署工具，自动在云中创建基础架构。基础架构就位后，您的本地部署工具可以将其自身部署到新创建的基础架构并持续运行。良好的部署工具可以让你在完成后轻松清理。&lt;/p&gt;
&lt;p&gt;在初始基础架构引导问题解决后，我们可以使用基础架构应用程序来引导新的基础架构。现在本地计算机已经被排除在外，现在我们完全运行在云端。&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;在前面的章节中，我们讨论了表示基础架构的各种方法。在本章中，我们将探讨为基础架构提供 API 的概念。&lt;/p&gt;
&lt;p&gt;当用软件实现 API 时，很可能会通过数据结构来完成。因此，根据您使用的编程语言，将 API 视为类、字典、数组、对象或结构体是安全的。&lt;/p&gt;
&lt;p&gt;API 将是数据值的任意定义，可能是字符串、整数或布尔值。API 将通过 JSON 或 YAML 格式进行编码和解码甚至可能存储在数据库中。&lt;/p&gt;
&lt;p&gt;对于大多数软件工程师来说，为程序提供可版本化的 API 是很常见的做法。这允许程序随着时间移动、改变和增长。工程师可以声称支持较旧的 API 版本并提供向后兼容性保证。在基础架构即软件中，由于这些原因，使用 API 是首选的。&lt;/p&gt;
&lt;p&gt;寻找一个 API 作为基础架构的接口是用户使用基础架构即软件的许多线索之一。传统上，基础架构即代码是用户将要管理的基础架构的直接表示，而 API 是对要管理的具体底层资源之上的抽象。&lt;/p&gt;
&lt;p&gt;最终，API 只是代表基础架构的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;状态&#34;&gt;状态&lt;/h2&gt;
&lt;p&gt;在基础架构即软件工具的环境中，我们要管理的对象是基础架构。因此，对象状态只是我们的程序对软件的审计表示。&lt;/p&gt;
&lt;p&gt;对象的状态最终将回到基础架构表示的内存中。这些内存中的表示应映射到用于声明基础架构的原始 API。审计的 API 或对象状态通常需要保存。&lt;/p&gt;
&lt;p&gt;存储介质（有时称为状态存储）可用于存储新审计的 API。介质可以是任何传统存储系统，例如本地文件系统、云对象存储或数据库。如果数据存储在类似文件系统的存储中，那么该工具将很可能以逻辑方式对数据进行编码，以便可以在运行时轻松对数据进行编码和解码。常见的编码包括 JSON、YAML 和 TOML。&lt;/p&gt;
&lt;p&gt;当设计程序时您可能会想要将用于存储其他数据的特权信息存储起来。这究竟是不是最佳实践具体取决于您的安全性要求以及您计划存储数据的位置。&lt;/p&gt;
&lt;p&gt;记住存储机密可能是一个漏洞，这一点很重要。在设计软件来控制堆栈最基本的部分时，安全性至关重要。所以通常值得额外的努力来确保机密信息是安全的。&lt;/p&gt;
&lt;p&gt;除了存储有关程序和云提供商凭证的元信息之外，工程师还需要存储有关基础架构的信息。重要的是要记住，基础架构将以某种方式呈现，理想情况下，该程序易于解码。记住对系统进行更改不会立即发生，而随着时间的推移也很重要。&lt;/p&gt;
&lt;p&gt;存储这些数据并能够轻松访问是设计基础架构管理应用程序的重要部分。仅基础架构定义很可能就已经是系统中最具智慧价值的部分。我们来看一个基本的例子，看看这些数据和程序如何一起工作。&lt;/p&gt;
&lt;p&gt;重新审视例 4-1 至 4-4，因为它们被用作本章进一步演示的具体例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件系统状态存储示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一下，数据存储在一个名为 state 的目录中。在该目录中，有三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;meta_information.yaml&lt;/li&gt;
&lt;li&gt;secrets.yaml&lt;/li&gt;
&lt;li&gt;infrastructure.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个简单的数据存储可以准确地封装需要保留的信息，以便有效管理基础架构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;secrets.yaml&lt;/code&gt;和&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件存储基础架构的表示形式，&lt;code&gt;meta_information.yaml&lt;/code&gt;文件（示例 4-1）存储其他重要信息，例如基础架构上次调配时间，调配时间和日志信息。&lt;/p&gt;
&lt;p&gt;例 4-1. state/meta_information.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;lastExecution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exitCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2017-08-01 15:32:11 +00&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kris&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;logFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log/infra.log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二个文件&lt;code&gt;secrets.yaml&lt;/code&gt;保存私人信息，用于在程序执行过程中以任意方式验证（例 4-2）。&lt;/p&gt;
&lt;p&gt;重申一下，以这种方式存储机密可能是不安全的。我们仅以&lt;code&gt;secrets.yaml&lt;/code&gt;为例。&lt;/p&gt;
&lt;p&gt;例 4-2. state/secrets.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiAccessToken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a8233fc28d09a9c27b2e2f&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiSecret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;8a2976744f239eaa9287f83b23309023d&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;privateKeyPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;~/.ssh/id_rsa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个文件&lt;code&gt;infrastructure.yaml&lt;/code&gt;将包含 API 的编码表示形式，包括使用的 API 版本（示例 4-3）。我们可以在这里找到基础架构表示，例如网络和 DNS 信息，防火墙规则和虚拟机定义。&lt;/p&gt;
&lt;p&gt;例 4-3. state/infrastructure.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;San Francisco 2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/infra/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnetHostsCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu-16-04-x64&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;起初&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件可能看起来只不过是基础架构代码的一个例子。但是，如果仔细观察，您会发现许多定义的指令都是具体基础架构之上的抽象。例如，&lt;code&gt;subnetHostsCount&lt;/code&gt;指令是一个整数值并定义了子网中主机的预定数量。该程序将设法为运维人员划分网络中定义的更大的无类别域间路由（CIDR）值。运维人员不会声明子网，只需要声明有多少主机。软件会帮运维人员完成剩下的操作。&lt;/p&gt;
&lt;p&gt;程序运行时可能会更新 API 并将新的表示写入数据存储区（本案例中仅是一个文件）。继续我们的&lt;code&gt;subnetHostsCount&lt;/code&gt;示例，假设程序确实为我们挑选了一个子网 CIDR。新的数据结构可能如例 4-4 所示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;San Francisco 2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/infra/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnetHostsCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;assignedSubnetCIDR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.100.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu-16-04-x64&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意程序如何编写 assignedSubnetCIDR 指令，而不是由运维人员操作。另外，请记住应用程序如何更新 API 是用户以软件方式与基础架构进行交互的标志。&lt;/p&gt;
&lt;p&gt;现在，请记住，这只是一个例子，并不一定主张使用抽象计算子网 CIDR。不同的用例可能需要在应用程序中进行不同的抽象和实现。关于构建基础架构应用程序的一个好处是，用户可以以任何他们认为可以解决自己问题的方式设计软件。&lt;/p&gt;
&lt;p&gt;数据存储（&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件）现在可以被认为是软件工程领域的传统数据存储。也就是说，该程序可以对文件进行完全的写入控制。&lt;/p&gt;
&lt;p&gt;我们会发现，这会带来风险，但对工程师来说也是一个巨大的胜利。基础架构表示不必存储在文件系统的文件中。相反，它可以存储在任何数据存储中，如传统数据库或键/值存储系统。&lt;/p&gt;
&lt;p&gt;为了理解软件如何处理这种新的基础架构表示的复杂性，我们必须理解系统中的两种状态——API 形式的预期状态，可在&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件中找到，另一种可以在现实（或审计）中观察到的实际状态。&lt;/p&gt;
&lt;p&gt;在这个例子中，软件还没有做任何事情或者采取任何行动，而我们正处于管理时间线的开始。因此，实际状态将是什么都没有，而预期状态将是封装在&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件中的任何状态。&lt;/p&gt;
&lt;h2 id=&#34;调节器模式&#34;&gt;调节器模式&lt;/h2&gt;
&lt;p&gt;调节器模式（reconciler pattern）是一种软件模式，可用于管理云原生基础架构。该模式强化了基础架构的两种表现形式——第一种是基础架构的实际状态，第二种是基础架构的预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式将迫使工程师以两个独立的途径忘记这些表示，以及实现一个解决方案，以协调实际状态达到预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式可以被认为是一套四种方法和四种哲学规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的输入和输出都使用数据结构。&lt;/li&gt;
&lt;li&gt;确保数据结构是不可变的。&lt;/li&gt;
&lt;li&gt;保持资源映射简单。&lt;/li&gt;
&lt;li&gt;使实际状态符合预期状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些模式的消费者可以依靠这些强大的保证。此外，他们将消费者从实施细节中解放出来。&lt;/p&gt;
&lt;h3 id=&#34;规则-1为所有输入和输出使用数据结构&#34;&gt;规则 1：为所有输入和输出使用数据结构&lt;/h3&gt;
&lt;p&gt;实现调节器模式的方法只能接受和返回数据结构。结构必须在调节器实现的上下文之外定义，但实现必须知道它。&lt;/p&gt;
&lt;p&gt;通过仅接受用于输入的数据结构并将其作为输出返回，消费者可以协调其数据存储中定义的任何结构，而不必担心该协调如何发生。这也允许在运行时或者程序的不同版本中改变、修改或切换实现。&lt;/p&gt;
&lt;p&gt;尽管我们希望尽可能经常遵守第一条规则，但是永远不要将数据结构和代码库紧密结合也非常重要。始终遵守最佳的抽象和分离实践，绝不使用 API 的子集来传递函数或类。&lt;/p&gt;
&lt;h3 id=&#34;规则-2确保数据结构不可变&#34;&gt;规则 2：确保数据结构不可变&lt;/h3&gt;
&lt;p&gt;考虑像合同或担保这样的数据结构。在调节器模式的上下文中，实际和期望的结构在运行时设置在内存中。这保证了在调节之前结构是准确的。在协调基础架构的过程中，如果结构发生变化，则必须创建一个具有相同保证的新结构。明智的基础架构应用程序将强制数据结构的不变性，即使工程师试图改变数据结构，它也不会工作，或者程序会出错（甚至可能会编译不过）。&lt;/p&gt;
&lt;p&gt;基础架构应用程序的核心组件是将表示映射到一组资源的能力。资源是需要运行以满足基础架构要求的单个任务。这些任务中的每一个都将负责以某种方式更改基础架构。&lt;/p&gt;
&lt;p&gt;部署新虚拟机是基本示例，设置新网络或配置现有虚拟机。这些工作单元中的每一个都将被称为资源。每个数据结构都应映射到一定数量的资源。应用程序负责推理结构并创建资源集。图 4-1 中显示了 API 映射到单个资源的示例。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/designing-infrastructure-applicaitons/f-4-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/designing-infrastructure-applicaitons/f-4-1.jpg&#34; data-width=&#34;1158&#34; data-height=&#34;722&#34; alt=&#34;image&#34; data-caption=&#34;图4-1. 将结构映射到资源的图表&#34;&gt;
    
  
  &lt;figcaption&gt;图4-1. 将结构映射到资源的图表&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;调节器模式演示了一种处理数据结构的稳定方法，因为它会改变资源。由于调节器模式需要比较资源状态，所以数据结构必须是不可变的。这意味着无论何时需要更新数据结构，都必须创建新的数据结构。&lt;/p&gt;
&lt;p&gt;注意基础架构的变化。每次发生突变时，实际的数据结构都是陈旧的。一个聪明的基础架构应用程序将意识到这个问题并相应地处理它。&lt;/p&gt;
&lt;p&gt;一种简单的解决方案是在发生突变时更新内存中的数据结构。如果每次突变都更新实际状态，则可以观察调节过程，因为实际状态会随时间经历一系列更改，直到最终匹配预期状态并且调节完成。&lt;/p&gt;
&lt;h3 id=&#34;规则-3保持资源映射简单&#34;&gt;规则 3：保持资源映射简单&lt;/h3&gt;
&lt;p&gt;在调节者的幕后，这个模式就是一个实现。一个实现只是一组代码，具有创建、修改和删除基础结构的方法。一个程序可能有很多实现。&lt;/p&gt;
&lt;p&gt;每个实现最终都需要将数据结构映射到一组资源。这组资源需要按逻辑方式组合在一起，以便程序可以推断每个资源。&lt;/p&gt;
&lt;p&gt;除了创建资源的基本模型之外，您必须非常注意每个资源的依赖关系。许多资源依赖于其他资源，这意味着许多基础架构都依赖于其他部分。例如，在将虚拟机放入网络之前，网络需要存在。&lt;/p&gt;
&lt;p&gt;调节器模式规定应该使用用于分组资源的最简单的数据结构。&lt;/p&gt;
&lt;p&gt;解决资源映射问题是一个工程决策，每个实现都可能会发生变化。仔细挑选数据结构非常重要，因为从工程角度看，调节器需要稳定且易于理解。&lt;/p&gt;
&lt;p&gt;映射数据的两种常见结构是集合和图形。&lt;/p&gt;
&lt;p&gt;一组是可以迭代的资源的平面列表。在许多编程语言中，这些被称为列表、集合、数组等。&lt;/p&gt;
&lt;p&gt;图形是通过指针链接在一起的顶点（vertex）的集合。根据编程语言，图的顶点通常是结构或类。顶点通过在顶点某处定义的指针有一个到另一个顶点的链接。图形实现可以通过指针从一个跳到另一个来访问每个顶点。&lt;/p&gt;
&lt;p&gt;例 4-5 是 Go 编程语言中一个基本顶点的例子。&lt;/p&gt;
&lt;p&gt;例 4-5. 示例顶点&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Vertex 是表示图中单点的数据结构。一个 Vertex 可以有 N 个子点或一个也没有。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遍历图的例子可能像迭代遍历每个子元素一样简单。这种遍历有时被称为“walking the graph”。&lt;/p&gt;
&lt;p&gt;例 4-6 是通过 Go 中写入的深度优先遍历递归访问图中每个顶点的示例。&lt;/p&gt;
&lt;p&gt;例 4-6. 深度优先遍历&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// recursiveWalk 将递归地挖掘所有子级，并相应地搜索其子级，并将当前正在访问的顶点的名称回显到 STDOUT。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recursiveWalk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Currently visiting vertex: %s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;recursiveWalk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，图的简单实现似乎是解决资源图的合理选择，因为可以通过逻辑方式构建图来处理依赖关系。虽然图会起作用，但它也会带来风险和复杂性。实施图来绘制资源的最大风险是在图中有环。一个循环是当一个图的一个顶点通过一条以上的路径指向另一个顶点时，这意味着遍历该图是一个无止境的操作。&lt;/p&gt;
&lt;p&gt;必要时可以使用图，但在大多数情况下，调节器模式应该映射一组资源，而不是图。通过使用一个集合，调节器可以程序化地遍历资源，并提供线性方法来解决映射问题。此外，撤销或删除基础架构的过程与通过反向遍历集合一样简单。&lt;/p&gt;
&lt;h3 id=&#34;规则-4使实际状态符合预期状态&#34;&gt;规则 4：使实际状态符合预期状态&lt;/h3&gt;
&lt;p&gt;协调器模式中提供的保证是，用户可以准确得到预期的结果或错误。这是使用调节器的工程师可以依赖的保证。这很重要，因为消费者不必担心验证调节人突变是幂等的并且按预期结束。实现最终负责解决此问题。有了这种保证，在更复杂的操作中使用调节器模式，如控制器或 operator，现在变得更加简单。&lt;/p&gt;
&lt;p&gt;在返回调用代码之前，实现应检查新调节的实际数据结构是否与最初预期的数据结构匹配。如果没有，它应该是错误的。消费者不应该关心验证 API，并且应该相信如果出现问题调节器会报错。&lt;/p&gt;
&lt;p&gt;因为数据结构是不可变的，并且如果协调器模式不成功，API 也会出错，因此我们可以高度信任 API。对于复杂的系统，重要的是，您必须相信软件可以以可预测的方式工作或失败。&lt;/p&gt;
&lt;h2 id=&#34;调节器模式的方法&#34;&gt;调节器模式的方法&lt;/h2&gt;
&lt;p&gt;根据我们刚刚解释的调节器模式的信息和规则，让我们看看这些规则是如何实现的。我们将通过查看实现调节器模式的应用程序所需的方法来执行此操作。&lt;/p&gt;
&lt;p&gt;调节器模式的第一种方法是&lt;code&gt;GetActual()&lt;/code&gt;。这种方法有时称为审计，用于查询基础架构的实际状态。该方法通过生成资源映射，然后程序地调用每个资源以查看存在什么（如果有的话）。该方法将根据查询结果更新数据结构，并返回表示实际正在运行的程序状态以填充数据结构。&lt;/p&gt;
&lt;p&gt;一个更简单的方法&lt;code&gt;GetExpected()&lt;/code&gt;将从数据存储中读取对象的预期状态。在&lt;code&gt;infrastructure.yaml&lt;/code&gt;示例（例 4-4）中，&lt;code&gt;GetExpected()&lt;/code&gt;将简单地解组这个 YAML 并将其以内存中的数据结构的形式返回。在这一步没有进行资源审计。&lt;/p&gt;
&lt;p&gt;最令人兴奋的方法是&lt;code&gt;Reconcile()&lt;/code&gt;方法，其中调节器实现将获得对象的实际状态和预期状态。&lt;/p&gt;
&lt;p&gt;这是调节器模式的意图驱动行为的核心。底层调节器实现将使用在&lt;code&gt;GetActual()&lt;/code&gt;中使用的相同资源映射逻辑来定义一组资源。然后协调执行将对这些资源进行操作，独立协调每一个资源。&lt;/p&gt;
&lt;p&gt;了解每个资源调节步骤的复杂性非常重要。调节器实现必须以两种方式工作。&lt;/p&gt;
&lt;p&gt;首先，从所需和实际状态获取资源属性。接下来，将更改应用到最小的一组属性，以使实际状态与所需的状态匹配。&lt;/p&gt;
&lt;p&gt;只要这两个基础架构的表示有冲突，调节器执行必须采取行动并改变基础架构。协调步骤完成后，调节器实施必须创建一个新的表示，然后转到下一个资源。在所有资源调和后，调节器实现将新的数据结构返回给接口的调用者。现在这个新的数据结构准确地代表了对象的实际状态，并应该保证它与原始的实际数据结构相匹配。&lt;/p&gt;
&lt;p&gt;调节器模式的最后一个方法是&lt;code&gt;Destroy()&lt;/code&gt;方法。&lt;code&gt;wordDestroy()&lt;/code&gt;是故意选择在&lt;code&gt;Delete()&lt;/code&gt;上的，因为我们希望工程师意识到该方法应该销毁基础架构，并且从不禁用它。&lt;code&gt;Destroy()&lt;/code&gt;方法的实现很简单。它使用与前面实现方法中定义的资源映射相同的资源映射，但仅对资源进行反向操作。&lt;/p&gt;
&lt;h3 id=&#34;go-中的模式示例&#34;&gt;Go 中的模式示例&lt;/h3&gt;
&lt;p&gt;例 4-7 是 Go 编程语言中定义的调节器模式的四种方法。&lt;/p&gt;
&lt;p&gt;如果你不了解 Go，别担心。该模式可以很容易地用任何语言实现。我们只使用 Go，因为它清楚地定义了每种方法的输入和输出类型。请阅读每种方法的注释，因为它定义了每种方法需要做什么以及何时应该使用。&lt;/p&gt;
&lt;p&gt;例 4-7. 调节器模式接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 下面的 reconciler 接口是调节器模式的示例，每当用户打算根据可能随时间变化的状态来更改基础结构时，都应使用它。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Reconciler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// GetActual 不接受输入参数。数据结构应包含基础架构的完整表示。有时称为审核。应该使用此方法来实时表示现有的基础架构。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetActual&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// GetExpected 不接受输入参数，并返回一个填充的数据结构，该数据结构表示运维人员已声明存在的基础结构以及可能的错误。有时将其称为预期或预期状态。应该使用此方法来实时表示运维人员打算使用的基础结构。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetExpected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Reconcile 有两个参数。actualApi 是从 GetActual 方法返回的填充数据结构。ExpectedApi 是从 GetExpected 方法返回的填充数据结构。Reconcile 将返回填充的数据结构，该数据结构表示新的“实际”状态以及可能的错误。根据定义，此处返回的数据结构应与从 GetExpected 方法返回的数据结构匹配。此方法负责对基础结构进行更改。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Reconcile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;actualApi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedApi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Destroy 有一个参数。actualApi 是从 GetActual 方法返回的填充数据结构。Destroy 将返回填充的数据结构，该数据结构表示新的“实际”状态以及可能的错误。根据定义，此处返回的数据结构应与从 GetExpected 方法返回的数据结构匹配。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;actualApi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;审计关系&#34;&gt;审计关系&lt;/h2&gt;
&lt;p&gt;随着时间的推移，基础架构的最后一次审计变得陈旧，增加了我们对基础架构的表示不准确的风险。因此，折衷的办法是运维人员可以调整审计频率以确定基础架构表示的准确性。&lt;/p&gt;
&lt;p&gt;调节是隐式的审计。如果没有任何变化，调节器就什么也不用做，这一步就成为了审计，验证我们对基础架构的表示是否准确。&lt;/p&gt;
&lt;p&gt;此外，如果在我们的基础架构中碰巧发生了一些变化，调节器将检测到这一变化并尝试纠正它。在完成调节后，基础架构的状态将保证准确。因此，隐含地，我们再次审计了基础架构。&lt;/p&gt;
&lt;h2 id=&#34;配置管理中的审计和调节器模式&#34;&gt;配置管理中的审计和调节器模式&lt;/h2&gt;
&lt;p&gt;基础架构工程师可能熟悉来自配置管理工具的调节器模式，这些工具使用类似的方法来改变操作系统。配置管理工具通过一组资源来管理工程师定义的一组清单或配方。&lt;/p&gt;
&lt;p&gt;该工具将对系统采取行动以确保实际状态和所需状态匹配。如果没有更改，则执行简单审计以确保状态匹配。&lt;/p&gt;
&lt;p&gt;配置管理与云原生基础架构应用程序不同的原因是，配置管理传统上是抽象的单节点，并且不会创建或管理基础架构资源。&lt;/p&gt;
&lt;p&gt;一些配置管理工具正在将其在这个领域的使用扩展到一定程度的成功，但它们仍然属于基础架构类的代码范畴，而不是软件提供的基础架构的双向关系。&lt;/p&gt;
&lt;p&gt;轻量级和稳定的调节器实施可以产生强大的效果，并快速协调，从而为运维人员提供准确的基础架构表示的信心。&lt;/p&gt;
&lt;h3 id=&#34;在控制器中使用调节器模式&#34;&gt;在控制器中使用调节器模式&lt;/h3&gt;
&lt;p&gt;编排管理工具（如 Kubernetes）为我们提供了一个可以方便地运行应用程序的平台。控制器是为预期状态提供控制回路。Kubernetes 建立在这个基础之上。调节器模式可以很容易地审计和协调由 Kubernetes 控制的对象。&lt;/p&gt;
&lt;p&gt;想象一下在以下步骤中循环将无休止地流经调节器模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;GetExpected()&lt;/code&gt;并从数据存储中读取基础结构的预期状态。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;GetActual()&lt;/code&gt;并从环境中读取以获取基础结构的实际状态。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Reconcile()&lt;/code&gt;并调和状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以这种方式实施调节器模式的程序将用作控制器。由于很容易看出控制器本身的程序必须有多小巧，因此该方案的优雅显而易见。&lt;/p&gt;
&lt;p&gt;此外，改变基础架构就像改变状态存储一样简单。控制器将在下次调用&lt;code&gt;GetExpected()&lt;/code&gt;时读取更改并触发协调。负责基础架构的运维人员可以放心，稳定可靠的循环在后台安静地运行，在基础架构环境中执行他的意愿。现在，运维人员通过管理应用来管理基础架构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制回路的目标搜寻行为非常稳定。Kubernetes 已经证明了这一点，我们曾经发现过一些没有被注意到的错误，因为控制回路基本上是稳定的，并且会随着时间的推移而自行修正。&lt;/p&gt;
&lt;p&gt;如果您被边缘（edge）触发，则会冒着损害您的状态的风险，并且永远无法重新创建状态。如果您是水平（level）触发的，并为不正常的组件留出了空间，应予以纠正。这就是使 Kubernetes 如此出色地工作的原因。&lt;/p&gt;
&lt;p&gt;——Joe Beda，Heptio 公司首席技术官&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;销毁基础架构现在就像通知控制器我们希望销毁基础架构一样简单。这可以通过多种方式完成。一种方法是让控制器遵守禁用的状态文件。这可以通过从开启一个比特位反转来表示。&lt;/p&gt;
&lt;p&gt;另一种方式可能是删除状态的内容。无论运维人员如何选择发送&lt;code&gt;Destroy()&lt;/code&gt;信号，控制器都准备好调用&lt;code&gt;convenienceDestroy()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&#34;本章小结&#34;&gt;本章小结&lt;/h2&gt;
&lt;p&gt;基础架构工程师也是软件工程师，负责构建先进的高度分布式系统，在后台开发。他们必须编写管理他们负责的基础架构的软件。&lt;/p&gt;
&lt;p&gt;虽然这两个学科之间有许多相似之处，但基础架构管理应用程序的工程需要终身学习。诸如引导基础架构之类的难题不断发展，需要工程师不断学习新事物。还需要维护和优化基础架构，这一定会让工程师长期受雇。&lt;/p&gt;
&lt;p&gt;本章为用户提供了强大的模式和基础知识，将不明确的 API 结构映射为粒度资源。这些资源可以应用到您的本地数据中心、私有云或公有云中。&lt;/p&gt;
&lt;p&gt;了解这些模式的工作原理对于构建可靠的基础架构管理应用程序至关重要。本章阐述的模式旨在为工程师提供构建声明式基础架构管理应用程序的起点和灵感。&lt;/p&gt;
&lt;p&gt;在构建基础架构管理应用程序时，没有正确或错误的答案，只要应用程序遵循 Unix 哲学：“做一件事并把它做得很好。“&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>开发基础架构应用程序</title>
      <link>https://jimmysong.io/book/cloud-native-infra/developing-infrastructure-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/developing-infrastructure-applications/</guid>
      <description>
        
        
        &lt;p&gt;在构建应用程序以管理基础架构时，我们要将需要公开的 API 与要创建的应用程序等量看待。这些 API 将代表您的基础架构的抽象，而应用程序将使用 API 消费这些这些基础架构。&lt;/p&gt;
&lt;p&gt;务必牢牢掌握两者的重要性，和如何利用它们来创建可扩展的弹性基础架构。&lt;/p&gt;
&lt;p&gt;在本章中，我们将举一个虚构的云原生应用程序和 API 示例，这些应用程序和 API 会经历正常的应用程序周期。如果您想了解更多有关管理云原生应用程序的信息，请参阅第 7 章。&lt;/p&gt;
&lt;h2 id=&#34;设计-api&#34;&gt;设计 API&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 API 是指处理数据结构中的基础架构表示，而不关心如何暴露或消费这些 API。通常使用 HTTP RESTful 端点来传递数据结构，API 如何实现对本章并不重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着基础架构的不断发展，运行在基础架构之上的应用程序也要随之演变。为这些应用程序的功能将随着时间而改变，因此基础架构是也是隐性地演变。随着基础架构的不断发展，管理它的应用程序也必须发展。&lt;/p&gt;
&lt;p&gt;基础架构的功能、需求和发展将永无止境。如果幸运的话，云供应商的 API 将会保持稳定，不会频繁更改。作为基础架构工程师，我们需要做好准备，以适应这些需求。我们需要准备好发展我们的基础架构和运行其上的应用程序。&lt;/p&gt;
&lt;p&gt;我们必须创建可缩放的应用程序，并准备对其进行扩展。为了做到这一点，我们需要了解在不破坏应用程序现有流程的情况下对应用程序进行大量更改的细微差别。&lt;/p&gt;
&lt;p&gt;管理基础架构的工程应用的好处在于它解放了运维人员的生产力。&lt;/p&gt;
&lt;p&gt;应用程序中使用的抽象现在由工程师来完成。我们可以详尽或抽象的描述 API，这都可以。通过具体和抽象定义的强大组合可以帮助运维人员准确地描述他们需要管理基础架构。&lt;/p&gt;
&lt;h2 id=&#34;添加功能&#34;&gt;添加功能&lt;/h2&gt;
&lt;p&gt;根据功能的性质，向基础架构应用程序添加功能可能非常简单也可能非常复杂。添加功能的目标是能够添加新功能而不会危害现有功能。我们绝不希望引入会以给系统其他组件带来负面影响的功能。此外，我们一直希望确保系统输入在合理的时间内保持有效。&lt;/p&gt;
&lt;p&gt;例 5-1 是本书前面介绍的基础架构 API 演化的具体示例。我们称之为 API v1。&lt;/p&gt;
&lt;p&gt;例 5-1. v1.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;想象一下，我们希望实现一项功能，允许基础架构运维人员为虚拟机定义 DNS 记录。新的 API 看起来略有不同。在例 5-2 中，我们将定义一个名为 version 的顶级指令，告诉应用程序这是 API 的 v2 版本。我们还将添加一个新的块，用于在虚拟机块的上下文中定义 DNS 记录。这是 v1 中不支持的新指令。&lt;/p&gt;
&lt;p&gt;例 5-2. v2.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;dnsRecords&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ttl&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两个对象都是有效的，应用程序应该继续支持它们。应用程序应检测到 v2 对象是否打算使用内置于应用程序中的 DNS 新功能。该应用程序应该足够聪明，以适当地导航到新功能。将资源应用于云时，新的 v2 对象的资源集将与第一个 v1 对象相同，但添加了单个 DNS 资源。&lt;/p&gt;
&lt;p&gt;这引入了一个有趣的问题：应用程序应该如何处理旧的 API 对象？应用程序应仍可以在云中创建资源，且支持无 DNS 的虚拟机。&lt;/p&gt;
&lt;p&gt;随着时间的推移，运维人员可以修改现有虚拟机对象以使用新的 DNS 功能。应用程序自动检测到增量并为新功能创建 DNS 记录。&lt;/p&gt;
&lt;h2 id=&#34;弃用功能&#34;&gt;弃用功能&lt;/h2&gt;
&lt;p&gt;让我们快速转到下一个 API v3。在这种情况下，我们的 API 不断发展，我们在表示 IP 地址方面已陷入僵局。&lt;/p&gt;
&lt;p&gt;在 API v1 中，我们能够通过本地 IP 指令方便地为网络接口声明一个本地 IP 地址。我们现在的任务是为虚拟机提供多种网络接口。需要注意的是，这将与最初的 API v1 冲突。&lt;/p&gt;
&lt;p&gt;让我们来看一下示例 5-3 中新的 v3 版本的 API。&lt;/p&gt;
&lt;p&gt;例 5-3. v3.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;networkInterfaces&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ip&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.11&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;dnsRecords&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ttl&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用定义多个网络接口所需的新数据结构，我们已弃用本地 IP 指令。但是我们并没有删除定义 IP 地址的概念，我们只是简单地重组了它。这意味着我们可以分两个阶段废弃该指令。首先警告，然后是拒绝。&lt;/p&gt;
&lt;p&gt;在警告阶段，我们的应用程序可能会输出不再支持本地 IP 指令的警告。应用程序可以接受在对象中定义的指令，并将旧 API v2 转换为新 API v3。&lt;/p&gt;
&lt;p&gt;转换将采用为本地 IP 定义的值，并在新网络接口指令中创建与初始值相匹配的单个块。应用程序可以继续处理 API 对象，就好像用户发送了 v3 对象而不是 v2 对象一样。预计用户会注意到该指令已被弃用，并及时更新其表示。&lt;/p&gt;
&lt;p&gt;在拒绝阶段，应用程序将彻底拒绝 v2 API。用户将被迫更新他们的 API 到更新的版本，或者甘愿在基础架构中冒此风险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;弃用是非常危险的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个极其危险的过程，成功将用户引导到新版本可能会非常困难。拒绝输入必须给出很好的理由。&lt;/p&gt;
&lt;p&gt;如果输入信息的会破坏应用程序保障，则应拒绝该信息。否则，最佳实践通常是警告并继续。&lt;/p&gt;
&lt;p&gt;破坏用户的输入很容易让运维人员感到不安和沮丧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基础架构工程师在对 API 进行版本控制时，必须对在何时弃用哪些功能做出最佳判断。此外，工程师需要花时间给出巧妙的解决方案，这些方案可以是警告或转换。在某些情况下，做到悄无声息的 API 转换对不断发展的云原生基础架构来说是一个巨大的胜利。&lt;/p&gt;
&lt;h2 id=&#34;基础架构变异&#34;&gt;基础架构变异&lt;/h2&gt;
&lt;p&gt;基础架构需要随着时间的推移而变化。这是云原生环境的本质。不仅应用程序频繁部署，而且运行基础架构的云供应商也在不断变化。&lt;/p&gt;
&lt;p&gt;基础架构的变化可以有多种形式，比如扩大或缩小基础架构，复制整个环境或消费新资源。&lt;/p&gt;
&lt;p&gt;当运维人员承担变更基础架构的任务时，我们可以看到 API 的真实价值。假设我们想要扩展环境中的虚拟机数量。不需要更改 API 版本，但对基础架构的表示做一些小的调整将很快反映出变化。就这么简单。&lt;/p&gt;
&lt;p&gt;然而，重要的是要记住，在这种情况下，运维可能是一个人，也可能是另一个软件。&lt;/p&gt;
&lt;p&gt;请记住，我们故意将 API 构造成易于被计算机解码。我们可以在 API 的两端使用该软件！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用 Operator 消费和生产 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Operater—— 构建云原生产品和平台的 CoreOS 公司创造了这个术语，即 Kubernetes 控制器，实现了软件取代人类参与管理特定应用的需求。通过协调预期状态和设定预期状态来实现。&lt;/p&gt;
&lt;p&gt;CoreOS 在他们的博客文章中这样描述 Operator：&lt;/p&gt;
&lt;p&gt;Operator 是特定应用程序的控制器，它代表 Kubernetes 用户扩展 Kubernetes API 以创建、配置和管理复杂有状态应用程序的实例。它建立在基本的 Kubernetes 资源和控制器概念的基础上，但包含一个域或特定于应用程序的知识体系以实现常见任务的自动化。&lt;/p&gt;
&lt;p&gt;该模式规定 Operator 可以通过给定声明性指令集来更改环境。Operator 是工程师应该创建的用于管理其基础架构的云原生应用程序类型的完美示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设想一个简单的情景 —— 自动调节器（autoscaler）。假设我们有一个非常简单的软件，可以检查环境中虚拟机上的平均负载。我们可以定义一个规则，只要平均负载平均值高于 0.7，我们就需要创建更多的虚拟机来均匀地分配我们的负载。&lt;/p&gt;
&lt;p&gt;Operator 的规则会随着负载平均值的增加而不再适用，最终 Operator 需要用另一台虚拟机更新基础架构 API。这样可以扩大我们的基础架构，但同样我们也可以很容易的定义另一个规则当平均负载降至 0.2 以下时缩小虚拟机规模。请注意，Operator 这个术语在这里应该是一个应用程序，而不是一个人。&lt;/p&gt;
&lt;p&gt;这是自动缩放的一个非常原始的例子，但该模式清楚地表明软件现在可以开始扮演人类运维人员的角色。&lt;/p&gt;
&lt;p&gt;有许多工具可以帮助扩展如 Kubernetes、Nomad 和 Mesos 等基础架构上的应用程序负载。这假定应用程序层运行一个编排调度器上，它将为我们管理应用程序负载。&lt;/p&gt;
&lt;p&gt;想象一下，如果多个基础架构管理应用程序使用相同的 API，那么会进一步将基础架构 API 的价值最大化。这是一个非常强大的基础架构演进模式。&lt;/p&gt;
&lt;p&gt;我们来看看相同的 API—— 记住它只有几千字节的数据，并且在两个独立的基础架构管理应用程序运行。图 5-1 显示了一个示例，两个基础架构应用程序从相同的 API 获取数据但将基础架构部署到各自独立的云环境。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/developing-infrastructure-applications/f-5-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/developing-infrastructure-applications/f-5-1.jpg&#34; data-width=&#34;1232&#34; data-height=&#34;832&#34; alt=&#34;image&#34; data-caption=&#34;图 5-1. 一个 API 被部署在两个云中&#34;&gt;
    
  
  &lt;figcaption&gt;图 5-1. 一个 API 被部署在两个云中&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该模型为基础架构工程师提供了在多个云提供商之间提供通用抽象的强大功能。现在我们可以看到应用程序如何确保 API 在多个地方代表相同的基础架构。如果基础架构 API 负责提供自己的抽象和资源调配，则基础架构不必与单个云提供商的抽象相关联。用户可以在他们选择的云中创建独特的基础架构排列。&lt;/p&gt;
&lt;h2 id=&#34;维护云提供商兼容性&#34;&gt;维护云提供商兼容性&lt;/h2&gt;
&lt;p&gt;虽然保持 API 与云提供商的兼容性将会有很多工作要做，但对于部署工作流程和供应流程时，很少需要改变。请记住，人类比技术更难改变。如果您可以保证人类的环境一致，这将抵消所需的技术开销。&lt;/p&gt;
&lt;p&gt;您还应该权衡多云兼容性的好处。如果它不是您的基础架构的需求，您可以节省大量的工作。考虑云厂商锁定时请参阅附录 B。&lt;/p&gt;
&lt;p&gt;我们也可以在同一个云中运行不同的基础架构管理应用程序。这些应用程序可能会对 API 进行不同的解释，这会导致对于运维人员的意图的定义略有不同。根据运维人员定义的基础架构的意图，在管理应用程序之间进行切换可能只是我们所需要的。图 5-2 显示了两个应用程序正在读取相同的 API 源，但在实现数据时会根据环境和需要而不同。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/developing-infrastructure-applications/f-5-2.jpg&#34; data-img=&#34;/book/cloud-native-infra/developing-infrastructure-applications/f-5-2.jpg&#34; data-width=&#34;1232&#34; data-height=&#34;836&#34; alt=&#34;image&#34; data-caption=&#34;图 5-2. 一个 API 以不同的方式部署在同一个云中&#34;&gt;
    
  
  &lt;figcaption&gt;图 5-2. 一个 API 以不同的方式部署在同一个云中&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;与基础架构 API 相比，基础架构应用的排列组合是无止境的。这为基础架构工程师提供了一个非常灵活和可扩展的解决方案，希望能够以不同的环境和方式掌握基础架构。&lt;/p&gt;
&lt;p&gt;我们为满足基础架构要求而可能构建的各种应用程序现在已成为基础架构本身的代表。这是第 3 章中定义的基础设施即软件的缩影。&lt;/p&gt;
&lt;p&gt;请务必记住，我们构建的应用程序本身就是云原生应用程序。这是一个有趣的故事，因为我们正在构建云原生应用程序来管理云原生基础架构。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>测试云原生基础架构</title>
      <link>https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/</guid>
      <description>
        
        
        &lt;p&gt;基础架构是用来支撑应用程序的。可信任的软件对于工程成功至关重要。如果每次在终端输入 ls 命令，都会发生随机动作，那么你将永远也不会相信 ls，而是去找另一种方式来列出目录中的文件。&lt;/p&gt;
&lt;p&gt;我们的基础架构必须值得信任。本章旨在建立信任和验证基础架构的意识形态。我们将描述的实践旨在增加对应用程序和基础架构工程的信心。&lt;/p&gt;
&lt;p&gt;软件测试在当今的软件工程领域非常普遍。然而，如何测试基础架构还没有很明确的最佳实践。&lt;/p&gt;
&lt;p&gt;这意味着本书中的所有章节中，这一节应该是最令人兴奋的！在该领域像您这样的工程师有充分的空间发挥出色的影响力。&lt;/p&gt;
&lt;p&gt;软件测试是一种证明软件可以正常工作的有效做法，证明软件在各种特殊情况下软件仍然可以正常运行。因此，如果我们将相同的范例应用于基础架构测试，测试目标如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明基础架构按预期运行。&lt;/li&gt;
&lt;li&gt;证明基础架构不会失败。&lt;/li&gt;
&lt;li&gt;证明这两种情况在各种边缘情况下都是正确的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;衡量基础架构是否有效需要我们先定义什么叫有效。现在，您应该对使用基础架构和工程代表应用程序的想法感到满意。&lt;/p&gt;
&lt;p&gt;定义基础架构 API 的人应该花时间构思一个可以创建有效基础架构的理智的 API。例如，如果创建了一个定义虚拟机的 API 但里面没有使之可以运行的网络信息，这种做法就很愚蠢。您应该在 API 中创建有用的抽象，然后使用第 3 章和第 4 章中提出的想法来确保 API 创建出正确的基础架构组件。&lt;/p&gt;
&lt;p&gt;我们开始开发一个心智模型，通过定义 API 对基础架构的健全性进行检查。这意味着我们可以翻转逻辑并想象出相反的情况，这将是除了原始心智模型之外的所有东西。&lt;/p&gt;
&lt;p&gt;很值得为基础架构定义基本的完整性测试。测试基础架构的第一步是证明您的基础架构是按预期存在的，并且没有任何东西的违背原意而存在。&lt;/p&gt;
&lt;p&gt;在本章中，我们将探索基础架构测试，这将为新的测试工具奠定基础。&lt;/p&gt;
&lt;h2 id=&#34;我们该测试什么&#34;&gt;我们该测试什么？&lt;/h2&gt;
&lt;p&gt;在开始编写代码之前，我们首先必须确定要测试的内容。&lt;/p&gt;
&lt;p&gt;使用测试驱动开发是测试优先的常见做法。测试是为了证明测试点而编写的，从一开始就隐含失败。软件的开发周期都需要通过测试；也就是说，软件是为了满足测试中定义的每个要求而开发的。这是一个强大的实践，可以帮助软件保持专注，帮助工程师建立对软件的信心。&lt;/p&gt;
&lt;p&gt;这是一个可以用多种方式回答的哲学问题。建立值得信赖的基础架构是必不可少的。例如，如果存在依赖基础架构的业务问题，则应该对其进行测试。更重要的是，许多业务不仅依赖基础架构，还会在出现问题时自行修复。&lt;/p&gt;
&lt;p&gt;确定基础架构需要填补的问题空间代表了将需要编写的第一轮测试。&lt;/p&gt;
&lt;p&gt;远景规划是基础架构测试的另一个重要方面，但应该谨慎。在足够的前瞻性和过度工程化之间有一条看不见的界限。如果有疑问，坚持最少量的测试逻辑。&lt;/p&gt;
&lt;p&gt;在我们完全了解需要的测试之后，就可以考虑实施测试套件。&lt;/p&gt;
&lt;h2 id=&#34;编写可测试代码&#34;&gt;编写可测试代码&lt;/h2&gt;
&lt;p&gt;调节器模式不仅旨在创建整洁的基础架构应用程序，而且还鼓励编写可测试的基础架构代码。&lt;/p&gt;
&lt;p&gt;这意味着，在应用程序的每一个重要步骤中，我们总是会重新创建一个相同类型的新对象，也就是说基础系统的每个主要组件都会使用相同的输入和输出。使用相同的输入和输出可以更轻松地以编程方式测试软件的小型组件。测试将确保您的组件按预期工作。&lt;/p&gt;
&lt;p&gt;然而，在编写基础架构测试代码时，还有许多经验值得借鉴。我们将在看看在一些虚拟情景测试基础架构的具体示例。通过浏览场景，您将学到测试基础架构代码的经验教训。&lt;/p&gt;
&lt;p&gt;我们还会给出工程师一些规则，应在编写可测试基础架构代码时遵守这些规则。&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;p&gt;采用非常基础的基础架构定义，如示例 6-1。&lt;/p&gt;
&lt;p&gt;例 6-1. infrastructure.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.1.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这些数据的目的显而易见：确保一个名为&lt;code&gt;my-vm&lt;/code&gt;的虚拟机的大小为&lt;code&gt;large&lt;/code&gt;，IP 地址为&lt;code&gt;192.168.1.111&lt;/code&gt;。这些数据也暗示确保一个名为&lt;code&gt;my-subnet&lt;/code&gt;的子网将容纳虚拟机&lt;code&gt;my-vm&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;希望您发现了这个数据的问题。虚拟机的 IP 地址超出了子网的可用 CIDR 范围。&lt;/p&gt;
&lt;p&gt;应用程序在运行此数据时应该会失败，因为虚拟机设置了无效的网络。如果将我们的应用程序构建为盲目地允许部署任何数据，那么我们将创建一个可以联网的基础架构。尽管我们应该编写测试以确保新的虚拟机能够在网络上路由，但是我们可以做一些其他事情来帮助加强我们的应用程序并使测试更加容易。&lt;/p&gt;
&lt;p&gt;在应用程序处理输入之前，我们可以首先尝试验证输入。这在软件工程中是很常见的做法。&lt;/p&gt;
&lt;p&gt;想象一下，如果不是盲目部署这个基础架构，我们首先会尝试验证输入。在运行时，应用程序可以很容易的检测到虚拟机的 IP 地址在虚拟机所连接的子网中无效。这将阻止输入到达基础架构环境。由于知道应用程序将故意拒绝无效的基础架构表示，我们可以编写 happy 和 sad 测试来确保实现此行为。&lt;/p&gt;
&lt;p&gt;Happy 测试可以对条件进行正面处理。换句话说，它是一种向应用程序发送有效 API 对象并确保应用程序接受有效输入的测试。Sad 测试，可以对相反的情况或负面情况进行分析。例 6-1 是一个 sad 测试的例子，它将一个无效的 API 对象发送给应用程序，并确保应用程序拒绝无效输入。&lt;/p&gt;
&lt;p&gt;这种新模式使测试基础架构非常快速，而且通常不用费什么力气。一个工程师就可以开发大量的 happy 和 sad 测试，即使是最奇怪的应用程序输入也是如此。此外，测试集合可以随着时间的推移而增长；在欺骗 API 对象流入环境场景中时，工程师可以快速添加测试以防止其再次发生。&lt;/p&gt;
&lt;p&gt;输入验证是测试最基本的事情之一。通过在我们的应用程序中编写简单的验证来检查理智的值，我们可以开始过滤应用程序的输入。这也给了我们一个很容易定义错误并快速返回错误的途径。&lt;/p&gt;
&lt;p&gt;验证提供信心，而不会让您等待基础架构发生变异。这为面向 API 开发的工程师创建了更快的反馈循环。&lt;/p&gt;
&lt;h3 id=&#34;输入代码库&#34;&gt;输入代码库&lt;/h3&gt;
&lt;p&gt;编写易于测试的代码非常重要。经常出错可能会导致成本上升，因此需要围绕专有输入设计应用程序。专有输入是仅与程序中的一个点相关的输入，获得所需输入的唯一方法是线性执行程序。以这种方式线性编写代码对于人类大脑来说是有意义的，但这也是有效测试的最难的模式之一，特别是当涉及到测试基础架构时。&lt;/p&gt;
&lt;p&gt;专有输入陷入困境的例子如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数 &lt;code&gt;DoSomething ()&lt;/code&gt; 的调用返回 &lt;code&gt;Something {}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Something {}&lt;/code&gt; 传递给函数 &lt;code&gt;NextStep (Something)&lt;/code&gt; 并返回 &lt;code&gt;SomethingElse {}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SomethingElse {}&lt;/code&gt; 被传递给函数 &lt;code&gt;FinalStep (something else)&lt;/code&gt;，返回 true 或 false。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的问题是，为了测试 &lt;code&gt;FinalStep ()&lt;/code&gt; 函数，我们首先需要遍历步骤 1 和 2。在测试的情况下，这会引入复杂性和更多的失败点；甚至可能不会在测试执行的环境中工作。&lt;/p&gt;
&lt;p&gt;更优雅的解决方案是以这样一种方式构造代码，即可以在程序的其余部分使用相同的数据结构上调用最后的 step ()：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码初始化 &lt;code&gt;GreatSomething {}&lt;/code&gt; 实现了方法 &lt;code&gt;great.DoSomething ()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GreatSomething {}&lt;/code&gt; 实现 &lt;code&gt;NextStep ()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GreatSomething {}&lt;/code&gt; 实现了 &lt;code&gt;something.FinalStep ()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从测试的角度来看，我们可以为我们希望测试的任何步骤填充 &lt;code&gt;GreatSomething {}&lt;/code&gt;，并相应地调用这些方法。这个例子中的方法现在负责处理它们扩展的对象中定义的内存。这与最后一种方法不同，在这种方法中，特殊的内存中的结构被传递到每个函数中。&lt;/p&gt;
&lt;p&gt;这是一种更为优雅的设计，因为测试工程师可以轻松地在整个过程中的任何一步合成内存，而不必担心学习相同数据的一种表示形式。这是更加模块化的，如果可以迅速发现任何故障，我们可以介入。&lt;/p&gt;
&lt;p&gt;当您开始编写构成应用程序的软件时，请记住，您将需要在传统的运行时间轴上的许多地方跳入代码库。构建代码以使其易于在任何时候输入代码库并在内部进行测试，这是至关重要的。在这种情况下，您可以成为自己最好的朋友，也可以成为最大的敌人。&lt;/p&gt;
&lt;h2 id=&#34;自我意识&#34;&gt;自我意识&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;告诉我你如何衡量我，我会告诉你我的行为。&lt;/p&gt;
&lt;p&gt;——Eliyahu M. Goldratt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编写代码和测试时注意自己的置信度。自我意识是软件工程中最重要的部分之一，也是最容易被忽视的部分之一。&lt;/p&gt;
&lt;p&gt;测试的最终目标是增加对应用程序的信心。就基础架构领域来说，我们的目标就是增强对基础架构的信心。&lt;/p&gt;
&lt;p&gt;测试基础架构的方法没有对错之分。可以在应用程序中通过代码覆盖率和单元测试来建立信心，但是对于基础架构来说这样做可能会存在误导。&lt;/p&gt;
&lt;p&gt;代码覆盖率是以程序化方式衡量代码可以满足预期的行为。这个度量标准可以用作原始数据点，但我们要知道即使是覆盖率达到 100％的代码库仍然可能会出现极端中断，这一点至关重要。&lt;/p&gt;
&lt;p&gt;如果你以代码覆盖率来衡量测试结果，那么工程师就会编写更容易被测试覆盖的代码，而不是编写更适应该任务的代码。Dan Ariely 在他刊登于哈弗商业评论的文章“衡量标准决定一切” ：&lt;/p&gt;
&lt;p&gt;人们的行为会根据衡量指标作出相应的调整。衡量指标会促使某个人在该指标上做出优化。你想要得到什么，就要去衡量什么。&lt;/p&gt;
&lt;p&gt;应该衡量的唯一指标是信心，即我们的基础架构可以按预期工作，并且可以证明这一点。&lt;/p&gt;
&lt;p&gt;衡量信心几乎是不可能的。但是有些方法可以从工程师的心理和情绪中抽取有意义的数据集。&lt;/p&gt;
&lt;p&gt;问自己以下几个问题，记录下答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我担心这行不通吗？&lt;/li&gt;
&lt;li&gt;我可以肯定，这将做我认为会做的事吗？&lt;/li&gt;
&lt;li&gt;如果有人更改此文件，会发生什么情况？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从问题中提取数据的最强好的方式是比较以前的经验水平。例如，工程师可以做出如下陈述，团队的其他成员很快就会明白他想要传达的内容：&lt;/p&gt;
&lt;p&gt;比起上个季度，这次代码发布更令人担忧。&lt;/p&gt;
&lt;p&gt;现在，根据团队以前的经验，我们可以开始为我们的信心水平制定一套标准，从 0 开始表示完全没有信心，随着时间的流逝然后增加到非常自信。当我们了解了我们担心应用程序的哪些问题之后，再为了增加信心而制定测试内容就很简单了。&lt;/p&gt;
&lt;h2 id=&#34;测试类型&#34;&gt;测试类型&lt;/h2&gt;
&lt;p&gt;了解测试的类型以及测试方式将有助于工程师增加其对基础架构应用程序的信心。这些测试不需要编写，而且没有正确或错误之分。唯一的问题是我们相信应用程序会做我们想要它做的事情。&lt;/p&gt;
&lt;h3 id=&#34;基础架构断言&#34;&gt;基础架构断言&lt;/h3&gt;
&lt;p&gt;在软件工程中，有一个重要的概念是断言，这是一种强制的方式 —— 完全确定条件是否成立。目前已经有许多成功的框架使用断言来测试软件。断言是一个微小的函数，它将测试条件是否为真。这些功能可以在各种测试场景中使用，以证明概念正在发挥作用和增加我们的信心。&lt;/p&gt;
&lt;p&gt;在本章的其余部分中，我们将提到基础架构断言。您需要对这些断言的内容以及他们希望完成的内容有基本的了解。您还需要对 Go 语言有基本的了解，才能充分认识这些断言是做什么的。&lt;/p&gt;
&lt;p&gt;在基础架构领域需要声明我们的基础架构有效。对于您的项目来说值得练习下使用构建这些断言功能的库。开源社区也可以从这个工具包测试基础架构中受益。&lt;/p&gt;
&lt;p&gt;例 6-2 显示了 Go 语言中的断言模式。假设我们想测试虚拟机是否可以解析公共主机名，然后路由到它们。&lt;/p&gt;
&lt;p&gt;例 6-2. assertNetwork.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localIp&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;AssertResolvesHostname&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedIp&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to query DNS for a hostname,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//and compare to the expectedIp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;AssertRouteable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;port&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to verify the virtualMachine can route
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//to a hostname on a specific port
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Connect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to connect to the virtual machine to run the assertions
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;eturn&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to close the connection to the virtual machine 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，我们将两个断言作为&lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体上的方法来存储。方法签名是我们将在此演示中关注的内容。&lt;/p&gt;
&lt;p&gt;第一种方法 AssertResolvesHostname () 演示了一种将用于检查给定主机名是否解析为预期 IP 地址的方法。第二种方法 AssertRouteable () 演示了一种用于检查给定主机名是否可在特定端口上路由的方法。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体是如何定义成员本地 IP 的。另请注意，&lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体具有 &lt;code&gt;Connect ()&lt;/code&gt; 函数以及 &lt;code&gt;Close ()&lt;/code&gt; 函数。这是因为断言框架可以在虚拟机的上下文中运行这个断言。测试可以在基础架构环境之外的系统上运行，然后连接到环境中的虚拟机以运行基础架构断言。&lt;/p&gt;
&lt;p&gt;在例 6-3 中，我们演示了工程师该如何在本地系统上编写 Go 测试。&lt;/p&gt;
&lt;p&gt;例 6-3. network_test.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TestVm&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localIp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;10.0.0.17&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Connect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to connect to VM: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AssertResolvesHostname&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com should resolve to any IP&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to resolve hostname: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AssertRouteable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com should be routable on port 443&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to route to hostname: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该示例使用 Go 语言中的内置测试标准，这意味着该函数将作为应用程序中 Go 测试的正常运行测试的一部分执行。测试框架将测试名称以&lt;code&gt;_test.go&lt;/code&gt;结尾的所有文件，并使用以&lt;code&gt;TestXxx&lt;/code&gt;开头的签名名称测试所有函数。该框架还将&lt;code&gt;* test.T&lt;/code&gt; 指针传递给以这种方式定义的每个函数。&lt;/p&gt;
&lt;p&gt;这个简单的测试将使用我们之前定义的断言库来完成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试连接到应在 10.0.0.17 上可访问的虚拟机。&lt;/li&gt;
&lt;li&gt;在虚拟机上尝试断言虚拟机可以解析 google.com 并且可返回一些 IP 地址。&lt;/li&gt;
&lt;li&gt;在虚拟机上尝试声明虚拟机可以通过端口 443 路由到 google.com。&lt;/li&gt;
&lt;li&gt;关闭与虚拟机的连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个非常强大的程序。它为我们的基础架构按预期工作建立了信心。它还引入了一个优雅的脚手架，供工程师定义测试，而不必担心它们将如何运行。&lt;/p&gt;
&lt;p&gt;开源社区迫切需要这样的基础架构测试框架。基础架构测试的标准化和可靠方法将成为开发者工具箱中的有益补充。&lt;/p&gt;
&lt;h3 id=&#34;集成integration测试&#34;&gt;集成（integration）测试&lt;/h3&gt;
&lt;p&gt;集成测试也被称为端到端（e2e）测试。这些是长期运行的测试。按照预生产的方式来运行系统，这是证明可靠性和增加信心的最有价值的测试。&lt;/p&gt;
&lt;p&gt;编写集成测试套件可能很有趣，也很有意义。在集成测试基础架构管理应用程序的情况下，测试将执行基础架构生命周期的大扫除。&lt;/p&gt;
&lt;p&gt;线性集成测试套件的一个简单例子如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个常用的基础架构 API。&lt;/li&gt;
&lt;li&gt;将数据保存到应用程序的数据存储区。&lt;/li&gt;
&lt;li&gt;运行该应用程序并创建基础架构。&lt;/li&gt;
&lt;li&gt;针对基础架构运行一系列断言。&lt;/li&gt;
&lt;li&gt;从应用程序的数据存储中删除 API 数据。&lt;/li&gt;
&lt;li&gt;确保基础架构已成功销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在此过程中的任何一步，测试都可能失败，并且测试套件应该清理发生变异的基础架构。这是测试可以按照预期销毁基础架构重要的原因之一。&lt;/p&gt;
&lt;p&gt;测试使我们相信，该应用程序将创建并销毁预期的基础架构，并按预期工作。随着时间的推移，我们可以增加步骤 4 中运行的断言的数量，并继续强化套件。&lt;/p&gt;
&lt;p&gt;集成测试工具可能是测试基础架构最强大的环境。没有集成测试工具，运行像单元测试这样的小测试就没有多大价值。&lt;/p&gt;
&lt;h3 id=&#34;单元unit测试&#34;&gt;单元（unit）测试&lt;/h3&gt;
&lt;p&gt;单元测试是测试系统并单独运行其组件的基本部分。单元测试的责任是小而谨慎。单元测试是软件工程中的常见做法，因此将成为基础架构工程的一部分。&lt;/p&gt;
&lt;p&gt;在编写基础架构测试的情况下，测试系统的一个组件是困难的。基础架构的大多数组件都建立在彼此的基础之上。相应地测试软件通常需要改变基础架构来测试并查看其是否工作。这个过程通常涉及大部分系统。&lt;/p&gt;
&lt;p&gt;但这并不意味着为基础架构管理系统编写单元测试是不可能的。事实上，前面例子中定义的大部分断言在技术上将都是单元测试！单元测试只测试一个小组件，但在大型集成测试系统环境中使用时，它们可能非常有用。&lt;/p&gt;
&lt;p&gt;在测试基础架构时鼓励进行单元测试，但请记住，它们运行的上下文通常需要相当大的开销。这种开销通常以集成测试的形式出现。将单元测试的小而谨慎的检查与更大的整体测试模式相结合，使基础架构工程师对其基础架构按照预期工作具有高度的信心。&lt;/p&gt;
&lt;h3 id=&#34;模拟mock测试&#34;&gt;模拟（Mock）测试&lt;/h3&gt;
&lt;p&gt;在软件工程中，综合系统的常见做法是模拟测试。在模拟测试中，工程师编写或使用旨在欺骗或伪造系统的软件。&lt;/p&gt;
&lt;p&gt;一个简单的例子就是使用一个旨在与 API 通信并以“mock”模式运行的 SDK。SDK 不会将任何数据发送到 API，而是合成 SDK 认为 API 在各种情况下应该执行的操作。&lt;/p&gt;
&lt;p&gt;确保模拟软件准确地反映它正在合成的系统的责任在于开发模拟软件的工程师手中。在某些情况下，模拟软件也是由开发其正在模拟的系统的工程师开发的。&lt;/p&gt;
&lt;p&gt;尽管可能有一些模拟工具保持最新并且比其他工具更稳定，但使用模拟系统合成您计划测试的基础架构时存在一个普遍的道理：虚假系统只会给您带来虚假信心。&lt;/p&gt;
&lt;p&gt;现在，这条规则可能看起来很苛刻。但它的目的是鼓励工程师不要轻易走出去，并通过构建真正的集成套件来运行测试的实践。虽然模拟系统功能强大，但将它作为基础架构测试的核心（因此也是您的信心）是非常危险的。&lt;/p&gt;
&lt;p&gt;大多数公有云提供商对其资源实施配额限制。想象一下与一个对资源有严格限制的系统进行交互的测试。模拟系统可能会尽最大努力限制资源，但是如果不在运行时审核实际系统，模拟系统将无法确定您的基础架构是否实际部署。在这种情况下，您的模拟测试会成功。但是，当代码在真实环境中运行时，它会中断。&lt;/p&gt;
&lt;p&gt;这只是许多实例中的一个例子，这些实例证明了为什么变异实际基础架构和发送实际网络数据包比使用模拟系统更可靠。请记住，测试的目标是增强您的基础架构在真实环境中按照预期工作的信心。&lt;/p&gt;
&lt;p&gt;这并不是说所有的模拟测试都不好。了解模拟正在测试的基础架构与为了方便而模拟另一部分系统之间的差异非常重要。&lt;/p&gt;
&lt;p&gt;工程师需要决定什么时候适合使用模拟系统。我们只是告诫工程师不要对这些系统有太大的信心。&lt;/p&gt;
&lt;h3 id=&#34;混沌chaos测试&#34;&gt;混沌（chaos）测试&lt;/h3&gt;
&lt;p&gt;混沌测试可能是本书中介绍的所有测试基础架构的方法中中最令人兴奋。混沌测试证明在基础架构中发生不可预知的事件时不会影响基础架构的稳定性。我们通过故意破坏基础架构并衡量系统如何应对灾难来做此演示。与其他的所有测试一样，我们将以基础架构工程师的身份来应对这个问题。&lt;/p&gt;
&lt;p&gt;我们将编写旨在以意想不到的方式打破生产系统的软件。建立对系统的信心的一部分是理解它们如何以及为什么会破坏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google 如何建立信心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习如何破解系统的例子可以在谷歌的 DiRT（灾难恢复培训）计划中看到。该计划旨在帮助 Google 的 SRE 熟悉他们所支持的系统。在站点可靠性工程中，他们解释说，DiRT 计划的目的是因为“长时间与生产脱节可能会导致信心问题，不管是过于自信还是不自信，该计划仅仅是为了发现当事件发生时的认知差距“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不幸的是，如果没有系统来衡量影响并从灾难中恢复过来，就不会让工程团队感觉释然。再次，我们将要求运行本章前面定义的基础结构断言。微小的单一责任功能为测量系统随时间的稳定性提供了绝佳的数据点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测量混沌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一下例 6-3 中的 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 函数。想象一下，我们有一个服务，将连接到虚拟机，并尝试保持连接打开。服务每秒都会调用 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 函数并记录结果。来自此服务的数据是虚拟机在其网络上路由的能力的准确表示。只要虚拟机可以路由，数据就会在图形上产生一条直线，如图 6-1 所示。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-1.jpg&#34; data-width=&#34;1234&#34; data-height=&#34;480&#34; alt=&#34;image&#34; data-caption=&#34;图 6-1. 随着时间推移的 AssertRoutable 测试图&#34;&gt;
    
  
  &lt;figcaption&gt;图 6-1. 随着时间推移的 AssertRoutable 测试图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果在任何时候连接断开或者虚拟机不再能够路由，那么图形数据会发生变化，并且我们会看到图形上的线条发生变化。随着基础架构自行修复，线路开启该图将再次稳定下来，如图 6-2 所示。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-2.jpg&#34; data-img=&#34;/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-2.jpg&#34; data-width=&#34;1232&#34; data-height=&#34;482&#34; alt=&#34;image&#34; data-caption=&#34;图 6-2. 失败并且随着时间的推移修复 AssertRoutable 测试&#34;&gt;
    
  
  &lt;figcaption&gt;图 6-2. 失败并且随着时间的推移修复 AssertRoutable 测试&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里考虑的重要方面是时间。随着时间的推移，测量混乱将伴随着混沌的测量。&lt;/p&gt;
&lt;p&gt;我们可以快速扩展测量。想象一下，名为 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 的服务现在正在虚拟机上调用一组 100 个基础结构断言。另外，假设我们有 100 台虚拟机正在测量。&lt;/p&gt;
&lt;p&gt;这将对我们的基础架构产生大约每秒 1.0×10&lt;sup&gt;4&lt;/sup&gt; 个断言。来自我们的基础架构断言的大量数据使我们能够创建强大的图形表示基础架构。以可查询的格式记录数据也可以进行高级混沌调查。&lt;/p&gt;
&lt;p&gt;随着混沌的测量，拥有可靠的测量工具和服务非常重要。以有意义的方式存储来自服务的数据也很重要，以便稍后可以引用它们。强烈建议将数据存储在日志聚合器或其他容易索引的数据存储中。&lt;/p&gt;
&lt;p&gt;系统的混乱与系统的可靠性成反比。因此，它直接反映了我们正在评估的基础架构的稳定性。这意味着，当事情发生中断或引入变化时，将信息随时间绘制成分析是非常有价值的，以了解是否降低了稳定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入混沌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将混沌引入系统的另一种说法：“故意破坏系统”。我们希望总结出我们可能在野外看到的意想不到的基础架构问题组合。如果我们不会故意注入混沌，那么云提供商、互联网或某个系统会为我们做这件事。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Netflix 的猿猴军队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Netflix 推出了它称之为猿猴军队（Simian Army）的系统，导致其混乱。猴子、猿猴以及猿猴家族的其他动物都以不同的方式造成混乱。Netflix 解释了这些工具之一 Chaos Monkey 的工作原理：&lt;/p&gt;
&lt;p&gt;构建 Chaos Monkey 是我们的哲学，它是随机禁用我们的生产实例以确保我们能够在没有任何客户影响的情况下经受这种常见故障的工具。这个名字来自于在数据中心（或云区域）用武器释放野猴以随机击落实例并通过电缆咀嚼的想法 —— 这一切都是在我们不间断的继续为客户提供服务的同时进行。通过在工作日运行 Chaos Monkey，在受到严密监控的环境中，工程师站在一边解决问题，我们仍然可以学习有关系统弱点的教训，并构建自动恢复机制来处理这些问题。所以下一次星期天上午 3 点有一个实例失败的时候，我们甚至不会注意到。&lt;/p&gt;
&lt;p&gt;就云原生基础架构而言，Monkey 是基础架构作为软件和利用协调模式的很好例子。主要区别在于它们旨在以意想不到的方式摧毁基础架构，而不是可预测地创建和管理基础架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，您应该有一个准备好使用的基础架构管理应用程序，或者至少有一个。用于部署，管理和稳定基础架构的基础架构管理应用程序也可用于引入混乱。&lt;/p&gt;
&lt;p&gt;想象一下两个非常相似的部署。&lt;/p&gt;
&lt;p&gt;第一个示例 6-4 代表有效（或 happy）基础架构。&lt;/p&gt;
&lt;p&gt;例 6-4. infrastructure_happy.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.17&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使在环境中设置的方式来部署此基础架构。这个基础架构应该部署且运行稳定。就像以前一样，随着时间的推移记录您的基础架构测试非常重要；图 6-3 就是一个例子。理想情况下，您运行的测试数量应该随着时间的推移而增加。&lt;/p&gt;
&lt;p&gt;我们决定引入混乱。因此，我们创建了原始基础架构管理应用程序的副本，但这次我们采取了更加险恶的方式部署基础架构。我们利用我们的部署工具的能力来审计基础架构，并对已经存在的基础架构进行更改。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-3.jpg&#34; data-img=&#34;/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-3.jpg&#34; data-width=&#34;1234&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;图 6-3. 成功的测试&#34;&gt;
    
  
  &lt;figcaption&gt;图 6-3. 成功的测试&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二次部署将代表有意故障的基础架构，并仍使用与原始基础架构相同的标识符（名称）。基础架构管理工具将检测现有基础架构并进行更改。在第二个示例（示例 6-5）中，我们将虚拟机大小更改为较小，并且意图将虚拟机的静态 IP 地址 192.168.1.111 分配到 10.0.100.0/24 范围之外。&lt;/p&gt;
&lt;p&gt;我们知道虚拟机上的工作负载不会在小型虚拟机上运行，并且我们知道虚拟机将无法在网络上路由。这是我们将要介绍的混乱情况。&lt;/p&gt;
&lt;p&gt;例 6-5. infrastructure_sad.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;small&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.1.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于第二个基础架构管理应用程序默默地对基础架构进行了更改，因此我们可以预料会看到事态发展。我们图中的数据将开始波动，如图 6-4 所示。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-4.jpg&#34; data-img=&#34;/book/cloud-native-infra/testing-cloud-native-infrastructure/f-6-4.jpg&#34; data-width=&#34;1234&#34; data-height=&#34;654&#34; alt=&#34;image&#34; data-caption=&#34;图 6-4. 包含网络故障的图形&#34;&gt;
    
  
  &lt;figcaption&gt;图 6-4. 包含网络故障的图形&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果虚拟机上的任何应用程序未完全中断，则应该缓慢地失败。虚拟机的内存和 CPU 现在已经过载。该 shell 无法 fork 新进程。负载平均值远高于 20。系统正在接近死锁，我们甚至无法访问虚拟机来查看错误，因为没有任何方式可以路由到冒名顶替者的 IP 地址。&lt;/p&gt;
&lt;p&gt;正如预期的那样，初始系统将检测到底层基础架构中的某些内容发生了变化，并会相应地进行调整。冒名顶替者系统脱机是非常重要的，否则两个系统之间可能会有永无休止的和解，而这两者将会按照指示的方式相互竞争以纠正基础架构。&lt;/p&gt;
&lt;p&gt;这种引入混沌的方法之美在于，我们不需要开发任何额外的工具或花费任何工程时间编写混沌框架。我们以巧妙的方式滥用了原有的基础架构管理工具，引发了一场灾难。&lt;/p&gt;
&lt;p&gt;当然，这可能并不总是一个完美的解决方案。与您的生产基础架构应用程序不同，您的混沌应用程序应该有一定的限制，以确保它们有益。一些常见的限制是能够根据标签或元数据排除某些系统，不能在非工作时间运行混沌测试，并将混沌限制在特定的百分比或系统类型。&lt;/p&gt;
&lt;p&gt;现在引入随机混沌的主要负担在于基础架构工程师随着时间推移而随机化探索的工作流程的能力。当然，基础架构工程师还需要确保从实验中收集的数据以可消化的格式提供。&lt;/p&gt;
&lt;h2 id=&#34;监控基础架构&#34;&gt;监控基础架构&lt;/h2&gt;
&lt;p&gt;除了测试基础架构外，我们不能忘记监控正在运行的系统。测试和熟悉的失败模式可以让您对基础架构充满信心，但要测试系统可能出现的所有故障是不可能的。&lt;/p&gt;
&lt;p&gt;监测可以检测到的，在测试期间未识别的异常并执行正确的操作是非常重要的。通过积极监控站点基础架构还可以增强我们的信心，即当发生的事情认为是不“正常”时，我们会收到警报。明确什么时候以及如何提醒人类这些异常是一个很有争议的话题。&lt;/p&gt;
&lt;p&gt;在云原生环境中监控基础架构的实践中涌现出许多优秀的资源。我们不会在这里讨论这些主题，但您应该先阅读 Rob Ewaschuk 的“监控分布式系统：Google 的 SRE 团队的案例研究”（O’Reilly），并观看 MonitoramaConference 上的视频。两者都可以在线免费观看。&lt;/p&gt;
&lt;p&gt;无论您实施哪种监控解决方案，都要记住用云原生方法来创建您的监控规则。规则应声明并存储为代码。监控规则应与您的应用程序代码放在一起，并以自助服务的方式提供。当测试和遥测可能满足您的大部分需求时，不要过度补偿监控。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;测试可以将强我们对基础架构的信心，我们所支持的应用程序也获得了信心和信任。如果一个测试套件不能提供信心，它的价值应该是有问题的。记住，本章中提出的工具和模式是出发点，旨在激发和吸引在这个领域中工作的工程师。无论测试类型或运行它们的框架如何，最重要的一点是工程师可以开始相信他们的系统。作为工程师，我们通常会通过观察实践证明事情按预期工作的动手演示获得信心。&lt;/p&gt;
&lt;p&gt;而且，在生产中进行实验不仅是可以的，而且是值得鼓励的。您需要确保环境是为了进行这种实验而建立的，并且实施了适当的跟踪，以便不会浪费测试！&lt;/p&gt;
&lt;p&gt;现实测量是基础架构开发和测试的重要组成部分。能够从工程角度和运营角度来封装现实是运用基础架构的重要组成部分，因此可以确信它能够按预期运行。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>管理云原生应用程序</title>
      <link>https://jimmysong.io/book/cloud-native-infra/managing-cloud-native-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/managing-cloud-native-applications/</guid>
      <description>
        
        
        &lt;p&gt;云原生应用程序依赖基础架构才能运行，反过来说，云原生基础架构也需要云原生应用程序来维持。&lt;/p&gt;
&lt;p&gt;对于传统基础架构，维护和升级基本上都是由人工完成。可能是在单机上手动运行服务或使用自动化工具定义基础结构和应用程序的快照。&lt;/p&gt;
&lt;p&gt;但是，如果基础架构可以由应用程序管理，同时基础架构又可以管理应用程序，那么基础架构工具就会成为另一种应用程序。工程师对于基础架构的责任可以用调解器模式表示，内置于该基础架构上运行的应用程序中。&lt;/p&gt;
&lt;p&gt;我们花了三章来说明如何构建可以管理基础架构的应用程序。本章将介绍如何在基础架构上运行云原生应用或其它任何应用。&lt;/p&gt;
&lt;p&gt;如前所述，保持基础架构和应用程序的简单非常重要。解决应用程序复杂性最常用的方法就是把应用程序分解成小的，易于理解的组件。通常通过创建单一职责的服务来实现，或者将代码分解为一系列事件触发的函数。&lt;/p&gt;
&lt;p&gt;随着小型、可部署单元的扩容成多份即使是最自动化的基础架构也可能被压垮。管理大量应用程序的唯一方法是让它们承担第 1 章中所述的功能性操作。应用程序需要在可以按规模管理之前变成原生云。&lt;/p&gt;
&lt;p&gt;学习完本章不会帮助您建下一个伟大的应用程序，但您将了解一些基础知识，这块可以让您的应用程序在云原生基础架构是良好运行。&lt;/p&gt;
&lt;h2 id=&#34;应用程序设计&#34;&gt;应用程序设计&lt;/h2&gt;
&lt;p&gt;已经有很多教您如何构建应用程序的书了，本书不打算再讨论。但是，了解应用程序架构如何影响基础架构设计仍然很重要。&lt;/p&gt;
&lt;p&gt;正如我们在第 1 章中讨论的那样，我们假设应用程序设计成云原生的，这样可以从云原生基础架构中获得最大收益。云原生的本质是应用程序由软件而不是人类来管理。&lt;/p&gt;
&lt;p&gt;应用程序的设计和打包方式是分开考虑的。应用程序可以是云原生的，打包为 RPM 或 DEB 文件，可以部署到虚拟机而不是容器。它们可以是单体应用或微服务，可以用 Java 或 Go 编写。&lt;/p&gt;
&lt;p&gt;这些实现细节不影响应用程序被设计成在云上运行。&lt;/p&gt;
&lt;p&gt;假设我们有一个用 Go 编写的应用程序，使用容器打包，运行在 Kubernetes 上，视为微服务运行。&lt;/p&gt;
&lt;p&gt;我们假想的这个应用是“云原生”的吗？&lt;/p&gt;
&lt;p&gt;如果应用程序将所有活动日志记录到文件，还硬编码数据库 IP 地址呢？也许它不接受运行时配置并将状态存储在本地磁盘上。如果它不以可预见的方式存在或挂起并等待人工调试呢？&lt;/p&gt;
&lt;p&gt;这个应用所选择的语言和打包方式，可能会让您觉的它是云原生的，但实际上它根本不是。像 Kubernetes 这样的框架可以通过各种功能来管理这个应用，但即使它可以运行，但还是需要人类来维护。&lt;/p&gt;
&lt;p&gt;第 1 章详细介绍了使应用程序在云原生基础架构上运行得更好的一些特点。如果我们具有第 1 章中规定的特点，应用程序还有另一个考虑因素：我们如何有效地管理它们？&lt;/p&gt;
&lt;h2 id=&#34;实施云原生模式&#34;&gt;实施云原生模式&lt;/h2&gt;
&lt;p&gt;诸如弹性伸缩、服务发现、配置、日志、健康检查和相关监控指标等功能都可以以不同方式在应用程序中实现。实现这些功能的常见做法是通过导入实现相关功能的标准语言库。Netflix OSS 和 Twitter 的 Finagle 是在 Java 语言库中实现这些功能的很好的例子。&lt;/p&gt;
&lt;p&gt;应用程序可以导入和使用库，自动获得库中提供许多相关的功能，无需额外的代码。当一个组织内支持的语言很少时，这种模式很有意义。这种模式很容易实现最佳实践。&lt;/p&gt;
&lt;p&gt;当组织开始实施微服务时，它们往往倾向于使用多语言服务。这样可以自由地为不同的服务选择正确的语言，但是很难为每种语言维护库。&lt;/p&gt;
&lt;p&gt;获得该功能的另一种方法是通过所谓的 &amp;ldquo;Sidecar&amp;rdquo; 模式。此模式应用程序本身与实现管理功能的应用程序绑定在一起。通常作为单独的容器来实现，但也可以通过在虚拟机上运行另一个守护进程来实现。&lt;/p&gt;
&lt;p&gt;Sidecar 的例子包括以下内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Envoy 代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为服务增加弹性伸缩和监控指标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过外部服务发现注册服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;订阅配置更改并通知服务进程重新加载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供用于检查应用程序运行状况的 HTTP 端点 (Endpoints)&lt;/p&gt;
&lt;p&gt;Sidecar 容器还可以用来适配 Polyglot 容器，通过暴露特定于语言的端点与使用库的应用程序进行交互。来自 Netflix 的 Prana 正是为那些不使用标准 Java 库的应用程序而定制的。&lt;/p&gt;
&lt;p&gt;当有团队集中管理特定的 Sidecar 进程时，Sidecar 模式很有意义。如果工程师想要在它们的服务中暴露监控指标，它们可以将其构建到应用程序中，或者一个单独的团队也可以提供处理日志记录输出并公开计算出的监控指标的 Sidecar 应用。&lt;/p&gt;
&lt;p&gt;在这两种情况下，都可以在不修改应用程序的情况下为应用添加功能。在可以使用软件管理应用程序后，我们来看看如何管理应用程序的生命周期。&lt;/p&gt;
&lt;h2 id=&#34;应用程序生命周期&#34;&gt;应用程序生命周期&lt;/h2&gt;
&lt;p&gt;云原生应用程序除了生命周期应该由软件管理以外，其生命周期本身与传统应用程序并没有什么不同。&lt;/p&gt;
&lt;p&gt;本章不打算解释管理应用程序时涉及的所有模式和选项。我们将简要讨论几个阶段，在云原生基础架构之上运行云原生应用，这几个阶段受益程度最高：部署、运行和下线。&lt;/p&gt;
&lt;p&gt;这些主题并不都包含所有选项，但还有很多其他书籍和文章可供参考，这取决于应用程序的架构，语言和所选库。&lt;/p&gt;
&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;
&lt;p&gt;部署是应用程序最依赖基础架构的一个领域。虽然没有什么东西会阻止应用程序自行部署，但基础架构管理还可以管理更多的方面。&lt;/p&gt;
&lt;p&gt;本文不会涉及集成和交付，但是在这个领域的一些做法很明确。应用程序部署不仅仅是获取和运行代码。&lt;/p&gt;
&lt;p&gt;云原生应用程序旨在由软件管理应用生命周期的各个阶段。这包括周期性的健康检查和部署初始化。应尽可能地消除技术、流程和策略中人为造成的瓶颈。&lt;/p&gt;
&lt;p&gt;应用程序的部署首先应该是自动、自助的，如果应用正在活跃开发中，则应该是被频繁触发的。也应该可以被测试、验证可稳定运行。&lt;/p&gt;
&lt;p&gt;新版本和新功能的发布时很少会有一次性替换应用程序的所有实例的情况。新功能在配置标志成 &amp;ldquo;gated&amp;rdquo;，可以在不重启应用的情况下选择性地动态启用新功能。版本升级部分发布，通过测试进行验证，并在所有测试通过时以受控方式发布。&lt;/p&gt;
&lt;p&gt;当启用新功能或部署新版本时，应该存在控制流向或隔离应用流量的机制（请参阅附录 A）。通过缓慢的部署和更快的应用性能反馈循环进行新功能的试用，可以限制中断带来的影响。&lt;/p&gt;
&lt;p&gt;基础架构应负责部署软件的所有细节。工程师可以定义应用程序版本，基础架构要求和依赖关系，并且基础架构将朝着该状态发展，直至满足所有要求或需求更改。&lt;/p&gt;
&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;
&lt;p&gt;运行应用程序应该是应用程序生命周期中最平稳最稳定的阶段。运行软件最重要的两个的方面在第 1 章中讨论：了解应用程序在做什么以及可操作性即可以根据需要更改应用程序。&lt;/p&gt;
&lt;p&gt;我们已经在第 1 章中详细介绍了关于应用报告健康和遥测数据的可观测性，但是当事情不按预期工作时，你会做什么？如果应用程序的遥测数据显示它不符合 SLO，那么如何解决和调试应用程序？&lt;/p&gt;
&lt;p&gt;对于云原生应用程序，你不应该通过 SSH 连接到服务器的形式查看日志。如果你需要 SSH，更应该考虑使用日志或其它的服务替代。&lt;/p&gt;
&lt;p&gt;你仍然需要访问应用程序（API）和日志数据（云日志记录）以及获取在堆栈中的服务，但这值得通过演练来查看是否需要传统工具。当事件中断时，你需要一个调试应用程序和基础架构组件的方法。&lt;/p&gt;
&lt;p&gt;在做系统调试时，你应该首先查看你的基础架构测试，如第 5 章所述。测试应公开所有未正确配置或未提供预期性能的基础架构组件。&lt;/p&gt;
&lt;p&gt;不能说因为你不管理底层基础架构就意味着基础架构不可能出问题。通过测试来验证期望值将确保你的基础架构能够以你期望的方式运行。&lt;/p&gt;
&lt;p&gt;在排除基础架构后，你应该查看应用程序以获取更多信息。应用程序调试的最佳位置是应用性能管理（APM）以及可能通过 OpenTracing 等标准进行的分布式应用程序跟踪。&lt;/p&gt;
&lt;p&gt;OpenTracing 示例、实现和 APM 不在本书的范围之内。总而言之，OpenTracing 允许你在整个应用程序中跟踪调用，以更轻松地识别网络和应用程序通信问题。OpenTracing 的示例可视化可以在图 7-1 中看到。APM 为你的应用程序添加了用于向收集服务报告指标和故障的工具。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/managing-cloud-native-applications/f-7-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/managing-cloud-native-applications/f-7-1.jpg&#34; data-width=&#34;1232&#34; data-height=&#34;600&#34; alt=&#34;image&#34; data-caption=&#34;图 7-1. OpenTracing 可视化&#34;&gt;
    
  
  &lt;figcaption&gt;图 7-1. OpenTracing 可视化&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当测试和跟踪仍然没有暴露出问题时，有时你只需要在应用程序上启用更详细的日志记录。但是，如何在不破坏问题的情况下启用调试？&lt;/p&gt;
&lt;p&gt;运行时配置对于应用程序很重要，但在云原生环境中，无须重启应用程序，配置就应该是动态的。配置选项仍然通过应用程序中的库实现，但标志值应该能够通过集中协调器，应用程序 API 调用，HTTP 协议 Header 或多种方式进行动态更改。&lt;/p&gt;
&lt;p&gt;Netflix 的 Archaius 和 Facebook 的 GateKeeper 是动态配置的两个例子。前 Facebook 工程师经理 Justin Mitchell 在 Quora 的帖子中分享到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GateKeeper 是从代码部署中解耦出来的功能。我们可以在几天或几周内发布新功能，因为我们观察了用户指标、性能并确保服务可以随时扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;允许对应用程序配置进行动态控制，可以实现更多对曝光过度的新功能的控制并更好地测试已部署代码的覆盖范围。可以很容易的发布新代码并不意味着这是适合所有情况的正确解决方案。&lt;/p&gt;
&lt;p&gt;基础架构可以帮助解决此问题，并通过协调何时启用新功能和基于高级网络策略的路由控制来启用更灵活的应用程序。这种模式还允许更细粒度的控制和更好的协调发布或回滚场景。&lt;/p&gt;
&lt;p&gt;在动态的自助服务环境中，部署的应用程序数量将快速增长。你需要确保有一个简单的方法来动态调试应用类似自助服务模型中部署的应用。&lt;/p&gt;
&lt;p&gt;工程师喜欢发布新应用程序一样，反过来很难让它们下线旧应用程序。即使如此，旧应用下线仍然是应用程序生命周期中的关键阶段。&lt;/p&gt;
&lt;h3 id=&#34;下线&#34;&gt;下线&lt;/h3&gt;
&lt;p&gt;部署新的应用程序和服务在快速迭代的环境中很常见。下线应用程序应该像创建应用一样自动化。&lt;/p&gt;
&lt;p&gt;如果新的服务和资源被自动化部署与监控，则它们应该按照相同标准下线。尽快部署新服务而不删除未使用的服务是应对技术债务的最简单方法。&lt;/p&gt;
&lt;p&gt;识别应该下线的服务和资源，这是一个特定的业务。你可以使用应用程序遥测的经验数据来了解某个应用程序是否正在被使用，但是下线应用程序的决定应由该业务决定。&lt;/p&gt;
&lt;p&gt;基础架构组件（例如，VM 实例和负载均衡器端点）应在不需要时被自动清理。自动化组件清理的一个例子是 Netflix 的 Janitor Monkey。该公司在一篇博文中解释道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Janitor Monkey 通过应用一组规则来决定资源是否应该成为候选的清理内容。如果任何规则确定该资源是被清理的候选内容，则 Janitor Monkey 标记该资源并安排清理时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有这些应用阶段的目标是让基础架构和软件来管理原本由人类管理的方面。我们采用协调模式与组件元数据相结合的方式来不断运行，并根据当前上下文对需要采取的高层次操作做出决策。以此来取代由人类编写的临时自动化脚本。&lt;/p&gt;
&lt;p&gt;应用程序的生命周期不是唯一一个需要依赖于基础架构的阶段。还有一些每个阶段都要依赖于基础架构服务的程序。我们将在下一节讨论一些提供给这类应用的支持服务和基础架构 API。&lt;/p&gt;
&lt;h2 id=&#34;对运行于基础架构上的应用的要求&#34;&gt;对运行于基础架构上的应用的要求&lt;/h2&gt;
&lt;p&gt;云原生应用程序对基础架构的期望不仅只是执行二进制文件，它们还需要抽象、隔离与保证应用程序运行和管理。对于应用程序来说，需要提供 hook 和 API 以允许基础架构管理它们。为了实现这种模式，两者就需要有一种共生关系。&lt;/p&gt;
&lt;p&gt;我们在第 1 章中定义了云原生应用程序，并刚刚讨论了一些生命周期的要求。现在让我们看看云原生应用程序对从运行它们的基础架构建设的更多期望：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行与隔离&lt;/li&gt;
&lt;li&gt;资源分配和调度&lt;/li&gt;
&lt;li&gt;环境隔离&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;状态管理&lt;/li&gt;
&lt;li&gt;监控和记录&lt;/li&gt;
&lt;li&gt;监控指标聚合&lt;/li&gt;
&lt;li&gt;调试和跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些期望都应该是服务的默认选项，或者是由自助 API 提供。我们将更详细地解释每个要求，以确保这些期望被明确的定义。&lt;/p&gt;
&lt;h3 id=&#34;应用程序运行和隔离&#34;&gt;应用程序运行和隔离&lt;/h3&gt;
&lt;p&gt;除了有时候需要的解释器，传统应用程序只需要一个内核就可以运行。云原生应用仍然需要它们，但云原生应用运行时同样也需要与操作系统和其他应用程序隔离。隔离使多个应用能够在同一台服务器上运行并控制它们的依赖和资源。&lt;/p&gt;
&lt;p&gt;应用隔离有时被称为多租户。该术语可用于在同一服务器上运行的多个应用程序以及在共享集群中运行应用程序的多个用户。用户可以运行经过验证的可信代码，也可以运行你不能控制且不信任的代码。&lt;/p&gt;
&lt;p&gt;云原生不意味着需要使用容器。Netflix 率先推出了许多云原生模式，当他们从原来的方式过渡到在公有云上运行时，使用虚拟机作为它们的部署工具，而不是容器。FaaS 服务（例如 AWS Lambda）是用于打包和部署代码的另一种流行的云原生技术。在大多数情况下，它们使用容器进行应用程序隔离，但容器包装对用户是不可见的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是容器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器有很多不同的实现。Docker 推广了术语“容器”来描述一种在隔离的环境中打包和运行应用程序的方式。基本上，容器使用内核原语或硬件功能来隔离单个操作系统上的进程。&lt;/p&gt;
&lt;p&gt;容器隔离级别可能会有所不同，但通常这意味着应用程序使用独立的根文件系统、命名空间以及来自同一服务器上其他进程的资源分配（例如，CPU 和 RAM）运行。容器格式已被许多项目采用，并创建了开放容器计划（OCI），该计划定义了如何打包和运行应用程序容器的标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器隔离还会给编写应用程序的工程师造成负担。它们现在负责声明所有的软件依赖关系。如果它们没做到这点，应用程序将无法运行，因为必要的库将不可用。&lt;/p&gt;
&lt;p&gt;容器经常被选中来用于云原生应用程序，因为已经出现了更好的用于管理它们流程和编排的工具。虽然容器是实现运行时和资源隔离的最简单方式，但这并不总是（并且也可能不会）如此。&lt;/p&gt;
&lt;h3 id=&#34;资源分配和调度&#34;&gt;资源分配和调度&lt;/h3&gt;
&lt;p&gt;从历史上看，应用程序可以提供最低系统要求的粗略估计，人类有责任确定应用程序在满足什么需求下可以运行。人工调度可能需要很长时间才能准备好应用程序运行的操作系统和依赖项。&lt;/p&gt;
&lt;p&gt;部署可以通过配置管理实现自动化，但在运行应用程序时，仍然需要人员验证资源并标记服务器。云原生基础架构基于依赖隔离，允许应用程序在任何有资源的地方运行。&lt;/p&gt;
&lt;p&gt;通过隔离，只要系统有可用的进程，存储和可访问的依赖，应用程序就可以在任何地方被调度。动态调度通过将决策留给机器更好地消除了人为瓶颈。集群调度程序从所有系统收集资源信息并计算出应用程序的最佳位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人为控制应用程序不能很好的伸缩。当人生病、休假（或至少它们应该），通常会带来瓶颈。随着规模和复杂性的增加，人们也不可能清楚地记住应用程序在哪里运行。&lt;/p&gt;
&lt;p&gt;许多公司试图通过招聘更多人来扩大规模。这加剧了系统的复杂性，因为调度需要在多个人之间进行协调。最终，人为调度将采用电子表格（或类似的解决方案）来保存每个应用程序的运行位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态调度并不意味着运维人员无法控制。基于调度器可能没有的知识，运维人员仍然可以覆盖或强制进行调度决策。覆盖和手动资源调度应通过 API 提供，而不是会议请求。&lt;/p&gt;
&lt;p&gt;解决这些问题是 Google 编写名为 Borg 的内部集群调度程序的主要原因之一。在 Borg 的研究报告中，谷歌指出 Borg 提供了三大好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它隐藏了资源管理和失败处理的细节，因此用户可以专注于应用程序开发；&lt;/li&gt;
&lt;li&gt;以非常高的可靠性和可用性运行，并支持相同的应用程序；&lt;/li&gt;
&lt;li&gt;让我们可以有效地在数以万计的机器上运行工作负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调度程序在任何云原生环境中的角色都非常相似。从根本上说，它需要抽象出许多机器并允许用户而不是服务器请求资源。&lt;/p&gt;
&lt;h3 id=&#34;环境隔离&#34;&gt;环境隔离&lt;/h3&gt;
&lt;p&gt;当应用程序由许多服务组成时，基础架构就需要提供一种方法来定义所有依赖的隔离。传统的方法是通过将复杂的服务器，网络或集群隔离成开发或测试环境来管理依赖关系。基础架构应能够通过应用程序环境在逻辑上分离依赖关系，而不会完全复制集群。&lt;/p&gt;
&lt;p&gt;逻辑分割环境可以更好地利用硬件，减少重复的自动化，并且更容易测试应用程序。在某些情况下，需要单独的测试环境（例如，需要进行底层更改时）。但是，应用程序测试应该在完全复制的基础架构下进行。&lt;/p&gt;
&lt;p&gt;环境可以是传统的永久性开发、测试、预发和生产，也可以是动态分支或基于提交（commit）。它们甚至可以是生产环境的一部分，通过动态配置和实例的选择性路由启用功能。&lt;/p&gt;
&lt;p&gt;环境应有应用程序所需的所有数据，服务和网络资源组成。这包括诸如数据库，文件共享和任何外部服务之类的东西。云原生基础架构可以创建低开销的环境。&lt;/p&gt;
&lt;p&gt;基础架构应该能够提供环境和被使用。应用程序应遵循最佳实践，允许灵活配置以支持环境，并通过服务发现发现支持服务的端点。&lt;/p&gt;
&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;应用程序几乎可以肯定依靠一项或多项服务来提供商业利益。基础架构的责任是提供一种服务在每个环境基础上找到彼此的方式。&lt;/p&gt;
&lt;p&gt;某些服务发现需要应用程序进行 API 调用，而其他服务则通过 DNS 或网络代理公开透明地进行。使用什么工具并不重要，但服务使用服务发现很重要。&lt;/p&gt;
&lt;p&gt;尽管服务发现是最古老的网络服务之一（即 ARP 和 DNS），但它经常被忽视不用。在每个实例文本文件或代码中静态定义服务端点是不可扩展的，且不适合云原生环境。端点（Endpoint）注册应该在创建服务时自动发生，并且端点可用或消失。&lt;/p&gt;
&lt;p&gt;云原生应用程序与基础架构一起工作以发现其相关服务。这些包括但不限于 DNS，云元数据服务或独立服务发现工具（即 etcd 和 consul）。&lt;/p&gt;
&lt;h3 id=&#34;状态管理&#34;&gt;状态管理&lt;/h3&gt;
&lt;p&gt;如果有状态管理的话基础架构将能知道应用程序实例需要做什么。这与应用程序生命周期截然不同，因为生命周期适用于应用程序的整个开发过程。状态适用于启动和停止的实例。&lt;/p&gt;
&lt;p&gt;应用程序有责任提供 API 或 hook，以便检查其当前状态。基础架构的责任是监控实例的当前状态并采取相应的行动。&lt;/p&gt;
&lt;p&gt;以下是一些应用程序状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交&lt;/li&gt;
&lt;li&gt;预定&lt;/li&gt;
&lt;li&gt;准备好了&lt;/li&gt;
&lt;li&gt;健康&lt;/li&gt;
&lt;li&gt;不健康&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些状态和相应行动的简要概述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个应用申请提交运行。&lt;/li&gt;
&lt;li&gt;基础架构检查请求的资源并安排应用程序。应用程序启动时，提供一个准备好 / 未准备好的状态。&lt;/li&gt;
&lt;li&gt;基础架构将等待就绪状态，然后允许使用应用程序资源（例如，将实例添加到负载均衡器）。如果应用程序在指定的时间前未准备就绪，基础结构将终止它并安排一个新的应用程序实例。&lt;/li&gt;
&lt;li&gt;一旦应用程序准备就绪，基础架构将监控活动状态并等待不健康状态，或者直到应用程序设置为不再运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有比上述更多的状态。如果要对状态进行正确的检查和采取行动，则状态需要得到基础架构的支持。Kubernetes 通过事件、探针和 hook 实现应用程序状态管理，但是每个编排平台都应该具有类似的应用程序管理功能。&lt;/p&gt;
&lt;p&gt;当应用程序被提交、调度或扩缩容时，会触发 Kubernetes 事件。探针用于检查应用程序何时准备好提供流量（就绪）并确保应用程序健康（存活）。Hook 用于在进程启动之前或之后需要发生的事件。&lt;/p&gt;
&lt;p&gt;应用程序实例的状态与应用程序生命周期管理同样重要。基础架构在确保实例可用并据此采取行动方面起着关键作用。&lt;/p&gt;
&lt;h3 id=&#34;监控和记录&#34;&gt;监控和记录&lt;/h3&gt;
&lt;p&gt;永远不要让应用程序自己要求监控或被日志记录；它们是基础架构运行的基本条件。更重要的是，如果需要被监控和记录，其配置应该以应用程序资源请求相同的方式声明为代码。如果你拥有部署应用程序的所有自动化功能，但无法动态监控服务，那么云原生基础架构也就不完整。&lt;/p&gt;
&lt;p&gt;状态管理（即进程健康检查）和日志记录处理应用程序的各个实例。日志系统应该能够根据应用程序、环境、标签或任何其他有用的元数据整合日志。&lt;/p&gt;
&lt;p&gt;应用程序应该尽可能没有单点故障，并且应该运行多个实例。如果一个应用程序有 100 个实例正在运行，就算单个实例变得不健康，监控系统也不应触发警报。&lt;/p&gt;
&lt;p&gt;监控从整体上看应用程序，并用于调试和验证所需的状态监控与警报不同，因为应根据应用程序的度量和 SLO 触发警报。&lt;/p&gt;
&lt;h3 id=&#34;指标聚合&#34;&gt;指标聚合&lt;/h3&gt;
&lt;p&gt;要知道应用程序处于健康状态时的行为方式，收集指标。它们还可以提供有关不健康时可能被破坏的信息的洞察，并且就像监控一样，收集的指标应作为代码与应用程序定义的一部分被请求。&lt;/p&gt;
&lt;p&gt;基础架构可以自动收集有关资源利用率的指标，但应用程序有责任呈现服务级别指标。&lt;/p&gt;
&lt;p&gt;监测和日志记录是对应用程序运行时的状况检查，指标可提供所需的遥测数据。没有指标（metric），就无法知道应用程序是否满足服务级别目标以提供商业价值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从日志中提取遥测和健康检查数据可能很诱人，但要小心，因为日志记录需要后处理，并且比应用特定监控指标来说开销更重。&lt;/p&gt;
&lt;p&gt;在收集指标时，你希望尽可能接近实时数据。这需要一个可扩展且简单高效的解决方案。&lt;/p&gt;
&lt;p&gt;应该使用日志进行调试，且应该预计到数据处理的延迟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与日志记录类似，指标通常在实例级别收集，然后汇总在一起以提供完整的服务视图，而不是单个实例的展示。&lt;/p&gt;
&lt;p&gt;一旦应用程序提供收集指标的方法，基础架构的工作就是搜集、整合和存储指标用于分析。收集指标的端点应该可以根据每个应用程序进行配置，但数据格式应该标准化，以便可以在单个系统中查看所有指标。&lt;/p&gt;
&lt;h3 id=&#34;调试和跟踪&#34;&gt;调试和跟踪&lt;/h3&gt;
&lt;p&gt;应用程序在开发过程中很容易调试。集成开发环境（IDE），代码断点以及在调试模式下运行都是工程师在编写代码时可以使用的所有工具。&lt;/p&gt;
&lt;p&gt;对于部署的应用程序来说，自检要困难得多。当应用程序由数十或数百个微服务或独立部署的功能组成时，此问题更为严重。当用多种语言和不同的团队编写服务时，也可能无法将工具内置到应用程序中。&lt;/p&gt;
&lt;p&gt;基础架构需要提供调试整个应用程序的方法，不仅仅是单个服务。调试有时可以通过日志记录系统完成，但是复现错误需要较短的反馈回路。&lt;/p&gt;
&lt;p&gt;如前所述，调试对于动态配置来说是很好用的。当发现问题时，应用程序可以切换到详细日志记录，而无需重新启动，并且流量可以通过应用程序代理有选择地路由到实例。&lt;/p&gt;
&lt;p&gt;如果问题无法通过日志输出解决，那么分布式跟踪提供了一个不同的界面来可视化发生的事情。分布式跟踪系统（如 OpenTracing）可以补充日志以帮助人类调试问题。&lt;/p&gt;
&lt;p&gt;跟踪为调试分布式系统提供了更短的反馈回路。如果它不能构建到应用程序中，则可以通过代理或流量分析由基础架构透明地完成。当你大规模地运行任何协调的应用程序时，基础架构提供了一种调试应用程序的方法。&lt;/p&gt;
&lt;p&gt;尽管在分布式系统中设置跟踪有很多好处和实现细节，但我们不会在此讨论。应用程序跟踪一直非常重要，并且在分布式系统中越来越困难。云原生基础架构需要提供可以以透明方式跨越多个服务的跟踪服务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;应用程序需求已经改变：带有操作系统和软件包管理器的服务器已经不够用了。应用程序现在需要协调服务和更高级别的抽象。抽象允许资源与服务器分离并根据需求以编程的方式使用。&lt;/p&gt;
&lt;p&gt;本章中提出的要求并不是基础架构可以提供的所有服务，但它们是云原生应用程序所期望的基础。如果基础架构不提供这些服务，那么应用程序将不得不实施它们，否则它们将无法达到现代业务所需的规模和速度。&lt;/p&gt;
&lt;p&gt;基础架构不会自行发展：人们需要改变自己的行为方式，从根本上解决以不同的方式运行应用程序这个问题。幸运的是，有些项目已经在借鉴开创了这些解决方案的公司的经验了。&lt;/p&gt;
&lt;p&gt;应用程序依赖基础架构的功能和服务来支持敏捷开发。基础架构要求应用程序公开端点和集成以自主管理的方式。工程师应尽可能使用现有的工具，并设计出有弹性的简单解决方案。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>保护应用程序</title>
      <link>https://jimmysong.io/book/cloud-native-infra/securing-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/securing-applications/</guid>
      <description>
        
        
        &lt;p&gt;我们讨论过只能使用云原生应用程序来创建基础架构。同时基础架构也负责运行这些应用程序。&lt;/p&gt;
&lt;p&gt;运行由应用程序配置和控制的基础架构可以轻松得扩展。我们通过学习如何通过扩展应用的方式来扩展基础架构。我们还通过学习如何保护应用程序来保护基础架构。&lt;/p&gt;
&lt;p&gt;在动态环境中，无法通过增加人手来管理这样的复杂性，同样也不能靠增加人手来处理策略和安全问题。&lt;/p&gt;
&lt;p&gt;这意味着，就像我们必须创建通过协调器模式强制执行基础架构状态的应用程序一样，我们需要创建实施安全策略的应用程序。在创建应用程序以执行的策略之前，我们需要以机器可解析的格式编写策略。&lt;/p&gt;
&lt;h2 id=&#34;策略即代码&#34;&gt;策略即代码&lt;/h2&gt;
&lt;p&gt;由于策略没有明确定义的技术实现，所以策略难以纳入代码。它更多地关注业务如何实现而不是谁来实现。&lt;/p&gt;
&lt;p&gt;如何实现和谁来实现都会经常变化，但是实现方式变化更频繁且不容易被抽象化。它也是组织特定的，可能需要了解创建基础架构人员的沟通结构的具体细节。&lt;/p&gt;
&lt;p&gt;策略需要应用于应用程序生命周期的多个阶段。正如我们在第 7 章中所讨论的，应用程序通常有三个阶段：部署、运行和退役。&lt;/p&gt;
&lt;p&gt;部署阶段将在应用程序和基础架构变更发布之前先应用策略。这将包括部署规则和一致性测试。运行阶段将包括持续的遵守和执行访问控制和隔离。退役阶段很重要，以确保没有服务落后于未安排或未维护的状态。&lt;/p&gt;
&lt;p&gt;在这些阶段中，您需要将策略分解为明确的，可操作的实现。模糊的策略无法执行。您需要将实现放在代码中，然后创建应用程序或使用现有的应用程序来执行策略规则。&lt;/p&gt;
&lt;p&gt;您应该将策略视为代码。策略更改应视为应用程序更改并在版本控制中进行跟踪。&lt;/p&gt;
&lt;p&gt;控制应用程序部署的相同策略也应该适用于您的新策略部署。您可以使用与部署应用程序相同的工具跟踪和部署的基础架构组件越多，就越容易了解正在运行的内容以及变更如何影响系统。&lt;/p&gt;
&lt;p&gt;将策略作为代码带来的巨大好处是您可以轻松地添加或删除策略并对其进行跟踪，因此记录了谁执行了策略，何时执行了策略以及提交和提交请求的评论。由于该策略以代码形式存在，因此您现在可以为自己的策略编写测试！如果你想验证一个策略是否可以正常工作，你可以使用第 5 章中的测试实践。&lt;/p&gt;
&lt;p&gt;让我们更仔细地看看如何将策略应用到应用程序生命周期。&lt;/p&gt;
&lt;h3 id=&#34;部署-gateway&#34;&gt;部署 Gateway&lt;/h3&gt;
&lt;p&gt;部署 gateway 确保应用程序的部署符合业务规则。这意味着您将需要构建部署流水线，并且不允许从用户机器进行直接生产部署。&lt;/p&gt;
&lt;p&gt;在实施集中化策略之前，您需要集中控制，但是应该从小规模开始，并在实施之前证明解决方案可行。部署流水线的好处远不止于策略执行，而且应该是任何拥有少数开发人员的组织中的标准。&lt;/p&gt;
&lt;p&gt;以下是一些策略示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署只有在所有测试都通过后才能进行。&lt;/li&gt;
&lt;li&gt;新应用程序要求高级开发人员检查更改并对提取请求发表评论。&lt;/li&gt;
&lt;li&gt;生产工件推送只能从部署流水线发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gateway 不应该强制运行状态或应用程序的 API 请求。应用程序应该知道如何配置基础架构组件，并通过合规性和审计将策略应用于这些组件，而不是在应用程序部署期间应用。&lt;/p&gt;
&lt;p&gt;部署 gateway 策略的一个例子是，星期五下午 3 点之后，如果您的组织没有获得经理批准，不允许部署代码。&lt;/p&gt;
&lt;p&gt;这个很容易放入代码中。图 8-1 是代表策略的非常简化的图。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/book/cloud-native-infra/securing-applications/f-8-1.jpg&#34; data-img=&#34;/book/cloud-native-infra/securing-applications/f-8-1.jpg&#34; data-width=&#34;1232&#34; data-height=&#34;332&#34; alt=&#34;image&#34; data-caption=&#34;图 8-1. 部署策略&#34;&gt;
    
  
  &lt;figcaption&gt;图 8-1. 部署策略&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;您可以看到该策略简单地检查了允许部署部署的一周中的时间和日期。如果是星期五和下午 3 点以后，那么策略会检查管理员确定。&lt;/p&gt;
&lt;p&gt;该策略可以通过经理发送的经过验证的电子邮件，经过验证的 API 调用或各种其他方式来获得 OK 通知。决定首选通信方法的内容以及等待批准的时间长度取决于策略。&lt;/p&gt;
&lt;p&gt;这个简单的例子可以用很多不同的选项进行扩展，但确保该策略不符合人类解析和执行是很重要的。人的解释是不同的，而不明确的策略通常不会得到执行。&lt;/p&gt;
&lt;p&gt;通过确保策略阻止新的部署，可以为解决生产环境的状态节省很多工作。有一系列可以通过软件验证的事件可以帮助您理解系统。版本控制和持续部署流水线可以验证代码；使用策略和流程作为代码可以验证软件的部署方式和时间。&lt;/p&gt;
&lt;p&gt;除了确保通过公司策略部署正确的事情之外，我们还应该轻松地使用模板部署受支持的事物，并通过一致性测试强制执行它们。&lt;/p&gt;
&lt;h3 id=&#34;合规性测试&#34;&gt;合规性测试&lt;/h3&gt;
&lt;p&gt;在任何基础架构中，您都需要提供建议的方式来创建特定类型的应用程序。这些建议成为用户根据需要消费和拼凑在一起的基石。&lt;/p&gt;
&lt;p&gt;这些建议是可堆砌的，但又不能太小。需要在其预期的功能和自助服务方面可以理解。我们已经建议将云原生应用程序打包为容器并通过协调器使用；由您决定什么最适合您的用户以及您想要提供哪些组件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您可以通过多种方式为用户提供模板化基础架构。&lt;/p&gt;
&lt;p&gt;提供一个模板化的代码，比如 Jsonnet，或者完全模板化的应用程序，例如 Helm 的 chart。&lt;/p&gt;
&lt;p&gt;您还可以通过您的部署流水线提供模板。可以是 Terraform 模块或特定于部署的工具，例如 Spinnaker 模板。&lt;/p&gt;
&lt;p&gt;创建部署模板允许用户成为模板的消费者，随着最佳实践的发展，用户将自动受益。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基础架构模板的最关键的一点是使做正确的事情变得容易，并且很难做错事情。如果您满足客户的需求，那么获得适配器将会容易得多。&lt;/p&gt;
&lt;p&gt;但是，我们需要模板化基础架构的根本原因是可以执行合规性测试。合规性测试的存在是为了确保应用程序和基础架构组件符合组织的标准。&lt;/p&gt;
&lt;p&gt;对不符合标准的基础架构进行测试的一些示例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不在自动缩放组中的服务或端点&lt;/li&gt;
&lt;li&gt;不在负载均衡器后面的应用程序&lt;/li&gt;
&lt;li&gt;前端层直接与数据库通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些标准是关于基础架构的信息，您可以通过调用云提供商的 API 来找到这些信息。合规性测试应持续运行，并强制执行公司采用的架构标准。&lt;/p&gt;
&lt;p&gt;如果发现基础架构组件或应用程序架构违反了公司提供的标准，则应尽早终止它们。越早可以对模板进行编码，就可以越早检查出不符合标准的应用程序。在应用程序的生命早期解决不受支持的体系结构非常重要，因此可以最大限度地减少对体系结构决策的依赖。&lt;/p&gt;
&lt;p&gt;合规性处理如何构建应用程序和维护可操作性。合规性测试确保应用程序和基础架构安全。&lt;/p&gt;
&lt;h3 id=&#34;一致性测试&#34;&gt;一致性测试&lt;/h3&gt;
&lt;p&gt;合规性测试不会测试架构设计，而是集中于组件的实施，以确保它们遵守定义的策略。放在代码中的最简单的策略是那些有助于安全的策略。围绕组织需求（例如 HIPAA）的策略也应定义为代码并在合规性测试期间进行测试。&lt;/p&gt;
&lt;p&gt;合规策略的一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象存储的用户访问受限，并且不能被公共因特网读取或写入&lt;/li&gt;
&lt;li&gt;API 端点全部使用 HTTPS 并具有有效证书&lt;/li&gt;
&lt;li&gt;虚拟机实例（如果有的话）没有过分宽松的防火墙规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些策略不会使应用程序免受所有漏洞或错误的影响，但是如果应用程序确实被利用，合规性策略应将影响范围降至最低。&lt;/p&gt;
&lt;p&gt;Netflix 在其博客文章“The Netflix Simian Army”中通过其 Security Monkey 解释了其执行合规性测试的目的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Security Monkey 是 Conformity Monkey 的延伸。它会查找安全违规或漏洞（如未正确配置的 AWS 安全组），并终止违规实例。它还确保我们所有的 SSL 和 DRM 证书都是有效的，并且不会延期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将您的策略放入代码并通过观察云提供商 API 继续运行它，可以让您保持更高的安全性，立即捕获不安全的设置，并随时跟踪版本控制系统的策略。根据这些策略不断测试您的基础架构的模型也非常适合调节器模式。&lt;/p&gt;
&lt;p&gt;如果您认为策略是需要应用和实施的配置类型，那么实施它可能会更简单。请务必记住，随着您的基础架构和业务需求的变化，您的合规策略也应该如此。&lt;/p&gt;
&lt;p&gt;部署测试在将应用程序部署到基础架构之前进行监视，合规性和合规性测试都处理正在运行的应用程序。确保您拥有策略的最后一个应用程序生命周期阶段是了解何时以及如何废止应用程序和生命周期组件。&lt;/p&gt;
&lt;h3 id=&#34;活动测试&#34;&gt;活动测试&lt;/h3&gt;
&lt;p&gt;合规性和一致性测试应该删除那些未通过定义策略的应用和基础架构。还应该有一个应用程序清理旧的和未使用的基础架构组件。高级使用模式应基于应用程序遥测数据，但仍有其他基础架构组件很容易被遗忘并需要退役。&lt;/p&gt;
&lt;p&gt;在云环境中，您可以根据需要消费资源，但很容易会忘记需求。如果没有自动清理旧的或未使用的资源，最后您会对账单感到惊讶，或者需要耗费大量人力进行手动审计和清理。&lt;/p&gt;
&lt;p&gt;您应该测试并自动清理的资源的一些示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧磁盘快照&lt;/li&gt;
&lt;li&gt;测试环境&lt;/li&gt;
&lt;li&gt;以前的应用程序版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负责清理的应用程序需要根据默认策略做正确的事情，并为工程师指定的异常提供灵活性。&lt;/p&gt;
&lt;p&gt;正如第 7 章所提到的，Netflix 已经实现了它所称的“Janitor Monkey”，它的实现完美地描述了这种需要的模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Janitor Monkey 在“标记、通知和删除”过程中工作。当 Janitor Monkey 将资源标记为候选清理对象时，它会安排删除资源的时间。删除时间在标记资源的规则中指定。&lt;/p&gt;
&lt;p&gt;每个资源都与一个所有者电子邮件相关联，该电子邮件可以在资源上指定为标签，或者您可以快速扩展 Janitor Monkey 以从您的内部系统获取信息。最简单的方法是使用默认的电子邮件地址，例如您的团队的电子邮件列表中的所有资源。您可以配置若干天，以指定何时让 Janitor Monkey 在计划终止之前向资源所有者发送通知。默认情况下，数字为 3，表示业主将在终止日期前 3 个工作日收到通知。&lt;/p&gt;
&lt;p&gt;在这 3 天期间，资源所有者可以决定资源是否可以删除。如果资源需要保留更长时间，则所有者可以使用简单的 REST 接口将资源标记为未被 Janitor Monkey 清除。所有者总是可以使用另一个 REST 接口来删除该标志，然后 Janitor Monkey 将能够再次管理该资源。&lt;/p&gt;
&lt;p&gt;当 Janitor Monkey 看到标记为清理候选者的资源并且预定的终止时间已经过去时，它将删除资源。如果资源所有者想要提前释放资源以节省成本，则还可以手动删除该资源。当资源状态改变而使资源不是清理候选者时，例如一个分离的 EBS 卷被附加到一个实例，Janitor Monkey 将取消该资源的标记并且不会终止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拥有自动清理基础架构的应用程序可以降低您的复杂性和成本。该测试将协调模式应用到应用程序的最后生命周期阶段。&lt;/p&gt;
&lt;p&gt;还有其他一些基础架构的实践很重要，需要考虑。其中一些实践适用于传统基础架构，但在云原生环境中需要进行不同的处理。&lt;/p&gt;
&lt;p&gt;不断测试基础架构的各个方面有助于您了解自己遵守的策略。当基础架构频繁变更时，很难审计哪些变更可能导致停机或使用历史数据来预测未来趋势。&lt;/p&gt;
&lt;p&gt;如果您希望从账单声明中获取该信息或通过基础架构的当前快照来推断，您会很快发现它们所提供的信息是没用的。为了跟踪变化并预测未来，我们需要有审计工具，可以快速提供我们需要的信息。&lt;/p&gt;
&lt;h2 id=&#34;审计基础架构&#34;&gt;审计基础架构&lt;/h2&gt;
&lt;p&gt;在这个意义上审计云原生基础架构与审核调解器模式中的组件不同，它与第 6 章中讨论的测试框架也不同。相反，当我们谈论审计时，我们指的是对变更的高级概述和基础架构内的组件关系。&lt;/p&gt;
&lt;p&gt;跟踪基础架构中存在的内容以及它与其他组件的关系，为我们了解当前状态提供了重要的背景。当某些事情中断时，第一个问题几乎总是“什么改变了？”审计为我们回答了这个问题，并且可以用来告诉我们如果我们应用变更会受到什么影响。&lt;/p&gt;
&lt;p&gt;在传统的基础架构中，配置管理数据库（CMDB）通常是基础架构当前状态的真相来源。但是，CMDB 不会跟踪基础架构或资产关系的历史版本。&lt;/p&gt;
&lt;p&gt;云提供商可以通过库存 API 为您提供 CMDB 替代服务，但它们可能不会激励您显示历史趋势或让您查询您需要进行故障排除的特定详细信息，例如主机名。&lt;/p&gt;
&lt;p&gt;一个好的云审计工具可以让你显示当前基础架构与昨天或上周相比的差异（diff）。它应该能够将云提供商数据与其他来源（例如容器编排器）相结合，以便您可以查询云提供商可能没有的数据的基础架构，理想情况下，它可以自动构建组件关系的拓扑表示。&lt;/p&gt;
&lt;p&gt;如果您的应用程序完全在单个平台上运行（例如 Kubernetes），则收集资源依赖关系的拓扑信息要容易得多。自动可视化关系的另一种方法是统一关系发生的层次。&lt;/p&gt;
&lt;p&gt;对于在云中运行的服务，可以在服务之间的网络通信中识别关系。有很多方法可以识别服务之间的网络流量，但审计的重要考虑是对信息进行历史跟踪。您需要能够轻松识别关系何时发生变化，就像您识别组件之间关系一样容易。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自动识别服务关系的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跟踪服务之间的网络流量意味着您需要了解用于通信的网络协议的工具。您不能简单地依赖流入或流出服务端点的原始数据包流量。你需要一种方法来利用信息流来建立关系模型。&lt;/p&gt;
&lt;p&gt;检查网络流量和构建依赖关系图的一种流行方式是通过网络代理。&lt;/p&gt;
&lt;p&gt;网络代理的一些实现示例是 linkerd 和 envoy。服务通过这些代理来传输所有流量，这些代理知道正在使用的协议和其他相关服务。如附录 B 所述，代理还允许其他网络弹性模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟踪时间拓扑结构是一个强大的审计工具。结合基础架构的历史，它将确保“改变了什么？”问题更容易回答。&lt;/p&gt;
&lt;p&gt;还有一个审计方面涉及在当前基础架构状态下建立信任。应用程序通过所描述的测试工具获得信任，但基础架构的某些方面无法应用相同的测试。&lt;/p&gt;
&lt;p&gt;用可验证的可重现组件构建基础架构可以提供很大的信任。这种做法被称为不可变基础设施。&lt;/p&gt;
&lt;h2 id=&#34;不可变基础设施&#34;&gt;不可变基础设施&lt;/h2&gt;
&lt;p&gt;不可变的基础架构是通过替换而不是修改来创建变更的做法。换句话说，不是运行配置管理来对所有服务器应用更改，而是建立新服务器并丢弃旧服务器。&lt;/p&gt;
&lt;p&gt;云环境很大程度上受益于创建变更的方法，因为部署新 VM 的成本通常非常低，比管理可强制配置并保持实例运行的另一个系统要容易。因为服务器是虚拟的（即用软件定义），所以您可以像构建服务器镜像一样应用与构建应用程序相同的实践。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物理服务器的传统基础架构与系统创建时的云具有完全相反的优化。提供物理服务器需要很长时间，并且在修改现有操作系统方面有很大的好处，而不是替换旧的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不可变基础设施的问题之一是建立信任链，为部署创造黄金镜像。镜像在构建时应该是可验证的（例如，签名密钥或镜像哈希），并且一旦部署就不应改变。&lt;/p&gt;
&lt;p&gt;镜像创建也需要自动化。历史上使用黄金镜像的最大问题之一是它们通常依靠人类在对照检查表十分耗时得创建出来。&lt;/p&gt;
&lt;p&gt;存在工具（例如，Hashicorp 的 Packer）来自动化构建过程，并且没有理由存在旧镜像。自动化还允许旧的清单成为可以审计和版本控制的脚本。了解配置工具何时发生变化以及由谁建立信任的不可变基础设施的另一方面。&lt;/p&gt;
&lt;p&gt;发生变更时，应该经常变更，您需要一种方法来跟踪变更内容和原因。审计将有助于确定发生了什么变化，而不可变的基础架构可以帮助您追踪到 Git 提交或拉取请求。&lt;/p&gt;
&lt;p&gt;追踪历史也大大有助于从失败中恢复过来。如果您有一个已知可用的虚拟机映像，另一个虚拟机镜像不可用，则可以像部署新的破损版本一样快速地部署以前的工作版本。&lt;/p&gt;
&lt;p&gt;不可变基础设施不是云原生基础架构的要求，但环境从这种基础架构管理风格中受益匪浅。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;通过本章介绍的实践，您将能够更轻松地控制在基础架构中运行的内容，并跟踪其运作的方式。将您的策略放在代码中可让您跟踪变更，而且您不用认为来解读策略。&lt;/p&gt;
&lt;p&gt;审计和不可变基础设施为您提供了更好的信息，以确保您的系统安全并帮助您更快地从故障中恢复。&lt;/p&gt;
&lt;p&gt;除了本章前面讨论的合规性测试要求之外，我们不会在本书中讨论安全性，但您应该及时了解您使用的技术和云提供商的安全最佳实践。安全性最重要的方面之一是在整个堆栈中应用“分层安全”。&lt;/p&gt;
&lt;p&gt;换句话说，仅仅在主机操作系统上运行防病毒守护进程不足以保护您的应用程序。您需要查看您控制的所有基础架构层，并应用适合您需求的安全监控。&lt;/p&gt;
&lt;p&gt;本章中介绍的所有测试都应以第 4 章中介绍的相同协调模式运行。收集信息以了解当前状态，根据一组规则查找更改，然后使这些更改都适合云原生模式。&lt;/p&gt;
&lt;p&gt;如果您可以将您的策略作为代码实施，那么您将超越云的技术优势，并为云原生模式实现商业利益。&lt;/p&gt;
&lt;p&gt;历史和拓扑审计可能看起来并不明显，但随着基础架构的增长以及变化率和应用敏捷性的增加，这些审计将非常重要。将传统方法应用于管理云基础架构不是云原生，本章向您展示了您应该利用的一些好处以及您将面临的一些挑战。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>实施云原生基础架构</title>
      <link>https://jimmysong.io/book/cloud-native-infra/implementing-cloud-native-infrasctructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/implementing-cloud-native-infrasctructure/</guid>
      <description>
        
        
        &lt;p&gt;如果您认为云原生基础架构是可购买的产品或是从云供应商那购买的服务器，我们很抱歉让您失望了。如果不采用这些做法并改变您建设和维护基础架构的方式，您就不会受益。&lt;/p&gt;
&lt;p&gt;它不仅仅影响服务器、网络和存储。它关乎的是工程师如何管理应用程序，就像接受故障一样。&lt;/p&gt;
&lt;p&gt;围绕云原生实践建立的文化与传统技术和工程组织有很大不同。我们并不是解决组织文化或结构问题的专家，但如果您希望改变组织结构，我们建议您从高绩效组织中实施 DevOps 实践的角度来看待价值观和经验教训。&lt;/p&gt;
&lt;p&gt;一些需要探索的地方是 Netflix 的文化套餐，它促进了自由和责任感，还有亚马逊的双比萨团队，这些团队以低开销推广自治团体。云原生应用程序需要与构建它们的团队具有相同的解耦特征。康威定律很好地描述了这一点：“设计系统的架构受制于产生这些设计的组织的沟通结构。”&lt;/p&gt;
&lt;p&gt;在我们结束本书时，我们希望关注哪些领域是您采用云原生实践时最重要的。我们还将讨论一些预测变化的基础架构模式，以便您知道将来要寻找什么。&lt;/p&gt;
&lt;h2 id=&#34;关注改变的地方&#34;&gt;关注改变的地方&lt;/h2&gt;
&lt;p&gt;如果您拥有现有的基础架构或传统数据中心，则过渡到云原生不会在一夜之间发生。如果您有足够大的基础架构或两个以上的人员管理它，试图强制实施基础架构管理的新方法可能会失败。&lt;/p&gt;
&lt;p&gt;采用这些模式与配置新服务器或购买新软件无关。要开始采用云原生基础架构，最重要的是是首先关注这些领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人&lt;/li&gt;
&lt;li&gt;架构&lt;/li&gt;
&lt;li&gt;混乱&lt;/li&gt;
&lt;li&gt;应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到您准备好这些区域以使用本书中描述的实践，才能开始更改基础架构。&lt;/p&gt;
&lt;h3 id=&#34;人&#34;&gt;人&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;比竞争对手更快学习的能力可能是唯一的可持续竞争优势。&lt;/p&gt;
&lt;p&gt;——Arie de Geus&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如我们在第 2 章中所讨论的，人是实施任何变革中最难的部分。他们的抵制有很多原因，而那些要求进行变更以帮助其影响的人有责任。&lt;/p&gt;
&lt;p&gt;当需要改变的驱动激励时，变更更容易。主动提高潜力是一个很好的激励因素，但如果没有紧迫感，就很难改变行为。&lt;/p&gt;
&lt;p&gt;人们抗拒改变的原因大多来自恐惧。人们喜欢习惯，因为他们可以控制并避免意外。&lt;/p&gt;
&lt;p&gt;为了使任何技术取得成功的重大转变，您需要与人们合作以最大限度地减少他们的恐惧。给他们一种主人翁感，并解释变化的明确目标。确保突出新旧技术之间的相似之处，特别是在改变后他们将扮演的角色。&lt;/p&gt;
&lt;p&gt;人们了解这种变化并不是因为他们在旧系统或现有系统中的失败，这一点也很重要。他们需要明白，要求已经改变，环境不同，并且希望他们成为变革的一部分，因为你尊重他们所做的并且对他们能做的事有信心。&lt;/p&gt;
&lt;p&gt;他们需要学习新事物，为此，失败是必要的，预期的，并且是进步的标志。&lt;/p&gt;
&lt;p&gt;鼓励学习和实验，并奖励适应数据洞察的人员和系统。让工程师通过诸如“百分之二十的时间”之类的自由来探索新的可能性，可以做到这一点。&lt;/p&gt;
&lt;p&gt;如果敏捷系统没有改变，它就没有好处。一个不适应和改进的系统将无法满足正在改变和学习的企业的需求。&lt;/p&gt;
&lt;p&gt;一旦你能够激发人们寻求改变，你应该用信任和自由来赋予他们力量。不断引导他们将自己的目标与业务需求结合起来，并赋予他们应聘的管理职责。&lt;/p&gt;
&lt;p&gt;如果人们已经准备好采用本书中的做法，那么实现它就没有什么限制。关于创建组织变革的更深入的指导，我们推荐阅读 John P. Kotter（哈佛商业评论出版社）的“领导变革”。&lt;/p&gt;
&lt;p&gt;改变环境文化需要组织的大量努力和支持，以及更改应用程序运行的基础架构。您选择的架构可能会对采用云原生模式的能力产生重大影响。&lt;/p&gt;
&lt;h3 id=&#34;架构&#34;&gt;架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;弹性、安全性、可伸缩性、可部署性、可测试性是架构问题。&lt;/p&gt;
&lt;p&gt;——Jez Humble&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将应用程序迁移到云原生基础架构时，您需要考虑如何管理和设计应用程序。例如，作为云原生应用程序前身的 12 因子应用程序受益于在平台上运行。它们被设计为最小化手动管理，频繁更改和弹性。许多传统应用程序的架构都是为了抵制自动化，不经常升级和失败。在迁移它之前，您应该考虑应用程序的架构。&lt;/p&gt;
&lt;p&gt;单个应用程序架构是一个问题，但您还需要考虑应用程序如何与基础架构内的其他服务通信。应用程序应已云环境中支持的协议以及通过明确界定的接口进行通信，通过采用微服务保持应用程序范围很小可以帮助定义应用程序间接口和提高应用程序部署速度。但是，采用微服务会暴露出新的问题，如应用程序通信速度较慢以及分布式跟踪和策略控制网络的需求。如果不能为您的基础架构提供好处，就不要采用微服务。&lt;/p&gt;
&lt;p&gt;虽然您几乎可以适应任何应用程序在容器中运行并使用容器编排器进行部署，但如果首选迁移所有关键业务数据库服务器，您将很快就会后悔。&lt;/p&gt;
&lt;p&gt;首先确定接近具有第 1 章概述的特性的应用程序并获得在云原生环境中运行它们的经验。一旦您围绕简单的应用程序集体获得经验和良好实践，那么您就可以决定接下来要做什么。&lt;/p&gt;
&lt;p&gt;您的服务器和服务也不例外。在将基础架构切换为不可变的之前，您应确保它解决了当前的问题，并意识到新问题。&lt;/p&gt;
&lt;p&gt;可靠系统中最重要的架构考虑是争取简单的解决方案。软件和系统自然会变得复杂，这会造成不稳定。在云中，您可以释放对许多区域的控制，因此在仍然可以控制的区域保持简单性很重要。&lt;/p&gt;
&lt;p&gt;无论您将内部部署基础架构迁移到云中还是创建新的解决方案，都要确保您在第 1 章中进行可用性数学计算，并为混乱情况做好准备。&lt;/p&gt;
&lt;h3 id=&#34;混沌管理&#34;&gt;混沌管理&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;拥抱失败并期待混乱。&lt;/p&gt;
&lt;p&gt;——Netflix 的 Andrew Spyker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当您构建云原生应用程序和基础架构时，其目标是创建最小可行产品（MVP）和迭代。尝试指定您的客户需要什么或他们将如何使用您的产品可能会有用一段时间，但成功的应用程序将适应而不是预测。&lt;/p&gt;
&lt;p&gt;客户需求改变；应用程序需要随它们改变。您无法计划和构建完整的解决方案，因为在产品准备就绪时，需求已发生变化。&lt;/p&gt;
&lt;p&gt;保持敏捷并在现有技术基础上发展很重要。就像您为应用程序导入库一样，您应该为基础架构使用 IaaS 和 SaaS。你越努力建立自己，你就越能提供价值。&lt;/p&gt;
&lt;p&gt;无论何时释放对某物的控制，都会冒着意想不到的风险。如果因为导入的库已更新而导致应用程序中断，您将会知道这是什么感觉。&lt;/p&gt;
&lt;p&gt;您的应用程序依赖于库所提供的功能，该功能已更改。你是否应该删除库并编写自己的功能以便控制它？答案几乎总是不。相反，您更新应用程序以使用新库，或者将正在运行的较旧版本的库与应用程序捆绑在一起，以暂时避免损坏。&lt;/p&gt;
&lt;p&gt;运行在公有云上的基础架构也是如此。您不再控制硬连线网络，使用什么 RAID 控制器，或者虚拟机的哪个版本的虚拟机管理程序运行。您所拥有的只是可以在底层技术之上提供抽象的 API。&lt;/p&gt;
&lt;p&gt;您无法控制底层技术何时发生变化。如果云提供商弃用所有大型内存实例类型，则您别无选择，只能遵守。您要么适应新的尺寸，要么支付更换提供商的成本（时间和金钱）（请参阅附录 B 关于锁定）。&lt;/p&gt;
&lt;p&gt;最重要的是，您构建的基础架构不再可以从单个关键服务器获得。如果您采用云原生基础架构，无论您是否喜欢，您正在构建一个分布式系统。&lt;/p&gt;
&lt;p&gt;通过简单地避免失败来保持服务可用的旧做法不起作用。目标不再是您可以设计的最大数目的几个 9—— 而是你可以摆脱的最小数量的几个 9。&lt;/p&gt;
&lt;p&gt;站点可靠性工程（Site Reliability Engineering）以这种方式解释它：&lt;/p&gt;
&lt;p&gt;坚持 SLO 将百分之百满足是不现实的和不可取的：这样做可能会降低创新和部署的速度，需要昂贵的，过于保守的解决方案，或两者兼而有之。相反，最好允许一个错误预算 —— 一个可能错过 SLO 的速率，并且每天或每周对其进行跟踪。&lt;/p&gt;
&lt;p&gt;工程的目标不可用；它创造了商业价值。你应该制造弹性系统，但不要以过度工程解决方案为代价来避免混乱。&lt;/p&gt;
&lt;p&gt;测试更改以防止停机的旧方法也不起作用。为大型分布式系统创建测试环境并不重要。当服务经常更新并且部署是自助服务时尤其如此。&lt;/p&gt;
&lt;p&gt;当 Netflix 每天有 4,000 次部署或 Facebook 有 10,000 个同时运行的版本时，对环境进行快照是不可能的。测试环境需要动态分离生产部分。基础架构需要支持这种测试方法，并支持经常测试生产中的新代码所带来的失败。&lt;/p&gt;
&lt;p&gt;你可以测试一些混乱（参见第 5 章），但混沌根据定义是不可预测的。准备您的基础架构和应用程序，以便可预测地对混乱做出反应，而不要试图避免它。&lt;/p&gt;
&lt;h3 id=&#34;应用程序&#34;&gt;应用程序&lt;/h3&gt;
&lt;p&gt;基础架构的目的是运行应用程序。如果您的业务完全基于向其他公司提供基础架构，那么您的成功仍取决于其运行应用程序的能力。&lt;/p&gt;
&lt;p&gt;如果你建立它，他们不能保证来用。您创建的任何抽象需要提高运行应用程序的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;避免“泄漏抽象”（Leaky Abstraction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象并不完全隐藏抽象的实现细节。泄漏抽象定律指出：“所有非平凡的抽象在一定程度上都是泄漏的。”&lt;/p&gt;
&lt;p&gt;这意味着你进一步抽象某事，隐藏事物的细节就越困难。&lt;/p&gt;
&lt;p&gt;例如，应用程序资源请求通常通过请求 CPU 核心的百分比，内存量和磁盘存储量来抽象化。这些资源的物理分配不直接由应用程序管理（API 不是由它们规定的），但对资源的请求很明显地表明运行应用程序的系统具有可用的这些类型的资源。&lt;/p&gt;
&lt;p&gt;相反，如果抽象是服务器或数据中心（例如，50 台服务器，0.2 个数据中心）的百分比，那么抽象并不具有相同的含义，因为不存在单一大小的服务器或数据中心单元。确保创建的抽象对于将使用它们的应用程序有意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生实践的好处是，随着您提高运行应用程序的能力，您还可以提高运行基础架构的能力。如果您遵循第 3-6 章的模式，您将很好地适应使用应用程序不断改进和调整您的基础架构以满足应用程序的需求。&lt;/p&gt;
&lt;p&gt;重点关注构建范围小，易于适应，易于操作和故障发生时具有弹性的应用程序。确保这些应用程序负责所有基础架构管理和更改。如果你这样做，你将创建云原生基础架构。&lt;/p&gt;
&lt;h2 id=&#34;预测未来&#34;&gt;预测未来&lt;/h2&gt;
&lt;p&gt;如果您已经采用了本书中的模式和实践，那么您现在处于未知领域。运行全球最大基础架构的公司已采用了这些做法。无论他们运行基础架构的新模式是否公开披露或仍在发现之中。&lt;/p&gt;
&lt;p&gt;好消息是您的基础架构现在被设计为敏捷和变化。您可以更轻松地适应您遇到的任何新挑战。&lt;/p&gt;
&lt;p&gt;为了展望未来的道路，我们可以不考虑现有的基础架构模式，而是考虑基础架构在哪里获得灵感 —— 软件。几乎所有基础架构采用的模式都来自软件开发模式。&lt;/p&gt;
&lt;p&gt;例如，分布式应用程序。很多年前，当软件暴露于互联网时，在单一代码库下的单个服务器上运行应用程序不会扩展。这包括管理应用程序的性能和流程限制。&lt;/p&gt;
&lt;p&gt;该应用程序需要复制到其他服务器上，然后进行负载均衡以满足需求。当达到限制时，它被分解成更小的组件，创建 API 以通过 HTTP 远程调用功能，而不是通过应用程序库。&lt;/p&gt;
&lt;p&gt;基础架构采取了类似的方法来扩大规模；在大多数领域只适应比软件更慢的速度。像 Kubernetes 这样的现代化基础架构平台将基础架构管理分解成更小的组件。这些组件可以根据其性能瓶颈（CPU、内存和 I/O）独立扩展，并且可以快速迭代。&lt;/p&gt;
&lt;p&gt;有些应用程序没有相同的扩展需求，也不需要适应新的架构。工程师的需要知道何时采用新技术。只有那些了解其堆栈的局限性和瓶颈的人才能决定什么是正确的方向。&lt;/p&gt;
&lt;p&gt;当发现新的限制时，请密切注意新的解决方案应用程序的发展。如果您了解限制是什么以及进行更改的原因，那么您将始终处于基础架构的领先地位。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;本书的目标是帮助您更好地理解什么是云原生基础架构以及您为什么要采用它。虽然我们相信它比传统基础架构有很多优势，但我们不希望您在不理解它的情况下盲目使用任何技术。&lt;/p&gt;
&lt;p&gt;不要期望在不采用其伴随的文化和流程的情况下获得所有好处。只是在公有云中运行基础架构或运行容器编排器不会改变该基础架构如何适应的过程。&lt;/p&gt;
&lt;p&gt;在 AWS 中手动创建少量虚拟机，通过 SSH 连接到每台虚拟机，创建 Kubernetes 集群比改变人们的工作方式更容易。前者不是云原生的。&lt;/p&gt;
&lt;p&gt;请记住，配置基础架构的应用程序不是及时的静态快照；它们应该不断运行并将基础架构推向期望的状态。管理基础架构不是维护主机。您需要为资源创建抽象，用 API 来表示这些抽象，以及使用它们的应用程序。&lt;/p&gt;
&lt;p&gt;目标是满足您的应用程序的需求，并编写与您的业务流程和工作职能相当的软件应用程序。随着流程和功能的频繁变化，软件需要轻松适应。&lt;/p&gt;
&lt;p&gt;掌握它时，您将不断发现在创建新抽象，保持服务弹性以及推动可伸缩性极限方面的挑战。如果您能够找到新的限制和有用的抽象，请回馈给您所属的社区。&lt;/p&gt;
&lt;p&gt;开源并通过研究和社区回馈是这些模式是使得它们从先驱环境中出现。共享使更多的创新和见解得以传播，并使每个人更容易实践和适应。&lt;/p&gt;
&lt;p&gt;创新不仅来自寻找解决方案或打造下一个出色的产品。创新通常来自寻常的提问、交谈和失败。&lt;/p&gt;
&lt;p&gt;请继续做所有这些事情，尤其是失败和分享。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 A：网络弹性模式</title>
      <link>https://jimmysong.io/book/cloud-native-infra/appendix-a-patterns-for-network-resiilency/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/appendix-a-patterns-for-network-resiilency/</guid>
      <description>
        
        
        &lt;p&gt;在云环境中运行时，应用程序需要具有弹性。网络通信方面特别容易出现故障。添加网络弹性的一种常见模式是创建一个导入到应用程序中的库，该库提供本附录中描述的网络弹性模式。但是，导入的库很难维护以多种语言编写的服务，且当新版本的网络库发布时，会增加应用程序测试和重新部署的负担。&lt;/p&gt;
&lt;p&gt;取代应用程序处理网络弹性逻辑的另一种方式是，可以将代理置于适当的位置，作为应用程序的保护和增强层。代理的优势在于避免应用程序需要额外的复杂代码，尽量减少开发人员的工作量。&lt;/p&gt;
&lt;p&gt;可以在连接层（物理或 SDN），应用程序或透明代理中处理网络弹性逻辑。虽然代理不是传统网络堆栈的一部分，但它们可用于透明地管理应用程序的网络弹性。&lt;/p&gt;
&lt;p&gt;透明代理可以在基础架构中的任何位置运行，但与应用程序的距离越近越有利。代理支持的协议还要尽可能全面，且可以代理的开放系统互连模型（OSI 模型）层。&lt;/p&gt;
&lt;p&gt;通过实施以下模式，代理在基础架构的弹性中扮演着积极的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;负载切分（Load shedding）&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;重试和 deadline&lt;/li&gt;
&lt;li&gt;断路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理也可以用来为应用程序添加功能。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全和认证&lt;/li&gt;
&lt;li&gt;路由（入口和出口）&lt;/li&gt;
&lt;li&gt;洞察和监测&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;p&gt;应用程序负载均衡的方式有很多，应始终将负载均衡器放在云原生应用程序之前的原因有：&lt;/p&gt;
&lt;p&gt;DigitalOcean 在“5 个 DigitalOcean 负载均衡器使用案例”中给出了一些很好的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平缩放&lt;/li&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;应用程序部署&lt;/li&gt;
&lt;li&gt;动态流量路由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;协调透明代理（例如 Envoy 和 Linkerd）是负载均衡应用程序的一种方式。具有透明代理句柄负载均衡的一些好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对所有端点的请求视图允许更好的负载均衡决策。&lt;/li&gt;
&lt;li&gt;基于软件的负载均衡器可灵活选择正确的方式来平衡负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;透明代理不必盲目地将流量传递给下一个路由器。正如 Bunyan 在其博客文章“超越循环：负载均衡延迟”中指出的，他们可以集中协调以对基础架构有更广泛的了解。这使得负载均衡能够从全局优化流量路由，而不是仅为本地优化快速分组切换。&lt;/p&gt;
&lt;p&gt;随着对端点中哪些服务正在发送和接收请求有了更深的了解，代理可以更合理地向发送流量。&lt;/p&gt;
&lt;h2 id=&#34;负载切分&#34;&gt;负载切分&lt;/h2&gt;
&lt;p&gt;“站点可靠性工程”手册解释了负载切分（Load shedding）与负载均衡不同。尽管负载均衡试图找到正确的后端来发送流量，但是如果应用程序无法接受请求，负载剔除会有意地丢弃流量。&lt;/p&gt;
&lt;p&gt;通过删除负载来保护应用程序实例，可以确保应用程序不会重新启动或被迫进入不利条件。删除请求比等待超时并要求重新启动应用程序要快得多。&lt;/p&gt;
&lt;p&gt;当发生中断或流量过多时，减载可以帮助保护应用程序实例。一切正常时，应用程序应该通过服务发现发现其他相关服务。&lt;/p&gt;
&lt;h2 id=&#34;服务发现&#34;&gt;服务发现&lt;/h2&gt;
&lt;p&gt;服务发现通常由运行服务的编排系统处理。透明代理可以绑定到相同的数据并提供附加功能。&lt;/p&gt;
&lt;p&gt;代理可以通过将多个源绑定在一起（例如，DNS 和键值数据库）并将它们呈现在统一接口中来增强标准服务发现。这允许实现者在不重写所有应用程序代码的情况下改变其后端。如果在应用程序之外处理服务发现，则可以更改服务发现工具而不必重写任何应用程序代码。&lt;/p&gt;
&lt;p&gt;由于代理可以对基础架构中的请求提供更全面的视图，因此可以决定端点何时健康与否。这与其他功能配合使用，例如负载均衡和重试，以将流量路由到最佳端点。&lt;/p&gt;
&lt;p&gt;当允许服务彼此发现时，代理服务器还可以考虑额外的元数据。它们可以实现逻辑，如节点延迟或“距离”，以确保为请求发现正确的服务。&lt;/p&gt;
&lt;h2 id=&#34;重试和-deadline&#34;&gt;重试和 deadline&lt;/h2&gt;
&lt;p&gt;通常，应用程序会使用内置逻辑来知道如何处理对外部服务失败的请求。这也可以由代理无需额外的应用程序代码来处理。&lt;/p&gt;
&lt;p&gt;代理拦截应用程序的所有入口和出口流量并路由请求。如果传出请求失败，代理可以自动重试，而无需涉及应用程序。如果请求因任何其他原因返回，则代理可以根据其配置中的规则进行适当处理。&lt;/p&gt;
&lt;p&gt;这很好，只要应用程序对延迟有弹性。否则，代理应根据申请截止日期返回失败通知。&lt;/p&gt;
&lt;p&gt;截止日期允许应用程序指定允许请求的时间长度。由于代理可以“追踪”到目的地和返回的请求，因此它可以在使用代理的所有应用程序中强制执行最终期限策略。&lt;/p&gt;
&lt;p&gt;当超过 deadline 时，失败将返回给应用程序，并且可以决定适当的操作。选项可能会降级服务，但应用程序也可能选择将错误发回给用户。&lt;/p&gt;
&lt;h2 id=&#34;断路&#34;&gt;断路&lt;/h2&gt;
&lt;p&gt;该模式根据家用的断路器命名。当一切正常时，电路默认为“关闭”状态，允许流量流过断路器。当检测到故障时，电路“打开”并切断流量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重试模式使应用程序能够重试操作，以期成功。断路器模式阻止应用程序执行可能失败的操作。&lt;/p&gt;
&lt;p&gt;——Alex Homer，云设计模式：云应用程序指令性架构指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;断开的电路可以是单个端点或整个服务。打开后，不会发送任何流量，所有发送流量的尝试都将立即返回失败。&lt;/p&gt;
&lt;p&gt;与家用电路不同，即使处于打开状态，代理也可以测试失败的端点。当检测到故障后再次可用时，可将损坏的端点置于“半开”状态。此状态将发送少量流量，直到端点被标记为失败或健康。&lt;/p&gt;
&lt;p&gt;这种模式可以使得应用程序快速失败，并且只能发送到健康端点，从而使应用程序更快。通过不断检查端点，网络可以自行修复并智能地路由流量。&lt;/p&gt;
&lt;p&gt;除了这些弹性功能外，代理还可以通过以下方式增强应用程序。&lt;/p&gt;
&lt;h2 id=&#34;tls-和身份验证&#34;&gt;TLS 和身份验证&lt;/h2&gt;
&lt;p&gt;代理可以终止传输层安全性（TLS）或代理支持的任何其他安全性。这使得安全逻辑能够集中管理，而不是在每个应用程序中重新实现。然后可以在整个基础架构中更新安全协议或证书，而无需重新部署应用程序。&lt;/p&gt;
&lt;p&gt;身份验证也是如此。但是，授权仍应由应用程序管理，因为它通常是更细粒度的应用程序特定功能。在应用程序监督它们之前，用户会话 cookie 可以由代理验证。这意味着只有通过认证的流量才会被应用程序看到。&lt;/p&gt;
&lt;p&gt;这不仅可以节省应用程序的时间，还可以防止某些类型的滥用导致的停机。&lt;/p&gt;
&lt;h2 id=&#34;路由入口和出口&#34;&gt;路由（入口和出口）&lt;/h2&gt;
&lt;p&gt;当代理在所有应用程序之前运行时，它们控制流入和流出应用程序的流量。它们还可以管理流入和流出集群的流量。&lt;/p&gt;
&lt;p&gt;正如反向代理可以用于在 N 层体系结构中将流量路由到后端一样，服务代理也可能暴露于集群外部，用来路由到达的请求。这里的代理知道流量的另一个数据点来自何处和目的地。&lt;/p&gt;
&lt;p&gt;具有对所有服务间通信的深入了解的反向代理，可以比传统的反向代理更好地了解路由选择。&lt;/p&gt;
&lt;h2 id=&#34;洞察和监控&#34;&gt;洞察和监控&lt;/h2&gt;
&lt;p&gt;利用所有关于基础架构内流量流的知识，代理系统可以公开关于单个端点和整个集群范围内的流量视图的指标。这些数据点传统上已经在专有网络系统或难以自动化的协议中暴露出来（例如，SNMP）。&lt;/p&gt;
&lt;p&gt;由于代理可以立即知道何时端点无法访问，所以它们也最先了解端点何时不健康。虽然编排系统也可以检查应用程序运行状况，但应用程序可能不知道向编排工具报告不健康的状态。有了对同一服务所有端点的了解后，代理也可以成为监控服务运行状况的最佳位置。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 B：锁定</title>
      <link>https://jimmysong.io/book/cloud-native-infra/appendix-b-lock-in/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/appendix-b-lock-in/</guid>
      <description>
        
        
        &lt;p&gt;关于使用云提供商和避免供应商锁定存在很多争议。这种辩论充满了意识心态之争。&lt;/p&gt;
&lt;p&gt;锁定通常是工程师和管理层关心的问题。应该将其与选择编程语言或框架一样作为应用程序的风险来权衡。编程语言和云提供商的选择是锁定的形式，工程师有责任了解风险并评估这些风险是否可以接受。&lt;/p&gt;
&lt;p&gt;当您选择供应商或技术时，请记住以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁定是不可避免的。&lt;/li&gt;
&lt;li&gt;锁定是一种风险，但并不总是很高。&lt;/li&gt;
&lt;li&gt;不要外包思维。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;锁定是不可避免的&#34;&gt;锁定是不可避免的&lt;/h2&gt;
&lt;p&gt;在技术上有两种类型的锁定：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术锁定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个开发技术栈中底层技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;供应商锁定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数情况下，作为项目的一部分而使用的服务和软件（供应商锁定还可能包括硬件和操作系统，但我们只关注服务）&lt;/p&gt;
&lt;h3 id=&#34;技术锁定&#34;&gt;技术锁定&lt;/h3&gt;
&lt;p&gt;开发人员将选择他们熟悉的技术或为正在开发的应用程序提供最大利益的技术。这些技术可以是供应商提供的技术（例如.NET 和 Oracle 数据库）到开源软件（例如 Python 和 PostgreSQL）。&lt;/p&gt;
&lt;p&gt;在此级别提供的锁定通常要求符合 API 或规范，这将影响应用程序的开发。也可以选择一些替代技术，但是这通常有很高的转换成本，因为技术对应用程序的设计有很大影响。&lt;/p&gt;
&lt;h3 id=&#34;供应商锁定&#34;&gt;供应商锁定&lt;/h3&gt;
&lt;p&gt;供应商，如云提供商，是另一种不同形式的锁定。在这种情况下，您正在消费供应商的资源。这可以是基础架构资源（例如，计算和存储），或者是托管软件（例如，Gmail）。&lt;/p&gt;
&lt;p&gt;消费资源的堆栈越高，应该从消耗的资源（例如 Heroku）中获得的价值就越高。高层次资源是从底层资源中抽离出来的，能产品的生产速度更快。&lt;/p&gt;
&lt;h2 id=&#34;锁定是一种风险&#34;&gt;锁定是一种风险&lt;/h2&gt;
&lt;p&gt;技术锁定通常是一次性决定或与供应商达成使用该技术的协议。如果您不再与供应商达成支持协议，则您的软件不会立即中断 —— 只是变得自我支持。&lt;/p&gt;
&lt;p&gt;开源软件可以在一定程度上减少来自技术的锁定，但并不能完全消除。使用开放标准可以进一步减少锁定，但了解开放标准与开放源代码之间的差异很重要。&lt;/p&gt;
&lt;p&gt;仅仅因为别人编写代码并不能使其成为标准。同样，专有系统可以形成非官方标准，允许从它们迁移出去（如 AWS S3）。&lt;/p&gt;
&lt;p&gt;供应商锁定的原因通常不仅仅是技术锁定，而是因为供应商锁定的风险高于技术风险。如果您不向供应商不支付费用，您的申请将停止运行；你不再能够访问你所支付的资源。&lt;/p&gt;
&lt;p&gt;如前所述，供应商服务提供更多价值，因为它们允许产品开发不需要所有较低级别的实现。不要避免托管服务来消除风险；你应该像对待其他任何事情一样权衡服务的风险和回报。&lt;/p&gt;
&lt;p&gt;如果服务提供标准接口，则风险非常低。接口越是自定义，或者产品越独特，切换的风险就越高。&lt;/p&gt;
&lt;h2 id=&#34;不要外包思维&#34;&gt;不要外包思维&lt;/h2&gt;
&lt;p&gt;本书的目标之一就是帮助您自己做出决定。在不了解建议的背景和是否适用于您的情况下，不要盲目听从其他人的意见或报告。&lt;/p&gt;
&lt;p&gt;如果您可以通过使用托管云服务更快地交付产品，则应该选择一个供应商开始使用。虽然衡量风险是好的，但将大把的时间花费在具有类似解决方案的多家供应商的争论上，又自己构建服务并不能节约您的时间。&lt;/p&gt;
&lt;p&gt;如果多个供应商提供类似的服务，请选择最容易采用的服务。开始使用该服务后，限制将很快显现。选择供应商时最重要的因素是选择一个与您具有相同创新步伐的供应商。&lt;/p&gt;
&lt;p&gt;如果供应商的创新速度比您快，那么您将无法利用其最新技术，还可能不得不花大量时间迁移旧技术。如果供应商的创新过于缓慢，那么您将不得不根据供应商提供的内容构建自己的抽象，而且您不会专注于您的业务目标。&lt;/p&gt;
&lt;p&gt;为了保持竞争力，您可能需要消费尚未拥有标准或替代品的资源（例如，新的和实验性的服务）。不要因为它们会使你陷入这项服务而害怕。重视保持竞争力或失去市场份额的风险，您的竞争对手可能会更快地创新。&lt;/p&gt;
&lt;p&gt;了解您无法避免的风险以及您的业务有多大风险。做可以最大化回报和将风险降至最低的决策。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>附录 C Box：案例研究</title>
      <link>https://jimmysong.io/book/cloud-native-infra/appendix-c-box-case-study/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/cloud-native-infra/appendix-c-box-case-study/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;以下内容最初由 CNCF 发布在 Kubernetes.io 上，并且在此获得许可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 2014 年夏天，Box 对沉淀了十年的硬件和软件基础架构的痛苦，这无法与公司的需求保持一致。&lt;/p&gt;
&lt;p&gt;该平台为超过 5000 万用户（包括政府和大型企业如通用电气公司）管理和共享云中的内容，Box 最初是一个使用 PHP 写的具有数百万行的庞大代码，内置裸机数据中心。它已经开始将单体应用分解成微服务。 “随着我们扩展到全球各地，公有云战争正在升温，我们开始专注于如何在许多不同的环境和许多不同的云基础架构提供商之间运行我们的工作负载”，Box 联合创始人和服务架构师 Sam Ghods 说。 “迄今为止，这是一个巨大的挑战，因为所有这些不同的提供商，特别是裸机，都有非常不同的接口和与合作方式。”&lt;/p&gt;
&lt;p&gt;当 Ghods 参加 DockerCon 时，Box 的云原生之旅加速了。该公司已经认识到，它不能再仅仅使用裸机来运行应用程序，正在研究 Docker 容器化，使用 OpenStack 进行虚拟化以及支持公有云。&lt;/p&gt;
&lt;p&gt;在那次会议上，Google 宣布发布 Kubernetes 容器管理系统，Ghods 成功了。 “我们研究了许多不同的选择，但 Kubernetes 确实很出色，特别是因为 Borg 老兵的团队非常强大，可以以基础架构不可知的方式来运行云软件，”他谈到 Google 内部的容器调度器 Borg。 “事实上，一开始它设计与裸机一样运行，就像我们可以在数据中心内迁移到它一样，然后也使用相同的工具和概念在公有云提供商上运行。”&lt;/p&gt;
&lt;p&gt;另外：Ghods 喜欢 Kubernetes 拥有一套通用的 API 对象，如 pod、服务、副本集和部署，这些对象创建了一个一致的接口来构建工具。 “甚至像 OpenShift 或 Deis 这样的构建在 Kubernetes 之上的 PaaS 层仍然将这些对象视为统一的原则，”他说。 “我们很高兴能够在整个生态系统中共享这些抽象概念，这会产生比我们在其他潜在解决方案中更多的动力。”&lt;/p&gt;
&lt;p&gt;六个月后 Box 在一个生产数据中心的集群中部署了 Kubernetes。Kubernetes 在 0.11 版本之前仍然是测试版。他们从小版本开始：Ghods 的团队在 Kubernetes 上运行的第一个服务就是 Box API 监视器，确认了 Box 可以运行。 “这只是一个让整个管道运作正常的测试服务，”他说。接下来是一些处理作业的守护进程，它们“很好而且安全，因为如果他们遇到任何中断，也不会让来自客户的同步传入请求失败。”&lt;/p&gt;
&lt;p&gt;几个月后，该团队可以发送并要求提供信息的第一个实时服务启动。那时，Ghods 说：“我们对 Kubernetes 集群的稳定性感到满意。我们开始迁移一些服务，然后我们将扩大集群的规模和端口数量，最后每个数据中心的服务器数量大约为 100 台，这些服务器纯粹专用于 Kubernetes。在未来的 12 个月里，这个数字将会增长很多，达到数百甚至数千。“&lt;/p&gt;
&lt;p&gt;在观察开始使用 Kubernetes 进行微服务的团队时，“我们看到正在发布的微服务数量有所增加，”Ghodsnotes 说。 “显然，通过微服务构建软件的方式已被压抑很久，随着灵活性的提高帮助我们的开发人员提高了生产力，并为更好的架构选择做好了准备。”&lt;/p&gt;
&lt;p&gt;Ghods 反映，作为早期采用者，Box 经历了不同的旅程。他说：“我们肯定是在等待某些事情稳定和功能发布，我们在这一步上被锁定，”他说。 “在早期，我们对 Kubectl 应用等组件做了很多贡献，并等待 Kubernetes 发布，然后我们会升级，贡献更多，并来回多次。整个项目从我们第一次在 Kubernetes 上进行实际部署到 GA 需要大约 18 个月的时间。如果我们今天自己来做一遍同样的事情，可能会少于六个月。“&lt;/p&gt;
&lt;p&gt;无论如何，Box 无需为 Kubernetes 做过多修改。Ghods 说：“我们团队在 Box 中实施 Kubernetes 所做的绝大多数工作一直致力于在我们现有的（往往是遗留下来的）基础架构内的工作，例如将我们的基础操作系统从 RHEL6 升级到 RHEL7 或将其整合纳入到我们的监控基础架构 Nagios。但总体而言，Kubernetes 非常灵活，能够适应我们的许多限制因素，并且它在我们的裸机基础架构上运行非常成功。“&lt;/p&gt;
&lt;p&gt;对于 Box 来说，更大的挑战也许是文化上的挑战。Ghods 说：“Kubernetes 和一般的云本身代表了一个非常大的范式转换，并且它不是非常渐进的，”Ghods 说。 “我们可以这样说，Kubernetes 将会解决所有问题，因为它能够以正确的方式做事，一切都会变得更好。但是要记住，它不像其他许多解决方案那样可靠。你不能说这家或那家公司花了多少时间做这件事，因为还没有那么多。我们的团队必须真正为资源而战，因为我们的项目有一点点的恐惧。“&lt;/p&gt;
&lt;p&gt;从经验中学习，Ghods 为经历类似挑战的公司提供了以下两条建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提前和经常交付。对于 Box 来说，服务发现是一个巨大的问题，团队必须决定是建立一个临时解决方案还是等待 Kubernetes 本身满足 Box 的独特要求。经过多次辩论之后，“我们刚开始专注于提供可行的解决方案，然后处理可能在稍后迁移到更原始的解决方案，”Ghods 说。 “无论多么微不足道，团队的上述目标应始终是为基础架构上的实际生产用例服务。这有助于保持团队本身和组织对项目的看法。“&lt;/li&gt;
&lt;li&gt;保持开放的态度，了解公司必须从开发人员那里抽象出什么和没有抽象出什么。早期，团队在 Dockerfiles 之上构建了一个抽象，以帮助确保所有容器镜像具有正确的安全更新。事实证明这是多余的工作，因为容器镜像是不可变的，您可以在构建后扫描它们以确保它们不包含漏洞。因为通过容器化来管理基础架构是一个不连续的飞跃，所以最好先直接使用本地工具学习其独特的优势和注意事项。抽象只能在实际需要出现之后才能建立。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，影响力非常强大。“在 Kubernetes 之前，”Ghods 说，“我们的基础架构非常陈旧，需要 6 个多月才能部署一个新的微服务。现在，一个新的微服务部署时间不到五天。我们正在努力让它达到不到一天。诚然，这六个月的大部分时间都是由于我们的系统有多么糟糕，但裸机本质上是一个难以支持的平台，除非您有像 Kubernetes 这样的系统来帮助管理它。“&lt;/p&gt;
&lt;p&gt;按 Ghods 的估计，Box 距离完成 90％运行在 Kubernetes 上的目标还有几年的时间。 “到目前为止，我们已经完成了一项稳定的，关键任务的 Kubernetes 部署，它提供了很多价值，”他说。 “现在我们 10％左右服务器都运行在 Kubernetes 上，我认为明年我们可能会超过一半。我们正在努力实现所有无状态服务使用案例，并计划在此之后将我们的重点转移到有状态服务。“&lt;/p&gt;
&lt;p&gt;事实上，这就是他在整个行业中的设想：Ghods 预测 Kubernetes 有机会成为新的云平台。Kubernetes 提供了一个涵盖不同云平台的 API，包括裸机，以及“当我们可以针对单一界面进行编程时，我不认为人们已经看到了可能的全部潜力”，他说。 “与 AWS 改变基础架构一样，您不必再考虑服务器或机柜或网络设备，Kubernetes 使您能够专注于您正在运行的软件，这非常令人兴奋。这是愿景。“&lt;/p&gt;
&lt;p&gt;Ghods 指出了已经在开发或最近发布的作为云平台的项目：集群联邦，Dashboard UI 和 CoreOS 的 etcd operator。 “我真的相信这是我在云基础架构中看到的最激动人心的事情，”他说，“因为它是一个前所未有的自动化和智能环境，其基础架构对每个基础架构平台都是可移植和不可知的。”&lt;/p&gt;
&lt;p&gt;由于早期决定使用裸机，Box 不得已开始了 Kubernetes 之旅。但是 Ghods 表示，即使公司现在不必对云提供商不可知，Kubernetes 也可能很快成为行业标准，因为越来越多的工具和扩展是围绕 API 构建的。&lt;/p&gt;
&lt;p&gt;“同样的方式，偏离 Linux 是没有意义的，因为它是如此的标准，”Ghods 说，“我认为 Kubernetes 正在走相同的道路。现在还处于早期阶段 —— 文档仍然需要工作，用于编写和发布 YAML 到 Kubernetes 集群的用户体验仍然很艰难。当你处于潮流最前线时，你可能会做出一些牺牲。但底线是，这是行业发展的方向。从现在开始的三到五年，如果您还会以其他方式运行基础架构，那么真的会让人非常震惊。“&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>深入解读 CNCF 推出的云原生 AI 白皮书</title>
      <link>https://jimmysong.io/blog/cloud-native-ai-whitepaper/</link>
      <pubDate>Tue, 16 Apr 2024 12:54:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cloud-native-ai-whitepaper/</guid>
      <description>
        
        
        &lt;p&gt;2024 年 3 月，在 KubeCon EU 期间，云原生计算基金会（CNCF）发布了首份关于云原生人工智能（CNAI）的详细&lt;a href=&#34;https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/&#34; title=&#34;白皮书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;白皮书&lt;/a&gt;
。这份报告详尽地探讨了将云原生技术与人工智能融合的当前状态、面临的挑战、以及未来的发展方向。本文将对这份白皮书的核心内容进行深入解读。&lt;/p&gt;
&lt;h2 id=&#34;什么是云原生-ai&#34;&gt;什么是云原生 AI？&lt;/h2&gt;
&lt;p&gt;云原生 AI 指的是利用云原生技术原则来构建和部署人工智能应用和工作负载的方法。这包括利用微服务、容器化、声明式 API 和持续集成/持续部署（CI/CD）等云原生技术来增强 AI 应用的可扩展性、可复用性和可操作性。&lt;/p&gt;
&lt;p&gt;下图展示了云原生 AI 的架构，图片根据该白皮书重新绘制。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-ai-whitepaper/cloud-native-ai.svg&#34; data-img=&#34;/blog/cloud-native-ai-whitepaper/cloud-native-ai.svg&#34; alt=&#34;image&#34; data-caption=&#34;云原生 AI 架构&#34;&gt;
    
  
  &lt;figcaption&gt;云原生 AI 架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生-ai-与云原生技术之间的关系&#34;&gt;云原生 AI 与云原生技术之间的关系&lt;/h2&gt;
&lt;p&gt;云原生技术提供了一个灵活、可扩展的平台，使得开发和运行 AI 应用变得更加高效。通过容器化和微服务架构，开发人员可以快速迭代和部署 AI 模型，同时保证系统的高可用性和可扩展性。Kubernetes 和其他云原生工具提供了必要的支持，例如资源调度、自动扩缩容和服务发现等。&lt;/p&gt;
&lt;p&gt;白皮书中给出了两个例子说明云原生 AI 与云原生技术的关系，即在云原生基础架构上运行 AI：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://huggingface.co/blog/hugging-face-endpoints-on-azure&#34; title=&#34;Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openai.com/research/scaling-kubernetes-to-7500-nodes&#34; title=&#34;OpenAI Scaling Kubernetes to 7,500 nodes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAI Scaling Kubernetes to 7,500 nodes&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生-ai-的挑战&#34;&gt;云原生 AI 的挑战&lt;/h2&gt;
&lt;p&gt;尽管云原生技术为 AI 应用提供了坚实的基础，但在将 AI 工作负载与云原生平台整合时，仍然存在一些挑战。这些挑战包括数据准备的复杂性、模型训练的资源需求、以及在多租户环境中保持模型的安全性和隔离性。此外，云原生环境中的资源管理和调度对于大规模 AI 应用尤其关键，需要进一步优化以支持高效的模型训练和推理。&lt;/p&gt;
&lt;h2 id=&#34;云原生-ai-的发展路径&#34;&gt;云原生 AI 的发展路径&lt;/h2&gt;
&lt;p&gt;白皮书中提出了几条云原生 AI 的发展路径，包括改进资源调度算法以更好地支持 AI 负载、开发新的服务网格技术以提高 AI 应用的性能和安全性，以及通过开源项目和社区合作来推动云原生 AI 技术的创新和标准化。&lt;/p&gt;
&lt;h2 id=&#34;云原生-ai-技术景观图&#34;&gt;云原生 AI 技术景观图&lt;/h2&gt;
&lt;p&gt;云原生 AI 涉及到多种技术，从容器和微服务到服务网格和无服务器计算。Kubernetes 是部署和管理 AI 应用的关键平台，而 Istio、Envoy 等服务网格技术则提供了强大的流量管理和安全功能。此外，Prometheus 和 Grafana 等监控工具对于维护 AI 应用的性能和可靠性至关重要。&lt;/p&gt;
&lt;p&gt;下面是白皮书中给出的云原生 AI 景观图。&lt;/p&gt;
&lt;h3 id=&#34;general-orchestration&#34;&gt;General Orchestration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;Volcano&lt;/li&gt;
&lt;li&gt;Armada&lt;/li&gt;
&lt;li&gt;Kuberay&lt;/li&gt;
&lt;li&gt;Nvidia NeMo&lt;/li&gt;
&lt;li&gt;Yunikorn&lt;/li&gt;
&lt;li&gt;Kueue&lt;/li&gt;
&lt;li&gt;Flame&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;distributed-training&#34;&gt;Distributed Training&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubeflow Training Operator&lt;/li&gt;
&lt;li&gt;Pytorch DDP&lt;/li&gt;
&lt;li&gt;TensorFlow Distributed&lt;/li&gt;
&lt;li&gt;Open MPI&lt;/li&gt;
&lt;li&gt;DeepSpeed&lt;/li&gt;
&lt;li&gt;Megatron&lt;/li&gt;
&lt;li&gt;Horovod&lt;/li&gt;
&lt;li&gt;Apla&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ml-serving&#34;&gt;ML Serving&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kserve&lt;/li&gt;
&lt;li&gt;Seldon&lt;/li&gt;
&lt;li&gt;VLLM&lt;/li&gt;
&lt;li&gt;TGT&lt;/li&gt;
&lt;li&gt;Skypilot&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cicd---delivery&#34;&gt;CI/CD - Delivery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubeflow Pipelines&lt;/li&gt;
&lt;li&gt;Mlflow&lt;/li&gt;
&lt;li&gt;TFX&lt;/li&gt;
&lt;li&gt;BentoML&lt;/li&gt;
&lt;li&gt;MLRun&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-science&#34;&gt;Data Science&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Jupyter&lt;/li&gt;
&lt;li&gt;Kubeflow Notebooks&lt;/li&gt;
&lt;li&gt;PyTorch&lt;/li&gt;
&lt;li&gt;TensorFlow&lt;/li&gt;
&lt;li&gt;Apache Zeppelin&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;workload-observability&#34;&gt;Workload Observability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Influxdb&lt;/li&gt;
&lt;li&gt;Grafana&lt;/li&gt;
&lt;li&gt;Weights and Biases (wandb)&lt;/li&gt;
&lt;li&gt;OpenTelemetry&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;automl&#34;&gt;AutoML&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hyperopt&lt;/li&gt;
&lt;li&gt;Optuna&lt;/li&gt;
&lt;li&gt;Kubeflow Katib&lt;/li&gt;
&lt;li&gt;NNI&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;governance--policy&#34;&gt;Governance &amp;amp; Policy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kyverno&lt;/li&gt;
&lt;li&gt;Kyverno-JSON&lt;/li&gt;
&lt;li&gt;OPA/Gatekeeper&lt;/li&gt;
&lt;li&gt;StackRox Minder&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-architecture&#34;&gt;Data Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ClickHouse&lt;/li&gt;
&lt;li&gt;Apache Pinot&lt;/li&gt;
&lt;li&gt;Apache Druid&lt;/li&gt;
&lt;li&gt;Cassandra&lt;/li&gt;
&lt;li&gt;ScyllaDB&lt;/li&gt;
&lt;li&gt;Hadoop HDFS&lt;/li&gt;
&lt;li&gt;Apache HBase&lt;/li&gt;
&lt;li&gt;Presto&lt;/li&gt;
&lt;li&gt;Trino&lt;/li&gt;
&lt;li&gt;Apache Spark&lt;/li&gt;
&lt;li&gt;Apache Flink&lt;/li&gt;
&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;Pulsar&lt;/li&gt;
&lt;li&gt;Fluid&lt;/li&gt;
&lt;li&gt;Memcached&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Alluxio&lt;/li&gt;
&lt;li&gt;Apache Superset&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vector-databases&#34;&gt;Vector Databases&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Milvus&lt;/li&gt;
&lt;li&gt;Chroma&lt;/li&gt;
&lt;li&gt;Weaviate&lt;/li&gt;
&lt;li&gt;Quadrant&lt;/li&gt;
&lt;li&gt;Pinecone&lt;/li&gt;
&lt;li&gt;Extensions
&lt;ul&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Postgres SQL&lt;/li&gt;
&lt;li&gt;ElasticSearch&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;modelllm-observability&#34;&gt;Model/LLM Observability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Trulens&lt;/li&gt;
&lt;li&gt;Langfuse&lt;/li&gt;
&lt;li&gt;Deepchecks&lt;/li&gt;
&lt;li&gt;OpenLLMetry&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后，笔者梳理了以下关键观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开源社区的推动作用&lt;/strong&gt;：白皮书明确指出开源社区对云原生 AI 进步的推动作用，其中包括通过开源项目和广泛的合作来加速创新和降低成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云原生技术的重要性&lt;/strong&gt;：云原生 AI 是按照云原生原则构建和部署的，突出了可重复性和可扩展性的重要性。云原生技术为 AI 应用提供了高效的开发和运行环境，特别是在资源调度和服务可伸缩性方面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存在的挑战&lt;/strong&gt;：尽管云原生 AI 带来了诸多优势，但在数据准备、模型训练资源需求以及模型安全性和隔离性方面，仍面临不少挑战。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;未来发展方向&lt;/strong&gt;：白皮书提出的发展路径包括优化资源调度算法以支持 AI 负载，开发新的服务网格技术以提升性能和安全性，以及利用开源项目和社区合作进一步促进技术创新和标准化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键技术组件&lt;/strong&gt;：云原生 AI 涉及的关键技术包括容器、微服务、服务网格和无服务器计算等，其中 Kubernetes 扮演着 AI 应用部署和管理的中心角色，Istio 和 Envoy 等服务网格技术提供了必要的流量管理和安全保障。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关详情，请下载 &lt;a href=&#34;https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/&#34; title=&#34;云原生 AI 白皮书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生 AI 白皮书&lt;/a&gt;
。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>“寒武纪大爆发”之后的云原生，2021 年走向何处？</title>
      <link>https://jimmysong.io/blog/cloud-native-2021/</link>
      <pubDate>Thu, 28 Jan 2021 08:34:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cloud-native-2021/</guid>
      <description>
        
        
        &lt;p&gt;很荣幸收到 CSDN 的邀请，接受”云原生人物志“专栏采访，其实我从 2017 年起就已经在撰写 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; title=&#34;Kubernetes 和云原生年度总结和新年展望&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 和云原生年度总结和新年展望&lt;/a&gt;
，今天在此聊抒己见，欢迎大家讨论和指正。&lt;/p&gt;
&lt;h2 id=&#34;云原生在演进&#34;&gt;云原生在演进&lt;/h2&gt;
&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生 1.0 的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得&lt;strong&gt;云原生从基础设施层不断向应用架构层挺进&lt;/strong&gt;，我们正处于一个云原生 2.0 的新时代。&lt;/p&gt;
&lt;h2 id=&#34;业界动向&#34;&gt;业界动向&lt;/h2&gt;
&lt;p&gt;最近国内的一些云厂商，如阿里云、腾讯云、华为云陆续发布了各自的云原生相关的架构和实践白皮书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020 年 7，中国信通院发布了《云原生产业白皮书（2020）》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 20 日，在腾讯 2020 Techo Park 开发者大会上，腾讯云正式发布了《云原生最佳实践路线图》，同时发布的还有一份 3 万多字的《腾讯云原生路线图手册》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 23 日，阿里云原生实战峰会上发布了《云原生架构白皮书》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 30 日，华为云在深圳的 TechWave 云原生 2.0 技术峰会上联合 Forrester 发布了《云原生白皮书：拥抱云原生优先战略》。&lt;/li&gt;
&lt;li&gt;2021 年初，阿里巴巴达摩院发布 2021 十大科技趋势，其中将“云原生重塑 IT 技术体系”作为 2021 年技术预测之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生项目的寒武纪大爆发&#34;&gt;云原生项目的“寒武纪大爆发”&lt;/h2&gt;
&lt;p&gt;云原生已历经”寒武纪大爆发“，标志是从 2018 年 Kubernetes 毕业 后走向深耕路线。云原生领域的开源项目层出不穷，令人眼花缭乱，见我收集的 Awesome Cloud Native。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk.jpg&#34; data-width=&#34;945&#34; data-height=&#34;229&#34; alt=&#34;image&#34; data-caption=&#34;云原生发展阶段&#34;&gt;
    
  
  &lt;figcaption&gt;云原生发展阶段&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2020 年 CNCF 共接纳了 35 个项目加入基金会，并且有多个项目毕业或晋级，CNCF 托管的项目总数达到了 80 多个。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh.jpg&#34; data-width=&#34;945&#34; data-height=&#34;679&#34; alt=&#34;image&#34; data-caption=&#34;图片来自 CNCF 年度报告 2020&#34;&gt;
    
  
  &lt;figcaption&gt;图片来自 CNCF 年度报告 2020&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生之争实际上是标准之争&#34;&gt;云原生之争实际上是标准之争&lt;/h2&gt;
&lt;p&gt;PC 端操作系统 Windows 占据上风，移动端是 iOS 和 Android，服务器端是 Linux，而云计算商用分布式操作系统呢？答案是 Kubernetes。&lt;/p&gt;
&lt;p&gt;2020 年 Kubernete 宣布将&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110520682&#34; title=&#34;在 v1.20 版本之后弃用 Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 v1.20 版本之后弃用 Docker&lt;/a&gt;
，实际上 Docker 本来就不是 Kubernetes 中默认和唯一的的容器运行时了，实际上只要是支持 CRI（Container Runtime Interface）或 OCI（Open Container Initiative）标准的容器运行时都可以在 Kubernetes 中运行。如下图所示，容器，英文是 container，也是集装箱的意思，其实集装箱不止一种型号，根据运送的货物的不同特性可以制定了多种集装箱类型。而这个容器类型是标准只能是由 Kubernetes 来定，否则只能是削足适履。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqbb2lj30q90enwpl.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vqbb2lj30q90enwpl.jpg&#34; data-width=&#34;945&#34; data-height=&#34;527&#34; alt=&#34;image&#34; data-caption=&#34;各种容器类型&#34;&gt;
    
  
  &lt;figcaption&gt;各种容器类型&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 统一了云上的资源对象制定和调度的标准，只要在其标准之上开发 CRD 和 Operator 即可。但是这也仅限于单个应用的管理，如何管理复杂的多集群和混合云环境，如何管理应用间流量，如何如何保证调用链的安全？以 Istio 为代表的服务网格就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;云原生趋势云上应用管理&#34;&gt;云原生趋势：云上应用管理&lt;/h2&gt;
&lt;p&gt;Kubernetes 奠定了云原生基础设施的基础，随着而来的监控、存储、AI、大数据等技术的迁移，从单个应用层面来说已经日趋成熟，而在&lt;strong&gt;使用云原生架构尤其是对云上应用的管理&lt;/strong&gt;，而在异构环境、多集群、混合云等已成为常态的情况下，&lt;strong&gt;如何对云上的应用进行管理，成为棘手的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 以其开创新的声明式 API 和调节器模式，奠定了云原生的基础。我们看到 Google 的项目 Anthos，Azure 的 Arc，AWS 最近开源的 EKS-D，它们都是着重在混合云管理，让云无处不在。另外，服务网格（Service Mesh）经过两年的推广和发酵，将会看到越来越多的应用。&lt;/p&gt;
&lt;h2 id=&#34;云原生与开源社区&#34;&gt;云原生与开源社区&lt;/h2&gt;
&lt;p&gt;目前&lt;strong&gt;企业云原生化转型最缺乏的东西 —— 套路和组合拳&lt;/strong&gt;。对于基础软件，企业往往会选择开源项目并根据自身需求进行改造，而云原生的开源项目又有很多，企业不是没有选择，而是选择太多，以致于无从下手。就像下面教你如何画猫头鹰的示例。我们可以将企业的云原生化的愿景想象成是这只猫头鹰，这些开源项目就像步骤一中圆，你可能想当然的认为只要用了 Kubernetes 就是云原生了，这就像画了两个圆，而剩余部分没有人教你如何完成。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y.jpg&#34; data-img=&#34;/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y.jpg&#34; data-width=&#34;945&#34; data-height=&#34;629&#34; alt=&#34;image&#34; data-caption=&#34;如何画猫头鹰&#34;&gt;
    
  
  &lt;figcaption&gt;如何画猫头鹰&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开源社区的核心是面向开发者，就是向开发者灌输如何来画好这只“猫头鹰”的。开源不意味着免费和做慈善，使用开源也是有代价的。&lt;strong&gt;开源社区存在的意义是平衡开发者、终端用户及供应商之间的共同利益&lt;/strong&gt;，而一个中立的开源社区有利于发挥开源的生态优势。&lt;/p&gt;
&lt;p&gt;近年来随着云原生大热，在美国诞生了大量该领域的初创公司，他们基于 AWS、谷歌云、Azure 等提供各种云原生的解决方案，从每次 KubeCon 的赞助商规模上就可以窥知一二。国内该领域的公司目前还不多，而云原生终端用户社区的公司规模上依然跟国外的公司数量有不小的差距。&lt;/p&gt;
&lt;p&gt;云原生社区就是在这样的背景下于 2020 年初由我发起，开始筹备并在 5 月 12 号正式成立，致力于推广云原生技术，构建开发者生态。云原生社区采取 SIG（特别兴趣小组）和 WG（工作组）的组织形式，基于开源项目和不同的专业领域构建研讨组，与厂商合作定期举办线下 meetup，并邀请社区的专家们定期在 B 站的云原生学院进行直播。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;开源应该关注的是终端用户和开发者生态，用 Apache Way 来说就是“社区大于代码”，没有社区的项目是难以长久的。因此我们可以看到国内一些云厂商开源项目之后也会积极投入运营，举行各种各样的活动。我们看到在云原生的推广过程中，CNCF 起到的相当大的作用，2020 年国内也有类似的基金会成立，我们希望看到更多中立的基金会和社区的成立，更多的厂商参与其中，为终端用户提供更佳的解决方案。&lt;/p&gt;
&lt;p&gt;最后感谢 CSDN 宋慧编辑和「CSDN 云计算」的邀请。&lt;/p&gt;
&lt;p&gt;往期报道见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/112293560&#34; title=&#34;梁胜：做开源项目的贡献者没有意义&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;梁胜：做开源项目的贡献者没有意义&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/FL63Zv9Zou86950w/article/details/110433443&#34; title=&#34;华为云 CTO 张宇昕：云原生已经进入深水区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;华为云 CTO 张宇昕：云原生已经进入深水区&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110508201&#34; title=&#34;APISIX 温铭：开源的本质是要拿开发者的杠杆&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX 温铭：开源的本质是要拿开发者的杠杆&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人介绍&#34;&gt;个人介绍&lt;/h2&gt;
&lt;p&gt;在我的职业生涯里先后从事过 Java 开发、大数据运维、DevOps、开源管理等工作，个人爱好是研究并推广开源技术及理念，摄影和旅行。目前在企业级服务网格初创公司 Tetrate 担任 Developer Advocate，同时作为中立的云原生终端用户社区 —— 云原生社区（Cloud Native Community）的负责人。&lt;/p&gt;
&lt;p&gt;我的整个职业生涯都是与开源息息相关的，渊源可以追溯到大学时期。大学时我就开始使用 Linux 系统（Ubuntu）学习，刚进入职场的时候面向的也是 Hadoop 的开源生态及各种开源中间件，2015 起开始接触 Docker，2016 年开始进入云原生领域，2017 年开始写 Kubernetes 领域的第一本开源中文电子书《&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&lt;/a&gt;
》，本书直到如今仍在更新，2018 年在蚂蚁集团做开源管理及服务网格社区 ServiceMesher，2020 年加入基于 Istio、Envoy 和 Apache SkyWalking 等开源项目而构建企业级服务网格的初创公司 Tetrate。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Sun, 18 Oct 2020 14:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/must-read-for-cloud-native-beginner/</guid>
      <description>
        
        
        &lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;
 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; title=&#34;Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt;
 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; title=&#34;CoreOS rkt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;
、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; title=&#34;Mesos Containerizer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt;
 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; title=&#34;LXC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;
。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; title=&#34;服务网格 (Service Mesh)&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt;
 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; title=&#34;Kubernetes 次世代的云原生应用&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt;
 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;
。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; title=&#34;Minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;
、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; title=&#34;MicroK8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;
、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; title=&#34;Docker Desktop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt;
 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; title=&#34;Kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;
。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; title=&#34;Katacoda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt;
 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; title=&#34;Microsoft Bridge to Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt;
 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; title=&#34;telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;
。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; title=&#34;资源管道和全度量管道&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;
。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; title=&#34;Nagios&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt;
 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; title=&#34;Prometheus Alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt;
 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; title=&#34;Awesome Cloud Native/云原生开源项目大全&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;
），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多书籍，建议大家通过阅读&lt;a href=&#34;https://kubernetes.io&#34; title=&#34;官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;
和实践来学习，也可以参考我编写的&lt;a href=&#34;https://jimmysong.io/book/kubernetes-handbook&#34; title=&#34;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的&lt;a href=&#34;https://cloudnative.to&#34; title=&#34;云原生社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;
，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的&lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; title=&#34;云原生学院&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt;
定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Kubernetes 次世代的云原生应用</title>
      <link>https://jimmysong.io/blog/post-kubernetes-era/</link>
      <pubDate>Mon, 01 Jun 2020 18:13:19 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/post-kubernetes-era/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 自开源至今已经走过六个年头了，&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34; title=&#34;云原生时代&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代&lt;/a&gt;
也已到来，我关注云原生领域也四年有余了，最近开始思考云原生的未来走向，特此撰写本文作为&lt;a href=&#34;https://jimmysong.io/guide-to-cloud-native-app&#34; title=&#34;《云原生应用白皮书》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《云原生应用白皮书》&lt;/a&gt;
的开篇，更多关于云原生应用的介绍请转到白皮书中浏览。&lt;/p&gt;
&lt;h2 id=&#34;重点&#34;&gt;重点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;云原生基础设施已渡过了野蛮生长期，正朝着统一应用标准方向迈进。&lt;/li&gt;
&lt;li&gt;Kubernetes 的原语无法完整描述云原生应用体系，且在资源的配置上开发与运维功能耦合严重。&lt;/li&gt;
&lt;li&gt;Operator 在扩展了 Kubernetes 生态的同时导致云原生应用碎片化，亟需一个统一的应用定义标准。&lt;/li&gt;
&lt;li&gt;OAM 的本质是将云原生应用定义中的研发、运维关注点分离，资源对象进行进一步抽象，化繁为简，包罗万象。&lt;/li&gt;
&lt;li&gt;“Kubernetes 次世代”是指在 Kubernetes 成为基础设施层标准之后，云原生生态的关注点正在向应用层过度，近两年来火热的 Service Mesh 正是该过程中的一次有力探索，而基于 Kubernetes 的云原生&lt;strong&gt;应用&lt;/strong&gt;架构的时代即将到来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 已成为云原生应用的既定运行平台，本文以 Kubernetes 为默认平台展开，包括云原生应用的分层模型。&lt;/p&gt;
&lt;h2 id=&#34;云原生的不同发展阶段&#34;&gt;云原生的不同发展阶段&lt;/h2&gt;
&lt;p&gt;Kubernetes 从开源至今已经走过快&lt;a href=&#34;https://jimmysong.io/cloud-native/memo/open-source/&#34; title=&#34;六个年头&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;六个年头&lt;/a&gt;
（2014 年 6 月开源）了，可以说是 Kubernetes 的诞生开启了整个云原生的时代。我粗略的将云原生的发展划分为以下几个时期。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-stages.png&#34; data-img=&#34;/blog/post-kubernetes-era/cloud-native-stages.png&#34; data-width=&#34;2096&#34; data-height=&#34;508&#34; alt=&#34;image&#34; data-caption=&#34;云原生的发展阶段&#34;&gt;
    
  
  &lt;figcaption&gt;云原生的发展阶段&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：孵化期（2014 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2014 年，Google 开源 Kubernetes，在此之前的 2013 年，Docker 开源，DevOps、微服务已变得十分流行，云原生的概念已经初出茅庐。在开源了 Kubernetes 之后，Google 联合其他厂商发起成立了 CNCF，并将 Kubernetes 作为初创项目捐献给了 CNCF。CNCF 作为云原生的背后推手，开始推广 Kubernetes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：高速发展期（2015 年 - 2016 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几年间，Kubernetes 保持着高速发展，并于 2017 年打败了 Docker Swarm、Mesos，确立了容器编排工具领导者的地位。CRD 和 Operator 模式的诞生，大大增强了 Kubernetes 的扩展性，促进了周边生态的繁荣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：野蛮生长期（2017 年 - 2018 年）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2016 年之后的云原生基本都默认运行在 Kubernetes 平台上，2017、2018 年 Google 主导的 Istio、Knative 相继开源，这些开源项目都大量利用了 Kubernetes 的 Operator 进行了扩展，Istio 刚发布时就有 50 多个 CRD 定义。Istio 号称是&lt;a href=&#34;https://jimmysong.io/blog/service-mesh-the-microservices-in-post-kubernetes-era/&#34; title=&#34;后 Kubernetes 时代的微服务&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;后 Kubernetes 时代的微服务&lt;/a&gt;
，它的出现第一次使得云原生以服务（应用）为中心。Knative 是 Google 在基于 Kubernetes 之上开源的 Serverless 领域的一次尝试。2018 年 Kubernetes 正式从 CNCF &lt;a href=&#34;https://www.cncf.io/blog/2018/03/06/kubernetes-first-cncf-project-graduate/&#34; title=&#34;毕业&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;毕业&lt;/a&gt;
，Prometheus、Envoy 也陆续从 CNCF 毕业。CNCF 也与 2018 年修改了 charter，对云原生进行了重定义，从原来的三要素：”应用容器化；面向微服务架构；应用支持容器的编排调度“，修改为”云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API“。这一年，我曾写过两篇 Kubernetes 及云原生发展的年终总结和展望，见 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; title=&#34;2017 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年&lt;/a&gt;
和 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2018-and-outlook-for-2019.html&#34; title=&#34;2018 年&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2018 年&lt;/a&gt;
的预测和总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四阶段：普及推广期（2019 年至今）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过几年的发展，Kubernetes 已经得到的大规模的应用，云原生的概念开始深入人心，Kubernetes 号称是云原生的操作系统，基于 Operator 模式的生态大放异彩。整合 Kubernetes 和云基础设施，研发和运维关注点分离。Kubernetes 到 Service Mesh（后 Kubernetes 时代的微服务），基于 Kubernetes 的 Serverless 都在快速发展，OAM 诞生，旨在定义云原生应用标准。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-开辟了云原生时代&#34;&gt;Kubernetes 开辟了云原生时代&lt;/h2&gt;
&lt;p&gt;Kubernetes 开源之初就继承了 Google 内部调度系统 Borg 的经验，屏蔽掉了底层物理机、虚拟机之间的差异，经过几年时间的发展成为了容器编排标准，进而统一了 PaaS 平台的基础设施层。&lt;/p&gt;
&lt;p&gt;下图是 Kubernetes 原生内置的可以应用到一个 Pod 上的所有控制器、资源对象等。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/kubernetes-concepts.png&#34; data-img=&#34;/blog/post-kubernetes-era/kubernetes-concepts.png&#34; data-width=&#34;800&#34; data-height=&#34;596&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 概念&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes 概念&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自图书 &lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34; title=&#34;Kubernetes Patterns（O’Reilly）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Patterns（O’Reilly）&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 作为云原生基础设施设计之初遵循了以下原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础设施即代码（声明式 API）&lt;/li&gt;
&lt;li&gt;不可变基础设施&lt;/li&gt;
&lt;li&gt;幂等性&lt;/li&gt;
&lt;li&gt;调节器模式（Operator 的原理）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中声明式 API 可谓开创了云原生时代的基调，而调节器模式是 Kubernetes 区别于其他&lt;a href=&#34;https://jimmysong.io/cloud-native-infra/evolution-of-cloud-native-developments.html&#34; title=&#34;云部署形式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云部署形式&lt;/a&gt;
的主要区别之一，这也为后来的 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;Operator 框架的诞生&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator 框架的诞生&lt;/a&gt;
打下了基础。&lt;/p&gt;
&lt;h3 id=&#34;声明式-api&#34;&gt;声明式 API&lt;/h3&gt;
&lt;p&gt;根据声明式 API 可以做应用编排，定义组件间的依赖，通常使用人类易读的 YAML 文件来表示。但是，YAML 文件声明的字段真的就是最终的状态吗？有没有可能动态改变？&lt;/p&gt;
&lt;p&gt;我们在创建 &lt;code&gt;Deployment&lt;/code&gt; 时会指定 Pod 的副本数，但是其实际副本数并不一定是一成不变的。假如集群中还有定义 HPA，那么 Pod 的副本数就可能随着一些外界因素（比如内存、CPU 使用率或者自定义 metric）而改变，而且如果集群中还有运行自定义的控制器话，那么也有可能修改应用的实例数量。在有多个控制器同时控制某个资源对象时，如何确保控制器之间不会发生冲突，资源对象的状态可预期？可以使用&lt;a href=&#34;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#monitoring-admission-webhooks&#34; title=&#34;动态准入控制&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;动态准入控制&lt;/a&gt;
来达到这一点。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-原生应用&#34;&gt;Kubernetes 原生应用&lt;/h3&gt;
&lt;p&gt;我们都知道要想运行一个应用至少需要以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用的业务逻辑（代码）、运行时（可运行的二进制文件、字节码或脚本）。&lt;/li&gt;
&lt;li&gt;应用的配置注入（配置文件、环境变量等），身份、路由、服务暴露等满足应用的安全性和可访问性。&lt;/li&gt;
&lt;li&gt;应用的生命周期管理（各种 Controller 登场）。&lt;/li&gt;
&lt;li&gt;可观察性、可运维、网络和资源及环境依赖、隔离性等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了基于 Kubernetes 原语及 PaaS 平台资源的 Kubernetes 原生应用的组成。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/kubernetes-native-application-motion.gif&#34; data-img=&#34;/blog/post-kubernetes-era/kubernetes-native-application-motion.gif&#34; data-width=&#34;600&#34; data-height=&#34;334&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes 原生应用&#34;&gt;
    
  
  &lt;figcaption&gt;Kubernetes 原生应用&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们都知道 Kubernetes 提供了大量的&lt;a href=&#34;https://kubernetes.io/docs/concepts/&#34; title=&#34;原语&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原语&lt;/a&gt;
，用户可以基于这些原语来编排服务，管理应用的生命周期。上图展示的是基于 Kubernetes 原生应用可以使用的 Kubernetes 原语、扩展及平台层资源，从内向外的对象跟应用程序（业务逻辑）的关联度依次降低，到最外层基本只剩下平台资源依赖，已经与 Kubernetes 几乎没有关系了。该图里仅展示了部分资源和对象（包含阿里巴巴开源的 &lt;a href=&#34;https://github.com/openkruise/kruise&#34; title=&#34;OpenKruise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenKruise&lt;/a&gt;
、Istio），实际上 &lt;a href=&#34;https://operatorhub.io/&#34; title=&#34;Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator&lt;/a&gt;
 资源之丰富，也是 Kubernetes 生态如此繁荣的原因之一。&lt;/p&gt;
&lt;p&gt;Kubernetes 本身的原语、资源对象、配置、常用的 CRD 扩展有几十、上百个之多。开发者需要了解这些复杂的概念吗？我只是想部署一个应用而已！不用所对于应用开发者，即使对于基础实施开发和运维人员也需要很陡峭的学习曲线才能完全掌握它。&lt;/p&gt;
&lt;p&gt;我将 Kubernetes 原生应用所需要的定义和资源进行了分层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心层&lt;/strong&gt;：应用逻辑、服务定义、生命周期控制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离与服务访问层&lt;/strong&gt;：资源限制与隔离、配置、身份、路由规则等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度层&lt;/strong&gt;：各种调度控制器，这也是 Kubernetes 原生应用的主要扩展层；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源层&lt;/strong&gt;：提供网络、存储和其他平台资源；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些不同的层，完全可以将其职责分配给相应的人员，比如核心层是由应用程序开发者负责，将其职责分离，可以很大程度上降低开发和运维的复杂度。&lt;/p&gt;
&lt;p&gt;云原生应用落实到 Kubernetes 平台之上，仅仅利用 Kubernetes 的对象原语已很难描述一个复杂的应用程序，所以诞生了各种各样的 Operator，但这也仅仅解决了单个应用的定义，对于应用的打包封装则无能为力。&lt;/p&gt;
&lt;p&gt;同一个资源对象又有多种实现方式，比如 Ingress 就有 &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1DnsHtdHbxjvHmxvlu7VhzWcWgLAn_Mc5L1WlhLDA__k/edit#gid=0&#34; title=&#34;10 多种实现&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10 多种实现&lt;/a&gt;
，PV 就更不用说，对于对于开发者究竟如何选择，平台如何管理，这都是让人很头疼的问题。而且有时候平台所提供的扩展能力还可能会有冲突，这些能力有的可能互不相干，有的可能会有正交，有的可能完全重合。且应用本身与运维特性之间存在太多耦合，不便于复用。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/resources-motion.gif&#34; data-img=&#34;/blog/post-kubernetes-era/resources-motion.gif&#34; data-width=&#34;600&#34; data-height=&#34;363&#34; alt=&#34;image&#34; data-caption=&#34;资源交集动画&#34;&gt;
    
  
  &lt;figcaption&gt;资源交集动画&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图中不同颜色的方框代表不同的资源类别，红线框代表不能为一个资源同时应用该配置，否则会出现冲突，不同的颜色上面是一个动画，展示的是部分资源组合。图中仅包含了部分 Kubernetes 中的原语和 Istio 中的资源对象组合及自定义扩展，实际上用户可以根据应用的自身特点，基于 Kubernetes 原语和 CRD 创建出千变万化的组合。&lt;/p&gt;
&lt;p&gt;为了管理这些应用诞生出了众多的 &lt;a href=&#34;https://github.com/operator-framework/awesome-operators&#34; title=&#34;Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Operator&lt;/a&gt;
。Kubernetes 1.7 版本以来就引入了&lt;a href=&#34;https://kubernetes.io/docs/concepts/api-extension/custom-resources/&#34; title=&#34;自定义控制器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义控制器&lt;/a&gt;
的概念，该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像 Kubernetes 原生的组件一样，Operator 直接使用 Kubernetes API 进行开发，也就是说它们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods/Services、对正在运行的应用进行扩缩容。&lt;/p&gt;
&lt;p&gt;Operator 的本质是一种调节器模式（Reconciler Pattern）的应用，跟 Kubernetes 本身的实现模式是一样的，用于管理云原生应用，协调应用的实际状态达到预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式的四个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的输入和输出都使用数据结构。&lt;/li&gt;
&lt;li&gt;确保数据结构是不可变的。&lt;/li&gt;
&lt;li&gt;保持资源映射简单。&lt;/li&gt;
&lt;li&gt;使实际状态符合预期状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;云原生应用走向碎片化&#34;&gt;云原生应用走向碎片化&lt;/h2&gt;
&lt;p&gt;利用声明式 API 及调节器模式，理论上可以在 Kubernetes 上部署任何可声明应用，但是在 Operator 出现之前，管理 Kubernetes 上的有状态应用一直是一个难题，随着 Operator 模式的确立，该难题已得以解决，并促进了 Kubernetes 生态的进一步发展。随着该生态的繁荣，有一种碎片化的特征正在显现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生应用碎片化的体现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 模式将运维人员的反应式经验转化成基于 &lt;code&gt;Reconcile&lt;/code&gt; 模式的代码，统一了有状态应用的管理模式，极大得扩展了 Kubernetes 应用生态。&lt;/li&gt;
&lt;li&gt;开发者在引用 Operator 所提供的能力时没有统一的视图，加大了基础设施运维与开发者之间的沟通成本。&lt;/li&gt;
&lt;li&gt;Operator 总体上治理松散，没有统一的管控机制，在同时应用时可能导致互相冲突或无法预期的结果发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有状态应用管理难题&#34;&gt;有状态应用管理难题&lt;/h3&gt;
&lt;p&gt;Kubernetes 对于无状态应用的管理很出色，但是对于有状态应用就不是那么回事了。虽然 StatefulSet 可以帮助管理有状态应用，但是这还远远不够，有状态应用往往有复杂的依赖。声明式的 API 里往往要加载着大量的配置和启动脚本，才能实现一个复杂应用的 Kubernetes 化。&lt;/p&gt;
&lt;p&gt;例如在 2017 年初，Operator Framework 出现之前，需要使用大量的 &lt;code&gt;ConfigMap&lt;/code&gt;、复杂的启动脚本才能&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/migrating-hadoop-yarn-to-kubernetes.html&#34; title=&#34;在 Kubernetes 上定义 Hadoop YARN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Kubernetes 上定义 Hadoop YARN&lt;/a&gt;
 和&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/usecases/running-spark-with-kubernetes-native-scheduler.html&#34; title=&#34;运行 Spark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行 Spark&lt;/a&gt;
。虽然 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/&#34; title=&#34;&amp;lt;code&amp;gt;StatefulSet&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;StatefulSet&lt;/code&gt;&lt;/a&gt;
 号称可以解决有状态应用的部署问题，但是它主要是保证了 Pod 的在启动、伸缩时的顺序和使 Pod 具有稳定的标识。但是很多分布式应用来说并不仅依靠启动顺序就可以保证其状态，根据其在分布式应用中的角色不同（master/worker）而需要有大量的自定义配置，在没有 Operator 之前这些配置通常是通过一些自定义脚本来实现，这些脚本可能存在于应用镜像中，也可以通过 &lt;code&gt;ConfigMap&lt;/code&gt; 挂在到容器运行时，但无论如何这些脚本都可能因为散落在各处，这些脚本还是面向过程的，跟在 Kubernetes 诞生之前的运维方式毫无二致，这极其不便于版本控制和运维管理。&lt;/p&gt;
&lt;h3 id=&#34;operator-统一了-kubernetes-应用运维框架&#34;&gt;Operator 统一了 Kubernetes 应用运维框架&lt;/h3&gt;
&lt;p&gt;Operator 大大增强了 Kubernetes 的可扩展性，丰富了以 Kubernetes 为基础的云原生生态，许多原先不是为 Kubernetes 而构建的应用纷纷通过&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;构建自己的 Operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建自己的 Operator&lt;/a&gt;
 迁移到 Kubernetes 上。还有一些直接基于 Kubernetes 构建的 Service Mesh、Serverless 框架，它们应用 Operator 模式（如 &lt;a href=&#34;https://istio.io&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
、&lt;a href=&#34;https://knative.dev&#34; title=&#34;Knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;
），试图成为云原生应用的基础设施层，补齐 Kubernetes 在服务治理、无服务架构等方面的短板，随着大量的 CRD、Operator 控制器的出现，而 Kubernetes 却无法以应用的视角来管理这些能力及其背后零散的 CRD，这使得云原生应用碎片化。&lt;/p&gt;
&lt;p&gt;Operator 百花齐放，在没有一个大一统的视图之前，各个控制器之间存在着这样的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立&lt;/strong&gt;：互不干涉，比如 Controller 与服务发现之间就不存在冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合&lt;/strong&gt;：例如 &lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt; 同属一类资源（可访问性与路由），就是可组合的（后两者是 Istio 中的 CRD，用于流量管理）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有冲突&lt;/strong&gt;：例如图中的 &lt;code&gt;CronHorizontalPodAutoscaler&lt;/code&gt;（CRD）、&lt;code&gt;HorizontalPodAutoscaler&lt;/code&gt;（Kubernetes 内置），同时使用可能导致无法意料的情况发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是以为这样复杂的关系，导致其无法做到开箱即用，还需要基础设施团队基于云原生社区和生态自己构建出来的，比如&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;应用交付领域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付领域&lt;/a&gt;
的系列开源项目。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用管理工具-helm&#34;&gt;云原生应用管理工具 Helm&lt;/h2&gt;
&lt;p&gt;Kubernetes 之上有很多能力缺失，比如应用构建、发布、管理和运维等，Helm 的出现主要补偿了应用打包和版本管理的缺陷。其中云原生应用的配置包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序启动时加载的配置文件；&lt;/li&gt;
&lt;li&gt;应用程序的运维配置，如资源申请限额；&lt;/li&gt;
&lt;li&gt;应用程序的服务发现配置；&lt;/li&gt;
&lt;li&gt;应用程序的工作负载、发布策略、依赖等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些配置可以存在于 &lt;code&gt;ConfigMap&lt;/code&gt;、&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt; 等 Kubernetes 的多个资源文件中，如何保证应用程序的复用性？应用程序之间有依赖该如何解决？这是时候你可能自然的想到了 Helm。&lt;/p&gt;
&lt;p&gt;云原生应用打包和发布管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Helm 通过 chart 模板，提高了应用程序的复用性并解决了部分依赖问题；&lt;/li&gt;
&lt;li&gt;Chart 仓库提供了云原生应用程序的统一管控视图；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release&lt;/code&gt; 概念的引入，使得云原生应用版本化管理进一步加强；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Helm 主要关注的是 &lt;a href=&#34;https://12factor.net/zh_cn/&#34; title=&#34;12 因素应用&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;12 因素应用&lt;/a&gt;
法则&lt;a href=&#34;https://12factor.net/zh_cn/build-release-run&#34; title=&#34;构建、发布、运行&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建、发布、运行&lt;/a&gt;
这一原则中的”发布”这一环节。下图是 Helm v3 的架构图。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/helm-chart.png&#34; data-img=&#34;/blog/post-kubernetes-era/helm-chart.png&#34; data-width=&#34;600&#34; data-height=&#34;429&#34; alt=&#34;image&#34; data-caption=&#34;Helm3 架构&#34;&gt;
    
  
  &lt;figcaption&gt;Helm3 架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Helm 可以安装本地或者远程的 chart，当 chart 安装到 Kubernetes 中后就会创建一个 release，每次更新该 chart 的配置并执行 &lt;code&gt;helm upgrade&lt;/code&gt;，release 的版本数就会加 1，开发者可以升级 chart 或回滚到历史版本。&lt;/p&gt;
&lt;h3 id=&#34;打包配置和发布&#34;&gt;打包、配置和发布&lt;/h3&gt;
&lt;p&gt;Helm 和 chart 的主要作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序封装&lt;/li&gt;
&lt;li&gt;版本管理&lt;/li&gt;
&lt;li&gt;依赖检查&lt;/li&gt;
&lt;li&gt;便于应用程序分发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;打包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Helm 采用 &lt;a href=&#34;https://helm.sh/docs/topics/charts/&#34; title=&#34;Chart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chart&lt;/a&gt;
 的格式来标准化描述应用，可以将目录打包成版本化的压缩包进行部署理论上一个 Chart 是可以嵌套若干个 Chart 并定义依赖关系，组织形式非常灵活。Helm chart 用于打包 Kubernetes 原生应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用配置参数，在 Chart 中由 &lt;code&gt;values.yaml&lt;/code&gt; 和命令行参数组成。Chart 采用 Go Template 的特性和 &lt;code&gt;values.yaml&lt;/code&gt; 对部署的模板文件进行参数渲染，也可以通过 &lt;code&gt;helm&lt;/code&gt; 命令 &lt;code&gt;--set key=value&lt;/code&gt; 的方式进行参数赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release 代表 Chart 在集群中的运行实例，Helm 围绕 Release 对应用提供了强大的生命周期管理能力，包括 Release 的查询、安装、更新、删除、回滚等。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用&#34;&gt;云原生应用&lt;/h2&gt;
&lt;p&gt;以上关注的点都是基于 Kubernetes 原语的实现，虽然基于 Kubernetes 构建的 PaaS 平台部分屏蔽了底层基础设施的差异，但是仍有很多云服务是无法通过 Kubernetes 创建，或者需要提前创建供 Kubernetes 原生应用使用的，这些应用通常不运行在 Kubernetes 集群中。因此创建和管理一个云原生应用程序需要考虑以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时：ECS、Docker、KataContainer、gVisor 等；&lt;/li&gt;
&lt;li&gt;资源隔离性：多租户、VPC、Namespace、防火墙；&lt;/li&gt;
&lt;li&gt;资源调度：各种类型的 controller；&lt;/li&gt;
&lt;li&gt;网络可达性：Service、Ingress、Egress、Gateway、VirtualService、DestinationRule、LoadBalancer、ServiceEntry 等；&lt;/li&gt;
&lt;li&gt;可观测性：日志、分布式追踪、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、NetworkPolicy、AuthorizationPolicy；&lt;/li&gt;
&lt;li&gt;平台资源申请：数据库、存储等；&lt;/li&gt;
&lt;li&gt;运行与隔离：ECS、Docker、KataContainer 等；&lt;/li&gt;
&lt;li&gt;资源分配和调度：各种控制器；&lt;/li&gt;
&lt;li&gt;环境隔离：Namespace、多租户、VPC、防火墙、LimitRange、Resources；&lt;/li&gt;
&lt;li&gt;可访问性：Service、Ingress、Egress、Gateway、LoadBalancer、VirtualService、DestinationRule、ServiceEntry；&lt;/li&gt;
&lt;li&gt;状态管理：Operator；&lt;/li&gt;
&lt;li&gt;可观察性：日志、监控、指标；&lt;/li&gt;
&lt;li&gt;安全性：SecurityPolicy、ServiceAccount；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云原生应用分层模型&#34;&gt;云原生应用分层模型&lt;/h3&gt;
&lt;p&gt;那么究竟如何来给云原生应用分层，化繁就简？近几年来，基于 Kubernetes 的应用呈爆炸式发展，光是在&lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;应用交付领域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付领域&lt;/a&gt;
的开源项目就达几十个之多。下图展示我根据这些项目的特性而绘制的 App Delivery Landscape。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/post-kubernetes-era/cloud-native-app.png&#34; data-img=&#34;/blog/post-kubernetes-era/cloud-native-app.png&#34; data-width=&#34;1054&#34; data-height=&#34;514&#34; alt=&#34;image&#34; data-caption=&#34;云原生应用的分层模型&#34;&gt;
    
  
  &lt;figcaption&gt;云原生应用的分层模型&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用定义和包装&lt;/strong&gt;：云原生应用的最上层，直接定义云原生应用的组成形式，解决云原生应用之间的依赖关系，并封装成发布包，如 Helm、CNAB，还有云原生变成语言 Pulumi 和 Ballerina，基于 API 的方式来编排云原生应用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载定义&lt;/strong&gt;：基于 Kubernetes Operator，大多是 Serverless 负载，既负责了负载的定义又负责了生命周期管理。&lt;a href=&#34;https://istio.io&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;
 是比较特殊的存在，它不仅管理服务间的流量，还负责安全性、可观察性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用发布和上线&lt;/strong&gt;：关注应用的构建和发布、GitOps、发布策略等，这也是云原生应用全景中最丰富的部分之一；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes 原语&lt;/strong&gt;：Kubernetes 本身提供的原语，Operator 基于此构建；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为我个人分类的云原生应用全景模型，仅限于 Kubernetes 之上的应用，对于其他非 Kubernetes 应用非本文的考虑范围。另外，CNCF SIG App Delivery 中也给出的云原生应用的分层模型，其模型将非 Kubernetes 应用场景也纳入了考虑，详见：&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34; title=&#34;The Dictionary of Cloud-Native App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Dictionary of Cloud-Native App Delivery&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;Platform/Kuberntes，Kubernetes 仅仅是屏蔽了平台的一些差异，但是对于最上层的应用来说，没有涉及，用户需要自己来基于各种开源组件来搭积木。&lt;/p&gt;
&lt;h3 id=&#34;oam开放应用模型&#34;&gt;OAM（开放应用模型）&lt;/h3&gt;
&lt;p&gt;那么以上这么多应用有哪些共性，能不能再进一步抽象呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有应用是都以容器作为运行时环境（ContainerizedWorkload），这是 OAM 中的核心 Workload 类型；&lt;/li&gt;
&lt;li&gt;在应用发布和上线方面，有些是属于应用的运维特征，需要根据实际需求组合和变更，这些是持续变动的部分；&lt;/li&gt;
&lt;li&gt;要实现某些复杂的应用管控，需要使用到多个 CRD 的组合，比如 Istio 中的让流量根据百分比切分到不同的而服务，就需要部署 Istio Operator，并声明 &lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt;，二者同时使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 的 Runtime 的正常流程应该是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用开发者创建自己的 &lt;code&gt;Component&lt;/code&gt;，在 &lt;code&gt;Component&lt;/code&gt; 中描述要应用相关的信息，如应用名称、镜像配置、环境变量等，应用到 Kubernetes cluster 中；&lt;/li&gt;
&lt;li&gt;运维创建各种运维策略，如发布策略、网络策略等等，发布时由 AppConfig 对象关联要发布的 &lt;code&gt;Component&lt;/code&gt; 和本次的运维策略，apply 到集群中，集群的 OAM operator watch 到一次 &lt;code&gt;ApplicationConfiguration&lt;/code&gt;的下发，生成 &lt;code&gt;Component&lt;/code&gt; 对应的 &lt;code&gt;Workload&lt;/code&gt; 和 &lt;code&gt;Trait&lt;/code&gt;，&lt;code&gt;Trait&lt;/code&gt; controller 将本次的 &lt;code&gt;Trait&lt;/code&gt; 策略应用到本次要管理的 &lt;code&gt;Workload&lt;/code&gt; 当中，最终到达终态，完成一次发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OAM 是对 Kubernetes 友好的，一样采用声明式 API 的理念开发。如果你已经编写了现成的 CRD Operator，可以平滑的接入到 OAM 体系中。OAM 以应用为中心，高度可扩展，扩展点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Workload：扩展各种运行时类型，不仅限于容器运行时，还可以定义更多其他运行时，比如 Serverless 负载、虚拟机、数据库、网络等；例如，Pod、无服务器函数、数据存储、消息队列或任何其他类型的工作负载，这些都是应用程序开发人员需要设计一个完整的应用程序所需要的，可以直接引用 Kubernetes 的 CRD；&lt;/li&gt;
&lt;li&gt;Trait：各种运维规则，比如扩缩容、流量控制、安全性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生态&#34;&gt;生态&lt;/h3&gt;
&lt;p&gt;以前 CNCF 的主要关注群体大多是基础设施领域的技术人员，但是自 2019 年 9 月，&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34; title=&#34;CNCF 宣布成立 SIG App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 宣布成立 SIG App Delivery&lt;/a&gt;
 后，CNCF 正在将应用开发者和运维人员更紧密的联系在一起。&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;应用交付 SIG&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用交付 SIG&lt;/a&gt;
 的使命是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在与开发、分发、部署、管理和运行安全的云原生应用相关的领域进行合作，目标是以云原生方式交付应用。&lt;/li&gt;
&lt;li&gt;发展信息资源，包括指南、教程和白皮书，让社区了解最佳实践和应用交付的价值。&lt;/li&gt;
&lt;li&gt;识别合适的项目和现状的差距，定期向 TOC 更新，并以结构化的方式向 TOC 提出行动建议。这包括帮助 TOC 评估和对潜在的新项目进行尽职调查。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 OAM 定义的云原生应用模型已有以下项目支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://crossplane.io/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt;
：这是一个开源的 Kubernetes 扩展组件，适用于主流公有云平台，使用 &lt;code&gt;kubectl&lt;/code&gt; 配置和管理基础架构、服务和应用。对于 OAM 的支持详见&lt;a href=&#34;https://crossplane.io/docs/v0.11/getting-started/run-applications.html&#34; title=&#34;运行应用程序&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行应用程序&lt;/a&gt;
。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://googlecontainertools.github.io/kpt/&#34; title=&#34;KPT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KPT&lt;/a&gt;
：Kpt（发音为 &amp;ldquo;keep&amp;rdquo;）是一个在资源配置之上构建声明性工作流的开源工具。它的 git + YAML 架构意味着它只需与现有的工具、框架和平台一起工作。Kpt 包括了获取、显示、自定义、更新、验证和应用 Kubernetes 配置的解决方案。对 OAM 的支持详见 &lt;a href=&#34;https://googlecontainertools.github.io/kpt/guides/ecosystem/oam/&#34; title=&#34;使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 kpt 来管理由开放应用模型（OAM）定义的自定义 Kubernetes 应用程序&lt;/a&gt;
。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用交付领域相关的开源项目还有很多，详见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native/#application-delivery&#34; title=&#34;Awesome Cloud Native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;基于 Kubernetes 的云原生生态发展至今已有 6 年时间，当前已步入了普及推广阶段。可以说谁云原生应用定义的制高点，就可以掌握云原生的未来。从前我们是新技术浪潮的追随者，现在我们抓住时代的基于，参与标准制定、引领云原生的浪潮！欢迎加入 &lt;a href=&#34;https://oam.dev/&#34; title=&#34;OAM 社区&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM 社区&lt;/a&gt;
，一起参与进来，把国人参与指定的标准推向世界。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.ibm.com/technologies/containers/blogs/kubernetes-helm-3/&#34; title=&#34;Do you know what’s in Helm 3? - developer.ibm.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do you know what’s in Helm 3? - developer.ibm.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/cms/managed-files/cm-oreilly-kubernetes-patterns-ebook-f19824-201910-en.pdf&#34; title=&#34;O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O’Reilly: Kubernetes patterns for designing cloud-native apps - redhat.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#heading=h.h9so53gv5zen&#34; title=&#34;The Dictionary of Cloud-Native App Delivery - docs.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Dictionary of Cloud-Native App Delivery - docs.google.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/Cdw7ISlEqKilGyN9V3Pj&#34; title=&#34;CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 宣布成立应用交付领域小组，正式开启云原生应用时代 - infoq.cn&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/c7A8lOdAKkW25GoqmwOgWg&#34; title=&#34;OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM v1alpha2 新版发布：平衡标准与可扩展性，灵活接入 CRD operator - mp.weixin.qq.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/54633203&#34; title=&#34;Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API 与 Operator，不为人知的开发者战争 - zhuanlan.zhihu.com&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-era/&#34; title=&#34;云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代——投资人视角下的云原生趋势思考 - cloudnative.to&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>OAM（开放应用模型）——定义云原生应用标准的野望</title>
      <link>https://jimmysong.io/blog/oam-intro/</link>
      <pubDate>Wed, 22 Apr 2020 14:18:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/oam-intro/</guid>
      <description>
        
        
        &lt;p&gt;&lt;a href=&#34;https://oam.dev/&#34; title=&#34;OAM（Open Application Model）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM（Open Application Model）&lt;/a&gt;
是阿里巴巴和微软共同开源的云原生应用规范模型，同时开源了基于 OAM 的实现 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34; title=&#34;Rudr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr&lt;/a&gt;
，自 2019 年 10 月宣布开源以来截止本文发稿已经有快半年时间了。&lt;/p&gt;
&lt;p&gt;当前可能大部分人才刚刚开始了解 OAM，所以这篇文章将从最基础出发，为大家介绍 OAM 的诞生背景和要解决的问题，以及它在云原生生态中的作用。&lt;/p&gt;
&lt;h2 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;如果你没有兴趣或者时间阅读下面的全文，那么建议阅读下面这些核心观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAM 的本质是根据软件设计的“兴趣点分离”原则对负责的 DevOps 流程的高度抽象和封装，这背后还是“&lt;strong&gt;康威定律&lt;/strong&gt;”在起作用。&lt;/li&gt;
&lt;li&gt;OAM 仅定义云原生应用的规范，目前推出的 &lt;a href=&#34;https://github.com/oam-dev/rudr&#34; title=&#34;Rudr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr&lt;/a&gt;
 可以看做是 OAM 规范的 Kubernetes 解释器（实验实现），将云原生应用定义翻译成 Kubernetes 的资源对象。&lt;/li&gt;
&lt;li&gt;OAM 与 &lt;a href=&#34;https://crossplane.io/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt;
 将展开合作，就 Kubernetes 式以 API 为中心的应用定义发扬光大，并深度参与 &lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;CNCF SIG App Delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF SIG App Delivery&lt;/a&gt;
，以共同定义云原生应用标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;康威定律（Conway’s Law）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B&#34; title=&#34;康威定律&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;康威定律&lt;/a&gt;
是马尔文·康威（Melvin Conway）1967 年提出的： &amp;ldquo;设计系统的架构受制于产生这些设计的组织的沟通结构。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;oam-简介&#34;&gt;OAM 简介&lt;/h2&gt;
&lt;p&gt;OAM 全称是 Open Application Model，从名称上来看它所定义的就是一种模型，同时也实现了基于 OAM 的我认为这种模型旨在定义了云原生应用的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放（Open）：支持异构的平台、容器运行时、调度系统、云供应商、硬件配置等，总之与底层无关&lt;/li&gt;
&lt;li&gt;应用（Application）：云原生应用&lt;/li&gt;
&lt;li&gt;模型（Model）：定义标准，以使其与底层平台无关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺便说下 CNCF 中的也有几个定义标准的「开源项目」，其中有的项目都已经毕业。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34; title=&#34;SMI（Service Mesh Interface）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SMI（Service Mesh Interface）&lt;/a&gt;
：服务网格接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34; title=&#34;Cloud Events&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Events&lt;/a&gt;
：Serverless 中的事件标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theupdateframework/specification&#34; title=&#34;TUF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TUF&lt;/a&gt;
：更新框架标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe&#34; title=&#34;SPIFFE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE&lt;/a&gt;
：身份安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其中唯独没有应用标准的定义，&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; title=&#34;CNCF SIG App delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF SIG App delivery&lt;/a&gt;
 即是要做这个的。当然既然要制定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。本文将默认底层平台为 Kubernetes。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是从管理大量 CRD 中汲取的经验。&lt;/li&gt;
&lt;li&gt;业务和研发的沟通成本，比如 YAML 配置中很多字段是开发人员不关心的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-基本对象&#34;&gt;OAM 基本对象&lt;/h3&gt;
&lt;p&gt;OAM 模型中包含以下基本对象，以本文发稿时的最新 API 版本 &lt;code&gt;core.oam.dev/v1alpha2&lt;/code&gt; 为准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/4.component.md&#34; title=&#34;&amp;lt;strong&amp;gt;Component&amp;lt;/strong&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/a&gt;
：OAM 中最基础的对象，该配置与基础设施无关，定义负载实例的运维特性。例如一个微服务 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/3.workload.md&#34; title=&#34;workload&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;workload&lt;/a&gt;
 的定义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/6.traits.md&#34; title=&#34;&amp;lt;strong&amp;gt;TraitDefinition&amp;lt;/strong&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;TraitDefinition&lt;/strong&gt;&lt;/a&gt;
：一个组件所需的&lt;strong&gt;运维策略与配置&lt;/strong&gt;，例如环境变量、Ingress、AutoScaler、Volume 等。（注意：该对象在 &lt;code&gt;apiVersion: core.oam.dev/v1alpha1&lt;/code&gt; 中的名称为 &lt;code&gt;Trait&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/5.application_scopes.md&#34; title=&#34;&amp;lt;strong&amp;gt;ScopeDefinition&amp;lt;/strong&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ScopeDefinition&lt;/strong&gt;&lt;/a&gt;
：多个 Component 的共同边界。可以根据组件的特性或者作用域来划分 Scope，一个 Component 可能同时属于多个 Scope。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/7.application_configuration.md&#34; title=&#34;&amp;lt;strong&amp;gt;ApplicationConfiguration&amp;lt;/strong&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;ApplicationConfiguration&lt;/strong&gt;&lt;/a&gt;
：将 Component（必须）、Trait（必须）、Scope（非必须）等组合到一起形成一个完整的应用配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;oam-api-的演变&#34;&gt;OAM API 的演变&lt;/h3&gt;
&lt;p&gt;因为 OAM 还处在发展早起，API 变化较快，以上四个对象在不同的 API 版本中的 &lt;code&gt;kind&lt;/code&gt; 名称不同，请大家使用时注意区别。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;core.oam.dev/v1alpha1&lt;/th&gt;
&lt;th&gt;core.oam.dev/v1alpha2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Component&lt;/td&gt;
&lt;td&gt;ComponentSchematic&lt;/td&gt;
&lt;td&gt;Component&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trait&lt;/td&gt;
&lt;td&gt;Trait&lt;/td&gt;
&lt;td&gt;TraitDefinition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scope&lt;/td&gt;
&lt;td&gt;Scope&lt;/td&gt;
&lt;td&gt;ScopeDefinition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Application configuration&lt;/td&gt;
&lt;td&gt;ApplicationConfiguration&lt;/td&gt;
&lt;td&gt;ApplicationConfiguration&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总的来说，OAM 模型对象的定义格式与 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields&#34; title=&#34;Kubernetes 对象的类型字段&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 对象的类型字段&lt;/a&gt;
相似。关于 OAM 的基本概念模型的更多信息请访问 &lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/2.overview_and_terminology.md&#34; title=&#34;Overview and Terminology&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Overview and Terminology&lt;/a&gt;
。&lt;/p&gt;
&lt;h3 id=&#34;oam-工作原理&#34;&gt;OAM 工作原理&lt;/h3&gt;
&lt;p&gt;下图来自阿里云原生应用平台团队孙健波在 &lt;strong&gt;《OAM:云原生时代的应用模型与 下一代 DevOps 技术》&lt;/strong&gt; 中的分享，OAM 的工作原理如下图所示，OAM Spec 定义了云原生应用的规范（使用一些列 CRD 定义），Rudr 可以看做是 OAM 规范的解析器，将应用定义翻译为 Kubernetes 中的资源对象。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/oam-intro/oam-principle.png&#34; data-img=&#34;/blog/oam-intro/oam-principle.png&#34; data-width=&#34;2568&#34; data-height=&#34;1388&#34; alt=&#34;image&#34; data-caption=&#34;OAM 的原理&#34;&gt;
    
  
  &lt;figcaption&gt;OAM 的原理&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以将上图分为三个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;汇编层&lt;/strong&gt;：即人工或者使用工具来根据 OAM 规范定义汇编出一个云原生应用的定义，其中包含了该应用的工作负载和运维能力配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转义层&lt;/strong&gt;：汇编好的文件将打包为 YAML 文件，由 Rudr 或其他 OAM 的实现将其转义为 Kubernetes 或其他云服务（例如 Istio）上可运行的资源对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行层&lt;/strong&gt;：执行经过转义好的云平台上的资源对象并执行资源配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rudr&#34;&gt;Rudr&lt;/h2&gt;
&lt;p&gt;Rudr 是对  &lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.1&#34; title=&#34;OAM v1alpha1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM v1alpha1&lt;/a&gt;
 在 Kubernetes 环境下的实现，OAM 正在与 &lt;a href=&#34;https://github.com/crossplane/&#34; title=&#34;Crossplane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt;
 合作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Crossplane&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Kubernetes 社区开创的以 API 为中心的声明式配置和自动化方法，使基础设施和应用管理标准化。官方网站：&lt;a href=&#34;https://crossplane.io/&#34; title=&#34;https://crossplane.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://crossplane.io/&lt;/a&gt;
。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安装-rudr&#34;&gt;安装 Rudr&lt;/h3&gt;
&lt;p&gt;请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/setup/install.md&#34; title=&#34;Rudr 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rudr 文档&lt;/a&gt;
安装，主要依赖以下组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;li&gt;helm 3&lt;/li&gt;
&lt;li&gt;Kubernetes 1.15+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行下面的命令安装 Rudr 和需要的 trait。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 克隆项目&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/oam-dev/rudr.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rudr
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建一个名为 oam 的 namespace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create namespace oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装 Rudr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install rudr ./charts/rudr --wait -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 要使用 ingress trait，推荐安装 Nginx ingress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install nginx-ingress stable/nginx-ingress
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 要使用 autoscaler trait，安装 HorizontalPodAutoscaler&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add kedacore https://kedacore.github.io/charts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install keda kedacore/keda -n oam
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看当前 oam namespace 下的所有 pod，你会发现已创建了以下 pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pod -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                              READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;keda-operator-b6466c989-pn25n                     1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;keda-operator-metrics-apiserver-6cf88c468-k5wd8   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          63m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nginx-ingress-controller-787bd69d8-n6v8c          1/1     Running   &lt;span class=&#34;m&#34;&gt;15&lt;/span&gt;         7d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;nginx-ingress-default-backend-7c868597f4-vvddn    1/1     Running   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;          7d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rudr-c648c9b7b-knj9b                              1/1     Running   &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt;          7d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;部署示例&#34;&gt;部署示例&lt;/h2&gt;
&lt;p&gt;我们使用 OAM 官方提供的教程 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/tutorials/deploy_and_update.md&#34; title=&#34;Tutorial: Deploy, inspect, and update a Rudr application and its components&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tutorial: Deploy, inspect, and update a Rudr application and its components&lt;/a&gt;
 中的 Python &lt;a href=&#34;https://palletsprojects.com/p/flask/&#34; title=&#34;flask&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;flask&lt;/a&gt;
 示例，该示例基于 OAM v1alpha1 API，最新版 API 的示例可以参考 &lt;a href=&#34;https://github.com/oam-dev/crossplane-oam-sample&#34; title=&#34;crossplane-oam-sample&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;crossplane-oam-sample&lt;/a&gt;
。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 部署 Component&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f examples/helloworld-python-component.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时 get pod 会发现并没有创建任何新的 pod，因为 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/helloworld-python-component.yaml&#34; title=&#34;examples/helloworld-python-component.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/helloworld-python-component.yaml&lt;/a&gt;
 文件中只定义了一个名为 &lt;code&gt;helloworld-python-v1&lt;/code&gt; 的 &lt;code&gt;ComponentSchematic&lt;/code&gt;，但是 &lt;code&gt;ComponentSchematic&lt;/code&gt; 是仅仅是定义了一个组件而已，还无法直接创建 pod 的，还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 绑定才可以创建应用的 pod。&lt;/p&gt;
&lt;p&gt;关于该示例的详细信息请参考 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/docs/how-to/create_component_from_scratch.md&#34; title=&#34;Python flask 示例&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python flask 示例&lt;/a&gt;
的创建步骤。&lt;/p&gt;
&lt;h3 id=&#34;创建应用配置&#34;&gt;创建应用配置&lt;/h3&gt;
&lt;p&gt;在部署了 &lt;code&gt;ComponentSchematic&lt;/code&gt; 之后我们还需要创建一个 &lt;code&gt;ApplicationConfiguration&lt;/code&gt; 将其与 &lt;code&gt;Trait&lt;/code&gt; 资源绑定才可以创建应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前已有的 Trait&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装 Rudr 时已在 oam namespace 中部署了一些 trait，使用下面的命令查看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get trait -n oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME             AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto-scaler      7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;empty            7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ingress          7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;manual-scaler    7d1h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;volume-mounter   7d1h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34; title=&#34;examples/first-app-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/first-app-config.yaml&lt;/a&gt;
 中将 &lt;code&gt;ComponentSchematic&lt;/code&gt; 与 ingress &lt;code&gt;Trait&lt;/code&gt; 联系起来。一个完整的可部署的应用配置 &lt;a href=&#34;https://github.com/oam-dev/rudr/blob/master/examples/first-app-config.yaml&#34; title=&#34;examples/first-app-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/first-app-config.yaml&lt;/a&gt;
 的内容如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;core.oam.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ApplicationConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;first-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;components&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;componentName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-python-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 引用了上文中的 Component&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;instanceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;first-app-helloworld-python-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parameterValues&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Rudr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;9999&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;traits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Ingress 引用，Rudr 已默认创建&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;properties&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行下面的命令部署应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f examples/first-app-config.yaml -n oam
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若此时查看 oam namespace 下的 pod 将发现有一个新的 pod 创建。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pod -o oam
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                              READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;first-app-helloworld-python-v1-69945684c7-wfd82   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          16m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;p&gt;执行下面的命令可以测试刚安装的应用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将 Python flask 应用的 pod 暴露到本机&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;POD_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get pods -l &lt;span class=&#34;s2&#34;&gt;&amp;#34;oam.dev/instance-name=first-app-helloworld-python-v1,app.kubernetes.io/name=first-app&amp;#34;&lt;/span&gt; -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.items[0].metadata.name}&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward &lt;span class=&#34;nv&#34;&gt;$POD_NAME&lt;/span&gt; 9999:9999
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Forwarding from 127.0.0.1:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Forwarding from &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;::1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;:9999 -&amp;gt; &lt;span class=&#34;m&#34;&gt;9999&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器中访问 &lt;a href=&#34;http://127.0.0.1:9999&#34; title=&#34;http://127.0.0.1:9999&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://127.0.0.1:9999&lt;/a&gt;
 将看到 &lt;code&gt;Hello Rudr!&lt;/code&gt; 的输出，这表示测试成功。&lt;/p&gt;
&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;
&lt;p&gt;从以上描述中可以看出 OAM 对于定义云原生应用标准的野望，其目标不仅限于 Kubernetes 之上的又一上层抽象，而是对于一切云服务，在基于资源对象的基础上，Trait 来控制 Kubernetes 中的一众高层次非可调度的资源对象，如 AutoScaler、Volume、Ingress，Istio 中的流量配置对象 VirtualService、DestinationRule 等，还可容纳更多的云服务，对于 Serverless 时代的去基础设施化的思想不谋而合，OAM 与 Crossplane 的合作及 CNCF SIG App Delivery 的未来可期。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://oam.dev&#34; title=&#34;OAM 官方网站 - oam.dev&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM 官方网站 - oam.dev&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>TheNewStack 云原生 Devops 报告解读</title>
      <link>https://jimmysong.io/blog/cloud-native-devops-book/</link>
      <pubDate>Sun, 02 Jun 2019 18:13:19 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cloud-native-devops-book/</guid>
      <description>
        
        
        &lt;p&gt;本书的主旨是：如果没有成熟的 DevOps 实践，云原生是玩转不起来的。DevOps 已经不是什么新鲜的话题，但到底什么是 &amp;ldquo;Cloud Native DevOps”及如何实践 Cloud Native DevOps，这正是本书要探讨的内容。&lt;/p&gt;
&lt;p&gt;DevOps 正在经历一次转型，从自动化构建到声明式基础设施、微服务和 Serverless。大部分人对云原生存在误解，以为&lt;code&gt;云原生&lt;/code&gt;就是&lt;code&gt;运行在云上&lt;/code&gt;，其实云原生更偏向于一种理念，即应用的定义及架构方式，而不是将应用运行在哪里。而云上的 DevOps 与传统的 DevOps 有什么区别，开发者和运维人员在云原生时代如何转型？也许本书会给你答案。&lt;/p&gt;
&lt;h2 id=&#34;关于本书&#34;&gt;关于本书&lt;/h2&gt;
&lt;p&gt;本书是由 &lt;a href=&#34;https://thenewstack.com&#34; title=&#34;TheNewStack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack&lt;/a&gt;
 出品的免费电子书，可以在 &lt;a href=&#34;https://thenewstack.io/ebooks/devops/cloud-native-devops-2019/&#34; title=&#34;TheNewStack 网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack 网站&lt;/a&gt;
 上获取本书的电子版，同时推荐 &lt;a href=&#34;https://thenewstack.io/ebooks&#34; title=&#34;TheNewStack 的电子书系列&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheNewStack 的电子书系列&lt;/a&gt;
，囊括了容器、微服务、Kubernetes、云原生诸多主题，可以作为企业决策的参考读物。&lt;/p&gt;
&lt;p&gt;本书是 TheNewStack 编辑集结 DevOps 领域的专家在各种大会上的发言、演讲，有很多观点引用，并结合了一些调查问卷数据展示了一幅云原生 DevOps 的趋势与全景图，下文中我会找一些代表性的观点和图表来说明。&lt;/p&gt;
&lt;p&gt;下面是本书目录，一共分为三大部分：构建、部署和管理，其中前两个部分还给出了参考书目、示例研究等。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/a.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/a.jpg&#34; data-width=&#34;770&#34; data-height=&#34;1058&#34; alt=&#34;image&#34; data-caption=&#34;云原生 DevOps 目录&#34;&gt;
    
  
  &lt;figcaption&gt;云原生 DevOps 目录&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;谁适合读这本书&#34;&gt;谁适合读这本书&lt;/h2&gt;
&lt;p&gt;IT 经理、CIO、团队领导者，希望规划自己公司或团队的云原生化 DevOps 的实践路径以面对大规模场景。&lt;/p&gt;
&lt;h2 id=&#34;云原生化的-devops&#34;&gt;云原生化的 DevOps&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;云原生是对业务价值和团队功能的重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生化的 DevOps 在应用的管理上与原始的 DevOps 最大的区别就是——使用 YAML 文件配置的声明式基础设施（Declarative infrastructure）与应用程序的代码本身放在同一个存储库中，这些 &lt;code&gt;代码&lt;/code&gt; 将由开发团队来维护，而运维团队的职能将转变为基础设施的构建者，服务安全性、健壮性、可见性及耐用性的守护者。&lt;/p&gt;
&lt;p&gt;AWS 的 Serverless 布道师 Chris Munns 早已甚至预测到 2025 年非云供应商的运维人员将不复存在，虽然听上去有点危言耸听，但这也是为传统 IT 运维人员的职业生涯敲响的警钟。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/b.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/b.jpg&#34; data-width=&#34;1682&#34; data-height=&#34;974&#34; alt=&#34;image&#34; data-caption=&#34;云原生 DevOps 高亮部分&#34;&gt;
    
  
  &lt;figcaption&gt;云原生 DevOps 高亮部分&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开发接手了原来传统运维的一些职责，如配置和发布，减少了每次发布的成本，而运维的职责向管理整个系统的复杂性转变，例如转变为 SRE（Site Reliability Engineer）。&lt;/p&gt;
&lt;h2 id=&#34;工作流自动化的价值&#34;&gt;工作流自动化的价值&lt;/h2&gt;
&lt;p&gt;DevOps 的原始教义：DevOps 不是一种工具或流程，而是一种重视整个组织的持续沟通、协作、集成和自动化的实践。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cloud-native-devops-book/c.jpg&#34; data-img=&#34;/blog/cloud-native-devops-book/c.jpg&#34; data-width=&#34;1968&#34; data-height=&#34;1300&#34; alt=&#34;image&#34; data-caption=&#34;工作流自动化的五个案例&#34;&gt;
    
  
  &lt;figcaption&gt;工作流自动化的五个案例&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据自动化的驱动力及持续时间的长短，将 Workflow Automation 划分为五个类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务流程自动化&lt;/li&gt;
&lt;li&gt;分布式系统通信&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;编排&lt;/li&gt;
&lt;li&gt;决策自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运维需要做出的转变&#34;&gt;运维需要做出的转变&lt;/h2&gt;
&lt;p&gt;Damon Edwards 提出于运维需要面对的四个灾难（&lt;a href=&#34;https://zh.wikipedia.org/wiki/%e5%90%af%e7%a4%ba%e5%bd%95%e4%b8%ad%e7%9a%84%e5%9b%9b%e9%aa%91%e5%a3%ab&#34; title=&#34;圣经启示录中的四骑士&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;圣经启示录中的四骑士&lt;/a&gt;
）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silos（孤岛）&lt;/li&gt;
&lt;li&gt;Ticket queues（无尽的低效的工单）&lt;/li&gt;
&lt;li&gt;Toil（干脏活累活的辛勤）&lt;/li&gt;
&lt;li&gt;Low trust（低信任度）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要向云原生 DevOps 转变就要克服以上几个问题。&lt;/p&gt;
&lt;h2 id=&#34;devops-领域的扩展&#34;&gt;DevOps 领域的扩展&lt;/h2&gt;
&lt;p&gt;本书第三章中提到 DevOps 的领域扩展到 Security 和 Networking。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了维持合规的编程语言&lt;/li&gt;
&lt;li&gt;容器镜像扫描&lt;/li&gt;
&lt;li&gt;基于策略的网络安全&lt;/li&gt;
&lt;li&gt;金丝雀测试&lt;/li&gt;
&lt;li&gt;运行时的威胁检测&lt;/li&gt;
&lt;li&gt;日志分析&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>CNCF 年度报告解读（2018 年）</title>
      <link>https://jimmysong.io/blog/cncf-annual-report-2018-review/</link>
      <pubDate>Wed, 13 Feb 2019 17:23:01 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cncf-annual-report-2018-review/</guid>
      <description>
        
        
        &lt;p&gt;2019 年 2 月初，CNCF 发布了 2018 年的年度报告，这是 CNCF 继 2017 年度报告之后，第二次发布年度报告，2017 年度的报告只有区区 14 页，今年的报告长度增长了一倍达 31 页。下面我将带大家一起来深度解读下这份 2018 年的年度报告，一窥 CNCF 过去一年里在推广云原生的道路上取得的进展。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文最后附上了 2017 年和 2018 年度的报告下载地址。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;cncf-年度报告涵盖的范围&#34;&gt;CNCF 年度报告涵盖的范围&lt;/h2&gt;
&lt;p&gt;在解读 CNCF 的 2018 年度报告之前，我们先简单回顾下&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; title=&#34;2017 年度的报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度的报告&lt;/a&gt;
，因为 2017 年度报告是 CNCF 的首份年度报告，这样我们也能更好的了解 CNCF 的来龙去脉。&lt;/p&gt;
&lt;p&gt;2017 年度报告已经基本确定了 CNCF 每个年度报告所包含的主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我定位&lt;/li&gt;
&lt;li&gt;会员参与情况&lt;/li&gt;
&lt;li&gt;终端用户社区&lt;/li&gt;
&lt;li&gt;项目更新&lt;/li&gt;
&lt;li&gt;会议和活动&lt;/li&gt;
&lt;li&gt;社区&lt;/li&gt;
&lt;li&gt;培训和认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为 CNCF 主要的市场活动，2017 年时其成立的第二年，经过一年时间的筹备，这一年里各种市场活动都已经开始确立并有声有色的开展了起来，包括 KubeCon、成员单位、终端用户都已经发展起来了，以后历年里只是对其不断的发展和完善。&lt;/p&gt;
&lt;p&gt;2018 年度报告中又新增了一些主题，这些主题是从 2018 年开始开展的，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;项目更新与满意度调查&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;给 CNCF 项目的维护者发调查问卷询问满意度&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;CNCF charter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF charter&lt;/a&gt;
 的修订（2018 年 11 月）&lt;/li&gt;
&lt;li&gt;项目更新与发布&lt;/li&gt;
&lt;li&gt;项目服务与支援&lt;/li&gt;
&lt;li&gt;专项活动、文档、网站与博客支持&lt;/li&gt;
&lt;li&gt;本地化、IT 支持和培训&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社区拓展&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;社区奖项&lt;/li&gt;
&lt;li&gt;CNCF Meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;CNCF Ambassador 计划&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassador 计划&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;卡通吉祥物 Phippy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态系统工具&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devstats.cncf.io/&#34; title=&#34;devstats&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;devstats&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt;
 和路线图&lt;/li&gt;
&lt;li&gt;项目 logo 物料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试一致性项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国际化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进入中国&lt;/li&gt;
&lt;li&gt;本地化网站&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请大家从本文最后的链接下载报告原文以查看详情。&lt;/p&gt;
&lt;h2 id=&#34;cncf-的定位&#34;&gt;CNCF 的定位&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）成立于 2015 年 12 月 11 日，每届年度报告的开篇都会阐明 CNCF 的定位，CNCF 的自我定位在 2018 年发生了一次变动，这也说明基金会是跟随市场形势而动，其定位不是一成不变的，其中的变化暗含着 CNCF 战略的转变。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2017-年度定位&#34;&gt;CNCF 的 2017 年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; title=&#34;2017 年度报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度报告&lt;/a&gt;
中是这样正式介绍自己的：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud-native computing universal and sustainable. Cloud-native computing uses an &lt;strong&gt;open source&lt;/strong&gt; software stack to deploy applications as &lt;strong&gt;microservices&lt;/strong&gt;, packaging each part into its own &lt;strong&gt;container&lt;/strong&gt;, and &lt;strong&gt;dynamically orchestrating&lt;/strong&gt; those containers to optimize resource utilization. Cloud-native technologies enable software developers to build great products faster.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Envoy and Prometheus. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;可以看到介绍中的重点技术是：微服务、容器、动态编排。而在 2018 年 CNCF 对自己进行了重新的定位和包装，增加了新的内容。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2018-年度定位&#34;&gt;CNCF 的 2018 年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; title=&#34;2018 年度报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2018 年度报告&lt;/a&gt;
中 CNCF 对自己的定位是：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. &lt;strong&gt;Containers&lt;/strong&gt;, &lt;strong&gt;service meshes&lt;/strong&gt;, &lt;strong&gt;microservices&lt;/strong&gt;, &lt;strong&gt;immutable infrastructure&lt;/strong&gt;, and &lt;strong&gt;declarative APIs&lt;/strong&gt; exemplify this approach.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Prometheus, Envoy, and many others. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;我们可以看到其表述中更加注重多云环境，主要涉及的技术比 2017 年多了 Service Mesh（服务网格）、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;h2 id=&#34;数读报告&#34;&gt;数读报告&lt;/h2&gt;
&lt;p&gt;CNCF 年度报告的原文主要是汇报了 CNCF 一年来的所展开的活动和进展，下表示根据 CNCF 2017 和 2018 年度报告整理了关键数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Year&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;170&lt;/td&gt;
&lt;td&gt;365&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Contributors&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;18687&lt;/td&gt;
&lt;td&gt;47358&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CNCF Meetup Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;53925&lt;/td&gt;
&lt;td&gt;89112&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Projects&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;End User Community Members&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Conference and Events Participants&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;4085&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Certified Kubernetes Partners&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Certified Kubernetes Service Providers&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;74&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CNCF Ambassador&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Kubernetes Training Partners&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：其中 2016 年是 CNCF 正式开始工作的第一年，大部分数据因为活动尚未开展而缺失。&lt;/p&gt;
&lt;p&gt;从上表中我们可以看到 CNCF 诞生三年来基金会成员规模、托管项目的贡献者、参加 CNCF 名义的 Meetup 的人数取得较大范围的增长，尤其是 2018 年，因为基金会成员的爆发式增长（+130%），CNCF 开始给成员分级，会员级别、费用和权益也在 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; title=&#34;CNCF 官网&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 官网&lt;/a&gt;
上明码标价。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 组织的 KubeCon&amp;amp;CloudNativeCon 开始固定每年在西欧、北美和中国举行，且 2018 年是首次进入中国；原来的 Certified Kubernetes Partners 也取消了变成了 Certified Kubernetes Service Providers；CNCF 的 &lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;Ambassador&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador&lt;/a&gt;
 计划拥有了来自 15 个国家的 65 位 Ambassador，在世界各地为云原生布道；CNCF 还首次引入了 Kubernetes Training Partner。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 又推出了一系列新的认证（CKA 为 2017 年推出），包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/cka/&#34; title=&#34;CKA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKA&lt;/a&gt;
（Kubernetes 管理员认证）：这是 CNCF 最早制定的一个证书，顾名思义，通过该认证证明用户具有管理 Kubernetes 集群的技能、知识和能力。虽然该证书在 2017 年即推出，但 2018 年对考试做了更细致的指导。KCSP 要求企业必须有至少三人通过 CKA。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/ckad/&#34; title=&#34;CKAD&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKAD&lt;/a&gt;
（Kubernetes 应用开发者认证）：该认证证明用户可以为 Kubernetes 设计、构建、配置和发布云原生应用程序。经过认证的 Kubernetes Application Developer 可以定义应用程序资源并使用核心原语来构建、监控 Kubernetes 中可伸缩应用程序和排除故障。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;
（Kubernetes 服务提供商认证）：截止本文发稿时共有 74 家企业通过该认证。该认证的主体是企业或组织，通过 KCSP 的企业意味着可以为其他组织提供 Kubernetes 支持、咨询、专业服务和培训。通过该认证的中国企业有：灵雀云、阿里云、博云、才云、DaoCloud、EasyStack、易建科技、精灵云、谐云科技、华为、时速云、星号科技、睿云智合、沃趣、元鼎科技、ZTE。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34; title=&#34;Certified Kubernetes Conformance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Kubernetes Conformance&lt;/a&gt;
（Kubernetes 一致性认证）：通过该认证的 Kubernetes 提供商所提供的服务，意味着其可以保证 Kubernetes API 的可移植性及跨云的互操作性；及时更新到最新的 Kubernetes 版本；是否一致是可以通过&lt;a href=&#34;https://github.com/cncf/k8s-conformance/blob/master/instructions.md&#34; title=&#34;运行开源脚本&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行开源脚本&lt;/a&gt;
验证的。截止本文发稿通过该认证的中国企业的发行版有：灵雀云（ACE、ACP、AKS）、才云 Compass、华为 FusionStage、酷栈科技 CStack MiaoYun、Daocloud Enterprise、新智认知新氦云、浪潮云、京东 TIG、网易云、七牛云、同方有云、睿云智合 WiseCloud；通过认证的中国企业托管平台有：阿里云、百度云、博云、EasyStack、易建科技、谐云科技、华为云 CCE、腾讯云 TKE、时速云、ZTE TECS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 提供的主要证书，一般通过 KCSP 的企业都要先通过 Kubernetes 一致性认证，而通过 Kubernetes 一致性认证不一定要同时通过 KCSP，所以我们看到很多通过 Kubernetes 一致性认证的企业就不一定会通过 KCSP，因为 KCSP 的要求更多，至少要成为 CNCF 会员才可以。&lt;/p&gt;
&lt;p&gt;下面将就 CNCF 会员、托管项目的成熟度等级划分、Kubernetes 服务提供商认证和 Kubernetes 提供商认证做详细说明。&lt;/p&gt;
&lt;h2 id=&#34;cncf-会员&#34;&gt;CNCF 会员&lt;/h2&gt;
&lt;p&gt;2018 年 CNCF 的会员单位经历了爆发式增长，从 170 家增长到 365 家。CNCF 制定了如下的会员等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silver Member&lt;/li&gt;
&lt;li&gt;Gold Member&lt;/li&gt;
&lt;li&gt;Platinum Member&lt;/li&gt;
&lt;li&gt;Academic/Nonprofit Member&lt;/li&gt;
&lt;li&gt;End User Member&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同等级的会员需要交纳的年费与权益不同，详情请见 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; title=&#34;https://www.cncf.io/about/join/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/join/&lt;/a&gt;
。&lt;/p&gt;
&lt;h3 id=&#34;成为-cncf-会员的好处&#34;&gt;成为 CNCF 会员的好处&lt;/h3&gt;
&lt;p&gt;成为 CNCF 会员包括但不限于如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将可以参与 CNCF 市场委员会、CNCF Webinar、在 CNCF 和 Kubernetes 官网发表博客、博客被 KubeWeekly 收录、&lt;/li&gt;
&lt;li&gt;获得 KubeCon + CloudNativeCon 的门票折扣和参与大会的市场活动&lt;/li&gt;
&lt;li&gt;对于 Kubernetes 系列认证如 KCSP、入选 TOC 也要求必须成为 CNCF 会员才可以获得&lt;/li&gt;
&lt;li&gt;End User Case Study&lt;/li&gt;
&lt;li&gt;有机会加入 Ambassador 计划&lt;/li&gt;
&lt;li&gt;在社区里具有更多的话语权，例如 CNCF 在全球范围内组织的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;项目成熟度等级&#34;&gt;项目成熟度等级&lt;/h2&gt;
&lt;p&gt;自 2015 年底 CNCF 创立之初 Kubernetes 成为其首个托管项目以来，截止到 2018 年底，CNCF 已经托管了&lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;32 个开源项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;32 个开源项目&lt;/a&gt;
，随着越来越多的项目加入到 CNCF，为了更好的管理这些项目，为这些项目划分不同的成熟度等级就成了迫在眉睫的事情。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/cncf-annual-report-2018-review/cncf-graduation-criteria-v2.jpg&#34; data-img=&#34;/blog/cncf-annual-report-2018-review/cncf-graduation-criteria-v2.jpg&#34; data-width=&#34;1056&#34; data-height=&#34;714&#34; alt=&#34;image&#34; data-caption=&#34;CNCF 项目成熟度级别&#34;&gt;
    
  
  &lt;figcaption&gt;CNCF 项目成熟度级别&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据《Crossing the Chasm》一书中的技术采用生命周期理论，CNCF 将其托管的项目划分为三个等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graduated：对应于早期成熟项目。截止到本文发稿时只有 &lt;a href=&#34;https://kubernetes.io/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;
、&lt;a href=&#34;https://prometheus.io/&#34; title=&#34;Prometheus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;
、&lt;a href=&#34;https://www.envoyproxy.io/&#34; title=&#34;Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;
 和 &lt;a href=&#34;https://coredns.io/&#34; title=&#34;https://coredns.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://coredns.io/&lt;/a&gt;
 毕业。&lt;/li&gt;
&lt;li&gt;Incubating：对应于早期采用者阶段。截止到本文发稿时有 16 个项目。&lt;/li&gt;
&lt;li&gt;Sandbox：对应于创新者阶段。截止到本文发稿时有 12 个项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看 CNCF 托管的项目列表请访问：https://www.cncf.io/projects/&lt;/p&gt;
&lt;p&gt;CNCF 通过为项目设置成熟度水平是来建议企业应该采用哪些项目。CNCF 中托管的项目通过向 CNCF 的技术监督委员会（TOC）展示其可持续发展性来提高其成熟度：项目的采用率，健康的变化率，有来自多个组织的提交者，采用了 &lt;a href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34; title=&#34;CNCF 行为准则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 行为准则&lt;/a&gt;
，实现并维护了核心基础设施倡议（Core Infrastructure Initiative）&lt;a href=&#34;https://bestpractices.coreinfrastructure.org/&#34; title=&#34;最佳实践证书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最佳实践证书&lt;/a&gt;
。详细信息在 &lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&#34; title=&#34;毕业标准 v1.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;毕业标准 v1.1&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-service-provider&#34;&gt;Certified Kubernetes Service Provider&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;
 意味着企业具有为其他企业或组织提供 Kubernetes 支持、咨询、专业服务和培训的资质。2018 年又有 46 家企业通过了&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;KCSP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;
，通过该认证的企业累计达到 76 家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何通过 KCSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想通过 KCSP 必须满足以下三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三名或更多工程师通过认证 Kubernetes 管理员（CKA）考试。&lt;em&gt;（CKAD 考试不计入此要求）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;支持企业最终用户的商业模式，包括为客户提供驻场工程师&lt;/li&gt;
&lt;li&gt;成为 CNCF 会员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 KCSP 有如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业的 logo 会出现在 &lt;a href=&#34;https://kubernetes.io/partners/&#34; title=&#34;Kubernetes Partners&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Partners&lt;/a&gt;
 页面&lt;/li&gt;
&lt;li&gt;参加与云原生项目 leader、TOC 成员、CNCF Governing Board 的月度会议&lt;/li&gt;
&lt;li&gt;向终端用户的 leader 寻求帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为有如上这些好处，为了获得 Kubernetes 项目实施的资质，同时保持与基金会至今的交流，Kubernetes 厂商对该认证都趋之若鹜。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-offering&#34;&gt;Certified Kubernetes offering&lt;/h2&gt;
&lt;p&gt;通过 KCSP 认证只代表企业有为他人实施 Kubernetes 项目的资质，而企业自身可能并不对外提供 Kubernetes 平台或服务，这些企业可能只是系统集成商或 ISV，这时候 CNCF 又推出了 Kubernetes 提供商认证。&lt;/p&gt;
&lt;p&gt;Kubernetes 认证的提供商包括 Kubernetes 发行版、托管平台和安装器，通过认证的工具或平台将允许使用 Kubernetes 认证的 Logo，并保证 Kubernetes 一致性认证。&lt;/p&gt;
&lt;h2 id=&#34;展望-2019&#34;&gt;展望 2019&lt;/h2&gt;
&lt;p&gt;2018 年 Kubernetes 成为 CNCF 孵化的首个毕业项目，根据 CNCF 打造的项目成熟度模型，Prometheus、Envoy、CoreDNS 相继毕业，CNCF 的眼光早已不再仅盯着 Kubernetes 了，&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt;
 几乎包揽了所有云计算相关开源项目。可以说 CNCF 早已超出了 Kubernetes 的范畴，而是旨在一个建立在 Kubernetes 为底层资源调度和应用生命周期管理之上的生态系统，CNCF 中还演进出了如 Service Mesh 和 Serverless 之类的分支。&lt;/p&gt;
&lt;p&gt;从 CNCF 2017 和 2018 年度的变化来看，其中已经去掉了”dynamically orchestrating“的字眼，也就意味着 Kubernetes 在容器编排领域已经胜出，进而强调多云环境，同时 CNCF 推动的 Kubernetes 一致性认证也受到众多云厂商的支持，这也意味着 Kubernetes 将成为多云环境 API 一致性的保证。&lt;/p&gt;
&lt;p&gt;CNCF 在 2019 年的战略将更聚焦于开发者社区，协助尤其是来自终端用户的开发者成为项目的 contributor 和 maintainer，保证终端用户的意见能够在社区里被正确地传达和并最终成功地采纳云原生。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; title=&#34;CNCF Annual Report 2017 pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Annual Report 2017 pdf&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; title=&#34;CNCF Annual Report 2018 pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Annual Report 2018 pdf&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;CNCF  Projects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF  Projects&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; title=&#34;CNCF Landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; title=&#34;CNCF Ambassadors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassadors&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; title=&#34;Kubernetes Certified Service Providers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Certified Service Providers&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>云原生编程语言 Pulumi 开源宣言</title>
      <link>https://jimmysong.io/blog/hello-pulumi-from-jeo-duffy/</link>
      <pubDate>Sun, 24 Jun 2018 11:38:30 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/hello-pulumi-from-jeo-duffy/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;2018 年 6 月 18 日 Joe Duffy 在&lt;a href=&#34;http://joeduffyblog.com/2018/06/18/hello-pulumi/&#34; title=&#34;他的博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;他的博客&lt;/a&gt;
中宣布开源了云原生编程语言&lt;a href=&#34;https://pulumi.io&#34; title=&#34;Pulumi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pulumi&lt;/a&gt;
。这是继&lt;a href=&#34;https://ballerina.io&#34; title=&#34;Ballerina&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina&lt;/a&gt;
之后我看到的另一款云原生编程语言，他们之间有一些共同的特点，例如都是为了支持多种云环境，基于不可变基础设施和基础设施即代码的理念构建，使云原生应用的集成更加方便，但也有一些不同，Ballerina 是直接创建了一个基于 JVM 的语言，而 Pulumi 是为不同编程语言构建了 SDK。&lt;/p&gt;
&lt;p&gt;下文是对	&lt;a href=&#34;http://joeduffyblog.com/2018/06/18/hello-pulumi/&#34; title=&#34;Hello, Pulumi!&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hello, Pulumi!&lt;/a&gt;
一文的翻译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们发布了 Pulumi，这是一款开源的云开发平台。有了 Pulumi，您可以使用自己最喜欢的编程语言来开发云应用程序，可以直接跨过底层的基础设施即代码直接开发更高效更具生产力的现代容器和 serverless 应用。一年多前我们发起了 Pulumi，我们都为自己在这一年多取得的成绩感到惊讶。这是我们开源的第一步，也是我们做出的一步重大跨越，我们期望与您分享我们的成就。&lt;/p&gt;
&lt;p&gt;Pulumi 支持多语言、混合云环境、完全可扩展。初期支持 JavaScript、TypeScript、Python 和 Go 语言，支持 AWS、Azure、GCP 云平台，另外还支持所有兼容 Kubernetes 的公有云、私有云和混合云。Pulumi 实现了一种单一、一致的编程模型，一组编程工具，可管理所有以上环境，丰富的生态系统支持大量可复用的包。使用真实的语言来改变一切。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL;DR 有了 Pulumi，38 页的手动操作说明将变成了 38 行代码。25000 行 YAML 配置变成了使用真实编程语言的 500 行语句。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Pulumi 的整个运行时、CLI、支持的库都可以在 GitHub 上免费下载。我们的团队正急切的等待您的反馈。与此同时，我需要告诉您一些关于 Pulumi 的事情，为什么我们会创造它。&lt;/p&gt;
&lt;h2 id=&#34;为什么创造-pulumi&#34;&gt;为什么创造 Pulumi？&lt;/h2&gt;
&lt;p&gt;我的背景是 100% 在开发者工具上。我是.NET 的早期工程师，设计了其中的并发和异构部分，领导的分布式操作系统的变成平台，管理微软语言小组，包括开源和使.NET Core 跨平台。因为这些背景，进入云领域我有自己的见解。&lt;/p&gt;
&lt;p&gt;我发现的东西显然无法吸引我。&lt;/p&gt;
&lt;p&gt;2016 年年末的时候我就开始跟我的朋友也是共同创始人 Eric Rudder 开始构思 Pulumi，那时候容器和 serverless 已经甚嚣尘上，但是距离落地还为时尚早。云的能力十分惊人，但是至今将使用它还是十分困难。&lt;/p&gt;
&lt;p&gt;对于每一个 serverless 函数来说，我都要写几十行的 JSON 或者 YAML 配置。要链接到一个 API 端点，我还要学习晦涩的概念，执行一系列复制 - 粘贴的低级工作。如果我想在本机上运行一个小的集群的话，那么 Docker 还是很棒的，但是如果要在生产上使用的话，那么就要手动管理 etcd 集群，配置网络和 iptables 路由表，还有一系列与我的应用程序本身不相干的事情。不过 Kubernetes 的出现至少让我可以配置一次下次就可以跨云平台重用，但这还是会分散开发人员的精力。&lt;/p&gt;
&lt;p&gt;我认为我还算一个经验丰富的工程师，已经在软件行业从业 20 年了，但是当我想要将自己的代码部署到云中的时候，我感觉自己就像是个傻子。真是太令人悲哀了！如果我掌握了这些能力，那么是世界就会出触手可及。我总是在淌这浑水，处理云的复杂性，而我真正想做的是花时间来创造业务价值。&lt;/p&gt;
&lt;p&gt;关于编程的许多方面都经历了类似的转变过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 80 年代初，我们使用汇编语言对微处理器进行了编程。最终，编译器技术进步了，我们可以同时处理多种常见的架构。像 FORTRAN 和 C 这样的 Low-level 的编程语言开始兴起。&lt;/li&gt;
&lt;li&gt;在 90 年代初期，我们直接针对低级别操作系统原语进行编程，无论是 POSIX 系统调用还是 Win32 API，并进行手动内存和资源管理。最终，语言运行时技术和处理器速度提升到了可以使用更高级别语言的状态，如 Java。除了动态语言之外，这种趋势已经加速，如 JavaScript 统治了 Web。&lt;/li&gt;
&lt;li&gt;在 21 世纪初期，我们的编程模型中的共享内存并发性最好是原始的（&lt;a href=&#34;http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/&#34; title=&#34;我花了很多时间在这个问题上&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我花了很多时间在这个问题上&lt;/a&gt;
）。现在，我们简单地假设 OS 具有高级线程共享、调度和异步 IO 功能，以及编程到更高级别的 API，例如任务和承诺。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我相信云软件也在进行类似的转变。从构建单一应用程序到构建真正的云优先分布式系统，我们正处在一场巨变中。然而，当海啸发生之前，人们几乎不知道它正在发生。&lt;/p&gt;
&lt;p&gt;从上面的角度来看，使用“配置”情况是有道理的。在虚拟机的早期，我们利用现有的应用程序并将它们扔在栅栏上，以便有人添加一点 INI 或 XML 粘合剂，让它们在虚拟机内部运行，以实现更灵活的管理。随着我们将这些相同的虚拟机“提升并转移到云中”，这种配置方法一直伴随着我们。这将我们带到了大致正确的边界。&lt;/p&gt;
&lt;p&gt;使用这种相同类型的配置表示基于容器的微服务、serverless 和细粒度托管服务之间的关系导致了异常的复杂性。将应用程序转变为分布式系统应该是事后的想法。事实证明，云覆盖了您的架构和设计。表达架构和设计的最好的方式是使用代码，使用真正的编程语言编写抽象，重用和优秀的工具。&lt;/p&gt;
&lt;p&gt;早些时候，Eric 和我采访了几十个客户。我们发现，开发人员和 DevOps 工程师都普遍感到幻灭。我们发现了极端的专业化，即使在同一个团队中，工程师也不会使用同一种语言。最近几周我已经听到了这个消息，我期待有一天会出现 NoYAML 运动。&lt;/p&gt;
&lt;p&gt;专业化是一件好事，我们希望我们最优秀和最聪明的云计算架构师晋升到 DevOps 和 SRE 的高级职位，但团队必须能够在合作时使用相同的语言。因为没有共同的通用语言导致了团队之间的物理隔离，而不是根据策略和环境分工。Pulumi 的目标是为人们提供解决这个问题所需的工具。&lt;/p&gt;
&lt;h2 id=&#34;pulumi-是什么&#34;&gt;Pulumi 是什么？&lt;/h2&gt;
&lt;p&gt;Pulumi 是一个支持多语言和混合云开发平台。它可以让您使用真实语言和真实代码创建云计算的各个方面，从基础设施到应用程序本身。只需编写程序并运行它们，Pulumi 就能帮你完成出其余部分。&lt;/p&gt;
&lt;p&gt;Pulumi 的中心是一个云对象模型，与运行时相结合以了解如何以任何语言编写程序，理解执行它们所需的云资源，然后以强大的方式规划和管理您的云资源。这种云运行时和对象模型本质上是与语言、云中立的，这就是为什么我们能够支持如此多的语言和云平台。更多支持正在路上。&lt;/p&gt;
&lt;p&gt;Pulumi 采用了基础设施即代码以及不可变基础设施的概念，并可让您从您最喜欢的语言（而不是 YAML 或 DSL）中获得自动化和可重复性优势。在部署它们之前，您可以对变更进行区分，并且我们会对谁更改了什么以及何时更改进行完善的审计追踪。核心模型因此是陈述性的。&lt;/p&gt;
&lt;p&gt;使用真正的语言可以带来巨大的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;熟悉&lt;/strong&gt;：不需要学习新的定制 DSL 或基于 YAML 的模板语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象&lt;/strong&gt;：正如我们喜爱的编程语言那样，我们可以用更小的东西来构建更大的东西&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享和重用&lt;/strong&gt;：利用现有的语言包管理器共享和重用这些抽象，无论是与社区、团队内部共享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表现力&lt;/strong&gt;：充分利用您的编程语言，包括异步、循环和条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工具&lt;/strong&gt;：通过使用真正的语言，我们可以即时访问 IDE、重构、测试、静态分析和编排等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生产力&lt;/strong&gt;：将以上所有好处加在一起，一起将变得更快，我们也会变得更快乐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当提供原始云资源时，这些好处当然最重要，但是我们在团队中发现，您只能使用抽象。这包括在函数中包装事物以消除样板并创建引入更高级别概念的自定义类，通常将它们打包并重复使用。&lt;/p&gt;
&lt;p&gt;例如，此代码在 AWS 中创建一个 DynamoDB 数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@pulumi/aws&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;music&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dynamodb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;music&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Album&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;S&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Artist&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;S&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hashKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Album&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rangeKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Artist&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此代码创建一个基于容器的任务和无服务器功能，由一个存储桶触发：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@pulumi/cloud&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;bucket&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cloud&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Task&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ffmpegThumbTask&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;./path_to_dockerfile/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onPut&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;onNewVideo&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucketArgs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucketArgs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;S3_BUCKET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;INPUT_VIDEO&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;TIME_OFFSET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;_&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;replace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;OUTPUT_FILE&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;_&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;.jpg&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更好的是，这些代码可以根据您的需求部署到任何公共或私有云中。&lt;/p&gt;
&lt;p&gt;最后，这个例子创建了一个 Redis 缓存。我们怎么知道？我们不需要。缓存组件是一个抽象，它封装了我们可以安全忽略的不重要的细节：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;./cache&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;url-cache&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在使用 Pulumi 之后，你不会再以同样的方式考虑基础设施。你的大脑将不再是一个独立于应用程序的独特“事物”，而是开始将分布式云系统看作是你的程序架构的核心部分，而不是事后的想法。&lt;/p&gt;
&lt;p&gt;由于抽象，我们已经能够提供一些强大的库。该库是提炼和执行最佳实践的绝佳方式。当然，对于我们自己的库来说没有什么特别的，因为它们只是功能、类和代码，我们期待着看到你为自己、你的团队或者社区建立的那些库。&lt;/p&gt;
&lt;p&gt;我们最复杂的库——Pulumi 云框架——提供了一些令人兴奋的正在进行的工作的早期预览，展示如何创建跨越云提供商自己对诸如容器、无服务器功能和存储桶等核心概念的抽象。以同样的方式，您可以用 Node.js、Python、Java、.NET 等语言编写功能强大的应用程序，利用进程、线程和文件系统，无论是在 macOS、Linux 还是 Windows 上，这种方法都可以让您创建针对任何云提供商的现代混合云应用程序。像 Kubernetes 和其他 CNCF 产品组合这样的技术正在帮助推动这一不可避免的结果，因为它们在整个云基板上实现了对基本计算抽象的民主化和共识。&lt;/p&gt;
&lt;p&gt;Pulumi 不是 PaaS，尽管它提供类似 PaaS 的生产力；您的程序总是直接针对您选择的云运行，并且始终可以访问该基础云的全部功能。即使您选择使用更高级别的组件，它也会向下兼容，并且您可以随时直接使用原始资源。它就像任何复杂的现代软件：有时，整个事情必须用 C++ 编写，以便访问底层平台的全部功能，但对于大多数常见情况，70% 到 100％可以是平台独立代码，而只有不到 30% 的专业化才能真正需要直接与操作系统交互。&lt;/p&gt;
&lt;p&gt;接下来我还将发布十几篇博客文章来介绍 Pulumi 所有方面的更多细节。然而，为了保持这篇文章尽量简短，我将首先介绍下 Pulumi 的一些我最喜欢的方面。&lt;/p&gt;
&lt;h2 id=&#34;我最喜欢的东西&#34;&gt;我最喜欢的东西&lt;/h2&gt;
&lt;p&gt;这很难选择，但这里有一些关于 Pulumi 我最喜欢的东西：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源&lt;/strong&gt;。我坚信所有开发人员工具都应该是开源的。当然，Pulumi 也是一家公司，但是有充足的机会通过增加便利性以建立商业模式。（可以认为是​​Git 与 GitHub 的关系）我们从以前的工作中受益匪浅，其中包括 Docker、Terraform、Kubernetes、TypeScript 以及其他许多明确提及的工作。我们期待成为生态系统的一部分。因为我们在开放源代码方面下了很大功夫，所以我很高兴看到社区给我们带来什么，特别是在更高级别的软件包领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多语言&lt;/strong&gt;。就像使用 Java 和.NET 一样，Pulumi 运行时的架构可以支持多种语言，并以目标语言的所有方面（风格、语法、软件包等）的惯用方式来实现。因为我们是开源的，任何人都可以贡献自己的力量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合云&lt;/strong&gt;。我们的云对象模型是一个强大的基础，可以支持任何云提供商。这提供了一个统一的编程模型，工具和控制平面，用于在任何地方管理云软件。如果仅仅是为了让一个简单的基于容器的应用程序在生产中运行起来，没有必要学习三种不同的 YAML 方言和五种不同的 CLI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云对象模型&lt;/strong&gt;。这个底层云对象模型为您的云计算构建方式提供了丰富的视图。所得到的对象使用程序中的依赖关系组成一个 DAG，系统可以分析和理解这些依赖关系以提供洞察力，这是我们打算随着时间的推移解锁复杂的静态分析和可视化的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重复使用的组件&lt;/strong&gt;。由于拥有真正的语言，我们可以构建更高层次的抽象。我最喜欢的例子之一是帮助我们的客户定期从部署中排除 1000 行 YAML，这是我们的 AWS 基础架构软件包。它采用 AWS 最佳实践来设置虚拟私有云，并提供专用子网和多可用区域支持，并将其转变为几行代码以配置整个网络：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;awsinfra&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@pulumi/aws-infra&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;network&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;awsinfra&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`$&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;numberOfAvailabilityZones&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Create&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subnets&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;many&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AZs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;usePrivateSubnets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Run&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inside&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;per&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AZ&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subnets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;迄今为止，我最喜欢的成功案例是将客户的 25,000 行 AWS CloudFormation YAML 文件（其中使用无服务器、容器、基础设施和三个自定义部署管道）使用 500 行 TypeScript 和一个 Pulumi 的持续部署架构来替换。这不仅仅使得公司所有工程师都可以理解的代码变得少得多，这样他们可以将过去需要花费数周时间才能完成的事情现在用一个下午就可以搞定，而且现在可以在任何云或原生的 Kubernetes 上运行，而不仅是在 AWS。管理团队的 CloudFormation 堆栈，而不是一个工作量过饱和的工程师，整个团队可以更加高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;统一的容器构建/发布管道&lt;/strong&gt;。尝试将容器投入生产时有个问题让我早就感到很沮丧，就是同步我的应用程序、容器和基础架构管理，因为每个容器都倾向于使用不同的工具。我们的云框架演示了一个集成的工作流程，在这个工作流程中，只需简单地运行 Pulumi 构建、diff、推送和拉取新的容器镜像，所有这些都经过精心安排，以消除停机时间。&lt;/p&gt;
&lt;p&gt;**Lambda 无服务器功能 **。AWS 的取了个好名字：Lambda。在 Pulumi 中，我现在可以用我最喜欢的语言使用 lambda 表达式来编写我的无服务器函数，而不需要一行 YAML：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@pulumi/aws&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverless&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@pulumi/aws-serverless&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topic&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aws&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Topic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;topic&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;serverless&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cloudwatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onEvent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hourly&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;rate(60 minutes)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;aws-sdk&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SNS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sns&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;publish&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JSON&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringify&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;TopicArn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此功能允许您捕获对变量的引用：常量、配置设置或加密，甚至可以引用其他资源，以便与它们进行通信。当你第一次这样做的时候，我保证你会有一个“哇塞”的时刻，将无服务器连接到你写过的每一个事件驱动的代码片段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 API 的资源&lt;/strong&gt;。因为我可以捕获对其他云资源的引用，所以我可以在其上创建 API 以使它们更易于在我的运行时代码中使用。这使得“演员般的”编程模型无需处理配置和服务发现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆栈&lt;/strong&gt;。Pulumi 的核心是“堆栈”的概念。堆栈是您的云计算的独立实例，其资源和配置与所有其他堆栈不同。您可能有一堆用于生产、暂存和测试的堆栈，或者可能是每个单一租户的环境。Pulumi 的 CLI 使得启动和卸载大量堆栈变得轻而易举。这会打开以前可能没有尝试过的工作流，例如每个开发人员都拥有自己的堆栈，将新堆叠起来（并拆除）以测试每个 Pull 请求，甚至将服务的层拆分成多个链接在一起的堆栈。&lt;/p&gt;
&lt;p&gt;我将在未来的博客文章介绍如何做。现在 Pulumi 已经公开，期望在接下来的几天和几周内听到更多的消息。我希望这能让您更好地了解整体平台，其方法和独特优势。&lt;/p&gt;
&lt;h2 id=&#34;下一步是什么&#34;&gt;下一步是什么？&lt;/h2&gt;
&lt;p&gt;我们希望通过 Pulumi，开发人员和 DevOps 团队都将体验到云的复兴。构建强大的云软件将更加愉快、更高效、更具协作性。现代云计算软件将从代码孤岛转变为等量的配置胶水，成为优雅的分布式系统。&lt;/p&gt;
&lt;p&gt;这是一个难题。我绝不会说我们已经解决了它。我确实相信 Pulumi 是我亲身见过并希望最接近我心目中的云开发平台。在这个激动人心的时刻，投注于语言将使我们所有人“站在巨人的肩膀上”，这让我感到乐观；语言总是一个安全的赌注。&lt;/p&gt;
&lt;p&gt;今天很可能是我职业生涯中最激动人心的一天。我想感谢我们的团队和所有帮助过我们的人，放纵我们的疯狂想法并相信我们。&lt;/p&gt;
&lt;p&gt;现在访问&lt;a href=&#34;https://pulumi.io/&#34; title=&#34;https://pulumi.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://pulumi.io&lt;/a&gt;
，或者直接运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -fsSL https://get.pulumi.com &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我迫不及待想看看你将使用 Pulumi 构建的所有令人难以置信的东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;P.S 我要感谢我已故的导师，最好的朋友 Chris Brumme。虽然 Chris 没办法和我们一起庆祝这一刻，但我清楚“Chris 每一步会做些什么”。Pulumi 是夏威夷语，是“扫帚”的意思，尽管这完全是他名字的错误发音，但为了纪念 Chirs 我还是用了它。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>云原生编程语言 Ballerina 介绍</title>
      <link>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</link>
      <pubDate>Sat, 12 May 2018 23:27:49 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/</guid>
      <description>
        
        
        &lt;p&gt;当我第一眼看到 &lt;a href=&#34;https://ballerina.io&#34; title=&#34;Ballerina&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina&lt;/a&gt;
 还真有点惊艳的感觉。Ballerina 这个单词的意思是“芭蕾舞女演员”。我想他们之所以给公司和这们语言起这个名字，可能是希望它成为云原生这个大舞台中，Ballerina 能像一个灵活的芭蕾舞者一样轻松自如吧！&lt;/p&gt;
&lt;p&gt;Ballerina 是一款开源的编译式的强类型语言，该语言本身的代码可以通过 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-lang&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;
 上获取。我们可以通过 Ballerina 官网上的&lt;a href=&#34;https://ballerina.io/philosophy/&#34; title=&#34;设计哲学&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;设计哲学&lt;/a&gt;
页面来对这门云原生编程语言一探究竟。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8tj7gxj30ws0u0774.jpg&#34; data-width=&#34;800&#34; data-height=&#34;732&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 Ballerina&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;未来的应用程序应该是基于 API 的，而众多 API 之间的通讯和集成就成了关键问题。Ballerina 是一款使用文本和图形语法编译的、事务的、静态和强类型编程语言。Ballerina 包含分布式系统集成到语言的基本概念，并提供类型安全，并发环境下实现的分布式事务，可靠的消息传递，流处理和工作流。&lt;/p&gt;
&lt;h2 id=&#34;为什么创建-ballerina&#34;&gt;为什么创建 Ballerina？&lt;/h2&gt;
&lt;p&gt;与 ESB 集成仍然是瀑布式开发。你必须部署服务器，配置连接器，使用 XML 编程服务逻辑以及使用 XPath 查询和转换数据。这不是开发者友好的。&lt;/p&gt;
&lt;p&gt;带有 Spring 和 Node.js 等框架的编程语言提供了灵活性，但是它没有使适合于序列并行化、并发模型编程的分布式系统结构变得简单。&lt;/p&gt;
&lt;p&gt;ESB、EAI、BPM 和 DSL 需要 XML 和配置来中断迭代开发流程：编辑、构建、运行和测试。这与运行实际应用之间是有一条鸿沟的，而云原生编程语言 Ballerina 的出现就是为了解决这条“集成鸿沟”的。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-设计理念&#34;&gt;Ballerina 设计理念&lt;/h2&gt;
&lt;h3 id=&#34;序列图&#34;&gt;序列图&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c8ji2zdj30u00wwdgm.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina 的序列图设计理念&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 Ballerina 的序列图设计理念&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言灵感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列图反映了设计开发人员记录的互联的系统。Ballerina 的语法和高效的编码模式要求开发人员使用强大的交互最佳实践来编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列图可视化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的语言语义模型旨在定义独立的各方如何通过结构化的交互沟通。接着，每个 Ballerina 程序都可以显示为其流程的序列图。IntelliJ 和 VS Code 的插件中提供了这些可视化。Ballerina Composer 是一款通过序列图创建 Ballerina 服务的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actor 与 action&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端、worker 和远程系统在 Ballerina 的序列图中以不同的 actor 表示。在代码中，远程端点通过连接器进行连接，连接器提供类型安全操作。在图形上，每个连接器在序列图中表示为一个 actor（即一条垂直线），action 表示为与这些 actor 的交互。&lt;/p&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c99h584j30u00ww752.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88c99h584j30u00ww752.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 Ballerina 的并发理念&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 Ballerina 的并发理念&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列图和并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的并发模型是并行优先的，因为与远程方的交互总是涉及多个 worker。Worker 之间的交互作为消息传递进行处理，它们之间没有共享状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worker 语义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 的执行模型由称为 woker 的轻量级并行执行单元组成。Worker 使用非阻塞策略来确保没有函数锁定正在执行的线程，例如等待响应的 HTTP I/O 调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Worker 和 fork/join 语义抽象了底层非阻塞方法，以启用更简单的并发编程模型。&lt;/p&gt;
&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;
&lt;p&gt;下面是 Ballerina 中支持的类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anything&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;floatingPoint&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blob&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toBlob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsonNative&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;XML&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;natively&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;supports&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;             &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ballerina&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringArray&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;there&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[][]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arrayOfArrays&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unionType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// the empty tuple acts as &amp;#34;null&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringOrInt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;this is a union type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intOrNull&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inferred&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myMap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ballerina&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myRecord&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myObject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;returns&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;类型安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 有一个结构化的类型系统，包括 primitive、recored、object、tuple 和 union 类型。该类型安全模型在赋值时包含了类型推断，并为连接器、逻辑和网络绑定的有效负载提供了大量的编译时完整性检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Union 类型和显式 Null&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;各个网络端点通常会根据其输入和逻辑返回具有不同有效负载类型消息或 error。Ballerina 的类型系统采用了基于 union 类型的方法。Union 类型明确地采用了这种语义，不需要开发人员创建不必要的“包装”类型。这种方法也增强了对 null 值的处理。默认情况下，类型不支持 null 值。开发人员必须明确创建 union 类型来处理 null 值。结果是 null 的异常不会发生，并且语言语法和编译器会识别是否需要 null 处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异构数据处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 类型系统内置丰富的对 JSON、XML、流和表格的支持以及对 ProtoBuf 和 gRPC 的直接支持。这样做的结果是可以获得处理网络负载、SQL 编程和流处理的干净可读的代码。数据转换逻辑不受复杂的生成类型、第三方库代码或其他混淆因素的影响——简单明了的可读代码捕捉与异构数据和转换逻辑的交互。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-如何工作&#34;&gt;Ballerina 如何工作？&lt;/h2&gt;
&lt;p&gt;Ballerina 的语法、代码和编译器创建了运行时服务和部署构件，这些工件都是云原生就绪的，您可以选择将其部署在 IaaS、编排系统或 service mesh 中的。开发人员的体验旨在维护流程，包括快速的编辑、构建、调试周期并集成到团队的生命周期工具链中。&lt;/p&gt;
&lt;h3 id=&#34;运行时架构&#34;&gt;运行时架构&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cazdfcnj30u00wxjsr.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 运行时架构&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 ballerina 运行时架构&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina API 网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强制执行身份策略并保证性能。通过代码注解（类似于 Spring 中的注解）进行配置和部署。可以运行嵌入式服务、作为管理多个服务的容器代理或者使用 API 管理解决方案（如 WSO2 API Manager）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示您的 API 和执行逻辑。服务通过不同的协议运行，内部代码结构被编译为支持 OpenAPI 和 Swagger 的 API 接口。服务与端点进行通信，无论它们是调用客户端还是其他服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina bridge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许传统代码和服务参与分布式事务中的 Ballerina 服务。Bridge 将您现有服务与本地代理包装起来，通过调用 Ballerina 服务参与和代理分布式事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息代理、事务协调者和身份代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为参与事务、事件驱动的通信和为认证流程的 Ballerina 服务提供代理基础设施功能。这些组件可以嵌入到单个服务部署中或者进行单独部署和扩展以管理多个服务。&lt;/p&gt;
&lt;h3 id=&#34;部署架构&#34;&gt;部署架构&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cbr5hquj30u00wxq46.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cbr5hquj30u00wxq46.jpg&#34; data-width=&#34;600&#34; data-height=&#34;658&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 部署架构图&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 ballerina 部署架构图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IaaS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用代码注解和构建系统，可以打包 Ballerina 服务和其他运行时组件（如 API 网关）以部署到任何云原生环境中。在 IaaS 环境中，Ballerina 服务可以以虚拟机或容器的方式运行，也可以在构建期间将镜像推送到 registry 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码注解会触发编译器扩展，从而为不同的编排器（如 Kubernetes 或 Cloud Foundry）生成 Ballerina 组件的工件包。供应商或 DevOps 可以添加自定义代码注解以生成特定于环境的部署，例如自定义蓝色部署算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ballerina 可以选择断路器和事务流程逻辑委托给像 Istio 或 Envoy 这样的 service mesh（如果有的话）。如果没有 service mesh 的话，Ballerina 服务将嵌入相应的功能。&lt;/p&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
  
    
    &lt;img src=&#34;https://jimmysong.io/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cck2s8xj30u00wtgni.jpg&#34; data-img=&#34;/blog/introducing-cloud-native-programming-language-ballerina/006y8mN6ly1g88cck2s8xj30u00wtgni.jpg&#34; data-width=&#34;600&#34; data-height=&#34;656&#34; alt=&#34;image&#34; data-caption=&#34;云原生编程语言 ballerina 生命周期架构图&#34;&gt;
    
  
  &lt;figcaption&gt;云原生编程语言 ballerina 生命周期架构图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用我们的语言服务器可以在 VS Code 和 IntelliJ 中获取自动补全和调试等智能感知。Ballerina 的关键字和语法结构可以用序列图的方式来表示。使用 Ballerina Composer 可以可视化的编辑 Ballerina 代码。另外它也可以做可视化得运行时和开发环境追踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ballerina 构建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将服务编译为经过优化的字节码，以便使用内存调优后的 BVM 运行。提供了使用 Testerina 的项目结构、依赖管理、包管理和单元测试。构建锁可以轻松地重新创建服务和部署。生成可执行文件（.balx）或库（.balo）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署代码注解会触发构建扩展，从而为持续集成、持续交付或编排器环境生成工件。将构建工件推送到您的 CI/CD 系统或完全跳过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Registry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将端点连接器、自定义注解和代码功能作为可共享软件包组合在一起。可以在全球共享资源库——Ballerina Central 中 pull 或 push 版本化的软件包。&lt;/p&gt;
&lt;h2 id=&#34;ballerina-的语言特性&#34;&gt;Ballerina 的语言特性&lt;/h2&gt;
&lt;p&gt;Ballerina 设计为云优先，内置对现代 Web 协议和数据格式的支持，完全支持图灵完备编程语言，以及对微服务架构的原生支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 构造&lt;/li&gt;
&lt;li&gt;逻辑语言&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;Json 和 XML&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;稳定和强大的类型&lt;/li&gt;
&lt;li&gt;stream&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ballerina-中集成了哪些内容&#34;&gt;Ballerina 中集成了哪些内容？&lt;/h2&gt;
&lt;p&gt;Ballerina 是一种旨在&lt;strong&gt;集成简化&lt;/strong&gt;的语言。基于顺序图的交互，Ballerina 内置了对通用集成模式和连接器的支持，包括分布式事务、补偿和断路器。凭借对 JSON 和 XML 的一流支持，Ballerina 能够简单有效地构建跨网络终端的强大集成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型安全端点集成&lt;/li&gt;
&lt;li&gt;类型安全连接器&lt;/li&gt;
&lt;li&gt;可靠的消息传递&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;断路器&lt;/li&gt;
&lt;li&gt;注入攻击防护&lt;/li&gt;
&lt;li&gt;Docker 和 Kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 Ballerina 中各个功能的示例代码请查阅 &lt;a href=&#34;https://github.com/ballerina-platform/ballerina-examples&#34; title=&#34;ballerina-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ballerina-example&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io&#34; title=&#34;Ballerina 官网&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina 官网&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/microservices-docker-kubernetes-serverless-service&#34; title=&#34;Microservices, Docker, Kubernetes, Serverless, Service Mesh, and Beyond&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microservices, Docker, Kubernetes, Serverless, Service Mesh, and Beyond&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>CNCF - 云原生计算基金会简介</title>
      <link>https://jimmysong.io/blog/cncf-introduction/</link>
      <pubDate>Sun, 04 Mar 2018 18:03:39 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/cncf-introduction/</guid>
      <description>
        
        
        &lt;p&gt;CNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），口号是&lt;strong&gt;坚持和整合开源技术来编排容器作为微服务架构的一部分&lt;/strong&gt;，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。&lt;/p&gt;
&lt;p&gt;CNCF 作为一个厂商中立的基金会，致力于 Github 上的快速成长的开源技术的推广，如 Kubernetes、Prometheus、Envoy 等，帮助开发人员更快更好的构建出色的产品。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://github.com/cncf/landscape&#34; title=&#34;http://github.com/cncf/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://github.com/cncf/landscape&lt;/a&gt;
 中维护了一幅 CNCF 的全景图。&lt;/p&gt;
&lt;p&gt;其中包含了 CNCF 中托管的项目，还有很多是非 CNCF 项目，还有个交互式的浏览 CNCF 涵盖的所有的项目的页面：https://i.cncf.io&lt;/p&gt;
&lt;p&gt;关于 CNCF 的使命与组织方式请参考&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;CNCF 章程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 章程&lt;/a&gt;
，概括的讲 CNCF 的使命宝库以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装。&lt;/li&gt;
&lt;li&gt;通过中心编排系统的动态资源管理。&lt;/li&gt;
&lt;li&gt;面向微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 最初对云原生特征的定义。&lt;/p&gt;
&lt;p&gt;CNCF 这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。&lt;/p&gt;
&lt;p&gt;另外 CNCF 组织由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会员&lt;/strong&gt;：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理事会&lt;/strong&gt;：负责事务管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TOC（技术监督委员会）&lt;/strong&gt;：技术管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户社区&lt;/strong&gt;：推动 CNCF 技术的采纳并选举最终用户技术咨询委员会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户技术咨询委员会&lt;/strong&gt;：为最终用户会议或向理事会提供咨询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;营销委员会&lt;/strong&gt;：市场推广&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cncf-项目成熟度分级与毕业条件&#34;&gt;CNCF 项目成熟度分级与毕业条件&lt;/h2&gt;
&lt;p&gt;每个 CNCF 项目都需要有个成熟度等级，申请成为 CNCF 项目的时候需要确定项目的成熟度级别。&lt;/p&gt;
&lt;p&gt;成熟度级别（Maturity Level）包括以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sandbox（初级）一开始是叫 inception&lt;/li&gt;
&lt;li&gt;incubating（孵化中）&lt;/li&gt;
&lt;li&gt;graduated（毕业）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否可以成为 CNCF 项目需要通过 Technical Oversight Committee（技术监督委员会）简称&lt;a href=&#34;https://github.com/cncf/toc&#34; title=&#34;TOC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOC&lt;/a&gt;
，投票采取 fallback 策略，即&lt;strong&gt;回退策略&lt;/strong&gt;，先从最高级别（graduated，目前是从 incubating）开始，如果 2/3 多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到 inception 级别都没得到 2/3 多数投票通过的话，则拒绝其进入 CNCF 项目。一般一个项目处于孵化阶段不会超过 2 年。&lt;/p&gt;
&lt;p&gt;当前所有的 CNCF 项目可以访问 &lt;a href=&#34;https://www.cncf.io/projects/&#34; title=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/projects/&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;在太平洋时间 3 月 6 日，Kubernetes 成为了 CNCF 的第一个毕业项目！&lt;/p&gt;
&lt;h2 id=&#34;toc技术监督委员会&#34;&gt;TOC（技术监督委员会）&lt;/h2&gt;
&lt;p&gt;TOC（Technical Oversight Committee）作为 CNCF 中的一个重要组织，它的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义和维护技术视野&lt;/li&gt;
&lt;li&gt;审批新项目加入组织，为项目设定概念架构&lt;/li&gt;
&lt;li&gt;接受最终用户的反馈并映射到项目中&lt;/li&gt;
&lt;li&gt;调整组件见的访问接口，协调组件之间兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TOC 成员通过选举产生，见&lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/election-schedule.md&#34; title=&#34;选举时间表&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;选举时间表&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;参考 CNCF TOC：https://github.com/cncf/toc&lt;/p&gt;
&lt;h2 id=&#34;cncf-章程&#34;&gt;CNCF 章程&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）是 Linux 基金会旗下的一个基金会，加入 CNCF 等于同时加入 Linux 基金会（也意味着你还要交 Linux 基金会的份子钱），对于想加入 CNCF 基金会的企业或者组织首先要做的事情就是要了解 CNCF 的章程（charter），就像是作为一个国家的公民，必须遵守该国家的宪法一样。CNCF 之所以能在短短三年的时间内发展壮大到如此规模，很大程度上是与它出色的社区治理和运作模式有关。了解该章程可以帮助我们理解 CNCF 是如何运作的，也可以当我们自己进行开源项目治理时派上用场。&lt;/p&gt;
&lt;p&gt;该章程最后更新于 2018 年 5 月 15 日，详见&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;
。下文中关于 CNCF 章程的介绍部分引用自&lt;a href=&#34;http://www.ocselected.org/posts/foundation_introduce/how_cncf_works/&#34; title=&#34;CNCF 是如何工作的&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 是如何工作的&lt;/a&gt;
，有改动。&lt;/p&gt;
&lt;h3 id=&#34;1-cncf-的使命&#34;&gt;1. CNCF 的使命&lt;/h3&gt;
&lt;p&gt;CNCF 没有偏离自己的主题，核心是解决技术问题：基金会的使命是创建并推动采用新的计算模式，该模式针对现代分布式系统环境进行了优化，能够扩展至数万个自愈式多租户节点。&lt;/p&gt;
&lt;p&gt;所谓的云原生系统须具备下面这些属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用容器化&lt;/strong&gt;：将软件容器中的应用程序和进程作为独立的应用程序部署单元运行，并作为实现高级别资源隔离的机制。从总体上改进开发者的体验、促进代码和组件重用，而且要为云元是国内应用简化运维工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态管理&lt;/strong&gt;：由中心化的编排来进行活跃的调度和频繁的管理，从根本上提高机器效率和资源利用率，同时降低与运维相关的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向微服务&lt;/strong&gt;：与显式描述的依赖性松散耦合（例如通过服务端点），可以提高应用程序的整体敏捷性和可维护性。CNCF 将塑造技术的发展，推动应用管理的先进技术发展，并通过可靠的接口使技术无处不在，并且易于使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-cncf-扮演的角色&#34;&gt;2. CNCF 扮演的角色&lt;/h3&gt;
&lt;p&gt;CNCF 其实是在开源社区的基础上发挥着作用，应负责：&lt;/p&gt;
&lt;p&gt;a) 项目管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保技术可用于社区并且没有杂七杂八的影响&lt;/li&gt;
&lt;li&gt;确保技术的品牌（商标和标识）得到社区成员的关注和使用，特别强调统一的用户体验和高水平的应用程序兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;b) 促进生态系统的发展和演进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;评估哪些技术可以纳入云原生计算应用的愿景，鼓励社区交付这样的技术，以及集成它们，且要积极的推进总结进度。&lt;/li&gt;
&lt;li&gt;提供一种方法来培养各个部分的通用技术标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;c) 推广底层技术和应用定义和管理方法，途径包括：活动和会议、营销（SEM、直接营销）、培训课程和开发人员认证。&lt;/p&gt;
&lt;p&gt;d) 通过使技术可访问和可靠来为社区服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旨在通过对参考架构进行明确定义的节奏，为每个组成部分提供完全集成和合格的构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-cncf-的价值观&#34;&gt;3. CNCF 的价值观&lt;/h3&gt;
&lt;p&gt;CNCF 会极力遵循以下一些原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;快速胜过磨叽&lt;/strong&gt;，基金会的初衷之一就是让项目快速的发展，从而支持用户能够积极的使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放！&lt;/strong&gt; CNCF 是以开放和高度透明为最高准则的，而且是独立于任何的其它团体进行运作的。CNCF 根据贡献的内容和优点接受所有的贡献者，且遵循开源的价值观，CNCF 输出的技术是可以让所有人使用和受益的，技术社区及其决策应保持高度透明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公平&lt;/strong&gt;：CNCF 会极力避免那些不好的影响、不良行为、以及“按需付费”的决策。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的技术身份&lt;/strong&gt;：CNCF 会实现并保持高度的自身技术认同，并将之同步到所有的共享项目中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清晰的边界&lt;/strong&gt;：CNCF 制定明确的目标，并在某些情况下，要确定什么不是基金会的目标，并会帮助整个生态系统的运转，让人们理解新创新的重点所在。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展&lt;/strong&gt;：能够支持从小型开发人员中心环境到企业和服务提供商规模的所有部署规模。这意味着在某些部署中可能不会部署某些可选组件，但总体设计和体系结构仍应适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平台中立&lt;/strong&gt;：CNCF 所开发的项目并不针对某个特定平台，而是旨在支持各种体系结构和操作系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-会员制&#34;&gt;4. 会员制&lt;/h3&gt;
&lt;p&gt;CNCF 中的会员包括白金、金牌、银牌、最终用户、学术和非赢利成员等级别，不同级别的会员在理事会中的投票权不同。&lt;/p&gt;
&lt;p&gt;a) &lt;strong&gt;白金会员&lt;/strong&gt;：在 CNCF 理事会中任命 1 名代表，在理事会的每个次级委员会和活动中任命 1 名有投票权的代表，在网站可以突出显示；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;b) &lt;strong&gt;金牌会员&lt;/strong&gt;：基金会中每有 5 个金牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;c) &lt;strong&gt;银牌会员&lt;/strong&gt;：基金会中每有 10 个银牌会员，该级别的会员就可以任命 1 名代表，最多任命 3 个；如果也是终端用户成员将继承终端用户成员的所有权利&lt;/p&gt;
&lt;p&gt;d) &lt;strong&gt;终端用户&lt;/strong&gt;：参加终端用户咨询社区；向终端用户技术咨询委员会中提名 1 名代表&lt;/p&gt;
&lt;p&gt;e) &lt;strong&gt;学术和非赢利会员&lt;/strong&gt;：学术和非营利会员分别限于学术和非营利机构，需要理事会批准。学术成员和非营利成员有权将其组织认定为支持 CNCF 使命的成员以及理事会确定的任何其他权利或利益。&lt;/p&gt;
&lt;h3 id=&#34;5-理事会&#34;&gt;5. 理事会&lt;/h3&gt;
&lt;p&gt;a) CNCF 理事会负责市场营销、业务监督和预算审批，不负责技术方面，除了与 TOC 配合确定 CNCF 工作范围、完成时间表 a)、更新 CNCF 网站&lt;/p&gt;
&lt;p&gt;b) 负责日常事务&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与 TOC 协商 CNCF 的整体范围&lt;/li&gt;
&lt;li&gt;商标和版权保护&lt;/li&gt;
&lt;li&gt;市场营销、布道和生态系统建设&lt;/li&gt;
&lt;li&gt;创建和执行品牌承诺项目，如果需要的话&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;募资和财务管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;c) 理事会投票成员由会员代表和社区代表组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员代表包括：
&lt;ul&gt;
&lt;li&gt;每名白金会员任命 1 名代表&lt;/li&gt;
&lt;li&gt;黄金和银牌成员当选代表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术社区代表包括：
&lt;ul&gt;
&lt;li&gt;技术监督委员会主席&lt;/li&gt;
&lt;li&gt;根据当时在任的理事会批准的程序从 CNCF 项目中选出两名提交者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理事会可能会以白金会员比例的价格扩展白金会员资格，对年收入低于 5000 万美元的创业公司进行长达 5 年的逐年审计，这些公司被视为理事会的战略技术贡献者。&lt;/li&gt;
&lt;li&gt;只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任会员代表。只有来自一组&lt;strong&gt;关联公司&lt;/strong&gt;的人员可以担任技术社区代表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;d) 职责&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;批准预算，指导将所有收入来源筹集的资金用于技术、市场或社区投资，以推动 CNCF 基金的使命；&lt;/li&gt;
&lt;li&gt;选举理事会主席主持会议，批准预算批准的支出并管理日常运作；&lt;/li&gt;
&lt;li&gt;对理事会的决定或事项进行投票；&lt;/li&gt;
&lt;li&gt;界定和执行基金会的知识产权（版权，专利或商标）政策；&lt;/li&gt;
&lt;li&gt;通过活动、新闻和分析师宣传、网络、社交媒体以及其他营销活动进行直接营销和布道；&lt;/li&gt;
&lt;li&gt;监督运营，业务发展；&lt;/li&gt;
&lt;li&gt;建立并监督为推动 CNCF 的使命而创建的任何委员会；&lt;/li&gt;
&lt;li&gt;根据 CNCF 要求（可能包括认证测试）建立并执行品牌合规计划（如有），以使用 TOC 建立的品牌标志；&lt;/li&gt;
&lt;li&gt;采用商标使用准则或政策；&lt;/li&gt;
&lt;li&gt;提供整体财务管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;e) 基金会的收入用途&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;市场营销，用户扩展 CNCF 中的项目的采用&lt;/li&gt;
&lt;li&gt;关键设施建设、运行和管理项目的基础设施&lt;/li&gt;
&lt;li&gt;促进基于容器的计算使用 CNCF 中的项目实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-技术监督委员会toc&#34;&gt;6. 技术监督委员会（TOC）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) 要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNCF 技术监督委员会，为了保持中立，则达成了以下共识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义和维护 CNCF 的技术愿景。&lt;/li&gt;
&lt;li&gt;批准由理事会制定的 CNCF 范围内的新项目，并为项目创建一个概念架构。&lt;/li&gt;
&lt;li&gt;纠正项目的发展方向，决策删除或存档项目。&lt;/li&gt;
&lt;li&gt;接受最终用户委员会的反馈并反映在项目中。&lt;/li&gt;
&lt;li&gt;在科学管理的情况下调整组件的接口（在代码标准化之前实现参考）&lt;/li&gt;
&lt;li&gt;定义在 CNCF 项目中实施的常用做法（如果有的话）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;b) 技术监督委员会的构成&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 最多由 9 名成员组成。&lt;/li&gt;
&lt;li&gt;选出的 TOC 成员将涵盖关键的技术领域：容器技术、操作系统、技术运维、分布式系统、用户级应用程序设计等。&lt;/li&gt;
&lt;li&gt;理事会将选举 6 名 TOC 成员，最终用户 TAB 将选出 1 名 TOC 成员，最初的 7 名 TOC 成员应另选两名 TOC 成员。&lt;/li&gt;
&lt;li&gt;如果超过两名 TOC 成员来自同一组关联公司，无论是在选举时还是来自后来的工作变更，他们将共同决定谁应该下台，或如果没有协商的依据，则应抽签决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;c) 运营模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 会选举出 TOC 的主席来，此角色主要负责 TOC 的议程和召集会议。&lt;/li&gt;
&lt;li&gt;TOC 每个季度会面对面讨论重要的热点问题。&lt;/li&gt;
&lt;li&gt;TOC 可能会根据需要开会讨论新出现的问题。TOC 审核可能会提出以下问题：
&lt;ul&gt;
&lt;li&gt;任何的 TOC 成员&lt;/li&gt;
&lt;li&gt;任何的理事会成员&lt;/li&gt;
&lt;li&gt;建立的 CNCF 项目的维护者或顶级项目负责人&lt;/li&gt;
&lt;li&gt;CNCF 执行董事&lt;/li&gt;
&lt;li&gt;最终用户技术咨询委员会获得多数票&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持透明：TOC 会议、邮件列表、以及会议记录等均是公开可访问的。&lt;/li&gt;
&lt;li&gt;简单的 TOC 问题可以通过简短的讨论和简单的多数表决来解决。TOC 讨论可通过电子邮件或 TOC 会议进行。&lt;/li&gt;
&lt;li&gt;在对意见和可选虚拟讨论/辩论选项进行审查后，寻求共识并在必要时进行投票。&lt;/li&gt;
&lt;li&gt;目的是让 TOC 在 TOC 和社区内寻找达成共识的途径。满足法定人数要求的会议的 TOC 决定应以超过 TOC 成员出席率的 50％的方式通过。&lt;/li&gt;
&lt;li&gt;TOC 会议需要 TOC 总人数的三分之二法定人数进行表决或作出任何决定。如果 TOC 会议未能达到法定人数要求，可以进行讨论，但不应有任何投票或决定。&lt;/li&gt;
&lt;li&gt;TOC 决定可以在没有会议的情况下以电子方式提出，但要通过表决则需要多少票数才能达到会议法定人数。在电子投票中，如果任何两名 TOC 成员要求召开会议讨论决定，则电子投票结束时无效，并且在会议结束后可以启动新的投票，以讨论决定已经完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;d) 提名标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得 TOC 提名的开源贡献者应该具备下面条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;承诺有足够的可用可用时间参与 CNCF TOC 的活动，包括在 CNCF 成立时相当早期的投入，然后需持续投入时间，而且在季度的 TOC 会议之前要进行充分的准备和审查事宜。&lt;/li&gt;
&lt;li&gt;在 CNCF 范围内展示了高水准的专业经验。&lt;/li&gt;
&lt;li&gt;证明其有资格能够获得额外的工作人员或社区成员协助其在 TOC 的工作。&lt;/li&gt;
&lt;li&gt;在讨论中保持中立，并提出 CNCF 的目标和成功与公司目标或 CNCF 中的任何特定项目保持平衡。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;e) TOC 成员提名和选举程序&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 由 9 位 TOC 成员组成：由理事会选出的 6 位，由最终用户 TAB 选出的 1 位和由最初的 7 位 TOC 成员选出的 2 位。&lt;/li&gt;
&lt;li&gt;提名：每个有资格提名 TOC 成员的个人（实体或成员）可以提名至多 2 名技术代表（来自供应商、最终用户或任何其他领域），其中至多一个可能来自其各自公司。被提名者必须提前同意加入到候选人名单中。
&lt;ul&gt;
&lt;li&gt;最初的 7 名 TOC 成员（理事会选出的 6 名成员加上由最终用户 TAB 选出的 1 名成员）应使用提名程序提名并选举 2 名 TOC 成员。&lt;/li&gt;
&lt;li&gt;提名者需要提供最多一页纸的介绍，其中包括被提名者的姓名，联系信息和支持性陈述，确定了在 CNCF 领域提名的经验。&lt;/li&gt;
&lt;li&gt;理事会、最终用户 TAB 和 TOC 应确定提名、投票和关于 TOC 选举提名和选举过程的任何其他细节的时间表和日期。&lt;/li&gt;
&lt;li&gt;评估期间最少保留 14 个日历日，TOC 提名者可以联系和/或评估候选人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选举：评估期结束后，理事会、最终用户标签和最初的 7 位 TOC 成员应分别对每位被候选人进行表决。有效投票需要满足会议法定人数所需的选票数量。每名被候选人均需要支持超过 50％的投票人数，以确认被提名者符合资格标准。以多数票通过的候选人应为合格的 TOC 成员。&lt;/li&gt;
&lt;li&gt;如果合格的被提名者的人数等于或少于可选 TOC 席位的数量，则此被提名者应在提名期结束后获得批准。如果有更多的合格被候选人比理事会，最终用户 TAB 或 TOC 可选的开放 TOC 席位多，那么该组应通过 Condorcet 投票选出 TOC 成员。Condorcet 投票应通过康奈尔在线服务（http://civs.cs.cornell.edu/）使用 Condorcet-IRV 方法运行。&lt;/li&gt;
&lt;li&gt;如果理事会，最终用户 TAB 或 TOC 可供选举的公开 TOC 席位的合格被候选人数较少，该小组将启动另一轮提名，每名成员或个人有资格提名至多提名 1 名候选人。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;f) 约束条件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TOC 的成员任期为两年，来自理事会选举的最初六名当选 TOC 成员的任期为 3 年。由最终用户 TAB 和 TOC 选出的 TOC 成员的初始任期为 2 年。&lt;/li&gt;
&lt;li&gt;TOC 成员可能会被其他 TOC 成员的三分之二投票撤除，受影响的个人不能参加投票。&lt;/li&gt;
&lt;li&gt;任何 TOC 成员连续 3 次连续会议都将被自动暂停投票资格，直至连续参加两次会议。为避免疑义，暂停的 TOC 成员有资格在连续第二次会议中投票。&lt;/li&gt;
&lt;li&gt;TOC 章程、模式、方法、组成等可以由整个理事会的三分之二票通过修改。&lt;/li&gt;
&lt;li&gt;TOC 议程将由 TOC 制定。但是，预计最初的 TOC 讨论和决定将包括：
&lt;ul&gt;
&lt;li&gt;评估包含在 CNCF 中的技术&lt;/li&gt;
&lt;li&gt;确定新技术纳入 CNCF 的接受标准&lt;/li&gt;
&lt;li&gt;定义批准作为标准 API 的贡献技术的流程&lt;/li&gt;
&lt;li&gt;找出需要进一步调查的直接差距&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-最终用户社区&#34;&gt;7. 最终用户社区&lt;/h3&gt;
&lt;p&gt;a) CNCF 的最终用户成员有权协调和推动 CNCF 用户作为 CNCF 设计的消费者的重要活动。任何作为最终用户的成员或非成员，每个“最终用户参与者”均可被邀请参加。最终用户参与者将帮助向技术咨询委员会和 CNCF 社区就与用户有关的主题提供意见。&lt;/p&gt;
&lt;p&gt;b) 	最终用户技术咨询委员会是由最终用户社区成员选举所产生。&lt;/p&gt;
&lt;p&gt;c) 最终用户社区成员将获得 CNCF 执行董事的批准，或者 CNCF 执行董事缺席的话，则由 Linux 基金会执行董事来批准。&lt;/p&gt;
&lt;h3 id=&#34;8-最终用户技术咨询委员会最终用户-tab&#34;&gt;8. 最终用户技术咨询委员会（“最终用户 TAB”）&lt;/h3&gt;
&lt;p&gt;a) 构成：最终用户 TAB 应由来自最终用户参与者的 7 名代表加上 TOC 的 1 名成员组成，以便于从最终用户 TAB 到 TOC 的晋级。&lt;/p&gt;
&lt;p&gt;b) 选举：为了鼓励最终用户参与 CNCF，前 7 名最终用户会员可以委任 1 名代表参加初始最终用户 TAB，并将 CNCF 董事分配给任何最终用户参与者的任何剩余席位。在第一年之后，所有最终用户参与者可以提名 1 名代表并且最终用户社区应该投票选择使用当前最终用户 TAB 批准流程的最终用户 TAB 成员。&lt;/p&gt;
&lt;p&gt;c) 经过三分之二投票通过后最终用户 TAB 可以更改最终用户社区的大小，前提是至少有 7 名可能的代表。&lt;/p&gt;
&lt;p&gt;d) 最终用户代表应当基于业务和技术敏锐度提名。候选人应该具备建设和运营体现 CNCF 原则的基础设施和应用方面的重要实践经验。&lt;/p&gt;
&lt;p&gt;e) 最终用户 TAB 将讨论和推进主题，重点是找出 TOC 和 CNCF 开发者社区的差距并提出优先事项。&lt;/p&gt;
&lt;p&gt;f) 也会侧重于主动推进最终用户关心的话题，促进 CNCF 的市场采用，为最终用户举办会议或向理事会提供咨询。&lt;/p&gt;
&lt;p&gt;g) 如果最终用户 TAB 有意愿的话，它可以批准小组委员会特别兴趣小组（“SIG”）来解决行业或专业话题。&lt;/p&gt;
&lt;p&gt;h) 最终用户 TAB 是技术监督委员会的主要输入方，应与技术监督委员会的其他输入方和反馈一起作出决策和计划。这些建议只是建议性的，在任何时候，最终用户 TAB 的建议都不能用于命令或指导任何 TOC 或项目参与者采取任何行动或结果。&lt;/p&gt;
&lt;p&gt;i) 为促进与 TOC 的双边互动，最终用户技术咨询委员会应选出 1 名 TOC 代表。最终用户 TAB 可邀请任何人参加最终用户会议、SIG 或其他讨论。&lt;/p&gt;
&lt;h3 id=&#34;9-cncf-项目&#34;&gt;9. CNCF 项目&lt;/h3&gt;
&lt;p&gt;通常情况下，是由 CNCF 的成员公司、开源社区的成员将项目先是带到 CNCF 的技术监督委员会来进行讨论，然后决定是否被 CNCF 接纳。要贡献给 CNCF 的项目必须是经过技术监督委员会制定的标准的，之后当然还要经过理事会的批准。CNCF 的目标是希望捐赠给 CNCF 的项目和 CNCF 已有的项目在一定程度上是有关联的，而且是可集成的。&lt;/p&gt;
&lt;p&gt;和 CNCF 关联起来有以下三种方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 已经在 CNCF 的纳管之下，毕竟 CNCF 是中立的，致力于成为大家的协作的归属地。&lt;/p&gt;
&lt;p&gt;a) 项目的方方面面都交由 CNCF 来打理
b) 项目是由 CNCF 来进行市场推广的
c) 项目是解决云原生计算问题的核心组件，如 Kubernetes、Mesos、etcd 等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 通过 API 或规范与 CNCF 相关联 XM&lt;/p&gt;
&lt;p&gt;a) 包括 CNCF 可能提供或启用多个选项的组件
b) 该项目被称为 CNCF 集成的一个组成部分，而不是由 CNCF 主办的项目
c) 集成和合规性由 API 或规范定义
d) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; CNCF 使用到的&lt;/p&gt;
&lt;p&gt;a) 项目或组件完全根据 OSI 批准的开源许可证进行授权，并且管理良好，并在 CNCF 中被用作组件。&lt;/p&gt;
&lt;p&gt;b) 项目并没有由 CNCF 来进行市场推广&lt;/p&gt;
&lt;p&gt;c) 项目或组件的开发是由上游社区所开发，而且保持一定的活跃度&lt;/p&gt;
&lt;p&gt;现有的开源项目应该继续保持其现有的技术治理结构，以保持凝聚力和速度。但是由技术监督委员会批准之后，则会适当的进行一些适应。&lt;/p&gt;
&lt;p&gt;应根据个人的水平和贡献期限在项目间建立一个达到提交者地位的标准协议。因为提交者是维护者的选拔人才池，有了一定程度的贡献，且经过同行们的认可，提交者就可晋升为维护者。&lt;/p&gt;
&lt;p&gt;CNCF 启动的新开源项目应完成 TOC 采纳的项目建议模板，并由 TOC 批准纳入 CNCF。TOC 成员应有充足的时间讨论和审查新的项目建议书。新的项目建议书应包括项目中的角色细节，为项目提出的治理，并确定与 CNCF 的角色和价值观保持一致。&lt;/p&gt;
&lt;h3 id=&#34;10-市场委员会&#34;&gt;10. 市场委员会&lt;/h3&gt;
&lt;p&gt;a) 构成，市场委员会将向所有成员开放参与，应选举市场委员会主席制定会议议程，进行一般的讨论，并帮助委员会实现其目标。市场委员会应尽可能寻求共识。在市场委员会中无法达成共识的任何问题应提交给理事会。&lt;/p&gt;
&lt;p&gt;b) 职责，市场委员会代表理事会负责设计，开发和执行相关的市场工作。&lt;/p&gt;
&lt;p&gt;c) 如果市场委员会变得太大而无法有效运作，市场委员会可以选择选举市场董事，并将决策权委托给市场董事。&lt;/p&gt;
&lt;h3 id=&#34;11-知识产权政策&#34;&gt;11. 知识产权政策&lt;/h3&gt;
&lt;p&gt;a) 任何加入到 CNCF 的项目都必须将其拥有的商标和徽标资产转让给 Linux 基金会的所有权。&lt;/p&gt;
&lt;p&gt;b) 每个项目应确定是否需要使用经批准的 CNCF CLA。对于选择使用 CLA 的项目，所有代码贡献者将承担 Apache 贡献者许可协议中规定的义务，只有在必要时才作出修改，以确定 CNCF 是捐赠的接受者，并且应由理事会批准。请参阅 &lt;a href=&#34;https://github.com/cncf/cla&#34; title=&#34;https://github.com/cncf/cla&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/cla&lt;/a&gt;
 上提供的 CNCF 参与者许可协议。&lt;/p&gt;
&lt;p&gt;c) 所有向 CNCF 提交的新入站代码应当（i）附有开发者原始证书签名（&lt;a href=&#34;http://developercertificate.org&#34; title=&#34;http://developercertificate.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://developercertificate.org&lt;/a&gt;
和（ii）根据 Apache 许可证 2.0 版（可从&lt;a href=&#34;http://developercertificate.org&#34; title=&#34;http://developercertificate.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://developercertificate.org&lt;/a&gt;
和&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34; title=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;
 获得）该许可证除了并且不得取代根据上文（b）规定的供款许可协议所承担的义务。&lt;/p&gt;
&lt;p&gt;d) 所有出站代码将在 Apache 许可证 2.0 版下提供。&lt;/p&gt;
&lt;p&gt;e) 所有评估纳入 CNCF 的项目都必须获得 OSI 批准的开源许可证的完全许可，如果 CNCF 中包含的项目的许可证不是 Apache 许可证 2.0 版，则需要获得理事会的批准。&lt;/p&gt;
&lt;p&gt;f) 所有文档将由 CNCF 根据知识共享署名 4.0 国际许可证来提供。&lt;/p&gt;
&lt;p&gt;g) 如果需要替代入站或出站许可证以符合杠杆式开放源代码项目的许可证或为实现 CNCF 的使命而需要其他许可证，理事会可以批准使用替代许可证 对于例外情况下的接受或提供的项目捐赠。&lt;/p&gt;
&lt;h3 id=&#34;12-反托拉斯指南&#34;&gt;12. 反托拉斯指南&lt;/h3&gt;
&lt;p&gt;a) 所有成员均应遵守&lt;a href=&#34;http://www.linuxfoundation.org/antitrust-policy&#34; title=&#34;http://www.linuxfoundation.org/antitrust-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.linuxfoundation.org/antitrust-policy&lt;/a&gt;
上提供的 Linux 基金会反托拉斯政策中规定的 Linux 基金会的要求。&lt;/p&gt;
&lt;p&gt;b) 所有成员都应鼓励任何能够满足成员要求的组织的公开参与，而不论其竞争利益如何。换言之，理事会不应根据除用于所有成员的标准，要求或原因之外的任何标准，要求或理由寻求排除成员。&lt;/p&gt;
&lt;h3 id=&#34;13-行为准则&#34;&gt;13. 行为准则&lt;/h3&gt;
&lt;p&gt;所有参与者都须同意遵守 &lt;a href=&#34;http://events.linuxfoundation.org/code-of-conduct&#34; title=&#34;Linux 基金会行为准则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 基金会行为准则&lt;/a&gt;
。TSC 可以投票通过自己的 CNCF 行为准则。&lt;/p&gt;
&lt;h3 id=&#34;14-关联公司&#34;&gt;14. 关联公司&lt;/h3&gt;
&lt;p&gt;a) 定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“子公司”是指会员直接或间接拥有所涉实体超过百分之五十有投票权的证券或会员权益的任何实体；&lt;/li&gt;
&lt;li&gt;“关联公司”是指任何控制或由成员控制的实体，或者与成员一起受第三方共同控制的实体，在所有情况下，直接或间接拥有多于所有权的控制权；&lt;/li&gt;
&lt;li&gt;“关联公司”是指各成员的关联公司。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b) 只有执行了参与协议的法人实体及其子公司才有权享有该会员的权利和特权；但条件是该成员及其子公司应作为单一成员共同对待。&lt;/p&gt;
&lt;p&gt;c) 只有一名属于一组关联公司的成员有权一次性任命或提名理事会代表参加类别选举。&lt;/p&gt;
&lt;p&gt;d) 如果会员本身是会员或赞助商的基金会，联盟，开源项目，会员组织，用户组或其他实体，那么授予该成员的权利和特权只能扩展到该成员的员工代表，而不能扩展到其成员或发起人，除非理事会不时在特定情况下另行批准。&lt;/p&gt;
&lt;p&gt;e) 会员资格不得转让，不可转让、也不能转让，除非现有会员将其现有的会员利益和义务转让给其大部分业务和/或资产的继任者，无论是通过合并，出售还是其他方式；只要受让人同意遵守 CNCF 的章程以及 Linux Foundation 成员所需的章程和政策。&lt;/p&gt;
&lt;h3 id=&#34;15-预算&#34;&gt;15. 预算&lt;/h3&gt;
&lt;p&gt;a) 理事会应批准年度预算，绝不会承诺超出筹集的资金。预算应与 Linux 基金会的非营利性使命相一致。&lt;/p&gt;
&lt;p&gt;b) Linux 基金会应定期报告预算支出。&lt;/p&gt;
&lt;h3 id=&#34;16-常规和管理费用&#34;&gt;16. 常规和管理费用&lt;/h3&gt;
&lt;p&gt;a) Linux 基金会应保管任何费用，资金和其他现金收据。&lt;/p&gt;
&lt;p&gt;b) 一般和行政（G＆A）费用将用于筹集资金以支付财务、会计和运营费用。G＆A 费用应等于 CNCF 首期总收入 1,000,000 美元的 9％以及 CNCF 总收入超过 1,000,000 美元的 6％。&lt;/p&gt;
&lt;h3 id=&#34;17-一般规则和操作&#34;&gt;17. 一般规则和操作&lt;/h3&gt;
&lt;p&gt;参与 CNCF 应做到：&lt;/p&gt;
&lt;p&gt;a) 展示与开源项目开发人员社区进行协调的计划和方法，包括关于代表社区的品牌、徽标和其它标志性的主题；&lt;/p&gt;
&lt;p&gt;b) 以专业的方式体现维持社区的凝聚力为目标，同时还要保持 Linux 基金会在开放源代码软件社区的善意和尊重；&lt;/p&gt;
&lt;p&gt;c) 尊重所有商标所有人的权利，包括任何品牌和使用准则；&lt;/p&gt;
&lt;p&gt;d) 参与 Linux 基金会的所有新闻和分析师关系活动；&lt;/p&gt;
&lt;p&gt;e) 根据要求，向 Linux 基金会提供关于项目参与的信息，包括参加项目赞助活动的信息；&lt;/p&gt;
&lt;p&gt;f) 直接参与到基金会旗下的任何站点。&lt;/p&gt;
&lt;p&gt;g) 根据理事会批准的规则和程序进行运营，前提是这些规则和程序不得与 Linux 基金会的宗旨和政策不一致，并且不得损害 Linux 基金会。&lt;/p&gt;
&lt;h3 id=&#34;18-修正案&#34;&gt;18. 修正案&lt;/h3&gt;
&lt;p&gt;本章程可以通过所有理事会成员的三分之二票数（不包括弃权）进行修改，前提是任何此类修改不得与 Linux 基金会的目的或政策不一致，并且不得对 Linux 基金会产生不利影响。&lt;/p&gt;
&lt;h3 id=&#34;时间表-a提出-cncf-范围愿景&#34;&gt;时间表 A：提出 CNCF 范围愿景&lt;/h3&gt;
&lt;p&gt;CNCF 背后的首要目标是支持和加速“云原生计算”的采用。以下内容是初步范围，旨在阐明 CNCF 将努力实施的“云原生计算”的核心概念。该初始范围应成为发布在 CNCF 网站上的文档。&lt;/p&gt;
&lt;p&gt;CNCF 社区坚信云原生计算包含三个核心属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装和分发&lt;/li&gt;
&lt;li&gt;动态调度&lt;/li&gt;
&lt;li&gt;面向微服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：关于云原生的定义正在重新设定中，已经与上述不同了。&lt;/p&gt;
&lt;p&gt;云原生计算系统支持基于这些核心属性的计算，并包含以下理想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放性和可扩展性&lt;/li&gt;
&lt;li&gt;在标准化子系统的边界处定义良好的 API&lt;/li&gt;
&lt;li&gt;应用程序生命周期管理的最小障碍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为上述时间表已经有些过时了，CNCF 成立已经有三年时间了，正在规划新的方案。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/&#34; title=&#34;https://www.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; title=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/charter/&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/landscape&#34; title=&#34;https://github.com/cncf/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/landscape&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/toc&#34; title=&#34;https://github.com/cncf/toc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/toc&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ocselected.org/posts/foundation_introduce/how_cncf_works/&#34; title=&#34;CNCF 是如何工作的&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 是如何工作的&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>博客</title>
      <link>https://jimmysong.io/blog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jimmysong.io/blog/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
