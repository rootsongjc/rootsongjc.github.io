<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song&#39;s Blog – Linux</title>
    <link>https://jimmysong.io/categories/linux/</link>
    <description>Recent content in Linux on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 02 Jun 2022 12:00:00 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>第一章：eBPF 简介</title>
      <link>https://jimmysong.io/book/what-is-ebpf/introduction/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/introduction/</guid>
      <description>
        
        
        &lt;p&gt;在过去的几年里，eBPF 已经从相对默默无闻变成了现代基础设施建设中最热门的技术领域之一。就我个人而言，自从看到 Thomas Graf 在 DockerCon 17 的&lt;a href=&#34;https://www.youtube.com/watch?v=ilKlmTDdFgk&amp;amp;ab_channel=Docker&#34; title=&#34;黑带会议&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;黑带会议&lt;/a&gt;
（Black Blet）&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 上谈到 eBPF 时，我就对它的可能性感到兴奋。在云原生计算基金会（CNCF），我在技术监督委员会（TOC）的同事把 eBPF 作为我们预测 2021 年将会起飞的重点技术之一来关注。超过 2500 人报名参加了当年的 eBPF 峰会线上会议，世界上最先进的几家软件工程公司共同创建了 &lt;a href=&#34;https://ebpf.io/foundation&#34; title=&#34;eBPF 基金会&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 基金会&lt;/a&gt;
。显然，人们对这项技术有很大的兴趣。&lt;/p&gt;
&lt;p&gt;在这个简短的报告中，我希望能给你一些启示，为什么人们对 eBPF 如此兴奋，以及它在现代计算环境中提供的工具能力。你会了解到 eBPF 是什么以及为什么它如此强大。还有一些代码实例，以使这种感觉更加具象化（但如果你愿意，你可以跳过这些）。&lt;/p&gt;
&lt;p&gt;你将了解到在建立支持 eBPF 的工具时涉及的内容，以及为什么 eBPF 在如此短的时间内变得如普遍。&lt;/p&gt;
&lt;p&gt;在这份简短的报告中，难免无法了解所有的细节，但如果你想更深入地了解，我将给你一些参考信息。&lt;/p&gt;
&lt;h2 id=&#34;扩展的伯克利数据包过滤器&#34;&gt;扩展的伯克利数据包过滤器&lt;/h2&gt;
&lt;p&gt;让我们把缩写说出来：eBPF 代表&lt;strong&gt;扩展的伯克利数据包过滤器（Extended Berkeley Packet Filter）&lt;/strong&gt;。从这个名字中，你可以看到它的根源在于过滤网络数据包，而且最初的 &lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34; title=&#34;论文&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;论文&lt;/a&gt;
 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 是在伯克利实验室（Lawrence Berkeley National Laboratory）写的。但是（在我看来）这个名字对于传达 eBPF 的真正力量并没有很大的帮助，因为&amp;quot;扩展&amp;quot; 版本可以实现比数据包过滤多得多的功能。最近，eBPF 被用作一个独立的名称，它所包含的内容比它的缩写更多。&lt;/p&gt;
&lt;p&gt;那么，如果它不仅仅是包过滤，什么是 eBPF？eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。这意味着它可以扩展甚至修改内核的行为。&lt;/p&gt;
&lt;p&gt;当 eBPF 程序被加载到内核中时，有一个验证器确保它是安全运行的，如果无法确认，则拒绝它。一旦加载，eBPF 程序需要被附加到一个事件上，这样，每当事件发生时，程序就会被触发。&lt;/p&gt;
&lt;p&gt;eBPF 最初是为 Linux 开发的，这也是我在本报告中重点讨论的操作系统；但值得注意的是，截至本文写作时，微软正在 &lt;a href=&#34;https://oreil.ly/J0N1H&#34; title=&#34;为 Windows 开发 eBPF 的实现&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为 Windows 开发 eBPF 的实现&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;现在，广泛使用的 Linux 内核都支持 &amp;ldquo;扩展&amp;rdquo; 部分，eBPF 和 BPF 这两个术语现在基本上可以互换使用。&lt;/p&gt;
&lt;h2 id=&#34;基于-ebpf-的工具&#34;&gt;基于 eBPF 的工具&lt;/h2&gt;
&lt;p&gt;正如你在本报告中所看到的，动态改变内核行为的能力非常有用。传统上，如果我们想观察应用程序的行为，我们在应用程序中添加代码，以产生日志和追踪。eBPF 允许我们收集关于应用程序行为的定制信息，通过在内核中观察它，而不必修改应用程序。我们可以在这种可观测性的基础上创建 eBPF 安全工具，从内核中检测甚至防止恶意活动。我们可以用 eBPF 创建强大的、高性能的网络功能，在内核内处理网络数据包，避免昂贵的用户空间转换。&lt;/p&gt;
&lt;p&gt;从内核的角度来观测应用程序的概念并不新颖——这建立在较早的 Linux 功能之上，比如 perf &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，它也从内核内部收集行为和性能信息，而不需要修改被测量的应用程序。但是这些工具定义了可以收集的数据种类以及数据的格式。有了 eBPF，我们就有了更大的灵活性，因为我们可以编写完全自定义的程序，允许我们出于不同的目的建立广泛的工具。&lt;/p&gt;
&lt;p&gt;eBPF 编程的能力异常强大，但也很复杂。对于我们大多数人来说，eBPF 的效用不是来自于自己写的程序，而是来自于使用别人创造的工具。有越来越多的项目和供应商在 eBPF 平台上创建了新一代的工具，包括可观测性、安全性、网络等。&lt;/p&gt;
&lt;p&gt;我将在本报告后面讨论这些更高级别的工具，但是，如果你对 Linux 命令行很熟悉，迫不及待地想看到 eBPF 的运行，推荐你从 BCC 项目开始。BCC 包含丰富的追踪工具集合；即使只是瞥一眼列表也可以领略到 eBPF 广泛的应用，包括文件操作、内存使用、CPU 统计，甚至观察在系统任意位置输入的 bash 命令。&lt;/p&gt;
&lt;p&gt;在下一章，我们将介绍改变内核行为的作用，为什么使用 eBPF 比直接编写内核代码更容易操作。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Thomas Graf，《Cilium——使用 BPF 和 XDP 的网络和应用安全》（DockerCon 2017 年 4 月 17-20 日）&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Steven McCanne 和 Van Jacobson，《BSD 数据包过滤器：用户级数据包捕获的新架构》（工作文件，劳伦斯伯克利国家实验室，伯克利，1992 年 12 月 19 日）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;perf 是一个 Linux 子系统，用于收集性能数据。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>什么是 eBPF？</title>
      <link>https://jimmysong.io/book/what-is-ebpf/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/</guid>
      <description>
        
        
        &lt;p&gt;《什么是 eBPF —— 新一代网络、安全和可观测性工具介绍》译自 O&amp;rsquo;Reilly 发布的报告“What is eBPF”，作者是 Liz Rice，由 JImmy Song 翻译，英文原版可以在 &lt;a href=&#34;https://www.oreilly.com/library/view/what-is-ebpf/9781492097266/&#34; title=&#34;O&amp;amp;rsquo;Reilly 网站&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;O&amp;rsquo;Reilly 网站&lt;/a&gt;
上获取。&lt;/p&gt;
&lt;h2 id=&#34;译者序&#34;&gt;译者序&lt;/h2&gt;
&lt;p&gt;最近两年来关于 eBPF 的讨论在云原生社区里越来越多，尤其是当谈到 Cilium 的商业化，使用 eBPF 来优化 Istio 服务网格，甚至扬言干掉 Sidecar 时，eBPF 更是赚足了眼球。&lt;/p&gt;
&lt;p&gt;这本报告是由基于 Cilium  的创业公司 Isovalent 的 Liz Rice 撰写，由 O&amp;rsquo;Reilly 发布，相信可以为你揭开 eBPF 技术的神秘面纱，带你了解什么是 eBPF 还有它的强大之处。更重要的是它在云原生环境中，在服务网格、可观测性和安全中的应用。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;Liz Rice 是云原生网络和安全专家，Isovalent 的首席开源官，是基于 eBPF 的 Cilium 网络项目的创建者。她在 2019-2022 年担任 CNCF 的技术监督委员会（TOC）主席，并在 2018 年担任 KubeCon + CloudNativeCon 的联合主席。她也是 Container Security 一书的作者，由 O&#39;Reilly 出版。她拥有丰富的软件开发、团队和产品管理经验，曾在网络协议和分布式系统以及数字技术领域（如 VOD、音乐和 VoIP）工作。在不写代码的时候，Liz 喜欢在天气比她的家乡伦敦好的地方骑自行车，和在 Zwift 上参加虚拟比赛。&lt;/p&gt;
&lt;h2 id=&#34;本书大纲&#34;&gt;本书大纲&lt;/h2&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/introduction/&#34;&gt;第一章：eBPF 简介&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/&#34;&gt;第二章：修改内核很困难&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-programs/&#34;&gt;第三章：eBPF 程序&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/&#34;&gt;第四章：eBPF 的复杂性&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/&#34;&gt;第五章：云原生环境中的 eBPF&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/ebpf-tools/&#34;&gt;第六章：eBPF 工具&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&#34;https://jimmysong.io/book/what-is-ebpf/conclusion/&#34;&gt;第七章：结论&lt;/a&gt;&lt;/p&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;


&lt;ul class=&#34;cta-group&#34;&gt;
  
  &lt;li&gt;
    &lt;a href=&#34;introduction&#34;  class=&#34;btn btn-sm btn-primary&#34;&gt;开始阅读&lt;/a&gt;
  &lt;/li&gt;
  
  
&lt;/ul&gt;


      </description>
    </item>
    
    <item>
      <title>第二章：修改内核很困难</title>
      <link>https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/changing-the-kernel-is-hard/</guid>
      <description>
        
        
        &lt;p&gt;由于 eBPF 允许在 Linux 内核中运行自定义代码，在解释 eBPF 之前我需要确保你对内核的作用有所了解。然后我们将讨论为什么在修改内核行为这件事情上，eBPF 改变了游戏规则。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核&#34;&gt;Linux 内核&lt;/h2&gt;
&lt;p&gt;Linux 内核是应用程序和它们所运行的硬件之间的软件层。应用程序运行在被称为&lt;strong&gt;用户空间&lt;/strong&gt;的非特权层，它不能直接访问硬件。相反，应用程序使用系统调用（syscall）接口发出请求，要求内核代表它行事。这种硬件访问可能涉及到文件的读写，发送或接收网络流量，或者只是访问内存。内核还负责协调并发进程，使许多应用程序可以同时运行。&lt;/p&gt;
&lt;p&gt;应用程序开发者通常不直接使用系统调用接口，因为编程语言给了我们更高级别的抽象和&lt;strong&gt;标准库&lt;/strong&gt;，开发者更容易掌握这些接口。因此，很多人都不知道在程序运行时内核做了什么。如果你想了解内核调用频率，你可以使用 strace 工具来显示程序所做的所有系统调用。这里有一个例子，用 cat 从文件中读取 hello 这个词并将其写到屏幕上涉及到 100 多个系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;liz@liz-ebpf-demo-1:~$ strace -c cat liz.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;     seconds  usecs/call     calls    errors syscall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         5	  &lt;span class=&#34;nb&#34;&gt;read&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  write
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        21	  close
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        20	  fstat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        23	  mmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  mprotect
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	  munmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         3	  brk
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  pread64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; access
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  execve
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; arch_prctl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  fadvise64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        19	  openat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;100.00    0.000000              &lt;span class=&#34;m&#34;&gt;107&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; total
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于应用程序在很大程度上依赖于内核，这意味着如果我们能够观测到应用程序与内核的交互，我们就可以了解到很多关于它的行为方式。例如，如果你能够截获打开文件的系统调用，你就可以准确地看到任何应用程序访问了哪些文件。但是，怎么才能做到这种拦截呢？让我们考虑一下，如果我们想修改内核，添加新的代码，在系统调用时创建某种输出，会涉及到什么问题。&lt;/p&gt;
&lt;h2 id=&#34;向内核添加新功能&#34;&gt;向内核添加新功能&lt;/h2&gt;
&lt;p&gt;Linux 内核很复杂，在写这篇文章的时候有大约 3000 万行代码 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。对任何代码库进行修改都需要对现有的代码有一定的熟悉，所以除非你已经是一个内核开发者，否则这很可能是一个挑战。&lt;/p&gt;
&lt;p&gt;但你将面临的挑战并不是纯粹的技术问题。Linux 是一个通用的操作系统，在不同的环境和情况下使用。这意味着，如果你想对内核进行修改，这并不是简单地写出能用的代码。它必须被社区（更确切地说，是被 Linux 的创造者和主要开发者 Linus Torvalds）接受，你的改变将是为了大家的更大利益。而这并不是必然的——提交的内核补丁只有三分之一被接受 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;假如，你已经想出了一个好方法来拦截打开文件的系统调用。经过几个月的讨论和一些艰苦的开发工作，让我们想象一下，这个变化被接受到内核中。很好！但是，要到什么时候它才会出现在每个人的机器上呢？&lt;/p&gt;
&lt;p&gt;每隔两三个月就会有一个新的 Linux 内核版本，但是即使一个变化已经进入了其中一个版本，它仍然需要一段时间才能在大多数人的生产环境中使用。这是因为我们大多数人并不直接使用 Linux 内核——我们使用像 Debian、Red Hat、Alpine、Ubuntu 等 Linux 发行版，它们将 Linux 内核的一个版本与其他各种组件打包在一起。你可能会发现，你最喜欢的发行版使用的是几年前的内核版本。&lt;/p&gt;
&lt;p&gt;例如，很多企业用户都采用红帽 ® Enterprise Linux®（RHEL）。在撰写本文时，目前的版本是 RHEL8.5，发行日期为 2021 年 11 月。这使用的是基于 4.18 版本的内核。这个内核是在 2018 年 8 月发布的。&lt;/p&gt;
&lt;p&gt;如 &lt;a href=&#34;#figure-f-2-1&#34; title=&#34;图 2-1&#34;&gt;图 2-1&lt;/a&gt;
 中的漫画所示，将新功能从想法阶段转化为生产环境中的 Linux 内核，需要数年时间 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-2-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）&#34; id=&#34;f-2-1&#34;data-img=&#34;f-2-1.jpg&#34;
         data-caption=&#34;图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）&#34;
         
         
         data-width=&#34;1780&#34;
         data-height=&#34;1140&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;内核模块&#34;&gt;内核模块&lt;/h2&gt;
&lt;p&gt;如果你不想等上好几年才把你的改动写进内核，还有一个选择。Linux 内核可以接受内核模块（module），这些模块可以根据需要加载和卸载。如果你想改变或扩展内核行为，编写一个模块是理所当然的。在我们打开文件的系统调用的例子中，你可以写一个内核模块来实现。&lt;/p&gt;
&lt;p&gt;这里最大的挑战是，这仍然是全面的内核编程。用户在使用内核模块时历来非常谨慎，原因很简单：如果内核代码崩溃了，就会导致机器和上面运行的所有东西瘫痪。用户如何确保内核模块可以安全运行呢？&lt;/p&gt;
&lt;p&gt;“安全运行”并不仅仅意味着不崩溃——用户想知道内核模块从安全角度来看是否安全。是否包括攻击者可以利用的漏洞？我们是否相信模块的作者不会在其中加入恶意代码？因为内核是特权代码，它可以访问机器上的一切，包括所有的数据，所以内核中的恶意代码将是一个令人担忧的严重问题。这也适用于内核模块。&lt;/p&gt;
&lt;p&gt;考虑到内核的安全性，这就是为什么 Linux 发行商需要这么长时间来发布新版本的一个重要原因。如果其他人已经在各种情况下运行了数月或数年的内核版本，那些漏洞可能已经被修复。发行版的维护者可以有一些信心，他们提供给用户 / 客户的内核是经过加固的，也就是说，可以安全运行。&lt;/p&gt;
&lt;p&gt;eBPF 提供了一个非常不同的安全方法：&lt;strong&gt;eBPF 验证器（verifier）&lt;/strong&gt;，它确保一个 eBPF 程序只有在安全运行的情况下才被加载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-验证和安全&#34;&gt;eBPF 验证和安全&lt;/h2&gt;
&lt;p&gt;由于 eBPF 允许我们在内核中运行任意代码，需要有一种机制来确保它的安全运行，不会使用户的机器崩溃，也不会损害他们的数据。这个机制就是 eBPF 验证器。&lt;/p&gt;
&lt;p&gt;验证器对 eBPF 程序进行分析，以确保无论输入什么，它都会在一定数量的指令内安全地终止。例如，如果一个程序解除对一个指针的定义，验证器要求该程序首先检查指针，以确保它不是空的（null）。解除对指针的引用意味着 &amp;ldquo;查找这个地址的值&amp;rdquo;，而空值或零值不是一个有效的查找地址。如果你在一个应用程序中解引用一个空指针，该应用程序就会崩溃；而在内核中解引用一个空指针则会使整个机器崩溃，所以避免这种情况至关重要。&lt;/p&gt;
&lt;p&gt;验证也确保了 eBPF 程序只能访问其应该访问的内存。例如，有一个 eBPF 程序在网络堆栈中触发，并通过内核的 &lt;strong&gt;套接字缓冲区（socket buffer）&lt;/strong&gt;，其中包括正在传输的数据。有一些特殊的辅助函数，如 &lt;code&gt;bpf_skb_load_bytes()&lt;/code&gt;，这个 eBPF 程序可以调用，从套接字缓冲区读取字节数据。另一个由系统调用触发的 eBPF 程序，没有可用的套接字缓冲区，将不允许使用这个辅助函数。验证器还确保程序只读取套接字缓冲区内的数据字节——它不允许访问任意的内存。这里的目的是确保 eBPF 程序是安全的。&lt;/p&gt;
&lt;p&gt;当然，仍然有可能编写一个恶意的 eBPF 程序。如果你可以出于合法的原因观测数据，你也可以出于非法的原因观测它。要注意只从可验证的来源加载可信的 eBPF 程序，并且只将管理 eBPF 工具的权限授予你信任的拥有 root 权限的人。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-程序的动态加载&#34;&gt;eBPF 程序的动态加载&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以动态地加载到内核中和从内核中删除。不管是什么原因导致该事件的发生，一旦它们被附加到一个事件上就会被该事件所触发。例如，如果你将一个程序附加到打开文件的系统调用，那么只要任何进程试图打开一个文件，它就会被触发。当程序被加载时，该进程是否已经在运行，这并不重要。&lt;/p&gt;
&lt;p&gt;这也是使用 eBPF 的可观测性或安全工具的巨大优势之一——即刻获得了对机器上发生的一切事件的可视性。&lt;/p&gt;
&lt;p&gt;此外，如 &lt;a href=&#34;#figure-f-2-2&#34; title=&#34;图 2-2&#34;&gt;图 2-2&lt;/a&gt;
 所示，人们可以通过 eBPF 非常快速地创建新的内核功能，而不要求其他 Linux 用户都接受同样的变更。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-2-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）&#34; id=&#34;f-2-2&#34;data-img=&#34;f-2-2.jpg&#34;
         data-caption=&#34;图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）&#34;
         
         
         data-width=&#34;1484&#34;
         data-height=&#34;1290&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;现在你已经看到了 eBPF 是如何允许对内核进行动态的、自定义的修改的，让我们来看看如果你想写一个 eBPF 程序会涉及哪些内容。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Linux 5.12 有大约 2880 万行代码，Phoronix（2021 年 3 月）。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Yujuan Jiang 等人，《我的补丁能用了吗？要多久？》（论文，2013 年）。根据这篇研究论文，33% 的补丁将在 3 - 6 个月后被接受。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;值得庆幸的是，现有功能的安全补丁会更快地被提供。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第三章：eBPF 程序</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-programs/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-programs/</guid>
      <description>
        
        
        &lt;p&gt;在这一章中，让我们来谈谈编写 eBPF 代码。我们需要考虑在内核中运行的 eBPF 程序本身，以及与之交互的用户空间代码。&lt;/p&gt;
&lt;h2 id=&#34;内核和用户空间代码&#34;&gt;内核和用户空间代码&lt;/h2&gt;
&lt;p&gt;首先，你可以用什么编程语言来编写 eBPF 程序？&lt;/p&gt;
&lt;p&gt;内核接受字节码形式的 eBPF 程序 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。人工编写这种字节码是可能的，就像用汇编语言写应用程序代码一样——但对人类来说，使用一种可以被编译（即自动翻译）为字节码的高级语言通常更实用。&lt;/p&gt;
&lt;p&gt;由于一些原因，eBPF 程序不能用任意的高级语言编写。首先，语言编译器需要支持发出内核所期望的 eBPF 字节码格式。其次，许多编译语言都有运行时特性——例如 Go 的内存管理和垃圾回收，使它们不适合。在撰写本文时，编写 eBPF 程序的唯一选择是 C（用 clang/llvm 编译）和最新的 Rust。迄今为止，绝大多数的 eBPF 代码都是用 C 语言发布的，考虑到它是 Linux 内核的语言，这是有道理的。&lt;/p&gt;
&lt;p&gt;至少，用户空间的程序需要加载到内核中，并将其附加到正确的事件中。有一些实用程序，如 bpftool，可以帮助我们解决这个问题，但这些都是低级别的工具，假定你有丰富的 eBPF 知识，它们是为 eBPF 专家设计的，而不是普通用户。在大多数基于 eBPF 的工具中，有一个用户空间的应用程序，负责将 eBPF 程序加载到内核中，传入任何配置参数，并以用户友好的方式显示 eBPF 程序收集的信息。&lt;/p&gt;
&lt;p&gt;至少在理论上，eBPF 工具的用户空间部分可以用任何语言编写，但在实践中，有一些库只支持相当少的语言。其中包括 C、Go、Rust 和 Python。这种语言的选择更加复杂，因为并不是所有的语言都有支持 libbpf 的库，libbpf 已经成为使 eBPF 程序在不同版本的内核中可移植的流行选择。(我们将在 &lt;a href=&#34;../ebpf-complexity&#34; title=&#34;第四章&#34;&gt;第四章&lt;/a&gt;
 中讨论 libbpf）。&lt;/p&gt;
&lt;h2 id=&#34;附属于事件的自定义程序&#34;&gt;附属于事件的自定义程序&lt;/h2&gt;
&lt;p&gt;eBPF 程序本身通常是用 C 或 Rust 编写的，并编入一个对象文件 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。这是一个标准的 ELF（可执行和可链接格式，Executable and Linkable Format）文件，可以用像 &lt;strong&gt;readelf&lt;/strong&gt; 这样的工具来检查，它包含程序字节码和任何映射的定义（我们很快就会讨论）。如 &lt;a href=&#34;#figure-f-3-1&#34; title=&#34;图 3-1&#34;&gt;图 3-1&lt;/a&gt;
 所示，如果在前一章中提到的验证器允许的话，用户空间程序会读取这个文件并将其加载到内核中。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-3-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中&#34; id=&#34;f-3-1&#34;data-img=&#34;f-3-1.jpg&#34;
         data-caption=&#34;图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中&#34;
         
         
         data-width=&#34;1486&#34;
         data-height=&#34;518&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;eBPF 程序加载到内核中时必须被附加到事件上。每当事件发生，相关的 eBPF 程序就会运行。有一个非常广泛的事件，你可以将程序附加到其中；我不会涵盖所有的事件，但以下是一些更常用的选项。&lt;/p&gt;
&lt;h3 id=&#34;从函数中进入或退出&#34;&gt;从函数中进入或退出&lt;/h3&gt;
&lt;p&gt;你可以附加一个 eBPF 程序，在内核函数进入或退出时被触发。当前的许多 eBPF 例子都使用了 &lt;code&gt;kprobes&lt;/code&gt;（附加到一个内核函数入口点）和 &lt;code&gt;kretprobes&lt;/code&gt;（函数退出）的机制。在最新的内核版本中，有一个更有效的替代方法，叫做 &lt;code&gt;fentry/fexit&lt;/code&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;请注意，你不能保证在一个内核版本中定义的所有函数一定会在未来的版本中可用，除非它们是稳定 API 的一部分，如 syscall 接口。&lt;/p&gt;
&lt;p&gt;你也可以用 &lt;code&gt;uprobes&lt;/code&gt; 和 &lt;code&gt;uretprobes&lt;/code&gt; 将 eBPF 程序附加到用户空间函数上。&lt;/p&gt;
&lt;h3 id=&#34;tracepoints&#34;&gt;Tracepoints&lt;/h3&gt;
&lt;p&gt;你也可以将 eBPF 程序附加到内核内定义的 &lt;code&gt;tracepoints&lt;/code&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。通过在 &lt;code&gt;/sys/kernel/debug/tracing/events&lt;/code&gt; 下查找机器上的事件。&lt;/p&gt;
&lt;h3 id=&#34;perf-事件&#34;&gt;Perf 事件&lt;/h3&gt;
&lt;p&gt;Perf &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 是一个收集性能数据的子系统。你可以将 eBPF 程序挂到所有收集 perf 数据的地方，这可以通过在你的机器上运行 perf list 来确定。&lt;/p&gt;
&lt;h3 id=&#34;linux-安全模块接口&#34;&gt;Linux 安全模块接口&lt;/h3&gt;
&lt;p&gt;LSM 接口在内核允许某些操作之前检查安全策略。你可能见过 AppArmor 或 SELinux，利用了这个接口。通过 eBPF，你可以将自定义程序附加到相同的检查点上，从而实现灵活、动态的安全策略和一些运行时安全工具的新方法。&lt;/p&gt;
&lt;h3 id=&#34;网络接口express-data-path&#34;&gt;网络接口——eXpress Data Path&lt;/h3&gt;
&lt;p&gt;eXpress Data Path（XDP）允许将 eBPF 程序附加到网络接口上，这样一来，每当收到一个数据包就会触发 eBPF 程序。它可以检查甚至修改数据包，程序的退出代码可以告诉内核如何处理该数据包：传递、放弃或重定向。这可以构成一些非常有效的网络功能 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; 的基础。&lt;/p&gt;
&lt;h3 id=&#34;套接字和其他网络钩子&#34;&gt;套接字和其他网络钩子&lt;/h3&gt;
&lt;p&gt;当应用程序在网络套接字上打开或执行其他操作时，以及当消息被发送或接收时，你可以附加运行 eBPF 程序。在内核的网络堆栈中也有称为 &lt;strong&gt;流量控制（traffic control）&lt;/strong&gt; 或 &lt;strong&gt;tc&lt;/strong&gt; 的 钩子，eBPF 程序可以在初始数据包处理后运行。&lt;/p&gt;
&lt;p&gt;一些功能可以单独用 eBPF 程序实现，但在许多情况下，我们希望 eBPF 代码能从用户空间的应用程序接收信息，或将数据传递给用户空间的应用程序。允许数据在 eBPF 程序和用户空间之间，或在不同的 eBPF 程序之间传递的机制被称为 &lt;strong&gt;map&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-map&#34;&gt;eBPF Map&lt;/h2&gt;
&lt;p&gt;map 的开发是 eBPF 缩略语中的 &lt;strong&gt;e&lt;/strong&gt; 代表 &lt;strong&gt;extended&lt;/strong&gt; 重要区别之一。&lt;/p&gt;
&lt;p&gt;map 是与 eBPF 程序一起定义的数据结构体。有各种不同类型的 map，但它们本质上都是键值存储。eBPF 程序可以读取和写入 map，用户空间代码也可以。map 的常见用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF 程序写入关于事件的指标和其他数据，供用户空间代码以后检索。&lt;/li&gt;
&lt;li&gt;用户空间代码编写配置信息，供 eBPF 程序读取并作出相应的行为。&lt;/li&gt;
&lt;li&gt;eBPF 程序将数据写入 map，供另一个 eBPF 程序以后检索，允许跨多个内核事件的信息协调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果内核和用户空间的代码都要访问同一个映射，它们需要对存储在该映射中的数据结构体有一个共同的理解。这可以通过在用户空间和内核代码中加入定义这些数据结构体的头文件来实现，但是如果这些代码不是用相同的语言编写的，作者将需要仔细创建逐个字节兼容的结构体定义。&lt;/p&gt;
&lt;p&gt;我们已经讨论了 eBPF 工具的主要组成部分：在内核中运行的 eBPF 程序，加载和与这些程序交互的用户空间代码，以及允许程序共享数据的 map。为了更具体化，让我们看一个例子。&lt;/p&gt;
&lt;h2 id=&#34;opensnoop-示例&#34;&gt;Opensnoop 示例&lt;/h2&gt;
&lt;p&gt;在 eBPF 程序的例子中，我选择了 &lt;code&gt;opesnnoop&lt;/code&gt;，一个可以显示任何进程所打开的文件的工具。这个工具的原始版本是 Brendan Gregg 最初在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; title=&#34;BCC 项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BCC 项目&lt;/a&gt;
中编写的许多 BPF 工具之一，你可以在 GitHub 上找到。它后来被重写为 &lt;code&gt;libbpf&lt;/code&gt;（你将在下一章见到它），在这个例子中，我使用 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录下的较新版本。&lt;/p&gt;
&lt;p&gt;当你运行 &lt;code&gt;opensnoop&lt;/code&gt; 时，你将看到的输出在很大程度上取决于当时在虚拟机上发生了什么，但它应该看起来像这样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PID    COMM	FD	ERR	PATH
93965  cat	3	0	/etc/ld.so.cache
93965  cat	3	0	/lib/x86_64-linux-gnu/libc.so.6
93965  cat	3	0	/usr/lib/locale/locale-archive
93965  cat	3	0	/usr/share/locale/locale.alias
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行输出表示一个进程打开（或试图打开）一个文件。这些列显示了进程的 ID，运行的命令，文件描述符，错误代码的指示，以及被打开的文件的路径。&lt;/p&gt;
&lt;p&gt;Opensnoop 的工作方式是将 eBPF 程序附加到 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt; 系统调用上，所有应用程序都必须通过这些调用来要求内核打开文件。让我们深入了解一下这是如何实现的。为了简洁起见，我们将不看每一行代码，但我希望这足以让你了解它是如何工作的（如果你对这么深的内容不感兴趣的话，请跳到下一章！）。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-ebpf-代码&#34;&gt;Opensnoop eBPF 代码&lt;/h3&gt;
&lt;p&gt;eBPF 代码是用 C 语言编写的，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/libbpf-tools/opensnoop.bpf.c&#34; title=&#34;&amp;lt;code&amp;gt;opensnoop.bpf.c&amp;lt;/code&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opensnoop.bpf.c&lt;/code&gt;&lt;/a&gt;
 文件中。在这个文件的开头，你可以看到两个 eBPF map 的定义 —— &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;events&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10240&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;args_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 ELF 对象文件被创建时，它包含了每个 map 和每个要加载到内核的程序的部分，&lt;code&gt;SEC()&lt;/code&gt; 宏定义了这些部分。&lt;/p&gt;
&lt;p&gt;当我们研究这个程序的时候，你会看到，在系统调用被处理的时候，&lt;code&gt;start&lt;/code&gt; map 被用来临时存储系统调用的参数 —— 包括被打开的文件的名称。&lt;code&gt;events&lt;/code&gt; map &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; 用于将事件信息从内核中的 eBPF 代码传递给用户空间的可执行程序。如 &lt;a href=&#34;#figure-f-3-2&#34; title=&#34;图 3-2&#34;&gt;图 3-2&lt;/a&gt;
 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-3-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中&#34; id=&#34;f-3-2&#34;data-img=&#34;f-3-2.jpg&#34;
         data-caption=&#34;图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中&#34;
         
         
         data-width=&#34;1486&#34;
         data-height=&#34;686&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 文件的后面，你会发现两个极其相似的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_open&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tracepoint__syscalls__sys_enter_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_openat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tracepoint__syscalls__sys_enter_openat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个不同的系统调用用于打开文件 &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;：&lt;code&gt;openat()&lt;/code&gt; 和
&lt;code&gt;open()&lt;/code&gt;。它们是相同的，除了 &lt;code&gt;openat()&lt;/code&gt; 有一个额外的参数是目录文件描述符，而且要打开的文件的路径名是相对于该目录而言的。同样，除了处理参数上的差异，opensnoop 中的两个函数也是相同的。&lt;/p&gt;
&lt;p&gt;正如你所看到的，它们都需要一个参数，即一个指向名为 &lt;code&gt;trace_event_raw_sys_enter&lt;/code&gt; 结构体的指针。你可以在你运行的特定内核生成的 &lt;code&gt;vmlinux&lt;/code&gt; 头文件中找到这个结构体的定义。编写 eBPF 程序之道包括找出每个程序接收的结构体作为其上下文，以及如何访问其中的信息。&lt;/p&gt;
&lt;p&gt;这两个函数使用一个 BPF 辅助函数来检索调用这个 syscall 的进程 ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_get_current_pid_tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码得到了文件名和传递给系统调用的标志，并把它们放在一个叫做 &lt;code&gt;args&lt;/code&gt; 的结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个结构体被写入 &lt;code&gt;start&lt;/code&gt; map 中，使用当前程序 ID 作为键。&lt;/p&gt;
&lt;p&gt;这就是 eBPF 程序在进入 syscall 时所做的一切。但在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 中定义了另一对 eBPF 程序，当系统调用退出时被触发。&lt;/p&gt;
&lt;p&gt;这个程序和它的双胞胎 &lt;code&gt;openat()&lt;/code&gt; 在函数 &lt;code&gt;trace_exit()&lt;/code&gt; 中共享代码。你有没有注意到，所有被 eBPF 程序调用的函数的前缀都是 &lt;code&gt;static __always_inline&lt;/code&gt;？这迫使编译器将这些函数的指令放在内联中，因为在旧的内核中，BPF 程序不允许跳转到一个单独的函数。新的内核和 LLVM 版本可以支持非内联的函数调用，但这是一种安全的方式，可以确保 BPF 验证器满意（现在还有一个 BPF 尾部调用的概念，即执行从一个 BPF 程序跳转到另一个程序。你可以在 &lt;a href=&#34;https://docs.cilium.io/en/v1.10/bpf/#bpf-to-bpf-calls&#34; title=&#34;eBPF 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 文档&lt;/a&gt;
中阅读更多关于 BPF 函数调用和尾部调用的内容）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;trace_exit()&lt;/code&gt; 函数创建一个空的事件结构体：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该结构体将用即将结束的 &lt;code&gt;open/openat&lt;/code&gt; 系统调用的信息填充，并通过 &lt;code&gt;events&lt;/code&gt; map 发送到用户空间。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;start&lt;/code&gt; 哈希 map 中应该有一个与当前进程 ID 相对应的条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有先前在调用 &lt;code&gt;sys_enter_open(at)&lt;/code&gt; 时写入的关于文件名和标志的信息。标志字段是一个直接存储在结构体中的整数，所以直接从结构体中读取它是可以的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相反，文件名被写入用户空间内存的一些字节中，验证者需要确定这个 eBPF 程序从内存的那个位置读取这个字节数是安全的。这是用另一个辅助函数 &lt;code&gt;bpf_probe_read_user_str()&lt;/code&gt; 完成的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_probe_read_user_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前的命令名称（即进行 &lt;code&gt;open(at)&lt;/code&gt; 系统调用的可执行文件的名称）也被复制到事件结构体中，使用另一个 BPF 辅助函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_get_current_comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事件结构体被写入 &lt;code&gt;events&lt;/code&gt; perf buffer map 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_perf_event_output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_F_CURRENT_CPU&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户空间的代码从这个 map 中读取事件信息。在我们讨论这个问题之前，让我们简单看看 Makefile。&lt;/p&gt;
&lt;h3 id=&#34;libbpf-tools-makefile&#34;&gt;libbpf-tools Makefile&lt;/h3&gt;
&lt;p&gt;当你构建 eBPF 代码时，你得到一个包含 eBPF 程序和 map 的二进制定义的对象文件。你还需要一个额外的用户空间可执行文件，它将把这些程序和 map 加载到内核中，作为用户 &lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; 的接口。我们看看如何构建 &lt;code&gt;opensnoop&lt;/code&gt; 的 Makefile，看看它是如何创建 eBPF 对象文件和可执行文件的。&lt;/p&gt;
&lt;p&gt;Makefile 由一组规则组成，这些规则的语法可能有点不透明，所以如果你不熟悉 Makefile，也不特别关心这些细节，请随意跳过这一节。&lt;/p&gt;
&lt;p&gt;我们正在看的 opensnoop 的例子是一大批示例工具的其中之一，它们都是用 Makefile 构建的，你可以在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到。在这个文件中，并不是所有的东西都特别有意义，但有几个规则我想强调一下。第一条规则是使用 &lt;code&gt;bpf.c&lt;/code&gt; 文件并使用 clang 编译器来创建一个 BPF 目标对象文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.bpf.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;AR&lt;/span&gt;.. 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BPF&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CLANG&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bpf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;D__TARGET_ARCH_&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              -&lt;span class=&#34;nv&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@ &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LLVM_STRIP&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，&lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 被编译成 &lt;code&gt;\$(OUTPUT)/open snoop.bpf.o&lt;/code&gt;。这个对象文件包含将被加载到内核的 eBPF 程序和 map。&lt;/p&gt;
&lt;p&gt;另一条规则使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt;，从该 &lt;code&gt;bpf.o&lt;/code&gt; 对象文件中包含的 map 和程序定义中创建一个骨架头文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.skel.h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;GEN&lt;/span&gt;-&lt;span class=&#34;nv&#34;&gt;SKEL&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BPFTOOL&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;gen&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;skeleton&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;opensnoop.c&lt;/code&gt; 用户空间代码包括这个 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 头文件，以获得它与内核中的 eBPF 程序共享的 map 的定义。这使得用户空间和内核代码能够了解存储在这些 map 中的数据结构体的布局。&lt;/p&gt;
&lt;p&gt;下面的规则将用户空间的代码 &lt;code&gt;opensnoop.c&lt;/code&gt; 的编译成为 &lt;code&gt;$(OUTPUT)/opensnoop.o&lt;/code&gt; 的二进制对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，有一条规则是使用 &lt;code&gt;cc&lt;/code&gt; 将用户空间的应用对象（在我们的例子中是 &lt;code&gt;opensnoop.o&lt;/code&gt;）链接成一组可执行文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(APPS)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;COMMON_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUT&lt;/span&gt;... 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BINARY&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lelf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lz&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在你已经看到 eBPF 和用户空间程序分别是如何生成的，让我们看看用户空间的代码。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-用户空间代码&#34;&gt;Opensnoop 用户空间代码&lt;/h3&gt;
&lt;p&gt;如前所述，与 eBPF 代码交互的用户空间代码几乎可以用任何编程语言编写。我们在本节讨论的例子是用 C 语言写的，但如果你有兴趣，你可以把它与用 Python 写的原始 BCC 版本相比较，你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; title=&#34;bcc/tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc/tools&lt;/a&gt;
 中找到。&lt;/p&gt;
&lt;p&gt;用户空间的代码在 &lt;code&gt;opensnoop.c&lt;/code&gt; 文件中。文件的前半部分有 &lt;code&gt;#include&lt;/code&gt; 指令（其中之一是自动生成的 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 文件），各种定义，以及处理不同命令行选项的代码，我们在此不再赘述。我们还将略过 &lt;code&gt;print_event()&lt;/code&gt; 等函数，该函数将一个事件的信息显示到屏幕上。从 eBPF 的角度来看，所有有趣的代码都在 &lt;code&gt;main()&lt;/code&gt; 函数中。&lt;/p&gt;
&lt;p&gt;你会看到像 &lt;code&gt;opensnoop_bpf__open()&lt;/code&gt;、&lt;code&gt;opensnoop_bpf__load()&lt;/code&gt; 和 &lt;code&gt;opensnoop_bpf__attach()&lt;/code&gt; 这样的函数。这些都是在由 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; &lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;  自动生成的代码中定义的。这个自动生成的代码处理所有在 eBPF 对象文件中定义的单个 eBPF 程序、map 和附着点。&lt;/p&gt;
&lt;p&gt;opensnoop 启动和运行后，它的工作就是监听 &lt;code&gt;events&lt;/code&gt; 的 perf
buffer，并将每个事件中包含的信息写到屏幕上。首先，它打开与 perf buffer 相关的文件描述符，并将 &lt;code&gt;handle_event()&lt;/code&gt; 设置为新事件到来时要调用的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perf_buffer__new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;bpf_map__fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PERF_BUFFER_PAGES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_lost_events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后它对缓冲区事件进行轮询，直到达到一个时间限制，或者用户中断程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exiting&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;perf_buffer__poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PERF_POLL_TIMEOUT_MS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传递给 &lt;code&gt;handle_event()&lt;/code&gt; 的数据参数指向 eBPF 程序为该事件写进 map 的事件结构体。&lt;/p&gt;
&lt;p&gt;用户空间的代码可以检索这些信息，将其格式化并写出来给用户看。&lt;/p&gt;
&lt;p&gt;正如你所看到的，opensnoop 注册了 eBPF 程序，每当有应用程序进行 &lt;code&gt;open()&lt;/code&gt; 或 &lt;code&gt;openat()&lt;/code&gt; 系统调用时都会被调用。这些运行在内核中的 eBPF 程序收集有关该系统调用的上下文信息 —— 可执行文件名和进程 ID—— 以及被打开的文件的信息。这些信息被写进一个 map，用户空间可以从中读取并显示给用户。&lt;/p&gt;
&lt;p&gt;你会在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到几十个这样的 eBPF 工具的例子，每个例子通常都是一个系统调用，或者是一系列相关的系统调用，如 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统调用是一个稳定的内核接口，它提供了一个非常强大的方式来观察（虚拟）机器上正在发生的事情。但是，不要以为 eBPF 编程只能用于拦截系统调用。还有很多其他的固定接口，包括 LSM 和网络堆栈中的各种点，eBPF 可以连接到这些接口。如果你愿意承担内核版本变更的风险，eBPF 程序可以附加的范围是绝对宽广的。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;见 &lt;a href=&#34;https://oreil.ly/4MMPL&#34; title=&#34;BPF 指令集文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF 指令集文档&lt;/a&gt;
。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;也可以跳过对象文件，使用 bpf() 系统调用直接将字节码加载到内核。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;code&gt;entry/fexit&lt;/code&gt; 在 Alexei Starovoitov 的文章中描述：《引入 BPF Trampoline》（LWN.net，2019 年 11 月 14 日）。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Oracle Linux 博客，《Taming Tracepoints in the Linux Kernel》，作者 Matt Keenan，2020 年 3 月 9 日发布。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Brendan Gregg 的网站是一个关于 &lt;a href=&#34;https://www.brendangregg.com/perf.html&#34; title=&#34;perf events&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf events&lt;/a&gt;
的良好信息来源。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;如果你有兴趣看到这方面的具体例子，你可以看一下我在 2021 年 eBPF 峰会上的&lt;a href=&#34;https://www.youtube.com/watch?v=L3_AOFSNKK8&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;
，我在几分钟内实现了一个非常基本的负载均衡器，以此来说明我们如何使用 eBPF 来改变内核处理网络数据包的方式。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;在写这篇文章的时候，这段代码使用的是事件映射的 perf 缓冲器。如果你今天为最近的内核编写这段代码，你会从一个 &lt;a href=&#34;https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf&#34; title=&#34;ring buffer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ring buffer&lt;/a&gt;
 中获得更好的性能，这是一个更新的替代方案。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;在一些内核中，你还会发现 &lt;code&gt;openat2()&lt;/code&gt;，但这个版本的 opensnoop 没有处理这个问题，至少在写作本文时是这样的。&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;你可以使用一个通用的工具，如 bpftool，它可以读取 BPF 对象文件并对其进行操作，但这需要用户知道关于加载什么以及将程序附加到什么事件的细节。对于大多数应用来说，编写一个特定的工具来为最终用户简化这一点是有意义的。&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;见 Andrii Nakryiko 描述 BPF 骨架代码生成的&lt;a href=&#34;https://lwn.net/Articles/806328/&#34; title=&#34;帖子&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;
。&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第四章：eBPF 的复杂性</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-complexity/</guid>
      <description>
        
        
        &lt;p&gt;现在你已经看到了 eBPF 编程的例子，了解到它是如何工作的。虽然基础示例使得 eBPF 看起来相对简单，但也有一些复杂的地方使得 eBPF 编程充满挑战。&lt;/p&gt;
&lt;p&gt;长期以来，有个问题使得编写和发布 eBPF 程序相对困难，那就是内核兼容性。&lt;/p&gt;
&lt;h2 id=&#34;跨内核的可移植性&#34;&gt;跨内核的可移植性&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以访问内核数据结构，而这些结构可能在不同的内核版本中发生变化。这些结构本身被定义在头文件中，构成了 Linux 源代码的一部分。在过去编译 eBPF 程序时，必须基于你想运行这些程序的内核兼容的头文件集。&lt;/p&gt;
&lt;h3 id=&#34;bcc-对可移植性的处理方法&#34;&gt;BCC 对可移植性的处理方法&lt;/h3&gt;
&lt;p&gt;为了解决跨内核的可移植性问题，BCC &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（BPF 编译器集合，BPF Compiler Collection）项目采取了在运行时编译 eBPF 代码的方法，在目标机器上就地进行。这意味着编译工具链需要安装到每个你想让代码运行 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的目标机器上，而且你必须在工具启动之前等待编译完成，而且文件系统上必须有内核头文件（实际上并不总是这样）。这就引出了 BPF CO-RE。&lt;/p&gt;
&lt;h3 id=&#34;co-re&#34;&gt;CO-RE&lt;/h3&gt;
&lt;p&gt;CO-RE（Compile Once, Run Everyone，编译一次，到处运行）方法由以下元素组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BTF (BPF Type Format)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种用于表达数据结构和函数签名布局的格式。现代 Linux 内核支持 BTF，因此你可以从运行中的系统中生成一个名为 &lt;code&gt;vmlinux.h&lt;/code&gt; 的头文件，其中包含一个 BPF 程序可能需要的关于内核的所有数据结构信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libbpf，BPF 库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;libbpf 一方面提供了加载 eBPF 程序和映射到内核的功能，另一方面也在可移植性方面也起着重要的作用：它依靠 BTF 信息来调整 eBPF 代码，以弥补其编译时的数据结构与目标机器上的数据结构之间的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译器支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clang 编译器得到了增强，因此当它编译 eBPF 程序时，它包括所谓的 BTF 重定位（relocation），这使得 libbpf 在加载 BPF 程序和映射到内核时知道要调整什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可选的 BPF 骨架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; 可以从编译的 BPF 对象文件中自动生成一个骨架，其中包含用户空间代码可以方便调用的函数，以管理 BPF 程序的生命周期 —— 将它们加载到内核，附加到事件等等。这些函数是更高层次的抽象，对开发者来说比直接使用 libbpf 更方便。&lt;/p&gt;
&lt;p&gt;关于 CO-RE 的更详细的解释，请阅读 Andrii Nakryiko 的出色 &lt;a href=&#34;https://nakryiko.com/posts/bpf-portability-and-co-re/&#34; title=&#34;描述&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;描述&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;自 5.4 版本 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 以来，&lt;code&gt;vmlinux&lt;/code&gt; 文件形式的 BTF 信息已经包含在 Linux 内核中，但 libbpf 可以利用的原始 BTF 数据也可以为旧内核生成。在 &lt;a href=&#34;https://github.com/aquasecurity/btfhub&#34; title=&#34;BTF Hub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF Hub&lt;/a&gt;
 上有关于如何生成 BTF 文件的信息，以及用于各种 Linux 发行版的文件档案。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 方法使得 eBPF 程序更易于在任意 Linux 发行版上运行 —— 或者至少在新 Linux 发行版上支持任意 eBPF 能力。但这并不能使 eBPF 更优雅：它本质上仍然是内核编程。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核知识&#34;&gt;Linux 内核知识&lt;/h2&gt;
&lt;p&gt;很快就会发现，为了编写更高级的工具，你需要一些关于 Linux 内核的领域知识。你需要了解你可以访问的数据结构，取决于你的 eBPF 代码被调用的环境。不是所有应用程序的开发者都有解析网络数据包、访问套接字缓冲区或处理系统调用参数的经验。&lt;/p&gt;
&lt;p&gt;内核将如何对你 eBPF 代码的行为做出反应？正如你在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34; title=&#34;第二章&#34;&gt;第二章&lt;/a&gt;
 中了解到的，内核由数百万行代码组成。它的文档可能是稀少的，所以你可能会发现自己不得不阅读内核的源代码来弄清楚某些东西是如何工作的。&lt;/p&gt;
&lt;p&gt;你还需要弄清楚你的 eBPF 代码应该附加到哪些事件。由于可以将 &lt;code&gt;kprobe&lt;/code&gt; 附加到整个内核的任何函数入口点，这可能不是一个简单的决定。在某些情况下，这可能很明确 —— 例如，如果你想访问一个传入的网络数据包，那么适当的网络接口上的 XDP 钩子是一个明显的选择。如果你想提供对特定内核事件的可观测性，在内核代码中找到合适的点可能并不难。&lt;/p&gt;
&lt;p&gt;但在其他情况下，选择可能不那么明显。例如，简单地使用 &lt;code&gt;kprobes&lt;/code&gt; 来钩住构成内核系统调用接口的函数的工具，可能会被名为 &lt;code&gt;time-of-check&lt;/code&gt; 到 &lt;code&gt;time-of-use&lt;/code&gt;（TOCTTOU）的安全漏洞所影响。攻击者有一个小的机会窗口，他们可以在 eBPF 代码读取参数后，但在参数被复制到内核内存之前，改变系统调用的参数。在 DEF CON 29 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 上，Rex Guo 和 Junyuan Zeng 做了一个关于这个问题的 &lt;a href=&#34;https://www.youtube.com/watch?v=yaAdM8pWKG8&amp;amp;ab_channel=DEFCONConference&#34; title=&#34;出色演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;出色演讲&lt;/a&gt;
。一些被最广泛使用的 eBPF 工具是以相当天真的方式编写的，极易受到这种攻击。这不是一个简单的漏洞，而且有办法减轻这些攻击，但如果你正在保护高度敏感的数据，对抗复杂的、有动机的对手，请深入了解你使用的工具是否可能受到影响。&lt;/p&gt;
&lt;p&gt;你已经看到了 BPF CO-RE 是如何使 eBPF 程序在不同的内核版本上工作的，但它只考虑到了数据结构布局的变化，而没有考虑到内核行为的更大变化。例如，如果你想把一个 eBPF 程序附加到内核中的一个特定的函数或 tracepoint 上，你可能需要一个 B 计划，如果该函数或 tracepoint 在不同的内核版本中不存在，该怎么做。&lt;/p&gt;
&lt;h2 id=&#34;编排多个-ebpf-程序&#34;&gt;编排多个 eBPF 程序&lt;/h2&gt;
&lt;p&gt;当前有很多基于 eBPF 的工具提供了一套可观测能力，通过将 eBPF 程序与一组内核事件挂钩来实现。其中大部分是由 Brendan Gregg 和其他人在 BCC 和 &lt;code&gt;bpftrace&lt;/code&gt; 工具中所做的工作而开创的。很多工具（通常是商业的）可能会提供更漂亮的图形和用户界面，但他们还是在这些 eBPF 程序的基础上实现的。&lt;/p&gt;
&lt;p&gt;当你想写代码来编排不同类型的事件之间的交互时，事情就变得相当复杂了。举个例子，Cilium 通过内核的网络堆栈 &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 在不同的点上观察到网络数据包，基于来自 Kubernetes CNI（容器网络接口）关于 Kubernetes pod 的信息，对流量进行操作。构建这个系统需要 Cilium 开发人员深入了解内核如何处理网络流量，以及用户空间的 &lt;strong&gt;pod&lt;/strong&gt; 和 &lt;strong&gt;容器&lt;/strong&gt; 概念如何映射到内核概念，如 cgroups 和命 namespace。在实践中，一些 Cilium 的维护者也是内核的开发者，他们致力于增强 eBPF 和网络支持；因此，他们拥有这些知识。&lt;/p&gt;
&lt;p&gt;底线是，尽管 eBPF 提供了一个极其有效和强大的平台来连接到内核，但对于没有大量内核经验的普通开发者来说，这并不容易。如果你对 eBPF 编程感兴趣，我非常鼓励你把它作为练习来学习；在这个领域积累经验可能是非常有价值的，因为它在未来几年内一定会成为受欢迎的专业技能。但实际上，大多数组织不太可能在内部建立许多定制的 eBPF 工具，而是利用专业 eBPF 社区的项目和产品。&lt;/p&gt;
&lt;p&gt;让我们继续思考为什么这些基于 eBPF 的项目和产品在云原生环境中如此强大。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; title=&#34;GitHub 页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 页面&lt;/a&gt;
 上找到 BCC。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;一些项目采取了将 eBPF 源和所需工具链打包成一个容器镜像的方法。这避免了安装工具链的复杂性和任何随之而来的依赖管理，但这仍意味着编译步骤在目标机器上运行。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;更多信息见 Andrii Nakryiko 的 IO Visor &lt;a href=&#34;https://lists.iovisor.org/g/iovisor-dev/message/1966&#34; title=&#34;帖子&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;
。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Rex Guo and Junyuan Zeng, &amp;ldquo;Phantom Attack: 逃离系统调用监控，&amp;quot;（DEF CON，2021 年 8 月 5-8 日）。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.cilium.io/en/stable/concepts/ebpf/intro/&#34; title=&#34;Cilium 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 文档&lt;/a&gt;
描述了 eBPF 程序如何附加到不同的网络能力钩子，组合起来以实现复杂的网络能力。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第五章：云原生环境中的 eBPF</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-in-cloud-native-environments/</guid>
      <description>
        
        
        &lt;p&gt;近年来，云原生应用已呈指数级增长。在本章中，我将讨论为什么 eBPF 如此适合于云原生环境。为了更具象化，我将提到 Kubernetes，但同样适用于任何容器平台。&lt;/p&gt;
&lt;h2 id=&#34;每台主机一个内核&#34;&gt;每台主机一个内核&lt;/h2&gt;
&lt;p&gt;要理解为什么 eBPF 在云原生世界中如此强大，你需要搞清楚一个概念：每台机器（或虚拟机）只有一个内核，所有运行在该机器上的容器都共享同一个内核 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 如 &lt;a href=&#34;#figure-f-5-1&#34; title=&#34;图 5-1&#34;&gt;图 5-1&lt;/a&gt;
 所示，内核了解主机上运行的所有应用代码。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-5-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 5-1. 同一主机上的所有容器共享一个内核&#34; id=&#34;f-5-1&#34;data-img=&#34;f-5-1.jpg&#34;
         data-caption=&#34;图 5-1. 同一主机上的所有容器共享一个内核&#34;
         
         
         data-width=&#34;1490&#34;
         data-height=&#34;582&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 5-1. 同一主机上的所有容器共享一个内核
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;通过对内核的检测，就像我们在使用 eBPF 时做的那样，我们可以同时检测在该机器上运行的所有应用程序代码。当我们将 eBPF 程序加载到内核并将其附加到事件上时，它就会被触发，而不考虑哪个进程与该事件有关。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-与-sidecar-模式的比较&#34;&gt;eBPF 与 sidecar 模式的比较&lt;/h2&gt;
&lt;p&gt;在 eBPF 之前，Kubernetes 的可观测性和安全工具大多都采用了 sidecar 模式。这种模式允许你在与应用程序相同的 pod 中，单独部署一个工具容器。这种模式的发明是一个进步，因为这意味着不再需要直接在应用程序中编写工具代码。仅仅通过部署 sidecar，工具就获得了同一 pod 中的其他容器的可视性。注入 sidecar 的过程通常是自动化的，所以这提供了一种机制，以确保你的所有应用程序都被仪器化。&lt;/p&gt;
&lt;p&gt;每个 sidecar 容器都会消耗资源，而这要乘以注入了 sidecar 的 pod 的数量。这可能是非常重要的 —— 例如，如果每个 sidecar 需要它自己的路由信息副本，或策略规则，这就是浪费（关于这一点，Thomas Graf 写了一篇 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; title=&#34;关于服务网格 sidecar 与 eBPF 的比较&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于服务网格 sidecar 与 eBPF 的比较&lt;/a&gt;
）。&lt;/p&gt;
&lt;p&gt;Sidecar 的另一个问题是，你不能保证机器上的每一个应用程序都被正确检测。设想下有一个攻击者设法破坏了你的一台主机，并启动了一个单独的 pod 来运行，比如，加密货币挖矿程序。他们不可能对你有礼貌，用你的 sidecar 可观测或安全工具来检测他们的挖矿 pod。你需要一个单独的系统来了解这种活动。&lt;/p&gt;
&lt;p&gt;但同样的加密货币矿工与运行在该主机上的合法 pod 共享内核。如果你使用基于 eBPF 的工具，如 &lt;a href=&#34;#figure-f-5-2&#34; title=&#34;图 5-2&#34;&gt;图 5-2&lt;/a&gt;
 所示，矿工会自动受到它的影响。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-5-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动&#34; id=&#34;f-5-2&#34;data-img=&#34;f-5-2.jpg&#34;
         data-caption=&#34;图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动&#34;
         
         
         data-width=&#34;1488&#34;
         data-height=&#34;818&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;ebpf-和进程隔离&#34;&gt;eBPF 和进程隔离&lt;/h2&gt;
&lt;p&gt;我主张将功能整合到一个单一的、基于 eBPF 的代理中，而不是每个 pod 的 sidecar 中。如果该代理可以访问机器上运行的所有 pod，这不是一种安全风险吗？我们不是失去了应用程序之间的隔离，而这种隔离可以防止它们相互干扰吗？&lt;/p&gt;
&lt;p&gt;作为一个容器安全领域的过来人，我可以体会到你对此的担忧，但重要的是要挖掘底层机制，以真正理解为什么它不是一开始可能出现的缺陷。&lt;/p&gt;
&lt;p&gt;请注意，这些 pod 共享同一个内核，而内核原生不能感知 pod 或容器。相反，内核对进程进行操作，并使用 cgroup 和 namespace 来隔离进程。这些结构由内核监管，以隔离用户空间中的进程，防止它们互相干扰。只要数据在内核中处理（例如，从磁盘中读取或发送到网络中），你就依赖于内核的正确行为。只有内核代码控制文件权限。没有其他层面的东西可以阻止内核忽略文件权限的东西，内核可以从任何文件中读取数据 —— 只是内核本身不会这样做。&lt;/p&gt;
&lt;p&gt;存在于 Linux 系统中的安全控制措施假定内核本身是可以信任的。它们的存在是为了防止在用户空间运行的代码产生不良行为。&lt;/p&gt;
&lt;p&gt;我们在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34; title=&#34;第二章&#34;&gt;第二章&lt;/a&gt;
 中看到，eBPF 检查器确保 eBPF 程序只能访问它有权限的内存。检查器检查程序时不可能超出其职权范围，包括确保内存为当前进程所拥有或为当前网络包的一部分。这意味着 eBPF 代码比它周围的内核代码受到更严格的控制，内核代码不需要通过任何类型的检查器。&lt;/p&gt;
&lt;p&gt;如果攻击者逃脱了容器化的应用程序而到了节点上，而且还能够提升权限，那么该攻击者就可以危害到同一节点上的其他应用程序。由于这些逃逸是未知的，作为一个容器安全专家，我不建议在没有额外安全工具的情况下，在共享机器上与不受信任的应用程序或用户一起运行敏感的应用程序。对于高度敏感的数据，你甚至可能不希望在虚拟机中与不受信任的用户在同一裸机上运行。但是，如果你准备在同一台虚拟机上并行运行应用程序（这在许多不是特别敏感的应用程序中是完全合理的），那么 eBPF 就不会在共享内核已经存在的风险之上增加额外的风险。&lt;/p&gt;
&lt;p&gt;当然，恶意的 eBPF 程序可能造成各种破坏，当然也很容易写出劣迹的 eBPF 代码 —— 例如，复制每个网络数据包并将其发送给窃听者。默认情况下，非 root 用户没有加载 eBPF 程序 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的权限，只有当你真正信任他们时，你才应该授予用户或软件系统这种权限，就像 root 权限一样。因此，必须小心你所运行的代码的出处（有一个倡议正在进行中，以支持 eBPF 程序的签名检查来帮助解决这个问题）。你也可以使用 eBPF 程序来监视其他的 eBPF 程序！现在你已经对为什么 eBPF 是云原生工具的强大基础有了一个概念，下一章给你举一些来自云原生生态系统中的 eBPF 工具的具体例子。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;这基本正确，除非你使用的是虚拟化技术，像 KataContainer、Firecracker 或 unikernels 这样的方法，每个 &amp;ldquo;容器&amp;rdquo; 在自己的虚拟机中运行。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Linux &lt;code&gt;CAP_BPF&lt;/code&gt; 授予加载 BPF 程序的权限。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第六章：eBPF 工具</title>
      <link>https://jimmysong.io/book/what-is-ebpf/ebpf-tools/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/ebpf-tools/</guid>
      <description>
        
        
        &lt;p&gt;现在你已经了解了什么是 eBPF 以及它是如何工作的，我们再探索一些可能会在生产部署中使用的基于 eBPF 技术的工具。我们将举一些基于 eBPF 的开源项目的例子，这些项目提供了三方面的能力：网络、可观测性和安全。&lt;/p&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以连接到网络接口和内核的网络堆栈的各个点。在每个点上，eBPF 程序可以丢弃数据包，将其发送到不同的目的地，甚至修改其内容。这就实现了一些非常强大的功能。让我们来看看通常用 eBPF 实现的几个网络功能。&lt;/p&gt;
&lt;h3 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;Facebook 正在大规模的使用 eBPF 的网络功能，因此你不必对 eBPF 用于网络的可扩展性有任何怀疑。他们是 BPF 的早期采用者，并在 2018 年推出了 &lt;a href=&#34;https://engineering.fb.com/2018/05/22/open-source/open-sourcing-katran-a-scalable-network-load-balancer/&#34; title=&#34;Katran&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katran&lt;/a&gt;
，一个开源的四层负载均衡器。&lt;/p&gt;
&lt;p&gt;另一个高度扩展的负载均衡器的例子是来自 Cloudflare 的 &lt;a href=&#34;https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/&#34; title=&#34;Unimog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unimog&lt;/a&gt;
 边缘负载均衡器。通过在内核中运行，eBPF 程序可以操作网络数据包，并将其转发到适当的目的地，而不需要数据包通过网络堆栈和用户空间。&lt;/p&gt;
&lt;p&gt;Cilium 项目作为一个 eBPF Kubernetes 网络插件更为人所知（我一会儿会讨论），但作为独立的负载均衡器，它也被用于大型电信公司和企业内部部署。同样，因为它能够在早期阶段处理数据包，而不需要进入到用户空间，它具有很高的性能。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-网络&#34;&gt;Kubernetes 网络&lt;/h3&gt;
&lt;p&gt;CNCF 项目 Cilium 最初基于 eBPF 的 CNI 实现。它最初是由一群从事 eBPF 工作的内核维护者发起的，他们认识到 eBPF 在云原生网络中的应用潜力。它现在被用作谷歌 Kubernetes 引擎、亚马逊 EKS Anywhere 和阿里云的默认数据平面。&lt;/p&gt;
&lt;p&gt;在云原生环境下，pod 在不断的启停，每个 pod 都会被分配一个 IP 地址。在启用 eBPF 网络之前，当 pod 启停的时候，每个节点都必须为它们更新 iptables 规则，以便在 pod 之间进行路由；而当这些 iptable 规则规模变大后，将十分不便于管理。如 &lt;a href=&#34;#figure-f-6-1&#34; title=&#34;图 6-1&#34;&gt;图 6-1&lt;/a&gt;
 所示，Cilium 极大地简化了路由，仅需在 eBPF 中创建的一个简单的查找表，就可以获得 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark/&#34; title=&#34;可观的性能改进&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观的性能改进&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;另一个在传统的 iptables 版本之外还增加了 eBPF 实现的 Kubernetes CNI 是 &lt;a href=&#34;https://github.com/projectcalico/calico&#34; title=&#34;Calico&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calico&lt;/a&gt;
。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-1.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-1. 用 eBPF 绕过主机网络堆栈&#34; id=&#34;f-6-1&#34;data-img=&#34;f-6-1.jpg&#34;
         data-caption=&#34;图 6-1. 用 eBPF 绕过主机网络堆栈&#34;
         
         
         data-width=&#34;968&#34;
         data-height=&#34;1546&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-1. 用 eBPF 绕过主机网络堆栈
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;服务网格&#34;&gt;服务网格&lt;/h3&gt;
&lt;p&gt;eBPF 作为服务网格数据平面的基础也是非常有意义的。许多服务网格在七层，即应用层运行，并使用代理组件（如 Envoy）来辅助应用程序。在 Kubernetes 中，这些代理通常以 sidecar 模式部署，每个 pod 中有一个代理容器，这样代理就可以访问 pod 的网络命名空间。正如你在 &lt;a href=&#34;../ebpf-in-cloud-native-environments&#34; title=&#34;第五章&#34;&gt;第五章&lt;/a&gt;
 中看到的，eBPF 有一个比 sidecar 模型更有效的方法。由于内核可以访问主机中所有 pod 的命名空间，我们可以使用 eBPF 连接 pod 中的应用和主机上的代理，如 &lt;a href=&#34;#figure-f-6-2&#34; title=&#34;图 6-2&#34;&gt;图 6-2&lt;/a&gt;
 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-2.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理&#34; id=&#34;f-6-2&#34;data-img=&#34;f-6-2.jpg&#34;
         data-caption=&#34;图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理&#34;
         
         
         data-width=&#34;1608&#34;
         data-height=&#34;1336&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;我还有一篇关于使用 eBPF 实现更高效的服务网格数据平面的文章，Solo.io 上也有发布过类似文章。在写这篇文章的时候，Cilium 服务网格已进入测试阶段，并显示出比传统的 sidecar 代理方法具有更大的 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; title=&#34;性能提升&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能提升&lt;/a&gt;
。&lt;/p&gt;
&lt;h2 id=&#34;可观测性&#34;&gt;可观测性&lt;/h2&gt;
&lt;p&gt;正如你在本报告前面所看到的，eBPF 程序可以获得对机器上发生的一切的可观测性。通过收集事件数据并将其传递给用户空间，eBPF 实现了一系列强大的可观测性工具，可以向你展示你的应用程序是如何执行和表现的，而不需要对这些应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;在本报告的前面，你已经看到了 BCC 项目，几年来，Brendan Gregg 在 Netflix 做了开创性的工作，展示了这些 eBPF 工具如何被用来 &lt;a href=&#34;https://www.brendangregg.com/&#34; title=&#34;观测我们感兴趣的几乎任何指标&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;观测我们感兴趣的几乎任何指标&lt;/a&gt;
，而且是大规模和高性能的。&lt;/p&gt;
&lt;p&gt;Kinvolk 的 &lt;a href=&#34;https://github.com/kinvolk/inspektor-gadget&#34; title=&#34;Inspektor Gadget&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inspektor Gadget&lt;/a&gt;
 将其中一些起源于 BCC 的工具带入了 Kubernetes 的世界，这样你就可以在命令行上轻松观测特定的工作负载。&lt;/p&gt;
&lt;p&gt;新一代的项目和工具正在这项工作的基础上，提供基于 GUI 的观测能力。CNCF 项目 &lt;a href=&#34;https://px.dev/&#34; title=&#34;Pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt;
 可以让你运行预先写好的或自定义的脚本，通过一个强大的、视觉上吸引人的用户界面查看指标和日志。因为它是基于 eBPF 的，这意味着你可以自动检测所有应用程序，获得性能数据，而无需进行任何代码修改或配置。&lt;a href=&#34;#figure-f-6-3&#34; title=&#34;图 6-3&#34;&gt;图 6-3&lt;/a&gt;
 显示的只是 Pixie 中众多可视化的一个例子。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-3.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图&#34; id=&#34;f-6-3&#34;data-img=&#34;f-6-3.jpg&#34;
         data-caption=&#34;图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;892&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;另一个名为 &lt;a href=&#34;https://github.com/parca-dev/parca&#34; title=&#34;Parca&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Parca&lt;/a&gt;
 的可观测性项目专注于连续剖析，使用 eBPF 对 CPU 使用率等指标进行有效采样，可以用来检测性能瓶颈。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/hubble&#34; title=&#34;Hubble&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hubble&lt;/a&gt;
 组件是一个具有命令行界面和用户界面的可观测性工具（如 &lt;a href=&#34;#figure-f-6-4&#34; title=&#34;图 6-4&#34;&gt;图 6-4&lt;/a&gt;
 所示），它专注于 Kubernetes 集群中的网络流。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-4.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量&#34; id=&#34;f-6-4&#34;data-img=&#34;f-6-4.jpg&#34;
         data-caption=&#34;图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;894&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;在云原生环境中，IP 地址不断被动态重新分配，基于 IP 地址的传统网络观测工具的作用非常有限。作为一个 CNI，Cilium 可以访问工作负载身份信息，这意味着 Hubble 可以显示由 Kubernetes pod、服务和命名空间标识的服务映射和流量数据。这对于诊断网络问题十分有用。&lt;/p&gt;
&lt;p&gt;能够观测到活动，这是安全工具的基础，这些工具将正在发生的事情与策略或规则相比较，以了解该活动是预期的还是可疑的。让我们来看看一些使用 eBPF 来提供云原生安全能力的工具。&lt;/p&gt;
&lt;h2 id=&#34;安全&#34;&gt;安全&lt;/h2&gt;
&lt;p&gt;有一些强大的云原生工具，通过使用 eBPF 检测甚至防止恶意活动来增强安全性。我将其分为两类：一类是确保网络活动的安全，另一类是确保应用程序在运行时的预期行为。&lt;/p&gt;
&lt;h3 id=&#34;网络安全&#34;&gt;网络安全&lt;/h3&gt;
&lt;p&gt;由于 eBPF 可以检查和操纵网络数据包，它在网络安全方面有许多用途。基本原理是，如果一个网络数据包被认为是恶意的或有问题的，因为它不符合一些安全验证标准，就可以被简单地丢弃。eBPF 可以很高效的来验证这一点，因为它可以钩住内核中网络堆栈的相关部分，甚至在网卡上 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。这意味着策略外的或恶意的数据包可以在产生网络堆栈处理和传递到用户空间的处理成本之前被丢弃。&lt;/p&gt;
&lt;p&gt;这里有一个 eBPF 早期在生产中大规模使用的一个例子 —— &lt;a href=&#34;https://blog.cloudflare.com/how-to-drop-10-million-packets/&#34; title=&#34;Cloudflare&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudflare&lt;/a&gt;
 的 DDoS（分布式拒绝服务）保护。DDoS 攻击者用许多网络信息淹没目标机，希望目标机忙于处理这些信息，导致无法提供有效工作。Cloudflare 的工程师使用 eBPF 程序，在数据包到达后立即对其进行检查，并迅速确定一个数据包是否是这种攻击的一部分，如果是，则将其丢弃。数据包不必通过内核的网络堆栈，因此需要的处理资源要少得多，而且目标可以应对更大规模的恶意流量。&lt;/p&gt;
&lt;p&gt;eBPF 程序也被用于动态缓解”死亡数据包“的内核漏洞 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。攻击者以这样的方式制作一个网络工作数据包——利用了内核中的一个错误，使其无法正确处理该数据包。与其等待内核补丁的推出，不如通过加载一个 eBPF 程序来缓解攻击，该程序可以寻找这些特别制作的数据包并将其丢弃。这一点的真正好处是，eBPF 程序可以动态加载，而不必改变机器上的任何东西。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中，&lt;a href=&#34;https://networkpolicy.io/&#34; title=&#34;网络策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络策略&lt;/a&gt;
 是一等资源，但它是由网络插件来执行的。一些 CNI，包括 Cilium 和 Calico，为更强大的规则提供了扩展的网络策略功能，例如允许或禁止流量到一个由完全限定域名而不是仅仅由 IP 地址指定的目的地。在 &lt;a href=&#34;https://app.networkpolicy.io/&#34; title=&#34;app.networkpolicy.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;app.networkpolicy.io&lt;/a&gt;
 有一个探索网络策略及其效果的好工具，如 &lt;a href=&#34;#figure-f-6-5&#34; title=&#34;图 6-5&#34;&gt;图 6-5&lt;/a&gt;
 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
    &lt;img src=&#34;f-6-5.jpg&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;
         alt=&#34;图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示&#34; id=&#34;f-6-5&#34;data-img=&#34;f-6-5.jpg&#34;
         data-caption=&#34;图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示&#34;
         
         
         data-width=&#34;1552&#34;
         data-height=&#34;1728&#34;
         
         
    /&gt;&lt;figcaption&gt;
            图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;标准的 Kubernetes 网络策略规则适用于进出应用 pod 的流量，但由于 eBPF 对所有网络流量都有可视性，它也可用于主机防火墙功能，限制进出主机（虚拟机）的流量 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;eBPF 也可以被用来提供透明的加密，无论是通过 WireGuard 还是 IPsec &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。在这里，&lt;strong&gt;透明&lt;/strong&gt; 意味着应用程序不需要任何修改 —— 事实上，应用程序可以完全不知道其网络流量是被加密的。&lt;/p&gt;
&lt;h3 id=&#34;运行时安全&#34;&gt;运行时安全&lt;/h3&gt;
&lt;p&gt;eBPF 也被用来构建工具，检测恶意程序，防止恶意行为。这些恶意程序包括访问未经许可的文件，运行可执行程序，或试图获得额外的权限。&lt;/p&gt;
&lt;p&gt;事实上，你很可能已经以 seccomp 的形式使用了基于 BPF 的安全策略，这是一个 Linux 功能，限制应用程序可以调用的系统调用集。&lt;/p&gt;
&lt;p&gt;CNCF 项目 &lt;a href=&#34;https://falco.org/&#34; title=&#34;Falco&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falco&lt;/a&gt;
 扩展了这种限制应用程序可以进行系统调用的想法。Falco 的规则定义是用 YAML 创建的，这比 seccomp 配置文件更容易阅读和理解。默认的 Falco 驱动是一个内核模块，但也有一个 eBPF 探针驱动，它与”原始系统调用“事件相联系。它不会阻止这些系统调用的完成，但它可以生成日志或其他通知，提醒操作人员注意潜在的恶意程序。&lt;/p&gt;
&lt;p&gt;正如我们在 &lt;a href=&#34;../ebpf-programs&#34; title=&#34;第三章&#34;&gt;第三章&lt;/a&gt;
 中看到的，eBPF 程序可以附加到 LSM 接口上，以防止恶意行为或修复已知的漏洞。例如，Denis Efremov 写了一个 &lt;a href=&#34;https://github.com/evdenis/lsm_bpf_check_argc0&#34; title=&#34;eBPF 程序&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 程序&lt;/a&gt;
 来防止 &lt;code&gt;exec()&lt;/code&gt; 系统调用在没有传递任何参数的情况下运行，以修复 PwnKit &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 的高危漏洞。eBPF 也可用于缓解投机执行的”Spectre“攻击 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aquasecurity/tracee&#34; title=&#34;Tracee&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracee&lt;/a&gt;
 是另一个使用 eBPF 的运行时安全开源项目。除了基于系统调用的检查之外，它还使用 LSM 接口。这有助于避免受到 &lt;a href=&#34;https://lwn.net/Articles/245630/&#34; title=&#34;TOCTTOU 竞争&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOCTTOU 竞争&lt;/a&gt;
 条件的影响，因为只检查系统调用时可能会出现这种情况。Tracee 支持用 Open Policy Agent 的 Rego 语言定义的规则，也允许用 Go 定义的插件规则。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/tetragon&#34; title=&#34;Tetragon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetragon&lt;/a&gt;
 组件提供了另一种强大的方法，使用 eBPF 来监控 &lt;strong&gt;容器安全可观测性的四个黄金信号&lt;/strong&gt;：进程执行、网络套接字、文件访问和七层网络身份。这使操作人员能够准确地看到所有恶意或可疑事件，直击特定 pod 中的可执行文件名称和用户身份。例如，如果你受到加密货币挖矿的攻击，你可以看到到底是什么可执行程序打开了与矿池的网络连接，什么时候，从哪个 pod。这些取证是非常有价值的，可以了解漏洞是如何发生的，并使其容易建立安全策略，以防止类似的攻击再次发生。&lt;/p&gt;
&lt;p&gt;如果你想更深入地了解 eBPF 的安全可观测性这一主题，请查看 Natália Ivánkó 和 Jed Salazar 的报告 &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。请关注云原生 eBPF 领域，因为不久之后我们就会看到利用 BPF LSM 和其他 eBPF 定制的工具来提供安全执行和可以观测能力。&lt;/p&gt;
&lt;p&gt;我们在网络、可观测性和安全方面对几个云原生工具进行了考察。与前几代相比，eBPF 的使用为它们两个关键优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从内核中的有利位置来看，eBPF 程序对所有进程都有可视性。&lt;/li&gt;
&lt;li&gt;通过避免内核和用户空间执行之间的转换，eBPF 程序为收集事件数据或处理网络数据包提供了一种极其有效的方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着我们应该使用 eBPF 来处理所有的事情！在 eBPF 中编写特定业务的应用程序是没有意义的，就像我们不可能将应用程序写成内核模块一样。但是也有一些例外情况，比如对于高频交易这样对性能有极高的情况下。正如我们在本章中所看到的那样，eBPF 主要是用于为其他应用程序提供工具。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;有些网卡或驱动支持 XDP 或 eXpress Data Path 钩子，允许 eBPF 程序完全从内核中卸载出来。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Daniel Borkmann 在他的&lt;a href=&#34;https://www.youtube.com/watch?v=Qhm1Zn_BNi4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;
中讨论了这个问题，《BPF 更适合作为数据平面》（eBPF 峰会（线上），2020 年）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;见 Cilium 的主机防火墙&lt;a href=&#34;https://docs.cilium.io/en/stable/gettingstarted/host-firewall/&#34; title=&#34;文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;
。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Tailscale 有这两种加密协议的&lt;a href=&#34;https://tailscale.com/kb/1173/ipsec-vs-wireguard/&#34; title=&#34;比较&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;比较&lt;/a&gt;
。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;见 Bharat Jogi 的&lt;a href=&#34;https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034&#34; title=&#34;博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;
，《PwnKit: 本地权限升级漏洞》（Qualys，2022 年 1 月 25 日）。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;见 Daniel Borkmann 的&lt;a href=&#34;https://www.youtube.com/watch?v=6N30Yp5f9c4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; title=&#34;演讲&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;
，《BPF 和 Spectre：缓解瞬时执行攻击问题》（eBPF 峰会（线上），2021 年 8 月 18-19 日）。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Natália Ivánkó 和 Jed Salazar，《&lt;a href=&#34;https://learning.oreilly.com/library/view/security-observability-with/9781492096719/&#34; title=&#34;Security Observability with eBPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Security Observability with eBPF&lt;/a&gt;
》（O’Reilly，2022）。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>第七章：结论</title>
      <link>https://jimmysong.io/book/what-is-ebpf/conclusion/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      
      <guid>https://jimmysong.io/book/what-is-ebpf/conclusion/</guid>
      <description>
        
        
        &lt;p&gt;我希望这个简短的报告能让你了解 eBPF 和它的强大之处。我真正希望的是，你已经准备好尝试一些基于 eBPF 的工具！如果你想在技术方面深入研究，可以从 &lt;a href=&#34;https://ebpf.io/&#34; title=&#34;ebpf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io&lt;/a&gt;
 开始，在那里你会找到更多关于技术和 ebPF 基金会的信息。对于编码实例，可以在 GitHub 上的 &lt;a href=&#34;https://github.com/lizrice/ebpf-beginners&#34; title=&#34;ebpf-beginners&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf-beginners&lt;/a&gt;
 仓库里找到。&lt;/p&gt;
&lt;p&gt;为了了解其他人是如何利用 eBPF 工具的，请参加 &lt;a href=&#34;https://twitter.com/ebpfsummit&#34; title=&#34;eBPF Summit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF Summit&lt;/a&gt;
 和 &lt;a href=&#34;https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/&#34; title=&#34;Cloud Native eBPF Day&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native eBPF Day&lt;/a&gt;
 等活动，在这些活动中，用户分享他们的成功和学习经验。还有一个活跃的 Slack 频道 &lt;a href=&#34;https://cilium.herokuapp.com/&#34; title=&#34;ebpf.io/slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io/slack&lt;/a&gt;
。我希望能在那里见到你！&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
