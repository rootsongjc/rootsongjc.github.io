
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 安全专栏</title>
    <link>https://jimmysong.io/categories/%E5%AE%89%E5%85%A8/</link>
    <description>Recent content in 安全专栏 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>Jimmy Song</managingEditor>
    <webMaster>Jimmy Song</webMaster>
    
      <follow_challenge>
        <feedId>51621818828612637</feedId>
        <userId>59800919738273792</userId>
      </follow_challenge>
    
    
    <lastBuildDate>Thu, 08 Aug 2024 18:01:48 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
                                                         
    
                                                   
                           
    <item>
      <title>在 Envoy 中集成 SPIRE</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/envoy/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/envoy/</guid>
      <description>
        
        
        &lt;p&gt;本文指导你如何配置 Envoy 代理与 SPIFFE 和 SPIRE 配合使用。&lt;/p&gt;
&lt;p&gt;Envoy 是一种流行的开源服务代理，广泛用于提供抽象、安全、经过身份验证和加密的服务间通信。Envoy 拥有丰富的配置系统，允许灵活地与第三方进行交互。&lt;/p&gt;
&lt;p&gt;该配置系统的一个组成部分是 Secret Discovery Service 协议或 SDS。Envoy 使用 SDS 从 SDS 提供者检索和维护更新的“密钥”。在 TLS 身份验证的上下文中，这些密钥是 TLS 证书、私钥和可信 CA 证书。SPIRE 代理可以配置为 Envoy 的 SDS 提供者，使其能够直接向 Envoy 提供所需的密钥材料以进行 TLS 身份验证。SPIRE 代理还会根据需要重新生成短期密钥和证书。&lt;/p&gt;
&lt;p&gt;有关如何将 SPIRE 与 Envoy 集成的基于 Kubernetes 的示例，请参阅&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/tree/main/k8s/envoy-x509&#34; title=&#34;使用 X.509 证书集成 Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 X.509 证书集成 Envoy&lt;/a&gt; 和&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/tree/main/k8s/envoy-jwt&#34; title=&#34;使用 JWT 集成 Envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 JWT 集成 Envoy&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;工作原理&#34;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;当 Envoy 连接到 SPIRE 代理提供的 SDS 服务器时，代理会对 Envoy 进行验证，并确定应向 Envoy 公开哪些服务标识和 CA 证书，以通过 SDS。&lt;/p&gt;
&lt;p&gt;随着服务标识和 CA 证书的轮换，更新会流式传输回 Envoy，使其可以立即将其应用于新连接，无需中断或停机，并且无需私钥接触磁盘。换句话说，SPIRE 丰富的定义和验证服务的方法可以用于定位 Envoy 进程、为其定义标识，并为其提供 Envoy 可用于 TLS 通信的 X.509 证书和信任信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy/spire_plus_envoy_hu5461745831327954119.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy/spire_plus_envoy.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy/spire_plus_envoy.png&#34; data-width=&#34;1600&#34; data-height=&#34;563&#34; alt=&#34;image&#34; data-caption=&#34;示意图展示了两个 Envoy 代理在使用 SPIRE 代理 SDS，实现获取用于服务间相互认证的 TLS 通信的密钥。&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;示意图展示了两个 Envoy 代理在使用 SPIRE 代理 SDS，实现获取用于服务间相互认证的 TLS 通信的密钥。&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;配置-spire&#34;&gt;配置 SPIRE&lt;/h2&gt;
&lt;p&gt;在 SPIRE v0.10 版本中，默认启用了 SDS 支持，因此不需要进行 SPIRE 配置更改。在早期版本的 SPIRE 中，SPIRE 代理配置文件中需要设置 &lt;code&gt;enable_sds = true&lt;/code&gt;。该设置现已停用，应在 SPIRE v0.10 及更高版本的 SPIRE 代理配置文件中删除该设置。&lt;/p&gt;
&lt;h2 id=&#34;配置-envoy&#34;&gt;配置 Envoy&lt;/h2&gt;
&lt;h3 id=&#34;spire-代理集群&#34;&gt;SPIRE 代理集群&lt;/h3&gt;
&lt;p&gt;必须配置 Envoy 以与 SPIRE 代理通信，方法是配置一个指向 SPIRE 代理提供的 Unix 域套接字的集群。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;25s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http2_protocol_options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/tmp/spire-agent/public/api.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;connect_timeout&lt;/code&gt; 影响当 Envoy 在启动时 SPIRE 代理未运行或 SPIRE 代理重新启动时，Envoy 能够快速响应的速度。&lt;/p&gt;
&lt;h3 id=&#34;tls-证书&#34;&gt;TLS 证书&lt;/h3&gt;
&lt;p&gt;要从 SPIRE 获取 TLS 证书和私钥，可以在 TLS 上下文中设置 SDS 配置。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;tls_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;common_tls_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls_certificate_sds_secret_configs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/backend&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_config_source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GRPC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;TLS 证书的名称是 Envoy 作为代理的服务的 SPIFFE ID。&lt;/p&gt;
&lt;h3 id=&#34;验证上下文&#34;&gt;验证上下文&lt;/h3&gt;
&lt;p&gt;Envoy 使用可信 CA 证书来验证对等证书。验证上下文提供这些可信 CA 证书。SPIRE 可以为每个信任域提供验证上下文。&lt;/p&gt;
&lt;p&gt;要获取信任域的验证上下文，可以在 TLS 上下文的 SDS 配置中配置验证上下文，将验证上下文的名称设置为信任域的 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;tls_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;common_tls_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;validation_context_sds_secret_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_config_source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GRPC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SPIFFE 和 SPIRE 的重点是促进安全身份验证作为授权的构建块，而不是授权本身，因此验证上下文中的授权相关字段（例如 &lt;code&gt;match_subject_alt_names&lt;/code&gt;）不在其范围之内。相反，我们建议你利用 Envoy 的广泛过滤器框架执行授权。&lt;/p&gt;
&lt;p&gt;此外，你可以配置 Envoy 以将客户端证书详细信息转发到目标服务，使其能够执行自己的授权步骤，例如使用嵌入在客户端 X.509-SVID 的 URI SAN 中的 SPIFFE ID。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 基本概念</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/concept/spiffe/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/concept/spiffe/</guid>
      <description>
        
        
        &lt;p&gt;SPIFFE，即普适安全生产身份框架（Secure Production Identity Framework for Everyone），是一套开源标准，用于在动态和异构环境中安全地进行身份识别。采用 SPIFFE 的系统无论在哪里运行，都可以轻松可靠地相互认证。&lt;/p&gt;
&lt;p&gt;SPIFFE 开源规范的核心是——通过简单 API 定义了一个短期的加密身份文件 SVID。然后，工作负载进行认证时可以使用该身份文件，例如建立 TLS 连接或签署和验证 JWT 令牌等。&lt;/p&gt;
&lt;p&gt;SPIFFE 已经在云原生应用中得到了大量的应用，尤其是在 Istio 和 Envoy 中。下面将向你介绍 SPIFFE 的一些基本概念。&lt;/p&gt;
&lt;h2 id=&#34;工作负载&#34;&gt;工作负载&lt;/h2&gt;
&lt;p&gt;工作负载是一个单一的软件实体，通过特定配置部署，用于单一目的；它可能包括多个运行中的软件实例，所有这些实例执行相同的任务。术语“工作负载”可能涵盖软件系统的各种不同定义，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 Python Web 应用程序的 Web 服务器，部署在一组虚拟机上，前面有一个负载均衡器。&lt;/li&gt;
&lt;li&gt;一个 MySQL 数据库的实例。&lt;/li&gt;
&lt;li&gt;处理队列中条目的工作程序。&lt;/li&gt;
&lt;li&gt;一组独立部署的系统共同工作，例如使用数据库服务的 Web 应用程序。Web 应用程序和数据库也可以分别被视为工作负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 SPIFFE 来说，工作负载往往比物理或虚拟节点更精细 - 通常精细到节点上的单个进程。对于在容器编排器中托管的工作负载而言，这对于多个工作负载可以共存（但在彼此之间隔离）于单个节点的情况非常重要。&lt;/p&gt;
&lt;p&gt;对于 SPIFFE 来说，工作负载也可能跨越多个节点 - 例如，一个可以在多台机器上同时运行的弹性缩放的 Web 服务器。&lt;/p&gt;
&lt;p&gt;尽管在不同的上下文中，将何为工作负载的粒度会有所不同，但对于 SPIFFE 的目的而言，&lt;em&gt;假定&lt;/em&gt;工作负载与其他工作负载隔离得足够好，以至于恶意的工作负载在发放证书后无法窃取另一个工作负载的凭据。此隔离的稳固性以及其实现机制超出了 SPIFFE 的范围。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-id&#34;&gt;SPIFFE ID&lt;/h2&gt;
&lt;p&gt;SPIFFE ID 是一个字符串，唯一且具体地标识一个工作负载。SPIFFE ID 也可以分配给工作负载运行在的中间系统（如一组虚拟机）。例如，&lt;strong&gt;spiffe://acme.com/billing/payments&lt;/strong&gt; 是一个有效的 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;SPIFFE ID 是一个&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;统一资源标识符 (URI)&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;统一资源标识符 (URI)&lt;/a&gt;，其格式如下：&lt;strong&gt;spiffe://信任域/工作负载标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;工作负载标识符&lt;/em&gt;唯一地标识&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-domain&#34; title=&#34;信任域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任域&lt;/a&gt;中的特定工作负载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE.md&#34; title=&#34;SPIFFE 规范&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 规范&lt;/a&gt;详细描述了 SPIFFE ID 的格式和用途。&lt;/p&gt;
&lt;h2 id=&#34;信任域&#34;&gt;信任域&lt;/h2&gt;
&lt;p&gt;信任域对应于系统的信任根。信任域可以代表运行其独立 SPIFFE 基础设施的个人、组织、环境或部门。在相同信任域中标识的所有工作负载都会收到可以与信任域的根密钥进行验证的身份文件。&lt;/p&gt;
&lt;p&gt;通常建议将位于不同物理位置（例如不同数据中心或云区域）或应用不同安全实践的环境（例如与生产环境相比的暂存或实验环境）的工作负载保持在不同的信任域中。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-可验证身份文件svid&#34;&gt;SPIFFE 可验证身份文件（SVID）&lt;/h2&gt;
&lt;p&gt;SVID 是工作负载用于向资源或调用方证明其身份的文档。如果由 SPIFFE ID 信任域内的权威签名，SVID 被认为是有效的。&lt;/p&gt;
&lt;p&gt;一个 SVID 包含一个单一的 SPIFFE ID，代表了呈现它的服务的身份。它将 SPIFFE ID 编码在一个密码学可验证的文档中，支持两种当前支持的格式之一：X.509 证书或 JWT 令牌。&lt;/p&gt;
&lt;p&gt;由于令牌容易受到&lt;em&gt;重放攻击&lt;/em&gt;，在传输中获取了令牌后，攻击者可以使用它来冒充一个工作负载，因此建议尽可能使用 X.509-SVIDs。但是，在某些情况下，JWT 令牌格式可能是唯一的选择，例如当你的架构在两个工作负载之间有一个 L7 代理或负载均衡器时。&lt;/p&gt;
&lt;p&gt;有关 SVID 的详细信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/main/standards/X509-SVID.md&#34; title=&#34;SVID 规范&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVID 规范&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-工作负载-api&#34;&gt;SPIFFE 工作负载 API&lt;/h2&gt;
&lt;p&gt;工作负载 API 提供以下功能：&lt;/p&gt;
&lt;p&gt;对于 X.509 格式的身份文件（X.509-SVID）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其身份，以 SPIFFE ID 形式描述。&lt;/li&gt;
&lt;li&gt;与该 ID 相关的私钥，可用于代表工作负载对数据进行签名。还创建了相应的短暂的 X.509 证书，即 X509-SVID。这可用于建立 TLS 连接或以其他方式对其他工作负载进行身份验证。&lt;/li&gt;
&lt;li&gt;一组证书 - 称为&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle&#34; title=&#34;信任捆绑包&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任捆绑包&lt;/a&gt; - 可用于验证另一个工作负载呈现的 X.509-SVID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 JWT 格式的身份文件（JWT-SVID）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其身份，以 SPIFFE ID 形式描述。&lt;/li&gt;
&lt;li&gt;JWT 令牌&lt;/li&gt;
&lt;li&gt;一组证书 - 称为&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle&#34; title=&#34;信任捆绑包&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任捆绑包&lt;/a&gt; - 可用于验证其他工作负载的身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与&lt;a href=&#34;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html&#34; title=&#34;Amazon EC2 实例元数据 API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon EC2 实例元数据 API&lt;/a&gt;和&lt;a href=&#34;https://cloud.google.com/compute/docs/storing-retrieving-metadata&#34; title=&#34;Google GCE 实例元数据 API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google GCE 实例元数据 API&lt;/a&gt;类似，工作负载 API 不要求调用工作负载具有自己的身份知识，或在调用 API 时拥有任何身份验证令牌。这意味着你的应用程序无需将任何身份验证密钥与工作负载一起部署。&lt;/p&gt;
&lt;p&gt;然而，与这些其他 API 不同，工作负载 API 是平台无关的，并且可以在进程级别以及内核级别识别运行的服务 - 这使其适用于与容器调度器（如 Kubernetes）一起使用。&lt;/p&gt;
&lt;p&gt;为了最小化由于密钥泄露或被破坏而造成的风险，所有私钥（及相应的证书）都是短暂的，会经常自动轮换。在相应的密钥到期之前，工作负载可以从工作负载 API 请求新的密钥和信任捆绑包。&lt;/p&gt;
&lt;h2 id=&#34;信任捆绑包&#34;&gt;信任捆绑包&lt;/h2&gt;
&lt;p&gt;在使用 X.509-SVID 时，信任捆绑包用于由目标工作负载验证源工作负载的身份。信任捆绑包是一个包含一个或多个证书颁发机构（CA）根证书的集合，工作负载应将其视为可信任的。信任捆绑包包含了验证 X.509 和 JWT SVID 的公钥材料。&lt;/p&gt;
&lt;p&gt;用于验证 X.509 SVID 的公钥材料是一组证书。用于验证 JWT 的公钥材料是一个原始的公钥。信任捆绑包的内容经常会发生变化。在调用工作负载 API 时，工作负载会检索信任捆绑包。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE ID 和 SVID</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-id/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-id/</guid>
      <description>
        
        
        &lt;p&gt;SPIFFE 标准提供了一个规范，用于在异构环境和组织边界中引导和颁发服务的身份。它包括各种规范，每个规定了 SPIFFE 功能的特定子集的操作。&lt;/p&gt;
&lt;p&gt;特别是本文档作为 SPIFFE 标准的核心规范。虽然在 SPIFFE 范围内还有其他规范，但符合本文档就足以实现 SPIFFE 合规性，并获得 SPIFFE 标准本身的互操作性好处。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;本文档提出了正式的 SPIFFE 规范。它定义了 SPIFFE 标准的两个最基本组件：SPIFFE 身份和 SPIFFE 可验证身份文档。&lt;/p&gt;
&lt;p&gt;第 2 节概述了 SPIFFE 身份（SPIFFE ID）及其命名空间。SPIFFE ID 被定义为符合&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;标准的 URI，包括“信任域名”和相关路径。信任域名作为 URI 的授权组件，用于识别发放给定身份的系统。以下示例演示了如何构造 SPIFFE ID：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://trust-domain-name/path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有效的 SPIFFE ID 必须将方案设置为&lt;code&gt;spiffe&lt;/code&gt;，包含非零的信任域名，并且不能包含查询或片段组件。换句话说，SPIFFE ID 由&lt;code&gt;spiffe&lt;/code&gt;方案和一个特定站点的&lt;code&gt;hier-part&lt;/code&gt;（其中包括授权组件和可选路径）完全定义。&lt;/p&gt;
&lt;h3 id=&#34;信任域&#34;&gt;信任域&lt;/h3&gt;
&lt;p&gt;信任域对应于系统的信任根。信任域可以代表独立运行其自己的 SPIFFE 基础设施的个人、组织、环境或部门。&lt;/p&gt;
&lt;p&gt;信任域名称通常是自我注册的，与公共 DNS 不同，没有委托权机构来断言并注册基本域名到实际的法律实体，或者断言该法律实体对任何特定信任域名拥有公正和正当的权利。&lt;/p&gt;
&lt;p&gt;信任域名被定义为 URI 的授权组件，并应用以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分不得为空。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;userinfo&lt;/code&gt;和&lt;code&gt;port&lt;/code&gt;部分必须为空。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分必须小写。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分只能包含字母、数字、点、破折号和下划线（[a-z0-9.-_]）。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分不能包含百分比编码的字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，此定义不排除用点分四段表示法表示的 IPv4 地址，但排除了 IPv6 地址。DNS 名称是有效信任域名的严格子集。实现在处理信任域名时，无论它们是有效的 IP 地址还是有效的 DNS 名称，都不得以不同方式处理它们。&lt;/p&gt;
&lt;h4 id=&#34;信任域名称冲突&#34;&gt;信任域名称冲突&lt;/h4&gt;
&lt;p&gt;信任域操作员可以自由选择任何他们认为合适的信任域名称：没有中央权威机构来监管或注册信任域名称。因此，不能保证全局唯一性，也没有技术手段阻止不同的信任域使用相同的信任域名称。&lt;/p&gt;
&lt;p&gt;为防止意外碰撞（两个信任域选择相同的名称），建议操作员选择高度可能全球唯一的信任域名称。即使信任域名称不是 DNS 名称，但如果可用，使用注册的域名作为信任域名的后缀将降低意外碰撞的可能性；例如，如果信任域操作员拥有域名&lt;code&gt;example.com&lt;/code&gt;，那么使用类似&lt;code&gt;trust_domain_name.example.com&lt;/code&gt;的信任域名可能不会产生冲突。当信任域名在没有操作员输入的情况下自动生成时，强烈建议随机生成一个唯一的名称（例如 UUID）。&lt;/p&gt;
&lt;p&gt;发生冲突时，这些信任域将继续独立运行，但将无法联合（相互连接）。因为每个信任域使用独特的信任根，由一个信任域发放的身份声明将在另一个信任域中验证失败。&lt;/p&gt;
&lt;h3 id=&#34;路径&#34;&gt;路径&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 的路径组件允许唯一标识给定的工作负载。路径的含义是开放式的，由管理员负责定义。&lt;/p&gt;
&lt;p&gt;有效的 SPIFFE ID 路径组件必须遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径组件不能包含百分比编码的字符。&lt;/li&gt;
&lt;li&gt;路径组件不能包含空段或相对路径修饰符（即&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;路径组件不能以斜杠结尾。&lt;/li&gt;
&lt;li&gt;单个路径段只能包含字母、数字、点、破折号和下划线（[a-zA-Z0-9.-_]）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路径可以是分层的，类似于文件系统路径。路径的具体含义保留给实施者，不属于 SVID 规范的范围之内。以下是一些示例和约定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接标识服务&lt;/p&gt;
&lt;p&gt;通常，直接标识服务是有价值的。例如，管理员可能会决定在特定一组节点上运行的任何进程都应该能够以特定的身份呈现自己。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://staging.example.com/payments/mysql&lt;/code&gt;
或
&lt;code&gt;spiffe://staging.example.com/payments/web-fe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述两个 SPIFFE ID 指代了两个不同的组件 - mysql 数据库服务和一个运行在暂存环境中的支付服务的 web 前端。环境“staging”的含义和“payments”作为高级服务集合的含义由实施者定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识服务所有者&lt;/p&gt;
&lt;p&gt;通常，更高级别的编排器和平台可能已经内置了它们自己的身份概念（如 Kubernetes 服务账户或 AWS/GCP 服务账户），直接将 SPIFFE 身份映射到这些身份是很有帮助的。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://k8s-west.example.com/ns/staging/sa/default&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，example.com 的管理员正在运行一个名为 k8s-west.example.com 的 Kubernetes 集群，该集群有一个“staging”命名空间，在其中有一个名为“default”的服务账户（sa）。这些都是由 SPIFFE 管理员定义的约定，而不是本规范所保证的断言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不透明的 SPIFFE 身份&lt;/p&gt;
&lt;p&gt;上述示例是说明性的，在最一般的情况下，SPIFFE 路径可能是不透明的，不包含任何可见的分层信息。例如，地理位置、逻辑系统分区和/或服务名称等元数据可以由注册身份及其属性的次级系统提供。可以查询以检索与 SPIFFE 标识符相关联的任何元数据。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://example.com/9eebccd2-12bf-40a6-b262-65fe0487d453&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最大-spiffe-id-长度&#34;&gt;最大 SPIFFE ID 长度&lt;/h3&gt;
&lt;p&gt;如&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;定义的 URI 没有最大长度。出于互操作性考虑，SPIFFE 实现必须支持最长为 2048 字节的 SPIFFE URI，并且不应生成长度大于 2048 字节的 URI。&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;仅允许 ASCII 字符，因此 SPIFFE ID 的推荐最大长度为 2048 字节。&lt;/p&gt;
&lt;p&gt;所有 URI 组件都会影响 URI 的长度，包括“spiffe”方案、“：//”分隔符、信任域名和路径组件。非 ASCII 字符在将其编码为 ASCII 字符后会影响 URI 的长度。请注意，&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;为 URI 的“host”组件定义了最大长度为 255 个字符；因此，信任域名的最大长度为 255 字节。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-id-解析&#34;&gt;SPIFFE ID 解析&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 遵循由&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;定义的 URI 规范。SPIFFE ID 的方案和信任域名对大小写不敏感，而路径对大小写敏感。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-可验证身份文档&#34;&gt;SPIFFE 可验证身份文档&lt;/h2&gt;
&lt;p&gt;SPIFFE 可验证身份文档（SVID）是工作负载将其身份通信给资源或调用者的机制。如果 SVID 已由 SPIFFE ID 所在信任域内的授权方签名，则认为 SVID 是有效的。&lt;/p&gt;
&lt;h3 id=&#34;svid-信任&#34;&gt;SVID 信任&lt;/h3&gt;
&lt;p&gt;SPIFFE 信任根植于给定 ID 的信任域。每个信任域必须存在一个签名授权机构，该授权机构必须携带自己的 SVID。签名授权机构的 SPIFFE ID 应该驻留在其具有权威性的信任域中，并且不应具有路径组件。授权机构的 SVID 然后形成了给定信任域的信任基础。&lt;/p&gt;
&lt;p&gt;如果需要，可以通过使用外部信任域授权机构的私钥对授权机构的 SVID 进行签名来实现信任链。如果不需要链接信任，那么授权机构的 SVID 将进行自签名。&lt;/p&gt;
&lt;h3 id=&#34;svid-组件&#34;&gt;SVID 组件&lt;/h3&gt;
&lt;p&gt;SVID 是一个相当简单的构造，包括三个基本组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 SPIFFE ID&lt;/li&gt;
&lt;li&gt;一个有效的签名&lt;/li&gt;
&lt;li&gt;一个可选的公钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SPIFFE ID 和公钥（如果存在）必须包含在签名的有效载荷的一部分中。如果包含了公钥，则相应的私钥将由发放 SVID 的实体保留，并用于证明对 SVID 本身的所有权。&lt;/p&gt;
&lt;p&gt;个别的 SVID 规范可能要求或以其他方式允许在 SVID 中包含超出此处描述的内容。所包含信息的性质可能或可能不会严格由相关的 SPIFFE 规范定义 - 例如，JWT-SVID 规范允许用户在 SVID 本身中包含任意信息。在相关 SVID 规范未明确指定此附加信息的情况下，操作者在将此信息用作安全决策的输入时应格外小心，特别是如果要验证的 SVID 属于不同的信任域。有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;svid-格式&#34;&gt;SVID 格式&lt;/h3&gt;
&lt;p&gt;SVID 本身不是一种文件类型。已经存在许多文件格式可以满足 SPIFFE SVID 的需求，我们不希望重新发明这些格式。相反，我们定义了一组特定于格式的规范，规范化了 SVID 信息的编码。&lt;/p&gt;
&lt;p&gt;为了使 SVID 被视为有效，它必须利用已定义相应规范的文件类型。在撰写本文时，唯一受支持的文件类型是 X.509 和 JWT。请注意，特定于格式的 SVID 规范可能会升级本文中规定的要求。&lt;/p&gt;
&lt;h2 id=&#34;安全注意事项&#34;&gt;安全注意事项&lt;/h2&gt;
&lt;p&gt;本节包含在使用 SPIFFE ID 和 SVID 时实施者和用户应考虑的安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;svid-断言&#34;&gt;SVID 断言&lt;/h3&gt;
&lt;p&gt;SVID 始终包含一组数据 - 至少是一个 SPIFFE ID。有时，此数据代表了信任域授权机构对 SVID 主体所做的断言。在从此数据中解释含义时，必须小心确保所有涉及方都充分理解所使用信息的含义和重要性。&lt;/p&gt;
&lt;p&gt;在考虑给定断言的相对安全性时，有四个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是时间上的准确性 - SVID 在到期之前一段时间内是有效的，SVID 中的断言在 SVID 的整个生命周期内是否为真？&lt;/li&gt;
&lt;li&gt;其次，断言的范围和影响 - 断言最初是在什么上下文下进行的，它的影响有多大？&lt;/li&gt;
&lt;li&gt;第三是解释和含义的问题 - 断言对授权机构和消费者是否具有相同的含义或解释，或者存在着不同的解释可能性？&lt;/li&gt;
&lt;li&gt;最后，断言本身的真实性在某些情况下可能会受到质疑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节探讨了这四个关注领域的所有方面，并提供了操作者可以评估任何给定 SVID 断言的相对安全性的指导方针。一般来说，操作者应该以谨慎为原则，只包含那些对所涉及的断言的安全性具有非常高度信心的断言。&lt;/p&gt;
&lt;p&gt;值得注意的是，虽然通常由 SPIFFE 规范直接形式化的断言通常不容易受到与解释和含义相关的问题的影响，但它们仍然可能容易受到与真实性相关的问题的影响。但是，由于 SPIFFE 定义的断言的范围非常有限，因此在这方面的真实性问题表明了与问题相关的信任域的安全姿态的更大问题，此时操作者应该认真考虑是否应该在第一时间与这些系统交换数据。&lt;/p&gt;
&lt;h4 id=&#34;时间上的准确性&#34;&gt;时间上的准确性&lt;/h4&gt;
&lt;p&gt;SVID 在一段有限的时间内有效，主要是为了降低密钥被泄露和相关损害的可能性。虽然通常情况下，SVID 中的断言在签发时是真实的，但并不一定意味着在使用时也是真实的。&lt;/p&gt;
&lt;p&gt;某些类型的断言比其他类型更容易受到此问题的影响。服务所有者的名称、角色或组成员资格以及访问策略都是在 SVID 签发时和验证或使用时之间更有可能发生变化的示例。相反，工作负载及其运行时的自然属性（例如 SPIFFE ID 或工作负载所在的区域）通常与工作负载的生命周期绑定，因此不太可能发生变化，这使得它们不太容易受到时间上的准确性的问题影响。&lt;/p&gt;
&lt;p&gt;在决定是否应该在 SVID 中包含某个特定的断言时，考虑到这一点是很重要的。在 SVID 中作出的断言将被认为在 SVID 的生命周期内都是有效的，并且对于具有旧断言的所有 SVID 来说，将首先过期，因此在活动系统上对此断言进行更改（或撤销）将会很费时。如果对于所考虑的断言的波动性不清楚，操作者应该以谨慎为原则，并将其排除在 SVID 之外。&lt;/p&gt;
&lt;h4 id=&#34;范围和影响&#34;&gt;范围和影响&lt;/h4&gt;
&lt;p&gt;SVID 由位于其信任域中的授权机构签名。签名授权机构有责任验证其签署的 SVID 中的所有信息，而包含在 SVID 中的所有断言实际上都是由签名授权机构所做的断言。&lt;/p&gt;
&lt;p&gt;此授权机构的影响和断言所做的范围是自然有限的。一个信任域的授权机构的权限不应该对其他信任域中的实体做出断言（即其断言的范围仅限于其控制下的实体）。同样，在消费 SVID 数据时，消费者应该将其中包含的所有断言视为受到 SVID 所在信任域的限制。&lt;/p&gt;
&lt;p&gt;例如：如果信任域 A 和 B 都使用名为“role”的属性，那么信任域 A 中具有“admin”角色的实体可以使用该角色做出自己信任域中 SVID 的断言，但信任域 B 中的实体不能使用与 A 中相同的断言对其 SVID 进行断言。&lt;/p&gt;
&lt;p&gt;在这方面，SPIFFE 设计意图是将这些信任域之间的安全隔离形式化并保证在接受 SPIFFE SVID 的所有系统中得到正确执行。&lt;/p&gt;
&lt;h4 id=&#34;解释&#34;&gt;解释&lt;/h4&gt;
&lt;p&gt;通过签名 SVID 断言，签名授权机构明确其对所签名断言的含义的解释。此解释的范围由信任域的信任基础确定。&lt;/p&gt;
&lt;p&gt;此外，消费者和其他参与者也可以对断言的含义进行自己的解释。例如，可能存在一个交叉信任域的场景，其中包含了不同信任域中的实体。这些实体可能会在实体之间以不同方式解释相同的断言。&lt;/p&gt;
&lt;p&gt;操作者和开发人员在评估任何给定 SVID 断言的相对安全性时应该非常小心，特别是如果要验证的 SVID 属于不同的信任域。尽管通常情况下这种情况不会出现问题，但它也可能会导致复杂的安全问题，甚至不可知的问题。&lt;/p&gt;
&lt;h4 id=&#34;真实性&#34;&gt;真实性&lt;/h4&gt;
&lt;p&gt;就像所有数字证书和断言一样，SVID 的真实性取决于其颁发方的安全性。签名授权机构的私钥的保护是 SVID 真实性的主要保障。如果授权机构的私钥暴露或泄漏，那么可以生成无效 SVID，并可能会导致错误的授权。&lt;/p&gt;
&lt;p&gt;授权机构的私钥的安全性是信任域操作员的责任，他们应该采取必要的措施来确保私钥的安全，包括使用强大的密码学方法（如硬件安全模块）来保护私钥。此外，应定期更换私钥以降低突破的风险。&lt;/p&gt;
&lt;p&gt;授权机构的私钥的安全性也是操作员选择是否使用外部信任域授权机构的一个重要考虑因素。如果使用外部授权机构的私钥进行签名，那么授权机构的私钥的安全性不再完全由信任域操作员控制，而是由外部授权机构的授权机构控制。这可能会引入一些风险和不确定性，特别是如果外部授权机构是第三方服务或实体。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;请注意，上述文档是一个假设的 SPIFFE（面向所有人的安全生产身份框架）标准的核心规范的示例草稿。实际的 SPIFFE 规范可能会包含更多细节和具体规定，同时也可能会参考其他相关规范。在实际使用中，请始终参考最新的 SPIFFE 规范文档以确保遵守正确的标准和规定。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>概念</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/concept/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/concept/</guid>
      <description>
        
        
        &lt;p&gt;本章介绍 SPIFFE 和 SPIRE 中的基本概念。&lt;/p&gt;


  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spiffe/&#34;&gt;SPIFFE&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/&#34;&gt;SPIRE&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>获取 SPIRE</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/installation/getting-spire/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/installation/getting-spire/</guid>
      <description>
        
        
        &lt;p&gt;本页面描述了一些开始使用 SPIRE 的选项。&lt;/p&gt;
&lt;h2 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://spiffe.io/docs/latest/try/spire101/&#34; title=&#34;SPIRE 101&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 101&lt;/a&gt; 是一个在 Docker Compose 上运行的 SPIRE 入门介绍&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spire-tutorials&lt;/a&gt; 存储库中提供了其他 Docker Compose 演示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SPIRE 没有官方的 Helm chart、Kustomize 文件或自定义资源操作器，但 &lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/getting-started-k8s/&#34; title=&#34;Kubernetes 快速入门&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 快速入门&lt;/a&gt; 包括一套用于测试 SPIRE Server 和 Agent 的基本 Kubernetes YAML 文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spire-tutorials&lt;/a&gt; 存储库中提供了其他 Kubernetes 演示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SPIRE GitHub &lt;a href=&#34;https://github.com/spiffe/spire/releases&#34; title=&#34;releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;releases&lt;/a&gt; 页面提供了每个 SPIRE 版本的下载链接和变更日志&lt;/li&gt;
&lt;li&gt;spiffe.io 的&lt;a href=&#34;https://spiffe.io/downloads/&#34; title=&#34;获取 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;获取 SPIRE&lt;/a&gt; 页面提供了其他下载选项和构建 SPIRE 的说明&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/getting-started-linux-macos-x/&#34; title=&#34;Linux 和 MacOS X 快速入门&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 和 MacOS X 快速入门&lt;/a&gt; 介绍了如何下载和测试 SPIRE Server 和 Agent 的简单单节点安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;macos&#34;&gt;MacOS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有预编译的 MacOS 可执行文件可用，但 &lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/getting-started-linux-macos-x/&#34; title=&#34;Linux 和 MacOS X 快速入门&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 和 MacOS X 快速入门&lt;/a&gt; 介绍了如何下载和构建 SPIRE 以测试 SPIRE Server 和 Agent 的简单单节点安装&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>扩展 SPIRE 部署：支持的 SPIRE 拓扑结构、身份联合和规模考虑</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/</guid>
      <description>
        
        
        &lt;p&gt;扩展 SPIRE 可以通过嵌套拓扑和联合拓扑来实现。&lt;strong&gt;嵌套拓扑允许将多个 SPIRE 服务器链接在一起，以发放属于同一信任域的身份。联合拓扑用于在不同信任域之间建立信任，使工作负载能够在不同信任域中进行身份验证&lt;/strong&gt;。SPIRE 还可以与其他 SPIFFE 兼容系统和 OIDC 提供者系统进行联合，以实现安全的身份验证和通信。在部署规模时，需要考虑 SVID 和根证书的生存时间、工作负载数量和分布、JWT-SVID 的使用等因素，并注意数据存储的设计和规划。&lt;/p&gt;
&lt;p&gt;SPIRE 部署可以根据工作负载的增长来调整大小或规模。一个 SPIRE 部署由一个或多个共享复制数据存储的 SPIRE 服务器组成，或者相反，由在同一信任域中的一组 SPIRE 服务器和至少一个 SPIRE 代理（通常是一个以上）组成。&lt;/p&gt;
&lt;p&gt;部署的大小范围广泛。单个 SPIRE 服务器可以容纳多个代理和工作负载注册条目。一个规模大小的考虑是，由于涉及到管理和发放与这些条目相对应的身份所涉及的操作数量，SPIRE 服务器实例的内存和 CPU 消耗往往与部署中的工作负载注册条目数量成比例增长。单个 SPIRE 服务器实例也代表了一个单点故障。&lt;/p&gt;
&lt;p&gt;为了支持给定部署中更多的代理和工作负载（数以万计或数十万个节点），可以水平扩展 SPIRE 服务器的数量。有了多个服务器，SPIRE 服务器执行的计算工作将在所有 SPIRE 服务器实例之间分布。除了额外的容量之外，使用多个 SPIRE 服务器实例还可以消除单点故障，实现高可用性。&lt;/p&gt;
&lt;h3 id=&#34;高可用性模式下的-spire-服务器&#34;&gt;高可用性模式下的 SPIRE 服务器&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/ha_mode_hu15327715924490176823.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/ha_mode.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/ha_mode.png&#34; data-width=&#34;1600&#34; data-height=&#34;712&#34; alt=&#34;image&#34; data-caption=&#34;水平扩展 SPIRE Server&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;水平扩展 SPIRE Server&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;要水平扩展 SPIRE 服务器，无论是出于高可用性还是负载分配目的，都要配置所有属于同一信任域的服务器以读写相同的共享数据存储。&lt;/p&gt;
&lt;p&gt;数据存储是 SPIRE 服务器持久保存动态配置信息的地方，例如注册条目和身份映射策略。SQLite 已捆绑到 SPIRE 服务器中，它是默认的数据存储。支持一些兼容的 SQL 数据库，以及一个用于使用 Kubernetes CRD 的 Kubernetes 插件。在水平扩展 SPIRE 服务器时，请选择符合你要求的数据存储，并配置所有 SPIRE 服务器以使用所选的数据存储。有关详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_datastore_sql.md&#34; title=&#34;数据存储插件配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据存储插件配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在高可用性模式下，每个服务器都维护自己的证书颁发机构，可以是自签名证书，也可以是从共享根证书颁发机构获取的中间证书（即在配置了上游机构时）。&lt;/p&gt;
&lt;h2 id=&#34;选择-spire-部署拓扑&#34;&gt;选择 SPIRE 部署拓扑&lt;/h2&gt;
&lt;p&gt;有三种主要的 SPIRE 部署拓扑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一信任域&lt;/li&gt;
&lt;li&gt;嵌套 SPIRE&lt;/li&gt;
&lt;li&gt;联合 SPIRE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;诸如管理域边界、工作负载数量、可用性要求、云供应商数量和身份验证要求等因素将决定你环境中的适当拓扑，如下所述。&lt;/p&gt;
&lt;h3 id=&#34;单一信任域&#34;&gt;单一信任域&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/single_trust_domain_hu5959286740032088029.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/single_trust_domain.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/single_trust_domain.png&#34; data-width=&#34;1600&#34; data-height=&#34;765&#34; alt=&#34;image&#34; data-caption=&#34;单一信任域&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;单一信任域&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;单一信任域最适合个体环境或在管理域内具有相似特征的环境。创建一个单一的主导信任域的主要动机是从单个证书颁发机构中发放身份，因为这会减少在不同部署中管理的 SPIRE 服务器数量。&lt;/p&gt;
&lt;p&gt;然而，当将单个 SPIRE 信任域部署以跨越地理区域、平台和云提供商环境时，在跨越地理位置或跨越云提供商边界的多个地方管理共享数据存储会带来一定的复杂性。在这些情况下，当部署扩展以覆盖多个环境时，解决在单一信任域上使用共享数据存储的问题的方法是在嵌套拓扑中配置 SPIRE 服务器。&lt;/p&gt;
&lt;h3 id=&#34;嵌套-spire&#34;&gt;嵌套 SPIRE&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/nested_spire_hu17688703301225944161.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/nested_spire.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/nested_spire.png&#34; data-width=&#34;1600&#34; data-height=&#34;765&#34; alt=&#34;image&#34; data-caption=&#34;嵌套 SPIRE&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;嵌套 SPIRE&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;嵌套 SPIRE 允许 SPIRE 服务器被“链接”在一起，所有服务器仍然发放属于同一信任域的身份，这意味着在同一信任域中识别的所有工作负载都会获得可以与信任域的根密钥进行验证的身份文档。&lt;/p&gt;
&lt;p&gt;嵌套拓扑通过在每个下游 SPIRE 服务器与“链接”的 SPIRE 代理共存来工作。下游 SPIRE 服务器通过 Workload API 获取凭据，然后使用这些凭据直接与上游 SPIRE 服务器进行身份验证以获取中间 CA。&lt;/p&gt;
&lt;p&gt;一个有助于理解嵌套拓扑功能的心理模型是将顶级 SPIRE 服务器想象成是一个全局服务器（或一组用于高可用性的服务器），而下游 SPIRE 服务器是区域或集群级别的服务器。&lt;/p&gt;
&lt;p&gt;在此配置中，顶层 SPIRE 服务器保存根证书/密钥，而下游服务器请求中间签名证书，用作下游服务器的 X.509 签名授权机构。这提供了弹性，因为顶层可能会崩溃，中间服务器将继续运行。&lt;/p&gt;
&lt;p&gt;嵌套拓扑非常适用于多云部署。由于能够混合匹配节点证明者，下游服务器可以驻留在不同云提供商环境中，为不同云提供商环境中的工作负载和代理提供身份。&lt;/p&gt;
&lt;p&gt;作为为了实现高可用性和负载平衡而将 SPIRE 服务器水平扩展的补充，嵌套拓扑可以用作分隔故障域的约束策略。&lt;/p&gt;
&lt;h3 id=&#34;联合-spire&#34;&gt;联合 SPIRE&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/federated_spire_hu13108857030248073349.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/federated_spire.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/federated_spire.png&#34; data-width=&#34;1600&#34; data-height=&#34;727&#34; alt=&#34;image&#34; data-caption=&#34;联合 SPIRE&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;联合 SPIRE&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;部署可能需要多个信任根：也许因为一个组织有不同的组织部门，各自有不同的管理员，或者因为它们有单独的临时和生产环境，需要偶尔进行通信。&lt;/p&gt;
&lt;p&gt;另一个用例是在组织之间实现 SPIFFE 互操作性，例如在云提供商和其客户之间。&lt;/p&gt;
&lt;p&gt;这些多信任域和互操作性用例都需要一种明确定义的、可互操作的方法，使一个信任域中的工作负载能够对另一个信任域中的工作负载进行身份验证。首先通过验证各自的束终点来建立不同信任域之间的信任，然后通过经过身份验证的端点检索外部信任域束。&lt;/p&gt;
&lt;p&gt;有关如何实现这一点的更多细节，请参阅以下 SPIFFE 规范，其中描述了这种机制：&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE_Trust_Domain_and_Bundle.md#5-spiffe-bundle-endpoint&#34; title=&#34;SPIFFE 信任域和 Bundle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 信任域和 Bundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关配置联合 SPIRE 的教程，请参阅：&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/tree/main/docker-compose/federation&#34; title=&#34;联合 SPIRE 教程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;联合 SPIRE 教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;与外部系统的交互&#34;&gt;与外部系统的交互&lt;/h2&gt;
&lt;h3 id=&#34;与-spiffe-兼容的系统联合&#34;&gt;与 SPIFFE 兼容的系统联合&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/spiffe_compatible_hu11350238083221882384.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/spiffe_compatible.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/spiffe_compatible.png&#34; data-width=&#34;1600&#34; data-height=&#34;765&#34; alt=&#34;image&#34; data-caption=&#34;与 SPIRE 兼容的系统联合&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;与 SPIRE 兼容的系统联合&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;SPIFFE 身份颁发者可以与其他暴露 SPIFFE 联合 API 实现的 SPIFFE 身份颁发者联合，使联合域中的工作负载能够安全地进行身份验证和通信。与在 SPIRE 部署之间建立联合一样，SPIFFE 联合用于在 SPIFFE 兼容系统之间启用联合，比如在一个 Istio 服务网格和另一个 Istio 服务网格之间运行的 Istio 服务网格。&lt;/p&gt;
&lt;p&gt;例如，在当前的 Istio 中，服务网格上的所有应用程序都位于同一个信任域中，因此共享一个共同的信任根。可能会有不止一个服务网格，或者在服务网格中通信到需要进行身份验证的外部服务。使用联合功能可以使得 SPIFFE 兼容的系统，比如多个 Istio 服务网格，能够为安全的跨网格和脱网通信建立信任。&lt;/p&gt;
&lt;h3 id=&#34;与-oidc-提供者系统的联合&#34;&gt;与 OIDC 提供者系统的联合&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/oidc_federation_hu4170596724668874989.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/oidc_federation.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/scaling-spire/oidc_federation.png&#34; data-width=&#34;1600&#34; data-height=&#34;765&#34; alt=&#34;image&#34; data-caption=&#34;与 OIDC 提供者系统联合&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;与 OIDC 提供者系统联合&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;SPIRE 具有一个特性，可以代表已识别的工作负载对远程系统进行编程身份验证，例如与支持 OIDC 联合的公共云提供商服务和密钥存储进行交互。例如，在亚马逊网络服务的情况下，一个经过 SPIRE 认证的工作负载可以对接 AWS S3 存储桶、AWS RDS 实例或 AWS CodePipeline 进行身份验证和通信。&lt;/p&gt;
&lt;p&gt;SPIRE OIDC 发现提供者使用 ACME 协议检索 WebPKI 证书，用于保护一个端点，该端点提供 OIDC 兼容的 JWKS 束和标准 OIDC 发现文档。然后需要配置远程 OIDC 认证服务以定位该端点并确定 WebPKI 服务。一旦完成此配置，可以设置远程系统的 IAM 策略和角色以映射到特定的 SPIFFE ID。工作负载随后将通过发送 JWT-SVID 与 OIDC 认证系统通信。然后，目标系统从预定义的 URI 获取 JWKS，该 URI 由 OIDC 发现提供者提供。目标系统使用 JWKS 文件验证 JWT-SVID，如果 JWT-SVID 中包含的 SPIFFE ID 被授权访问所请求的资源，则服务请求。然后，工作负载就能够访问外部远程服务，而无需拥有由其提供的任何凭据。&lt;/p&gt;
&lt;p&gt;有关 OIDC 发现提供者的配置参考，请参阅：&lt;a href=&#34;https://github.com/spiffe/spire/tree/main/support/oidc-discovery-provider&#34; title=&#34;OIDC 发现提供者配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OIDC 发现提供者配置参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关在 Amazon Web Services 配置 OIDC 联合的详细教程，请参阅：&lt;a href=&#34;https://spiffe.io/spire/try/oidc-federation-aws/&#34; title=&#34;配置 OIDC 到 Amazon Web Services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 OIDC 到 Amazon Web Services&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;部署规模考虑&#34;&gt;部署规模考虑&lt;/h2&gt;
&lt;p&gt;在为 SPIRE 部署调整大小以实现最佳性能时，需要考虑的因素包括但不限于以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SVID 和根证书的生存时间&lt;/li&gt;
&lt;li&gt;每个节点的工作负载数量和分布&lt;/li&gt;
&lt;li&gt;大量 JWT-SVID 的使用（因为 JWT 需要根据需要进行签名，而不像 x509 那样预先存储）&lt;/li&gt;
&lt;li&gt;注册更改的频率&lt;/li&gt;
&lt;li&gt;在 SPIRE 服务器节点上运行的其他进程&lt;/li&gt;
&lt;li&gt;基础架构环境的“形状”和“大小”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别要注意对数据存储的设计和规划。请注意，数据存储的性能在上述列表中没有得到解决，并且可能会限制 SPIRE 的性能。由于每个代理同步（每 5 秒一次）都会进行授权检查，因此数据存储通常是性能瓶颈。在嵌套拓扑中，由于嵌套拓扑中的每个 SPIRE 服务器集群都有自己的数据存储，因此可以降低此成本。&lt;/p&gt;
&lt;p&gt;下表旨在提供关于在 SPIRE 部署中调整 SPIRE 服务器大小的参考信息。这些参考数字基于测试环境。它们仅作为数量级指南，不代表任何特定用户环境的性能保证。网络带宽和数据库查询信息未包含在内。此外，所显示的工作负载和代理数量不代表在理论上可能的 SPIRE 部署规模。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;工作负载数量&lt;/th&gt;
          &lt;th&gt;10 代理&lt;/th&gt;
          &lt;th&gt;100 代理&lt;/th&gt;
          &lt;th&gt;1000 代理&lt;/th&gt;
          &lt;th&gt;5000 代理&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;10 工作负载&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，1 个 CPU 核心，1GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，2 个 CPU 核心，2GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，4 个 CPU 核心，4GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，8 个 CPU 核心，8GB RAM&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;100 工作负载&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，2 个 CPU 核心，2GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，2 个 CPU 核心，2GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，8 个 CPU 核心，8GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，16 个 CPU 核心，16GB RAM&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1000 工作负载&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，16 个 CPU 核心，8GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，16 个 CPU 核心，8GB RAM&lt;/td&gt;
          &lt;td&gt;2 个服务器单元，16 个 CPU 核心，8GB RAM&lt;/td&gt;
          &lt;td&gt;4 个服务器单元，16 个 CPU 核心，8GB RAM&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;10000 工作负载&lt;/td&gt;
          &lt;td&gt;每个 4 个服务器单元，16 个 CPU 核心，16GB RAM&lt;/td&gt;
          &lt;td&gt;每个 4 个服务器单元，16 个 CPU 核心，16GB RAM&lt;/td&gt;
          &lt;td&gt;每个 4 个服务器单元，16 个 CPU 核心，16GB RAM&lt;/td&gt;
          &lt;td&gt;每个 8 个服务器单元，16 个 CPU 核心，16GB RAM&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
                           
    <item>
      <title>配置 SPIRE</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/configuring/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/configuring/</guid>
      <description>
        
        
        &lt;p&gt;要根据你的应用程序需求自定义 SPIRE 服务器和 SPIRE 代理的行为，你需要编辑服务器和代理的配置文件。&lt;/p&gt;
&lt;h2 id=&#34;如何配置-spire&#34;&gt;如何配置 SPIRE&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器和代理的配置文件分别为 &lt;code&gt;server.conf&lt;/code&gt; 和 &lt;code&gt;agent.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，服务器期望配置文件位于 &lt;code&gt;conf/server/server.conf&lt;/code&gt;，但是服务器可以通过 &lt;code&gt;--config&lt;/code&gt; 标志配置为使用不同位置的配置文件。有关更多信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;同样，代理期望配置文件位于 &lt;code&gt;conf/agent/agent.conf&lt;/code&gt;，但是代理可以通过 &lt;code&gt;--config&lt;/code&gt; 标志配置为使用不同位置的配置文件。有关更多信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/&#34; title=&#34;SPIRE 代理参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;配置文件在启动服务器或代理时加载一次。如果更改了服务器或代理的配置文件，则必须重新启动服务器或代理以使配置生效。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中运行 SPIRE 时，通常将配置文件存储在 &lt;code&gt;ConfigMap&lt;/code&gt; 对象中，然后将其作为文件挂载到运行代理或服务器进程的容器中。&lt;/p&gt;
&lt;p&gt;SPIRE 代理支持使用 &lt;a href=&#34;https://github.com/hashicorp/hcl&#34; title=&#34;HCL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HCL&lt;/a&gt; 或 &lt;a href=&#34;http://www.json.org/&#34; title=&#34;JSON&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JSON&lt;/a&gt; 作为配置文件结构语法。下面的示例将假定使用 HCL。&lt;/p&gt;
&lt;h2 id=&#34;配置信任域&#34;&gt;配置信任域&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE 代理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;信任域对应于 SPIFFE 身份提供者的信任根。信任域可以表示运行其自己独立的 SPIFFE 基础设施的个人、组织、环境或部门。在同一信任域中标识的所有工作负载都将获得可以与信任域的根密钥进行验证的身份文件。&lt;/p&gt;
&lt;p&gt;每个 SPIRE 服务器关联一个必须在该组织内唯一的信任域。信任域采用与 DNS 名称相同的形式（例如，&lt;code&gt;prod.acme.com&lt;/code&gt;），但不需要与任何 DNS 基础设施对应。&lt;/p&gt;
&lt;p&gt;在首次启动服务器之前，需要在 SPIRE 服务器中配置信任域。通过在配置文件的 &lt;code&gt;server&lt;/code&gt; 部分的 &lt;code&gt;trust_domain&lt;/code&gt; 参数中配置。例如，如果服务器的信任域应配置为 &lt;code&gt;prod.acme.com&lt;/code&gt;，则应设置为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;trust_domain = &amp;#34;prod.acme.com&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，代理必须通过在代理配置文件的 &lt;code&gt;agent&lt;/code&gt; 部分的 &lt;code&gt;trust_domain&lt;/code&gt; 参数中配置来为相同的信任域颁发身份。&lt;/p&gt;
&lt;p&gt;SPIRE 服务器和代理只能为单个信任域&lt;em&gt;颁发&lt;/em&gt;身份，代理配置的信任域必须与其连接的服务器的信任域匹配。&lt;/p&gt;
&lt;h2 id=&#34;配置服务器监听代理的端口&#34;&gt;配置服务器监听代理的端口&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，SPIRE 服务器在端口 8081 上监听来自 SPIRE 代理的传入连接；要选择不同的值，请编辑 &lt;code&gt;server.conf&lt;/code&gt; 文件中的 &lt;code&gt;bind_port&lt;/code&gt; 参数。例如，要将监听端口更改为 9090：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bind_port = &amp;#34;9090&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果从服务器的默认配置更改了此配置，则还必须在代理上更改服务端口的配置。&lt;/p&gt;
&lt;h2 id=&#34;配置节点认证&#34;&gt;配置节点认证&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE 代理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIFFE 服务器通过节点认证和解析的过程来识别和验证代理。这是通过节点验证器和节点解析器插件来完成的，你需要在服务器中配置和启用它们。&lt;/p&gt;
&lt;p&gt;你选择的节点认证方法将确定你在 SPIRE 配置文件的服务器插件和代理插件部分中配置 SPIRE 使用哪些节点验证器插件。服务器上必须配置&lt;em&gt;至少一个&lt;/em&gt;节点验证器，每个代理上只能配置&lt;em&gt;一个&lt;/em&gt;节点验证器。&lt;/p&gt;
&lt;h3 id=&#34;对运行在-kubernetes-上的节点进行认证&#34;&gt;对运行在 Kubernetes 上的节点进行认证&lt;/h3&gt;
&lt;p&gt;为了向在 Kubernetes 集群中运行的工作负载发放身份，需要在每个运行负载的集群节点上部署一个 SPIRE 代理。（&lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/install-agents/#installing-spire-agents-on-kubernetes&#34; title=&#34;在 Kubernetes 上安装 SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Kubernetes 上安装 SPIRE 代理&lt;/a&gt;了解如何在 Kubernetes 上安装 SPIRE 代理）。&lt;/p&gt;
&lt;p&gt;可以使用 Kubernetes 的 &lt;a href=&#34;https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/&#34; title=&#34;Token Review API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Token Review API&lt;/a&gt; 对服务帐户令牌进行验证。因此，SPIRE 服务器本身不需要在 Kubernetes 上运行，并且单个 SPIRE 服务器可以支持在启用了 PSAT 认证的多个 Kubernetes 集群上运行的代理。&lt;/p&gt;
&lt;h4 id=&#34;projected-service-account-tokens&#34;&gt;Projected Service Account Tokens&lt;/h4&gt;
&lt;p&gt;在撰写本文时，预投影的服务帐户是 Kubernetes 的一个相对较新的功能，不是所有部署都支持它们。你的 Kubernetes 平台文档将告诉你是否支持此功能。如果你的 Kubernetes 部署不支持预投影的服务帐户令牌，则应启用服务帐户令牌。&lt;/p&gt;
&lt;p&gt;使用 Kubernetes 的 &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection&#34; title=&#34;Projected Service Account Tokens&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Projected Service Account Tokens&lt;/a&gt; (PSATs) 对节点进行认证允许 SPIRE 服务器验证在 Kubernetes 集群上运行的 SPIRE 代理的身份。预投影的服务帐户令牌相对于传统的 Kubernetes 服务帐户令牌提供了额外的安全保证，因此，如果 Kubernetes 集群支持，PSAT 是推荐的认证策略。&lt;/p&gt;
&lt;p&gt;要使用 PSAT 节点认证，请在 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_k8s_psat.md&#34; title=&#34;SPIRE Server&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Server&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_k8s_psat.md&#34; title=&#34;SPIRE Agent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Agent&lt;/a&gt; 上配置启用 PSAT 节点认证器插件。&lt;/p&gt;
&lt;h4 id=&#34;服务帐户令牌&#34;&gt;服务帐户令牌&lt;/h4&gt;
&lt;p&gt;在 Kubernetes 上运行工作负载时，如果集群上没有 Projected Service Account Token 功能，则 SPIRE 可以使用 Service Account Tokens 在 Server 和 Agent 之间建立信任。与使用 Projected Service Account Tokens 不同，此方法要求 SPIRE Server 和 SPIRE Agent 都部署在同一个 Kubernetes 集群上。&lt;/p&gt;
&lt;p&gt;由于服务帐户令牌不包含可用于强力识别运行 Agent 的节点/守护程序/Pod 的声明，因此任何在允许的服务帐户下运行的容器都可以冒充 Agent。因此，强烈建议在使用此认证方法时，Agent 应在专用的服务帐户下运行。&lt;/p&gt;
&lt;p&gt;要使用 SAT 节点认证，请在 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_k8s_sat.md&#34; title=&#34;SPIRE Server&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Server&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_k8s_sat.md&#34; title=&#34;SPIRE Agent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Agent&lt;/a&gt; 上配置和启用 SAT 节点认证器插件。&lt;/p&gt;
&lt;h3 id=&#34;对运行-linux-的节点进行认证&#34;&gt;对运行 Linux 的节点进行认证&lt;/h3&gt;
&lt;p&gt;SPIRE 能够对运行 Linux 的物理或虚拟机（节点）上的工作负载的身份进行认证。作为认证过程的一部分，SPIRE Server 需要建立与运行 Linux 节点上的 SPIRE Agent 的信任关系。根据节点运行的位置，SPIRE 支持各种节点认证器，这些节点认证器允许在创建注册项时使用不同的选择器来标识特定的工作负载。&lt;/p&gt;
&lt;h4 id=&#34;加入令牌join-token&#34;&gt;加入令牌（Join Token）&lt;/h4&gt;
&lt;p&gt;加入令牌是一种使用单次使用的令牌来对服务器进行认证的简单方法，该令牌在服务器上生成并在启动代理时提供给代理。它适用于在 Linux 上运行的任何节点。&lt;/p&gt;
&lt;p&gt;SPIRE 服务器可以通过在 &lt;code&gt;server.conf&lt;/code&gt; 配置文件中启用内置的&lt;code&gt;join-token&lt;/code&gt; NodeAttestor 插件来支持加入令牌认证，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NodeAttestor &amp;#34;join_token&amp;#34; {
    plugin_data {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置了加入令牌节点认证之后，可以使用&lt;code&gt;spire-server token generate&lt;/code&gt;命令在服务器上生成加入令牌。可以使用&lt;code&gt;-spiffeID&lt;/code&gt;标志将特定的 SPIFFE ID 与加入令牌关联起来。&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/#spire-server-token-generate&#34; title=&#34;在此处阅读更多&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在此处阅读更多&lt;/a&gt;有关使用此命令的更多信息。&lt;/p&gt;
&lt;p&gt;当第一次启动启用加入令牌证明的 SPIRE 代理时，可以使用 &lt;code&gt;spire-agent run&lt;/code&gt; 命令启动代理，并使用 &lt;code&gt;-joinToken&lt;/code&gt; 标志指定服务器生成的加入令牌。有关此命令的详细信息，请阅读&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/#spire-agent-run&#34; title=&#34;更多&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更多&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;服务器将验证加入令牌并向代理颁发 SVID（SPIFFE 身份验证信息文档）。只要代理与服务器保持连接，SVID 将自动轮换。在以后的启动中，除非 SVID 已过期且未续订，否则代理将使用该 SVID 对服务器进行身份验证。&lt;/p&gt;
&lt;p&gt;要使用加入令牌节点证明，请在 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_jointoken.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;和 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_jointoken.md&#34; title=&#34;SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理&lt;/a&gt;上配置和启用加入令牌节点证明插件。&lt;/p&gt;
&lt;p&gt;要在服务器上禁用加入令牌证明，请在启动之前从配置文件中注释或删除此部分。&lt;/p&gt;
&lt;h4 id=&#34;x509-证书&#34;&gt;X.509 证书&lt;/h4&gt;
&lt;p&gt;在许多情况下，特别是在手动配置节点的情况下（例如在数据中心），可以通过验证先前安装在节点上的现有 X.509 叶子证书来识别节点并唯一标识它。&lt;/p&gt;
&lt;p&gt;通常，这些叶子证书是从单个公共密钥和证书（在本指南中称为&lt;em&gt;根证书包&lt;/em&gt;）生成的。服务器必须配置根密钥和任何中间证书，以便能够验证特定机器呈现的叶子证书。只有找到可以通过证书链验证到服务器的证书时，节点证明才会成功，并且可以向该节点上的工作负载发布 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;此外，证明者公开了 &lt;code&gt;subject:cn &lt;/code&gt; 选择器，该选择器将匹配满足以下条件的证书：（a）有效，如上所述，（b）其通用名称（CN）与选择器中描述的通用名称匹配。&lt;/p&gt;
&lt;p&gt;要使用 X.509 证书节点证明，请在 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_x509pop.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;和 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_x509pop.md&#34; title=&#34;SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理&lt;/a&gt;上配置和启用 x509pop 节点证明插件。&lt;/p&gt;
&lt;h4 id=&#34;ssh-证书&#34;&gt;SSH 证书&lt;/h4&gt;
&lt;p&gt;在某些环境中，每个节点都会自动配备一个有效且唯一的 SSH 证书，用于标识该节点。SPIRE 可以使用此证书来引导其身份验证。&lt;/p&gt;
&lt;p&gt;通过这种方法进行验证的节点会自动获得形式为的 SPIFFE ID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://&amp;lt;trust-domain&amp;gt;/spire/agent/sshpop/&amp;lt;fingerprint&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;&amp;lt;fingerprint&amp;gt;&lt;/code&gt; 是证书本身的哈希值。然后，可以使用此 SPIFFE ID 作为其他工作负载注册条目的基础。&lt;/p&gt;
&lt;p&gt;要使用 SSH 证书节点验证，请在 SPIRE 服务器和 SPIRE 代理上配置并启用 sshpop 节点验证插件。&lt;/p&gt;
&lt;h3 id=&#34;云供应商上的-linux-节点验证&#34;&gt;云供应商上的 Linux 节点验证&lt;/h3&gt;
&lt;p&gt;许多云供应商提供特权 API，允许在由该供应商托管的特定节点上运行的进程能够证明其所在的节点。SPIRE 可以配置为利用这些 API 进行节点验证。这对于自动化来说特别方便，因为在新实例上首次启动代理时，代理可以自动向 SPIRE 服务器证明其身份，而无需为其发行预先存在的证书或加入令牌。&lt;/p&gt;
&lt;h4 id=&#34;google-compute-engine-实例&#34;&gt;Google Compute Engine 实例&lt;/h4&gt;
&lt;p&gt;Google Compute Engine（GCE）节点验证和解析允许 SPIRE 服务器自动识别和验证在 GCP GCE 实例上运行的 SPIRE 代理。简而言之，通过以下步骤完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPIRE 代理 gcp_iit 节点验证插件检索 GCP 实例的实例标识令牌，并向 SPIRE 服务器 gcp_iit 节点验证插件标识自身。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;use_instance_metadata&lt;/code&gt; 配置值设置为 &lt;code&gt;true&lt;/code&gt;，SPIRE 服务器 gcp_iit 节点验证插件调用 GCP API 验证令牌的有效性。&lt;/li&gt;
&lt;li&gt;验证完成后，SPIRE 代理被视为经过验证，并分配其自己的 SPIFFE ID。&lt;/li&gt;
&lt;li&gt;最后，如果工作负载与注册条目匹配，SPIRE 会向节点上的工作负载发放 SVID。注册条目可以包括节点验证插件或解析器公开的选择器，或者将 SPIRE 代理的 SPIFFE ID 作为父级。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要使用 GCP IIT 节点验证，请在 SPIRE 服务器和 SPIRE 代理上配置并启用 gcp_iit 节点验证插件。&lt;/p&gt;
&lt;h4 id=&#34;amazon-ec2-实例&#34;&gt;Amazon EC2 实例&lt;/h4&gt;
&lt;p&gt;EC2 节点认证和解析允许 SPIRE 服务器自动识别和验证在 AWS EC2 实例上运行的 SPIRE Agent。简而言之，通过以下方式实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPIRE Agent 的 aws_iid 节点证明插件检索 AWS 实例的实例身份文档，并向 SPIRE Server 的 aws_iid 节点证明插件进行身份验证。&lt;/li&gt;
&lt;li&gt;SPIRE Server 的 aws_iid 节点证明插件使用具有有限权限的 AWS IAM 角色调用 AWS API 来验证文档的有效性。&lt;/li&gt;
&lt;li&gt;如果配置了 aws_iid 节点解析器插件，则 SPIRE 将使用节点的已验证身份查找有关节点的其他信息。此元数据可以用作注册条目中的选择器。&lt;/li&gt;
&lt;li&gt;验证完成后，SPIRE Agent 被视为经过验证的，并被分配其自己的 SPIFFE ID。&lt;/li&gt;
&lt;li&gt;最后，如果工作负载与注册条目匹配，SPIRE 为节点上的工作负载发放 SVID。注册条目可以包含节点证明者或解析器提供的选择器，或者将 SPIRE Agent 的 SPIFFE ID 作为父级。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关配置 AWS EC2 节点证明者或解析器插件的更多信息，请参阅 SPIRE 服务器的相应 SPIRE 文档，其中包括 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_aws_iid.md&#34; title=&#34;SPIRE 服务器节点证明者&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器节点证明者&lt;/a&gt; 和 SPIRE 服务器节点解析器，以及代理上的 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_aws_iid.md&#34; title=&#34;SPIRE Agent 节点证明者&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Agent 节点证明者&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;azure-虚拟机&#34;&gt;Azure 虚拟机&lt;/h4&gt;
&lt;p&gt;Azure MSI 节点认证和解析允许 SPIRE 服务器自动识别和验证在 Azure VM 上运行的 SPIRE Agent。SPIRE 使用 MSI 令牌来验证代理。如果拦截，MSI 令牌必须进行范围限制以防止滥用。简而言之，通过以下方式实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPIRE Agent 的 azure_msi 节点证明插件检索 Azure VM 的 MSI 令牌，并向 SPIRE Server 的 azure_msi 节点证明插件进行身份验证。&lt;/li&gt;
&lt;li&gt;SPIRE Server 的 azure_msi 节点证明插件通过 API 调用从 Azure 检索 JSON Web Key Set (JWKS) 文档，并使用 JWKS 信息验证 MSI 令牌。&lt;/li&gt;
&lt;li&gt;SPIRE Server 的 azure_msi 节点解析器插件与 Azure 交互，获取有关代理 VM 的信息，例如订阅 ID、VM 名称、网络安全组、虚拟网络和虚拟网络子网，以构建有关代理 VM 的属性集，然后可以将其用作 Azure 节点集的节点选择器。&lt;/li&gt;
&lt;li&gt;一旦验证完成，SPIRE 代理将被视为已验证，并发放其自己的 SPIFFE ID。&lt;/li&gt;
&lt;li&gt;最后，如果工作负载与注册条目匹配，SPIRE 将向节点上的工作负载发放 SVID。注册条目可以包括节点验证器或解析器公开的选择器，或者将 SPIRE 代理的 SPIFFE ID 作为父级。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认情况下，代理插件分配的资源范围相对较大，它使用 Azure 资源管理器 (&lt;code&gt;https://management.azure.com&lt;/code&gt; 端点) 的资源 ID。出于安全考虑，考虑使用自定义资源 ID 来进行更精细的范围设置。&lt;/p&gt;
&lt;p&gt;如果在代理配置文件中配置自定义资源 ID，则必须在 &lt;code&gt;server.conf&lt;/code&gt; 配置文件的 &lt;code&gt;NodeAttestor&lt;/code&gt; 部分中为每个租户指定自定义资源 ID。&lt;/p&gt;
&lt;p&gt;有关配置 Azure MSI 节点验证器或解析器插件的更多信息，请参阅对应的 SPIRE 文档，包括 Azure MSI &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_azure_msi.md&#34; title=&#34;SPIRE Server 节点验证器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Server 节点验证器&lt;/a&gt;，SPIRE Server 节点解析器，以及代理上的 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_azure_msi.md&#34; title=&#34;SPIRE 代理节点验证器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理节点验证器&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;配置工作负载验证&#34;&gt;配置工作负载验证&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 代理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;与节点验证器关注的是 SPIRE Server 如何在特定物理或虚拟机上识别 SPIRE 代理不同，工作负载验证关注的是 SPIRE 代理如何识别特定进程。通常，两者结合使用以识别特定的工作负载。&lt;/p&gt;
&lt;p&gt;与节点验证类似，工作负载验证通过启用相关插件来完成。不同的插件提供了不同的选择器，可在注册条目中使用这些选择器来识别特定的工作负载。与节点验证不同，对于单个工作负载，工作负载验证可以使用多种策略。例如，对于给定的 Unix 组，可能要求单个工作负载运行，并从特定的 Docker 镜像启动。&lt;/p&gt;
&lt;h3 id=&#34;为由-kubernetes-调度的工作负载进行工作负载证明&#34;&gt;为由 Kubernetes 调度的工作负载进行工作负载证明&lt;/h3&gt;
&lt;p&gt;当工作负载在 Kubernetes 中运行时，能够用 Kubernetes 构造描述它们是非常有价值的，比如与工作负载运行的 Pod 相关联的命名空间、服务账户或标签。&lt;/p&gt;
&lt;p&gt;Kubernetes 工作负载证明插件通过与本地的 Kubelet 进行交互来检索有关特定进程的 Kubernetes 特定元数据，当它调用工作负载 API 时，使用这些元数据来识别与注册条目匹配的工作负载。&lt;/p&gt;
&lt;p&gt;有关更多信息，包括暴露的选择器的详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_k8s.md&#34; title=&#34;Kubernetes 工作负载证明插件的相应 SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 工作负载证明插件的相应 SPIRE 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;为-docker-容器进行工作负载证明&#34;&gt;为 Docker 容器进行工作负载证明&lt;/h3&gt;
&lt;p&gt;当工作负载在 Docker 容器中运行时，能够用该容器的属性来描述它们是很有帮助的，比如容器启动的 Docker 镜像或特定环境变量的值。&lt;/p&gt;
&lt;p&gt;Docker 工作负载证明插件通过与本地的 Docker 守护程序进行交互来检索有关特定进程的 Docker 特定元数据，当它调用工作负载 API 时。&lt;/p&gt;
&lt;p&gt;有关更多信息，包括暴露的选择器的详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_docker.md&#34; title=&#34;Docker 工作负载证明插件的相应 SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 工作负载证明插件的相应 SPIRE 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;为-unix-进程进行工作负载证明&#34;&gt;为 Unix 进程进行工作负载证明&lt;/h3&gt;
&lt;p&gt;当工作负载在 Unix 上运行时，能够用进程在 Unix 中的管理方式来描述它们是很有帮助的，比如它正在运行的 Unix 组的名称。&lt;/p&gt;
&lt;p&gt;Unix 工作负载证明通过检查 Unix 域套接字的调用者来确定调用 Workload API 的工作负载的内核元数据。&lt;/p&gt;
&lt;p&gt;有关更多信息，包括暴露的选择器的详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_unix.md&#34; title=&#34;Unix 工作负载证明插件的相应 SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unix 工作负载证明插件的相应 SPIRE 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;配置代理和服务器数据存储位置&#34;&gt;配置代理和服务器数据存储位置&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE 代理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;agent.conf&lt;/code&gt; 和 &lt;code&gt;server.conf&lt;/code&gt; 配置文件中的 &lt;code&gt;data_dir&lt;/code&gt; 选项设置了 SPIRE 运行时数据的目录。&lt;/p&gt;
&lt;p&gt;如果你为 &lt;code&gt;data_dir&lt;/code&gt; 指定了相对路径，即以 &lt;code&gt;./&lt;/code&gt; 开头的路径，则 &lt;code&gt;data_dir&lt;/code&gt; 将基于你执行 &lt;code&gt;spire-agent&lt;/code&gt; 或 &lt;code&gt;spire-server&lt;/code&gt; 命令时的当前工作目录进行评估。使用相对路径的 &lt;code&gt;data_dir&lt;/code&gt; 对于对 SPIRE 进行初始评估可能很有用，但对于生产部署，你可能希望将 &lt;code&gt;data_dir&lt;/code&gt; 设置为绝对路径。按照惯例，如果你已在 &lt;code&gt;/opt/spire&lt;/code&gt; 安装了 SPIRE，则将 &lt;code&gt;data_dir&lt;/code&gt; 指定为 &lt;code&gt;&amp;quot;/opt/spire/data&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;确保你为 &lt;code&gt;data_dir&lt;/code&gt; 指定的路径及其所有子目录对运行 SPIRE 代理或服务器可执行文件的 Linux 用户可读取。你可能需要使用 &lt;a href=&#34;http://man7.org/linux/man-pages/man1/chown.1.html&#34; title=&#34;chown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chown&lt;/a&gt; 来更改这些数据目录的所有权，以便其归属于将运行可执行文件的 Linux 用户。&lt;/p&gt;
&lt;p&gt;如果你为 &lt;code&gt;data_dir&lt;/code&gt; 指定的路径不存在，则 SPIRE 代理或服务器可执行文件将在具有执行权限的情况下创建该路径。&lt;/p&gt;
&lt;p&gt;通常，你应该将 &lt;code&gt;data_dir&lt;/code&gt; 的值用作在 &lt;code&gt;agent.conf&lt;/code&gt; 和 &lt;code&gt;server.conf&lt;/code&gt; 配置文件中配置的其他数据路径的基目录。例如，如果你在 &lt;code&gt;agent.conf&lt;/code&gt; 中将 &lt;code&gt;data_dir&lt;/code&gt; 设置为 &lt;code&gt;&amp;quot;/opt/spire/data&amp;quot;&lt;/code&gt;，则将 &lt;code&gt;KeyManager“disk”plugin_data directory&lt;/code&gt; 设置为 &lt;code&gt;&amp;quot;/opt/spire/data/agent&amp;quot;&lt;/code&gt;。或者，如果你在 &lt;code&gt;server.conf&lt;/code&gt; 中将 &lt;code&gt;data_dir&lt;/code&gt; 设置为 &lt;code&gt;/opt/spire/data&lt;/code&gt;，则将 &lt;code&gt;connection_string&lt;/code&gt; 设置为 &lt;code&gt;&amp;quot;/opt/spire/data/server/datastore.sqlite3&amp;quot;&lt;/code&gt;，如果你使用 SQLite 作为 SPIRE Server 数据存储，则如下所述。&lt;/p&gt;
&lt;h2 id=&#34;配置服务器数据存储方式&#34;&gt;配置服务器数据存储方式&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;数据存储是 SPIRE 服务器用于持久化动态配置的地方，例如从 SPIRE 服务器检索的注册条目和标识映射策略。默认情况下，SPIRE 使用 SQLite 捆绑并将其设置为默认的服务器数据存储方式。SPIRE 还支持其他兼容的数据存储。对于生产用途，你应该仔细考虑使用哪个数据库，特别是在将 SPIRE 部署在高可用配置时。&lt;/p&gt;
&lt;p&gt;可以通过配置默认的 SQL 数据存储插件来将 SPIRE 服务器配置为使用不同的 SQL 兼容存储后端，如下所述。有关如何配置此块的完整参考，请参阅&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_datastore_sql.md&#34; title=&#34;SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;将-sqlite-配置为-spire-数据存储&#34;&gt;将 SQLite 配置为 SPIRE 数据存储&lt;/h4&gt;
&lt;p&gt;默认情况下，SPIRE 服务器会创建并使用本地 SQLite 数据库来备份和存储配置数据。虽然对于测试来说很方便，但是在生产部署中通常不推荐使用，因为很难在多台机器上共享 SQLite 数据存储，这会使备份、HA 部署和升级变得复杂。&lt;/p&gt;
&lt;p&gt;要配置服务器使用 SQLite 数据库，请在配置文件中启用以下类似的部分：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    DataStore &amp;#34;sql&amp;#34; {
        plugin_data {
            database_type = &amp;#34;sqlite3&amp;#34;
            connection_string = &amp;#34;/opt/spire/data/server/datastore.sqlite3&amp;#34;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置文件中不应该有其他（取消注释的）&lt;code&gt;DataStore&lt;/code&gt; 部分。&lt;/p&gt;
&lt;p&gt;数据库将在 &lt;code&gt;connection_string&lt;/code&gt; 中指定的路径中创建。有关选择 SPIRE 相关数据位置的更多信息，请参见&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/configuring/#configuring-where-to-store-agent-and-server-data&#34; title=&#34;配置代理和服务器数据存储位置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置代理和服务器数据存储位置&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;将-mysql-配置为数据存储&#34;&gt;将 MySQL 配置为数据存储&lt;/h4&gt;
&lt;p&gt;在生产环境中，建议使用专用数据库来备份和存储配置数据。尽管安装和配置 MySQL 数据库不在本指南的范围内，但值得注意的是 SPIRE 服务器需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于 SPIRE 服务器配置的 MySQL 服务器上的专用数据库。&lt;/li&gt;
&lt;li&gt;具有能力连接到运行 SPIRE 服务器的任何 EC2 实例，并能向该数据库中的表、列和行插入和删除的 MySQL 用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要配置 SPIRE 服务器使用 MySQL 数据库，请在配置文件中启用以下类似的部分：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    DataStore &amp;#34;sql&amp;#34; {
        plugin_data {
            database_type = &amp;#34;mysql&amp;#34;
            connection_string = &amp;#34;username:password@tcp(localhost:3306)/dbname?parseTime=true&amp;#34;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上述连接字符串中，用以下内容替换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;username&lt;/code&gt;：要用于访问数据库的 MySQL 用户的用户名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt;：MySQL 用户的密码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;localhost:3306&lt;/code&gt;：MySQL 服务器的 IP 地址或主机名和端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dbname&lt;/code&gt;：数据库的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;将-postgres-配置为数据存储&#34;&gt;将 Postgres 配置为数据存储&lt;/h4&gt;
&lt;p&gt;在生产环境中，建议使用专用数据库来备份和存储配置数据。尽管安装和配置 Postgres 数据库不在本指南的范围内，但值得注意的是 SPIRE 服务器需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于 SPIRE 服务器配置的 Postgres 服务器上的专用数据库。&lt;/li&gt;
&lt;li&gt;具有能力连接到运行 SPIRE 服务器的任何实例，并能向该数据库中的表、列和行插入和删除的 Postgres 用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要配置 SPIRE 服务器使用 Postgres 数据库，请在服务器配置文件中启用以下部分：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    DataStore &amp;#34;sql&amp;#34; {
        plugin_data {
            database_type = &amp;#34;postgres&amp;#34;
            connection_string = &amp;#34;dbname=[database_name] user=[username]
                                 password=[password] host=[hostname] port=[port]&amp;#34;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;connection_string&lt;/code&gt; 的值采用键=值格式，但也可以使用连接 URI（参见 Postgres 文档中支持的连接字符串格式的 &lt;a href=&#34;https://www.postgresql.org/docs/11/libpq-connect.html#LIBPQ-CONNSTRING&#34; title=&#34;34.1.1. 连接字符串&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;34.1.1. 连接字符串&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;以下是你设置的连接字符串值的摘要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[database-name]：数据库的名称&lt;/li&gt;
&lt;li&gt;[username]：访问数据库的 Postgres 用户的用户名&lt;/li&gt;
&lt;li&gt;[password]：用户的密码&lt;/li&gt;
&lt;li&gt;[hostname]：Postgres 服务器的 IP 地址或主机名&lt;/li&gt;
&lt;li&gt;[port]：Postgres 服务器的端口号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配置代理和服务器上存储生成的密钥的方式&#34;&gt;配置代理和服务器上存储生成的密钥的方式&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE 代理&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理和 SPIRE 服务器在正常运行过程中会生成私钥和证书。保持这些密钥和证书的完整性非常重要，以确保维护所发行的 SPIFFE 身份的完整性。&lt;/p&gt;
&lt;p&gt;目前，SPIRE 在代理和服务器上支持两种密钥管理策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储于内存中。在此策略中，密钥和证书仅存储在内存中。这意味着，如果服务器或代理崩溃或重新启动，则必须重新生成密钥。对于 SPIRE 代理来说，这通常需要代理在重新启动时重新对服务器进行验证。通过启用和配置内存密钥管理器插件来管理此策略，可用于 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_keymanager_memory.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;和/或 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_keymanager_memory.md&#34; title=&#34;SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;存储在磁盘上。在此策略中，密钥和证书存储在指定的磁盘文件中。使用此方法的一个优点是它们在 SPIRE 服务器或代理重新启动后仍然存在。缺点是，由于密钥存储在磁盘文件中，必须采取其他预防措施，以防止恶意进程读取这些文件。通过启用和配置磁盘密钥管理器插件来管理此策略，可用于 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_keymanager_disk.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;和/或 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_keymanager_disk.md&#34; title=&#34;SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，SPIRE 可以配置为通过第三方密钥管理器插件集成自定义后端，例如秘密存储。&lt;a href=&#34;https://spiffe.io/docs/latest/spire/developing/extending/&#34; title=&#34;扩展 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;扩展 SPIRE&lt;/a&gt; 指南对此进行了更详细的介绍。&lt;/p&gt;
&lt;h2 id=&#34;配置应用程序将使用的信任根上游授权机构&#34;&gt;配置应用程序将使用的信任根/“上游授权机构”&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每个 SPIRE 服务器使用特定的根签名密钥，用于执行几个重要操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 SPIRE 代理对 SPIRE 服务器建立信任，因为代理持有由该密钥签名的证书（但请注意，服务器对代理的信任是通过验证建立的）。&lt;/li&gt;
&lt;li&gt;生成发放给工作负载的 X.509 或 JWT SVID。&lt;/li&gt;
&lt;li&gt;生成用于与其他 SPIRE 服务器建立信任的 SPIFFE 信任捆绑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应将此签名密钥视为非常敏感的，因为获取它将允许恶意行为者冒充 SPIRE 服务器并代表其发放身份。&lt;/p&gt;
&lt;p&gt;为了确保签名密钥的完整性，SPIRE 服务器可以自行对材料进行签名，使用存储在磁盘上的签名密钥，或委托签名给独立的证书颁发机构（CA），例如 AWS Secrets Manager。此行为通过 &lt;code&gt;server.conf&lt;/code&gt; 文件中的 &lt;code&gt;UpstreamAuthority&lt;/code&gt; 部分进行配置。&lt;/p&gt;
&lt;p&gt;有关完整的服务器配置参考，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;配置磁盘上的签名密钥&#34;&gt;配置磁盘上的签名密钥&lt;/h4&gt;
&lt;p&gt;SPIRE 服务器可以配置为从磁盘加载 CA 凭据，使用它们为服务器的签名机构生成中间签名证书。&lt;/p&gt;
&lt;p&gt;SPIRE 服务器附带了一个“虚拟”密钥和证书，可用于简化测试，但由于该密钥分发给所有 SPIRE 用户，因此不应将其用于除测试目的之外的任何用途。相反，应生成一个在磁盘上的签名密钥。&lt;/p&gt;
&lt;p&gt;如果已安装&lt;code&gt;openssl&lt;/code&gt;工具，则可以使用类似以下命令生成有效的根密钥和证书：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo openssl req &lt;span class=&#34;se&#34;&gt;\\\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       -subj &lt;span class=&#34;s2&#34;&gt;&amp;#34;/C=/ST=/L=/O=/CN=acme.com&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\\\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       -newkey rsa:2048 -nodes -keyout /opt/spire/conf/root.key &lt;span class=&#34;se&#34;&gt;\\\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       -x509 -days &lt;span class=&#34;m&#34;&gt;365&lt;/span&gt; -out /opt/spire/conf/root.crt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过启用和配置磁盘 &lt;code&gt;UpstreamAuthority&lt;/code&gt; 插件，可以管理此策略，用于 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_disk.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;配置-aws-证书管理器&#34;&gt;配置 AWS 证书管理器&lt;/h4&gt;
&lt;p&gt;可以配置 SPIRE 服务器从亚马逊网络服务的证书管理器（&lt;a href=&#34;https://aws.amazon.com/certificate-manager/private-certificate-authority/&#34; title=&#34;Private Certificate Authority&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Private Certificate Authority&lt;/a&gt;）加载 CA 凭据，并使用它们生成服务器签名授权的中间签名证书。&lt;/p&gt;
&lt;p&gt;可以通过启用和配置 &lt;code&gt;aws_pca&lt;/code&gt; UpstreamAuthority 插件来管理此策略，有关详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_aws_pca.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;配置另一个-spire-安装&#34;&gt;配置另一个 SPIRE 安装&lt;/h4&gt;
&lt;p&gt;可以配置 SPIRE 服务器从另一个 SPIFFE 实现（例如 SPIRE）的 Workload API 加载 CA 凭据。这使得可以使用一种称为“嵌套 SPIRE”的技术，作为 HA 部署的补充，允许独立的 SPIRE 服务器针对单个信任域发出标识。&lt;/p&gt;
&lt;p&gt;关于嵌套 SPIRE 的完整处理超出了本指南的范围。但是，可以通过启用和配置 &lt;code&gt;spire&lt;/code&gt; UpstreamAuthority 插件来管理此策略，有关详细信息，请参阅 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_spire.md&#34; title=&#34;SPIRE 服务器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;导出用于监控的指标&#34;&gt;导出用于监控的指标&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE Agent&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要将 SPIRE 服务器或 Agent 配置为将数据输出到指标收集器，请编辑 &lt;code&gt;server.conf&lt;/code&gt; 或 &lt;code&gt;agent.conf&lt;/code&gt; 中的遥测部分。SPIRE 可以将指标导出到 &lt;a href=&#34;https://docs.datadoghq.com/developers/dogstatsd/&#34; title=&#34;Datadog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datadog&lt;/a&gt; （DogStatsD 格式）、&lt;a href=&#34;https://github.com/m3db/m3&#34; title=&#34;M3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;M3&lt;/a&gt;、&lt;a href=&#34;https://prometheus.io/&#34; title=&#34;Prometheus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/statsd/statsd&#34; title=&#34;StatsD&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StatsD&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以同时配置多个收集器。在要将指标发送到多个收集器的情况下，DogStatsD、M3 和 StatsD 支持多个声明。&lt;/p&gt;
&lt;p&gt;如果要使用 Amazon CloudWatch 进行指标收集，请查阅 &lt;a href=&#34;https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Agent-custom-metrics-statsd.html&#34; title=&#34;此文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此文档&lt;/a&gt; 以了解使用 CloudWatch 代理程序和 StatsD 检索自定义指标的方法。&lt;/p&gt;
&lt;p&gt;以下是将遥测导出到 Datadog、M3、Prometheus 和 StatsD 并禁用内存收集器的 &lt;code&gt;agent.conf&lt;/code&gt; 或 &lt;code&gt;server.conf&lt;/code&gt; 的配置块示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;telemetry {
        Prometheus {
                port = 9988
        }

        DogStatsd = [
            { address = &amp;#34;localhost:8125&amp;#34; },
        ]

        Statsd = [
            { address = &amp;#34;localhost:1337&amp;#34; },
            { address = &amp;#34;collector.example.org:8125&amp;#34; },
        ]

        M3 = [
            { address = &amp;#34;localhost:9000&amp;#34; env = &amp;#34;prod&amp;#34; },
        ]

        InMem {
            enabled = false
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有关更多信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/telemetry_config/&#34; title=&#34;遥测配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;遥测配置&lt;/a&gt; 指南。&lt;/p&gt;
&lt;h2 id=&#34;日志记录&#34;&gt;日志记录&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;此配置适用于 SPIRE 服务器和 SPIRE Agent&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以在各自的配置文件中设置 SPIRE 服务器和 SPIRE Agent 的日志文件位置和日志级别。编辑 &lt;code&gt;log_file&lt;/code&gt; 值以设置日志文件位置，编辑 &lt;code&gt;log_level&lt;/code&gt; 值以设置日志级别。此值可以是 DEBUG、INFO、WARN 或 ERROR 中的一个。&lt;/p&gt;
&lt;p&gt;默认情况下，SPIRE 日志将输出到 STDOUT。但是，可以通过在 &lt;code&gt;log_file&lt;/code&gt; 属性中指定文件路径，将 SPIRE Agent 和 Server 配置为直接将日志写入文件。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>关于本书</title>
      <link>https://jimmysong.io/book/spiffe/preface/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/preface/</guid>
      <description>
        
        
        &lt;p&gt;本书介绍了服务身份的 SPIFFE 标准，以及 SPIFFE 的参考实现 SPIRE。这些项目为现代异构基础设施提供了一个统一的身份控制平面。这两个项目都是开源的，隶属于云原生计算基金会（CNCF）。&lt;/p&gt;
&lt;p&gt;随着企业发展他们的应用架构以充分利用新的基础设施技术，他们的安全模式也必须不断发展。软件已经从一个单片机上的单个应用发展到了几十甚至几百个紧密联系的微服务，这些微服务可能分布在公共云或私人数据中心的数千个虚拟机上。在这个新的基础设施世界里，SPIFFE 和 SPIRE 帮助保障系统的安全。&lt;/p&gt;
&lt;p&gt;本书努力提炼了 SPIFFE 和 SPIRE 的最重要的专家经验，以提供对身份问题的深刻理解，并协助你解决这些问题。通过这些项目，开发和运维可以利用新的基础设施技术构建软件，同时让安全团队摆脱昂贵和耗时的人工安全流程。&lt;/p&gt;
&lt;h2 id=&#34;关于零号乌龟&#34;&gt;关于零号乌龟&lt;/h2&gt;
&lt;p&gt;访问控制、秘密管理和身份是相互依赖的。大规模地管理秘密需要有效的访问控制；实施访问控制需要身份；证明身份需要拥有一个秘密。保护一个秘密需要想出一些办法来保护另一个秘密，这就需要保护那个秘密，以此类推。&lt;/p&gt;
&lt;p&gt;这让人想起一个著名的轶事：一个女人打断了一位哲学家的讲座，告诉他世界是在乌龟的背上。当哲学家问她乌龟靠的是什么时，她说：&amp;ldquo;还是乌龟！&amp;quot;。找到底层的乌龟，即所有其他安全所依赖的坚实基础，是 SPIFFE 和 SPIRE 项目的目标。&lt;/p&gt;
&lt;p&gt;本书封面上的 &amp;ldquo;零号乌龟&amp;rdquo; 就是这只底层乌龟。零代表了数据中心和云计算的安全基础。零号是值得信赖的，愉快地支持所有其他的乌龟。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 是帮助你为你的组织找到底层乌龟的项目。通过这本书中的工具，我们希望你也能为 &amp;ldquo;底层乌龟&amp;rdquo; 找到一个家。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>声明</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/preface/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/preface/</guid>
      <description>
        
        
        &lt;p&gt;以下是关于本书的声明。&lt;/p&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;本出版物由 NIST 根据 2014 年《联邦信息安全现代化法案》（FISMA）（44 U.S.C. §3551 etseq）规定的法定职责编写，公共法律（P.L.）113-283。NIST 负责制定信息安全标准和准则，包括联邦信息系统的最低要求，但这些标准和准则在未经对国家安全系统行使策略权力的适当联邦官员明确批准的情况下，不得适用于这些系统。本准则与管理和预算办公室（OMB）A-130 号通知的要求一致。&lt;/p&gt;
&lt;p&gt;本出版物中的任何内容都不应被视为与商务部长根据法定授权对联邦机构的强制性和约束性标准和准则相抵触。这些准则也不应被解释为改变或取代商务部长、OMB 主任或任何其他联邦官员的现有权力。本出版物可由非政府组织在自愿的基础上使用，在美国不受版权限制。但是，请注明出处，NIST 将对此表示感谢。&lt;/p&gt;
&lt;p&gt;国家标准和技术研究所特别出版物 800-204C Natl.Inst.
Stand.Technol.Spec.800-204C, 45 pages (March 2022) CODEN: NSPUE2&lt;/p&gt;
&lt;p&gt;本出版物可从以下网站免费获取。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://doi.org/10.6028/NIST.SP.800-204C&#34; title=&#34;https://doi.org/10.6028/NIST.SP.800-204C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.6028/NIST.SP.800-204C&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于计算机系统技术的报告&#34;&gt;关于计算机系统技术的报告&lt;/h2&gt;
&lt;p&gt;美国国家标准与技术研究所（NIST）的信息技术实验室（ITL）通过为国家的测量和标准基础设施提供技术领导来促进美国经济和公共福利。ITL 开发测试、测试方法、参考数据、概念实施证明和技术分析，以推动信息技术的发展和生产性使用。ITL 的职责包括为联邦信息系统中与国家安全无关的信息制定管理、行政、技术和物理标准和准则，以实现低成本的安全和隐私。&lt;/p&gt;
&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;云原生应用已经发展成为一个标准化的架构，由多个松散耦合的组件组成，这些组件被称为微服务（通常通常以容器实现），由提供应用服务的基础设施（如服务网格）支持。这两个组件通常都被托管在一个容器调度和资源管理平台上。在这个架构中，应用环境中涉及的整套源代码可以分为五种类型：1）应用代码（体现应用逻辑）；2）应用服务代码（用于会话建立、网络连接等服务）；3）基础设施即代码（用于配置计算、网络和存储资源）；4）策略即代码（用于定义运行时策略，如以声明性代码表达的零信任）；5）可观测性即代码（用于持续监测应用运行时状态）。由于安全、商业竞争力和松散耦合的应用组件的固有结构，这类应用需要一个不同的开发、部署和运行时范式。DevSecOps（分别由开发、安全和运维的首字母缩写组成）已经被发现是这些应用的促进范式，其基本要素包括持续集成、持续交付和持续部署（CI/CD）管道。这些管道是将开发者的源代码通过各个阶段的工作流程，如构建、测试、打包、部署和运维，由带有反馈机制的自动化工具支持。本文的目的是为云原生应用的 DevSecOps 原语的实施提供指导，其架构和代码类型如上所述。本文还讨论了这种方法对高安全保障和实现持续运维授权（C-ATO）的好处。&lt;/p&gt;
&lt;h2 id=&#34;鸣谢&#34;&gt;鸣谢&lt;/h2&gt;
&lt;p&gt;作者首先要感谢 NIST 的 David Ferraiolo，他发起了这项工作，为基于微服务的应用中服务网格的开发、部署和监控提供了有针对性的 DevSecOps 原语实施指导。衷心感谢美国空军 CSO Nicolas Chaillan 先生，感谢他详细而有见地的审查和反馈。还要感谢 Tetrate 公司的 Zack Butcher 为本文标题提供的建议。作者还对 NIST 的 Isabel Van
Wyk 的详细编辑审查表示感谢。&lt;/p&gt;
&lt;h2 id=&#34;专利披露通知&#34;&gt;专利披露通知&lt;/h2&gt;
&lt;p&gt;通知：信息技术实验室（ITL）已要求专利权持有人向 ITL 披露其使用可能需要遵守本出版物的指导或要求的专利权。然而，专利持有人没有义务回应 ITL 的专利要求，ITL 也没有进行专利搜索，以确定哪些专利可能适用于本出版物。&lt;/p&gt;
&lt;p&gt;截至本出版物发布之日，以及在呼吁确定可能需要使用其来遵守本出版物的指导或要求的专利权利要求之后，ITL 没有发现任何此类专利权利要求。&lt;/p&gt;
&lt;p&gt;ITL 没有作出或暗示在使用本出版物时不需要许可证以避免专利侵权。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>通知和历史</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/notices-and-hitory/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/notices-and-hitory/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;文件变更历史&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;英文版&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;版本&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2021 年 8 月&lt;/td&gt;
          &lt;td&gt;1.0&lt;/td&gt;
          &lt;td&gt;首次发布&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;中文版&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;日期&lt;/th&gt;
          &lt;th&gt;版本&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2021 年 8 月 8 日&lt;/td&gt;
          &lt;td&gt;1.0&lt;/td&gt;
          &lt;td&gt;首次发布&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;担保和认可的免责声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文件中的信息和意见是 &amp;ldquo;按原样&amp;rdquo; 提供的，没有任何保证或担保。本文件以商品名称、商标、制造商或其他方式提及任何具体的商业产品、程序或服务，并不一定构成或暗示美国政府对其的认可、推荐或青睐，而且本指南不得用于广告或产品代言的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于中文版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中文版为 &lt;a href=&#34;https://jimmysong.io&#34; title=&#34;Jimmy Song&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt; 个人翻译，翻译过程中完全遵照原版，未做任何删减。其本人与本书的原作者没有任何组织或利益上的联系，翻译本书仅为交流学习之用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商标认可&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 是 Linux 基金会的注册商标。&lt;/li&gt;
&lt;li&gt;SELinux 是美国国家安全局的注册商标。&lt;/li&gt;
&lt;li&gt;AppArmor 是 SUSE LLC 的注册商标。&lt;/li&gt;
&lt;li&gt;Windows 和 Hyper-V 是微软公司的注册商标。&lt;/li&gt;
&lt;li&gt;ETCD 是 CoreOS, Inc. 的注册商标。&lt;/li&gt;
&lt;li&gt;Syslog-ng 是 One Identity Software International Designated Activity 公司的注册商标。&lt;/li&gt;
&lt;li&gt;Prometheus 是 Linux 基金会的注册商标。&lt;/li&gt;
&lt;li&gt;Grafana 是 Raintank, Inc.dba Grafana Labs 的注册商标。&lt;/li&gt;
&lt;li&gt;Elasticsearch 和 ELK Stack 是 Elasticsearch B.V 的注册商标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;版权确认&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文件中的信息、例子和数字基于 Kubernetes 作者的 &lt;a href=&#34;https://kubernetes.io/docs/&#34; title=&#34;Kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; &lt;a href=&#34;https://kubernetes.io/docs/&#34; title=&#34;文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;，以&lt;a href=&#34;https://git.k8s.io/website/LICENSE&#34; title=&#34;知识共享&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;知识共享&lt;/a&gt;&lt;a href=&#34;https://git.k8s.io/website/LICENSE&#34; title=&#34;署名 4.0 许可方式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;署名 4.0 许可方式&lt;/a&gt;发布。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>使用 Envoy 和 X.509-SVID</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/</guid>
      <description>
        
        
        &lt;p&gt;本教程在 &lt;a href=&#34;https://spiffe.io/docs/latest/try/getting-started-k8s/&#34; title=&#34;Kubernetes 快速入门教程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 快速入门教程&lt;/a&gt;的基础上，演示了如何配置 SPIRE 以提供动态的 X.509 证书形式的服务身份，并由 Envoy 秘密发现服务（SDS）使用。本教程中展示了实现 X.509 SVID 身份验证所需的更改，因此你应该首先运行或至少阅读 Kubernetes 快速入门教程。&lt;/p&gt;
&lt;p&gt;为了演示 X.509 身份验证，我们创建了一个简单的场景，包含三个服务。其中一个服务是后端服务，是一个简单的 nginx 实例，用于提供静态数据。我们另外运行两个 &lt;code&gt;Symbank&lt;/code&gt; 演示银行应用作为前端服务。&lt;code&gt;Symbank&lt;/code&gt; 前端服务向 nginx 后端发送 HTTP 请求以获取用户账户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/SPIRE_Envoy_diagram_hu15859225034109772374.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/SPIRE_Envoy_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-x509/SPIRE_Envoy_diagram.png&#34; data-width=&#34;1200&#34; data-height=&#34;460&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;如图所示，前端服务通过 Envoy 实例建立的 mTLS 连接与后端服务连接，并且 Envoy 实例会为每个工作负载执行 X.509 SVID 身份验证。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学习如何：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置 SPIRE 以支持 SDS&lt;/li&gt;
&lt;li&gt;配置 Envoy SDS 以使用 SPIRE 提供的 X.509 证书&lt;/li&gt;
&lt;li&gt;在 SPIRE 服务器上为 Envoy 实例创建注册条目&lt;/li&gt;
&lt;li&gt;使用 SPIRE 测试成功的 X.509 身份验证&lt;/li&gt;
&lt;li&gt;可选地配置 Envoy RBAC HTTP 过滤器策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;在继续之前，请先阅读以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你需要访问通过 &lt;a href=&#34;https://spiffe.io/docs/latest/try/getting-started-k8s/&#34; title=&#34;Kubernetes 快速入门教程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 快速入门教程&lt;/a&gt;配置的 Kubernetes 环境。可选地，你可以使用下面描述的 &lt;code&gt;pre-set-env.sh&lt;/code&gt; 脚本创建 Kubernetes 环境。Kubernetes 环境必须能够将 Ingress 公开到公共互联网上。&lt;strong&gt;注意：对于本地 Kubernetes 环境（例如 Minikube），通常不适用此条件&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;本教程所需的 YAML 文件可在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;k8s/envoy-x509&lt;/code&gt; 目录中找到。如果你尚未克隆 &lt;em&gt;Kubernetes 快速入门教程&lt;/em&gt;的存储库，请现在进行克隆。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;em&gt;Kubernetes 快速入门教程&lt;/em&gt;环境不可用，你可以使用以下脚本创建该环境，并将其用作本教程的起点。从&lt;code&gt;k8s/envoy-x509&lt;/code&gt;目录中运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/pre-set-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该脚本将创建所需的 SPIRE 服务器和 SPIRE 代理资源。&lt;/p&gt;
&lt;h3 id=&#34;外部-ip-支持&#34;&gt;外部 IP 支持&lt;/h3&gt;
&lt;p&gt;本教程需要一个可以分配外部 IP 的负载均衡器（例如&lt;a href=&#34;https://metallb.universe.tf/&#34; title=&#34;metallb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metallb&lt;/a&gt;）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待 metallb 启动&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; --namespace metallb-system &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --for&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ready pod &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;metallb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --timeout&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;90s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 metallb 配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f metallb-config.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;envoy-sds-支持&#34;&gt;Envoy SDS 支持&lt;/h2&gt;
&lt;p&gt;SPIRE 代理原生支持 Envoy Secret Discovery Service（SDS）。SDS 通过与工作负载 API 和连接到 SDS 的 Envoy 进程使用相同的 Unix 域套接字提供服务，并对工作负载进行验证。&lt;/p&gt;
&lt;h2 id=&#34;第-1-部分运行工作负载&#34;&gt;第 1 部分：运行工作负载&lt;/h2&gt;
&lt;p&gt;现在，让我们部署本教程中将使用的工作负载。它由三个工作负载组成：如前所述，两个 &lt;em&gt;Symbank&lt;/em&gt; 演示应用程序的实例将充当前端服务，另一个提供静态文件的 nginx 实例将充当后端服务。&lt;/p&gt;
&lt;p&gt;为了区分两个 &lt;em&gt;Symbank&lt;/em&gt; 应用程序的实例，让我们将其称为 &lt;em&gt;frontend&lt;/em&gt; 和 &lt;em&gt;frontend-2&lt;/em&gt;。前者配置为显示与用户 &lt;em&gt;Jacob Marley&lt;/em&gt; 相关的数据，而后者将显示用户 &lt;em&gt;Alex Fergus&lt;/em&gt; 的帐户详细信息。&lt;/p&gt;
&lt;h2 id=&#34;部署所有工作负载&#34;&gt;部署所有工作负载&lt;/h2&gt;
&lt;p&gt;确保当前的工作目录是 &lt;code&gt;.../spire-tutorials/k8s/envoy-x509&lt;/code&gt;，然后使用以下命令部署新的资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -k k8s/.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-balance-json-data created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-envoy created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-profile-json-data created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-transactions-json-data created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/frontend-2-envoy created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/frontend-envoy created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/symbank-webapp-2-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/symbank-webapp-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/backend-envoy created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/frontend-2 created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/frontend created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/backend created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/frontend-2 created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/frontend created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;kubectl apply&lt;/code&gt; 命令将创建以下资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个工作负载的部署。它包含一个用于我们的服务和 Envoy Sidecar 的容器。&lt;/li&gt;
&lt;li&gt;每个工作负载的服务。用于它们之间的通信。&lt;/li&gt;
&lt;li&gt;多个 Configmap：
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;json-data&lt;/em&gt; 用于向作为后端服务运行的 Nginx 实例提供静态文件。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;envoy&lt;/em&gt; 包含每个工作负载的 Envoy 配置。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;symbank-webapp-&lt;/em&gt; 包含供每个前端服务实例使用的配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的两个部分将重点介绍配置 Envoy 所需的设置。&lt;/p&gt;
&lt;h4 id=&#34;spire-agent-集群&#34;&gt;SPIRE Agent 集群&lt;/h4&gt;
&lt;p&gt;为了让 Envoy SDS 使用 SPIRE Agent 提供的 X.509 证书，我们配置一个集群，指向 SPIRE Agent 提供的 Unix 域套接字。后端服务的 Envoy 配置位于 &lt;code&gt;k8s/backend/config/envoy.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;25s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http2_protocol_options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;load_assignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lb_endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/run/spire/sockets/agent.sock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;tls-证书&#34;&gt;TLS 证书&lt;/h4&gt;
&lt;p&gt;要从 SPIRE 获取 TLS 证书和私钥，你需要在 TLS 上下文中设置一个 SDS 配置。TLS 证书的名称是 Envoy 充当代理的服务的 SPIFFE ID。此外，SPIRE 为每个信任域提供一个验证上下文，Envoy 使用它来验证对等证书。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;transport_socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.transport_sockets.tls&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;common_tls_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls_certificate_sds_secret_configs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/ns/default/sa/default/backend&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resource_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_config_source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GRPC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transport_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;combined_validation_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# validate the SPIFFE ID of incoming clients (optionally)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;default_validation_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;match_typed_subject_alt_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;san_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;URI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;san_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;URI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/ns/default/sa/default/frontend-2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# obtain the trust bundle from SDS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;validation_context_sds_secret_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resource_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_config_source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GRPC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transport_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire_agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类似的配置也适用于前端服务，以建立一个 mTLS 通信。检查名为 &lt;code&gt;backend&lt;/code&gt; 的集群在 &lt;code&gt;k8s/frontend/config/envoy.yaml&lt;/code&gt; 和 &lt;code&gt;k8s/frontend-2/config/envoy.yaml&lt;/code&gt; 中的配置。&lt;/p&gt;
&lt;h3 id=&#34;创建注册条目&#34;&gt;创建注册条目&lt;/h3&gt;
&lt;p&gt;为了获得 SPIRE 颁发的 X.509 证书，必须先注册服务。我们通过在 SPIRE Server 上为每个工作负载创建注册条目来实现这一点。让我们使用以下 Bash 脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash create-registration-entries.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行脚本后，将显示所创建的注册条目列表。输出将显示 &lt;a href=&#34;https://spiffe.io/docs/latest/try/getting-started-k8s/&#34; title=&#34;Kubernetes Quickstart Tutorial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Quickstart Tutorial&lt;/a&gt; 创建的其他注册条目。这里重要的是每个工作负载的三个新条目：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;...
Entry ID      : 0d02d63f-712e-47ad-a06e-853c8b062835
SPIFFE ID     : spiffe://example.org/ns/default/sa/default/backend
Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
TTL           : 3600
Selector      : k8s:container-name:envoy
Selector      : k8s:ns:default
Selector      : k8s:pod-label:app:backend
Selector      : k8s:sa:default

Entry ID      : 3858ec9b-f924-4f69-b812-5134aa33eaee
SPIFFE ID     : spiffe://example.org/ns/default/sa/default/frontend
Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
TTL           : 3600
Selector      : k8s:container-name:envoy
Selector      : k8s:ns:default
Selector      : k8s:pod-label:app:frontend
Selector      : k8s:sa:default

Entry ID      : 4e37f863-302a-4b3c-a942-dc2a86459f37
SPIFFE ID     : spiffe://example.org/ns/default/sa/default/frontend-2
Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
TTL           : 3600
Selector      : k8s:container-name:envoy
Selector      : k8s:ns:default
Selector      : k8s:pod-label:app:frontend-2
Selector      : k8s:sa:default
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，我们工作负载的选择器指向了 Envoy 容器：k8s:container-name:envoy。这是我们配置 Envoy 代表工作负载执行 X.509 SVID 身份验证的方式。&lt;/p&gt;
&lt;h2 id=&#34;第二部分测试连接&#34;&gt;第二部分：测试连接&lt;/h2&gt;
&lt;p&gt;现在，服务已经部署并在 SPIRE 中注册，让我们测试我们配置的授权。&lt;/p&gt;
&lt;h3 id=&#34;使用有效的-x509-svid-进行身份验证的测试&#34;&gt;使用有效的 X.509 SVID 进行身份验证的测试&lt;/h3&gt;
&lt;p&gt;第一组测试将演示如何使用有效的 X.509 SVID 显示相关数据。为此，我们将展示前端服务 (&lt;code&gt;frontend&lt;/code&gt;和&lt;code&gt;frontend-2&lt;/code&gt;) 如何通过获取每个服务的正确 IP 地址和端口与&lt;code&gt;backend&lt;/code&gt;服务进行通信。要运行这些测试，我们需要找到用于访问数据的 URL 所组成的 IP 地址和端口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get services
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME            TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backend-envoy   ClusterIP      None          &amp;lt;none&amp;gt;           9001/TCP         6m53s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend        LoadBalancer   10.8.14.117   35.222.164.221   3000:32586/TCP   6m52s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend-2      LoadBalancer   10.8.7.57     35.222.190.182   3002:32056/TCP   6m53s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes      ClusterIP      10.8.0.1      &amp;lt;none&amp;gt;           443/TCP          59m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;frontend&lt;/code&gt; 服务将在 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 值和端口 &lt;code&gt;3000&lt;/code&gt; 处可用，这是我们容器配置的端口。在上面显示的示例输出中，导航的 URL 为 &lt;code&gt;http://35.222.164.221:3000&lt;/code&gt;。打开浏览器并导航到环境中显示的 &lt;code&gt;frontend&lt;/code&gt; 的 IP 地址，添加端口 &lt;code&gt;:3000&lt;/code&gt;。页面加载完成后，你将看到用户 &lt;em&gt;Jacob Marley&lt;/em&gt; 的账户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend_view_hu9562568468112413087.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend_view.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-x509/frontend_view.png&#34; data-width=&#34;1828&#34; data-height=&#34;735&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;按照相同的步骤，当你连接到 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 URL 时（例如 &lt;code&gt;http://35.222.190.182:3002&lt;/code&gt;），浏览器将显示用户 &lt;em&gt;Alex Fergus&lt;/em&gt; 的账户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view_hu12693506516063659642.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view.png&#34; data-width=&#34;1819&#34; data-height=&#34;734&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;更新-tls-配置以便只有一个前端可以访问后端&#34;&gt;更新 TLS 配置以便只有一个前端可以访问后端&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;backend&lt;/code&gt; 服务的 Envoy 配置使用 TLS 配置来通过验证 TLS 连接上呈现的证书的主题备用名称 (SAN) 来过滤传入的连接。对于 SVIDs，证书的 SAN 字段设置为与服务关联的 SPIFFE ID。因此，通过在 &lt;code&gt;combined_validation_context&lt;/code&gt; 部分的 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-x509/k8s/backend/config/envoy.yaml#L49&#34; title=&#34;Envoy 配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 配置&lt;/a&gt;中删除 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 SPIFFE ID，可以使&lt;code&gt;backend&lt;/code&gt;服务的 Envoy 配置允许仅来自 &lt;code&gt;frontend&lt;/code&gt;服务的请求。更新后的配置如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;combined_validation_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# validate the SPIFFE ID of incoming clients (optionally)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;default_validation_context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;match_typed_subject_alt_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;san_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;URI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;应用-envoy-的新配置&#34;&gt;应用 Envoy 的新配置&lt;/h3&gt;
&lt;p&gt;使用文件&lt;code&gt;backend-envoy-configmap-update.yaml&lt;/code&gt;更新&lt;code&gt;backend&lt;/code&gt;工作负载的 Envoy 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f backend-envoy-configmap-update.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，需要重新启动&lt;code&gt;backend&lt;/code&gt; Pod 以应用新配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在尝试再次在浏览器中查看&lt;code&gt;frontend-2&lt;/code&gt;服务之前，请等待几秒钟以使部署生效。一旦 Pod 准备就绪，请使用 &lt;code&gt;frontend-2&lt;/code&gt; 服务的正确 URL（例如 &lt;code&gt;http://35.222.190.182:3002&lt;/code&gt;）刷新浏览器。结果，现在 Envoy 不允许请求到达 &lt;code&gt;backend&lt;/code&gt; 服务，并且浏览器中不显示账户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view_no_details_hu16474765239360597105.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view_no_details.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-x509/frontend-2_view_no_details.png&#34; data-width=&#34;1809&#34; data-height=&#34;750&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;另一方面，你可以检查&lt;code&gt;frontend&lt;/code&gt;服务仍然能够从 &lt;code&gt;backend&lt;/code&gt; 获得响应。刷新浏览器以正确的 URL（例如 &lt;code&gt;http://35.222.164.221:3000&lt;/code&gt;），并确认对&lt;em&gt;Jacob Marley&lt;/em&gt;的账户显示账户详细信息。&lt;/p&gt;
&lt;h2 id=&#34;通过基于角色的访问控制过滤器扩展场景&#34;&gt;通过基于角色的访问控制过滤器扩展场景&lt;/h2&gt;
&lt;p&gt;Envoy 提供了一种基于角色的访问控制（RBAC）HTTP 过滤器，它根据一组策略检查请求。策略由权限和主体组成，其中主体指的是请求的下游客户端身份，例如下游客户端证书的 URI SAN。因此，我们可以使用为服务分配的 SPIFFE ID 创建策略，以实现更细粒度的访问控制。&lt;/p&gt;
&lt;p&gt;“Symbank”演示应用程序使用三个不同的端点来获取有关银行账户的所有信息。&lt;code&gt;/profiles&lt;/code&gt; 端点提供账户所有者的姓名和地址。另外两个端点，&lt;code&gt;/balances&lt;/code&gt; 和 &lt;code&gt;/transactions&lt;/code&gt;，提供账户的余额和交易信息。&lt;/p&gt;
&lt;p&gt;为了演示 Envoy 的 RBAC 过滤器，我们可以创建一个策略，允许“frontend”服务仅获取 &lt;code&gt;/profiles&lt;/code&gt; 端点的数据，并拒绝发送到其他端点的请求。这可以通过定义一个主体与服务的 SPIFFE ID 匹配以及只允许对 &lt;code&gt;/profiles&lt;/code&gt; 资源进行 GET 请求的权限来实现。&lt;/p&gt;
&lt;p&gt;可以将以下代码片段添加到&lt;code&gt;backend&lt;/code&gt;服务的 Envoy 配置中作为新的 HTTP 过滤器来测试该策略。&lt;em&gt;注意：为了使 Envoy 配置正常工作，必须在现有的  &lt;code&gt;envoy.router&lt;/code&gt;  过滤器之前添加此代码片段&lt;/em&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.http.rbac&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.http.rbac.v3.RBAC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ALLOW&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;policies&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;general-rules&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;permissions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;and_rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;:method&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;, exact_match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;url_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/profiles&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;principals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;authenticated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;principal_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该示例演示了如何在已由 SPIRE 获得其身份的 Envoy 实例建立了 TLS 连接时，根据请求参数执行更精细的访问控制。&lt;/p&gt;
&lt;h2 id=&#34;清理&#34;&gt;清理&lt;/h2&gt;
&lt;p&gt;完成本教程后，你可以使用以下脚本删除用于配置 Envoy 以代表工作负载执行 X.509 身份验证的所有资源。此命令将删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于 SPIRE - Envoy X.509 集成教程的所有资源。&lt;/li&gt;
&lt;li&gt;SPIRE 代理、SPIRE 服务器和命名空间的所有部署和配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/clean-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>SPIRE 基本概念</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/concept/spire/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/concept/spire/</guid>
      <description>
        
        
        &lt;p&gt;SPIRE 是 &lt;a href=&#34;../spiffe&#34; title=&#34;SPIFFE API&#34;&gt;SPIFFE API&lt;/a&gt; 的一个生产就绪的实现，它执行节点和工作负载认证，以便根据一组预先定义的条件，安全地向工作负载发出 SVID，并验证其他工作负载的 SVID。&lt;/p&gt;
&lt;h2 id=&#34;spire-架构和组件&#34;&gt;SPIRE 架构和组件&lt;/h2&gt;
&lt;p&gt;SPIRE 部署由一个 SPIRE 服务器和一个或多个 SPIRE 代理组成。服务器充当通过代理向一组工作负载发放身份的签名机构。它还维护一个工作负载身份的注册表，以及为签发这些身份而必须验证的条件。代理在本地向工作负载公开 SPIFFE 工作负载 API，必须安装在工作负载运行的每个节点上。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/spire-arch.svg&#34; data-img=&#34;/book/spiffe-and-spire/concept/spire/spire-arch.svg&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE 架构图&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE 架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;服务器&#34;&gt;服务器&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器负责管理和发布其配置的 SPIFFE 信任域中的所有身份。它存储注册条目（指定决定特定 SPIFFE ID 应被签发的条件的选择器）和签名密钥，使用节点证明来自动验证代理的身份，并在被验证的代理请求时为工作负载创建 SVID。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/spire-server.svg&#34; data-img=&#34;/book/spiffe-and-spire/concept/spire/spire-server.svg&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE 服务器&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE 服务器&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;服务器的行为是通过一系列的插件决定的。SPIRE 包含几个插件，你可以建立额外的插件来扩展 SPIRE 以满足特定的使用情况。插件的类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点证明器插件&lt;/strong&gt;：与代理节点证明器一起，验证代理运行的节点的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点解析器插件&lt;/strong&gt;：它通过验证关于节点的额外属性来扩展服务器可以用来识别节点的选择器集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据存储插件&lt;/strong&gt;：服务器用它来存储、查询和更新各种信息，如注册条目、哪些节点已认证、这些节点的选择器是什么。有一个内置的数据存储插件，可以使用 MySQL、SQLite3 或 PostgresSQL 数据库来存储必要的数据。默认情况下，使用 SQLite 3。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥管理器插件&lt;/strong&gt;：控制服务器如何存储用于签署 X.509-SVID 和 JWT-SVID 的私钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上游权威机构插件&lt;/strong&gt;：默认情况下，SPIRE 服务器充当其自身的证书授权机构。但是，你可以使用上游权威机构插件来使用来自不同 PKI 系统的不同 CA。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过配置插件和其他各种配置变量来定制服务器的行为。详见 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;p&gt;SPIRE 代理在已识别的工作负载所运行的每个节点上运行。该代理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从服务器上请求 SVID，并将其缓存起来，直到工作负载请求其 SVID 为止。&lt;/li&gt;
&lt;li&gt;向节点上的工作负载公开 SPIFFE 工作负载 API，并证明调用它的工作负载的身份&lt;/li&gt;
&lt;li&gt;为已识别的工作负载提供其 SVID&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/spire-agent.svg&#34; data-img=&#34;/book/spiffe-and-spire/concept/spire/spire-agent.svg&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE 代理&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE 代理&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;该代理的主要组成部分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点证明器插件&lt;/strong&gt;：与服务器节点证明器一起，验证代理运行的节点的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作负载证明器插件&lt;/strong&gt;：通过从节点操作系统中查询有关工作负载进程的信息，并将其与你在使用选择器注册工作负载属性时提供给服务器的信息进行比较，来验证节点上工作负载进程的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥管理器插件&lt;/strong&gt;：代理用来生成和使用颁发给工作负载的 X.509-SVID 的私钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过配置插件和其他配置变量来定制代理的行为。详见《&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/&#34; title=&#34;SPIRE 代理配置参考》&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理配置参考》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自定义服务器和代理插件&#34;&gt;自定义服务器和代理插件&lt;/h2&gt;
&lt;p&gt;你可以为特定的平台和架构创建自定义的服务器和代理插件，而 SPIRE 并不包括这些插件。例如，你可以为一个架构创建服务器和代理节点验证器，而不是在节点验证下总结的那些。或者你可以创建一个自定义密钥管理器插件，以 SPIRE 目前不支持的方式处理私钥。因为 SPIRE 在运行时加载自定义插件，你不需要重新编译 SPIRE 来启用它们。&lt;/p&gt;
&lt;h2 id=&#34;工作负载注册&#34;&gt;工作负载注册&lt;/h2&gt;
&lt;p&gt;为了让 SPIRE 识别工作负载，你必须通过注册条目向 SPIRE 服务器注册工作负载。工作负载注册告诉 SPIRE 如何识别工作负载以及为其提供哪个 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;注册条目将身份（以 SPIFFE ID 的形式）映射到一组称为选择器的属性，工作负载必须拥有这些属性才能获得特定身份。在工作负载证明期间，代理使用这些选择器值来验证工作负载的身份。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/registering/&#34; title=&#34;SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 文档&lt;/a&gt;中详细介绍了工作负载注册。&lt;/p&gt;
&lt;h2 id=&#34;证明&#34;&gt;证明&lt;/h2&gt;
&lt;p&gt;SPIRE 上下文中的证明（attestation）是断言工作负载的身份。SPIRE 通过从受信任的第三方收集工作负载进程本身和运行 SPIRE 代理的节点的属性并将它们与工作负载注册时定义的一组选择器进行比较来实现这一点。&lt;/p&gt;
&lt;p&gt;用于执行证明的可信第三方 SPIRE 查询是特定于平台的。&lt;/p&gt;
&lt;p&gt;SPIRE 分两个阶段执行证明：首先是节点证明（其中验证工作负载正在运行的节点的身份），然后是工作负载证明（其中验证节点上的工作负载）。&lt;/p&gt;
&lt;p&gt;SPIRE 有一个灵活的架构，允许它根据工作负载运行的环境，使用许多不同的受信第三方进行节点和工作负载验证。你通过代理和服务器配置文件中的条目告诉 SPIRE 使用哪些受信任的第三方，并通过你在注册工作负载时指定的选择器值告诉 SPIRE 使用哪些类型的信息进行验证。&lt;/p&gt;
&lt;h3 id=&#34;节点证明&#34;&gt;节点证明&lt;/h3&gt;
&lt;p&gt;SPIRE 要求每个代理在首次连接到服务器时进行身份验证和自我验证；这个过程称为节点证明（Node Attestation）。在节点证明期间，代理和服务器一起验证运行代理的节点的身份。他们通过称为节点证明器的插件来做到这一点。所有节点证明器都向节点及其环境询问只有该节点拥有的信息片段，以证明该节点的身份。&lt;/p&gt;
&lt;p&gt;节点证明的成功后，代理收到唯一的 SPIFFE ID。然后，代理的 SPIFFE ID 充当其负责的工作负载的“父级”。&lt;/p&gt;
&lt;p&gt;节点身份证明的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过云平台交付给节点的身份证明文件（例如 AWS Instance 身份证明文件）&lt;/li&gt;
&lt;li&gt;验证存储在连接到节点的硬件安全模块或可信平台模块上的私钥&lt;/li&gt;
&lt;li&gt;安装代理时通过加入令牌提供的手动验证&lt;/li&gt;
&lt;li&gt;多节点软件系统安装在节点上时提供的标识凭据（例如 Kubernetes 服务账户令牌）&lt;/li&gt;
&lt;li&gt;其他机器身份证明（例如部署的服务器证书）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点证明器向服务器返回一组（可选）节点选择器，用于标识特定机器（例如 Amazon 实例 ID）。由于在定义工作负载的身份时，单个机器的特定身份通常没有用处，因此 SPIRE 会查询&lt;a href=&#34;https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-resolution&#34; title=&#34;节点解析器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;节点解析器&lt;/a&gt;（如果有）以查看可以验证被证明节点的哪些附加属性（例如，如果节点是 AWS 安全组的成员）。来自证明器和解析者的选择器集成为与代理节点的 SPIFFE ID 关联的选择器集。&lt;/p&gt;



&lt;div class=&#34;alert alert-note-container&#34;&gt;
  
  &lt;div class=&#34;alert-note-title px-2 py-2&#34;&gt;
    注意
  &lt;/div&gt;
  
  &lt;div class=&#34;alert-note px-2&#34;&gt;
    节点证明不需要节点选择器，除非你&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/registering/#mapping-workloads-to-multiple-nodes&#34; title=&#34;将工作负载映射到多个节点&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将工作负载映射到多个节点&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;下图说明了节点证明中的步骤。在此图中，底层平台是 AWS：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/spire-node-attestor.svg&#34; data-img=&#34;/book/spiffe-and-spire/concept/spire/spire-node-attestor.svg&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE 节点证明步骤&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE 节点证明步骤&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h4 id=&#34;步骤总结节点证明&#34;&gt;步骤总结：节点证明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;代理 AWS 节点证明器插件向 AWS 查询节点身份证明，并将该信息提供给代理。&lt;/li&gt;
&lt;li&gt;代理将此身份证明传递给服务器。服务器将此数据传递给其 AWS 节点证明器。&lt;/li&gt;
&lt;li&gt;服务器 AWS 节点证明器独立验证身份证明，或者通过调用 AWS API，使用它在步骤 2 中获得的信息。节点证明器还为代理创建一个 SPIFFE ID，并将其传递回服务器进程，以及它发现的任何节点选择器。&lt;/li&gt;
&lt;li&gt;服务器发回代理节点的 SVID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;节点证明器&#34;&gt;节点证明器&lt;/h4&gt;
&lt;p&gt;代理和服务器通过它们各自的节点证明器询问底层平台。SPIRE 支持节点证明器在各种环境中证明节点身份，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS 上的 EC2 实例（使用 EC2 实例身份文档）&lt;/li&gt;
&lt;li&gt;Microsoft Azure 上的 VM（使用 Azure 托管服务标识）&lt;/li&gt;
&lt;li&gt;Google Cloud Platform 上的 Google Compute Engine 实例（使用 GCE 实例身份令牌）&lt;/li&gt;
&lt;li&gt;作为 Kubernetes 集群成员的节点（使用 Kubernetes 服务账户令牌）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于没有平台可以直接识别节点的情况，SPIRE 包括用于证明的节点证明器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用服务器生成的加入令牌&lt;/strong&gt;—— 加入令牌（join token）是 SPIRE 服务器和代理之间的预共享密钥。服务器可以在安装后生成加入令牌，该令牌可用于在代理启动时对其进行验证。为帮助防止滥用，加入令牌在使用后立即过期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用现有的 X.509 证书&lt;/strong&gt;—— 有关配置节点证明器的信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器配置参考&lt;/a&gt;和 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/&#34; title=&#34;SPIRE 代理配置参考&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;节点解析&#34;&gt;节点解析&lt;/h4&gt;
&lt;p&gt;一旦验证了单个节点的身份，“节点解析器”插件就会扩展一组选择器，这些选择器可用于通过验证节点的其他属性来识别节点（例如，如果节点是特定 AWS 安全组的成员） ，或具有与之关联的特定标签）。只有服务器参与节点解析。SPIRE 在证明之后直接运行一次节点解析器。&lt;/p&gt;
&lt;h4 id=&#34;节点解析器&#34;&gt;节点解析器&lt;/h4&gt;
&lt;p&gt;服务器支持以下平台的节点解析器插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;亚马逊网络服务（AWS）&lt;/li&gt;
&lt;li&gt;微软 Azure&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作负载证明&#34;&gt;工作负载证明&lt;/h3&gt;
&lt;p&gt;工作负载证明提出了一个问题：“这是谁的进程？”代理通过询问本地可用的权限（例如节点的操作系统内核，或在同一节点上运行的本地 kubelet）来回答这个问题，以确定调用工作负载 API 的进程的属性。&lt;/p&gt;
&lt;p&gt;然后，当你使用选择器注册工作负载的属性时，将这些属性与提供给服务器的信息进行比较。&lt;/p&gt;
&lt;p&gt;这些类型的信息可能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底层操作系统如何调度进程。在基于 Unix 的系统上，这可能是用户 ID (uid)、组 ID (gid)、文件系统路径等。）&lt;/li&gt;
&lt;li&gt;进程是如何由 Kubernetes 等编排系统调度的。在这种情况下，工作负载可能由运行它的 Kubernetes 服务账户或命名空间来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然代理和服务器都在节点证明中发挥作用，但只有代理参与工作负载证明。&lt;/p&gt;
&lt;p&gt;下图说明了工作负载证明的步骤：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/concept/spire/workload-attestation.svg&#34; data-img=&#34;/book/spiffe-and-spire/concept/spire/workload-attestation.svg&#34; alt=&#34;image&#34; data-caption=&#34;工作负载证明&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;工作负载证明&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h4 id=&#34;步骤摘要工作负载证明&#34;&gt;步骤摘要：工作负载证明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;工作负载调用工作负载 API 以请求 SVID。在 Unix 系统上，这被暴露为 Unix 域套接字。&lt;/li&gt;
&lt;li&gt;代理询问节点的内核以识别调用者的进程 ID。然后，它调用任何已配置的工作负载证明器插件，为它们提供工作负载的进程 ID。&lt;/li&gt;
&lt;li&gt;工作负载证明者使用进程 ID 来发现有关工作负载的其他信息，并根据需要查询相邻平台特定的组件，例如 Kubernetes kubelet。通常，这些组件也与代理驻留在同一节点上。&lt;/li&gt;
&lt;li&gt;证明者将发现的信息以选择器的形式返回给代理。&lt;/li&gt;
&lt;li&gt;代理通过将发现的选择器与注册条目进行比较来确定工作负载的身份，并将正确的缓存 SVID 返回给工作负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作负载证明者&#34;&gt;工作负载证明者&lt;/h4&gt;
&lt;p&gt;SPIRE 包括适用于 Unix、Kubernetes 和 Docker 的工作负载证明器插件。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIRE 嵌套架构：将 SPIRE 服务器链接为同一信任域</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/architecture/nested/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/architecture/nested/</guid>
      <description>
        
        
        &lt;p&gt;嵌套 SPIRE 允许将 SPIRE 服务器“链接”在一起，并且所有 SPIRE 服务器都可以在同一信任域中发放身份，这意味着在同一信任域中标识的所有工作负载都可以使用根密钥验证其身份文档。&lt;/p&gt;
&lt;p&gt;嵌套拓扑结构通过将一个 SPIRE 代理与每个下游 SPIRE 服务器“链接”在一起来实现。下游 SPIRE 服务器通过 Workload API 获得凭证，然后直接与上游 SPIRE 服务器进行身份验证，以获取一个中间 CA。&lt;/p&gt;
&lt;p&gt;为了演示嵌套拓扑中的 SPIRE 部署，我们使用 Docker Compose 创建了一个场景，其中包括一个根 SPIRE 部署和两个嵌套的 SPIRE 部署。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/nested/Nested_SPIRE_Diagram_hu6573345887674137817.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/nested/Nested_SPIRE_Diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/architecture/nested/Nested_SPIRE_Diagram.png&#34; data-width=&#34;788&#34; data-height=&#34;675&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;嵌套拓扑结构非常适合多云部署。由于可以混合匹配节点验证者，下游 SPIRE 服务器可以位于不同的云提供商环境中，并为工作负载和 SPIRE 代理提供身份。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学习以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在嵌套拓扑中配置 SPIRE&lt;/li&gt;
&lt;li&gt;配置 UpstreamAuthority 插件&lt;/li&gt;
&lt;li&gt;为嵌套 SPIRE 服务器创建注册条目&lt;/li&gt;
&lt;li&gt;测试在整个信任域中创建的 SVID 是否有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;本教程的所需文件可以在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;docker-compose/nested-spire&lt;/code&gt; 目录中找到。如果尚未克隆存储库，请现在进行克隆。&lt;/p&gt;
&lt;p&gt;在继续之前，请查看以下系统要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64 位 Linux 或 macOS 环境&lt;/li&gt;
&lt;li&gt;已安装 &lt;a href=&#34;https://docs.docker.com/get-docker/&#34; title=&#34;Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 和 &lt;a href=&#34;https://docs.docker.com/compose/install/&#34; title=&#34;Docker Compose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Compose&lt;/a&gt;（macOS Docker Desktop 包含 Docker Compose）&lt;/li&gt;
&lt;li&gt;已安装 &lt;a href=&#34;https://golang.org/dl/&#34; title=&#34;Go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt; 1.14.4 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第一部分运行服务&#34;&gt;第一部分：运行服务&lt;/h2&gt;
&lt;p&gt;本教程的“nested-spire”主目录包含三个子目录，分别用于存放 SPIRE 部署的配置文件：&lt;code&gt;root&lt;/code&gt;、&lt;code&gt;nestedA&lt;/code&gt;和&lt;code&gt;nestedB&lt;/code&gt;。这些目录包含用于验证 Agents 在 Servers 上的身份的私钥和证书。这些私钥和证书是在场景初始化时使用 Go 应用程序创建的，其详细信息超出了本教程的范围。&lt;/p&gt;
&lt;h3 id=&#34;创建共享目录&#34;&gt;创建共享目录&lt;/h3&gt;
&lt;p&gt;首先，需要一个本地目录，在服务上进行卷挂载，以在根 SPIRE Agent 和嵌套 SPIRE Servers 之间共享工作负载 API。本教程使用&lt;code&gt;.../spire-tutorials/docker-compose/nested-spire/sharedRootSocket&lt;/code&gt;作为共享目录。&lt;/p&gt;
&lt;h3 id=&#34;配置根-spire-部署&#34;&gt;配置根 SPIRE 部署&lt;/h3&gt;
&lt;p&gt;根 SPIRE 服务器和代理的配置文件与默认的&lt;code&gt;server.conf&lt;/code&gt;和&lt;code&gt;agent.conf&lt;/code&gt;文件没有改动，但值得注意的是 SPIRE 代理定义绑定工作负载 API socket 的位置：&lt;code&gt;socket_path =&amp;quot;/opt/spire/sockets/workload_api.sock&amp;quot;&lt;/code&gt;。稍后将使用此路径来配置卷，以便与嵌套 SPIRE Servers 共享工作负载 API。&lt;/p&gt;
&lt;p&gt;我们在&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/docker-compose/nested-spire/docker-compose.yaml&#34; title=&#34;docker-compose.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker-compose.yaml&lt;/a&gt;文件中定义了本教程中的所有服务。在&lt;code&gt;root-agent&lt;/code&gt;服务定义中，我们将 SPIRE Agent 容器中的&lt;code&gt;/opt/spire/sockets&lt;/code&gt;目录挂载到新的本地目录&lt;code&gt;sharedRootSocket&lt;/code&gt;上。在下一节中，当定义嵌套 SPIRE Server 服务时，我们将使用此目录将&lt;code&gt;root-agent&lt;/code&gt;套接字挂载到 SPIRE Server 容器上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;root-server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ghcr.io/spiffe/spire-server:1.5.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;root-server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./root/server:/opt/spire/conf/server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/server/server.conf&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;root-agent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Share the host pid namespace so this agent can attest the nested servers&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ghcr.io/spiffe/spire-agent:1.5.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;depends_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;root-server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;root-agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Share root agent socket to be accessed by nestedA and nestedB servers&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./sharedRootSocket:/opt/spire/sockets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./root/agent:/opt/spire/conf/agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/var/run/:/var/run/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/agent/agent.conf&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;配置嵌套-a-spire-部署&#34;&gt;配置嵌套 A SPIRE 部署&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nestedB&lt;/code&gt; SPIRE 部署需要相同的一组配置，但本文不描述这些更改，以避免重复。&lt;/p&gt;
&lt;p&gt;SPIRE Agent 和 Server 可以通过各种&lt;a href=&#34;https://spiffe.io/spire/docs/extending/&#34; title=&#34;插件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;插件&lt;/a&gt;进行扩展。&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/spire_server.md#built-in-plugins&#34; title=&#34;UpstreamAuthority 插件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UpstreamAuthority 插件&lt;/a&gt;类型允许 SPIRE Server 与现有 PKI 系统集成。UpstreamAuthority 插件可以使用从磁盘加载的 CA 进行证书签名，第三方工具如 AWS 和 Vault 等。嵌套 SPIRE 部署需要使用&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_spire.md&#34; title=&#34;spire UpstreamAuthority 插件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spire UpstreamAuthority 插件&lt;/a&gt;，该插件使用同一信任域中的上游 SPIRE Server 获取 SPIRE Server 的中间签名证书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/docker-compose/nested-spire/nestedA/server/server.conf&#34; title=&#34;nestedA-server 的配置文件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nestedA-server 的配置文件&lt;/a&gt;*包括&lt;code&gt;spire&lt;/code&gt; UpstreamAuthority 插件定义，其中&lt;code&gt;root-server&lt;/code&gt;被定义为其上游 SPIRE Server。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;na&#34;&gt;UpstreamAuthority &amp;#34;spire&amp;#34; {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 	   &lt;span class=&#34;na&#34;&gt;plugin_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt; 	       server_address      = &amp;#34;root-server&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt; 	       server_port         = 8081
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt; 	       workload_api_socket = &amp;#34;/opt/spire/sockets/workload_api.sock&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt; 	   }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/docker-compose/nested-spire/docker-compose.yaml&#34; title=&#34;docker-compose.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker-compose.yaml&lt;/a&gt;文件中，&lt;code&gt;nestedA-server&lt;/code&gt;服务的 Docker Compose 定义将新的本地目录&lt;code&gt;sharedRootSocket&lt;/code&gt;作为卷进行挂载。请记住，前一节中将&lt;code&gt;root-agent&lt;/code&gt;套接字挂载在该目录上。这样，&lt;code&gt;nestedA-server&lt;/code&gt;就可以访问&lt;code&gt;root-agent&lt;/code&gt;的工作负载 API 并获取其 SVID。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;nestedA-server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Share the host pid namespace so this server can be attested by the root agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ghcr.io/spiffe/spire-server:1.5.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nestedA-server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# label to attest nestedA-server against root-agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;org.example.name=nestedA&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Add root agent socket&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./shared/rootSocket:/opt/spire/sockets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;./nestedA/server:/opt/spire/conf/server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/server/server.conf&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建下游注册项&#34;&gt;创建下游注册项&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nestedA-server&lt;/code&gt;必须在&lt;code&gt;root-server&lt;/code&gt;中注册，以获取其身份，该身份将用于生成 SVID。我们通过在根 SPIRE Server 中创建一个注册项来实现为&lt;code&gt;nestedA-server&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -T root-server &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -parentID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/spire/agent/x509pop/&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;fingerprint root/agent/agent.crt.pem&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/nestedA&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector &lt;span class=&#34;s2&#34;&gt;&amp;#34;docker:label:org.example.name:nestedA-server&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -downstream
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parentID&lt;/code&gt;标志包含&lt;code&gt;root-agent&lt;/code&gt;的 SPIFFE ID。&lt;code&gt;root-agent&lt;/code&gt;的 SPIFFE ID 是由&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_x509pop.md&#34; title=&#34;x509pop Node Attestor 插件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x509pop Node Attestor 插件&lt;/a&gt;创建的，该插件将 SPIFFE ID 定义为&lt;code&gt;spiffe://&amp;lt;trust domain&amp;gt;/spire/agent/x509pop/&amp;lt;fingerprint&amp;gt;&lt;/code&gt;。shell 脚本中的&lt;code&gt;fingerprint()&lt;/code&gt;函数计算证书的 SHA1 指纹。另一个要注意的是&lt;code&gt;downstream&lt;/code&gt;选项。设置此选项时，表示该条目描述的是下游 SPIRE Server。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行场景&#34;&gt;运行场景&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;set-env.sh&lt;/code&gt;脚本来运行构成场景的所有服务。该脚本使用之前描述的配置选项启动&lt;code&gt;root&lt;/code&gt;、&lt;code&gt;nestedA&lt;/code&gt;和&lt;code&gt;nestedB&lt;/code&gt;服务。&lt;/p&gt;
&lt;p&gt;确保当前工作目录是&lt;code&gt;.../spire-tutorials/docker-compose/nested-spire&lt;/code&gt;，然后运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bash scripts/set-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;脚本完成后，在另一个终端中运行以下命令以查看所有服务的日志：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose logs -f -t
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第二部分测试部署&#34;&gt;第二部分：测试部署&lt;/h2&gt;
&lt;p&gt;现在 SPIRE 部署已准备就绪，让我们测试所配置的场景。&lt;/p&gt;
&lt;h3 id=&#34;创建工作负载注册项&#34;&gt;创建工作负载注册项&lt;/h3&gt;
&lt;p&gt;为了测试场景，我们创建两个工作负载注册项，一个用于每个嵌套 SPIRE Server（&lt;code&gt;nestedA&lt;/code&gt;和&lt;code&gt;nestedB&lt;/code&gt;）。测试的目标是演示在嵌套配置中创建的 SVID 在整个信任域中都有效，而不仅仅在生成 SVID 的 SPIRE Server 的范围内。以下命令演示了我们将用于创建这两个工作负载注册项的命令行选项，但你可以使用下面显示的&lt;code&gt;create-workload-registration-entries.sh&lt;/code&gt;脚本运行这些命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# nestedA部署的工作负载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -T nestedA-server &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -parentID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/spire/agent/x509pop/&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;fingerprint nestedA/agent/agent.crt.pem&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/nestedA/workload&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector &lt;span class=&#34;s2&#34;&gt;&amp;#34;unix:uid:1001&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# nestedB部署的工作负载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -T nestedB-server &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -parentID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/spire/agent/x509pop/&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;fingerprint nestedB/agent/agent.crt.pem&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/nestedB/workload&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector &lt;span class=&#34;s2&#34;&gt;&amp;#34;unix:uid:1001&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例再次使用&lt;code&gt;fingerprint path/to/nested-agent-cert&lt;/code&gt;的形式，以显示&lt;code&gt;-parentID&lt;/code&gt;标志指定了嵌套 SPIRE Agent 的 SPIFFE ID。最后，在两种情况下，Unix 选择器将 SPIFFE ID 分配给 uid 为 1001 的任何进程。&lt;/p&gt;
&lt;p&gt;使用以下 Bash 脚本使用刚才描述的选项创建注册条目：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bash scripts/create-workload-registration-entries.sh
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;运行测试&#34;&gt;运行测试&lt;/h3&gt;
&lt;p&gt;一旦两个工作负载注册条目被传播，我们可以测试在嵌套配置中创建的 SVID 是否在整个信任域中有效，而不仅仅在生成 SVID 的 SPIRE Server 的范围内。&lt;/p&gt;
&lt;p&gt;该测试包括从&lt;code&gt;nestedA-agent&lt;/code&gt; SPIRE Agent 获取 JWT-SVID，并使用&lt;code&gt;nestedB-agent&lt;/code&gt;对其进行验证。在两种情况下，Docker Compose 使用 uid 1001 运行进程，以匹配在上一节中创建的工作负载注册条目。&lt;/p&gt;
&lt;p&gt;输入以下命令从&lt;code&gt;nestedA&lt;/code&gt; SPIRE Agent 获取 JWT-SVID，并从 JWT-SVID 中提取令牌：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -u &lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt; -T nestedA-agent &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-agent api fetch jwt -audience nested-test -socketPath /opt/spire/sockets/workload_api.sock &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sed -n &lt;span class=&#34;s1&#34;&gt;&amp;#39;2p&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行以下命令在&lt;code&gt;nestedB&lt;/code&gt; SPIRE Agent 上验证&lt;code&gt;nestedA&lt;/code&gt;的令牌：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -u &lt;span class=&#34;m&#34;&gt;1001&lt;/span&gt; -T nestedB-agent &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-agent api validate jwt -audience nested-test  -svid &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      -socketPath /opt/spire/sockets/workload_api.sock
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;nestedB&lt;/code&gt; SPIRE Agent 输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    SVID is valid.
    SPIFFE ID : spiffe://example.org/nestedA/workload
    Claims    : {&amp;#34;aud&amp;#34;:[&amp;#34;nested-test&amp;#34;],&amp;#34;exp&amp;#34;:1595814190,&amp;#34;iat&amp;#34;:1595813890,&amp;#34;sub&amp;#34;:&amp;#34;spiffe://example.org/nestedA/workload&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出表示 JWT-SVID 是有效的。此外，尽管 SPIFFE ID 注册在&lt;code&gt;nestedA&lt;/code&gt;而不是&lt;code&gt;nestedB&lt;/code&gt;上，但该 SPIFFE ID 在&lt;code&gt;nestedB&lt;/code&gt; SPIRE Agent 上仍然有效，因为 SPIRE Agents 在嵌套 SPIRE 拓扑中处于相同的信任域。&lt;/p&gt;
&lt;p&gt;在 SPIRE 中，这是通过将每个 JWT-SVID 公共签名密钥传播到整个拓扑来实现的。在 X509-SVID 的情况下，由于 X.509 的链式语义，这很容易实现。&lt;/p&gt;
&lt;h2 id=&#34;清理&#34;&gt;清理&lt;/h2&gt;
&lt;p&gt;完成本教程后，你可以使用以下 Bash 脚本停止所有容器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bash scripts/clean-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>X.509 SPIFFE 可验证身份文档</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/x509-svid/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/x509-svid/</guid>
      <description>
        
        
        &lt;p&gt;SPIFFE 标准提供了一种框架的规范，能够在异构环境和组织边界中引导和发放服务的身份。它定义了一种称为 SPIFFE 可验证身份文档（SVID）的身份文档。&lt;/p&gt;
&lt;p&gt;SVID 本身并不代表一种新的文档类型。相反，我们提出了一个规范，定义了如何将 SVID 信息编码到现有文档类型中。&lt;/p&gt;
&lt;p&gt;本文档定义了一种标准，其中将 X.509 证书用作 SVID。假设读者对 X.509 有基本的了解。关于 X.509 的具体信息，请参考&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; title=&#34;RFC 5280&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 的最重要的功能之一是保护进程间通信。核心标准允许进行身份验证，但利用加密身份来构建安全的通信通道也是非常有益的。由于 TLS 被广泛采用，并且使用基于 X.509 的身份验证，将 X.509 用作 SPIFFE SVID 显然是有优势的。&lt;/p&gt;
&lt;p&gt;本规范讨论了将 SVID 信息编码到 X.509 证书中的约束条件，以及如何验证 X.509 SVID。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-id&#34;&gt;SPIFFE ID&lt;/h2&gt;
&lt;p&gt;在 X.509 SVID 中，对应的 SPIFFE ID 被设置为主题备用名称扩展（SAN 扩展，参见&lt;a href=&#34;https://tools.ietf.org/html/rfc5280#section-4.2.1.6&#34; title=&#34;RFC 5280 第 4.2.1.6 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280 第 4.2.1.6 节&lt;/a&gt;）。一个 X.509 SVID 必须恰好包含一个 URI SAN，因此也只包含一个 SPIFFE ID。包含多个 SPIFFE ID 的 SVID 会引入与审计和授权逻辑相关的挑战，包含多个 URI SAN 的 SVID 会引入与 SPIFFE ID 验证相关的挑战。遇到包含多个 URI SAN 的 SVID 的验证器必须拒绝该 SVID。有关更多信息，请参见验证部分。&lt;/p&gt;
&lt;p&gt;一个 X.509 SVID 可以包含任意数量的其他 SAN 字段类型，包括 DNS SAN。&lt;/p&gt;
&lt;h2 id=&#34;层级关系&#34;&gt;层级关系&lt;/h2&gt;
&lt;p&gt;本节讨论了叶证书、根证书和中间证书之间的关系，以及对每个证书的要求。&lt;/p&gt;
&lt;h3 id=&#34;叶证书&#34;&gt;叶证书&lt;/h3&gt;
&lt;p&gt;叶证书是用于标识调用方或资源的 SVID，适用于身份验证过程。叶证书（相对于签名证书，第 3.2 节）是唯一能够用于标识资源或调用方的类型。&lt;/p&gt;
&lt;p&gt;叶证书的 SPIFFE ID 必须具有非根路径组件。如果省略了主题字段，则不需要主题字段，但如果省略了主题字段，则 URI SAN 扩展必须标记为关键扩展，根据&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; title=&#34;RFC 5280 第 4.1.2.6 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280 第 4.1.2.6 节&lt;/a&gt;的规定。有关区分叶证书和签名证书的 X.509 特定属性的信息，请参见第 4.1 节。&lt;/p&gt;
&lt;h3 id=&#34;签名证书&#34;&gt;签名证书&lt;/h3&gt;
&lt;p&gt;X.509 SVID 签名证书是具有在密钥用途扩展中设置&lt;code&gt;keyCertSign&lt;/code&gt;的证书。它还在基本约束扩展中将&lt;code&gt;CA&lt;/code&gt;标志设置为&lt;code&gt;true&lt;/code&gt;（参见第 4.1 节）。也就是说，它是一个 CA 证书。&lt;/p&gt;
&lt;p&gt;签名证书应该本身是一个 SVID。如果存在，签名证书的 SPIFFE ID 必须没有路径组件，并且可以位于其发行的任何叶 SVID 的信任域中。签名证书可以用于在相同或不同的信任域中发行进一步的签名证书。&lt;/p&gt;
&lt;p&gt;签名证书不能用于身份验证目的。它们只作为验证材料，并且可以像&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; title=&#34;RFC 5280&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280&lt;/a&gt;中描述的那样以典型的 X.509 方式链接在一起。请参见第 4.3 节和第 4.4 节以获取有关签名证书的 X.509 特定限制的更多信息。&lt;/p&gt;
&lt;h2 id=&#34;约束和用途&#34;&gt;约束和用途&lt;/h2&gt;
&lt;p&gt;叶证书和签名证书具有不同的 X.509 属性 - 一些用于安全目的，一些用于支持其特殊的功能。本节描述了两种类型 X.509 SVID 的约束和密钥用法配置。&lt;/p&gt;
&lt;h3 id=&#34;基本约束&#34;&gt;基本约束&lt;/h3&gt;
&lt;p&gt;基本约束 X.509 扩展标识证书是否为签名证书，以及包括该证书在内的有效证书路径的最大深度。它在&lt;a href=&#34;https://tools.ietf.org/html/rfc5280#section-4.2.1.9&#34; title=&#34;RFC 5280 第 4.2.1.9 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280 第 4.2.1.9 节&lt;/a&gt;中定义。&lt;/p&gt;
&lt;p&gt;有效的 X.509 SVID 签名证书可以设置&lt;code&gt;pathLenConstraint&lt;/code&gt;字段。签名证书必须将&lt;code&gt;cA&lt;/code&gt;字段设置为&lt;code&gt;true&lt;/code&gt;，而叶证书必须将&lt;code&gt;cA&lt;/code&gt;字段设置为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;名称约束&#34;&gt;名称约束&lt;/h3&gt;
&lt;p&gt;名称约束指示了一个命名空间，其中后续证书中的所有 SPIFFE ID 必须位于其中。它们用于将受损的签名证书的影响范围限制在命名的信任域内，并在&lt;a href=&#34;https://tools.ietf.org/html/rfc5280#section-4.2.1.10&#34; title=&#34;RFC 5280 第 4.2.1.10 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280 第 4.2.1.10 节&lt;/a&gt;中定义。本节仅适用于签名证书。&lt;/p&gt;
&lt;p&gt;名称约束的类型与主题备用名称相同。由于 SVID 关心的仅是 SPIFFE ID，并且 SPIFFE ID 被定义为 SAN 类型 URI，因此我们只定义 URI 类型名称约束的语义。&lt;/p&gt;
&lt;p&gt;目前，对 URI 类型名称约束的支持相对较少。不支持它们的库将拒绝此类证书，阻止路径验证成功。虽然名称约束是 SPIFFE 希望使用的 X.509 功能，但作者认识到广泛支持的缺乏可能会给实现和/或部署带来重大痛苦。因此，X.509 SVID 签名证书可以根据实现者的意愿应用 URI 名称约束，但在此领域应谨慎使用。SPIFFE 社区正在努力在各种平台上启用对 URI 名称约束的支持，并且应该预期在未来的版本中，随着广泛支持的实现，本节中定义的要求将变得更加严格。&lt;/p&gt;
&lt;h3 id=&#34;密钥用法&#34;&gt;密钥用法&lt;/h3&gt;
&lt;p&gt;密钥用法扩展定义了证书中包含的密钥的用途。当要限制可以用于多个操作的密钥时，可以使用此用法限制。密钥用法扩展在&lt;a href=&#34;https://tools.ietf.org/html/rfc5280#section-4.2.1.3&#34; title=&#34;RFC 5280 第 4.2.1.3 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280 第 4.2.1.3 节&lt;/a&gt;中定义。&lt;/p&gt;
&lt;p&gt;密钥用法扩展必须在所有 SVID 上设置，并且必须标记为关键扩展。&lt;/p&gt;
&lt;p&gt;SVID 签名证书必须设置&lt;code&gt;keyCertSign&lt;/code&gt;。它们可以设置&lt;code&gt;cRLSign&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;叶 SVID 必须设置&lt;code&gt;digitalSignature&lt;/code&gt;。它们可以设置&lt;code&gt;keyEncipherment&lt;/code&gt;和/或&lt;code&gt;keyAgreement&lt;/code&gt;；这些对于 RSA 密钥的证书来说通常只有在需要的情况下才有意义，即使在那种情况下通常也不需要。叶 SVID 不能设置&lt;code&gt;keyCertSign&lt;/code&gt;或&lt;code&gt;cRLSign&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;扩展密钥用途&#34;&gt;扩展密钥用途&lt;/h3&gt;
&lt;p&gt;该扩展指示证书中包含的密钥可以用于的一个或多个目的，除了或代替密钥用途扩展中指示的基本目的之外。它在&lt;a href=&#34;https://tools.ietf.org/html/rfc5280#section-4.2.1.2&#34; title=&#34;RFC 5280，第 4.2.1.2 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280，第 4.2.1.2 节&lt;/a&gt;中定义。&lt;/p&gt;
&lt;p&gt;Leaf SVID 应包括此扩展，并且可以将其标记为关键。当包含时，字段&lt;code&gt;id-kp-serverAuth&lt;/code&gt;和&lt;code&gt;id-kp-clientAuth&lt;/code&gt;必须设置。&lt;/p&gt;
&lt;p&gt;签名证书可以包括扩展密钥用途。请注意，X.509 证书验证库中间 CA 证书中扩展密钥用途的处理方式因实现而异。有些 X.509 实现会对信任链中其下的所有证书都施加中间 CA 证书中的扩展密钥用途约束，而其他实现则不会。&lt;/p&gt;
&lt;h2 id=&#34;验证&#34;&gt;验证&lt;/h2&gt;
&lt;p&gt;本节描述了如何验证 X.509 SVID。该过程使用标准的 X.509 验证，以及一系列 SPIFFE 特定的验证步骤。&lt;/p&gt;
&lt;h3 id=&#34;路径验证&#34;&gt;路径验证&lt;/h3&gt;
&lt;p&gt;对给定 SVID 的信任验证基于标准的 X.509 路径验证，并且必须遵循&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; title=&#34;RFC 5280&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 5280&lt;/a&gt;的路径验证语义。&lt;/p&gt;
&lt;p&gt;证书路径验证需要提供叶子 SVID 证书和一个或多个 SVID 签名证书。用于验证的签名证书集合称为 CA 捆绑包。实体检索相关 CA 捆绑包的机制不在本文档范围内，而是在 SPIFFE 工作负载 API 规范中定义。&lt;/p&gt;
&lt;h3 id=&#34;叶子验证&#34;&gt;叶子验证&lt;/h3&gt;
&lt;p&gt;在验证资源或调用方时，需要进行超出 X.509 标准范围的验证。即，我们必须确保 1）证书是叶子证书，2）签发机构有权签发它。&lt;/p&gt;
&lt;p&gt;在验证用于身份验证目的的 X.509 SVID 时，验证器必须确保基本约束扩展中的&lt;code&gt;CA&lt;/code&gt;字段设置为&lt;code&gt;false&lt;/code&gt;，并且密钥用途扩展中未设置&lt;code&gt;keyCertSign&lt;/code&gt;和&lt;code&gt;cRLSign&lt;/code&gt;。验证器还必须确保 SPIFFE ID 的方案设置为&lt;code&gt;spiffe://&lt;/code&gt;。包含多个 URI SAN 的 SVID 必须被拒绝。&lt;/p&gt;
&lt;p&gt;随着 URI 名称约束的支持越来越广泛，本文档的未来版本可能会更新本节中设定的要求，以便更好地利用名称约束验证。&lt;/p&gt;
&lt;h2 id=&#34;在-spiffe-捆绑包中的表示&#34;&gt;在 SPIFFE 捆绑包中的表示&lt;/h2&gt;
&lt;p&gt;本节描述了如何将 X509-SVID CA 证书发布到 SPIFFE 捆绑包中，并从中使用。有关 SPIFFE 捆绑包的更多信息，请参阅 SPIFFE 信任域和捆绑包规范。&lt;/p&gt;
&lt;h3 id=&#34;发布-spiffe-捆绑包元素&#34;&gt;发布 SPIFFE 捆绑包元素&lt;/h3&gt;
&lt;p&gt;给定信任域的 X509-SVID CA 证书在 SPIFFE 捆绑包中表示为&lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; title=&#34;RFC 7517 兼容&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517 兼容&lt;/a&gt;的 JWK 条目，每个 CA 证书一个条目。&lt;/p&gt;
&lt;p&gt;每个 JWK 条目的&lt;code&gt;use&lt;/code&gt;参数必须设置为&lt;code&gt;x509-svid&lt;/code&gt;。另外，每个 JWK 条目的&lt;code&gt;kid&lt;/code&gt;参数不能设置。&lt;/p&gt;
&lt;p&gt;除了&lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; title=&#34;RFC 7517&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517&lt;/a&gt;要求的参数之外，表示 X509-SVID CA 证书的每个条目必须包含具有与该条目表示的基于 Base64 编码的 DER CA 证书相等的值的&lt;code&gt;x5c&lt;/code&gt;参数。该值必须包含且仅包含一个 CA 证书，并且该证书应为自签名。&lt;/p&gt;
&lt;h3 id=&#34;使用-spiffe-捆绑包&#34;&gt;使用 SPIFFE 捆绑包&lt;/h3&gt;
&lt;p&gt;从外部信任域使用 SPIFFE 捆绑包时，需要提取 X509-SVID CA 证书以供实际使用。SPIFFE 捆绑包可以包含许多不同类型的 SVID 条目，因此第一步是识别表示 X509-SVID CA 证书的条目。&lt;/p&gt;
&lt;p&gt;对于捆绑包中&lt;code&gt;use&lt;/code&gt;参数设置为&lt;code&gt;x509-svid&lt;/code&gt;的每个 JWK 条目，请检查&lt;code&gt;x5c&lt;/code&gt;参数是否设置并且至少具有一个值。如果&lt;code&gt;x5c&lt;/code&gt;未设置或为空，则必须忽略该条目。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x5c&lt;/code&gt;参数的第一个值是该条目表示的 Base64 DER 编码的 CA 证书。如果&lt;code&gt;x5c&lt;/code&gt;参数包含多个值，则除第一个值外的所有值都必须被忽略。然后，X509-SVID CA 捆绑包是从&lt;code&gt;x509-svid&lt;/code&gt; JWK 条目中提取的 CA 证书的并集。如果捆绑包中不存在&lt;code&gt;x509-svid&lt;/code&gt; JWK 条目，则信任域不支持 X509-SVID。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;本文档提出了 X.509 基于 SPIFFE 可验证身份文档的约定和标准。它构成了现实世界 SPIFFE 服务身份验证和 SVID 验证的基础。通过遵守 X.509 SVID 标准，可以构建一个可互操作且与平台无关的身份和身份验证系统。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-x509-字段参考&#34;&gt;附录 A. X.509 字段参考&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;扩展&lt;/th&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主题备用名称&lt;/td&gt;
          &lt;td&gt;uniformResourceIdentifier&lt;/td&gt;
          &lt;td&gt;此字段设置为 SPIFFE ID。仅允许一个此字段的实例。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;基本约束&lt;/td&gt;
          &lt;td&gt;CA&lt;/td&gt;
          &lt;td&gt;如果 SVID 是签名证书，则必须将此字段设置为 true。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;基本约束&lt;/td&gt;
          &lt;td&gt;pathLenConstraint&lt;/td&gt;
          &lt;td&gt;如果实现者希望执行有限的 CA 层次结构深度约束（例如，从现有私钥基础设施（PKI）继承），则可以设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;名称约束&lt;/td&gt;
          &lt;td&gt;permittedSubtrees&lt;/td&gt;
          &lt;td&gt;如果实现者希望使用 URI 名称约束，则可以设置此字段。这将在本文档的未来版本中要求。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;密钥用途&lt;/td&gt;
          &lt;td&gt;keyCertSign&lt;/td&gt;
          &lt;td&gt;如果 SVID 是签名证书，则必须设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;密钥用途&lt;/td&gt;
          &lt;td&gt;cRLSign&lt;/td&gt;
          &lt;td&gt;如果 SVID 是签名证书，则可以设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;密钥用途&lt;/td&gt;
          &lt;td&gt;keyAgreement&lt;/td&gt;
          &lt;td&gt;如果 SVID 是叶子证书，则可以设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;密钥用途&lt;/td&gt;
          &lt;td&gt;keyEncipherment&lt;/td&gt;
          &lt;td&gt;如果 SVID 是叶子证书，则可以设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;密钥用途&lt;/td&gt;
          &lt;td&gt;digitalSignature&lt;/td&gt;
          &lt;td&gt;如果 SVID 是叶子证书，则必须设置此字段。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;扩展密钥用途&lt;/td&gt;
          &lt;td&gt;id-kp-serverAuth&lt;/td&gt;
          &lt;td&gt;此字段可为叶子证书或签名证书设置。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;扩展密钥用途&lt;/td&gt;
          &lt;td&gt;id-kp-clientAuth&lt;/td&gt;
          &lt;td&gt;此字段可为叶子证书或签名证书设置。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
                           
    <item>
      <title>安装 SPIRE 服务器</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/installation/install-server/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/installation/install-server/</guid>
      <description>
        
        
        &lt;p&gt;本文指导你如何在 Linux 和 Kubernetes 上安装 SPIRE 服务器。&lt;/p&gt;
&lt;h2 id=&#34;步骤-1获取-spire-二进制文件&#34;&gt;步骤 1：获取 SPIRE 二进制文件&lt;/h2&gt;
&lt;p&gt;预构建的 SPIRE 发行版可在 &lt;a href=&#34;https://spiffe.io/downloads/#spire-releases&#34; title=&#34;SPIRE 下载页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 下载页面&lt;/a&gt;找到。tarball 包含服务器和代理二进制文件。&lt;/p&gt;
&lt;p&gt;如果需要，你也可以&lt;a href=&#34;https://github.com/spiffe/spire/blob/main/CONTRIBUTING.md&#34; title=&#34;从源代码构建 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;从源代码构建 SPIRE&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;步骤-2安装服务器和代理&#34;&gt;步骤 2：安装服务器和代理&lt;/h2&gt;
&lt;p&gt;本入门指南描述了如何在同一节点上安装服务器和代理。在典型的生产部署中，服务器将安装在一个节点上，而一个或多个代理将安装在不同的节点上。&lt;/p&gt;
&lt;p&gt;要安装服务器和代理，请执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从 &lt;a href=&#34;https://spiffe.io/downloads/#spire-releases&#34; title=&#34;SPIRE 下载页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 下载页面&lt;/a&gt;获取最新的 tarball，然后使用以下命令将其解压缩到 &lt;code&gt;/opt/spire&lt;/code&gt; 目录中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://github.com/spiffe/spire/releases/download/v1.8.2/spire-1.8.2-linux-amd64-musl.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar zvxf spire-1.8.2-linux-amd64-musl.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo cp -r spire-1.8.2/. /opt/spire/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了方便起见，将 &lt;code&gt;spire-server&lt;/code&gt; 和 &lt;code&gt;spire-agent&lt;/code&gt; 添加到你的 &lt;code&gt;$PATH&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ln -s /opt/spire/bin/spire-server /usr/bin/spire-server
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ln -s /opt/spire/bin/spire-agent /usr/bin/spire-agent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;步骤-3配置服务器&#34;&gt;步骤 3：配置服务器&lt;/h2&gt;
&lt;p&gt;要在 Linux 上配置服务器，你需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置信任域&lt;/li&gt;
&lt;li&gt;配置服务器证书颁发机构（CA），可能包括配置 UpstreamAuthority 插件&lt;/li&gt;
&lt;li&gt;配置节点认证插件&lt;/li&gt;
&lt;li&gt;配置用于持久化数据的默认 &lt;code&gt;.data&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，为了简单起见，仅需完成步骤 1、2 和 3 即可快速部署演示目的。&lt;/p&gt;
&lt;p&gt;要配置步骤 1、2 和 4 中的项，请编辑服务器的配置文件，位于 &lt;code&gt;/opt/spire/conf/server/server.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有关如何配置 SPIRE 的详细信息，请参阅&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/configuring/&#34; title=&#34;配置 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 SPIRE&lt;/a&gt;，特别是节点认证和工作负载认证。&lt;/p&gt;
&lt;p&gt;注意，SPIRE 服务器在修改配置后必须重新启动才能生效。&lt;/p&gt;
&lt;p&gt;请参阅&lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/install-agents/&#34; title=&#34;安装 SPIRE 代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装 SPIRE 代理&lt;/a&gt;，了解如何安装 SPIRE 代理。&lt;/p&gt;
&lt;h1 id=&#34;如何在-kubernetes-上安装-spire-服务器&#34;&gt;如何在 Kubernetes 上安装 SPIRE 服务器&lt;/h1&gt;
&lt;p&gt;本节将逐步向你介绍在 Kubernetes 集群中运行服务器并配置工作负载容器以访问 SPIRE 的方法。&lt;/p&gt;
&lt;p&gt;你必须从包含用于配置的 &lt;code&gt;.yaml&lt;/code&gt; 文件的目录中运行所有命令。&lt;/p&gt;
&lt;h2 id=&#34;步骤-1获取所需文件&#34;&gt;步骤 1：获取所需文件&lt;/h2&gt;
&lt;p&gt;要获取所需的.yaml 文件，请克隆 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 并从 &lt;code&gt;spire-tutorials/k8s/quickstart&lt;/code&gt; 子目录复制 &lt;code&gt;.yaml&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h2 id=&#34;步骤-2为-spire-组件配置-kubernetes-命名空间&#34;&gt;步骤 2：为 SPIRE 组件配置 Kubernetes 命名空间&lt;/h2&gt;
&lt;p&gt;按照以下步骤配置部署 SPIRE 服务器和 SPIRE 代理的 spire 命名空间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建命名空间：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f spire-namespace.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行以下命令，并验证输出中是否列出了&lt;em&gt;spire&lt;/em&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get namespaces
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;步骤-3配置-spire-服务器&#34;&gt;步骤 3：配置 SPIRE 服务器&lt;/h2&gt;
&lt;p&gt;要在 Kubernetes 上配置 SPIRE 服务器，你需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建服务器服务帐户&lt;/li&gt;
&lt;li&gt;创建服务器捆绑包 ConfigMap&lt;/li&gt;
&lt;li&gt;创建服务器 ConfigMap&lt;/li&gt;
&lt;li&gt;创建服务器 StatefulSet&lt;/li&gt;
&lt;li&gt;创建服务器服务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关详细信息，请参阅以下各节。&lt;/p&gt;
&lt;h3 id=&#34;创建服务器服务帐户&#34;&gt;创建服务器服务帐户&lt;/h3&gt;
&lt;p&gt;通过应用 server-account.yaml 配置文件来配置名为 spire-server 的服务帐户：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl apply -f server-account.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过运行以下命令确认成功创建，并验证该服务帐户是否出现在以下命令的输出中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl get serviceaccount --namespace spire
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建服务器捆绑包-configmap角色和-clusterrolebinding&#34;&gt;创建服务器捆绑包 ConfigMap、角色和 ClusterRoleBinding&lt;/h3&gt;
&lt;p&gt;为了使服务器能够为代理提供证书以用于在建立连接时验证服务器的身份，服务器需要具备在 spire 命名空间中获取和修补 ConfigMap 对象的功能。&lt;/p&gt;
&lt;p&gt;在这种部署中，代理和服务器共享同一集群，SPIRE 可以配置为定期生成这些证书并将证书内容更新到 ConfigMap 中。为此，服务器需要能够在 Kubernetes RBAC 中获取和修补 ConfigMap 对象。&lt;/p&gt;
&lt;p&gt;通过应用 &lt;code&gt;spire-bundle-configmap.yaml&lt;/code&gt; 配置文件来创建名为 &lt;code&gt;spire-bundle&lt;/code&gt; 的 ConfigMap：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f spire-bundle-configmap.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过运行以下命令确认成功创建，并验证 &lt;code&gt;spire-bundle&lt;/code&gt; ConfigMap 是否列在以下命令的输出中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get configmaps --namespace spire &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep spire
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了允许服务器读取和写入此 ConfigMap，必须创建一个 ClusterRole，授予 Kubernetes RBAC 相应的特权，并将 ClusterRoleBinding 与前一步创建的服务帐户关联。&lt;/p&gt;
&lt;p&gt;通过应用 &lt;code&gt;server-cluster-role.yaml&lt;/code&gt; 配置文件来创建名为 &lt;code&gt;spire-server-trust-role&lt;/code&gt; 的 ClusterRole 和相应的 ClusterRoleBinding：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f server-cluster-role.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过运行以下命令确认成功创建，并验证 &lt;code&gt;spire-server-trust-role&lt;/code&gt; ClusterRole 是否出现在以下命令的输出中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get clusterroles --namespace spire &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep spire
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建服务器-configmap&#34;&gt;创建服务器 ConfigMap&lt;/h3&gt;
&lt;p&gt;服务器在 Kubernetes ConfigMap 中进行配置，该 ConfigMap 在 &lt;code&gt;server-configmap.yaml&lt;/code&gt; 中指定了一些重要的目录，特别是 &lt;code&gt;/run/spire/data和/run/spire/config&lt;/code&gt;。这些卷在部署服务器容器时绑定。&lt;/p&gt;
&lt;p&gt;请参阅&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/configuring/&#34; title=&#34;配置 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 SPIRE&lt;/a&gt;部分，了解如何配置 SPIRE 服务器的详细信息，特别是节点认证和工作负载认证。&lt;/p&gt;
&lt;p&gt;注意，SPIRE 服务器在修改配置后必须重新启动才能生效。&lt;/p&gt;
&lt;p&gt;使用以下命令将服务器 ConfigMap 应用到你的集群：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f server-configmap.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建服务器-statefulset&#34;&gt;创建服务器 StatefulSet&lt;/h3&gt;
&lt;p&gt;通过应用 &lt;code&gt;server-statefulset.yaml&lt;/code&gt; 配置文件来部署服务器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f server-statefulset.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在 spire 命名空间中创建一个名为 &lt;code&gt;spire-server&lt;/code&gt; 的 StatefulSet，并启动一个 &lt;code&gt;spire-server&lt;/code&gt; 的 Pod，如以下两个命令的输出所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get statefulset --namespace spire
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME           READY   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server   1/1     86m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods --namespace spire
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                           READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server-0                 1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          86m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你部署服务器时，它会自动在 SPIRE 服务器的 gRPC 端口上配置 livenessProbe，以确保容器的可用性。&lt;/p&gt;
&lt;p&gt;服务器部署时，绑定到以下表中总结的卷：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;卷&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;挂载位置&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;spire-config&lt;/td&gt;
          &lt;td&gt;引用在前一步中创建的 spire-server ConfigMap&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;/run/spire/config&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;spire-data&lt;/td&gt;
          &lt;td&gt;服务器的 SQLite 数据库和密钥文件的 hostPath&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;/run/spire/data&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;创建服务器服务&#34;&gt;创建服务器服务&lt;/h3&gt;
&lt;p&gt;通过应用 server-service.yaml 配置文件来创建服务器服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f server-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过运行以下命令确认成功创建，并验证 spire 命名空间现在是否有一个名为 &lt;code&gt;spire-server&lt;/code&gt; 的服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get services --namespace spire
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME           TYPE       CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server   NodePort   10.107.205.29   &amp;lt;none&amp;gt;        8081:30337/TCP   88m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>规范</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-id/&#34;&gt;SPIFFE ID 和 SVID&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/x509-svid/&#34;&gt;X.509 SVID&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/jwt-svid/&#34;&gt;JWT SVID&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/&#34;&gt;SPIFFE 工作负载 API&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-endpoint/&#34;&gt;SPIFFE 工作负载端点&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-trust-domain-and-bundle/&#34;&gt;SPIFFE 信任域和 Bundle&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/&#34;&gt;SPIFFE 联邦&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>注册工作负载</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/registering/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/registering/</guid>
      <description>
        
        
        &lt;p&gt;本文将指导你在 SPIRE 服务器中使用 SPIFFE ID 注册工作负载。&lt;/p&gt;
&lt;h2 id=&#34;如何创建注册条目&#34;&gt;如何创建注册条目&lt;/h2&gt;
&lt;p&gt;注册条目包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPIFFE ID&lt;/li&gt;
&lt;li&gt;一个或多个选择器集合&lt;/li&gt;
&lt;li&gt;父级 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器将向代理发送所有有权在该节点上运行的工作负载的注册条目列表。代理缓存这些注册条目并保持其更新。&lt;/p&gt;
&lt;p&gt;在工作负载认证期间，代理会发现选择器并将其与缓存的注册条目中的选择器进行比较，以确定应该为工作负载分配哪些 SVID。&lt;/p&gt;
&lt;p&gt;你可以通过在命令行中发出 &lt;code&gt;spire-server entry create&lt;/code&gt; 命令或直接调用 Entry API 来注册工作负载，具体方法请参阅 &lt;a href=&#34;https://github.com/spiffe/spire-api-sdk/blob/v1.8.2/proto/spire/api/server/entry/v1/entry.proto&#34; title=&#34;Entry API 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Entry API 文档&lt;/a&gt;。可以使用 &lt;code&gt;spire-server entry update&lt;/code&gt; 命令修改现有条目。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 上运行时，调用 SPIRE 服务器的常见方法是通过在运行 SPIRE 服务器的 Pod 上使用&lt;code&gt;kubectl exec&lt;/code&gt;命令。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -n spire spire-server-0 -- &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    /opt/spire/bin/spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID spiffe://example.org/ns/default/sa/default &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -parentID spiffe://example.org/ns/spire/sa/spire-agent &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector k8s:ns:default &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关 &lt;code&gt;spire-server entry create&lt;/code&gt; 和 &lt;code&gt;spire-server entry update&lt;/code&gt; 命令和选项的更多信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器参考指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器参考指南&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;如何注册工作负载&#34;&gt;如何注册工作负载&lt;/h2&gt;
&lt;p&gt;通过在 SPIRE 服务器中创建一个或多个注册条目来注册工作负载。要注册工作负载，需要告诉 SPIRE：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配给在工作负载有权运行的节点上运行的代理的 SPIFFE ID。&lt;/li&gt;
&lt;li&gt;运行在这些机器上的工作负载本身的属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-定义代理的-spiffe-id&#34;&gt;1. 定义代理的 SPIFFE ID&lt;/h3&gt;
&lt;p&gt;分配给代理的 SPIFFE ID 可能是作为节点认证过程的一部分自动分配的 ID。例如，当代理经过 AWS IID 节点认证时，会自动分配形式为 &lt;code&gt;spiffe://example.org/agent/aws_iid/ACCOUNT_ID/REGION/INSTANCE_ID&lt;/code&gt; 的 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;或者，可以通过创建一个指定了选择器的&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/registering/#create-registration-entry&#34; title=&#34;注册条目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;注册条目&lt;/a&gt;来为一个或多个代理分配 SPIFFE ID。例如，可以通过创建以下注册条目将 SPIFFE ID  &lt;code&gt;spiffe://acme.com/web-cluster&lt;/code&gt; 分配给在标记 &lt;code&gt;app&lt;/code&gt; 设置为 &lt;code&gt;webserver&lt;/code&gt; 的一组 EC2 实例上运行的任何 SPIRE 代理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -node &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID spiffe://acme.com/web-cluster &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector tag:app:webserver
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;选择器是 SPIRE 可以在发出身份之前验证的节点或工作负载的本机属性。单个注册条目可以包含节点选择器或工作负载选择器，但不能同时包含两者。请注意上述命令中的 &lt;code&gt;-node&lt;/code&gt; 标志，它表示此命令正在指定节点选择器。&lt;/p&gt;
&lt;p&gt;根据工作负载应用程序运行的平台或架构，提供了不同的选择器。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;平台&lt;/th&gt;
          &lt;th&gt;请访问&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Kubernetes&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_k8s_sat.md&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;AWS&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_aws_iid.md&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Azure&lt;/td&gt;
          &lt;td&gt;GitHub&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-定义工作负载的-spiffe-id&#34;&gt;2. 定义工作负载的 SPIFFE ID&lt;/h3&gt;
&lt;p&gt;一旦代理或代理有一个分配的 SPIFFE ID，就可以创建另一个注册条目来标识在调用该代理公开的工作负载 API 时的特定工作负载。&lt;/p&gt;
&lt;p&gt;例如，要创建一个注册条目，以匹配在标识为 &lt;code&gt;spiffe://acme.com/web-cluster&lt;/code&gt; 的代理上运行的 Unix 组 ID 1000 下运行的 Linux 进程，可以使用以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -parentID spiffe://acme.com/web-cluster &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -spiffeID spiffe://acme.com/webapp  &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    -selector unix:gid:1000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;平台&lt;/th&gt;
          &lt;th&gt;请访问&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Unix&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_unix.md&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Kubernetes&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_k8s.md&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Docker&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_docker.md&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;如何列出注册条目&#34;&gt;如何列出注册条目&lt;/h2&gt;
&lt;p&gt;要列出所有现有的注册条目，请使用命令 &lt;code&gt;spire-server entry show&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要将注册条目筛选为与特定 SPIFFE ID、父级 SPIFFE ID 或注册条目 ID 匹配的条目，请分别使用 &lt;code&gt;-spiffeID&lt;/code&gt;、&lt;code&gt;-parentID&lt;/code&gt;、&lt;code&gt;-selector&lt;/code&gt; 或 &lt;code&gt;-entryID&lt;/code&gt; 标志。&lt;/p&gt;
&lt;p&gt;请注意，每个注册条目都有一个唯一的注册条目 ID，但是多个注册条目可以指定相同的 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;例如，要列出与标记 &lt;code&gt;app&lt;/code&gt; 设置为 &lt;code&gt;webserver&lt;/code&gt; 的一组 EC2 实例匹配的所有注册条目，请运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server entry show -selector tag:app:webserver
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关 &lt;code&gt;spire-server entry show&lt;/code&gt; 命令和选项的更多信息，请参阅&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器参考指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器参考指南&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;如何删除注册条目&#34;&gt;如何删除注册条目&lt;/h2&gt;
&lt;p&gt;要永久删除现有的注册条目，请使用 &lt;code&gt;spire-server entry delete&lt;/code&gt; 命令，并指定相关的注册条目 ID。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server entry delete -entryID 92f4518e-61c9-420d-b984-074afa7c7002
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关 &lt;code&gt;spire-server entry delete&lt;/code&gt; 命令和选项的更多信息，请参阅  &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; title=&#34;SPIRE 服务器参考指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器参考指南&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;将工作负载映射到多个节点&#34;&gt;将工作负载映射到多个节点&lt;/h2&gt;
&lt;p&gt;工作负载注册条目可以有一个父级 ID。这可以是特定节点的 SPIFFE ID（即通过节点认证获得的代理的 SPIFFE ID），也可以是节点注册条目（有时称为节点别名/集合）的 SPIFFE ID。节点别名（或集合）是具有相似特征的一组节点，它们被赋予了一个共享的身份。节点注册条目具有节点选择器，要求节点至少具有这些选择器才能符合共享的身份。这意味着具有至少与节点注册条目中定义的选择器相同的任何节点都被赋予该别名（或属于该节点集）。当工作负载注册条目使用节点别名的 SPIFFE ID 作为父级时，具有该别名的任何节点都有权为该工作负载获取 SVID&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 的历史和动机</title>
      <link>https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/</guid>
      <description>
        
        
        &lt;p&gt;本章介绍了 SPIFFE 的动机和它是如何诞生的。&lt;/p&gt;
&lt;h2 id=&#34;压倒性的动机和需要&#34;&gt;压倒性的动机和需要&lt;/h2&gt;
&lt;p&gt;我们到达今天的位置，首先要经历一些成长的痛苦。&lt;/p&gt;
&lt;p&gt;当互联网在 1981 年首次广泛使用时，它只有 213 个不同的服务器，而安全问题&lt;a href=&#34;https://tools.ietf.org/html/rfc1296&#34; title=&#34;几乎没有被考虑到&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几乎没有被考虑到&lt;/a&gt;。随着互联计算机数量的增加，安全问题仍然是一个弱点：容易被利用的漏洞导致了大规模的攻击，如&lt;a href=&#34;https://spaf.cerias.purdue.edu/tech-reps/823.pdf&#34; title=&#34;莫里斯蠕虫病毒&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;莫里斯蠕虫病毒&lt;/a&gt;，它在 1988 年占领了互联网上的大多数 Unix 服务器，或 &lt;a href=&#34;https://www.caida.org/publications/papers/2003/sapphire/sapphire.html&#34; title=&#34;Slammer 蠕虫病毒&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slammer 蠕虫病毒&lt;/a&gt;，它在 2003 年在数十万台 Windows 服务器上传播。&lt;/p&gt;
&lt;p&gt;随着时间的推移，过去的传统周边防御模式已经不能很好地适应不断发展的计算架构和现代技术的边界。各种解决方案和技术层出不穷，以掩盖基础网络安全概念未能跟上现代化趋势而出现的越来越大的裂缝。&lt;/p&gt;
&lt;p&gt;那么，为什么周边模式如此普遍，怎样才能解决这些缺陷？&lt;/p&gt;
&lt;p&gt;多年来，我们观察到三大的趋势，突出了传统的周边模式对网络未来的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件不再在组织控制的单个服务器上运行。自 2015 年以来，新的软件通常被构建为微服务的集合，可以单独扩展或转移到云主机供应商。如果你不能在需要安全的服务周围画出一条精确的线，就不可能在它们周围筑起一道墙。&lt;/li&gt;
&lt;li&gt;你不能相信一切，即使是公司内的软件。曾经，我们认为软件漏洞就像苍蝇，我们可以单独拍打；现在，它们似乎更像一群蜜蜂。平均而言，国家漏洞数据库每年报告超过 &lt;a href=&#34;https://nvd.nist.gov/vuln/search/statistics&#34; title=&#34;15000 个新的软件漏洞&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;15000 个新的软件漏洞&lt;/a&gt;。如果你编写或购买了一个软件，它在某些时候可能会有一些漏洞。&lt;/li&gt;
&lt;li&gt;你也不能相信人，他们会犯错，会心烦意乱，再加上他们可以完全接触到内部服务。首先，每年有&lt;a href=&#34;https://www.comparitech.com/blog/vpn-privacy/phishing-statistics-facts/&#34; title=&#34;数以万计的攻击是基于网络钓鱼&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数以万计的攻击是基于网络钓鱼&lt;/a&gt;或窃取有效的员工凭证。其次，随着云计算应用和移动工作队伍的出现，员工可以合法地从许多不同的网络访问资源。当人们为了工作而不得不不断地来回穿越这堵墙时，建造一堵墙就不再有意义了。正如你所看到的，对于当今的组织来说，周界安全不再是一个现实的解决方案。当周界安全被严格执行时，阻碍了组织使用微服务和云；当周界安全松懈时，它给了入侵者可乘之机。2004 年，Jericho 论坛认识到需要一个周界安全的继承者。十年后的 2014 年，谷歌发布了一个&lt;a href=&#34;https://research.google/pubs/pub43231/&#34; title=&#34;关于 BeyondCorp 安全架构的案例研究&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于 BeyondCorp 安全架构的案例研究&lt;/a&gt;。然而，两者都没有被广泛的采用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络曾经是友好的只要我们保持自律&#34;&gt;网络曾经是友好的，只要我们保持自律&lt;/h2&gt;
&lt;p&gt;最初的互联网使用案例集中在学术界，目的是分享信息，而不是组织意外访问。当其他组织开始将联网的计算机系统用于商业敏感的场景时，他们在很大程度上依赖于物理周界和物理证明，以保证访问网络的个人得到授权。当时还不存在受信任的内部威胁的概念。随着网络从学术用途发展到商业用途，软件从单体发展到微服务，安全成为增长的障碍。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-1_hu4906597768254710182.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-1.jpg&#34; data-img=&#34;/book/spiffe/history-and-motivation-for-spiffe/f1-1.jpg&#34; data-width=&#34;1108&#34; data-height=&#34;550&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;最初，通过防火墙、网络分段、私有地址空间和 ACL 来模拟墙和警卫来保护计算机的物理访问的传统方法。这在当时是有意义的，特别是考虑到需要控制的点的数量有限。&lt;/p&gt;
&lt;p&gt;随着网络的扩散，以及用户和商业伙伴访问点的增加，通过安全地交换和管理密钥、凭证和令牌，物理身份验证（常见于墙和警卫）变得虚拟化，随着技术和需求的发展，所有这些都变得越来越有问题。&lt;/p&gt;
&lt;h2 id=&#34;采用公共云&#34;&gt;采用公共云&lt;/h2&gt;
&lt;p&gt;从传统的内部部署和数据中心运作迁移到公共云，放大了现有问题。&lt;/p&gt;
&lt;p&gt;随着人们获得了在云中创建计算资源的自由，企业内的开发团队和运维团队开始更紧密地合作，并围绕着专注于软件自动化部署和管理的 DevOps 概念形成新的团队。公共云快速发展的动态环境使团队能够更频繁地进行部署 —— 从每几个月部署一次，到每天部署多次。按需配置和部署资源的能力使人们能够高速创建专门的、有针对性的、可独立部署的服务套件，其责任范围较小，俗称为&lt;strong&gt;微服务&lt;/strong&gt;。这反过来又增加了跨部署集群识别和访问服务的需要。&lt;/p&gt;
&lt;p&gt;这种高度动态和弹性的环境打破了公认的边界安全概念，需要更好的服务水平互动，与基础网络无关。传统的边界执行使用 IP 和端口进行认证、授权和审计，在云计算范式下，这不再是干净地映射到工作负载。&lt;/p&gt;
&lt;p&gt;公共云的参与所激发的模式，如 API 网关或用于多服务工作负载的管理的负载均衡器，强调了对不依赖网络拓扑或路径的身份的需求。保护这些服务间的通信的完整性变得更加重要，特别是对于需要跨工作负载统一性的团队。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-2_hu6996013322462300558.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-2.jpg&#34; data-img=&#34;/book/spiffe/history-and-motivation-for-spiffe/f1-2.jpg&#34; data-width=&#34;1060&#34; data-height=&#34;1458&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;休斯顿我们有一个问题&#34;&gt;休斯顿，我们有一个问题&lt;/h2&gt;
&lt;p&gt;随着企业采用新技术，如容器、微服务、云计算和无服务器功能，有一个趋势是明确的：更多更小的软件。这既增加了攻击者可以利用的潜在漏洞的数量，也使得管理周边防御越来越不现实。&lt;/p&gt;
&lt;p&gt;这种趋势正在加快，这意味着越来越多的组件被部署在自动化基础设施上，往往牺牲了安全和保障。绕过手动流程，如防火墙规则票或安全组的变化，并非闻所未闻。在这个新的现代世界里，无论部署环境如何，面向网络的访问控制都会迅速过时，需要不断维护。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-3_hu4764027386742669446.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-3.jpg&#34; data-img=&#34;/book/spiffe/history-and-motivation-for-spiffe/f1-3.jpg&#34; data-width=&#34;1036&#34; data-height=&#34;734&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;这些规则和例外情况的管理可以自动化，然而，它们需要迅速发生，这在较大的基础设施中可能是一个挑战。此外，网络拓扑结构，如网络地址转换（NAT），会使其变得困难。随着基础设施变得越来越大，越来越动态，依靠人力的系统根本无法扩展。毕竟，没有人愿意花钱请一个整天玩弄防火墙规则的团队，而他们仍然无法跟上需求的进度。&lt;/p&gt;
&lt;p&gt;依靠特定地点的细节，如服务器名称、DNS 名称、网络接口细节，在一个动态调度和弹性扩展的应用世界里有几个缺点。虽然网络结构的使用很普遍，但该模型是软件身份的一个无效的模拟。在应用层，使用传统的用户名和密码组合或其他硬编码的凭证，可以赋予一定程度的身份，但更多的是处理授权而不是认证。&lt;/p&gt;
&lt;p&gt;在软件开发生命周期的早期整合安全并引入反馈，使开发人员能够对其工作负载的识别和信息交换机制进行更多的操作控制。有了这种变化，授权政策的决定可以委托给个别服务或产品所有者，他们最适合做出与有关组件相关的决定。&lt;/p&gt;
&lt;h2 id=&#34;重新认识访问控制&#34;&gt;重新认识访问控制&lt;/h2&gt;
&lt;p&gt;在采用公有云之前，企业所经历的问题不断增加，而采用公有云后，企业又痛苦地出现了问题，这就推动了传统的周界是不够的，需要有更好的解决方案的概念。最终，去边界化意味着企业需要弄清楚如何识别他们的软件并实现服务对服务的访问控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案之一：秘密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;像密码和 API 密钥这样的共享秘密为分布式系统的访问控制提供了一个简单的选择。但这种解决方案也带来了许多问题。密码和 API 密钥很容易被泄露（试着在 GitHub 上搜索 &amp;ldquo;client_secret&amp;rdquo; 这样的短语，看看会发生什么）。在大型组织中，秘密可能很难因泄露而轮换，因为每个服务都需要以一种协调的方式意识到变化（而错过一个服务可能会导致停工）。&lt;/p&gt;
&lt;p&gt;诸如 HashiCorp Vault 这样的工具和秘密存储库已经被开发出来，以帮助缓解秘密管理和生命周期的困难。虽然也有许多其他工具试图解决这个问题，但它们往往提供了一个更加有限的解决方案，效果平平（见 &lt;a href=&#34;https://www.youtube.com/watch?v%3D15H5uCj1hlE&#34; title=&#34;Secrets at Scale: Automated Bootstrapping of Secrets &amp;amp; Identity in the Cloud&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Secrets at Scale: Automated Bootstrapping of Secrets &amp;amp; Identity in the Cloud&lt;/a&gt;）。有了所有这些选择，我们最终还是回到了同一个问题上：工作负载应该如何获得对这个秘密库的访问？仍然需要一些 API 密钥、密码或其他秘密。&lt;/p&gt;
&lt;p&gt;所有这些解决方案最终都会出现“乌龟下面还有一只乌龟&amp;quot; 的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启用对资源的访问控制，如数据库或其他资源。&lt;/li&gt;
&lt;li&gt;服务需要一个秘密，如 API 密钥或密码。&lt;/li&gt;
&lt;li&gt;该钥匙或密码需要被保护，所以你可以保护它，比如说用加密。但是，你仍然担心密码的解密密钥。&lt;/li&gt;
&lt;li&gt;该解密密钥可以被放入秘密库，但这样你仍然需要一些凭证，如密码或 API 密钥来访问秘密库。&lt;/li&gt;
&lt;li&gt;最终，为了保护对秘密的访问会产生需要保护的一个新秘密。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了打破这个循环，我们需要找到一个底层乌龟，也就是说，一些秘密提供了对我们所需的认证和访问控制的其他秘密的访问。一种选择是在服务部署时手动提供秘密。然而，这在高度动态的生态系统中是无法扩展的。随着企业转向具有快速部署管道和自动扩展资源的云计算，随着新计算单元的创建，手动配置秘密变得不可行。而当一个秘密被破坏时，使旧的凭证失效会带来使整个系统崩溃的风险。&lt;/p&gt;
&lt;p&gt;在应用程序中嵌入一个秘密，这样它就不需要手动配置了，其安全属性甚至更差。嵌入到源代码中的秘密有一个习惯，那就是出现在公共存储库中（你试过我建议的 GitHub 搜索吗）。虽然秘密可以在构建时被嵌入到机器镜像中，但这些镜像最终还是会被意外地推送到公共镜像库中，或者作为杀毒链的第二步从内部镜像库中提取。&lt;/p&gt;
&lt;p&gt;我们希望有一种解决方案，不包括长期存在的秘密（这些秘密很容易被破坏，也很难轮换），也不需要人工向工作负载提供秘密。为了实现这一点，无论是在硬件还是在云提供商，都&lt;strong&gt;必须有一个信任的根&lt;/strong&gt;，&lt;strong&gt;在此基础上建立一个以软件（工作负载）身份为中心的自动化解决方案&lt;/strong&gt;。然后，这种身份构成了所有需要认证和授权的互动的基础。为了避免产生另一个底层乌龟，工作负载需要能够在没有秘密或其他凭证的情况下获得这一身份。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-4_hu6966204097680878215.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-4.jpg&#34; data-img=&#34;/book/spiffe/history-and-motivation-for-spiffe/f1-4.jpg&#34; data-width=&#34;598&#34; data-height=&#34;600&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;迈向未来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自 2010 年以来，业界为解决软件身份问题进行了多种努力。谷歌的低开销认证服务（LOAS），后来被命名为&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security/&#34; title=&#34;应用层传输安全（ALTS）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用层传输安全（ALTS）&lt;/a&gt;，建立了一个新的身份格式和有线协议，用于从运行时环境接收软件身份，并将其应用于所有网络通信。它被称为&lt;strong&gt;拨号音安全（dial tone security）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在另一个例子中，Netflix 的内部开发的解决方案（代号为 &lt;a href=&#34;https://www.usenix.org/sites/default/files/conference/protected-files/enigma_haken_slides.pdf&#34; title=&#34;Metatron&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Metatron&lt;/a&gt;）通过利用云 API 来证明实例上运行的机器镜像，并通过 CI/CD 集成来产生机器镜像和代码身份之间的加密绑定，从而在每个实例基础上建立软件身份。这种软件身份采取 X.509 证书的形式，对服务间的通信进行相互认证，包括访问作为该解决方案一部分开发的&lt;strong&gt;秘密服务&lt;/strong&gt;，在此基础上实现秘密管理。&lt;/p&gt;
&lt;p&gt;业界的其他一些努力，包括来自 &lt;a href=&#34;https://engineering.fb.com/security/service-encryption/&#34; title=&#34;Facebook 等公司的努力&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Facebook 等公司的努力&lt;/a&gt;，证明了对这样一个系统的需要，并强调了实施的难度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普适安全生产身份框架（SPIFFE）的愿景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在成立通用的解决方案之前，需要建立一个框架编码原则。Kubernetes 的创始工程师 Joe Beda 在过去的工作中接触过各种技术，这些技术使工程团队的生活更加轻松，他在 2016 年开始呼吁为生产身份创建一个解决方案，作为一个专门的解决方案，旨在以一种通用的方式解决问题，可以在许多不同类型的系统中利用，而不是以艰难的方式进行 PKI 的中间解决方案。这种公司之间的大规模合作努力，为基于 PKI 的服务身份开发了一个新的标准，这就是 SPIFFE 的开始。&lt;/p&gt;
&lt;p&gt;2016 年 Beda 在 &lt;a href=&#34;https://engineering.fb.com/security/service-encryption/&#34; title=&#34;GlueCon 上发表的论文&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GlueCon 上发表的论文&lt;/a&gt;展示了一个具有这些参数的难题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过利用基于内核的自省来获得关于调用者的信息，而无需调用者出示凭证，从而解决零号秘密的问题。&lt;/li&gt;
&lt;li&gt;使用 X.509，因为大多数软件已经兼容，而且&lt;/li&gt;
&lt;li&gt;有效地将身份的概念从网络定位器中剥离出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在引入 SPIFFE 概念之后，Netflix 服务认证方面的专家举行了一次会议，讨论原始 SPIFFE 提案的最终形态和可行性。许多成员已经实施了、继续改进并重新解决了工作负载识别问题，突出了社区合作的机会。参加会议的成员希望获得彼此之间的互操作性。这些专家意识到他们已经实施了类似的解决方案来解决同样的问题，可以建立一个共同的标准。&lt;/p&gt;
&lt;p&gt;解决工作负载身份问题的最初目标是建立一个开放的规范和相应的生产实现。该框架需要在不同的实现和现成的软件之间提供互操作性，其核心是在一个不信任的环境中建立信任的根基，驱除隐性信任。最后，摆脱以网络为中心的身份，以实现灵活性和更好的扩展特性。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-5_hu6001913589435065835.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/history-and-motivation-for-spiffe/f1-5.jpg&#34; data-img=&#34;/book/spiffe/history-and-motivation-for-spiffe/f1-5.jpg&#34; data-width=&#34;1104&#34; data-height=&#34;622&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;

      </description>
    </item>
                           
    <item>
      <title>出版信息</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/publication-information/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/publication-information/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cybersecurity and Infrastructure Security Agency (CISA)&lt;/p&gt;
&lt;p&gt;National Security Agency (NSA) Cybersecurity Directorate Endpoint Security&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联系信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户要求 / 一般网络安全问题。&lt;/p&gt;
&lt;p&gt;网络安全需求中心，410-854-4200，&lt;a href=&#34;mailto:Cybersecurity_Requests@nsa.gov&#34; title=&#34;Cybersecurity_Requests@nsa.gov&#34;&gt;Cybersecurity_Requests@nsa.gov&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;媒体咨询&lt;/strong&gt; / &lt;strong&gt;新闻台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;媒体关系，443-634-0721，&lt;a href=&#34;mailto:MediaRelations@nsa.gov&#34; title=&#34;MediaRelations@nsa.gov&#34;&gt;MediaRelations@nsa.gov&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于事件响应资源，请联系 CISA：&lt;a href=&#34;mailto:CISAServiceDesk@cisa.dhs.gov&#34; title=&#34;CISAServiceDesk@cisa.dhs.gov&#34;&gt;CISAServiceDesk@cisa.dhs.gov&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于本书中文版的信息请联系 Jimmy Song：&lt;a href=&#34;mailto:jimmysong@jimmysong.io&#34; title=&#34;jimmysong@jimmysong.io&#34;&gt;jimmysong@jimmysong.io&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宗旨&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国家安全局和 CISA 制定本文件是为了促进其各自的网络安全，包括其制定和发布网络安全规范和缓解措施的责任。这一信息可以被广泛分享，以触达所有适当的利益相关者。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>执行摘要</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/executive-summary/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/executive-summary/</guid>
      <description>
        
        
        &lt;p&gt;云原生应用已经发展成为一个标准化的架构，由以下部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个松散耦合的组件被称为微服务（通常或典型地以容器形式实现）。&lt;/li&gt;
&lt;li&gt;一个应用服务基础设施，为用户、服务和设备提供安全通信、认证和授权等服务（例如，服务网格）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于安全、商业竞争力和其固有的结构（松散耦合的应用组件），这类应用需要一个不同的应用、部署和运行时监控范式 —— 统称为软件生命周期范式。DevSecOps（分别由开发、安全和运维的首字母缩写组成）是这些应用的开发、部署和运维的促进范式之一，其基本要素包括持续集成、持续交付和持续部署（CI/CD）管道。&lt;/p&gt;
&lt;p&gt;CI/CD 管道是将开发人员的源代码通过各个阶段的工作流程，如构建、功能测试、安全扫描漏洞、打包和部署，由带有反馈机制的自动化工具支持。在本文中，应用环境中涉及的整个源代码集被分为五种代码类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用代码，它体现了执行一个或多个业务功能的应用逻辑。&lt;/li&gt;
&lt;li&gt;应用服务代码，用于服务，如会话建立、网络连接等。&lt;/li&gt;
&lt;li&gt;基础设施即代码，它是以声明性代码的形式存在的计算、网络和存储资源。&lt;/li&gt;
&lt;li&gt;策略即代码，这是运行时策略（例如，零信任），以声明性代码的形式表达。&lt;/li&gt;
&lt;li&gt;可观测性即代码，用于持续监测应用程序的健康状况，其中监测功能被表述为声明性代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，可以为所有五个代码类型创建单独的 CI/CD 管道。还描述了这些代码类型中的每一种所执行的功能，以强调它们在整个应用程序的执行中所发挥的作用。&lt;/p&gt;
&lt;p&gt;虽然云原生应用有一个共同的架构堆栈，但堆栈组件运行的平台可能有所不同。该平台是物理（裸机）或虚拟化（如 Kubernetes）上的一个抽象层。为了在本文中明确提及该平台或应用环境，它被称为 &lt;strong&gt;DevSecOps 原语参考平台&lt;/strong&gt;，或简称为 &lt;strong&gt;参考平台&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文件的目的是为参考平台的 DevSecOps 原语的实施提供指导。本文还介绍了这种实施对高安全保障的好处，以及在管道内使用风险管理工具和仪表盘指标提供持续授权操作（C-ATO）的工件。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>使用 Envoy 和 JWT-SVID 进行安全的微服务通信</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt/</guid>
      <description>
        
        
        &lt;p&gt;本教程在&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/envoy-x509/&#34; title=&#34;SPIRE Envoy-X.509 教程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Envoy-X.509 教程&lt;/a&gt;的基础上构建，演示如何使用 SPIRE 代替 X.509 SVID 进行工作负载的 JWT SVID 身份验证。在这个教程中展示了实现 JWT SVID 身份验证所需的更改，因此你应该首先运行或至少阅读 X.509 教程。&lt;/p&gt;
&lt;p&gt;为了说明 JWT 身份验证，我们在 Envoy X.509 教程中使用的每个服务中添加了 sidecar。每个 sidecar 都充当 Envoy 的&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.25.1/intro/arch_overview/security/ext_authz_filter#arch-overview-ext-authz&#34; title=&#34;外部授权过滤器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;外部授权过滤器&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt/SPIRE-Envoy_JWT-SVID_diagram_hu15186891211203114652.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt/SPIRE-Envoy_JWT-SVID_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-jwt/SPIRE-Envoy_JWT-SVID_diagram.png&#34; data-width=&#34;2518&#34; data-height=&#34;863&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;如图所示，前端服务通过 Envoy 实例连接到后端服务，这些服务之间通过 Envoy 建立的 mTLS 连接进行通信。Envoy 通过携带的 JWT-SVID 进行身份验证的 HTTP 请求通过 mTLS 连接发送，并由 SPIRE Agent 提供和验证。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学习如何：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 Envoy JWT Auth Helper gRPC 服务添加到 Envoy X.509 教程中现有的前端和后端服务中&lt;/li&gt;
&lt;li&gt;将外部授权过滤器添加到 Envoy 配置中，将 Envoy 连接到 Envoy JWT Auth Helper&lt;/li&gt;
&lt;li&gt;在 SPIRE Server 上为 Envoy JWT Auth Helper 实例创建注册条目&lt;/li&gt;
&lt;li&gt;使用 SPIRE 测试成功的 JWT 身份验证&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;先决条件&#34;&gt;先决条件&lt;/h1&gt;
&lt;h2 id=&#34;支持外部-ip&#34;&gt;支持外部 IP&lt;/h2&gt;
&lt;p&gt;此教程需要一个可以分配外部 IP（例如&lt;a href=&#34;https://metallb.universe.tf/&#34; title=&#34;metallb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metallb&lt;/a&gt;）的负载均衡器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待 metallb 启动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; --namespace metallb-system &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --for&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ready pod &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;metallb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --timeout&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;90s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 metallb 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f ../envoy-x509/metallb-config.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;auth-helper-镜像&#34;&gt;Auth helper 镜像&lt;/h2&gt;
&lt;p&gt;使用 Envoy-jwt-auth-helper 实现了一个外部授权过滤器，提供了一个脚本来方便地使用 &lt;code&gt;kind&lt;/code&gt; 或 &lt;code&gt;minikube&lt;/code&gt; 构建和导入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash ./scripts/build-helper.sh kind
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;之前的-spire-安装&#34;&gt;之前的 SPIRE 安装&lt;/h2&gt;
&lt;p&gt;在继续之前，请查看以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你需要访问通过 SPIRE Envoy-X.509 教程*配置的 Kubernetes 环境。你也可以使用下面描述的 &lt;code&gt;pre-set-env.sh&lt;/code&gt; 脚本创建 Kubernetes 环境。&lt;/li&gt;
&lt;li&gt;本教程所需的 YAML 文件可以在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;k8s/envoy-jwt&lt;/code&gt; 目录中找到。如果你尚未克隆&lt;em&gt;SPIRE Envoy-X.509 教程&lt;/em&gt;的存储库，请立即克隆它。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 Kubernetes 的&lt;em&gt;SPIRE Envoy-X.509 教程&lt;/em&gt;环境不可用，你可以使用以下脚本创建它，并将其作为本教程的起点。从 &lt;code&gt;k8s/envoy-jwt&lt;/code&gt; 目录中运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/pre-set-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该脚本将创建集群中 SPIRE Server 和 SPIRE Agent 所需的所有资源，然后将为 SPIRE Envoy X.509 教程创建所有资源，这是本 SPIRE Envoy JWT 教程的基本场景。&lt;/p&gt;
&lt;h1 id=&#34;第-1-部分部署更新和新资源&#34;&gt;第 1 部分：部署更新和新资源&lt;/h1&gt;
&lt;p&gt;假设 SPIRE Envoy X.509 教程是一个起点，需要更新一些资源并创建其他资源。目标是通过 JWT SVID 对工作负载进行身份验证。Envoy 实例之间已经建立了 mTLS 连接，可以在请求头中传输 JWT SVID。因此，缺失的部分是如何获取 JWT 并将其插入请求中，以及在另一侧进行验证。本教程中应用的解决方案包括在 Envoy 上配置外部授权过滤器，该过滤器根据配置模式注入或验证 JWT SVID。关于此示例服务器的详细信息，请参见&lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-jwt/readme/#about-envoy-jwt-auth-helper&#34; title=&#34;关于 Envoy JWT Auth Helper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于 Envoy JWT Auth Helper&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;关于-envoy-jwt-auth-helper&#34;&gt;关于 Envoy JWT Auth Helper&lt;/h2&gt;
&lt;p&gt;Envoy JWT Auth Helper（&lt;code&gt;auth-helper&lt;/code&gt; 服务）是一个简单的 gRPC 服务，实现了 Envoy 的 External Authorization Filter。它是为本教程开发的，以演示如何注入或验证 JWT SVID。&lt;/p&gt;
&lt;p&gt;对于发送到 Envoy 转发代理的每个 HTTP 请求，Envoy JWT Auth Helper 从 SPIRE Agent 获取 JWT-SVID，并将其作为新的请求头注入，然后发送给 Envoy。另一方面，当 HTTP 请求到达反向代理时，Envoy External Authorization 模块将请求发送到 Envoy JWT Auth Helper，后者从标头中提取 JWT-SVID，然后连接到 SPIRE Agent 执行验证。验证成功后，请求将返回给 Envoy。如果验证失败，则拒绝请求。&lt;/p&gt;
&lt;p&gt;在内部，Envoy JWT Auth Helper 利用&lt;a href=&#34;https://github.com/spiffe/go-spiffe/&#34; title=&#34;go-spiffe&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-spiffe&lt;/a&gt;库，该库公开了获取和验证 JWT SVID 所需的所有功能。以下是代码的主要部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 使用 SPIRE 提供的 Unix 域套接字创建配置源的选项。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;clientOptions&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;workloadapi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithClientOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;workloadapi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithAddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SocketPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建 workloadapi.JWTSource 实例以从工作负载 API 中获取最新的 JWT 批。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jwtSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;workloadapi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewJWTSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;clientOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;无法创建JWTSource：%v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;jwtSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 获取将添加到请求头中的 JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jwtSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jwtSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;FetchJWTSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;jwtsvid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nx&#34;&gt;Audience&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;audience&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;forbiddenResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;PERMISSION_DENIED&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 解析并验证令牌与 jwtSource 获取的批对比。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;jwtsvid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ParseAndValidate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;jwtSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;audience&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;forbiddenResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;PERMISSION_DENIED&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：&lt;code&gt;workloadapi&lt;/code&gt; 和 &lt;code&gt;jwtsvid&lt;/code&gt; 是从 &lt;code&gt;go-spiffe&lt;/code&gt; 库导入的。&lt;/p&gt;
&lt;h2 id=&#34;更新部署&#34;&gt;更新部署&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;auth-helper&lt;/code&gt; 服务使得 Envoy 能够注入或验证携带 JWT-SVID 的身份验证头，如上所述。在这些部分中，&lt;code&gt;k8s/backend/config/envoy.yaml&lt;/code&gt; 中的 YAML 文件片段说明了将 JWT 身份验证添加到在&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/envoy-x509/&#34; title=&#34;SPIRE Envoy-X.509 教程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Envoy-X.509 教程&lt;/a&gt;中定义的 &lt;code&gt;backend&lt;/code&gt; 服务所需的更改。其他 YAML 文件也对其他两个服务（&lt;code&gt;frontend&lt;/code&gt; 和 &lt;code&gt;frontend-2&lt;/code&gt;）应用了相同的更改，但是本文档中不会详细描述这些更改，以避免不必要的重复。你无需手动对 YAML 文件进行这些更改。新文件已包含在 &lt;code&gt;k8s/envoy-jwt/k8s&lt;/code&gt; 目录中。必须将此新的 &lt;code&gt;auth-helper&lt;/code&gt; 服务作为 sidecar 添加，并且必须配置它与 SPIRE Agent 通信。通过挂载卷来共享 SPIRE Agent 提供的 Unix 域套接字来实现这一目标。通过新的第二个卷，可以访问使用服务配置定义的 configmap。下面是来自 &lt;code&gt;containers&lt;/code&gt; 部分的代码片段，描述了这些更改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;auth-helper&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy-jwt-auth-helper:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IfNotPresent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/run/envoy-jwt-auth-helper/config/envoy-jwt-auth-helper.conf&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9010&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy-jwt-auth-helper-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/run/envoy-jwt-auth-helper/config&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire-agent-socket&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/run/spire/sockets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;spire-agent-socket&lt;/code&gt; 卷已在部署中定义，无需再次添加。要将 configmap &lt;code&gt;envoy-jwt-auth-helper-config&lt;/code&gt; 添加到 &lt;code&gt;volumes&lt;/code&gt; 部分，可以使用以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy-jwt-auth-helper-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;be-envoy-jwt-auth-helper-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;添加外部授权过滤器&#34;&gt;添加外部授权过滤器&lt;/h2&gt;
&lt;p&gt;接下来，在 Envoy 配置中需要一个外部授权过滤器，该过滤器连接到新的服务。这个新的 HTTP 过滤器调用了刚刚添加到部署中的 &lt;code&gt;auth-helper&lt;/code&gt; 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;http_filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.http.ext_authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transport_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ext-authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是外部授权过滤器的相应集群配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ext-authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;1s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;strict_dns&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http2_protocol_options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;load_assignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ext-authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lb_endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;9010&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;应用新资源&#34;&gt;应用新资源&lt;/h2&gt;
&lt;p&gt;为了使新的配置生效，需要重新部署服务。让我们删除 &lt;code&gt;backend&lt;/code&gt; 和 &lt;code&gt;frontend&lt;/code&gt; 部署以便更新它们：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl delete deployment backend
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl delete deployment frontend
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;确保当前工作目录是 &lt;code&gt;.../spire-tutorials/k8s/envoy-jwt&lt;/code&gt;，然后使用以下命令部署新资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -k k8s/.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-envoy configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/be-envoy-jwt-auth-helper-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/fe-envoy-jwt-auth-helper-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/frontend-envoy configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/backend configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/frontend configured
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;创建注册条目&#34;&gt;创建注册条目&lt;/h2&gt;
&lt;p&gt;为了获取或验证由 SPIRE 发行的 JWT SVID，需要对 &lt;code&gt;auth-helper&lt;/code&gt; 实例在 SPIRE 服务器上进行身份验证。可以使用以下 Bash 脚本为每个实例创建注册条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash create-registration-entries.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;脚本运行后，将显示新的注册条目列表。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;...
Creating registration entry for the backend - auth-server...
Entry ID      : ecb140ab-50a7-4590-9fe0-d715ada67f29
SPIFFE ID     : spiffe://example.org/ns/default/sa/default/backend
Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
TTL           : 3600
Selector      : k8s:ns:default
Selector      : k8s:sa:default
Selector      : k8s:pod-label:app:backend
Selector      : k8s:container-name:auth-helper

Creating registration entry for the frontend - auth-server...
Entry ID      : 59a127fa-328c-4115-883e-5ee20b86714f
SPIFFE ID     : spiffe://example.org/ns/default/sa/default/frontend
Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
TTL           : 3600
Selector      : k8s:ns:default
Selector      : k8s:sa:default
Selector      : k8s:pod-label:app:frontend
Selector      : k8s:container-name:auth-helper
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，新服务的选择器指向 &lt;code&gt;auth-helper&lt;/code&gt; 容器：&lt;code&gt;k8s:container-name:auth-helper&lt;/code&gt;。这是为了对 &lt;code&gt;auth-helper&lt;/code&gt; 服务进行身份验证，以便它可以获取或验证配置为每个请求的身份验证标头的 JWT SVID。&lt;/p&gt;
&lt;p&gt;有意地，&lt;code&gt;frontend-2&lt;/code&gt; 服务没有注册条目。稍后将添加它，以演示在请求标头中没有 JWT-SVID 时，外部授权过滤器将拒绝请求。&lt;/p&gt;
&lt;h1 id=&#34;第二部分测试连接&#34;&gt;第二部分：测试连接&lt;/h1&gt;
&lt;p&gt;既然服务已经部署并在 SPIRE 中注册，让我们来测试我们配置的授权机制。&lt;/p&gt;
&lt;h2 id=&#34;测试有效和无效的-jwt-svid&#34;&gt;测试有效和无效的 JWT-SVID&lt;/h2&gt;
&lt;p&gt;第一组测试将演示如何通过有效的 JWT-SVID 来显示关联数据，以及如何通过无效的 JWT-SVID 阻止关联数据的显示。为了运行这些测试，我们需要找到组成用于访问数据的 URL 的 IP 地址和端口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get services
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME            TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backend-envoy   ClusterIP      None            &amp;lt;none&amp;gt;           9001/TCP         10m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend        LoadBalancer   10.96.226.176   172.18.255.200   3000:32314/TCP   10m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend-2      LoadBalancer   10.96.33.198    172.18.255.201   3002:31797/TCP   10m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes      ClusterIP      10.96.0.1       &amp;lt;none&amp;gt;           443/TCP          55m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;frontend&lt;/code&gt; 服务将在 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 值和端口 &lt;code&gt;3000&lt;/code&gt; 上提供。在上面显示的示例输出中，要访问的 URL 是 &lt;code&gt;http://172.18.255.200:3000&lt;/code&gt;。打开浏览器，并在你的环境中的 &lt;code&gt;frontend&lt;/code&gt; 的 IP 地址后面添加端口 &lt;code&gt;:3000&lt;/code&gt;。页面加载完成后，你将看到用户&lt;em&gt;Jacob Marley&lt;/em&gt;的帐户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
&lt;/figure&gt;
&lt;p&gt;另一方面，当你连接到 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 URL（例如 &lt;code&gt;http://172.18.255.201:3002&lt;/code&gt;）时，浏览器只显示标题而没有任何帐户详细信息。这是因为 &lt;code&gt;frontend-2&lt;/code&gt; 服务没有在请求中包含 JWT 令牌。请求中缺少有效的令牌使得位于 &lt;code&gt;backend&lt;/code&gt; 前面的 Envoy 实例拒绝该请求。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
&lt;/figure&gt;
&lt;p&gt;让我们来看看 &lt;code&gt;auth-helper&lt;/code&gt; 容器的日志，以了解幕后发生了什么。以下是与 &lt;code&gt;frontend&lt;/code&gt; 服务并行运行的 &lt;code&gt;auth-helper&lt;/code&gt; 实例的日志。在这种情况下，&lt;code&gt;auth-helper&lt;/code&gt; 服务器配置为以注入模式运行。对于每个请求，它将 JWT-SVID 作为新的请求头注入并将其返回给将其转发给 &lt;code&gt;backend&lt;/code&gt; 的 Envoy 实例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl logs -f --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;frontend -c auth-helper
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Envoy JWT Auth Helper running in jwt_injection mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Starting gRPC Server at &lt;span class=&#34;m&#34;&gt;9011&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;JWT-SVID injected. Sending response with &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; new headers
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;JWT-SVID injected. Sending response with &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; new headers
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;JWT-SVID injected. Sending response with &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; new headers
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一方面，位于 &lt;code&gt;backend&lt;/code&gt; 服务前面的 &lt;code&gt;auth-helper&lt;/code&gt; 实例配置为以验证模式运行，因此它将检查请求标头中的 JWT-SVID。它提取令牌并对其进行验证。在这种情况下，前三个请求的令牌是有效的，然后将其发送回 Envoy 实例。这些请求来自 &lt;code&gt;frontend&lt;/code&gt; 服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl logs -f --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;backend -c auth-helper
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Envoy JWT Auth Helper running in jwt_svid_validator mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Starting gRPC Server at &lt;span class=&#34;m&#34;&gt;9010&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Token is valid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Token is valid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Token is valid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Invalid or unsupported authorization header: &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Invalid or unsupported authorization header: &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Invalid or unsupported authorization header: &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当请求来自 &lt;code&gt;frontend-2&lt;/code&gt; 服务时（最后 3 条日志记录），&lt;code&gt;auth-helper&lt;/code&gt; 无法从请求中获取 JWT-SVID 并将其拒绝。这就是为什么在 &lt;code&gt;frontend-2&lt;/code&gt; 服务的浏览器中不显示帐户详细信息的原因。&lt;/p&gt;
&lt;h2 id=&#34;使用有效的-jwt-svid-重新测试-frontend-2&#34;&gt;使用有效的 JWT-SVID 重新测试 frontend-2&lt;/h2&gt;
&lt;p&gt;为了使 &lt;code&gt;frontend-2&lt;/code&gt; 能够成功进行 JWT-SVID 身份验证，我们将更新 Kubernetes 环境，使 &lt;code&gt;frontend-2&lt;/code&gt; 具有与 &lt;code&gt;frontend&lt;/code&gt; 类似的设置。这包括为 &lt;code&gt;auth-helper&lt;/code&gt; 服务创建一个新的容器，为 &lt;code&gt;auth-helper&lt;/code&gt; 创建一个新的 configmap，以及使用外部授权过滤器更新 &lt;code&gt;frontend-2-envoy&lt;/code&gt; 的 configmap。让我们先删除 &lt;code&gt;frontend-2&lt;/code&gt; 的部署，以准备新的配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl delete deployment frontend-2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要更新 &lt;code&gt;frontend-2&lt;/code&gt; 的 Envoy 配置和服务部署，请使用 &lt;code&gt;k8s/frontend-2/kustomization.yaml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -k k8s/frontend-2/.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/fe-2-envoy-jwt-auth-helper-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/frontend-2-envoy configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/frontend-2 created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，通过为 &lt;code&gt;auth-helper&lt;/code&gt; 服务在 SPIRE Server 中创建一个新的注册条目来对其进行身份验证：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash k8s/frontend-2/create-registration-entry.sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Creating registration entry &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; the frontend-2 - auth-server...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Entry ID      : bd0acd51-0d36-42be-8999-fccdcf1f33da
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SPIFFE ID     : spiffe://example.org/ns/default/sa/default/frontend-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Parent ID     : spiffe://example.org/ns/spire/sa/spire-agent
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TTL           : &lt;span class=&#34;m&#34;&gt;3600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector      : k8s:ns:default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector      : k8s:sa:default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector      : k8s:pod-label:app:frontend-2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Selector      : k8s:container-name:auth-helper
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待一些时间，让部署传播后再次尝试在浏览器中查看 &lt;code&gt;frontend-2&lt;/code&gt; 服务。一旦 Pod 准备好并且注册条目传播完毕，请使用 &lt;code&gt;frontend-2&lt;/code&gt; 服务的正确 URL（例如 &lt;code&gt;http://35.222.190.182:3002&lt;/code&gt;）刷新浏览器。结果，现在页面显示用户&lt;em&gt;Alex Fergus&lt;/em&gt;的帐户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
&lt;/figure&gt;
&lt;h1 id=&#34;清理&#34;&gt;清理&lt;/h1&gt;
&lt;p&gt;完成本教程后，你可以使用以下命令删除用于配置 Envoy 代表工作负载执行 JWT SVID 身份验证的所有资源。此命令将删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为 SPIRE - Envoy JWT 集成教程创建的所有资源。&lt;/li&gt;
&lt;li&gt;为 SPIRE - Envoy X.509 集成教程创建的所有资源。&lt;/li&gt;
&lt;li&gt;SPIRE 代理、SPIRE 服务器和命名空间的所有部署和配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/clean-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>JWT SPIFFE 可验证身份文档</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/jwt-svid/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/jwt-svid/</guid>
      <description>
        
        
        &lt;p&gt;JWT-SVID 是 SPIFFE 规范集中的第一个基于令牌的 SVID。旨在在解决跨第 7 层边界断言身份时提供即时价值，与现有应用程序和库的兼容性是核心要求。&lt;/p&gt;
&lt;p&gt;JWT-SVID 是一种带有一些限制的标准 JWT 令牌。JOSE 在安全实现上一直存在困难，在安全社区中被认为是一项可能在部署和实现中引入漏洞的技术。JWT-SVID 采取措施尽量减轻这些问题，同时不破坏与现有应用程序和库的兼容性。&lt;/p&gt;
&lt;p&gt;JWT-SVID 是使用 JWS 紧凑序列化的 JSON Web Signature (JWS) 数据结构。不得使用 JWS JSON 序列化。&lt;/p&gt;
&lt;h2 id=&#34;jose-头&#34;&gt;JOSE 头&lt;/h2&gt;
&lt;p&gt;历史上，JOSE 头的密码灵活性引入了一系列流行的 JWT 实现中的漏洞。为了避免这样的陷阱，本规范限制了一些最初允许的内容。本节描述了允许的注册头以及其值。JWT-SVID JOSE 头中未描述的任何头部，无论是注册的还是私有的，都不得包含在其中。&lt;/p&gt;
&lt;p&gt;只支持 JWS。&lt;/p&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;alg&lt;/code&gt; 头必须设置为 &lt;a href=&#34;https://tools.ietf.org/html/rfc7518&#34; title=&#34;RFC 7518&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7518&lt;/a&gt; 第 &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.3&#34; title=&#34;3.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3.3&lt;/a&gt;、&lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.4&#34; title=&#34;3.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3.4&lt;/a&gt; 或 &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.5&#34; title=&#34;3.5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3.5&lt;/a&gt; 节定义的值之一。接收到 &lt;code&gt;alg&lt;/code&gt; 参数设置为其他值的令牌的验证器必须拒绝该令牌。&lt;/p&gt;
&lt;p&gt;支持的 &lt;code&gt;alg&lt;/code&gt; 值为：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;alg 参数值&lt;/th&gt;
          &lt;th&gt;数字签名算法&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;RS256&lt;/td&gt;
          &lt;td&gt;使用 SHA-256 的 RSASSA-PKCS1-v1_5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RS384&lt;/td&gt;
          &lt;td&gt;使用 SHA-384 的 RSASSA-PKCS1-v1_5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RS512&lt;/td&gt;
          &lt;td&gt;使用 SHA-512 的 RSASSA-PKCS1-v1_5&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ES256&lt;/td&gt;
          &lt;td&gt;使用 P-256 和 SHA-256 的 ECDSA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ES384&lt;/td&gt;
          &lt;td&gt;使用 P-384 和 SHA-384 的 ECDSA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ES512&lt;/td&gt;
          &lt;td&gt;使用 P-521 和 SHA-512 的 ECDSA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;PS256&lt;/td&gt;
          &lt;td&gt;使用 SHA-256 和 SHA-256 MGF1 的 RSASSA-PSS&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;PS384&lt;/td&gt;
          &lt;td&gt;使用 SHA-384 和 SHA-384 MGF1 的 RSASSA-PSS&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;PS512&lt;/td&gt;
          &lt;td&gt;使用 SHA-512 和 SHA-512 MGF1 的 RSASSA-PSS&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;密钥-id&#34;&gt;密钥 ID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kid&lt;/code&gt; 头是可选的。&lt;/p&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typ&lt;/code&gt; 头是可选的。如果设置，其值必须是 &lt;code&gt;JWT&lt;/code&gt; 或 &lt;code&gt;JOSE&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;jwt-声明&#34;&gt;JWT 声明&lt;/h2&gt;
&lt;p&gt;JWT-SVID 规范没有引入任何新的声明，但它对 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; title=&#34;RFC 7519&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7519&lt;/a&gt; 定义的注册声明设置了一些限制。未在本文档中描述的注册声明，以及私有声明，可以根据实现者的需求使用。但应注意，在未定义的声明上依赖可能会影响互操作性，因为生成和使用令牌的应用程序必须独立协商。在引入其他声明时，实现者应谨慎行事，并仔细考虑其对 SVID 互操作性的影响，特别是在实现者无法控制生产者和消费者的环境中。如果绝对有必要使用其他声明，建议按照 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; title=&#34;RFC 7519&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7519&lt;/a&gt; 的建议使其抗冲突。&lt;/p&gt;
&lt;p&gt;本节概述了 JWT-SVID 规范对现有注册声明所施加的要求和限制。&lt;/p&gt;
&lt;h3 id=&#34;主题&#34;&gt;主题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sub&lt;/code&gt; 声明必须设置为其所属工作负载的 SPIFFE ID。这是对工作负载身份进行断言的主要声明。&lt;/p&gt;
&lt;h3 id=&#34;受众&#34;&gt;受众&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;aud&lt;/code&gt; 声明必须存在，包含一个或多个值。验证器必须拒绝没有设置 &lt;code&gt;aud&lt;/code&gt; 声明的令牌，或者验证器所识别的值不存在作为 &lt;code&gt;aud&lt;/code&gt; 元素。强烈建议在正常情况下将值的数量限制为一个。有关更多信息，请参见安全注意事项部分。&lt;/p&gt;
&lt;p&gt;所选择的值是特定于站点的，并且应该限定在要呈现给的服务范围内。例如，&lt;code&gt;reports&lt;/code&gt; 或 &lt;code&gt;spiffe://example.org/reports&lt;/code&gt; 是适用于向报告服务呈现的令牌的合适值。不建议使用 &lt;code&gt;production&lt;/code&gt; 或 &lt;code&gt;spiffe://example.org/&lt;/code&gt; 等值，因为它们的范围很广，如果 &lt;code&gt;production&lt;/code&gt; 中的单个服务受到损害，则可能导致冒充。&lt;/p&gt;
&lt;h3 id=&#34;过期时间&#34;&gt;过期时间&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;exp&lt;/code&gt; 声明必须设置，验证器必须拒绝没有此声明的令牌。鼓励实施者将有效期保持尽可能小，但本规范对其值没有设置任何硬上限。&lt;/p&gt;
&lt;h2 id=&#34;令牌签名和验证&#34;&gt;令牌签名和验证&lt;/h2&gt;
&lt;p&gt;JWT-SVID 的签名和验证语义与常规 JWT/JWS 相同。验证器在处理之前必须确保 &lt;code&gt;alg&lt;/code&gt; 头设置为支持的值。&lt;/p&gt;
&lt;p&gt;JWT-SVID 的签名是根据 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-7&#34; title=&#34;RFC 7519 第 7 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7519 第 7 节&lt;/a&gt; 中概述的步骤进行计算和验证的。&lt;code&gt;aud&lt;/code&gt; 和 &lt;code&gt;exp&lt;/code&gt; 声明必须存在，并根据 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; title=&#34;RFC 7519&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7519&lt;/a&gt; 第 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.3&#34; title=&#34;4.1.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;4.1.3&lt;/a&gt; 和 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.4&#34; title=&#34;4.1.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;4.1.4&lt;/a&gt; 节进行处理。接收到没有设置 &lt;code&gt;aud&lt;/code&gt; 和 &lt;code&gt;exp&lt;/code&gt; 声明的令牌的验证器必须拒绝该令牌。&lt;/p&gt;
&lt;h2 id=&#34;令牌传输&#34;&gt;令牌传输&lt;/h2&gt;
&lt;p&gt;本节描述了 JWT-SVID 可以从一个工作负载传输到另一个工作负载的方式。&lt;/p&gt;
&lt;h3 id=&#34;序列化&#34;&gt;序列化&lt;/h3&gt;
&lt;p&gt;JWT-SVID 必须使用 &lt;a href=&#34;https://tools.ietf.org/html/rfc7515#section-3.1&#34; title=&#34;RFC 7515 第 3.1 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7515 第 3.1 节&lt;/a&gt; 中描述的紧凑序列化方法进行序列化，正如 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-1&#34; title=&#34;RFC 7519 第 1 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7519 第 1 节&lt;/a&gt; 所要求的那样。请注意，这排除了使用 JWS 未保护的头部，正如 JOSE 头 部分所规定的那样。&lt;/p&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;p&gt;通过 HTTP 传输的 JWT-SVID 应该在“Authorization”头部（HTTP/2 的“authorization”）中使用“Bearer”身份验证方案进行传输，该方案在 &lt;a href=&#34;https://tools.ietf.org/html/rfc6750#section-2.1&#34; title=&#34;RFC 6750 第 2.1 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 6750 第 2.1 节&lt;/a&gt; 中定义。例如，在 HTTP/1.1 中使用 &lt;code&gt;Authorization: Bearer &amp;lt;serialized_token&amp;gt;&lt;/code&gt;，在 HTTP/2 中使用 &lt;code&gt;authorization: Bearer &amp;lt;serialized_token&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;gRPC 协议使用 HTTP/2。因此，HTTP 部分 中的 HTTP 传输指南同样适用。具体而言，gRPC 实现应该使用值为 &lt;code&gt;Bearer &amp;lt;serialized_token&amp;gt;&lt;/code&gt; 的元数据键 &lt;code&gt;authorization&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;在-spiffe-bundle-中的表示&#34;&gt;在 SPIFFE Bundle 中的表示&lt;/h2&gt;
&lt;p&gt;本节描述了 JWT-SVID 签名密钥如何发布到和从 SPIFFE Bundle 中消费。有关 SPIFFE Bundle 的更多信息，请参见 SPIFFE 信任域和 Bundle 规范。&lt;/p&gt;
&lt;h3 id=&#34;发布-spiffe-bundle-元素&#34;&gt;发布 SPIFFE Bundle 元素&lt;/h3&gt;
&lt;p&gt;给定信任域的 JWT-SVID 签名密钥在 SPIFFE Bundle 中表示为符合 &lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; title=&#34;RFC 7517&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517&lt;/a&gt; 的 JWK 条目，每个签名密钥一个条目。&lt;/p&gt;
&lt;p&gt;每个 JWK 条目的 &lt;code&gt;use&lt;/code&gt; 参数必须设置为 &lt;code&gt;jwt-svid&lt;/code&gt;。此外，每个 JWK 条目的 &lt;code&gt;kid&lt;/code&gt; 参数必须设置。&lt;/p&gt;
&lt;h3 id=&#34;使用-spiffe-bundle&#34;&gt;使用 SPIFFE Bundle&lt;/h3&gt;
&lt;p&gt;SPIFFE Bundle 可能包含许多不同类型的 JWK 条目。在使用这些条目进行验证之前，实现必须提取 JWT-SVID 特定的密钥。可以通过其 &lt;code&gt;use&lt;/code&gt; 参数的值来识别表示 JWT-SVID 签名密钥的条目，该值必须为 &lt;code&gt;jwt-svid&lt;/code&gt;。如果没有具有 &lt;code&gt;jwt-svid&lt;/code&gt; 使用值的条目，则表示 Bundle 的信任域不支持 JWT-SVID。&lt;/p&gt;
&lt;p&gt;提取 JWK 条目后，可以根据 &lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; title=&#34;RFC 7517&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517&lt;/a&gt; 描述的方式直接用于 JWT-SVID 验证。&lt;/p&gt;
&lt;h2 id=&#34;安全注意事项&#34;&gt;安全注意事项&lt;/h2&gt;
&lt;p&gt;本节概述了在使用 JWT-SVID 时实施者和用户应考虑的安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;重放保护&#34;&gt;重放保护&lt;/h3&gt;
&lt;p&gt;作为承载令牌，JWT-SVID 容易受到重放攻击的影响。通过要求设置 &lt;code&gt;aud&lt;/code&gt; 和 &lt;code&gt;exp&lt;/code&gt; 声明，本规范已经采取措施改善了这种情况，但在保留与 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; title=&#34;RFC 7515&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7515&lt;/a&gt; 的验证兼容性的同时无法完全解决。理解这个风险非常重要。建议设置较短的 &lt;code&gt;exp&lt;/code&gt; 声明值。某些用户可能希望利用 &lt;code&gt;jti&lt;/code&gt; 声明，尽管增加了额外的开销。虽然本规范允许使用 &lt;code&gt;jti&lt;/code&gt; 声明，但应注意，JWT-SVID 验证器不必跟踪 &lt;code&gt;jti&lt;/code&gt; 的唯一性。&lt;/p&gt;
&lt;h3 id=&#34;受众-1&#34;&gt;受众&lt;/h3&gt;
&lt;p&gt;赋予 JWT-SVID 接收方隐式信任。发送到一个受众的令牌可以被重播到另一个受众，如果存在多个受众。例如，如果 Alice 有一个包含 Bob 和 Chuck 作为受众的令牌，并将该令牌传输给 Chuck，那么 Chuck 可以通过将相同的令牌发送给 Bob 来冒充 Alice。因此，在发行具有多个受众的 JWT-SVID 时应格外小心。强烈建议使用单个受众的 JWT-SVID 令牌，以限制重放的范围。&lt;/p&gt;
&lt;h3 id=&#34;传输安全&#34;&gt;传输安全&lt;/h3&gt;
&lt;p&gt;JWT-SVID 与其他承载令牌方案存在相同的风险，即令牌被拦截后，攻击者可以利用其可重放性获得 JWT-SVID 所授予的完全权限。虽然通过 &lt;code&gt;exp&lt;/code&gt; 声明强制令牌过期可以减轻风险，但总会存在一个漏洞窗口。因此，在传输 JWT-SVID 的通信渠道上的每个跳跃/链接都应提供机密性（例如，从工作负载到负载均衡器，从负载均衡器到另一个工作负载）。值得注意的例外是非网络链接，其具有合理的安全假设，例如在同一主机上的两个进程之间的 Unix 域套接字。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-验证参考&#34;&gt;附录 A. 验证参考&lt;/h2&gt;
&lt;p&gt;以下表格为正在实施 JWT-SVID 验证器的任何人提供快速参考。如果使用现成的库，则实施者有责任确保采取了以下验证步骤。&lt;/p&gt;
&lt;p&gt;此外，请参阅 JWT-SVID Schema 获取更正式的参考。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;字段&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;要求&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;alg&lt;/td&gt;
          &lt;td&gt;Header&lt;/td&gt;
          &lt;td&gt;设置为算法表中的一个值。否则拒绝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;aud&lt;/td&gt;
          &lt;td&gt;Claim&lt;/td&gt;
          &lt;td&gt;至少有一个值存在。用户应提前配置至少一个可接受的值。否则拒绝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;exp&lt;/td&gt;
          &lt;td&gt;Claim&lt;/td&gt;
          &lt;td&gt;必须设置。不能过期（允许有一小段宽限期）。否则拒绝。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIRE 联邦：验证来自不同 SPIRE 服务器的工作负载</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/architecture/federation/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/architecture/federation/</guid>
      <description>
        
        
        &lt;p&gt;本教程展示了如何对由两个不同 SPIRE 服务器识别的两个 SPIFFE 标识的工作负载进行身份验证。&lt;/p&gt;
&lt;p&gt;本文的第一部分演示了如何通过显示 SPIRE 配置文件更改和 &lt;code&gt;spire-server&lt;/code&gt; 命令来配置 SPIFFE 联邦，以设置股票报价 web 应用的前端和服务后端为例。本文的第二部分列出了你可以在此教程目录中包含的 Docker Compose 文件中运行的步骤，以显示场景的实际操作。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学到如何：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置每个 SPIRE 服务器以使用 SPIFFE 身份验证和 Web PKI 身份验证公开其 SPIFFE 联邦捆绑点。&lt;/li&gt;
&lt;li&gt;配置 SPIRE 服务器以从彼此检索信任捆绑点。&lt;/li&gt;
&lt;li&gt;使用不同的信任域引导两个 SPIRE 服务器之间的联合。&lt;/li&gt;
&lt;li&gt;为工作负载创建注册条目，以便它们可以与其他信任域进行联合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;SPIFFE 联邦的基线组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行版本为 1.5.1 的两个 SPIRE 服务器实例。&lt;/li&gt;
&lt;li&gt;运行版本为 1.5.1 的两个 SPIRE 代理。一个连接到一个 SPIRE 服务器，另一个连接到另一个 SPIRE 服务器。&lt;/li&gt;
&lt;li&gt;两个需要通过 mTLS 进行通信的工作负载，并使用工作负载 API 获取 SVID 和信任捆绑点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;
&lt;p&gt;假设我们有一个股票 broker（经纪人）的 web 应用程序，它希望从股票 market web 服务提供商那里获取股票报价并显示。情景如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在浏览器中输入 broker web 应用的股票报价 URL。&lt;/li&gt;
&lt;li&gt;Web 应用的工作负载接收到请求并使用 mTLS 向股票 market 服务发出获取报价的 HTTP 请求。&lt;/li&gt;
&lt;li&gt;股票 market 服务收到请求并在响应中发送报价。&lt;/li&gt;
&lt;li&gt;Web 应用呈现使用返回的报价的股票报价页面并将其发送到浏览器。&lt;/li&gt;
&lt;li&gt;浏览器向用户显示报价。Web 应用包括一些 JavaScript 以便每隔 1 秒刷新页面，因此每秒都会执行这些步骤。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图详细描绘了本场景。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/federation/federation-scenario.svg&#34; data-img=&#34;/book/spiffe-and-spire/architecture/federation/federation-scenario.svg&#34; alt=&#34;image&#34; data-caption=&#34;联邦场景&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;联邦场景&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;除了上述内容，本教程的其余部分中，我们将假设以下 &lt;a href=&#34;https://spiffe.io/docs/latest/spiffe/concepts/#trust-domain&#34; title=&#34;信任域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任域&lt;/a&gt; 名称用于这些示例 SPIRE 安装：&lt;code&gt;broker.example&lt;/code&gt; 和 &lt;code&gt;stockmarket.example&lt;/code&gt;。请注意，信任域不需要对应实际的 DNS 域名。此外，应用程序直接访问 WorkloadAPI 以获取 SVID 和信任捆绑点，这意味着在所描述的情景中没有代理。&lt;/p&gt;
&lt;h2 id=&#34;配置-spiffe-联邦捆绑点&#34;&gt;配置 SPIFFE 联邦捆绑点&lt;/h2&gt;
&lt;p&gt;为了使联邦工作，并且因为 web 应用程序和报价服务将使用 &lt;code&gt;mTLS&lt;/code&gt;，两个 SPIRE 服务器都需要彼此的信任捆绑点。在某种程度上，这是通过在每个 SPIRE 服务器上配置所谓的联邦捆绑点来完成的，该捆绑点提供了由其他信任域中的 SPIRE 服务器使用的 API，以获取他们要与之联合的信任域的信任捆绑点。&lt;/p&gt;
&lt;p&gt;由 SPIRE 服务器公开的联邦捆绑点可以配置为使用两种身份验证方法之一：SPIFFE 身份验证或 Web PKI 身份验证。&lt;/p&gt;
&lt;h3 id=&#34;使用-spiffe-身份验证配置联邦捆绑点&#34;&gt;使用 SPIFFE 身份验证配置联邦捆绑点&lt;/h3&gt;
&lt;p&gt;要配置 broker 的 SPIRE 服务器捆绑点端点，我们在 broker 的 SPIRE 服务器配置文件中使用了 &lt;code&gt;federation&lt;/code&gt; 部分（默认为 &lt;code&gt;server.conf&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在运行 SPIRE 服务器的主机中的任何 IP 地址上的端口 8443 上发布联邦捆绑点。&lt;/p&gt;
&lt;p&gt;另一方面，股票 market 服务提供商的 SPIRE 服务器配置类似：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，两个 SPIRE 服务器都暴露了它们的联邦捆绑点以提供它们的信任捆绑点，但它们都不知道如何到达彼此的联邦捆绑点。&lt;/p&gt;
&lt;h3 id=&#34;使用-web-pki-身份验证配置联邦捆绑点&#34;&gt;使用 Web PKI 身份验证配置联邦捆绑点&lt;/h3&gt;
&lt;p&gt;我们将假设仅 broker 的 SPIRE 服务器将使用 Web PKI 身份验证来配置其联邦捆绑点。股票 market SPIRE 服务器仍将使用 SPIFFE 身份验证。因此，股票 market SPIRE 服务器配置与前一节中所见相同。&lt;/p&gt;
&lt;p&gt;然后，要配置 broker 的 SPIRE 服务器捆绑点端点，我们将 &lt;code&gt;federation&lt;/code&gt; 部分配置如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;acme&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 domain_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 email&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;some@email.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 tos_accepted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在任何 IP 地址上的端口 443 上发布联邦捆绑点。我们使用端口 443，因为我们演示了使用 Let&amp;rsquo;s Encrypt 作为我们的 ACME 提供商（如果你要使用其他提供商，则必须设置 &lt;code&gt;directory_url&lt;/code&gt; 可配置）。请注意，&lt;code&gt;tos_accepted&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;，这意味着我们接受了我们的 ACME 提供商的服务条款，这在使用 Let&amp;rsquo;s Encrypt 时是必要的。&lt;/p&gt;
&lt;p&gt;要使使用 Web PKI 的 SPIFFE 联邦正常工作，你必须拥有为 &lt;code&gt;domain_name&lt;/code&gt;（在我们的示例中为 &lt;code&gt;broker.example&lt;/code&gt;）指定的 DNS 域名，并且该域名必须解析到公开联邦捆绑点的 SPIRE 服务器 IP 地址。&lt;/p&gt;
&lt;h2 id=&#34;配置-spire-服务器以从彼此检索信任捆绑点&#34;&gt;配置 SPIRE 服务器以从彼此检索信任捆绑点&lt;/h2&gt;
&lt;p&gt;在配置联邦端点后，启用 SPIFFE 联邦的下一步是配置 SPIRE 服务器以查找其他信任域的信任捆绑点。在 &lt;code&gt;server.conf&lt;/code&gt; 中的 &lt;code&gt;federates_with&lt;/code&gt; 配置选项是你指定另一个信任域的端点的地方。在使用不同的身份验证方法时，该部分的配置有一些细微的差异，根据每个端点配置文件的要求。&lt;/p&gt;
&lt;h3 id=&#34;使用-spiffe-身份验证配置信任捆绑点位置https_spiffe&#34;&gt;使用 SPIFFE 身份验证配置信任捆绑点位置（https_spiffe）&lt;/h3&gt;
&lt;p&gt;如前所述，股票 market 服务提供商的 SPIRE 服务器将其联邦端点监听在任何 IP 地址的端口 &lt;code&gt;8443&lt;/code&gt; 上。我们还假设 &lt;code&gt;spire-server-stock&lt;/code&gt; 是一个解析为股票 market 服务的 SPIRE 服务器 IP 地址的 DNS 名称。 （这里的 Docker Compose 演示使用主机名 &lt;code&gt;spire-server-stock&lt;/code&gt;，但在典型的使用中，你会指定一个 FQDN。）然后，broker 的 SPIRE 服务器必须配置以下 &lt;code&gt;federates_with&lt;/code&gt; 部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://spire-server-stock:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_spiffe&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 endpoint_spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://stockmarket.example/spire/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，broker 的 SPIRE 服务器知道在哪里找到可以用于验证包含来自 &lt;code&gt;stockmarket.example&lt;/code&gt; 信任域的身份的信任捆绑点。&lt;/p&gt;
&lt;p&gt;另一方面，股票 market 服务提供商的 SPIRE 服务器必须以类似的方式进行配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://spire-server-broker:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_spiffe&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 endpoint_spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://broker.example/spire/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，指定了 &amp;ldquo;https_spiffe&amp;rdquo; 配置文件，指示了联邦捆绑点的预期 SPIFFE ID。指定 &lt;code&gt;server.conf&lt;/code&gt; 的 &lt;code&gt;federation&lt;/code&gt; 部分和 &lt;code&gt;federates_with&lt;/code&gt; 子部分是配置 SPIFFE 联邦所需的全部内容。要完成启用 SPIFFE 联邦，我们需要使用下面描述的 &lt;code&gt;spire-server&lt;/code&gt; 命令来引导信任捆绑点和注册工作负载。&lt;/p&gt;
&lt;h3 id=&#34;使用-web-pki-身份验证配置信任捆绑点位置https_web&#34;&gt;使用 Web PKI 身份验证配置信任捆绑点位置（https_web）&lt;/h3&gt;
&lt;p&gt;如前所述，在这种备选方案中，我们假设只有 broker 的 SPIRE 服务器将使用 Web PKI 身份验证来配置其联邦端点，因此 broker 服务器的 &lt;code&gt;federates_with&lt;/code&gt; 配置与前一节中所见相同。然而，股票 market 服务提供商的 SPIRE 服务器需要一个不同的配置，它使用 &amp;ldquo;https_web&amp;rdquo; 配置文件而不是 &amp;ldquo;https_spiffe&amp;rdquo;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://spire-server-broker:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_web&amp;#34;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以注意到 &amp;ldquo;https_web&amp;rdquo; 配置文件不需要额外的配置设置。端点使用安装在操作系统中的相同公共 CA 证书进行身份验证。&lt;/p&gt;
&lt;h2 id=&#34;引导联邦&#34;&gt;引导联邦&lt;/h2&gt;
&lt;p&gt;我们已经配置了 SPIRE 服务器的联邦端点地址，但这并不足以使联邦正常工作。为了使 SPIRE 服务器能够从彼此获取信任捆绑点，它们首先需要彼此的信任捆绑点，因为它们必须对试图访问联邦端点的联合服务器的 SPIFFE 身份进行身份验证。一旦联邦被引导，就可以使用当前信任捆绑点通过联邦端点 API 获取信任捆绑点更新。&lt;/p&gt;
&lt;p&gt;引导工作是通过使用 SPIRE Server 命令 &lt;code&gt;bundle show&lt;/code&gt; 和 &lt;code&gt;bundle set&lt;/code&gt; 来完成的。&lt;/p&gt;
&lt;h3 id=&#34;获取引导信任捆绑点&#34;&gt;获取引导信任捆绑点&lt;/h3&gt;
&lt;p&gt;假设我们想要获取 broker 的 SPIRE 服务器信任捆绑点。在运行 broker 的 SPIRE 服务器的节点上运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;broker&amp;gt; spire-server bundle show -format spiffe &amp;gt; broker.example.bundle
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会将信任捆绑点保存在 &lt;code&gt;broker.example.bundle&lt;/code&gt; 文件中。然后，broker 必须将此文件的副本提供给股票 market 服务人员，以便他们可以将此信任捆绑点存储在他们的 SPIRE 服务器上，并将其与 &lt;code&gt;broker.example&lt;/code&gt; 信任域关联起来。要做到这一点，股票 market 服务人员必须在他们运行 SPIRE 服务器的节点上运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stock-market&amp;gt; spire-server bundle &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; -format spiffe -id spiffe://broker.example -path /some/path/broker.example.bundle
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，股票 market 服务的 SPIRE 服务器可以验证具有 &lt;code&gt;broker.example&lt;/code&gt; 信任域的 SPIFFE ID 的 SVID。但是，broker 的 SPIRE 服务器尚无法验证具有 &lt;code&gt;stockmarket.example&lt;/code&gt; 信任域的 SPIFFE ID 的 SVID。要使此成为可能，股票 market 人员必须在他们运行 SPIRE 服务器的节点上运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stock-market&amp;gt; spire-server bundle show -format spiffe &amp;gt; stockmarket.example.bundle
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，股票 market 人员必须将此文件的副本提供给 broker，以便他们可以将此信任捆绑点存储在他们的 SPIRE 服务器上，并将其与 &lt;code&gt;stockmarket.example&lt;/code&gt; 信任域关联起来。要做到这一点，broker 必须在他们运行 SPIRE 服务器的节点上运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;broker&amp;gt; spire-server bundle &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; -format spiffe -id spiffe://stockmarket.example -path /some/path/stockmarket.example.bundle
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，两台 SPIRE 服务器都可以验证具有彼此信任域的 SPIFFE ID 的 SVID，因此两者可以开始从彼此的联邦端点获取信任捆绑点更新。此外，从现在起，他们可以创建用于联合的注册条目，如下一节所示。&lt;/p&gt;
&lt;p&gt;请注意，在 broker 的 SPIRE 服务器为其联邦捆绑点使用 Web PKI 身份验证时，不需要创建 &lt;code&gt;broker.example.bundle&lt;/code&gt; 文件（后来由股票 market 服务导入）。&lt;/p&gt;
&lt;h2 id=&#34;为联邦创建注册条目&#34;&gt;为联邦创建注册条目&lt;/h2&gt;
&lt;p&gt;现在，SPIRE 服务器具有了彼此的信任捆绑点，让我们看看它们如何创建用于联合的注册条目。&lt;/p&gt;
&lt;p&gt;为简化起见，我们假设股票 market Web 应用程序和行情服务都在运行在 Linux 主机上，一个属于股票 market 组织，另一个属于 broker。由于它们使用 SPIRE，每个 Linux 主机上还安装了一个 SPIRE 代理。除此之外，Web 应用程序是使用 &lt;code&gt;webapp&lt;/code&gt; 用户运行的，行情服务是使用 &lt;code&gt;quotes-service&lt;/code&gt; 用户运行的。&lt;/p&gt;
&lt;p&gt;在 broker 的 SPIRE Server 节点上，broker 必须创建一个注册条目。&lt;code&gt;-federatesWith&lt;/code&gt; 标志是必需的，以启用 SPIFFE 联邦：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;broker&amp;gt; spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -parentID &amp;lt;SPIRE 代理的 SPIFFE ID&amp;gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -spiffeID spiffe://broker.example/webapp &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -selector unix:user:webapp &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -federatesWith &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://stockmarket.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过指定 &lt;code&gt;-federatesWith&lt;/code&gt; 标志，创建了此注册条目后，当 Web 应用程序的 SPIRE 服务器请求 SVID 时，它将从 broker 的 SPIRE 服务器获取一个具有 &lt;code&gt;spiffe://broker.example/webapp&lt;/code&gt; 身份的 SVID，并附带与 &lt;code&gt;stockmarket.example&lt;/code&gt; 信任域关联的信任捆绑点。&lt;/p&gt;
&lt;p&gt;在股票 market 服务的一侧，他们必须创建一个注册条目，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stock-market&amp;gt; spire-server entry create &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -parentID &amp;lt;SPIRE 代理的 SPIFFE ID&amp;gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -spiffeID spiffe://stockmarket.example/quotes-service &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -selector unix:user:quotes-service &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   -federatesWith &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类似地，创建了此注册条目后，当行情服务请求 SVID 时，它将获得一个具有 &lt;code&gt;spiffe://stockmarket.example/quotes-service&lt;/code&gt; 身份的 SVID，并附带与 &lt;code&gt;broker.example&lt;/code&gt; 信任域关联的信任捆绑点。&lt;/p&gt;
&lt;p&gt;以上就是全部内容。现在，所有的组件都已就绪，可以使联邦正常工作，并演示 Web 应用程序如何在具有不同信任域的身份的情况下与行情服务通信。&lt;/p&gt;
&lt;h2 id=&#34;使用-spiffe-身份验证的联邦示例&#34;&gt;使用 SPIFFE 身份验证的联邦示例&lt;/h2&gt;
&lt;p&gt;本节将解释如何使用 Docker Compose 尝试此教程中描述的 SPIFFE 身份验证场景的示例实现。&lt;/p&gt;
&lt;p&gt;尽管此处没有显示出来，但你可以对 Web PKI 身份验证部分中显示的更改进行更改以尝试 Web PKI 场景。请记住，要配置 Web PKI，&lt;code&gt;domain_name&lt;/code&gt; 指定的 FQDN 必须由你拥有，并且可以通过 DNS 通过互联网进行解析。&lt;/p&gt;
&lt;h3 id=&#34;要求&#34;&gt;要求&lt;/h3&gt;
&lt;p&gt;本教程的所需文件可以在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;docker-compose/federation&lt;/code&gt; 目录中找到。如果你尚未克隆该存储库，请立即执行此操作。&lt;/p&gt;
&lt;p&gt;在继续之前，请查看以下系统要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64 位 Linux 或 macOS 环境&lt;/li&gt;
&lt;li&gt;安装了 &lt;a href=&#34;https://docs.docker.com/get-docker/&#34; title=&#34;Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 和 &lt;a href=&#34;https://docs.docker.com/compose/install/&#34; title=&#34;Docker Compose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Compose&lt;/a&gt;（Docker Compose 包含在 macOS Docker Desktop 中）&lt;/li&gt;
&lt;li&gt;安装了 &lt;a href=&#34;https://golang.org/dl/&#34; title=&#34;Go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt; 1.14.4 或更高版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构建&#34;&gt;构建&lt;/h3&gt;
&lt;p&gt;确保当前工作目录是 &lt;code&gt;.../spire-tutorials/docker-compose/federation&lt;/code&gt;，并运行以下命令以创建 Docker Compose 所需的文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./build.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;
&lt;p&gt;运行以下命令以启动 SPIRE 服务器和应用程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker-compose up -d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;启动-spire-agents&#34;&gt;启动 SPIRE Agents&lt;/h3&gt;
&lt;p&gt;运行以下命令以启动 SPIRE Agents：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./1-start-spire-agents.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;引导联邦-1&#34;&gt;引导联邦&lt;/h3&gt;
&lt;p&gt;运行以下命令以引导联邦：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./2-bootstrap-federation.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;创建工作负载注册条目&#34;&gt;创建工作负载注册条目&lt;/h3&gt;
&lt;p&gt;运行以下命令以创建工作负载注册条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ./3-create-registration-entries.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行此脚本后，应用程序可能需要几秒钟才能收到其 SVID（SPIFFE 身份验证信息）和信任捆绑包。&lt;/p&gt;
&lt;h3 id=&#34;在浏览器中查看场景工作&#34;&gt;在浏览器中查看场景工作&lt;/h3&gt;
&lt;p&gt;在浏览器中打开 http://localhost:8080/quotes，你应该看到一个显示每秒更新的随机生成的虚假股票报价的网格。&lt;/p&gt;
&lt;h3 id=&#34;查看配置&#34;&gt;查看配置&lt;/h3&gt;
&lt;p&gt;要查看经纪人的 SPIRE 服务器配置，可以运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; spire-server-broker cat conf/server/server.conf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你应该会看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     bind_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     bind_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8081&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     socket_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/tmp/spire-server/private/api.sock&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     data_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/data/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     log_level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;DEBUG&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     log_file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/server.log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     default_svid_ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1h&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     ca_subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         country&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;US&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         organization&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SPIFFE&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         common_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://spire-server-stock:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_spiffe&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 endpoint_spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://stockmarket.example/spire/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;DataStore&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sql&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             database_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             connection_string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/data/server/datastore.sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;NodeAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;x509pop&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;       ca_bundle_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/server/agent-cacert.pem&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;KeyManager&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;memory&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         plugin_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要查看股票 market 的 SPIRE 服务器配置，可以运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; spire-server-stock cat conf/server/server.conf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你应该会看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     bind_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     bind_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8081&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     socket_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/tmp/spire-server/private/api.sock&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stockmarket.example&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     data_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/data/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     log_level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;DEBUG&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     log_file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/server.log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     default_svid_ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1h&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;     ca_subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         country&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;US&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         organization&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SPIFFE&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         common_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;broker.example&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://spire-server-broker:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_spiffe&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                 endpoint_spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://broker.example/spire/server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;DataStore&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sql&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             database_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;             connection_string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/data/server/datastore.sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;NodeAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;x509pop&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;       ca_bundle_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/server/agent-cacert.pem&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;k&#34;&gt;KeyManager&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;memory&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;         plugin_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;查看注册条目&#34;&gt;查看注册条目&lt;/h3&gt;
&lt;p&gt;要查看经纪人的 SPIRE 服务器注册条目，可以运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; spire-server-broker bin/spire-server entry show
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你应该会看到类似以下内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Found 1 entry
 Entry ID      : 2d799235-ddca-4088-ba6f-bf54d2af918f
 SPIFFE ID     : spiffe://broker.example/webapp
 Parent ID     : spiffe://broker.example/spire/agent/x509pop/4f9238aaa7a93cf96ca3d6060abe27bc51a267e7
 Revision      : 0
 TTL           : 3600
 Selector      : unix:user:root
 FederatesWith : spiffe://stockmarket.example
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要查看股票 market 的 SPIRE 服务器注册条目，可以运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker-compose &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; spire-server-stock bin/spire-server entry show
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你应该会看到类似以下内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Found 1 entry
 Entry ID      : e42e8d6b-0a0a-4e38-b544-08510c35cbbe
 SPIFFE ID     : spiffe://stockmarket.example/quotes-service
 Parent ID     : spiffe://stockmarket.example/spire/agent/x509pop/50686366996ece3ca8e528765af685fe81f81435
 Revision      : 0
 TTL           : 3600
 Selector      : unix:user:root
 FederatesWith : spiffe://broker.example
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;清理&#34;&gt;清理&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; $ docker-compose down
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>安装 SPIRE 代理</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/installation/install-agent/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/installation/install-agent/</guid>
      <description>
        
        
        &lt;p&gt;本文指导你如何在 Linux 和 Kubernetes 上安装 SPIRE Agent。&lt;/p&gt;
&lt;h2 id=&#34;步骤-1获取-spire-二进制文件&#34;&gt;步骤 1：获取 SPIRE 二进制文件&lt;/h2&gt;
&lt;p&gt;可以在 &lt;a href=&#34;https://spiffe.io/downloads/#spire-releases&#34; title=&#34;SPIRE 下载页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 下载页面&lt;/a&gt; 找到预构建的 SPIRE 发行版。tarball 包含服务器和 Agent 二进制文件。&lt;/p&gt;
&lt;p&gt;如果愿意，也可以从源代码 &lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/CONTRIBUTING.md&#34; title=&#34;构建 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建 SPIRE&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;步骤-2安装服务器和-agent&#34;&gt;步骤 2：安装服务器和 Agent&lt;/h2&gt;
&lt;p&gt;本入门指南描述了如何在同一节点上安装服务器和 Agent。在典型的生产部署中，服务器安装在一个节点上，而一个或多个 Agent 安装在不同的节点上。&lt;/p&gt;
&lt;p&gt;要安装服务器和 Agent：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从 &lt;a href=&#34;https://spiffe.io/downloads/#spire-releases&#34; title=&#34;SPIRE 下载页面&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 下载页面&lt;/a&gt; 获取最新的 tarball，然后使用以下命令将其解压到 &lt;code&gt;/opt/spire&lt;/code&gt; 目录中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://github.com/spiffe/spire/releases/download/v1.8.2/spire-1.8.2-linux-amd64-musl.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tar zvxf spire-1.8.2-linux-amd64-musl.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo cp -r spire-1.8.2/. /opt/spire/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了方便起见，将 &lt;code&gt;spire-server&lt;/code&gt; 和 &lt;code&gt;spire-agent&lt;/code&gt; 添加到 &lt;code&gt;$PATH&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ln -s /opt/spire/bin/spire-server /usr/bin/spire-server
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ln -s /opt/spire/bin/spire-agent /usr/bin/spire-agent
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;步骤-3配置-agent&#34;&gt;步骤 3：配置 Agent&lt;/h2&gt;
&lt;p&gt;安装 SPIRE Agent 后，需要根据你的环境进行配置。有关如何配置 SPIRE 的详细信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/configuring/&#34; title=&#34;配置 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 SPIRE&lt;/a&gt;，特别是节点验证和工作负载验证。&lt;/p&gt;
&lt;p&gt;请注意，SPIRE Agent 在修改其配置后必须重新启动，以使更改生效。&lt;/p&gt;
&lt;p&gt;如果尚未安装 SPIRE Server，请参阅 &lt;a href=&#34;../install-server/&#34; title=&#34;安装 SPIRE Server&#34;&gt;安装 SPIRE Server&lt;/a&gt; 了解如何安装 SPIRE Server。&lt;/p&gt;
&lt;h2 id=&#34;在-kubernetes-上安装-spire-agents&#34;&gt;在 Kubernetes 上安装 SPIRE Agents&lt;/h2&gt;
&lt;p&gt;必须从包含用于配置的 .yaml 文件的目录中运行所有命令。有关详细信息，请参阅 SPIRE Server 安装指南的 &lt;a href=&#34;https://spiffe.io/docs/latest/spire/installing/install-server/#section-1&#34; title=&#34;Obtain the Required Files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Obtain the Required Files&lt;/a&gt; 部分。&lt;/p&gt;
&lt;p&gt;要在 Kubernetes 上安装 SPIRE Agents，你需要执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 Agent 服务账号&lt;/li&gt;
&lt;li&gt;创建 Agent ConfigMap&lt;/li&gt;
&lt;li&gt;创建 Agent DaemonSet&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关详细信息，请参阅以下各节。&lt;/p&gt;
&lt;h3 id=&#34;步骤-1创建-agent-服务账号&#34;&gt;步骤 1：创建 Agent 服务账号&lt;/h3&gt;
&lt;p&gt;将 &lt;code&gt;agent-account.yam&lt;/code&gt;l 配置文件应用于在 spire 命名空间中创建名为 spire-agent 的服务账号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f agent-account.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了允许代理读取 kubelet API 以执行工作负载验证，必须创建一个 ClusterRole，授予 Kubernetes RBAC 适当的权限，并将 ClusterRoleBinding 关联到上一步创建的服务账号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过应用 &lt;code&gt;agent-cluster-role.yaml&lt;/code&gt; 配置文件来创建名为 &lt;code&gt;spire-agent-cluster-role&lt;/code&gt; 的 ClusterRole 和相应的 ClusterRoleBinding：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f agent-cluster-role.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了确认成功创建，请验证 ClusterRole 是否出现在以下命令的输出中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get clusterroles --namespace spire &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep spire
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;步骤-2创建-agent-configmap&#34;&gt;步骤 2：创建 Agent ConfigMap&lt;/h3&gt;
&lt;p&gt;将 &lt;code&gt;agent-configmap.yaml&lt;/code&gt; 配置文件应用于创建代理 ConfigMap。这将作为 &lt;code&gt;agent.conf&lt;/code&gt; 文件挂载，用于确定 SPIRE Agent 的配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f agent-configmap.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;agent-configmap.yaml&lt;/code&gt; 文件指定了许多重要的目录，特别是 &lt;code&gt;/run/spire/sockets&lt;/code&gt; 和 &lt;code&gt;/run/spire/config&lt;/code&gt;。这些目录在部署代理容器时绑定。&lt;/p&gt;
&lt;p&gt;请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/configuring/&#34; title=&#34;配置 SPIRE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 SPIRE&lt;/a&gt; 部分，详细了解如何配置 SPIRE Agent，特别是节点验证和工作负载验证。&lt;/p&gt;
&lt;p&gt;请注意，一旦修改了 SPIRE Agent 的配置，必须重新启动该 Agent 才能使更改生效。&lt;/p&gt;
&lt;h3 id=&#34;步骤-3创建-agent-daemonset&#34;&gt;步骤 3：创建 Agent DaemonSet&lt;/h3&gt;
&lt;p&gt;代理以 DaemonSet 形式部署，每个 Kubernetes 工作节点上运行一个代理。&lt;/p&gt;
&lt;p&gt;通过应用 &lt;code&gt;agent-daemonset.yaml&lt;/code&gt; 配置来部署 SPIRE 代理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f agent-daemonset.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在 spire 命名空间中创建一个名为 spire-agent 的 DaemonSet，并在 spire-server 旁边启动一个 spire-agent pod，如以下两个命令的输出所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get daemonset --namespace spire
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-agent   &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;         &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;       &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;            &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           &amp;lt;none&amp;gt;          6m45s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods --namespace spire
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                           READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-agent-88cpl              1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          6m45s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spire-server-0                 1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          103m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当代理部署时，绑定以下表格中总结的卷：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;卷&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;挂载位置&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;spire-config&lt;/td&gt;
          &lt;td&gt;在步骤 2 中创建的 spire-agent configmap。&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;/run/spire/config&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;spire-sockets&lt;/td&gt;
          &lt;td&gt;hostPath，将与在同一工作节点上运行的所有其他 pod 共享。它包含一个 UNIX 域套接字，用于工作负载与代理 API 通信。&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;/run/spire/sockets&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
                           
    <item>
      <title>架构</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/architecture/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/architecture/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/scaling-spire/&#34;&gt;扩展 SPIRE 部署&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/nested/&#34;&gt;SPIRE 嵌套架构&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/architecture/federation/&#34;&gt;SPIRE 联邦架构&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>使用 SVID</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/svids/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/svids/</guid>
      <description>
        
        
        &lt;p&gt;本文指导你如何编写与 SPIFFE SVID 相关的代码。&lt;/p&gt;
&lt;p&gt;SPIRE 等符合 SPIFFE 的身份提供者将通过 SPIFFE Workload API 公开 SPIFFE 可验证身份文档（SVID）。工作负载可以使用从此 API 检索到的 SVID 来验证消息的来源或在两个工作负载之间建立相互 TLS 安全通道。&lt;/p&gt;
&lt;h2 id=&#34;与-workload-api-交互&#34;&gt;与 Workload API 交互&lt;/h2&gt;
&lt;p&gt;开发需要与 SPIFFE 进行交互的新工作负载的开发人员可以直接与 SPIFFE Workload API 进行交互，以便：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检索工作负载的身份，描述为 SPIFFE ID，例如 &lt;code&gt;spiffe://prod.acme.com/billing/api&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;代表工作负载生成短期密钥和证书，具体包括：
&lt;ul&gt;
&lt;li&gt;与该 SPIFFE ID 相关联的私钥，可用于代表工作负载签署数据。&lt;/li&gt;
&lt;li&gt;对应的短期 X.509 证书 - 一种称为 X509-SVID 的证书。该证书可用于建立 TLS 或以其他方式对其他工作负载进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一组证书 - 称为信任捆绑包（trust bundle） - 工作负载可以使用它来验证同一信任域或联合信任域中的另一个工作负载呈现的 X.509-SVID。&lt;/li&gt;
&lt;li&gt;生成或验证代表工作负载或同一信任域或联合信任域中另一个工作负载的 JSON Web Token（JWT-SVID）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Workload API 不需要任何显式的身份验证（如密钥）。相反，SPIFFE 规范将身份验证工作留给 SPIFFE Workload API 的实现来确定。在 SPIRE 的情况下，这是通过检查 SPIRE 代理在工作负载调用 API 时收集的 Unix 内核元数据来实现的。&lt;/p&gt;
&lt;p&gt;该 API 是基于 gRPC 的 API，派生自 &lt;a href=&#34;https://github.com/spiffe/go-spiffe/blob/main/v2/proto/spiffe/workload/workload.proto&#34; title=&#34;protobuf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf&lt;/a&gt;。&lt;a href=&#34;https://grpc.io/&#34; title=&#34;gRPC 项目&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC 项目&lt;/a&gt; 提供了从 protobuf 生成各种语言的客户端库的工具。&lt;/p&gt;
&lt;h3 id=&#34;在-go-中使用-svid&#34;&gt;在 Go 中使用 SVID&lt;/h3&gt;
&lt;p&gt;如果你在使用 Go 进行开发，SPIFFE 项目维护了一个 Go 客户端库，提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个命令行实用程序，用于解析和验证 X.509 证书中编码的 SPIFFE 身份，如 SPIFFE 标准中所述。&lt;/li&gt;
&lt;li&gt;一个客户端库，提供与 SPIFFE Workload API 的交互界面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以在 &lt;a href=&#34;https://github.com/spiffe/go-spiffe&#34; title=&#34;GitHub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上找到该库以及 GoDoc 的链接。&lt;/p&gt;
&lt;h2 id=&#34;使用-spiffe-helper-实用程序&#34;&gt;使用 SPIFFE Helper 实用程序&lt;/h2&gt;
&lt;p&gt;SPIFFE Helper 实用程序是一个通用实用程序，用于构建或与无法直接写入 Workload API 的应用程序集成时非常有用。大体上，该实用程序能够：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取用于验证 X.509-SVID 的 X.509-SVID、密钥和信任捆绑包（证书链），并将它们写入磁盘上的特定位置。&lt;/li&gt;
&lt;li&gt;启动一个子进程，该子进程可以使用这些密钥和证书。&lt;/li&gt;
&lt;li&gt;主动监视其过期时间，并根据需要从 Workload API 请求刷新的证书和密钥。&lt;/li&gt;
&lt;li&gt;一旦获取到更换的证书，向任何已启动的子进程发送信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用-spire-agent&#34;&gt;使用 SPIRE Agent&lt;/h2&gt;
&lt;p&gt;SPIRE Agent 二进制文件可用作作为 SPIFFE Workload API 的实现时的 SPIRE 部署的一部分，但它也可以作为 Workload API 的客户端运行，并提供一些简单的实用程序与其进行交互以检索 SPIFFE 凭据。&lt;/p&gt;
&lt;p&gt;例如，运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo -u webapp ./spire-agent api fetch x509 -socketPath /run/spire/sockets/agent.sock -write /tmp/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接到 Unix 域套接字 &lt;code&gt;/run/spire/sockets/agent.sock&lt;/code&gt; 上的 Workload API（即使 SPIRE 不提供 API）。&lt;/li&gt;
&lt;li&gt;检索与该进程所运行的用户相关联的任何身份（在此示例中为 &lt;code&gt;webapp&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;将每个身份关联的 X.509-SVID、私钥写入 &lt;code&gt;/tmp/&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将用于验证在该信任域下颁发的 X.509-SVID 的信任捆绑包（证书链）写入 &lt;code&gt;/tmp/&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关相关命令的完整列表，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/#command-line-options&#34; title=&#34;SPIRE Agent 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE Agent 文档&lt;/a&gt;。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>收益</title>
      <link>https://jimmysong.io/book/spiffe/benefits/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/benefits/</guid>
      <description>
        
        
        &lt;p&gt;本章从业务和技术的角度解释了在基础设施中部署 SPIFFE 和 SPIRE 的好处。&lt;/p&gt;
&lt;h2 id=&#34;任何人任何地方都适用&#34;&gt;任何人任何地方都适用&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 旨在加强对软件组件的识别，以一种通用的方式，任何人在任何地方都可以在分布式系统中加以利用。现代基础设施的技术环境是错综复杂的。环境在硬件和软件投资的混合下变得越来越不一样。通过对系统定义、证明和维护软件身份标准化的方式来维护软件安全，无论系统部署在哪里，也无论谁来部署这些系统，都会带来许多好处。&lt;/p&gt;
&lt;p&gt;对于专注于提高业务便利性和回报的企业领导人来说，SPIFFE 和 SPIRE 可以大大降低管理和签发加密身份文件（如 X.509 证书）的开销，开发人员无需了解服务间通信所需的身份和认证技术，从而加速开发和部署。&lt;/p&gt;
&lt;p&gt;对于专注于提供强大、安全和可互操作产品的服务提供商和软件供应商来说，SPIFFE 和 SPIRE 解决了在将许多解决方案互连到最终产品时普遍存在的关键身份问题。例如，SPIFFE 可以作为产品的 TLS 功能和用户管理/认证功能的基础，一举两得。还有，SPIFFE 可以取代管理和发行平台访问的 API 令牌的需要，&lt;strong&gt;免费&lt;/strong&gt;带来令牌轮换，并消除存储和管理访问所述令牌的客户负担。&lt;/p&gt;
&lt;p&gt;对于希望不仅加强传输中的数据安全，而且实现监管合规并解决其信任根源问题的安全从业人员来说，SPIFFE 和 SPIRE 致力于在不信任的环境中提供相互认证，而不需要交换秘密。安全和管理边界可以很容易地划定，并且在策略允许的情况下，可以跨越这些边界进行通信。&lt;/p&gt;
&lt;p&gt;对于需要身份管理抽象的开发人员、运维和 DevOps 从业人员，以及需要与现代云原生服务和解决方案互操作的工作负载和应用程序，SPIFFE 和 SPIRE 在整个软件开发生命周期中与许多其他工具兼容，以提供可靠的产品。开发人员可以继续他们的工作，直接进入业务逻辑，而不必担心证书、私钥和 JavaScript Web Token（JWT）等烦人的问题。&lt;/p&gt;
&lt;h2 id=&#34;对于企业领导人&#34;&gt;对于企业领导人&lt;/h2&gt;
&lt;h3 id=&#34;现代的组织有现代的需求&#34;&gt;现代的组织有现代的需求&lt;/h3&gt;
&lt;p&gt;在今天的商业环境中，通过差异化的应用和服务快速提供创新的客户体验是保持竞争优势的必要条件。因此，企业见证了应用程序和服务的架构、构建和部署方式的变化。诸如云和容器等新技术帮助企业更快、更大规模地发布。服务需要高速构建并部署在大量的平台上。随着开发速度的加快，这些系统变得越来越相互依赖和相互联系，以提供一致的客户体验。&lt;/p&gt;
&lt;p&gt;组织在实现高速发展和获得市场份额或任务保证方面可能会受到抑制，主要原因是合规性、专业知识的储备以及团队 / 组织之间和现有解决方案内的互操作性挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互操作性的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着系统的发展，对互操作性的需求也在无限地增长。脱节的团队建立的服务是孤立的，互不相识，尽管他们最终需要意识到彼此的存在。收购发生时，新的或从未见过的系统需要被整合到现有的系统中。商业关系的建立，需要与可能存在于堆栈深处的服务建立新的沟通渠道。所有这些挑战都围绕着“我如何以安全的方式将所有这些服务连接在一起，每个服务都有自己独特的属性和历史？”&lt;/p&gt;
&lt;p&gt;当不同的技术栈必须结合在一起进行互操作时，由于组织融合而产生的技术整合可能是一个挑战。为系统与系统之间的通信与身份和认证制定一个共同的、行业认可的标准，可以简化跨多个堆栈的完全互操作性和整合的技术问题。&lt;/p&gt;
&lt;p&gt;SPIFFE 带来了对构成软件身份的共识。通过进一步利用 SPIFFE Federation，不同组织或团队的不同系统中的组件可以建立信任，安全地进行通信，而不需要增加诸如 VPN 隧道、one-off 证书或用于这些系统之间的共享凭证等结构的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合规性和可审计性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 实施中的可审计性保证了执行行动的身份不会因为在环境中执行相互认证而被否定。此外，SPIFFE/SPIRE 发布的身份文件使相互认证的 TLS 得到广泛使用，有效地解决了与这种性质的项目相关的最困难的挑战之一。相互认证的 TLS 的其他好处包括对服务之间传输的数据进行本地加密，不仅保护了通信的完整性，还保证了敏感或专有数据的保密性。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/benefits/f2-1_hu13576890298080032487.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/benefits/f2-1.jpg&#34; data-img=&#34;/book/spiffe/benefits/f2-1.jpg&#34; data-width=&#34;1140&#34; data-height=&#34;710&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;另一个常见的合规要求是由《通用数据保护条例》（GDPR）带来的 —— 特别是要求欧盟（EU）的数据完全停留在欧盟内部，而不是在其管辖范围之外的实体中转或被处理。有了多个信任根基，全球组织可以确保欧盟实体只与其他欧盟实体沟通。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专业知识库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保开发、安全和运营团队具备正确的知识和经验，以适当地处理安全敏感系统，仍然是一项重大挑战。企业需要雇用具有基于标准的技能组合的开发人员，以减少入职时间，并在减少风险的情况下改善产品效率。&lt;/p&gt;
&lt;p&gt;解决以自动方式向每个软件实例提供加密身份的问题，并从根本上实现凭证轮换，是一项重大挑战。对于安全和运维团队来说，具有的实施此类系统所需的专业知识少之又少。在不依靠社区或行业知识的情况下维持日常运营会使问题恶化，导致中断和指责。&lt;/p&gt;
&lt;p&gt;不能合理地期望开发人员了解或获得安全的实际问题的专业知识，特别是在组织环境中适用于服务身份。此外，在开发、运维和工作负载执行方面具有深度知识的安全从业人员的储备是非常少的。利用一个开放的标准和开放的规范来解决关键的身份问题，允许没有个人经验的人通过一个得到良好支持的、不断增长的 SPIFFE/SPIRE 终端用户和从业人员社区来扩展知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节约&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用 SPIFFE/SPIRE 可以在许多方面节省成本，包括减少云 / 平台锁定，提高开发人员的效率，以及减少对专业知识的依赖，等等。&lt;/p&gt;
&lt;p&gt;通过将云提供商的身份接口抽象为一套建立在开放标准上的定义明确的通用 API，SPIFFE 大大减轻了开发和维护&lt;strong&gt;云感知&lt;/strong&gt;应用的负担。由于 SPIFFE 是平台无关的，它几乎可以在任何地方部署。当需要改变平台技术时，这种差异化可以节省时间和金钱，甚至可以加强与现有平台供应商的谈判地位。从历史上看，身份和访问管理服务是由每个组织自己的部署指挥和控制平台 —— 云服务提供商知道这一点，并利用这一制约因素作为主要的锁定机制，与他们的平台完全整合。&lt;/p&gt;
&lt;p&gt;在提高开发人员的效率方面也有很大的节省。SPIFFE/SPIRE 有两个重要方面可以节省开支：加密身份及其相关生命周期的完全自动化发布和管理，以及认证和服务间通信加密的统一性和加载性。通过消除与前者相关的手动流程，以及在后者中花费的研究和试验 / 错误时间，开发人员可以更好地专注于对他们重要的事情：业务逻辑。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;提高开发人员的生产力&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;值&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;开发人员在获取证书和配置每个应用组件的认证 / 保密协议方面花费的平均时间（小时）。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;减少开发人员在每个应用组件上对应的证书所花费的时间。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;95%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;开发人员在学习和实施特定 API 网关、秘密存储等控制方面花费的平均时间（小时）&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;减少了开发人员学习和实施特定 API 网关、秘密存储等控制的时间。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;75%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;本年度开发的新应用组件的数量&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;预计因提高开发人员生产力而节省的时间&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;530&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;正如我们在历史上看到的那样，财富 50 强的技术组织雇用了高度熟练和专业的工程师，花了几十年时间来解决这个身份问题。将 SPIFFE/SPIRE 添加到企业的云原生解决方案目录中，可以让你在多年的超专业安全和开发人才的基础上构建，而不需要相应的成本。&lt;/p&gt;
&lt;p&gt;凭借强大的社区支持几十个到几十万个节点的部署，SPIFFE/SPIRE 在复杂、大规模环境中的运作经验可以满足组织的需求。&lt;/p&gt;
&lt;h2 id=&#34;对于服务提供商和软件供应商&#34;&gt;对于服务提供商和软件供应商&lt;/h2&gt;
&lt;p&gt;减少客户在使用产品过程中的负担，始终是所有优秀产品经理的首要目标。了解那些表面上看起来无害的功能的实际意义是很重要的。例如，如果一个数据库产品需要支持 TLS，因为这是客户的要求，很简单，在产品中添加一些配置就可以了。&lt;/p&gt;
&lt;p&gt;不幸的是，这给客户带来了一些重大的挑战。即使是看似简单的用户管理也面临类似的挑战。考虑一下这两个常见的功能在默认情况下引入的以下客户痛点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谁生成证书和密码，以及如何生成？&lt;/li&gt;
&lt;li&gt;它们如何被安全地分配给需要的应用程序？&lt;/li&gt;
&lt;li&gt;如何限制对私钥和密码的访问？&lt;/li&gt;
&lt;li&gt;这些秘密是如何存储的，才能让它们不会泄漏到备份中？&lt;/li&gt;
&lt;li&gt;当证书过期，或必须改变密码时，会发生什么？这个过程是否具有破坏性？&lt;/li&gt;
&lt;li&gt;在这些任务中，有多少是必须要有人类操作的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这些功能从客户的角度来看是可行的之前，所有这些问题都需要得到回答。通常，客户发明或安装的解决方案在操作上是很痛苦的。&lt;/p&gt;
&lt;p&gt;这些客户的负担是非常真实的。有些组织有整个团队专门负责管理这些负担。通过简单地支持 SPIFFE，上述所有的担忧都会得到缓解。该产品可以集成进现有的基础设施，并&lt;strong&gt;免费&lt;/strong&gt;增加 TLS 支持。此外，由 SPIFFE 赋予的客户（用户）身份可以直接取代管理用户凭证（如密码）的需要。&lt;/p&gt;
&lt;h3 id=&#34;平台访问管理&#34;&gt;平台访问管理&lt;/h3&gt;
&lt;p&gt;访问一个服务或平台（如 SaaS 服务）也涉及类似的挑战。归根结底，这些挑战为凭证管理所带来的固有困难，尤其是当凭证是一个共享的秘密时。&lt;/p&gt;
&lt;p&gt;考虑一下 API 令牌 —— 在 SaaS 提供商中，使用 API 令牌来验证非人类的 API 调用者是很普遍的。它们实际上是密码，而且每一个都必须由客户仔细管理。上面列出的所有挑战都适用于此。支持 SPIFFE 认证的平台大大减轻了与访问平台有关的客户负担，一次性解决了存储、发行和生命周期问题。利用 SPIFFE，问题被简化为简单地授予给定工作负载所需的权限。&lt;/p&gt;
&lt;h2 id=&#34;对于安全从业人员&#34;&gt;对于安全从业人员&lt;/h2&gt;
&lt;p&gt;技术创新不能成为安全产品的抑制因素。开发、分发和部署工具需要与安全产品和方法无缝集成，不影响软件开发的自主性或为组织带来负担。组织需要易于使用的软件产品，并为现有工具增加额外的安全性。&lt;/p&gt;
&lt;p&gt;SPIRE 不是所有安全问题的最终解决方案。它并不否定对强大的安全实践和深度防御或分层安全的需要。然而，利用 SPIFFE/SPIRE 提供跨不信任网络的信任根，使组织能够在通往&lt;a href=&#34;https://csrc.nist.gov/publications/detail/sp/800-207/final&#34; title=&#34;零信任架构&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;零信任架构&lt;/a&gt;的道路上迈出有意义的一步，作为全面安全战略的一部分。&lt;/p&gt;
&lt;h3 id=&#34;默认安全&#34;&gt;默认安全&lt;/h3&gt;
&lt;p&gt;SPIRE 可以帮助减轻 &lt;a href=&#34;https://owasp.org/www-project-top-ten/&#34; title=&#34;OWASP 的几个主要威胁&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OWASP 的几个主要威胁&lt;/a&gt;。为了减少通过凭证泄露的可能性，SPIRE 为整个基础设施的认证提供了一个强有力的证明身份。保持证明的自动化使平台默认安全，消除了开发团队的额外配置负担。&lt;/p&gt;
&lt;p&gt;对于希望从根本上解决其产品或服务中的信任和身份问题的组织来说，SPIFFE/SPIRE 还通过实现普遍的相互 TLS 认证来解决客户的安全需求，以便在工作负载之间安全地进行通信，无论它们部署在何处。此外，与每个开源产品一样，代码库背后的社区和贡献者提供了更多双眼睛来审查合并前和合并后的代码。这个 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linus%27s_law&#34; title=&#34;莱纳斯法则（Linus Law）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;莱纳斯法则（Linus Law）&lt;/a&gt;的实施超越了&lt;strong&gt;四只眼睛&lt;/strong&gt;的原则，以确保任何潜在的错误或已知的安全问题在进入发布阶段之前被发现。&lt;/p&gt;
&lt;h3 id=&#34;策略执行&#34;&gt;策略执行&lt;/h3&gt;
&lt;p&gt;SPIRE 的 API 为安全团队提供了一种机制，以便以易于使用的方式在各平台和业务部门执行一致的认证策略。当与定义明确的策略相结合时，服务之间的互动可以保持在最低限度，确保只有授权的工作负载可以相互通信。这限制了恶意实体的潜在攻击面，并可以在策略引擎的默认拒绝规则中触发警报。&lt;/p&gt;
&lt;p&gt;SPIRE 利用一个强大的多因素证明引擎，该引擎实时运行，可以肯定地确定加密身份的发放。它还自动发放、分配和更新短期凭证，以确保组织的身份架构准确反映工作负载的运行状态。&lt;/p&gt;
&lt;h3 id=&#34;零信任&#34;&gt;零信任&lt;/h3&gt;
&lt;p&gt;在架构中采用零信任模式，可以减少漏洞发生时的爆炸半径。相互认证和信任撤销可以阻止被破坏的前端应用服务器从网络上或集群内可能存在的不相关数据库中渗出数据。虽然不可能发生在网络安全严密的组织中，但 SPIFFE/SPIRE 肯定会增加额外的防御层，以减轻错误配置的防火墙或不变的默认登录带来的漏洞和暴露点。它还将安全决策从 IP 地址和端口号（可以用不可察觉的方式进行操纵）转移到享有完整性保护的加密标识符上。&lt;/p&gt;
&lt;h3 id=&#34;记录和监控&#34;&gt;记录和监控&lt;/h3&gt;
&lt;p&gt;SPIRE 可以帮助改善基础设施的可观测性。关键的 SPIRE 事件，如身份请求和发放，是可记录的事件，有助于提供一个更完整的基础设施视图。SPIRE 还将生成各种行动的事件，包括身份注册、取消注册、验证尝试、身份发放和轮换。然后，这些事件可以被汇总并发送到组织的安全信息和事件管理（SIEM）解决方案，以便进行统一监控。&lt;/p&gt;
&lt;h2 id=&#34;对于开发运维和-devops-来说&#34;&gt;对于开发、运维和 DevOps 来说&lt;/h2&gt;
&lt;p&gt;即使你可以通过采用和支持 SPIFFE/SPIRE 而不考虑环境，量化对开发人员甚至运维生产力的改善，但最终，它通过在日常工作中重新引入焦点、流程和快乐，缓解了团队所经历的大部分劳累。&lt;/p&gt;
&lt;h3 id=&#34;聚焦&#34;&gt;聚焦&lt;/h3&gt;
&lt;p&gt;不能让安全成为技术创新的障碍。安全工具和控制需要与现代产品和方法进行无摩擦的整合，不影响开发的自主性或给运维团队带来负担。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 提供了一个统一的服务身份控制平面，可通过一致的 API 跨平台和跨域使用，因此团队可以专注于交付应用程序和产品，而不必担心或为目的地进行特殊配置。每个开发人员都可以利用这个 API，安全、轻松地进行跨平台和跨域的认证。&lt;/p&gt;
&lt;p&gt;开发人员还可以请求并接收一个身份，然后可用于为所提供的身份建立额外的应用程序特定控制，而运维和 DevOps 团队可以以自动化的方式管理和扩展身份，同时实施和执行消耗这些身份的策略。此外，团队可以使用 OIDC 联盟将 SPIFFE 身份与各种云认证系统（如 AWS IAM）相关联，从而减少对复杂的秘密管理需求。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;
&lt;p&gt;每一个曾经生成的凭证都面临着同样的问题：在某些时候，它将不得不被改变或撤销。这个过程往往是手动的和痛苦的 —— 就像部署一样，越是不经常发生就越是痛苦。对过程的不熟悉和因缺乏及时性或不方便的更新程序而引起的中断是正常的。&lt;/p&gt;
&lt;p&gt;当需要轮换时，常要求运维和开发人员进行昂贵的上下文切换。SPIFFE/SPIRE 通过将轮换作为一个关键的核心功能来解决这个问题。它是完全自动化的，并且定期发生，无需人工干预。轮换的频率由运维选择，而且涉及到权衡；然而，SPIFFE 证书每小时轮换一次的情况并不少见。这种频繁和自动化的轮换方式最大限度地减少了与证书生命周期管理有关的运维和开发人员的中断。&lt;/p&gt;
&lt;p&gt;值得注意的是，不仅仅轮换是自动化的。证书的最初发放（最常见的是 X.509 证书的形式）也是完全自动化的。这有助于简化开发人员的流程，将生成或采购凭证的任务从启动新服务的检查清单中剔除。&lt;/p&gt;
&lt;h3 id=&#34;互操作性&#34;&gt;互操作性&lt;/h3&gt;
&lt;p&gt;开发人员和集成商不再需要为组织的安全身份和认证解决方案缺乏互操作性而感到沮丧。SPIRE 提供了一个插件模型，允许开发人员和集成商扩展 SPIRE 以满足他们的需求。如果企业需要一套专有的 API 来生成 SPIRE 的密钥，或者 SPIRE 的中间签名密钥应该存在于特定的专有密钥管理服务（KMS）中，那么这种能力就特别重要。开发人员也不需要担心为即将上线的新工作负载开发定制的包装器，因为该组织正在遵守一个开放的规范。&lt;/p&gt;
&lt;p&gt;许多团队不敢改变或删除允许网络间追踪的防火墙规则，因为这可能会对关键系统的可用性产生不利影响。运维可以将身份及其相关策略的范围扩大到应用而不是全局。运维将有信息更改本地范围的身份和策略，而不必担心对下游的影响。&lt;/p&gt;
&lt;h3 id=&#34;改善日常工作&#34;&gt;改善日常工作&lt;/h3&gt;
&lt;p&gt;如果没有一个强大的软件身份系统，服务之间的访问管理通常是通过使用网络层面的控制（例如，基于 IP / 端口的策略）来完成的。不幸的是，这种方法产生了大量与管理网络访问控制列表（ACL）相关的操作。随着弹性基础设施的增减，以及网络拓扑结构的变化，这些 ACL 需要不间断的维护。它们甚至会妨碍新基础设施的启用，因为现有的系统现在需要被告知新组件的存在。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 致力于减少这种辛劳，因为与网络上的主机和工作负载的安排相比，软件身份的概念相对稳定。此外，它们还为将授权决策委托给服务所有者本身铺平了道路，因为他们最终处于做出这种决策的最佳位置。例如，希望向新的消费者授予访问权的服务所有者，他们不需要关心网络层面的细节就可以创建访问策略 —— 他们可以简单地声明他们希望授予访问权的服务名称，然后继续。&lt;/p&gt;
&lt;p&gt;SPIFFE/SPIRE 还致力于提高可观测性、监测以及最终对服务水平目标（SLO）的遵守。通过在许多不同类型的系统中规范软件身份（不一定只是容器化或云原生），并提供身份发布和使用的审计跟踪，SPIFFE/SPIRE 可以在事件发生之前、期间和之后极大地提高态势感知。更成熟的团队甚至会发现，它可以提高预测影响服务可用性问题的能力。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>简介</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/intro/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/intro/</guid>
      <description>
        
        
        &lt;p&gt;云原生应用由多个松散耦合的组件（称为微服务，通常以容器形式实现）组成，在需要零信任概念的无边界网络环境中运行（企业内部或云），并由来自不同地点的用户访问（例如，校园、家庭办公室等）。云原生应用不只是指在云中运行的应用。它们还指具有设计和运行时架构的一类应用，如微服务，以及用于提供所有应用服务（包括安全）的专用基础设施。将 &lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf&#34; title=&#34;零信任原则&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;零信任原则&lt;/a&gt; 纳入这类应用提供了一些技术，其中对所有受保护资源的访问是通过基于身份的保护和基于网络的保护（如微分）来强制执行的。&lt;/p&gt;
&lt;p&gt;由于业务原因，云原生应用程序需要敏捷和安全的更新和部署技术，以及应对网络安全事件的必要弹性。因此，它们需要一种与传统的单层或多层应用不同的应用开发、部署和运行时监控范式（统称为软件生命周期范式）。DevSecOps（开发、安全和运维）是这类应用的促进范式，因为它通过（a）持续集成、持续交付 / 持续部署（CI/CD）管道（在第 3 节中解释）等基本要素促进了敏捷和安全的开发、交付、部署和运维；（b）整个生命周期的安全测试；以及（c）运行时的持续监控，所有这些都由自动化工具支持。事实上，满足上述目标的范式最初被赋予了 DevOps 这个术语，以表明它试图消除开发和运维之间的隔阂，并促进（或推动）加强合作。后来，DevSecOps 这个词是由社区的一部分人创造的，以强调安全团队在整个过程中的作用。因此，DevSecOps 这个术语表示一种文化和一套带有自动化工具的实践，以推动负责交付软件的关键利益相关者（包括开发、运维和安全组织）之间加强协作、信任、分担责任、透明度、自主性、敏捷性和自动化。DevSecOps 拥有必要的基本要素和其他构建模块，以满足云原生应用的设计目标。&lt;/p&gt;
&lt;p&gt;应该注意的是，整个社区对 DevSecOps 一词并无共识。如前所述，该术语主要是为了强调一个事实，即必须在软件开发生命周期的所有阶段（即构建、测试、打包、部署和运行）对安全进行测试和整合。社区中的一部分人继续使用 DevOps 这个术语，理由是没有必要定义一个新的术语，因为安全必须是任何软件生命周期过程的一个组成部分。&lt;/p&gt;
&lt;h2 id=&#34;11-范围&#34;&gt;1.1 范围&lt;/h2&gt;
&lt;p&gt;从理论上讲，DevSecOps 原语可以应用于许多应用架构，但最适合于基于微服务的架构，由于应用是由相对较小的、松散耦合的模块组成的，被称为微服务，因此允许采用敏捷开发模式。即使在基于微服务的架构中，DevSecOps 原语的实现也可以采取不同的形式，这取决于平台。在本文中，所选择的平台是一个容器编排和资源管理平台（如 Kubernetes）。该平台是物理（裸机）或虚拟化（如虚拟机、容器）基础设施上的一个抽象层。为了在本文中明确提及该平台或应用环境，它被称为 &lt;strong&gt;DevSecOps 原语参考平台&lt;/strong&gt;，或简称为 &lt;strong&gt;参考平台&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在描述参考平台的 DevSecOps 原语的实现之前，我们假设在部署服务网格组件方面采用了以下 &lt;a href=&#34;https://www.oreilly.com/library/view/cloud-native-infrastructure/9781491984291/&#34; title=&#34;尽职调查&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;尽职调查&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于部署和管理基于服务网格的基础设施（如网络路由）、策略执行和监控组件的安全设计模式&lt;/li&gt;
&lt;li&gt;测试证明这些服务网格组件在应用的各个方面（如入口、出口和内部服务）的各种情况下都能按预期工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为参考平台实施 DevSecOps 原语所提供的指导与 (a) DevSecOps 管道中使用的工具和 (b) 提供应用服务的服务网格软件无关，尽管来自 Istio 等服务网格产品的例子被用来将它们与现实世界的应用工件（如容器、策略执行模块等）联系起来。&lt;/p&gt;
&lt;p&gt;以下是对参考平台所呈现的整个应用环境中的代码类型（在执行摘要中提到）的稍微详细的描述。请注意，这些代码类型包括那些支持实施 DevSecOps 原语的代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用代码：体现了执行一个或多个业务功能的应用逻辑，由描述业务事务和数据库访问的代码组成。&lt;/li&gt;
&lt;li&gt;应用服务代码（如服务网格代码）：为应用提供各种服务，如服务发现、建立网络路由、网络弹性服务（如负载均衡、重试），以及安全服务（如根据策略强制执行认证、授权等，见第 4 章）。&lt;/li&gt;
&lt;li&gt;基础设施即代码：以声明性代码的形式表达运行应用程序所需的计算、网络和存储资源。&lt;/li&gt;
&lt;li&gt;策略即代码：包含声明性代码，用于生成实现安全目标的规则和配置参数，例如在运行期间通过安全控制（如认证、授权）实现零信任。&lt;/li&gt;
&lt;li&gt;可观测性即代码：触发与日志（记录所有事务）和追踪（执行应用程序请求所涉及的通信途径）以及监控（在运行期间跟踪应用程序状态）有关的软件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码类型 3、4 和 5 可能与代码类型 2 有重叠。&lt;/p&gt;
&lt;p&gt;本文件涵盖了与上述所有五种代码类型相关的管道或工作流程的实施。因此，整个应用环境（不仅仅是应用代码）受益于应用代码的所有最佳实践（例如，敏捷迭代开发、版本控制、治理等）。基础设施即代码、策略即代码和可观测性即代码属于一个特殊的类别，称为声明性代码。当使用“xx 即代码”的技术时，编写的代码（例如，用于配置资源的代码）被管理，类似于应用源代码。这意味着它是有版本的，有文件的，并且有类似于应用源代码库的访问控制定义。通常，使用特定领域的声明性语言：声明需求，并由相关工具将其转换为构成运行时实例的工件。例如，在基础设施即代码（IaC）的情况下，声明性语言将基础设施建模为一系列的资源。相关的配置管理工具将这些资源集中起来，并生成所谓的 &lt;strong&gt;清单&lt;/strong&gt;，定义与所定义的资源相关的平台（运行时实例）的最终状态。这些清单存储在与配置管理工具相关的服务器中，并由该工具用于为指定平台上的运行时实例创建编译的配置指令。清单通常以平台中立的表示方式（如 JSON）进行编码，并通过 REST API 反馈给平台资源配置代理。&lt;/p&gt;
&lt;h2 id=&#34;12-相关的-devsecops-倡议&#34;&gt;1.2 相关的 DevSecOps 倡议&lt;/h2&gt;
&lt;p&gt;在联邦政府的各个机构中，有几个 DevSecOps 倡议，其重点和焦点各不相同，这取决于软件和任务需求所带来的流程。尽管并不详尽，但以下是对 &lt;a href=&#34;https://federalnewsnetwork.com/wp-content/uploads/2021/12/120821_Expert-Edition_DevSecOps.pdf&#34; title=&#34;这些倡议&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这些倡议&lt;/a&gt; 的简要概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DevSecOps 管道参与构建、签入和签出一个名为 Iron Bank 的容器镜像仓库，这是一个经过国防部审查的强化容器镜像库。&lt;/li&gt;
&lt;li&gt;空军的 Platform One，也就是实现了连续操作授权（C-ATO）概念的 DevSecOps 平台，这又简化了国防部的授权程序，以适应现代连续软件部署的速度和频率。&lt;/li&gt;
&lt;li&gt;国家地理空间情报局（NGA）在 &amp;quot;NGA 软件之路&amp;quot; 中概述了其 DevSecOps 战略，其中为其每个软件产品规定了三个关键指标：可用性、准备时间和部署频率，以及用于实现 DevSecOps 管道的七个不同产品系列的规格，包括消息传递和工作流工具。&lt;/li&gt;
&lt;li&gt;医疗保险和医疗补助服务中心（CMS）正在采用一种 DevSecOps 方法，其中一个重点是为软件材料清单（SBOM）奠定基 —— 这是一种正式记录，包含用于构建软件的各种组件的细节和供应链关系。制作 SBOM 的目的是为了实现持续诊断和缓解（CDM）计划下的目标。&lt;/li&gt;
&lt;li&gt;在海军水面作战中心（NSWC），DevSecOps 原语的实施方法被用来教导和培训软件工作人员，让他们了解各种软件指标以及自动化作为实现这些指标的助推器的作用。&lt;/li&gt;
&lt;li&gt;陆军的 DevSecOps 倡议被称为 &amp;ldquo;陆军软件工厂&amp;rdquo;，重点是建立技能组合而不是建立软件。它利用 DevSecOps 能力（管道和平台即服务功能）作为技术加速器，在产品管理、用户体验、用户界面（UI/UX）设计、平台和软件工程方面提高效率和熟练度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-目标受众&#34;&gt;1.3 目标受众&lt;/h2&gt;
&lt;p&gt;由于 DevSecOps 的基本要素跨越了开发（安全的构建和测试、打包）、交付 / 部署和持续监控（以确保运行期间的安全状态），本文建议的目标受众包括软件开发、运维和安全团队。&lt;/p&gt;
&lt;h2 id=&#34;14-与其他-nist-指导文件的关系&#34;&gt;1.4 与其他 NIST 指导文件的关系&lt;/h2&gt;
&lt;p&gt;由于参考平台是由容器编排和资源管理平台以及服务网格软件组成的，以下出版物为确保该平台的安全提供了指导，并为本文件的内容提供了背景信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SP800-204，&lt;a href=&#34;https://doi.org/10.6028/NIST.SP.800-204&#34; title=&#34;基于微服务的应用系统的安全策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于微服务的应用系统的安全策略&lt;/a&gt;，讨论了基于微服务的应用的特点和安全要求，以及满足这些要求的总体策略。&lt;/li&gt;
&lt;li&gt;SP800-204A，&lt;a href=&#34;https://doi.org/10.6028/NIST.SP.800-204A&#34; title=&#34;使用服务网格构建基于微服务的安全应用&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用服务网格构建基于微服务的安全应用&lt;/a&gt;，为基于微服务的应用的各种安全服务（如建立安全会话、安全监控等）提供了部署指导，这些服务使用基于独立于应用代码运行的服务代理的专用基础设施（即服务网格）。&lt;/li&gt;
&lt;li&gt;SP800-204B，&lt;a href=&#34;https://doi.org/10.6028/NIST.SP.800-204B&#34; title=&#34;使用服务网格的基于微服务的应用的基于属性的访问控制&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用服务网格的基于微服务的应用的基于属性的访问控制&lt;/a&gt;，为在服务网格中构建满足安全要求的认证和授权框架提供了部署指导，例如：（1）通过在任何一对服务之间的通信中实现相互认证来实现零信任；（2）基于访问控制模型，如基于属性的访问控制（ABAC）模型的强大访问控制机制，可用于表达广泛的策略集，并在用户群、对象（资源）和部署环境方面可扩展。&lt;/li&gt;
&lt;li&gt;SP800-190，&lt;a href=&#34;https://doi.org/10.6028/NIST.SP.800-190&#34; title=&#34;应用容器安全指南&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用容器安全指南&lt;/a&gt;，解释了与容器技术相关的安全问题，并为在规划、实施和维护容器时解决这些问题提出了实用建议。这些建议是针对容器技术架构中的每个层级提供的。&amp;mdash;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15-本文件的组织&#34;&gt;1.5 本文件的组织&lt;/h2&gt;
&lt;p&gt;本文件的结构如下：&lt;/p&gt;
&lt;p&gt;第二章简要介绍了参考平台，为其提供了实施 DevSecOps 原语的指导。&lt;/p&gt;
&lt;p&gt;第三章介绍了 DevSecOps 的基本要素（即管道），设计和执行管道的方法，以及自动化在执行中的作用。&lt;/p&gt;
&lt;p&gt;第四章涵盖了管道的所有方面，包括（a）所有管道需要解决的共同问题，（b）对第 1.1 节中列出的参考平台中五种代码类型的管道的描述，以及（c）DevSecOps 在整个生命周期中对整个应用环境（有五种代码类型的参考平台，因此承载着 DevSecOps 的实施）的安全保证的好处，包括 &lt;strong&gt;持续授权操作（C-ATO）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第五章提供了摘要和结论。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>执行摘要</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/executive-summary/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/executive-summary/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes® 是一个开源系统，可以自动部署、扩展和管理在容器中运行的应用程序，并且通常托管在云环境中。与传统的单体软件平台相比，使用这种类型的虚拟化基础设施可以提供一些灵活性和安全性的好处。然而，安全地管理从微服务到底层基础设施的所有方面，会引入其他的复杂性。本报告中详述的加固指导旨在帮助企业处理相关风险并享受使用这种技术的好处。&lt;/p&gt;
&lt;p&gt;Kubernetes 中三个常见的破坏源是供应链风险、恶意威胁者和内部威胁。&lt;/p&gt;
&lt;p&gt;供应链风险往往是具有挑战性的，可以在容器构建周期或基础设施收购中出现。恶意威胁者可以利用 Kubernetes 架构的组件中的漏洞和错误配置，如控制平面、工作节点或容器化应用程序。内部威胁可以是管理员、用户或云服务提供商。对组织的 Kubernetes 基础设施有特殊访问权的内部人员可能会滥用这些特权。&lt;/p&gt;
&lt;p&gt;本指南描述了与设置和保护 Kubernetes 集群有关的安全挑战。包括避免常见错误配置的加固策略，并指导国家安全系统的系统管理员和开发人员如何部署 Kubernetes，并提供了建议的加固措施和缓解措施的配置示例。本指南详细介绍了以下缓解措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扫描容器和 Pod 的漏洞或错误配置。&lt;/li&gt;
&lt;li&gt;以尽可能少的权限运行容器和 Pod。&lt;/li&gt;
&lt;li&gt;使用网络隔离来控制漏洞可能造成的损害程度。&lt;/li&gt;
&lt;li&gt;使用防火墙来限制不需要的网络连接，并使用加密技术来保护机密。&lt;/li&gt;
&lt;li&gt;使用强大的认证和授权来限制用户和管理员的访问，以及限制攻击面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用日志审计，以便管理员可以监控活动，并对潜在的恶意活动发出警告。&lt;/p&gt;
&lt;p&gt;定期审查所有 Kubernetes 设置，并使用漏洞扫描，以帮助确保风险得到适当考虑并应用安全补丁。&lt;/p&gt;
&lt;p&gt;有关其他安全加固指导，请参见互联网安全中心 Kubernetes 基准、Docker 和 Kubernetes 安全技术实施指南、网络安全和基础设施安全局（CISA）分析报告以及 Kubernetes 文档。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 工作负载 API</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/</guid>
      <description>
        
        
        &lt;p&gt;对于互联网工作负载而言，可移植和互操作的网络工作负载的加密身份可能是 SPIFFE 的核心用例。为了完全满足这个需求，社区必须达成一致，采用一种标准化的方式来检索、验证和与 SPIFFE 身份进行交互。本规范概述了要支持基于 SPIFFE 的身份验证系统所需的 API 签名和客户端/服务器行为。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 是一个 API，它提供了信息和服务，使工作负载或计算进程能够利用 SPIFFE 身份和基于 SPIFFE 的身份验证系统。它由 SPIFFE 工作负载端点提供，并由一些服务或“概要”组成。&lt;/p&gt;
&lt;p&gt;目前，有两个概要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X.509-SVID 概要&lt;/li&gt;
&lt;li&gt;JWT-SVID 概要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个概要是强制性的，并且 SPIFFE 实现必须支持它们。但是，运营商可以在部署中禁用特定的概要。&lt;/p&gt;
&lt;p&gt;本规范的未来版本可能会引入其他概要或使一个或多个概要成为可选项。&lt;/p&gt;
&lt;h2 id=&#34;可扩展性&#34;&gt;可扩展性&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 不能超出本规范进行扩展。希望提供扩展功能的实现者可以通过引入新的 gRPC 服务来实现，这是根据 SPIFFE 工作负载端点规范中概述的可扩展性方法来实现的。&lt;/p&gt;
&lt;h2 id=&#34;服务定义&#34;&gt;服务定义&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 由一份协议缓冲区（版本 3）服务定义来定义。完整的定义可以在 workloadapi.proto 中找到。&lt;/p&gt;
&lt;p&gt;概要作为单个&lt;code&gt;WorkloadAPI&lt;/code&gt;服务中的一组相关的 RPC 实现。&lt;/p&gt;
&lt;h2 id=&#34;客户端和服务器行为&#34;&gt;客户端和服务器行为&lt;/h2&gt;
&lt;h3 id=&#34;身份标识调用者&#34;&gt;身份标识调用者&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 支持任意数量的本地客户端，使其能够引导任何能够访问它的进程的身份标识。通常，希望为每个进程分配身份标识，其中某些进程被授予特定的身份标识。为了做到这一点，SPIFFE 工作负载 API 实现必须能够确定调用者的身份标识。&lt;/p&gt;
&lt;p&gt;SPIFFE 工作负载端点规范规定了不直接进行客户端身份验证的要求，而是依赖于带外真实性检查。因此，SPIFFE 工作负载端点实现有责任识别调用者。然后，SPIFFE 工作负载 API 可以利用有关调用者的信息来确定要提供的适当内容。有关详细信息，请参阅 SPIFFE 工作负载端点规范中的身份验证部分。&lt;/p&gt;
&lt;h3 id=&#34;连接生命周期&#34;&gt;连接生命周期&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 的客户端应尽可能保持打开连接的状态，等待流上接收服务器的响应消息。连接可以随时由服务器或客户端终止。在这种情况下，客户端应立即建立新连接。这有助于确保工作负载保持最新的身份相关材料。SPIFFE 工作负载 API 服务器实现者可以假设此属性，如果未能及时接收到消息，则工作负载可能过时，可能会影响其可用性。&lt;/p&gt;
&lt;h3 id=&#34;流式响应&#34;&gt;流式响应&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 包括使用 gRPC 服务器端流式传输的 RPC，以促进快速传播更新，例如吊销和 CA 证书引入。这使得客户端可以循环遍历服务器响应，接受发生的更新。&lt;/p&gt;
&lt;p&gt;服务器发送的每个流式响应消息都必须包含完整的信息集，而不仅仅是发生更改的信息。这避免了在客户端和服务器实现上进行状态跟踪的复杂性，包括对反熵机制的需求。&lt;/p&gt;
&lt;p&gt;服务器响应消息的确切定时是特定于实现的，并且应由更改响应的事件（例如 SVID 旋转、CRL 更新等）来决定。从客户端接收到请求消息被视为生成响应的事件。换句话说，服务器响应流的第一个响应消息（基于连接的基础上）应尽快发送，不延迟。&lt;/p&gt;
&lt;p&gt;最后，SPIFFE 工作负载 API 服务器的实现者应小心地推送更新的响应消息。一些软件可能会在接收到新信息后自动重新加载，如果所有实例同时重新加载，可能会导致一段时间的不可用。&lt;/p&gt;
&lt;h2 id=&#34;默认值和删除的信息&#34;&gt;默认值和删除的信息&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 响应消息是对先前发送的响应消息的完整更新。当响应消息包含设置为默认值或空值的字段时，客户端必须将这些字段的值解释为已设置为它们的默认值或空值；在接收到字段的默认值或空值之后，先前接收到的非默认值或非空值不应由客户端保留。例如，如果客户端在&lt;code&gt;federated_bundles&lt;/code&gt;字段中接收到默认值，则应舍弃先前接收到的&lt;code&gt;federated_bundles&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;由于每个消息必须包含完整的信息集（请参阅 Stream Responses 部分），客户端应将数据的缺失解释为删除。例如，如果客户端加载了&lt;code&gt;spiffe://foo.bar&lt;/code&gt;的 bundle，并接收到不包含&lt;code&gt;spiffe://foo.bar&lt;/code&gt;的 bundle 的消息，则应卸载该 bundle。&lt;/p&gt;
&lt;h3 id=&#34;强制字段&#34;&gt;强制字段&lt;/h3&gt;
&lt;p&gt;为了执行 profile RPC，交换的消息由强制和可选字段组成。服务器在接收到具有默认值的强制字段的消息时，应使用“InvalidArgument”gRPC 状态代码进行响应（有关更多信息，请参阅 SPIFFE Workload Endpoint 规范中的错误代码部分）。当客户端接收到具有默认值的强制字段的消息时，应报告错误并丢弃该消息。&lt;/p&gt;
&lt;h3 id=&#34;联邦-bundle&#34;&gt;联邦 Bundle&lt;/h3&gt;
&lt;p&gt;在此规范中定义的各种 RPC 可以返回来自外部信任域的信任 Bundle。包含外部 Bundle 可以使工作负载在信任域之间进行通信，并且是启用联邦的主要机制。代表外部信任域的 Bundle 称为&lt;em&gt;联邦 Bundle&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在验证客户端时，验证器会选择代表客户端所呈现的信任域的 Bundle 进行验证。同样，在验证服务器时，客户端会使用代表服务器所在的信任域的 Bundle。如果在使用的 SVID 的 SVID 中不存在匹配的 Bundle，则对等方是不受信任的。这种方法是必需的，以解决常见 X.509 库中对 SAN URI Name Constraints 的广泛支持的缺乏。&lt;/p&gt;
&lt;h2 id=&#34;x509-svid-profile&#34;&gt;X.509-SVID Profile&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 的 X.509-SVID 配置文件提供了一组 gRPC 方法，工作负载可以使用这些方法来检索 X.509-SVIDs 及其相关的信任捆绑包。该配置文件概述了这些方法的签名，以及相关的客户端和服务器行为。&lt;/p&gt;
&lt;h3 id=&#34;配置文件定义&#34;&gt;配置文件定义&lt;/h3&gt;
&lt;p&gt;下面定义了 X.509-SVID 配置文件中的 RPC 和相关的消息。有关完整的 Workload API 服务定义，请参见 workloadapi.proto。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SpiffeWorkloadAPI&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// X509-SVID配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取工作负载有权访问的所有SPIFFE标识的X.509-SVID，以及与之相关的信任捆绑包和CRL。随着信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchX509SVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X509SVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509SVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取信任捆绑包和CRL。对于仅需要验证SVID而不获取SVID自身的客户端非常有用。随着信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchX509Bundles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X509BundlesRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509BundlesResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 其他配置文件的RPC ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVIDRequest消息传递请求X.509-SVID的参数。目前没有此类参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVIDResponse消息携带X.509-SVID和相关信息，包括用于与外部信任域联合的全局CRL集合和捆绑列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。X509SVID消息列表，每个消息包括单个X.509-SVID、其私钥和信任域的捆绑。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509SVID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。ASN.1 DER编码的证书吊销列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;crl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。工作负载应该信任的外部信任域的CA证书捆绑，按照外部信任域的SPIFFE ID进行索引。捆绑包是ASN.1 DER编码的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;federated_bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVID消息携带单个SVID和所有相关信息，包括信任域的X.509捆绑包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVID&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。此条目中的SVID的SPIFFE ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。ASN.1 DER编码的证书链。可以包括中间证书，但必须首先是叶子证书（或SVID本身）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x509_svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。ASN.1 DER编码的PKCS#8私钥。必须是未加密的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x509_svid_key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。信任域的ASN.1 DER编码的X.509捆绑包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。操作员指定的字符串，用于在返回多个SVID时为工作负载提供其使用方式的指导。例如，`internal`和`external`分别表示内部或外部使用的SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509BundlesRequest消息传递请求X.509捆绑包的参数。目前没有这样的参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509BundlesRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509BundlesResponse消息携带一组全局CRL和工作负载应该信任的信任域的映射的CA证书捆绑包。由SPIFFE ID的信任域键控。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509BundlesResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。ASN.1 DER编码的证书吊销列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;crl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。工作负载应该信任的信任域的CA证书捆绑包，由SPIFFE ID的信任域键控。捆绑包是ASN.1 DER编码的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;profile-rpcs&#34;&gt;Profile RPCs&lt;/h3&gt;
&lt;h3 id=&#34;fetchx509svid&#34;&gt;FetchX509SVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchX509SVID&lt;/code&gt; RPC 流式返回 X509-SVID 和信任域以及外部信任域的 X.509 捆绑包。这些捆绑包只能用于验证 X509-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVIDRequest&lt;/code&gt;请求消息当前为空，是将来扩展的占位符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVIDResponse&lt;/code&gt;响应由一个必需的&lt;code&gt;svids&lt;/code&gt;字段组成，该字段必须包含一个或多个&lt;code&gt;X509SVID&lt;/code&gt;消息（每个授予客户端的标识一个）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVID&lt;/code&gt;消息中的所有字段都是必需的，除了&lt;code&gt;hint&lt;/code&gt;字段。当设置&lt;code&gt;hint&lt;/code&gt;字段时（即非空），SPIFFE Workload API 服务器必须确保其值在任何给定的&lt;code&gt;X509SVIDResponse&lt;/code&gt;消息中是唯一的。如果 SPIFFE Workload API 客户端遇到具有相同设置的&lt;code&gt;hint&lt;/code&gt;值的多个&lt;code&gt;X509SVID&lt;/code&gt;消息，则应选择列表中的第一个消息。&lt;/p&gt;
&lt;p&gt;如果客户端没有权限接收任何 X509-SVID，则服务器应以“PermissionDenied”gRPC 状态代码响应（有关更多信息，请参见 SPIFFE Workload Endpoint 规范中的“错误代码”部分）。在这种情况下，客户端可以在退避后尝试重新连接到&lt;code&gt;FetchX509SVID&lt;/code&gt; RPC 的另一个调用。&lt;/p&gt;
&lt;p&gt;如流式响应所述，每个 FetchX509SVID 流返回的 X509SVIDResponse 消息都包含客户端在那个时间点上的授权 SVID 和 bundle 的完整集合。因此，如果服务器从后续响应中删除了 SVID（或全部 SVID，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用已删除的 SVID。&lt;/p&gt;
&lt;h3 id=&#34;fetchx509bundles&#34;&gt;FetchX509Bundles&lt;/h3&gt;
&lt;p&gt;FetchX509Bundles RPC 流返回服务器所在的信任域和外部信任域的 X.509 bundles。这些 bundles 只用于验证 X509-SVID。&lt;/p&gt;
&lt;p&gt;X509BundlesRequest 请求消息目前为空，是未来扩展的占位符。&lt;/p&gt;
&lt;p&gt;X509BundlesResponse 响应消息有一个强制性的 bundles 字段，必须至少包含服务器所在信任域的信任 bundle。crl 字段是可选的。&lt;/p&gt;
&lt;p&gt;如果客户端无权接收任何 X.509 bundles，那么服务器应以“PermissionDenied”gRPC 状态代码响应（有关更多信息，请参见 SPIFFE Workload Endpoint 规范中的错误代码部分）。客户端可以在退避后尝试重新连接 FetchX509Bundles RPC。&lt;/p&gt;
&lt;p&gt;如流式响应所述，每个 X509BundleResponse 响应在那个时间点上包含客户端的授权 X.509 bundles 的完整集合。因此，如果服务器从后续响应中删除了 bundles（或全部 bundles，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用已删除的 bundles。&lt;/p&gt;
&lt;h3 id=&#34;默认身份&#34;&gt;默认身份&lt;/h3&gt;
&lt;p&gt;通常情况下，工作负载不知道它应该扮演什么身份。决定何时扮演何种身份是特定于站点的问题，因此，SPIFFE 规范不涉及如何做到这一点。&lt;/p&gt;
&lt;p&gt;为了支持最广泛的用例，X.509-SVID 配置文件支持发出多个身份，并定义了默认身份。预计了解多个身份的工作负载可以自行进行决策。不了解如何利用多个身份的工作负载可以使用默认身份。默认身份是在 X509SVIDResponse 消息中返回的&lt;code&gt;svids&lt;/code&gt;列表中的第一个。协议缓冲区确保列表的顺序得到保留。&lt;/p&gt;
&lt;p&gt;了解如何使用多个身份的工作负载可以利用可选的&lt;code&gt;hint&lt;/code&gt;字段，该字段可用于消除身份的歧义，并告知工作负载应该为何目的使用哪个身份。例如，&lt;code&gt;internal&lt;/code&gt;和&lt;code&gt;external&lt;/code&gt;分别表示用于内部或外部使用的 SVID。SPIFFE Workload API 实现不应支持超过 1024 字节长度的值。&lt;code&gt;hint&lt;/code&gt;字段的确切值是操作员的选择，除此规范外并无限制。&lt;/p&gt;
&lt;p&gt;工作负载有责任处理预期提示的缺失或意外存在（例如，失败、警告等）。&lt;/p&gt;
&lt;h2 id=&#34;jwt-svid-配置文件&#34;&gt;JWT-SVID 配置文件&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 的 JWT-SVID 配置文件提供了一组 gRPC 方法，可以用于工作负载获取 JWT-SVID 及其相关的信任包。该配置文件概述了这些方法的签名，以及相关的客户端和服务器行为。&lt;/p&gt;
&lt;h3 id=&#34;配置文件定义-1&#34;&gt;配置文件定义&lt;/h3&gt;
&lt;p&gt;JWT-SVID 配置文件的 RPC 和相关消息如下所定义。有关完整的 Workload API 服务定义，请参见 workloadapi.proto。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SpiffeWorkloadAPI&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// JWT-SVID配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取工作负载有权访问的所有SPIFFE标识的JWT-SVID，用于请求的受众。如果请求了可选的SPIFFE ID，则仅返回该SPIFFE ID的JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchJWTSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTSVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTSVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取以JWKS文档格式表示的JWT信任包，由信任域的SPIFFE ID作为键。随着这些信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchJWTBundles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTBundlesRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JWTBundlesResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 根据请求的受众验证JWT-SVID。返回JWT-SVID的SPIFFE ID和JWT声明。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ValidateJWTSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValidateJWTSVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValidateJWTSVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 其他配置文件的RPC ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。工作负载打算进行身份验证的受众。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audience&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。请求的JWT-SVID的SPIFFE ID。如果未设置，则返回工作负载有权访问的所有标识的JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTSVIDResponse消息传递JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。返回的JWT-SVID列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JWTSVID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTSVID消息携带JWT-SVID令牌和相关元数据。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVID&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。JWT-SVID的SPIFFE ID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。使用JWS紧凑序列化的编码JWT。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。操作员指定的字符串，用于在返回多个SVID时为工作负载提供如何使用此标识的指导。例如，`internal`和`external`分别表示用于内部或外部使用的SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTBundlesRequest消息传递请求JWT信任包的参数。目前没有请求参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTBundlesRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTBundlesReponse传递JWT信任包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTBundlesResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。以信任域的SPIFFE ID为键的JWK编码的JWT信任包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ValidateJWTSVIDRequest消息传递JWT-SVID验证的请求参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ValidateJWTSVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证方的受众。JWT-SVID必须包含一个包含此值的受众声明才能成功验证。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audience&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。要验证的JWT-SVID，使用JWS紧凑序列化进行编码。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ValidateJWTSVIDReponse消息传递JWT-SVID验证结果。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ValidateJWTSVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证的JWT-SVID的SPIFFE ID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证的JWT-SVID有效载荷中包含的声明。包括SPIFFE所需和非所需的声明。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;google.protobuf.Struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;claims&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;配置文件-rpc&#34;&gt;配置文件 RPC&lt;/h3&gt;
&lt;h3 id=&#34;获取-jwtsvid&#34;&gt;获取 JWTSVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchJWTSVID&lt;/code&gt; RPC 允许客户端请求一个或多个特定受众的短期 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVIDRequest&lt;/code&gt; 请求消息包含一个必填的&lt;code&gt;audience&lt;/code&gt;字段，该字段必须包含要嵌入返回的 JWT-SVID 中的受众声明的值。&lt;code&gt;spiffe_id&lt;/code&gt;字段是可选的，用于请求特定 SPIFFE ID 的 JWT-SVID。如果未指定，服务器必须返回授权给客户端的所有身份的 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVIDResponse&lt;/code&gt; 响应消息由一个必填的&lt;code&gt;svids&lt;/code&gt;字段组成，该字段必须包含一个或多个&lt;code&gt;JWTSVID&lt;/code&gt;消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVID&lt;/code&gt;消息中的所有字段都是必填的，除了&lt;code&gt;hint&lt;/code&gt;字段。当设置了&lt;code&gt;hint&lt;/code&gt;字段（即非空）时，SPIFFE Workload API 服务器必须确保其值在给定的&lt;code&gt;JWTSVIDResponse&lt;/code&gt;消息中的返回的 SVID 集合中是唯一的。如果 SPIFFE Workload API 客户端遇到具有相同&lt;code&gt;hint&lt;/code&gt;值设置的多个&lt;code&gt;JWTSVID&lt;/code&gt;消息，则应选择列表中的第一个消息。&lt;/p&gt;
&lt;p&gt;如果客户端没有授权任何身份，或者未经授权访问&lt;code&gt;spiffe_id&lt;/code&gt;字段请求的特定身份，则服务器应使用“PermissionDenied”gRPC 状态代码进行响应（有关更多信息，请参见 SPIFFE Workload 端点规范中的错误代码部分）。&lt;/p&gt;
&lt;h3 id=&#34;获取-jwt-bundles&#34;&gt;获取 JWT Bundles&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchJWTBundles&lt;/code&gt; RPC 返回服务器所在的信任域和外部信任域的 JWT bundles。这些 bundles 必须仅用于认证 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTBundlesRequest&lt;/code&gt;请求消息目前为空，是未来扩展的占位符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTBundlesResponse&lt;/code&gt;响应消息由一个必填的&lt;code&gt;bundles&lt;/code&gt;字段组成，该字段必须至少包含服务器所在信任域的 JWT bundle。&lt;/p&gt;
&lt;p&gt;返回的 bundles 以&lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; title=&#34;RFC 7517&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517&lt;/a&gt;定义的标准 JWK Set 格式进行编码，其中包含信任域的 JWT-SVID 签名密钥。这些密钥可能仅表示 SPIFFE 信任域中的密钥子集。服务器不得在返回的 JWT bundles 中包含其他用途的密钥。&lt;/p&gt;
&lt;p&gt;如果客户端无权接收任何 JWT bundles，则服务器应使用“PermissionDenied”gRPC 状态代码进行响应（有关更多信息，请参见 SPIFFE Workload 端点规范中的错误代码部分）。客户端可以在退避后尝试重新连接到&lt;code&gt;FetchJWTBundles&lt;/code&gt; RPC 的另一个调用。&lt;/p&gt;
&lt;p&gt;如流式响应中所述，每个&lt;code&gt;JWTBundleResponse&lt;/code&gt;响应在当前时间点包含客户端的所有授权 JWT bundles 的完整集合。因此，如果服务器从后续响应中删除 bundles（或所有 bundles，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用被删除的 bundles。&lt;/p&gt;
&lt;h3 id=&#34;验证-jwtsvid&#34;&gt;验证 JWTSVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ValidateJWTSVID&lt;/code&gt; RPC 代表客户端验证特定受众的 JWT-SVID。此外，服务器必须根据 JWT-SVID 规范中概述的规则解析和验证 JWT-SVID。JWT-SVID 负载中嵌入的声明应在&lt;code&gt;ValidateJWTSVIDResponse&lt;/code&gt;中的&lt;code&gt;claims&lt;/code&gt;字段中提供；本规范中定义的声明是必需的，但实现可能会在将它们返回给客户端之前过滤非 SPIFFE 声明。SPIFFE 声明对于互操作性是必需的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValidateJWTSVIDRequest&lt;/code&gt;和&lt;code&gt;ValidateJWTSVIDResponse&lt;/code&gt;消息中的所有字段都是必填的。&lt;/p&gt;
&lt;h3 id=&#34;jwt-svid-验证&#34;&gt;JWT-SVID 验证&lt;/h3&gt;
&lt;p&gt;如果客户端支持，Workload API 客户端应使用&lt;code&gt;ValidateJWTSVID&lt;/code&gt;方法进行 JWT 验证，允许 SPIFFE Workload API 代表其执行验证。这样做可以避免工作负载实现验证逻辑，从而减少出错的可能性。&lt;/p&gt;
&lt;p&gt;当与传统的 JWT 验证器进行交互时，可以使用&lt;code&gt;FetchJWTBundles&lt;/code&gt;方法获取 JWKS bundles，用于验证 JWT-SVID 的签名。例如，如果 SPIFFE Workload API 可用，但 JWT 验证软件不知道 Workload API（因此无法调用&lt;code&gt;ValidateJWTSVID&lt;/code&gt;），则实现可以单独检索每个 bundle 并将其提供给传统工作负载进行验证。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FetchJWTBundles&lt;/code&gt;方法返回以信任域的 SPIFFE ID 为键的 bundles。在验证 JWT-SVID 时，验证器必须使用与主题的信任域对应的 bundle。如果指定信任域的 JWT bundle 不存在，则令牌是不可信的。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-示例实现状态机&#34;&gt;附录 A. 示例实现状态机&lt;/h2&gt;
&lt;p&gt;为了提供清晰度，作者认为包括 SPIFFE Workload API 的客户端和服务器实现的示例状态图可能是有用的。应注意，有许多实现方式可以符合本规范，此特定实现仅供参考。&lt;/p&gt;
&lt;h3 id=&#34;服务器状态机&#34;&gt;服务器状态机&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_server_diagram_hu17629793554316077681.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_server_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_server_diagram.png&#34; data-width=&#34;617&#34; data-height=&#34;555&#34; alt=&#34;image&#34; data-caption=&#34;服务器状态机&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;服务器状态机&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;SPIFFE Workload 端点侦听器正在启动。&lt;/li&gt;
&lt;li&gt;使用 SPIFFE Workload API 处理程序启动 gRPC 服务器，现在可以接受连接。&lt;/li&gt;
&lt;li&gt;正在验证传入的 FetchX509SVIDRequest。这包括检查强制性的安全头，并确保调用方可用身份。&lt;/li&gt;
&lt;li&gt;Workload API 正在向客户端发送 FetchX509SVIDResponse。&lt;/li&gt;
&lt;li&gt;Workload API 处于等待状态。从等待状态过渡需要中断或取消。中断等待状态的典型原因是响应中的信息已更新（例如，SVID 已旋转或 CRL 已更改）。&lt;/li&gt;
&lt;li&gt;对待处理的响应执行验证。确保客户端仍有权使用身份，并且请求尚未取消。&lt;/li&gt;
&lt;li&gt;服务器正在关闭流，为客户端提供正确的错误代码以表示遇到的条件。&lt;/li&gt;
&lt;li&gt;服务器遇到致命错误，必须停止。这可能发生在无法创建侦听器或 gRPC 服务器遇到致命错误的情况下。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;客户端状态机&#34;&gt;客户端状态机&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_client_diagram_hu16474358787020298591.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_client_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/standard/spiffe-workload-api/workload_api_client_diagram.png&#34; data-width=&#34;754&#34; data-height=&#34;402&#34; alt=&#34;image&#34; data-caption=&#34;客户端状态机&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;客户端状态机&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;Workload API 客户端正在拨号 SPIFFE Workload 端点。&lt;/li&gt;
&lt;li&gt;客户端正在调用 FetchX509SVID RPC 调用，向服务器发送请求。&lt;/li&gt;
&lt;li&gt;客户端正在阻塞等待从服务器接收 X509SVIDResponse 消息。&lt;/li&gt;
&lt;li&gt;客户端正在使用从服务器响应中接收的 SVIDs、CRLs 和 bundles 更新其配置。此时，它可以将接收到的信息与当前配置进行比较，确定是否需要重新加载。&lt;/li&gt;
&lt;li&gt;客户端遇到致命错误，必须退出。&lt;/li&gt;
&lt;li&gt;客户端正在执行指数回退。&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIRE Agent 配置参考</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/agent/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/agent/</guid>
      <description>
        
        
        &lt;p&gt;本文描述 SPIRE Agent 的命令行选项、agent.conf 设置和内置插件。&lt;/p&gt;
&lt;p&gt;本文档是 SPIRE Agent 的配置参考。它包括有关插件类型、内置插件、代理配置文件、插件配置和 &lt;code&gt;spire-agent&lt;/code&gt; 命令的命令行选项的信息。&lt;/p&gt;
&lt;h2 id=&#34;插件类型&#34;&gt;插件类型&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;生成并存储代理的私钥。对于将密钥绑定到硬件等很有用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;收集用于向服务器证明代理身份的信息。一般与同类型的服务器插件搭配使用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WorkloadAttestor&lt;/td&gt;
          &lt;td&gt;内省工作负载以确定其属性，生成一组与其关联的选择器。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SVIDStore&lt;/td&gt;
          &lt;td&gt;将 X509-SVID（私钥、叶证书和中间体（如果有））、捆绑包和联合捆绑包存储到信任存储中。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;内置插件&#34;&gt;内置插件&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_keymanager_disk.md&#34; title=&#34;disk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;disk&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;将私钥写入磁盘的密钥管理器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_keymanager_memory.md&#34; title=&#34;memory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;memory&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;不保留私钥的内存密钥管理器（必须在重新启动后重新证明）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_aws_iid.md&#34; title=&#34;aws_iid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws_iid&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 AWS 实例身份文档证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_azure_msi.md&#34; title=&#34;azure_msi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;azure_msi&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Azure MSI 令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_gcp_iit.md&#34; title=&#34;gcp_iit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gcp_iit&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 GCP 实例身份令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_jointoken.md&#34; title=&#34;join_token&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;join_token&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用服务器生成的加入令牌的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_k8s_sat.md&#34; title=&#34;k8s_sat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s_sat&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Kubernetes 服务帐户令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_k8s_psat.md&#34; title=&#34;k8s_psat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s_psat&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Kubernetes 投影服务帐户令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_sshpop.md&#34; title=&#34;sshpop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sshpop&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用现有 ssh 证书证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_nodeattestor_x509pop.md&#34; title=&#34; x509pop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; x509pop&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用现有 X.509 证书证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WorkloadAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_docker.md&#34; title=&#34;docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;工作负载证明器允许基于 docker 构造的选择器，例如 &lt;code&gt;label&lt;/code&gt; 和 &lt;code&gt;image_id&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WorkloadAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_k8s.md&#34; title=&#34;k8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;工作负载证明器允许基于 Kubernetes 的选择器构造 &lt;code&gt;ns&lt;/code&gt; （命名空间）和 &lt;code&gt;sa&lt;/code&gt; （服务帐户）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WorkloadAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_unix.md&#34; title=&#34;unix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;unix&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;一个工作负载证明器，可生成基于 Unix 的选择器，例如 &lt;code&gt;uid&lt;/code&gt; 和 &lt;code&gt;gid&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WorkloadAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_workloadattestor_systemd.md&#34; title=&#34;systemd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;systemd&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;工作负载证明器，根据 systemd 单元属性（例如 &lt;code&gt;Id&lt;/code&gt; 和 &lt;code&gt;FragmentPath&lt;/code&gt; 生成选择器）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SVIDStore&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_svidstore_aws_secretsmanager.md&#34; title=&#34;aws_secretsmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws_secretsmanager&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;SVIDstore 将机密存储在 AWS 机密管理器中，以及代理有权访问的条目的生成 X509-SVID。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SVIDStore&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_agent_svidstore_gcp_secretmanager.md&#34; title=&#34;gcp_secretmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gcp_secretmanager&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;SVIDStore 将机密存储在 Google Cloud Secret Manager 中，并包含代理有权访问的条目的结果 X509-SVID。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;代理配置文件&#34;&gt;代理配置文件&lt;/h2&gt;
&lt;p&gt;下表概述了 SPIRE 代理的配置选项。这些可以在配置文件的顶级 &lt;code&gt;agent { ... }&lt;/code&gt; 部分中设置。大多数选项都有一个相应的 CLI 标志，如果设置了该标志，则该标志优先于文件中定义的值。&lt;/p&gt;
&lt;p&gt;SPIRE 配置文件可以用 HCL 或 JSON 表示。请参阅示例配置文件部分以获取完整示例。&lt;/p&gt;
&lt;p&gt;如果 -expandEnv 标志传递给 SPIRE，则在解析之前扩展 &lt;code&gt;$VARIABLE&lt;/code&gt; 或 &lt;code&gt;${VARIABLE}&lt;/code&gt; 样式环境变量。这对于模板化配置文件可能很有用，例如跨不同的信任域，或者插入诸如加入令牌之类的秘密。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;admin_socket_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;绑定管理 API 套接字的位置（默认禁用）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;allow_unauthenticated_verifiers&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;允许代理向未经身份验证的验证者发布信任包&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;allowed_foreign_jwt_claims&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;验证外部 JWTSVID 时要返回的可信声明列表&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;authorized_delegates&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;授权代表的 SPIFFE ID 列表。请参阅委托身份 API 了解更多信息&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;data_dir&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;代理可用于其运行时数据的目录&lt;/td&gt;
          &lt;td&gt;$PWD&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;experimental&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;可能会更改或删除的实验选项（见下文）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;insecure_bootstrap&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，代理将在不验证服务器身份的情况下进行引导&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;join_token&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;由 SPIRE 服务器生成的可选令牌&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_file&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将日志写入的文件&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_level&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;设置日志记录级别&lt;/td&gt;
          &lt;td&gt;信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;日志格式，&lt;/td&gt;
          &lt;td&gt;文本&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_source_location&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，日志将包含源文件、行号和方法名称字段（增加一点运行时成本）&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_enabled&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，则启用 net/http/pprof 端点&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_freq&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将分析数据转储到磁盘的频率。仅当 &lt;code&gt;profiling_enabled&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 且 &lt;code&gt;profiling_freq&lt;/code&gt; &amp;gt; 0 时启用。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_names&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将在每个分析标记上转储到磁盘的配置文件名称列表，请参阅分析名称&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_port&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;net/http/pprof 端点的端口号。仅当 &lt;code&gt;profiling_enabled&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时使用。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;server_address&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的 DNS 名称或 IP 地址&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;server_port&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的端口号&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;socket_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;绑定 SPIRE Agent API 套接字的位置（仅限 Unix）&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;sds&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;可选的 SDS 配置部分&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;trust_bundle_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 CA 捆绑包的路径&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;trust_bundle_url&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;下载初始 SPIRE 服务器信任包的 URL&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;trust_bundle_format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;初始信任包的格式，pem 或 spiffe&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;trust_domain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该代理所属的信任域（不得超过 255 个字符）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;workload_x509_svid_key_type&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;工作负载 X509 SVID 密钥类型&lt;/td&gt;
          &lt;td&gt;ec-p256&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;实验性的&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;named_pipe_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于绑定 SPIRE Agent API 命名管道的管道名称（仅限 Windows）&lt;/td&gt;
          &lt;td&gt;\spire-agent\public\api&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;sync_interval&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;与指数退避的 SPIRE 服务器同步间隔&lt;/td&gt;
          &lt;td&gt;5 秒&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;初始信任捆绑配置&#34;&gt;初始信任捆绑配置&lt;/h3&gt;
&lt;p&gt;代理需要初始信任捆绑才能安全连接到 SPIRE 服务器。有以下三种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用 &lt;code&gt;trust_bundle_path&lt;/code&gt; 选项，代理将从该路径的文件中读取初始信任包。你需要在启动 SPIRE 代理之前复制或共享该文件。&lt;/li&gt;
&lt;li&gt;如果使用 &lt;code&gt;trust_bundle_url&lt;/code&gt; 选项，代理将从指定的 URL 读取初始信任包。为了安全起见，URL 必须以 &lt;code&gt;https://&lt;/code&gt; 开头，并且服务器必须具有有效的证书（通过系统信任存储区进行验证）。这可用于快速部署 SPIRE 代理，而无需手动共享文件。请记住，URL 的内容需要保持最新。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;insecure_bootstrap&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则代理将不会使用初始信任捆绑包。它将连接到 SPIRE 服务器而不进行身份验证。这不是一个安全配置，因为中间人攻击者可以控制 SPIRE 基础设施。包含它是因为它对于测试和开发来说是一个有用的选项。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一次只能设置这三个选项之一。&lt;/p&gt;
&lt;h3 id=&#34;sds-配置&#34;&gt;SDS 配置&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;default_svid_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于 Envoy SDS 的默认 X509-SVID 的 TLS 证书资源名称&lt;/td&gt;
          &lt;td&gt;default&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;default_bundle_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于 Envoy SDS 的默认 X.509 捆绑包的验证上下文资源名称&lt;/td&gt;
          &lt;td&gt;ROOTCA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;default_all_bundles_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于 Envoy SDS 的所有捆绑包（包括联合捆绑包）的验证上下文资源名称&lt;/td&gt;
          &lt;td&gt;ALL&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;disable_spiffe_cert_validation&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;禁用 Envoy SDS 自定义验证&lt;/td&gt;
          &lt;td&gt;false&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析名称&#34;&gt;分析名称&lt;/h3&gt;
&lt;p&gt;这些是可以在 &lt;code&gt;profiling_freq&lt;/code&gt; 配置值中设置的可用配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadcreate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插件配置&#34;&gt;插件配置&lt;/h2&gt;
&lt;p&gt;代理配置文件还包含代理插件的配置。插件配置位于 &lt;code&gt;plugins { ... }&lt;/code&gt; 部分，其格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;pluginType&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;pluginName&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;configuration&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;here&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下配置选项可用于配置插件：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;plugin_cmd&lt;/td&gt;
          &lt;td&gt;插件实现二进制文件的路径（可选，内置插件不需要）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;plugin_checksum&lt;/td&gt;
          &lt;td&gt;插件二进制文件的可选 sha256（可选，内置不需要）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;enabled&lt;/td&gt;
          &lt;td&gt;启用或禁用插件（默认启用）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;plugin_data&lt;/td&gt;
          &lt;td&gt;插件特定数据&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请参阅内置插件部分，了解有关开箱即用的插件的信息。&lt;/p&gt;
&lt;h2 id=&#34;遥测配置&#34;&gt;遥测配置&lt;/h2&gt;
&lt;p&gt;请参阅遥测配置指南，了解有关配置 SPIRE Agent 以发出遥测数据的更多信息。&lt;/p&gt;
&lt;h2 id=&#34;健康检查配置&#34;&gt;健康检查配置&lt;/h2&gt;
&lt;p&gt;代理可以公开可用于健康检查的其他端点。它可以通过设置 &lt;code&gt;listener_enabled = true&lt;/code&gt; 来启用。目前它公开了 2 条路径：一条用于活动（代理启动），一条用于准备（代理准备好服务请求）。默认情况下，健康检查端点将侦听 localhost:80，除非另有配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;health_checks&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        listener_enabled&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        bind_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        bind_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8080&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        live_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/live&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        ready_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/ready&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;命令行选项&#34;&gt;命令行选项&lt;/h2&gt;
&lt;h3 id=&#34;spire-agent-run&#34;&gt;&lt;code&gt;spire-agent run&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上述所有配置文件选项都有相同的命令行对应项。此外，还可以使用以下标志：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-allowUnauthenticatedVerifiers&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;允许代理向未经身份验证的验证者发布信任包&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-config&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 配置文件的路径&lt;/td&gt;
          &lt;td&gt;conf/代理/agent.conf&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-dataDir&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;代理可用于其运行时数据的目录&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-expandEnv&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;展开配置文件中的环境 $VARIABLES&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-joinToken&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;由 SPIRE 服务器生成的可选令牌&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logFile&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将日志写入的文件&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logFormat&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;日志格式，&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logLevel&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;调试、信息、警告或错误&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-serverAddress&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的 IP 地址或 DNS 名称&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-serverPort&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的端口号&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;绑定工作负载 API 套接字的位置&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustBundle&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 CA 捆绑包的路径&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustBundleUrl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;下载 SPIRE 服务器 CA 捆绑包的 URL&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该代理所属的信任域（不得超过 255 个字符）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;将-spire-agent-作为-windows-服务运行&#34;&gt;将 SPIRE Agent 作为 Windows 服务运行&lt;/h4&gt;
&lt;p&gt;在 Windows 平台上，SPIRE Agent 可以选择作为 Windows 服务运行。作为 Windows 服务运行时，唯一支持的命令是 &lt;code&gt;run&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：SPIRE 不会自动在系统中创建该服务，必须由用户创建。启动服务时，使用 &lt;code&gt;run&lt;/code&gt; 命令执行 SPIRE Agent 的所有参数都必须作为服务参数传递。&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;创建-spire-agent-windows-服务的示例&#34;&gt;创建 SPIRE Agent Windows 服务的示例&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; sc.exe create spire-agent &lt;span class=&#34;nv&#34;&gt;binpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c:&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire&lt;span class=&#34;se&#34;&gt;\b&lt;/span&gt;in&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire-agent.exe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;运行-spire-agent-windows-服务的示例&#34;&gt;运行 SPIRE Agent Windows 服务的示例&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; sc.exe start spire-agent run -config c:&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire&lt;span class=&#34;se&#34;&gt;\c&lt;/span&gt;onf&lt;span class=&#34;se&#34;&gt;\a&lt;/span&gt;gent&lt;span class=&#34;se&#34;&gt;\a&lt;/span&gt;gent.conf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;spire-agent-api-fetch&#34;&gt;&lt;code&gt;spire-agent api fetch&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用工作负载 API 以获取 X509-SVID。该命令的别名为 &lt;code&gt;spire-agent api fetch x509&lt;/code&gt; 。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-silent&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;抑制标准输出&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-timeout&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;等待回复的时间&lt;/td&gt;
          &lt;td&gt;1s&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-write&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将 SVID 数据写入指定路径&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-api-fetch-jwt&#34;&gt;&lt;code&gt;spire-agent api fetch jwt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用工作负载 API 以获取 JWT-SVID。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-audience&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;以逗号分隔的受众群体值列表&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;正在请求的 JWT 的 SPIFFE ID（可选）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-timeout&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;等待回复的时间&lt;/td&gt;
          &lt;td&gt;1s&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-api-fetch-x509&#34;&gt;&lt;code&gt;spire-agent api fetch x509&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用工作负载 API 以获取 x.509-SVID。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-silent&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;抑制标准输出&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-timeout&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;等待回复的时间&lt;/td&gt;
          &lt;td&gt;1s&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-write&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将 SVID 数据写入指定路径&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-api-validate-jwt&#34;&gt;&lt;code&gt;spire-agent api validate jwt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用工作负载 API 以验证提供的 JWT-SVID。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-audience&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;以逗号分隔的受众群体值列表&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-svid&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;待验证的 JWT-SVID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-timeout&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;等待回复的时间&lt;/td&gt;
          &lt;td&gt;1s&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-api-watch&#34;&gt;&lt;code&gt;spire-agent api watch&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;连接到工作负载 API 并监视 X509-SVID 更新，并在收到更新时打印详细信息。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-healthcheck&#34;&gt;&lt;code&gt;spire-agent healthcheck&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;检查 SPIRE 代理的健康状况。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-shallow&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;执行不太严格的健康检查&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Agent API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-agent/public/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-verbose&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;打印详细信息&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-agent-validate&#34;&gt;&lt;code&gt;spire-agent validate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;验证 SPIRE 代理配置文件。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-config&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 代理配置文件的路径&lt;/td&gt;
          &lt;td&gt;代理配置文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-expandEnv&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;展开配置文件中的环境 $VARIABLES&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;配置文件示例&#34;&gt;配置文件示例&lt;/h2&gt;
&lt;p&gt;本节包括用于格式化和语法参考的示例配置文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;agent&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    trust_bundle_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/conf/initial_bundle.crt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    data_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/.data&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    log_level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;DEBUG&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    server_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spire-server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    server_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8081&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    socket_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/tmp/spire-agent/public/api.sock&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;telemetry&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;Prometheus&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1234&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;NodeAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;join_token&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;KeyManager&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;disk&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            directory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/.data&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;WorkloadAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;k8s&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            kubelet_read_only_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10255&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;WorkloadAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;委托身份-api&#34;&gt;委托身份 API&lt;/h2&gt;
&lt;p&gt;委派身份 API 允许授权（即委派）工作负载代表无法由 SPIRE Agent 直接证明的工作负载获取 SVID 和捆绑包。授权工作负载通过向 SPIRE Agent 提供通常在工作负载证明期间获取的选择器来实现此目的。委派身份 API 通过管理 API 端点提供服务。&lt;/p&gt;
&lt;p&gt;要启用委派身份 API，请配置管理 API 端点地址和授权委派的 SPIFFE ID 列表。例如：&lt;/p&gt;
&lt;p&gt;Unix 系统：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;agent&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    admin_socket_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/tmp/spire-agent/private/admin.sock&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    authorized_delegates&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/authorized_client1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/authorized_client2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Windows：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;agent&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;experimental&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        admin_named_pipe_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;\\spire-agent\\private\\admin&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    authorized_delegates&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/authorized_client1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/authorized_client2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;envoy-sds-支持&#34;&gt;Envoy SDS 支持&lt;/h2&gt;
&lt;p&gt;SPIRE 代理支持 Envoy Secret Discovery Service (SDS)。SDS 通过与工作负载 API 相同的 Unix 域套接字提供服务。连接到 SDS 的 Envoy 进程被证明为工作负载。&lt;/p&gt;
&lt;p&gt;可以使用工作负载的 SPIFFE ID 作为资源名称（例如 &lt;code&gt;spiffe://example.org/database&lt;/code&gt; ）来获取包含 X509-SVID 的 &lt;code&gt;tlsv3.TlsCertificate&lt;/code&gt; 资源。或者，如果使用默认名称“default”，则会获取包含工作负载（即 Envoy）的默认 X509-SVID 的 &lt;code&gt;tlsv3.TlsCertificate&lt;/code&gt; 。默认名称是可配置的（请参阅 SDS 配置下的 &lt;code&gt;default_svid_name&lt;/code&gt; ）。&lt;/p&gt;
&lt;p&gt;可以使用所需信任域的 SPIFFE ID 作为资源名称（例如 &lt;code&gt;spiffe://example.org&lt;/code&gt; ）来获取包含受信任 CA 证书的 &lt;code&gt;tlsv3.CertificateValidationContext&lt;/code&gt; 资源。此外，还有另外两个特殊资源名称可用。第一个默认为“ROOTCA”，为代理所属的信任域提供 CA 证书。第二个默认为“ALL”，返回代理所属信任域以及适用于 Envoy 工作负载的任何联合信任域的可信 CA 证书。这些资源名称的默认名称可分别通过 &lt;code&gt;default_bundle_name&lt;/code&gt; 和 &lt;code&gt;default_all_bundles_name&lt;/code&gt; 进行配置。 “ALL”资源名称需要支持 SPIFFE 证书验证器扩展，该扩展仅从 Envoy 1.18 开始可用。默认名称是可配置的（请参阅 SDS 配置下的 &lt;code&gt;default_all_bundles_name&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;SPIFFE 证书验证器将 Envoy 配置为执行 SPIFFE 身份验证。SPIRE Agent 返回的验证上下文默认包含此扩展。然而，如果需要标准 X.509 链验证，SPIRE Agent 可以配置为省略扩展。可以通过在 SDS 配置中配置 &lt;code&gt;disable_spiffe_cert_validation&lt;/code&gt; 来更改默认行为。各个 Envoy 实例还可以通过在 Envoy 节点元数据中配置设置 &lt;code&gt;disable_spiffe_cert_validation&lt;/code&gt; 键来覆盖默认行为。&lt;/p&gt;
&lt;h2 id=&#34;openshift-支持&#34;&gt;OpenShift 支持&lt;/h2&gt;
&lt;p&gt;OpenShift 的默认安全配置文件禁止访问主机级资源。可以应用一组自定义策略来启用 Spire 在 OpenShift 中运行所需的访问级别。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：需要具有 &lt;code&gt;cluster-admin&lt;/code&gt; 权限的用户才能应用这些策略。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;安全上下文约束&#34;&gt;安全上下文约束&lt;/h3&gt;
&lt;p&gt;Pod 执行的操作由安全上下文约束 (SCC) 控制，并且根据条件范围为每个被接纳的 Pod 分配一个特定的 SCC。以下名为 &lt;code&gt;spire&lt;/code&gt; 的自定义 SCC 可用于启用 Spire Agent 所需的必要主机级访问&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;allowHostDirVolumePlugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowHostIPC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowHostNetwork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowHostPID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowHostPorts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowPrivilegeEscalation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowPrivilegedContainer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allowedCapabilities&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;security.openshift.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;defaultAddCapabilities&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fsGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MustRunAs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;groups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SecurityContextConstraints&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;include.release.openshift.io/self-managed-high-availability&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubernetes.io/description&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Customized policy for Spire to enable host level access.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;release.openshift.io/create-only&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;priority&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnlyRootFilesystem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requiredDropCapabilities&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;KILL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;MKNOD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SETUID&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;SETGID&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runAsUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seLinuxContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MustRunAs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;supplementalGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RunAsAny&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;hostPath&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;downwardAPI&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;emptyDir&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;persistentVolumeClaim&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;projected&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;secret&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;将安全约束与工作负载关联&#34;&gt;将安全约束与工作负载关联&lt;/h3&gt;
&lt;p&gt;通过将 SCC 与 pod 引用的服务帐户相关联，可以通过基于角色的访问控制策略授予工作负载对安全上下文约束的访问权限。&lt;/p&gt;
&lt;p&gt;为了利用 &lt;code&gt;spire&lt;/code&gt; SCC，必须创建一个利用引用 SCC 的 &lt;code&gt;use&lt;/code&gt; 动词的 ClusterRole：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;include.release.openshift.io/self-managed-high-availability&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rbac.authorization.kubernetes.io/autoupdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;system:openshift:scc:spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;security.openshift.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceNames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;securitycontextconstraints&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;verbs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，通过在 &lt;code&gt;spire&lt;/code&gt; 命名空间中创建 RoleBinding，将 &lt;code&gt;system:openshift:scc:spire&lt;/code&gt; ClusterRole 关联到 &lt;code&gt;spire-agent&lt;/code&gt; 服务帐户&lt;/p&gt;
&lt;p&gt;注意：如果在应用以下策略之前存在 &lt;code&gt;spire&lt;/code&gt; 命名空间，则创建该命名空间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RoleBinding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;system:openshift:scc:spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;roleRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;system:openshift:scc:spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire-agent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;spire&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 SCC 在 Pod 准入时应用，因此请删除任何现有的 Spire Agent Pod。所有新接纳的 pod 将利用 &lt;code&gt;spire&lt;/code&gt; SCC，以便在 OpenShift 中使用。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>安装</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/installation/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/installation/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/installation/getting-spire/&#34;&gt;获取 SPIRE&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/installation/install-server/&#34;&gt;安装 SPIRE 服务器&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/installation/install-agent/&#34;&gt;安装 SPIRE 代理&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>使用 Envoy 和 X.509-SVID 进行 OPA 授权</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-opa/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-opa/</guid>
      <description>
        
        
        &lt;p&gt;通过 Envoy 与 X.509-SVIDs 实现安全通信并结合 Open Policy Agent（OPA）进行授权。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.openpolicyagent.org/&#34; title=&#34;Open Policy Agent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Policy Agent&lt;/a&gt;（OPA）是一个开源通用策略引擎，其提供的授权（AuthZ）是对 SPIRE 提供的认证（AuthN）的很好补充。&lt;/p&gt;
&lt;p&gt;本教程将在 SPIRE Envoy-X.509 教程 的基础上添加 &lt;a href=&#34;https://www.openpolicyagent.org/&#34; title=&#34;Open Policy Agent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Policy Agent&lt;/a&gt;（OPA）以演示如何将 SPIRE、Envoy 和 OPA 结合使用，实现 X.509 SVID 认证和请求授权。本教程将演示如何在现有教程的基础上实现使用 OPA 进行请求授权。&lt;/p&gt;
&lt;p&gt;为了便于说明，让我们通过将 OPA 代理实例作为后端服务的新侧车来扩展 Envoy X.509 教程中创建的场景。借助 Envoy 的外部授权过滤器功能，结合 OPA 作为授权服务，可以实现对传入后端服务的每个请求执行安全策略。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-opa/SPIRE_Envoy_OPA_X509_diagram_hu10804353332469438225.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-opa/SPIRE_Envoy_OPA_X509_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-opa/SPIRE_Envoy_OPA_X509_diagram.png&#34; data-width=&#34;2550&#34; data-height=&#34;863&#34; alt=&#34;image&#34; data-caption=&#34;SPIRE Envoy OPA 集成图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;SPIRE Envoy OPA 集成图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;如图所示，前端服务通过 Envoy 实例连接到后端服务，Envoy 实例使用 SPIRE 代理提供的 SDS 模块进行身份验证，从而建立了 mTLS 连接。Envoy 通过 mTLS 连接将 HTTP 请求发送到后端，后端通过 OPA 代理实例根据安全策略对 HTTP 请求进行授权或拒绝。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 OPA 代理添加到现有的 Envoy X.509 教程的后端服务中&lt;/li&gt;
&lt;li&gt;将外部授权过滤器添加到将 Envoy 连接到 OPA 的 Envoy 配置中&lt;/li&gt;
&lt;li&gt;使用 SPIRE 与 Envoy 进行 OPA 授权的测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;先决条件&#34;&gt;先决条件&lt;/h1&gt;
&lt;p&gt;在继续之前，请查看以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当通过 SPIRE Envoy-X.509 教程 进行配置时，你将需要访问 Kubernetes 环境。可选择使用 &lt;code&gt;pre-set-env.sh&lt;/code&gt; 脚本创建 Kubernetes 环境。&lt;/li&gt;
&lt;li&gt;本教程所需的 YAML 文件可以在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;k8s/envoy-opa&lt;/code&gt; 目录中找到。如果尚未克隆 spire-tutorials 存储库，请立即执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 Kubernetes 中的 &lt;em&gt;配置 Envoy 进行 X.509 SVID 认证&lt;/em&gt; 教程环境不可用，你可以使用以下脚本创建该环境，并将其用作本教程的起点。从 &lt;code&gt;k8s/envoy-opa&lt;/code&gt; 目录运行以下 Bash 脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/pre-set-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该脚本将创建集群中所需的所有 SPIRE 服务器和 SPIRE 代理资源，然后将为 SPIRE Envoy X.509 教程创建所有资源，该教程是 SPIRE Envoy 和 OPA 教程的基本场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 本教程中所需的配置更改已显示为教程中的代码段。但是，所有这些设置已经配置好了。你无需编辑任何配置文件。&lt;/p&gt;
&lt;h2 id=&#34;外部-ip-支持&#34;&gt;外部 IP 支持&lt;/h2&gt;
&lt;p&gt;本教程需要一个能够分配外部 IP（例如 &lt;a href=&#34;https://metallb.universe.tf/&#34; title=&#34;metallb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metallb&lt;/a&gt;）的负载均衡器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待 metallb 启动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; --namespace metallb-system &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --for&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ready pod &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;metallb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --timeout&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;90s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 metallb 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f ../envoy-x509/metallb-config.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;第一部分部署更新和新资源&#34;&gt;第一部分：部署更新和新资源&lt;/h1&gt;
&lt;p&gt;假设以 SPIRE Envoy X.509 教程为起点，需要更新一些资源并创建其他资源。目标是在请求到达 &lt;code&gt;backend&lt;/code&gt; 服务之前，通过 OPA 让其进行授权。Envoy 实例之间已经建立了 mTLS 连接，因此唯一缺&lt;/p&gt;
&lt;p&gt;失的部分是将 OPA 作为 sidecar 添加到部署中。可以通过以下方式将新容器添加到 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-opa/k8s/backend/backend-deployment.yaml&#34; title=&#34;backend-deployment.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;backend-deployment.yaml&lt;/code&gt;&lt;/a&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;openpolicyagent/opa:0.50.2-envoy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IfNotPresent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa-envoy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa-api-port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8181&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;--server&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;--config-file=/run/opa/opa-config.yaml&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;/run/opa/opa-policy.rego&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/run/opa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意使用了 &lt;code&gt;openpolicyagent/opa:0.50.2-envoy&lt;/code&gt; 镜像。该镜像通过在 OPA 中扩展了一个实现 Envoy 外部授权 API 的 gRPC 服务器，以便 OPA 可以与 Envoy 通信以做出策略决策。&lt;/p&gt;
&lt;p&gt;必须在 &lt;code&gt;volumes&lt;/code&gt; 部分中添加 ConfigMap &lt;code&gt;backend-opa-policy&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ConfigMap &lt;code&gt;backend-opa-policy&lt;/code&gt; 提供了两个资源，分别是在 &lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-opa/readme/#opa-configuration&#34; title=&#34;OPA Configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA Configuration&lt;/a&gt; 中描述的 &lt;code&gt;opa-config.yaml&lt;/code&gt; 和在 &lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-opa/readme/#opa-policy&#34; title=&#34;Rego Policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rego Policy&lt;/a&gt; 部分中解释的 &lt;code&gt;opa-policy.rego&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;opa-配置&#34;&gt;OPA 配置&lt;/h2&gt;
&lt;p&gt;在本教程中，我们将在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-opa/k8s/backend/config/opa-config.yaml&#34; title=&#34;opa-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opa-config.yaml&lt;/code&gt;&lt;/a&gt; 中创建以下 OPA 配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;decision_logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;bash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_ext_authz_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;data.envoy.authz.allow&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，&lt;code&gt;decision_logs.bash: true&lt;/code&gt; 强制 OPA 在本地以 info 级别记录决策。稍后在教程中，我们将使用这些日志来检查不同请求的结果。&lt;/p&gt;
&lt;p&gt;接下来，让我们来查看 &lt;code&gt;envoy_ext_authz_grpc&lt;/code&gt; 插件的配置。首先，&lt;code&gt;addr&lt;/code&gt; 键设置了 Envoy 外部授权 gRPC 服务器的监听地址。这必须与 Envoy 过滤器资源中配置的值相匹配，后面的章节将详细介绍。&lt;code&gt;query&lt;/code&gt; 键定义了要查询的策略的名称。接下来的部分将重点介绍针对 &lt;code&gt;query&lt;/code&gt; 键指定的 &lt;code&gt;envoy.authz.allow&lt;/code&gt; 策略的详细信息。&lt;/p&gt;
&lt;h2 id=&#34;opa-策略&#34;&gt;OPA 策略&lt;/h2&gt;
&lt;p&gt;OPA 策略以一种称为 Rego 的高级声明性语言表达。在本教程中，我们创建了一个名为 &lt;code&gt;allow&lt;/code&gt; 的示例规则，其中包含三个表达式（参见 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-opa/k8s/backend/config/opa-policy.rego&#34; title=&#34;opa-policy.rego&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opa-policy.rego&lt;/code&gt;&lt;/a&gt;）。为了使规则成立，所有表达式都必须为 true。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;default allow = false

allow {
   valid_path
   http_request.method == &amp;#34;GET&amp;#34;
   svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们逐个查看每个表达式。&lt;code&gt;valid_path&lt;/code&gt; 是一个用户定义的函数，用于确保仅允许发送到允许资源的请求。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import input.attributes.request.http as http_request

valid_path {
   glob.match(&amp;#34;/balances/*&amp;#34;, [], http_request.path)
}

valid_path {
   glob.match(&amp;#34;/profiles/*&amp;#34;, [], http_request.path)
}

valid_path {
   glob.match(&amp;#34;/transactions/*&amp;#34;, [], http_request.path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数 &lt;code&gt;valid_path&lt;/code&gt; 利用了内置函数 &lt;code&gt;glob.match(&lt;/code&gt;&lt;em&gt;pattern&lt;/em&gt;, &lt;em&gt;delimiters&lt;/em&gt;, &lt;em&gt;match&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;，其输出为 true，如果 &lt;em&gt;match&lt;/em&gt; 可以在以 &lt;em&gt;delimiters&lt;/em&gt; 分隔的 &lt;em&gt;pattern&lt;/em&gt; 中找到，然后在 Rego 中为了表示逻辑或，你定义具有相同名称的多个规则。这就是为什么有三个定义 &lt;code&gt;valid_path&lt;/code&gt; 的规则，每个规则对应一个有效资源。&lt;/p&gt;
&lt;p&gt;接下来的表达式定义了请求的 HTTP 方法必须等于 &lt;code&gt;GET&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_request.method == &amp;#34;GET&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后一个表达式也是一个用户定义的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;svc_spiffe_id&lt;/code&gt; 函数从请求中的 &lt;code&gt;x-forwarded-client-cert&lt;/code&gt;（XFCC）头中提取服务的 SPIFFE ID。XFCC 头是一个代理头，指示请求已通过的某些或所有客户端或代理的证书信息。&lt;code&gt;svc_spiffe_id&lt;/code&gt; 函数利用了来自 &lt;code&gt;envoy.yaml&lt;/code&gt; 的两个 Envoy 设置，这些设置修改了 HTTP 头：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;forward_client_cert_details: sanitize_set
set_current_client_cert_details:
   uri: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当客户端连接为 mTLS 时，例如在此场景中，&lt;code&gt;forward_client_cert_details: sanitize_set&lt;/code&gt; 会将 XFCC 头重置为客户端证书信息，&lt;code&gt;set_current_client_cert_details&lt;/code&gt; 指定要转发的客户端证书中的字段。&lt;/p&gt;
&lt;p&gt;XFCC 头值是一个以逗号（“,”）分隔的字符串。每个子字符串都是一个 XFCC 元素，每个 XFCC 元素都是一个以分号（“;”）分隔的字符串。每个子字符串都是一个键值对，由等号（“=”）组合在一起。Envoy 支持以下键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;By&lt;/code&gt; 当前代理证书的主题可选名称（URI 类型）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hash&lt;/code&gt; 当前客户端证书的 SHA 256 摘要。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cert&lt;/code&gt; 整个客户端证书的 URL 编码 PEM 格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt; 当前客户端证书的 Subject 字段。值总是被双引号引起来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URI&lt;/code&gt; 当前客户端证书的 URI 类型主题可选名称字段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DNS&lt;/code&gt; 当前客户端证书的 DNS 类型主题可选名称字段。客户端证书可能包含多个 DNS 类型的主题可选名称，每个都将是一个单独的键值对。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是带有示例值的 XFCC 头，为了便于阅读，该值分为两行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x-forwarded-client-cert: By=spiffe://example.org/ns/default/sa/default/backend;Hash=a9317919875e178ce6d6
1eaa023490a2091299753ca5cd01d5323e40696d690b;URI=spiffe://example.org/ns/default/sa/default/frontend
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;x-forwarded-client-cert&lt;/code&gt; 头中，&lt;code&gt;Hash&lt;/code&gt; 总是设置的，当客户端证书呈现 URI 类型的主题可选名称值时，&lt;code&gt;By&lt;/code&gt; 也总是设置的，这在使用 X.509 SVIDs 时是真的。然后 &lt;code&gt;set_current_client_cert_details: uri: true&lt;/code&gt; 确保了 URI 类型的主题可选名称（SAN）字段被转发。&lt;/p&gt;
&lt;p&gt;了解了 XFCC 头的这些细节，并知道 X.509 SVID &lt;strong&gt;必须&lt;/strong&gt; 包含一个 URI SAN，SPIFFE ID 设置为 SAN 扩展中的 URI 类型，那么就可以使用以下函数从 Envoy 设置的 XFCC 头中提取 SPIFFE ID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id = spiffe_id {
   [_, _, uri_type_san] := split(http_request.headers[&amp;#34;x-forwarded-client-cert&amp;#34;], &amp;#34;;&amp;#34;)
   [_, spiffe_id] := split(uri_type_san, &amp;#34;=&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，只有当请求发送到有效的资源（/balances/，/profiles/ 或者 /transactions/）时，使用 &lt;code&gt;GET&lt;/code&gt; 方法，并且请求来自 SPIFFE ID 等于 &lt;code&gt;spiffe://example.org/ns/default/sa/default/frontend&lt;/code&gt; 的工作负载时，策略才会评估为真。在所有其他情况下，请求都不会被 OPA 授权，因此会被 Envoy 拒绝。&lt;/p&gt;
&lt;h2 id=&#34;添加外部授权过滤器&#34;&gt;添加外部授权过滤器&lt;/h2&gt;
&lt;p&gt;最后，此设置需要添加一个连接到 OPA 实例的外部授权过滤器。这个新的 HTTP 过滤器与 OPA 一起作为授权服务使用，以通过 Envoy 接收的 API 请求来执行安全策略。这是通过在 &lt;code&gt;envoy.yaml&lt;/code&gt; 中添加一个新的 HTTP 过滤器来实现的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.ext_authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transport_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;with_request_body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max_request_bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8192&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allow_partial_message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failure_mode_allow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;google_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;target_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stat_prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ext_authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，&lt;code&gt;target_uri&lt;/code&gt; 配置为与前一步中定义的 OPA 服务通信。如果你感兴趣，完整的配置文件位于 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-opa/k8s/backend/config/envoy.yaml&#34; title=&#34;k8s/backend/config/envoy.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s/backend/config/envoy.yaml&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;应用新资源&#34;&gt;应用新资源&lt;/h2&gt;
&lt;p&gt;为了使新配置生效，需要应用 OPA 配置的 ConfigMap，并更新 Envoy 配置。确保当前工作目录是 &lt;code&gt;.../spire-tutorials/k8s/envoy-opa&lt;/code&gt;，并使用以下命令应用新配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -k k8s/.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-envoy configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-opa-policy-config configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/backend configured
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，需要重启 &lt;code&gt;backend&lt;/code&gt; pod 以获取新配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;第-2-部分测试连接&#34;&gt;第 2 部分：测试连接&lt;/h1&gt;
&lt;p&gt;现在，服务已经部署并在 SPIRE 中注册了，让我们测试一下我们已经配置的授权。&lt;/p&gt;
&lt;h2 id=&#34;测试有效请求&#34;&gt;测试有效请求&lt;/h2&gt;
&lt;p&gt;第一个测试将演示满足策略的请求允许显示关联的数据。要运行此测试，我们需要找到构成用于访问数据的 URL 的 IP 地址和端口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get services
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME            TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backend-envoy   ClusterIP      None          &amp;lt;none&amp;gt;           9001/TCP         6m53s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend        LoadBalancer   10.8.14.117   35.222.164.221   3000:32586/TCP   6m52s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend-2      LoadBalancer   10.8.7.57     35.222.190.182   3002:32056/TCP   6m53s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes      ClusterIP      10.8.0.1      &amp;lt;none&amp;gt;           443/TCP          59m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;frontend&lt;/code&gt; 服务将在 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 值和端口 &lt;code&gt;3000&lt;/code&gt; 上可用，这是我们为容器配置的。在上面显示的示例输出中，要导航到的 URL 是 &lt;code&gt;http://35.222.164.221:3000&lt;/code&gt;。打开浏览器，导航到环境中显示的 &lt;code&gt;frontend&lt;/code&gt; 的 IP 地址，添加端口 &lt;code&gt;:3000&lt;/code&gt;。一旦页面加载，你将看到用户 &lt;em&gt;Jacob Marley&lt;/em&gt; 的账户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
  &lt;figcaption&gt;前端视图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;让我们看一下 OPA 代理的日志，看看后台正在发生什么。使用以下 Bash 脚本获取运行在 &lt;code&gt;backend&lt;/code&gt; 服务旁边的 OPA 实例的日志，并使用 &lt;code&gt;[jq](&amp;lt;https://stedolan.github.io/jq/&amp;gt;)&lt;/code&gt; 处理输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/backend-opa-logs.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出显示了每个请求的决定。例如，对 &lt;code&gt;frontend&lt;/code&gt; 服务的请求可能会产生类似于以下的日志条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;decision_id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;207b7b54-0ec0-4ffb-a531-c86a9f05c38d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;input&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;attributes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:authority&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;localhost:3003&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:method&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/profiles/2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;accept-encoding&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gzip&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;content-length&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;user-agent&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Go-http-client/1.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;x-forwarded-client-cert&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;By=spiffe://example.org/ns/default/sa/default/backend;Hash=a9317919875e178ce6d61eaa023490a2091299753ca5cd01d5323e40696d690b;URI=spiffe://example.org/ns/default/sa/default/frontend&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;x-forwarded-proto&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;x-request-id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;e0939bcf-8beb-4910-a980-be0468ec023f&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;method&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/profiles/2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HTTP/1.1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Decision Log&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;query&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;data.envoy.authz.allow&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;requested_by&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;result&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-06-11T18:58:47Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;timestamp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-06-11T18:58:47.840319148Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;openpolicyagent.org/decision_logs&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这种情况下，OPA &lt;code&gt;result&lt;/code&gt; 决定为真，意味着请求被允许通过过滤器并到达 &lt;code&gt;backend&lt;/code&gt; 服务，因为满足了 &lt;code&gt;opa-policy.rego&lt;/code&gt; Rego 策略中定义的所有以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;x-forwarded-client-cert&lt;/code&gt;（XFCC）头中提取的 SPIFFE ID URI 匹配预期的 SPIFFE ID：&lt;code&gt;spiffe://example.org/ns/default/sa/default/frontend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求的路径匹配：&lt;code&gt;/profiles/2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HTTP 方法匹配：&lt;code&gt;GET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试无效请求&#34;&gt;测试无效请求&lt;/h2&gt;
&lt;p&gt;另一方面，按照相同的步骤，我们可以确认不满足策略的请求阻止了相关数据的显示。在此情况下，&lt;code&gt;frontend-2&lt;/code&gt;服务无法与&lt;code&gt;backend&lt;/code&gt;服务通信，因为其 SPIFFE ID 不满足 OPA Agent 的策略。因此，当你连接到&lt;code&gt;frontend-2&lt;/code&gt;服务的 URL（例如&lt;code&gt;http://35.222.190.182:3002&lt;/code&gt;），浏览器只显示标题，没有任何帐户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
  &lt;figcaption&gt;浏览器视图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;尝试显示&lt;code&gt;frontend-2&lt;/code&gt;数据后，你可以使用与上一节相同的&lt;code&gt;scripts/backend-opa-logs.sh&lt;/code&gt;脚本来验证 OPA 做出的决定。由于 SPIFFE ID 不匹配，&lt;code&gt;frontend-2&lt;/code&gt;服务有类似的日志条目，但结果等于&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;使用新策略重新测试-frontend-2&#34;&gt;使用新策略重新测试 frontend-2&lt;/h2&gt;
&lt;p&gt;让我们更新 Rego 策略以匹配&lt;code&gt;frontend-2&lt;/code&gt;的 SPIFFE ID，然后再进行测试。我们可以利用一个 Bash 脚本来完成这个任务。执行后，它将打开由你的&lt;code&gt;KUBE_EDITOR&lt;/code&gt;或&lt;code&gt;EDITOR&lt;/code&gt;环境变量定义的编辑器，或者在 Linux 上回退到&lt;code&gt;vi&lt;/code&gt;，在 Windows 上回退到 Notepad。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/backend-update-policy.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;打开编辑器后，寻找指定 SPIFFE ID 的以下行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新该行以匹配&lt;code&gt;frontend-2&lt;/code&gt;工作负载的 SPIFFE ID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend-2&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存更改并退出。&lt;code&gt;backend-update-policy.sh&lt;/code&gt;脚本恢复。该脚本应用 ConfigMap 的新版本，然后重新启动&lt;code&gt;backend&lt;/code&gt;pod 以获取新的规则。等待几秒钟，等待部署传播，然后再尝试在浏览器中查看&lt;code&gt;frontend-2&lt;/code&gt;服务。一旦 pod 准备就绪，刷新浏览器，使用&lt;code&gt;frontend-2&lt;/code&gt;服务的正确 URL（例如&lt;code&gt;http://35.222.190.182:3002&lt;/code&gt;）。结果，现在页面显示了用户&lt;em&gt;Alex Fergus&lt;/em&gt;的帐户详细信息。&lt;/p&gt;
&lt;p&gt;另一方面，如果你现在连接到&lt;code&gt;frontend&lt;/code&gt;服务的 URL（例如&lt;code&gt;http://35.222.164.221:3000&lt;/code&gt;），浏览器只显示标题，没有任何帐户详细信息。这是预期的行为，因为策略已经更新，现在&lt;code&gt;frontend&lt;/code&gt;服务的 SPIFFE ID 不再满足策略。&lt;/p&gt;
&lt;h1 id=&#34;清理&#34;&gt;清理&lt;/h1&gt;
&lt;p&gt;当你完成时，你可以使用以下命令清理为教程创建的环境。它将删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为此 SPIRE - Envoy 与 OPA 集成教程创建的所有资源&lt;/li&gt;
&lt;li&gt;为 SPIRE - Envoy X.509 集成教程创建的所有资源&lt;/li&gt;
&lt;li&gt;SPIRE Agent，SPIRE Server 和命名空间的所有部署和配置&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/clean-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>身份背后的通用概念</title>
      <link>https://jimmysong.io/book/spiffe/general-concepts-behind-identity/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/general-concepts-behind-identity/</guid>
      <description>
        
        
        &lt;p&gt;本章解释了什么是身份，以及分配、管理和使用身份的基本知识。这些是你需要知道的概念，以便了解 SPIFFE 和 SPIRE 的工作方式。&lt;/p&gt;
&lt;h2 id=&#34;什么是身份&#34;&gt;什么是身份？&lt;/h2&gt;
&lt;p&gt;对于人类来说，身份是复杂的。人类是独特的个体，不能被克隆，也不能用代码取代他们的思想，而且一生中可能会有多种社会身份。软件服务也同样复杂。&lt;/p&gt;
&lt;p&gt;一个单一的程序可能会扩展到成千上万的节点，或者在构建系统推送新的更新时，一天内多次改变其代码。在这样一个快速变化的环境中，一个身份必须代表服务的特定逻辑目的（例如，客户计费数据库）和与已建立的权威或信任根（例如，&lt;code&gt;my-company.example.org&lt;/code&gt; 或生产工作负载的发行机构）的关联。&lt;/p&gt;
&lt;p&gt;一旦为一个组织中的所有服务发布了身份，它们就可以被用于&lt;strong&gt;认证&lt;/strong&gt;：证明一个服务是它所声称的那样。一旦服务经过相互认证，它们就可以使用身份进行&lt;strong&gt;授权&lt;/strong&gt;，或控制谁可以访问这些服务，以及&lt;strong&gt;保密性&lt;/strong&gt;，或保持它们相互传输的数据的秘密。虽然 SPIFFE 本身并不包括认证、授权或保密性，但它发出的身份可用于所有这些。&lt;/p&gt;
&lt;p&gt;为一个组织指定服务身份与设计该组织基础设施的任何其他部分类似：它密切依赖于该组织的需求。当一个服务扩大规模、改变代码或移动位置时，它保持相同的身份可能是合乎逻辑的。&lt;/p&gt;
&lt;h3 id=&#34;值得信赖的身份&#34;&gt;值得信赖的身份&lt;/h3&gt;
&lt;p&gt;现在我们已经定义了身份，那么我们如何表示这种身份？我们如何知道，当一个软件（或工作负载）声称自己的身份时，这个声称是值得信赖的？为了开始探索这些问题，我们必须首先讨论身份是如何建立的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人类的身份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请允许我们用大家共同的东西来解释这些概念：现实世界中的身份。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;身份证件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果一个名字是一个人的身份，那么这个身份的证明就是一个身份文件。护照是允许一个人证明其身份的文件，所以它是一个身份文件。像不同国家的护照一样，不同类型的软件身份文件可能看起来不同，而且不总是包含相同的信息。但为了有用，它们通常至少都包含一些共同的信息，如姓名。&lt;/p&gt;
&lt;p&gt;护照和写有你名字的餐巾纸之间的区别是什么？&lt;/p&gt;
&lt;p&gt;最重要的区别是来源。对于护照，我们相信&lt;strong&gt;签发机构&lt;/strong&gt;已经核实了你的身份，而且我们有能力核实护照是由该受信任的机构签发的（验证）。对于那张餐巾纸，我们不知道它来自哪里，也没有办法验证它是否来自你说的那家餐馆。我们也无法相信餐厅在餐巾纸上写了正确的名字，或者在你传达你的名字时验证了它的准确性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;信任一个发行机构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们相信护照，因为我们隐含地相信签发护照的机构。我们信任他们签发这些身份文件的过程：他们有记录和控制，以确保他们只向正确的个人签发身份。我们信任这个过程的管理，所以我们知道该机构签发的护照是某人身份的忠实代表。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;核实身份文件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;鉴于此，我们如何区分真护照和假护照？这就是验证的意义所在。组织需要一种方法来确定身份文件是否是由我们信任的权威机构签发的。这通常是通过难以复制但容易验证的水印来实现的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对出示身份证件的人进行认证&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;护照记录了关于身份所代表的人的几项信息。首先，它们包括一个人的照片，可以用来验证出示者是护照上的同一个人。它们还可能包括此人的其他身体特征 —— 例如，他们的身高、体重和眼睛颜色。&lt;/p&gt;
&lt;p&gt;所有这些属性都可以用来&lt;strong&gt;验证&lt;/strong&gt;出示护照的人。&lt;/p&gt;
&lt;p&gt;简而言之，护照是我们的&lt;strong&gt;身份文件&lt;/strong&gt;，我们用它来确认彼此的身份，因为我们信任&lt;strong&gt;签发机构&lt;/strong&gt;，并且有办法&lt;strong&gt;验证&lt;/strong&gt;该文件来自该机构。最后，我们可以通过交叉参考护照的内容和持有护照的人，来&lt;strong&gt;验证&lt;/strong&gt;出示护照的人。&lt;/p&gt;
&lt;h3 id=&#34;数字世界中的身份加密身份&#34;&gt;数字世界中的身份：加密身份&lt;/h3&gt;
&lt;p&gt;绕回工作负载身份，上述概念如何映射到计算机系统？计算机使用的是&lt;strong&gt;数字身份文件&lt;/strong&gt;，而不是护照。X.509 证书、签名的 JSON 网络令牌（JWT）和 Kerberos 票据，都是数字身份文件的例子。数字身份文件可以使用加密技术进行验证。然后，计算机系统可以被验证，就像一个拥有护照的人一样。&lt;/p&gt;
&lt;p&gt;做到这一点的最有用和最普遍的技术之一是&lt;strong&gt;公钥基础设施（PKI）&lt;/strong&gt;。PKI 被定义为一套创建、管理、分发、使用、存储和撤销数字证书以及管理公钥加密所需的角色、策略、硬件、软件和程序。有了 PKI，数字身份文件可以在本地进行验证，即根据一组小的、静态的根信任包进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X.509 的简要概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当&lt;a href=&#34;https://www.itu.int/en/ITU-T/about/&#34; title=&#34;国际电信联盟电信标准化部门（ITU-T）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国际电信联盟电信标准化部门（ITU-T）&lt;/a&gt;于 1988 年首次发布 X.509 标准的 PKI 时，这在当时是非常雄心勃勃的，现在仍然被认为是如此。该标准最初设想为人类、服务器和其他设备提供证书，形成一个巨大的全球一体化安全通信系统。虽然 X.509 从未达到其最初的预期，但它是几乎所有安全通信协议的基础。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;X.509 是如何在单一机构中工作的&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bob 的计算机需要一个证书。他生成了一个随机的&lt;strong&gt;私钥&lt;/strong&gt;，还有一个&lt;strong&gt;证书签名请求&lt;/strong&gt;（CSR），其中包括他的计算机的基本信息，比如它的名字；我们称之为 &lt;code&gt;bobsbox&lt;/code&gt;。CSR 有点像护照申请。&lt;/li&gt;
&lt;li&gt;Bob 将他的 CSR 发送给一个&lt;strong&gt;证书颁发机构&lt;/strong&gt;（CA）。CA 验证 Bob 是否真的是 Bob。这种验证的具体方式可能有所不同 —— 它可能涉及一个人检查 Bob 的文件，或自动检查。&lt;/li&gt;
&lt;li&gt;然后，CA 通过对 CSR 中提出的信息进行编码来创建&lt;strong&gt;证书&lt;/strong&gt;，并添加数字签名，以断言 CA 已经验证了其中包含的信息是真实和正确的。它把证书送回给 Bob。&lt;/li&gt;
&lt;li&gt;当 Bob 想与 Alice 建立安全通信时，他的计算机可以出示他的证书，并以密码学方式证明它拥有 Bob 的私钥（而不需要实际与任何人分享该私钥的内容）。&lt;/li&gt;
&lt;li&gt;Alice 的计算机可以通过检查证书颁发机构是否签署了 Bob 的证书来检查 Bob 的证书是否真的是 Bob 的证书。她相信证书颁发机构在签署证书之前正确检查了 Bob 的身份。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-1_hu13478098108489278739.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-1.jpg&#34; data-img=&#34;/book/spiffe/general-concepts-behind-identity/f3-1.jpg&#34; data-width=&#34;1220&#34; data-height=&#34;614&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-2_hu17884504805637531244.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-2.jpg&#34; data-img=&#34;/book/spiffe/general-concepts-behind-identity/f3-2.jpg&#34; data-width=&#34;1106&#34; data-height=&#34;668&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-3_hu16998089643601076262.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/general-concepts-behind-identity/f3-3.jpg&#34; data-img=&#34;/book/spiffe/general-concepts-behind-identity/f3-3.jpg&#34; data-width=&#34;1226&#34; data-height=&#34;770&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;带有中间证书机构的 X.509&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在许多情况下，签署了某一特定证书的 CA &lt;strong&gt;并不&lt;/strong&gt;广为人知。相反，该 CA 有自己的密钥和证书，而该证书是由另一个 CA 签署的。通过签署该 CA 证书，上级 CA 证明了下级 CA 被授权签发数字身份。这种由高阶 CA 对低阶 CA 的授权被称为&lt;strong&gt;委托（delegation）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;委托可以重复发生，低阶 CA 进一步委托他们的权力，形成一个任意高的证书授权树。最高等级的 CA 被称为&lt;strong&gt;根 CA&lt;/strong&gt;，必须有一个知名的证书。链中的每一个其他 CA 都被称为 &lt;strong&gt;中间 CA&lt;/strong&gt;。这种方法的好处是，需要知名的密钥较少，允许列表的变化不那么频繁。&lt;/p&gt;
&lt;p&gt;这导致了 X.509 的一个关键弱点：&lt;strong&gt;任何 CA 可以签署任何证书，没有任何限制&lt;/strong&gt;。如果一个黑客决定建立自己的中间 CA，并能得到任何一个现有中间 CA 的批准，那么他就可以有效地签发他想要的任何身份。至关重要的是，每个知名的 CA 都是&lt;strong&gt;完全&lt;/strong&gt;值得信赖的，而且他们委托的每个中间 CA 也是&lt;strong&gt;完全&lt;/strong&gt;值得信赖的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证书和身份的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 PKI 中有几个额外的功能，使数字身份的管理和认证更容易和更安全。权限委托、身份撤销和有限的身份文件寿命是其中的几个例子。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;身份发放&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先，必须能够发布一个新的身份。人类的诞生，新软件服务的编写，在每一种情况下，我们都必须在以前没有身份的地方颁发一个身份。&lt;/p&gt;
&lt;p&gt;首先，一项服务需要申请一个新的身份。对于人来说，这可能是一个纸质表格。对于软件来说，它是一个 X.509 文件，称为&lt;strong&gt;证书签名请求（CSR）&lt;/strong&gt;，它是用一个相应的私钥创建的。CSR 类似于证书，但由于它没有被任何证书颁发机构签署，没有人会承认它是有效的。然后，该服务将 CSR 安全地发送给证书颁发机构。&lt;/p&gt;
&lt;p&gt;接下来，证书颁发机构根据申请证书的服务检查 CSR 的每个细节。最初，这本来是一个手工过程：人类检查文书工作，并在个人基础上作出决定。今天，检查和签署过程通常是完全自动化的。如果你使用过流行的 LetsEncrypt 证书颁发机构，那么你就会熟悉完全自动化的证书颁发机构签署过程。&lt;/p&gt;
&lt;p&gt;一旦满意，证书颁发机构将其数字签名附加到 CSR 上，将其变成一个完全成熟的证书。它把证书返回给服务。与它先前生成的私钥一起，该服务可以让他人安全地识别自己。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;证书撤销&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么，如果一项服务被破坏了，会发生什么？如果 Bob 的笔记本电脑被黑了，或者 Bob 离开了公司，不应该再有访问权，怎么办？&lt;/p&gt;
&lt;p&gt;这种取消信任的过程被称为&lt;strong&gt;证书撤销（Certificate Revocation）&lt;/strong&gt;。证书颁发机构维护一个名为 **&amp;ldquo;证书撤销列表&amp;rdquo;（CRL）**的文件，其中包含被撤销的证书的唯一 ID，并将该文件的签名副本分发给任何要求的人。&lt;/p&gt;
&lt;p&gt;撤销是很棘手的，有几个原因。首先，CRL 必须由某个端点托管和提供，这就给确保端点的正常运行和可达带来了挑战。当该端点不可用时，PKI 是否停止工作？在实践中，大多数软件将&lt;strong&gt;无法打开&lt;/strong&gt;，在 CRL 不可用时继续信任证书，使它们实际上没有用处。&lt;/p&gt;
&lt;p&gt;第二，CRL 可能会变得庞大而不方便。被撤销的证书必须保留在 CRL 中，直到它过期为止，而证书的寿命一般都很长（在几年的时间内）。这可能导致服务、下载和处理清单本身的性能问题。&lt;/p&gt;
&lt;p&gt;已经开发了几种不同的技术，试图使证书撤销更简单、更可靠，如在线证书状态协议（OCSP）。各种各样的方法使证书撤销成为一个持续的挑战。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;证书过期&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每个证书都有一个内置的过期日期。过期日期是 X.509 安全的一个重要部分，有几个不同的原因：管理过时，限制证书显示的身份变化的可能性，限制 CRL 的大小，以及减少秘钥被盗的可能性。&lt;/p&gt;
&lt;p&gt;证书已经存在了很长时间了。当它们刚被开发出来时，许多 CA 使用 1989 年的 MD2 散列算法，这种算法很快被发现是不安全的。如果这些证书仍然有效，攻击者可以伪造它们。&lt;/p&gt;
&lt;p&gt;有限的证书寿命的另一个重要方面是，CA 只有一次机会来验证申请者的身份，但这些信息不能保证长期保持正确。例如，域名经常改变所有权，是证书中一般包括的比较关键的信息之一。&lt;/p&gt;
&lt;p&gt;如果使用了证书撤销列表，那么每个仍然有效的证书都有可能被撤销。如果证书永远持续下去，那么证书撤销列表就会无止境地增长。为了保持证书撤销列表的小规模，证书需要过期。&lt;/p&gt;
&lt;p&gt;最后，证书的有效期越长，其证书的私钥或任何通往根的证书被盗的风险就越大。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;频繁的证书更新&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决撤销所带来的挑战的一个折中办法是更多地依靠证书过期。如果证书的有效期很短（也许只有几个小时），那么 CA 就可以经常重新执行它最初做的所有检查。如果证书的更新足够频繁，那么 CRL 可能甚至没有必要，因为等待证书过期可能会更快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;身份寿命的权衡&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;更短的寿命&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;更长的寿命&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果文件被盗，它的有效期会缩短&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;减少了证书颁发机构的负担（人和程序）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;CRL 比较短，也许没有必要&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;降低网络的负荷&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;一次性减少未结清的身份文件（更容易跟踪）&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;在一个节点因网络中断而无法更新其证书时，具有更好的弹性&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;另一种加密身份：JSON 网络令牌（JWT）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;另一个公钥身份文件，JSON 网络令牌（RFC7519），也表现为一个类似 PKI 的系统。它不使用证书，而是使用 JSON 令牌，并有一个称为 JSON Web Key Set 的结构，作为 CA 绑定来验证 JSON 令牌。证书和 JWT 之间有一些重要的区别，超出了本书的范围，但就像 X.509 证书一样，JWT 的真实性可以通过 PKI 来验证。&lt;/p&gt;
&lt;h3 id=&#34;外部身份的可信度&#34;&gt;外部身份的可信度&lt;/h3&gt;
&lt;p&gt;无论你使用哪种身份，都必须由一些受信任的机构来签发。在许多情况下，并不是每个人都信任相同的当局或其颁发的过程。Alice 的纽约州驾照在纽约是有效的身份证明，但它在伦敦是无效的，因为伦敦当局不信任纽约州的政府。然而，Bob 的美国护照在伦敦是有效的，因为英国当局信任美国政府，而伦敦当局信任英国当局。&lt;/p&gt;
&lt;p&gt;在数字身份文件领域，情况是相同的。Alice 和 Bob 可能拥有由完全不相关的 CA 签署的证书，但只要他们都信任这些 CA，他们就可以相互认证。这并不意味着 Alice 必须信任 Bob，只是她可以安全地识别他。&lt;/p&gt;
&lt;h2 id=&#34;如何使用软件身份&#34;&gt;如何使用软件身份&lt;/h2&gt;
&lt;p&gt;一旦一个软件有了数字身份文件，它就可以被用于许多不同的目的。我们已经讨论了使用身份文件进行认证。它们还可以用于相互 TLS、授权、可观测性和计量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份文件最常见的用途是作为认证的基础。对于软件身份，存在几种不同的认证协议，使用 X.509 证书或 JWT 来证明一个服务对另一个服务的身份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保密性和完整性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保密性意味着攻击者不能看到信息的内容，而完整性意味着他们不能在传输过程中改变信息。传输层安全（TLS）是一个广泛使用的协议，用于建立安全连接，在使用 X.509 证书的不受信任的网络连接之上提供认证、保密性和消息完整性。&lt;/p&gt;
&lt;p&gt;TLS 的一个特点是，连接的&lt;strong&gt;任何一方都&lt;/strong&gt;可以使用证书进行认证。例如，当你连接到你的银行网站时，你的网络浏览器使用银行提供的 X.509 证书来验证你的银行，但你的浏览器并没有向银行提供证书。(你用用户名和密码登录，而不是用证书）。&lt;/p&gt;
&lt;p&gt;当两个软件进行通信时，连接的&lt;strong&gt;双方&lt;/strong&gt;通常都有 X.509 证书并相互认证。这被称为相互认证的 TLS。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦数字身份得到认证，它就可以被用来授权访问服务。通常情况下，每个服务都有一个允许其他服务对其提出请求的列表。授权只有在认证之后才能发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可观测性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份识别对于提高你的组织的基础设施内的可观测性也很有用。在大型组织中，旧的或未维护的服务以神秘的、未记录的方式进行通信是非常普遍的。每个服务的独特身份可以与可观测性工具一起解决这个问题。对于日志记录来说，如果以后出了问题，请求者的可反驳身份是很有用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，一个常见的需求是对请求进行节流，以便快速的微服务不至于压倒慢的微服务。如果每个微服务都有一个独特的身份，就可以用来管理每秒的请求配额来解决这个问题，或者完全拒绝访问。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;人类和软件都有身份，而且都可以使用身份文件来证明自己的身份。对人类来说，护照是身份文件的一种典型形式。对于软件来说，最常见的数字身份文件形式是 X.509 证书。&lt;/p&gt;
&lt;p&gt;证书是由证书颁发机构颁发的。证书颁发机构需要注意正确验证他们为之创建证书的人或事，并管理证书的寿命。证书颁发后，无论谁使用它，都需要信任颁发它的证书机构。&lt;/p&gt;
&lt;p&gt;一旦有了可信的数字身份文件，它们有许多不同的用途。其中最常见的是创建一个相互认证的 TLS 连接，其中包括认证、保密性和完整性。另一个常见的用途是用于授权。有了认证、保密性、完整性和授权，服务之间的连接是安全的。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>实施 DevSecOps 原语的参考平台</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/reference-platform/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/reference-platform/</guid>
      <description>
        
        
        &lt;p&gt;如第 1.1 节所述，参考平台是一个容器编排和管理平台。在现代应用环境中，平台是物理（裸机）或虚拟化（如虚拟机、容器）基础设施上的一个抽象层。在实施 DevSecOps 原语之前，平台只是包含了应用代码，其中包含了应用逻辑和服务网状代码，而服务网状代码又提供应用服务。本节将考虑以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个容器编排和资源管理平台，容纳了应用程序代码和大部分的服务网格代码&lt;/li&gt;
&lt;li&gt;服务网格的软件架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21-容器编排和资源管理平台&#34;&gt;2.1 容器编排和资源管理平台&lt;/h2&gt;
&lt;p&gt;由于微服务通常是以容器的形式实现的，因此容器编排和资源管理平台被用于服务的部署、运维和维护。&lt;/p&gt;
&lt;p&gt;一个典型的协调和资源管理平台由各种逻辑（形成抽象层）和物理工件组成，用于部署容器。例如，在 Kubernetes 中，容器在最小的部署单元内运行，称为 Pod。一个 Pod 理论上可以承载一组容器，但通常情况下，一个 Pod 内只运行一个容器。一组 Pod 被定义在所谓的节点内，节点可以是物理机或虚拟机（VM）。一组节点构成了一个集群。通常情况下，需要单个微服务的多个实例来分配工作负载，以达到预期的性能水平。集群是一个资源池（节点），用于分配微服务的工作负载。使用的技术之一是横向扩展，即访问频率较高的微服务被分配更多的实例或分配到具有更多资源（如 CPU 和 / 或内存）的节点。&lt;/p&gt;
&lt;h2 id=&#34;22-服务网格架构&#34;&gt;2.2 服务网格架构&lt;/h2&gt;
&lt;p&gt;在看了基于微服务的应用所需的各种应用服务后，考虑一下提供这些服务的服务网格的架构。服务网格由两个主要部分组成：控制平面和数据平面。&lt;/p&gt;
&lt;h3 id=&#34;221-控制平面&#34;&gt;2.2.1 控制平面&lt;/h3&gt;
&lt;p&gt;控制平面有几个组件。虽然服务网格的数据面主要由作为容器运行在与应用容器相同的 Pod 中的代理组成，但控制面组件在它们自己的 Pod、节点和相关集群中运行。以下是控制平面的 &lt;a href=&#34;https://medium.com/avmconsulting-blog/managing-microservices-with-istio-service-mesh-in-kubernetes-36e1fda81757&#34; title=&#34;各种功能&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;各种功能&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Envoy sidecar 代理的服务发现和配置&lt;/li&gt;
&lt;li&gt;自动化的密钥和证书管理&lt;/li&gt;
&lt;li&gt;用于策略定义和收集遥测数据的 API&lt;/li&gt;
&lt;li&gt;服务网格组件的配置摄取&lt;/li&gt;
&lt;li&gt;管理一个到服务网格的入站连接（入站网关）&lt;/li&gt;
&lt;li&gt;管理来自服务网格的出站连接（出口网关）&lt;/li&gt;
&lt;li&gt;将 sidecar 代理注入那些托管应用程序微服务容器的 Pod、节点或命名空间中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，控制平面帮助管理员用配置数据填充数据平面组件，这些数据是由控制平面的策略产生的。上述功能 3 的策略可能包括网络路由策略、负载均衡策略、蓝绿部署的策略、金丝雀部署、超时、重试和断路能力。这后三项被统称为网络基础设施服务的弹性能力的特殊名称。最后要说的是与安全相关的策略（例如，认证和授权策略、TLS 建立策略等）。这些策略规则由一个模块解析，该模块将其转换为配置参数，供执行这些策略的数据平面代理中的可执行程序使用。&lt;/p&gt;
&lt;h3 id=&#34;222-数据平面&#34;&gt;2.2.2 数据平面&lt;/h3&gt;
&lt;p&gt;数据平面组件执行三种不同的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安全的网络功能&lt;/li&gt;
&lt;li&gt;策略执行功能&lt;/li&gt;
&lt;li&gt;可观测性功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行上述三种功能的数据平面的主要组件被称为 sidecar 代理。这个七层代理运行在与它执行代理功能的微服务相同的网络命名空间（在这个平台上，就是同一个 Pod）。每个微服务都有一个代理，以确保来自微服务的请求不会绕过其相关的代理，每个代理都作为容器运行在与应用微服务相同的 Pod 中。两个容器都有相同的 IP 地址，并共享相同的 IP 表规则。这使得代理完全控制了 Pod，并 &lt;a href=&#34;https://medium.com/avmconsulting-blog/managing-microservices-with-istio-service-mesh-in-kubernetes-36e1fda81757&#34; title=&#34;处理所有通过它的流量&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;处理所有通过它的流量&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第一类功能（安全网络）包括与微服务之间的实际路由或消息通信有关的所有功能。属于这一类的功能是服务发现、建立安全（TLS）会话、为每个微服务及其相关请求建立网络路径和路由规则、验证每个请求（来自服务或用户）以及授权请求。&lt;/p&gt;
&lt;p&gt;以建立双向 TLS 会话为例，发起通信会话的代理将与服务网格的控制平面中的模块进行交互，以检查是否需要通过链加密流量并与后端或目标 Pod 建立双向 TLS。使用双向 TLS 启用这个功能需要每个 Pod 有一个证书（即有效的凭证）。由于一个规模较大的微服务应用程序（由许多微服务组成）可能需要数百个 Pod（即使没有通过多个实例对单个微服务进行横向扩展），这可能涉及到管理数百个生命周期短暂的证书。这反过来又要求每个微服务有一个强大的身份，服务网格要有一个访问管理器、一个证书存储和一个证书验证能力。此外，为了支持认证策略，还需要识别和认证两个通信的 Pod 的机制。&lt;/p&gt;
&lt;p&gt;其他类型的代理包括拦截客户端调用到应用程序的第一个入口点（第一个被调用的微服务）的 &lt;a href=&#34;https://medium.com/swlh/kong-api-gateway-zero-to-production-5b8431495ee&#34; title=&#34;入口代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入口代理&lt;/a&gt; 和处理微服务对驻扎在平台集群外的应用模块的请求的出口代理。&lt;/p&gt;
&lt;p&gt;数据平面执行的第二类功能是通过代理中的配置参数执行控制平面中定义的策略（策略执行服务）。一个例子是使用作为微服务请求一部分的 JWT 令牌中的信息来验证调用服务。另一个例子是使用驻留在代理本身的代码或通过连接到外部授权服务，为每个请求执行访问控制策略。&lt;/p&gt;
&lt;p&gt;服务代理与应用服务容器联合执行的第三类功能是收集遥测数据，这有助于监测服务的健康和状态，将与服务相关的日志传输到控制平面中的日志聚合模块，并将必要的数据附加到应用请求头，以方便追踪与特定应用事务相关的所有请求。应用响应由代理机构以返回代码、响应描述或检索数据的形式传达给其相关的调用服务。&lt;/p&gt;
&lt;p&gt;服务网格是容器编排平台感知的，与 API 服务器互动，该服务器为安装在各种平台工件（如 Pod、节点、命名空间）中的应用服务提供一个窗口，监测它是否有新的微服务，并自动将 sidecar 容器注入包含这些新微服务的 Pod。一旦服务网格插入 sidecar 代理容器，运维和安全团队就可以对流量执行策略，并帮助保护和运维应用程序。这些团队还可以配置对微服务应用的监控，而不干扰应用的运作。&lt;/p&gt;
&lt;p&gt;基础设施、策略执行和可观测性服务的配置可以使用作为 DevSecOps 管道一部分的声明性代码来自动化。虽然开发团队应该全面了解其代码部署的安全和管理细节，但上述服务的自动化为他们提供了更多的时间来集中精力进行高效的开发范式，如代码模块化和结构化。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>勘误</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/corrigendum/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/corrigendum/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;勘误 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PDF 原文第 4 页，kubelet 端口，默认应为 10250，而不是 10251。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 工作负载端点</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-endpoint/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-workload-endpoint/</guid>
      <description>
        
        
        &lt;p&gt;对于网络工作负载而言，可移植且互操作的加密身份可能是 SPIFFE 的核心用例之一。为了完全满足这一要求，社区必须达成一致，以标准化检索身份和在运行时使用身份相关服务的方式。&lt;/p&gt;
&lt;p&gt;SPIFFE 工作负载终端点规范通过定义一个终端点来提供 SPIFFE 可验证身份文档（SVIDs）和相关服务。具体而言，它概述了如何定位终端点以及如何服务或使用它。这个终端点所暴露的服务集合超出了本文档的范围，但有一个例外，即 SPIFFE 工作负载 API。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点是一个 API 终端点，工作负载或正在运行的计算进程可以通过它在运行时访问与身份相关的服务（如身份签发或身份验证）。这个终端点可以暴露任意数量的与身份相关的服务，但至少，符合规范的环境中运行的工作负载可以期望 SPIFFE 工作负载 API 可用。&lt;/p&gt;
&lt;p&gt;本文档详细介绍了 SPIFFE 工作负载终端点的可访问性和范围、传输协议、身份验证过程以及可扩展性/发现机制。&lt;/p&gt;
&lt;h2 id=&#34;可访问性&#34;&gt;可访问性&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点通常用作初始身份引导的机制，包括传递和管理信任根的过程。由于在早期阶段，工作负载可能对自己的身份或应该信任的对象没有任何先验知识，因此很难确保对终端点的访问安全。因此，SPIFFE 工作负载终端点应通过本地终端点公开，并且实现者不应将同一终端点实例公开给多个主机。将终端点和相关流量限制在单个主机上可以减轻与初始身份验证和签发安全相关的引导问题。更多详细信息，请参见 传输 和 身份验证 部分。&lt;/p&gt;
&lt;h2 id=&#34;传输&#34;&gt;传输&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点必须通过 gRPC 进行提供，并且符合规范的客户端必须支持 gRPC。它可以作为 Unix 域套接字（Unix Domain Socket，UDS）或 TCP 监听套接字公开。实现者应优先选择 Unix 域套接字传输，但如果 Unix 域套接字不可行或不可能，也可以支持 TCP 传输。除非底层网络允许工作负载终端点服务器根据源 IP 地址（例如通过本地主机或链路本地网络）或其他强网络级断言（例如通过 SDN 策略）对工作负载进行强身份验证，否则不得使用 TCP 传输。&lt;/p&gt;
&lt;p&gt;为了防止 &lt;a href=&#34;https://www.owasp.org/index.php/Server_Side_Request_Forgery&#34; title=&#34;服务器端请求伪造&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务器端请求伪造&lt;/a&gt;（SSRF）攻击，每个客户端请求 SPIFFE 工作负载终端点时，都必须包含静态的 gRPC 元数据键 &lt;code&gt;workload.spiffe.io&lt;/code&gt;，其值为 &lt;code&gt;true&lt;/code&gt;（区分大小写）。未包含此元数据键/值的请求必须被 SPIFFE 工作负载终端点拒绝（有关详细信息，请参见 错误代码 部分）。这样可以防止攻击者利用 SSRF 漏洞访问 SPIFFE 工作负载终端点，除非该漏洞还使攻击者能够控制出站 gRPC 元数据。&lt;/p&gt;
&lt;h3 id=&#34;传输安全&#34;&gt;传输安全&lt;/h3&gt;
&lt;p&gt;尽管 gRPC 强烈推荐使用传输层安全（Transport Layer Security，TLS），但不得要求 SPIFFE 工作负载终端点。由于 SPIFFE 工作负载终端点通常传递和管理信任根，我们不能指望工作负载具有对活跃根的先进知识。因此，在早期阶段，工作负载可能无法验证所呈现身份的真实性，除非通过 Workload API 实现的特权位置。这是 SPIFFE 工作负载终端点实例不应公开给多个主机的另一个原因。有关更多信息，请参见 身份验证 部分。&lt;/p&gt;
&lt;h2 id=&#34;定位终端点&#34;&gt;定位终端点&lt;/h2&gt;
&lt;p&gt;客户端可以显式配置套接字位置，也可以使用名为 &lt;code&gt;SPIFFE_ENDPOINT_SOCKET&lt;/code&gt; 的众所周知的环境变量。如果没有显式配置，符合规范的客户端必须回退到环境变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SPIFFE_ENDPOINT_SOCKET&lt;/code&gt; 环境变量的值结构化为 &lt;a href=&#34;https://www.ietf.org/rfc/rfc3986.txt&#34; title=&#34;RFC 3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt; URI。方案（scheme）必须设置为 &lt;code&gt;unix&lt;/code&gt; 或 &lt;code&gt;tcp&lt;/code&gt;，分别表示终端点通过 Unix 域套接字或 TCP 监听套接字提供服务。&lt;/p&gt;
&lt;p&gt;如果方案设置为 &lt;code&gt;unix&lt;/code&gt;，则授权组件不得设置，路径组件必须设置为 SPIFFE 工作负载终端点 Unix 域套接字的绝对路径（例如 &lt;code&gt;unix:///path/to/endpoint.sock&lt;/code&gt;）。方案和路径组件是强制的，不得设置其他组件。&lt;/p&gt;
&lt;p&gt;如果方案设置为 &lt;code&gt;tcp&lt;/code&gt;，则授权的主机组件必须设置为 IP 地址，授权的端口组件必须设置为 SPIFFE 工作负载终端点 TCP 监听套接字的 TCP 端口号。方案、主机和端口组件是强制的，不得设置其他组件。例如，&lt;code&gt;tcp://127.0.0.1:8000&lt;/code&gt; 是有效的，而 &lt;code&gt;tcp://127.0.0.1:8000/foo&lt;/code&gt; 是无效的。&lt;/p&gt;
&lt;h2 id=&#34;身份验证&#34;&gt;身份验证&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点通常用作初始身份引导的机制。因此，预期工作负载没有任何可用于自身身份验证的“秘密”材料。为了适应这一非常重要的用例，SPIFFE 工作负载终端点不得要求直接对其客户端进行身份验证。&lt;/p&gt;
&lt;p&gt;实现者应该执行带外真实性检查，而不是直接的客户端身份验证。这可以包括内核检查或编排工具询问等技术。例如，可以通过检查内核套接字状态来了解调用 API 的进程是哪个。另一种方法是允许编排工具将 Unix 域套接字放入特定容器中，向 SPIFFE 工作负载终端点实现传递容器的属性/身份信息。然后可以将此信息用作身份验证机制。&lt;/p&gt;
&lt;p&gt;应注意，虽然如何实现这一点的方法是特定于实现的，但所选择的方法不得要求工作负载积极参与其中。&lt;/p&gt;
&lt;h2 id=&#34;错误代码&#34;&gt;错误代码&lt;/h2&gt;
&lt;p&gt;在与 SPIFFE Workload 端点交互时，客户端可能会遇到多种错误条件。例如，客户端请求可能省略了必需的安全头部（请参阅传输部分获取更多信息），或者 SPIFFE Workload 端点实现可能仍在初始化或无法使用。&lt;/p&gt;
&lt;p&gt;如果收到不包含必需安全头部的客户端请求，实现必须使用 gRPC 状态码 &amp;ldquo;InvalidArgument&amp;rdquo; 进行响应。如果客户端收到 &amp;ldquo;InvalidArgument&amp;rdquo; 状态码，不应重试，因为这表示客户端实现有误，不可恢复。&lt;/p&gt;
&lt;p&gt;如果 SPIFFE Workload 端点实现正在运行但不可用，例如仍在初始化或执行负载均衡，客户端将收到 gRPC 状态码 &amp;ldquo;Unavailable&amp;rdquo;。如果客户端收到这个状态码，或者无法到达 SPIFFE Workload 端点，可以使用指数退避重试。&lt;/p&gt;
&lt;p&gt;最后，如果给定调用者/客户端没有为 SPIFFE Workload 端点服务定义身份，服务应使用 gRPC 状态码 &amp;ldquo;PermissionDenied&amp;rdquo; 进行响应。如果客户端收到这个状态码，可以使用指数退避重试，因为在实现最终一致性的情况下可能会遇到此类响应。&lt;/p&gt;
&lt;p&gt;请参阅 附录 A 获取错误条件和代码的摘要。&lt;/p&gt;
&lt;h2 id=&#34;可扩展性和提供的服务&#34;&gt;可扩展性和提供的服务&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload 端点可以提供多种与身份相关的服务，例如身份发放或身份验证。通过使用 gRPC/Protobuf 服务原语来公开单个服务。为了扩展 SPIFFE Workload 端点，必须引入一个新的（唯一命名的）服务。&lt;/p&gt;
&lt;p&gt;由于本规范承诺提供强大的可移植性，作者认为允许扩展现有逻辑服务与 SPIFFE 的精神相悖。如果通过向现有逻辑服务添加端点来提供附加功能，那么在从一个符合 SPIFFE 的环境移动到另一个环境时，无法保证可移植性。因此，不能直接扩展现有的 gRPC 逻辑服务，如 SPIFFE Workload API。相反，可以通过添加 SPIFFE 规范集中未描述的独立逻辑服务来增强端点。&lt;/p&gt;
&lt;p&gt;虽然所有 SPIFFE Workload 端点实现都必须公开 SPIFFE Workload API，但有时很难知道给定环境中支持哪些附加服务。因此，端点实现者应该包含对 &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/server-reflection.md&#34; title=&#34;gRPC Server Reflection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Server Reflection&lt;/a&gt; 的支持。如果客户端遇到不支持 gRPC Server Reflection 的端点，应假设唯一可用的服务是 SPIFFE Workload API 中定义的那些。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-错误代码列表&#34;&gt;附录 A. 错误代码列表&lt;/h2&gt;
&lt;p&gt;本节列出了 SPIFFE Workload 端点实现可能返回的各种错误代码、返回条件以及如何处理它们。请参阅 错误代码 部分和 &lt;a href=&#34;https://godoc.org/google.golang.org/grpc/codes&#34; title=&#34;gRPC Code package 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Code package 文档&lt;/a&gt; 以获取有关这些代码的更多信息。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;代码&lt;/th&gt;
          &lt;th&gt;条件&lt;/th&gt;
          &lt;th&gt;客户端行为&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;InvalidArgument&lt;/td&gt;
          &lt;td&gt;客户端请求中未包含 gRPC 安全头部。请参阅 传输部分 获取更多信息。&lt;/td&gt;
          &lt;td&gt;报告错误，不要重试。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Unavailable&lt;/td&gt;
          &lt;td&gt;SPIFFE Workload 端点实现无法处理请求。&lt;/td&gt;
          &lt;td&gt;使用指数退避重试。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;PermissionDenied&lt;/td&gt;
          &lt;td&gt;客户端无权执行请求的操作。根据实现的情况，这可能表示工作负载在身份或信任域被配置之前就已启动。&lt;/td&gt;
          &lt;td&gt;使用指数退避重试。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIRE Server 配置参考</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/server/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/server/</guid>
      <description>
        
        
        &lt;p&gt;本文描述了 SPIRE Server 的命令行选项、server.conf 设置和内置插件。&lt;/p&gt;
&lt;p&gt;本文档是 SPIRE Server 的配置参考。它包括有关插件类型、内置插件、服务器配置文件、插件配置和 &lt;code&gt;spire-server&lt;/code&gt; 命令的命令行选项的信息。&lt;/p&gt;
&lt;h2 id=&#34;插件类型&#34;&gt;插件类型&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;DataStore&lt;/td&gt;
          &lt;td&gt;提供持久存储和 HA 功能。注意：不再支持数据存储的可插入性。只能使用内置的 SQL 插件。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;为服务器的签名操作实现签名和密钥存储逻辑。对于利用基于硬件的关键操作很有用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;为尝试断言其身份的节点实现验证逻辑。一般与同类型的代理插件搭配使用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;允许 SPIRE 服务器与现有 PKI 系统集成。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Notifier&lt;/td&gt;
          &lt;td&gt;由 SPIRE 服务器通知正在发生或已经发生的某些事件。对于正在发生的事件，通知者可以将结果告知 SPIRE 服务器。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;内置插件&#34;&gt;内置插件&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;DataStore&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_datastore_sql.md&#34; title=&#34;sql&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sql&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;用于 SPIRE 数据存储的 SQLite、PostgreSQL 和 MySQL 数据库的 SQL 数据库存储&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_keymanager_aws_kms.md&#34; title=&#34;aws_kms&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws_kms&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;管理 AWS KMS 中密钥的密钥管理器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_keymanager_disk.md&#34; title=&#34;disk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;disk&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;管理保存在磁盘上的密钥的密钥管理器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;KeyManager&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_keymanager_memory.md&#34; title=&#34;memory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;memory&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;管理内存中非持久密钥的密钥管理器&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_aws_iid.md&#34; title=&#34;aws_iid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws_iid&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 AWS 实例身份文档证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_azure_msi.md&#34; title=&#34;azure_msi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;azure_msi&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Azure MSI 令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_gcp_iit.md&#34; title=&#34;gcp_iit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gcp_iit&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 GCP 实例身份令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_jointoken.md&#34; title=&#34;join_token&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;join_token&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;节点证明器，用于验证使用服务器生成的加入令牌进行证明的代理&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_k8s_sat.md&#34; title=&#34;k8s_sat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s_sat&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Kubernetes 服务帐户令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_k8s_psat.md&#34; title=&#34;k8s_psat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s_psat&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 Kubernetes 投影服务帐户令牌证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_sshpop.md&#34; title=&#34;sshpop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sshpop&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用现有 ssh 证书证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_tpm_devid.md&#34; title=&#34;tpm_devid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tpm_devid&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;节点证明者，使用已配置 DevID 证书的 TPM 证明代理身份&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;NodeAttestor&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_nodeattestor_x509pop.md&#34; title=&#34;x509pop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x509pop&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用现有 X.509 证书证明代理身份的节点证明者&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Notifier&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_notifier_gcs_bundle.md&#34; title=&#34;gcs_bundle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gcs_bundle&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;将最新信任包内容推送到 Google Cloud Storage 中的对象的通知程序。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Notifier&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_notifier_k8sbundle.md&#34; title=&#34;k8sbundle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8sbundle&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;将最新信任包内容推送到 Kubernetes ConfigMap 的通知程序。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_disk.md&#34; title=&#34;disk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;disk&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用从磁盘加载的 CA 来签署 SPIRE 服务器中间证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_aws_pca.md&#34; title=&#34;aws_pca&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws_pca&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 AWS Certificate Manager 中的私有证书颁发机构来签署 SPIRE 服务器中间证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_awssecret.md&#34; title=&#34;awssecret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;awssecret&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用从 AWS SecretsManager 加载的 CA 来签署 SPIRE 服务器中间证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_gcp_cas.md&#34; title=&#34;gcp_cas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gcp_cas&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 GCP 证书颁发机构服务中的私有证书颁发机构来签署 SPIRE 服务器中间证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_vault.md&#34; title=&#34;vault&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vault&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用 HashiCorp Vault 中的 PKI 秘密引擎来签署 SPIRE 服务器中间证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_spire.md&#34; title=&#34;spire&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spire&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用同一信任域中的上游 SPIRE 服务器来获取 SPIRE 服务器的中间签名证书。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;UpstreamAuthority&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/spiffe/spire/blob/v1.8.2/doc/plugin_server_upstreamauthority_cert_manager.md&#34; title=&#34;cert-manager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cert-manager&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;使用引用的证书管理器颁发者来请求中间签名证书。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;服务器配置文件&#34;&gt;服务器配置文件&lt;/h2&gt;
&lt;p&gt;下表概述了 SPIRE 服务器的配置选项。这些可以在配置文件的顶级 &lt;code&gt;server { ... }&lt;/code&gt; 部分中设置。大多数选项都有一个相应的 CLI 标志，如果设置了该标志，则该标志优先于文件中定义的值。&lt;/p&gt;
&lt;p&gt;SPIRE 配置文件可以用 HCL 或 JSON 表示。请参阅示例配置文件部分以获取完整示例。&lt;/p&gt;
&lt;p&gt;如果 -expandEnv 标志传递给 SPIRE，则在解析之前扩展 &lt;code&gt;$VARIABLE&lt;/code&gt; 或 &lt;code&gt;${VARIABLE}&lt;/code&gt; 样式环境变量。这对于模板化配置文件（例如跨不同信任域）或插入数据库连接密码等机密可能很有用。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;admin_ids&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIFFE ID，当出现在呼叫者的 X509-SVID 中时，会授予该呼叫者管理员权限。管理 ID 必须驻留在服务器信任域或联合域中，并且不需要在服务器上有相应的管理注册条目。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;agent_ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于代理 SVID 的 TTL&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;default_x509_svid_ttl&lt;/code&gt; 的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;audit_log_enabled&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，则启用审核日志记录&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;bind_address&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的 IP 地址或 DNS 名称&lt;/td&gt;
          &lt;td&gt;0.0.0.0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;bind_port&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的 HTTP 端口号&lt;/td&gt;
          &lt;td&gt;8081&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;ca_key_type&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于服务器 CA 的密钥类型（X509 和 JWT），&lt;code&gt;&amp;lt;rsa-2048|rsa-4096|ec-p256|ec-p384&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;ec-p256（JWT 密钥类型可以被 &lt;code&gt;jwt_key_type&lt;/code&gt; 覆盖）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;ca_subject&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;CA 证书应使用的主题（见下文）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;ca_ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;默认 CA/签名密钥 TTL&lt;/td&gt;
          &lt;td&gt;24h&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;data_dir&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;服务器运行时可以使用的目录&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;default_x509_svid_ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;默认 X509-SVID TTL&lt;/td&gt;
          &lt;td&gt;1h&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;default_jwt_svid_ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;默认 JWT-SVID TTL&lt;/td&gt;
          &lt;td&gt;5m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;experimental&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;可能会更改或删除的实验选项（见下文）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;federation&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于联合的捆绑端点配置部分&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;jwt_key_type&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于服务器 CA (JWT) 的密钥类型，&lt;/td&gt;
          &lt;td&gt;如果未定义，则为 &lt;code&gt;ca_key_type&lt;/code&gt; 或 ec-p256 的值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;jwt_issuer&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;发行 JWT-SVID 时使用的发行者声明&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_file&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将日志写入的文件&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_level&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;设置日志记录级别&lt;/td&gt;
          &lt;td&gt;信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;日志格式，text 或 json&lt;/td&gt;
          &lt;td&gt;文本&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;log_source_location&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，日志将包含源文件、行号和方法名称字段（增加一点运行时成本）&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_enabled&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，则启用 net/http/pprof 端点&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_freq&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将分析数据转储到磁盘的频率。仅当 &lt;code&gt;profiling_enabled&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 且 &lt;code&gt;profiling_freq&lt;/code&gt; &amp;gt; 0 时启用。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_names&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将在每个分析标记上转储到磁盘的配置文件名称列表，请参阅分析名称&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;profiling_port&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;net/http/pprof 端点的端口号。仅当 &lt;code&gt;profiling_enabled&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时使用。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;ratelimit&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;速率限制配置，通常在服务器位于负载均衡器后面时使用（见下文）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;socket_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将 SPIRE 服务器 API 套接字绑定到的路径（仅限 Unix）&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;trust_domain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该服务器所属的信任域（不应超过 255 个字符）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;ca_subject&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;country&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Country&lt;/code&gt; 值数组&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;organization&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Organization&lt;/code&gt; 值数组&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;common_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;CommonName&lt;/code&gt; 值&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;实验性的&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;cache_reload_interval&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;两次重新加载内存条目缓存之间的时间量。增加此值将减轻超大型部署的高数据库负载，但也会减慢新条目或更新条目向代理的传播速度。&lt;/td&gt;
          &lt;td&gt;5s&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;auth_opa_policy_engine&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于授权决策的 auth opa_policy 引擎&lt;/td&gt;
          &lt;td&gt;默认 SPIRE 授权策略&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;named_pipe_name&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE Server API 命名管道的管道名称（仅限 Windows）&lt;/td&gt;
          &lt;td&gt;\spire-server\private\api&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;速率限制&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;attestation&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;是否对节点证明进行速率限制。如果为 true，则节点证明的速率限制为每个 IP 地址每秒一次尝试。&lt;/td&gt;
          &lt;td&gt;真的&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;signing&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;是否对 JWT 和 X509 签名进行速率限制。如果为 true，JWT 和 X509 签名的速率限制为每个 IP 地址每秒 500 个请求（单独）。&lt;/td&gt;
          &lt;td&gt;真的&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;auth_opa_policy_engine&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;local&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;授权策略的本地 OPA 配置。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;auth_opa_policy_engine.local&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;rego_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于检索 OPA rego 策略以进行授权的文件。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;policy_data_path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于检索数据绑定以进行策略评估的文件。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析名称&#34;&gt;分析名称&lt;/h3&gt;
&lt;p&gt;这些是可以在 &lt;code&gt;profiling_freq&lt;/code&gt; 配置值中设置的可用配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadcreate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插件配置&#34;&gt;插件配置&lt;/h2&gt;
&lt;p&gt;服务器配置文件还包含各种 SPIRE 服务器插件的配置部分。插件配置位于顶级 &lt;code&gt;plugins { ... }&lt;/code&gt; 部分，其格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;pluginType&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;pluginName&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;configuration&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;here&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下配置选项可用于配置插件：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;插件命令&lt;/td&gt;
          &lt;td&gt;插件实现二进制文件的路径（可选，内置插件不需要）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插件校验和&lt;/td&gt;
          &lt;td&gt;插件二进制文件的可选 sha256（可选，内置不需要）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;已启用&lt;/td&gt;
          &lt;td&gt;启用或禁用插件（默认启用）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插件数据&lt;/td&gt;
          &lt;td&gt;插件特定数据&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;请参阅下面的内置插件部分，了解有关开箱即用的插件的信息。&lt;/p&gt;
&lt;h2 id=&#34;联邦配置&#34;&gt;联邦配置&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器可以配置为与位于不同信任域中的其他 SPIRE 服务器联合。SPIRE 支持在 SPIRE 服务器配置文件中（静态关系）和通过信任域 API（动态关系）配置联合关系。本节介绍如何在配置文件中配置静态定义的关系。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：静态关系优先于动态关系。如果需要配置动态关系，请参见 &lt;code&gt;federation&lt;/code&gt; 命令。静态关系不会反映在 &lt;code&gt;federation&lt;/code&gt; 命令中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;配置联合信任域允许信任域对其他 SPIFFE 机构颁发的身份进行身份验证，从而允许一个信任域中的工作负载安全地对外部信任域中的工作负载进行身份验证。实现联合的一个关键要素是使用 SPIFFE 捆绑端点，这些资源（由 URL 表示）为信任域提供信任捆绑的副本。使用 &lt;code&gt;federation&lt;/code&gt; 部分，你将能够将 SPIRE 设置为 SPIFFE 捆绑包端点服务器，并配置此 SPIRE 服务器将从中获取捆绑包的联合信任域。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;federation&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;bundle_endpoint&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;8443&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            refresh_hint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10m&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_web&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;acme&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                    domain_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                    email&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;mail@example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;domain1.test&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://1.2.3.4:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_web&amp;#34;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;federates_with&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;domain2.test&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            bundle_endpoint_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://5.6.7.8:8443&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;bundle_endpoint_profile&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https_spiffe&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;                endpoint_spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://domain2.test/beserver&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;federation.bundle_endpoint&lt;/code&gt; 部分是可选的，用于在 SPIRE 服务器中设置 SPIFFE 捆绑端点服务器。 &lt;code&gt;federation.federates_with&lt;/code&gt; 部分也是可选的，用于配置与外部信任域的联合关系。此部分用于 SPIRE 服务器将定期获取捆绑包的每个联合信任域。&lt;/p&gt;
&lt;h3 id=&#34;federationbundle_endpoint-的配置选项&#34;&gt;&lt;code&gt;federation.bundle_endpoint&lt;/code&gt; 的配置选项&lt;/h3&gt;
&lt;p&gt;此可选部分包含 SPIRE 服务器用于公开捆绑端点的配置。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;address&lt;/td&gt;
          &lt;td&gt;该服务器将侦听 HTTP 请求的 IP 地址&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;port&lt;/td&gt;
          &lt;td&gt;该服务器将侦听 HTTP 请求的 TCP 端口号&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;refresh_hint&lt;/td&gt;
          &lt;td&gt;允许手动指定刷新提示。如果未设置，则根据捆绑包中密钥的生命周期确定。小值允许及时检索信任包更新&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;profile &amp;ldquo;&amp;lt;https_web|https_spiffe&amp;gt;&amp;rdquo;&lt;/td&gt;
          &lt;td&gt;允许配置捆绑配置文件&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;federationbundle_endpointprofile-的配置选项&#34;&gt;&lt;code&gt;federation.bundle_endpoint.profile&lt;/code&gt; 的配置选项&lt;/h3&gt;
&lt;p&gt;当设置 &lt;code&gt;bundle_endpoint&lt;/code&gt; 时，它是 &lt;code&gt;required&lt;/code&gt; 来指定捆绑配置文件。&lt;/p&gt;
&lt;p&gt;允许的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;https_web&lt;/code&gt; 允许配置自动证书管理环境部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https_spiffe&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;federationbundle_endpointprofile-https_webacme-的配置选项&#34;&gt;&lt;code&gt;federation.bundle_endpoint.profile &amp;quot;https_web&amp;quot;.acme&lt;/code&gt; 的配置选项&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;directory_url&lt;/td&gt;
          &lt;td&gt;目录端点 URL&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://acme-v02.api.letsencrypt.org/directory&#34; title=&#34;https://acme-v02.api.letsencrypt.org/directory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://acme-v02.api.letsencrypt.org/directory&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;domain_name&lt;/td&gt;
          &lt;td&gt;证书管理器尝试检索新证书的域&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;email&lt;/td&gt;
          &lt;td&gt;联系电子邮件地址。Let&amp;rsquo;s Encrypt 等 CA 使用它来通知已颁发证书的问题&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;tos_acceptted&lt;/td&gt;
          &lt;td&gt;接受 ACME 服务条款。如果没有设置为 true，并且提供商要求接受，则证书检索将失败&lt;/td&gt;
          &lt;td&gt;false&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;federationbundle_endpointprofile-https_spiffe-的配置选项&#34;&gt;&lt;code&gt;federation.bundle_endpoint.profile &amp;quot;https_spiffe&amp;quot;&lt;/code&gt; 的配置选项&lt;/h3&gt;
&lt;p&gt;默认捆绑配置文件配置。&lt;/p&gt;
&lt;h3 id=&#34;federationfederates_withtrust-domainbundle_endpoint-的配置选项&#34;&gt;&lt;code&gt;federation.federates_with[&amp;quot;&amp;lt;trust domain&amp;gt;&amp;quot;].bundle_endpoint&lt;/code&gt; 的配置选项&lt;/h3&gt;
&lt;p&gt;可选的 &lt;code&gt;federates_with&lt;/code&gt; 部分是捆绑端点配置文件配置的映射，以该服务器想要联合的 &lt;code&gt;&amp;quot;&amp;lt;trust domain&amp;gt;&amp;quot;&lt;/code&gt; 的名称为键。此部分具有以下可配置项：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;配置&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;bundle_endpoint_url&lt;/td&gt;
          &lt;td&gt;提供要联合的信任捆绑包的 SPIFFE 捆绑包端点的 URL。必须使用 HTTPS 协议。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;bundle_endpoint_profile &amp;ldquo;&amp;lt;https_web | https_spiffe&amp;gt;&amp;rdquo;&lt;/td&gt;
          &lt;td&gt;SPIFFE 端点配置文件类型的配置。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SPIRE 支持 &lt;code&gt;https_web&lt;/code&gt; 和 &lt;code&gt;https_spiffe&lt;/code&gt; 捆绑端点配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https_web&lt;/code&gt; 配置文件不需要额外的设置。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;https_spiffe&lt;/code&gt; 捆绑端点配置文件配置的信任域必须使用 &lt;code&gt;endpoint_spiffe_id&lt;/code&gt; 设置作为配置的一部分来指定远程 SPIFFE 捆绑端点服务器的预期 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;有关 SPIFFE 中定义的不同配置文件的更多信息，以及设置 SPIFFE 联合的安全注意事项，请参阅 &lt;a href=&#34;../../standard/spiffe-federation/&#34; title=&#34;SPIFFE 联邦标准&#34;&gt;SPIFFE 联邦标准&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;遥测配置&#34;&gt;遥测配置&lt;/h2&gt;
&lt;p&gt;请参阅遥测配置指南，了解有关配置 SPIRE 服务器以发出遥测数据的更多信息。&lt;/p&gt;
&lt;h2 id=&#34;健康检查配置&#34;&gt;健康检查配置&lt;/h2&gt;
&lt;p&gt;服务器可以公开可用于健康检查的附加端点。它可以通过设置 &lt;code&gt;listener_enabled = true&lt;/code&gt; 来启用。目前它公开了 2 条路径：一条用于活动（服务器是否已启动？），另一条用于准备（服务器是否准备好服务请求？）。默认情况下，健康检查端点将侦听 localhost:80，除非另有配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;health_checks&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        listener_enabled&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        bind_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        bind_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8080&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        live_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/live&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        ready_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/ready&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;命令行选项&#34;&gt;命令行选项&lt;/h2&gt;
&lt;h3 id=&#34;spire-server-run&#34;&gt;&lt;code&gt;spire-server run&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上面的大多数配置文件选项都有相同的命令行对应项。此外，还可以使用以下标志。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-bindAddress&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的 IP 地址或 DNS 名称&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-config&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 配置文件的路径&lt;/td&gt;
          &lt;td&gt;conf/服务器/服务器.conf&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-dataDir&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;存储运行时数据的目录&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-expandEnv&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;展开配置文件中的环境 $VARIABLES&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logFile&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将日志写入的文件&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logFormat&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;日志格式，&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-logLevel&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;调试、信息、警告或错误&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-serverPort&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器的端口号&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将 SPIRE 服务器 API 套接字绑定到的路径&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该服务器所属的信任域（不应超过 255 个字符）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;将-spire-server-作为-windows-服务运行&#34;&gt;将 SPIRE Server 作为 Windows 服务运行&lt;/h4&gt;
&lt;p&gt;在 Windows 平台上，SPIRE Server 可以选择作为 Windows 服务运行。作为 Windows 服务运行时，唯一支持的命令是 &lt;code&gt;run&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：SPIRE 不会自动在系统中创建该服务，必须由用户创建。启动服务时，使用 &lt;code&gt;run&lt;/code&gt; 命令执行 SPIRE Server 的所有参数都必须作为服务参数传递。&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;创建-spire-server-windows-服务的示例&#34;&gt;创建 SPIRE Server Windows 服务的示例&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; sc.exe create spire-server &lt;span class=&#34;nv&#34;&gt;binpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c:&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire&lt;span class=&#34;se&#34;&gt;\b&lt;/span&gt;in&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire-server.exe
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;运行-spire-server-windows-服务的示例&#34;&gt;运行 SPIRE Server Windows 服务的示例&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; sc.exe start spire-server run -config c:&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;pire&lt;span class=&#34;se&#34;&gt;\c&lt;/span&gt;onf&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;erver&lt;span class=&#34;se&#34;&gt;\s&lt;/span&gt;erver.conf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;spire-server-token-generate&#34;&gt;&lt;code&gt;spire-server token generate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;生成一个节点加入令牌并为其创建一个注册条目。该令牌可用于引导一个 spire-agent 安装。除了基于令牌的 ID 之外，可选的 &lt;code&gt;-spiffeID&lt;/code&gt; 可用于为令牌提供人类可读的注册条目名称。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于分配令牌所有者的附加 SPIFFE ID（可选）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;令牌 TTL（以秒为单位）&lt;/td&gt;
          &lt;td&gt;600&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-entry-create&#34;&gt;&lt;code&gt;spire-server entry create&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;创建注册条目。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-admin&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果设置，此条目中的 SPIFFE ID 将被授予对服务器 API 的访问权限&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-data&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含 JSON 格式的注册数据的文件的路径（可选，如果指定，则必须省略与条目信息相关的其他标志）。如果设置为“-”，则从 stdin 读取 JSON。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-dns&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;DNS 名称将包含在基于此条目发布的 SVID 中（如果适用）。可以多次使用&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-downstream&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;布尔值，设置后表示该条目描述下游 SPIRE 服务器&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryExpiry&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;从数据存储中删除生成的注册条目的到期时间（以秒为单位）。请注意，这是一项数据管理功能，而不是安全功能（可选）。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;新创建的注册条目的用户指定 ID（可选）。如果没有提供条目 ID，则会在创建时生成一个&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-federatesWith&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;代表与此注册条目联合的信任域的信任域 SPIFFE ID 列表。该信任域的捆绑包必须已存在&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-node&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果设置，此条目将应用于匹配节点而不是工作负载&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-parentID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该记录父记录的 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-selector&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于证明的冒号分隔的类型：值选择器。该参数可以多次使用，以指定必须满足的多个选择器。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该记录代表的 SPIFFE ID 并将被设置为颁发的 SVID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-x509SVIDTTL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;作为此记录的结果而发出的任何 X509-SVID 的 TTL（以秒为单位）。覆盖 &lt;code&gt;-ttl&lt;/code&gt; 值。&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;default_x509_svid_ttl&lt;/code&gt; 配置的 TTL&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-jwtSVIDTTL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;作为此记录的结果而发出的任何 JWT-SVID 的 TTL（以秒为单位）。覆盖 &lt;code&gt;-ttl&lt;/code&gt; 值。&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;default_jwt_svid_ttl&lt;/code&gt; 配置的 TTL&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-storeSVID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;一个布尔值，设置后表示必须通过 SVIDStore 插件存储从此条目生成的 SVID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-entry-update&#34;&gt;&lt;code&gt;spire-server entry update&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;更新注册条目。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-admin&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;如果为 true，则此条目中的 SPIFFE ID 将被授予对服务器 API 的访问权限&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-data&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含 JSON 格式的注册数据的文件的路径（可选，如果指定，则必须省略与条目信息相关的其他标志）。如果设置为“-”，则从 stdin 读取 JSON。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-dns&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;DNS 名称将包含在基于此条目发布的 SVID 中（如果适用）。可以多次使用&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-downstream&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;布尔值，设置后表示该条目描述下游 SPIRE 服务器&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryExpiry&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;到期时间（以秒为单位），用于修剪生成的注册条目&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要更新的记录的注册条目 ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-federatesWith&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;代表与此注册条目联合的信任域的信任域 SPIFFE ID 列表。该信任域的捆绑包必须已存在&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-parentID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该记录父记录的 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-selector&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;用于证明的冒号分隔的类型：值选择器。该参数可以多次使用，以指定必须满足的多个选择器。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;该记录代表的 SPIFFE ID 并将被设置为颁发的 SVID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-x509SVIDTTL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;作为此记录的结果而发出的任何 X509-SVID 的 TTL（以秒为单位）。覆盖 &lt;code&gt;-ttl&lt;/code&gt; 值。&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;default_x509_svid_ttl&lt;/code&gt; 配置的 TTL&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-jwtSVIDTTL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;作为此记录的结果而发出的任何 JWT-SVID 的 TTL（以秒为单位）。覆盖 &lt;code&gt;-ttl&lt;/code&gt; 值。&lt;/td&gt;
          &lt;td&gt;使用 &lt;code&gt;default_jwt_svid_ttl&lt;/code&gt; 配置的 TTL&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;storeSVID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;一个布尔值，设置后表示必须通过 SVIDStore 插件存储从此条目生成的 SVID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-entry-count&#34;&gt;&lt;code&gt;spire-server entry count&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示注册条目总数。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-entry-delete&#34;&gt;&lt;code&gt;spire-server entry delete&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;删除指定的注册条目。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要删除的记录的注册条目 ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-entry-show&#34;&gt;&lt;code&gt;spire-server entry show&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示配置的注册条目。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-downstream&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;布尔值，设置后表示该条目描述下游 SPIRE 服务器&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-entryID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的记录的条目 ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-federatesWith&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;与条目联合的信任域的 SPIFFE ID。可以多次使用&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-parentID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的记录的父 ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-selector&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;以冒号分隔的类型：值选择器。可以多次使用来指定多个选择器。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的记录的 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-bundle-count&#34;&gt;&lt;code&gt;spire-server bundle count&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示捆绑包的总数。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-bundle-show&#34;&gt;&lt;code&gt;spire-server bundle show&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示服务器信任域的捆绑包。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;显示捆绑包的格式。 &lt;code&gt;pem&lt;/code&gt; 或 &lt;code&gt;spiffe&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-bundle-list&#34;&gt;&lt;code&gt;spire-server bundle list&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示联合捆绑包。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的捆绑包的信任域 SPIFFE ID。如果未设置，则显示所有信任包&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;显示联合捆绑包的格式。 &lt;code&gt;pem&lt;/code&gt; 或 &lt;code&gt;spiffe&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-bundle-set&#34;&gt;&lt;code&gt;spire-server bundle set&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;创建或更新信任域的捆绑数据。此命令不能用于更改服务器信任域捆绑，只能用于其他信任域的捆绑。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要设置的捆绑包的信任域 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-path&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含捆绑数据的文件在磁盘上的路径。如果未设置，则从标准输入读取数据。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-format&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要设置的捆绑包的格式。 &lt;code&gt;pem&lt;/code&gt; 或 &lt;code&gt;spiffe&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-bundle-delete&#34;&gt;&lt;code&gt;spire-server bundle delete&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;删除信任域的捆绑数据。该命令不能用于删除服务器信任域捆绑，只能删除其他信任域的捆绑。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要删除的捆绑包的信任域 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-mode&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;以下之一： &lt;code&gt;restrict&lt;/code&gt; 、 &lt;code&gt;dissociate&lt;/code&gt; 、 &lt;code&gt;delete&lt;/code&gt; 。 &lt;code&gt;restrict&lt;/code&gt; 如果捆绑包与注册条目关联（即联合），则防止该捆绑包被删除。 &lt;code&gt;dissociate&lt;/code&gt; 允许删除捆绑包并从注册条目中删除关联。 &lt;code&gt;delete&lt;/code&gt; 删除捆绑包以及关联的注册条目。&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;restrict&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-create&#34;&gt;&lt;code&gt;spire-server federation create&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;创建与外部信任域的动态联合关系。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-bundleEndpointProfile&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;端点配置文件类型。 &lt;code&gt;https_web&lt;/code&gt; 或 &lt;code&gt;https_spiffe&lt;/code&gt; 。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-bundleEndpointURL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;提供信任捆绑包的 SPIFFE 捆绑包端点的 URL（必须使用 HTTPS 协议）。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-data&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含 JSON 格式的联合关系的文件的路径（可选，如果指定，则必须省略与联合关系信息相关的其他标志）。如果设置为“-”，则从 stdin 读取 JSON。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-endpointSpiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIFFE 捆绑端点服务器的 SPIFFE ID。仅用于 &lt;code&gt;https_spiffe&lt;/code&gt; 配置文件。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要联合的信任域的名称（例如 example.org）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomainBundleFormat&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;捆绑数据的格式（可选）。 &lt;code&gt;pem&lt;/code&gt; 或 &lt;code&gt;spiffe&lt;/code&gt; 。&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomainBundlePath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;信任域捆绑数据的路径（可选）。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-delete&#34;&gt;&lt;code&gt;spire-server federation delete&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;删除动态联合关系。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;关系的信任域的 SPIFFE ID。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-list&#34;&gt;&lt;code&gt;spire-server federation list&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;列出所有动态联合关系。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;关系信任域的 SPIFFE ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-refresh&#34;&gt;&lt;code&gt;spire-server federation refresh&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;从指定的联合信任域刷新捆绑包。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-id&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;关系信任域的 SPIFFE ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-show&#34;&gt;&lt;code&gt;spire-server federation show&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示动态的联邦关系。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的联合关系的信任域名（例如 example.org）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-federation-update&#34;&gt;&lt;code&gt;spire-server federation update&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;更新与外部信任域的动态联合关系。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-bundleEndpointProfile&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;端点配置文件类型。 &lt;code&gt;https_web&lt;/code&gt; 或 &lt;code&gt;https_spiffe&lt;/code&gt; 。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-bundleEndpointURL&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;提供信任捆绑包的 SPIFFE 捆绑包端点的 URL（必须使用 HTTPS 协议）。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-data&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含 JSON 格式的联合关系的文件的路径（可选，如果指定，则必须省略与联合关系信息相关的其他标志）。如果设置为“-”，则从 stdin 读取 JSON。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-endpointSpiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIFFE 捆绑端点服务器的 SPIFFE ID。仅用于 &lt;code&gt;https_spiffe&lt;/code&gt; 配置文件。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径。&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomain&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要联合的信任域的名称（例如 example.org）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomainBundleFormat&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;捆绑数据的格式（可选）。 &lt;code&gt;pem&lt;/code&gt; 或 &lt;code&gt;spiffe&lt;/code&gt; 。&lt;/td&gt;
          &lt;td&gt;pem&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-trustDomainBundlePath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;信任域捆绑数据的路径（可选）。&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-agent-ban&#34;&gt;&lt;code&gt;spire-server agent ban&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;根据 spiffeID 禁止已证明的节点。被禁止的证明节点无法重新证明。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要禁止的代理的 SPIFFE ID（代理身份）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-agent-count&#34;&gt;&lt;code&gt;spire-server agent count&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示已证明的节点总数。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-agent-evict&#34;&gt;&lt;code&gt;spire-server agent evict&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在给定 spiffeID 的情况下取消对已认证节点的认证。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要驱逐的代理的 SPIFFE ID（代理身份）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-agent-list&#34;&gt;&lt;code&gt;spire-server agent list&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示已证明的节点。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-agent-show&#34;&gt;&lt;code&gt;spire-server agent show&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;显示给定 spiffeID 的已证明节点的详细信息（包括节点选择器）。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要显示的代理的 SPIFFE ID（代理身份）&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-healthcheck&#34;&gt;&lt;code&gt;spire-server healthcheck&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;检查 SPIRE 服务器的健康状况。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-shallow&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;执行不太严格的健康检查&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-verbose&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;打印详细信息&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-validate&#34;&gt;&lt;code&gt;spire-server validate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;验证 SPIRE 服务器配置文件。参数与 &lt;code&gt;spire-server run&lt;/code&gt; 相同。通常，你可能至少需要：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-config&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器配置文件的路径&lt;/td&gt;
          &lt;td&gt;服务器配置文件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-expandEnv&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;展开配置文件中的环境 $VARIABLES&lt;/td&gt;
          &lt;td&gt;错误的&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-x509-mint&#34;&gt;&lt;code&gt;spire-server x509 mint&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;铸造 X509-SVID。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-dns&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将包含在 SVID 中的 DNS 名称。可以多次使用&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;X509-SVID 的 SPIFFE ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;X509-SVID 的 TTL&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Entry.x509_svid_ttl&lt;/code&gt; 、 &lt;code&gt;Entry.ttl&lt;/code&gt; 、 &lt;code&gt;default_x509_svid_ttl&lt;/code&gt; 、 &lt;code&gt;1h&lt;/code&gt; 中的第一个非零值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-write&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;将输出写入而不是 stdout 的目录&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spire-server-jwt-mint&#34;&gt;&lt;code&gt;spire-server jwt mint&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;铸造 JWT-SVID。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;命令&lt;/th&gt;
          &lt;th&gt;行动&lt;/th&gt;
          &lt;th&gt;默认&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-audience&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;观众声称将包含在 SVID 中。可以多次使用&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-socketPath&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;SPIRE 服务器 API 套接字的路径&lt;/td&gt;
          &lt;td&gt;/tmp/spire-server/private/api.sock&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-spiffeID&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;JWT-SVID 的 SPIFFE ID&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-ttl&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;JWT-SVID 的 TTL&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Entry.jwt_svid_ttl&lt;/code&gt; 、 &lt;code&gt;Entry.ttl&lt;/code&gt; 、 &lt;code&gt;default_jwt_svid_ttl&lt;/code&gt; 、 &lt;code&gt;5m&lt;/code&gt; 中的第一个非零值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-write&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;要写入令牌而不是标准输出的文件&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;-data-的-json-对象&#34;&gt;&lt;code&gt;-data&lt;/code&gt; 的 JSON 对象&lt;/h2&gt;
&lt;p&gt;传递给 &lt;code&gt;entry create/update&lt;/code&gt; 的 &lt;code&gt;-data&lt;/code&gt; 的 JSON 对象需要以下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;entries&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;入口对象在公共 protobuf 文件中由 &lt;code&gt;RegistrationEntry&lt;/code&gt; 描述。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：要创建节点条目，请将 &lt;code&gt;parent_id&lt;/code&gt; 设置为特殊值 &lt;code&gt;spiffe://&amp;lt;your-trust-domain&amp;gt;/spire/server&lt;/code&gt; 。这就是在 cli 上传递 &lt;code&gt;-node&lt;/code&gt; 标志时代码所做的事情。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置文件示例&#34;&gt;配置文件示例&lt;/h2&gt;
&lt;p&gt;本节包括用于格式化和语法参考的示例配置文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-hcl&#34; data-lang=&#34;hcl&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    trust_domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;example.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    bind_address&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    bind_port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8081&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    log_level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;INFO&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    data_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/.data/&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    default_x509_svid_ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;6h&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    default_jwt_svid_ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;5m&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;    ca_ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;72h&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;ca_subject&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        country&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;US&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        organization&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SPIRE&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        common_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;telemetry&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;Prometheus&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;        port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1234&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;DataStore&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sql&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            database_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            connection_string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/.data/datastore.sqlite3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;NodeAttestor&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;join_token&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;KeyManager&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;disk&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;plugin_data&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;            keys_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/opt/spire/.data/keys.json&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>配置</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/configuration/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/configuration/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/configuration/configuring/&#34;&gt;配置 SPIRE&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/configuration/registering/&#34;&gt;注册工作负载&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/configuration/svids/&#34;&gt;使用 SVID&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/configuration/agent/&#34;&gt;SPIRE Agent&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/configuration/server/&#34;&gt;SPIRE Server&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>使用 Envoy 和 JWT-SVIDs 进行 OPA 授权</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/</guid>
      <description>
        
        
        &lt;p&gt;本文指导你如何使用 Envoy 和 JWT-SVIDs 以及开放策略代理进行安全通信。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.openpolicyagent.org/&#34; title=&#34;开放策略代理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放策略代理&lt;/a&gt;（OPA）是一个开源的、通用的策略引擎。OPA 提供的授权（AuthZ）可以很好地补充 SPIRE 提供的认证（AuthN）。&lt;/p&gt;
&lt;p&gt;本教程基于 SPIRE Envoy-JWT 教程，演示如何结合 SPIRE、Envoy 和 OPA 进行 JWT SVID 认证和请求授权。实现 OPA 请求授权所需的更改在本教程中以增量形式展示，因此你应先运行或至少阅读 SPIRE Envoy-JWT 教程。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/SPIRE-Envoy_JWT_OPA_diagram_hu13384985837787862135.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/SPIRE-Envoy_JWT_OPA_diagram.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-jwt-opa/SPIRE-Envoy_JWT_OPA_diagram.png&#34; data-width=&#34;2518&#34; data-height=&#34;1125&#34; alt=&#34;image&#34; data-caption=&#34;架构图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;架构图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;为了说明如何使用 OPA 进行请求授权，我们在 SPIRE Envoy JWT 教程中使用的后端服务中添加了一个新的 sidecar。新的 sidecar 充当 Envoy 的新&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.25.1/intro/arch_overview/security/ext_authz_filter#arch-overview-ext-authz&#34; title=&#34;外部授权过滤器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;外部授权过滤器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如图所示，前端服务通过由 Envoy 实例建立的 mTLS 连接连接到后端服务。Envoy 通过 mTLS 连接发送 HTTP 请求，其中携带了用于认证的 JWT-SVID。JWT-SVID 由 SPIRE Agent 提供并验证，然后，请求会根据安全策略由 OPA Agent 实例授权或拒绝。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学习如何：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 OPA Agent 添加到 SPIRE Envoy JWT 教程中现有的后端服务&lt;/li&gt;
&lt;li&gt;在连接 Envoy 到 OPA 的 Envoy 配置中添加一个外部授权过滤器&lt;/li&gt;
&lt;li&gt;测试成功的使用 SPIRE 和 OPA 授权的 JWT 认证&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;h3 id=&#34;外部-ip-支持&#34;&gt;外部 IP 支持&lt;/h3&gt;
&lt;p&gt;本教程需要一个负载均衡器，该负载均衡器能够分配外部 IP（例如，&lt;a href=&#34;https://metallb.universe.tf/&#34; title=&#34;metallb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metallb&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等到 metallb 启动&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; --namespace metallb-system &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --for&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ready pod &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --selector&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;metallb &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                --timeout&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;90s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用 metallb 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f ../envoy-x509/metallb-config.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;授权助手镜像&#34;&gt;授权助手镜像&lt;/h3&gt;
&lt;p&gt;使用 Envoy-jwt-auth-helper 实现了一个外部授权过滤器，提供了一个脚本来简化使用&lt;code&gt;kind&lt;/code&gt;或&lt;code&gt;minikube&lt;/code&gt;的构建和导入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash ./scripts/build-helper.sh kind
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;之前的-spire-安装&#34;&gt;之前的 SPIRE 安装&lt;/h3&gt;
&lt;p&gt;在开始之前，回顾以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你需要访问在完成 SPIRE Envoy-JWT 教程时配置的 Kubernetes 环境。或者，你可以使用下面描述的&lt;code&gt;pre-set-env.sh&lt;/code&gt;脚本创建 Kubernetes 环境。&lt;/li&gt;
&lt;li&gt;此教程所需的 YAML 文件可以在  &lt;a href=&#34;https://github.com/spiffe/spire-tutorials&#34; title=&#34;https://github.com/spiffe/spire-tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/spiffe/spire-tutorials&lt;/a&gt; 的 &lt;code&gt;k8s/envoy-jwt-opa&lt;/code&gt; 目录中找到。如果你还没有克隆 spire-tutorials 存储库，请立即这样做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 Kubernetes &lt;em&gt;配置 Envoy 以执行 JWT SVID 身份验证&lt;/em&gt;教程环境不可用，你可以使用以下脚本创建它，并将它用作本教程的起点。从&lt;code&gt;k8s/envoy-jwt-opa&lt;/code&gt;目录中，运行以下 Bash 脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/pre-set-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该脚本将创建 SPIRE 服务器和 SPIRE 代理在集群中可用所需的所有资源，然后将为 SPIRE Envoy JWT 教程创建所有资源，这是此 SPIRE Envoy JWT 与 OPA 教程的基础场景。&lt;/p&gt;
&lt;p&gt;注意：本教程中显示的配置更改需要使 Envoy 和 OPA 与 SPIRE 一起工作。但是，所有这些设置已经配置好了。你不需要编辑任何配置文件。&lt;/p&gt;
&lt;h2 id=&#34;第一部分部署更新和新资源&#34;&gt;第一部分：部署更新和新资源&lt;/h2&gt;
&lt;p&gt;假定 SPIRE Envoy JWT 教程为起点，需要创建一些资源。目标是在请求到达&lt;code&gt;backend&lt;/code&gt;服务之前，由 OPA 代理对其进行授权。在 Envoy 实例之间建立了 mTLS 连接，其中 JWT SVID 在请求中作为&lt;code&gt;authorization&lt;/code&gt;头部传输。因此，缺少的部分是添加一个 OPA 代理以根据策略对请求进行授权。在本教程中应用的解决方案包括向运行在&lt;code&gt;backend&lt;/code&gt;服务前的 Envoy 实例添加新的外部授权过滤器。新的过滤器在请求通过 Envoy JWT Auth Helper（第一个过滤器）之后调用 OPA 代理，其作用是检查是否应授权或拒绝请求。&lt;/p&gt;
&lt;h3 id=&#34;更新部署&#34;&gt;更新部署&lt;/h3&gt;
&lt;p&gt;为了让 OPA 授权或拒绝发送到&lt;code&gt;backend&lt;/code&gt;服务的请求，我们需要将 OPA 添加为部署的 sidecar。我们使用&lt;code&gt;openpolicyagent/opa:0.50.2-envoy&lt;/code&gt;镜像，该镜像扩展了 OPA 并添加了一个实现 Envoy 外部授权 API 的 gRPC 服务器，因此 OPA 可以与 Envoy 通信策略决策。在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-jwt-opa/k8s/backend/backend-deployment.yaml&#34; title=&#34;backend-deployment.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;backend-deployment.yaml&lt;/code&gt;&lt;/a&gt;中，添加并配置新的容器，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;openpolicyagent/opa:0.50.2-envoy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IfNotPresent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa-envoy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opa-api-port&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8181&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;--server&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;--config-file=/run/opa/opa-config.yaml&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;/run/opa/opa-policy.rego&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/run/opa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要将&lt;code&gt;backend-opa-policy&lt;/code&gt; ConfigMap 添加到&lt;code&gt;volumes&lt;/code&gt;部分，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend-opa-policy-config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;backend-opa-policy&lt;/code&gt; ConfigMap 提供了两个资源，&lt;code&gt;opa-config.yaml&lt;/code&gt;在&lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-jwt-opa/readme/#opa-configuration&#34; title=&#34;OPA 配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA 配置&lt;/a&gt;中描述，而&lt;code&gt;opa-policy.rego&lt;/code&gt;策略在&lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-jwt-opa/readme/#opa-policy&#34; title=&#34;OPA 策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA 策略&lt;/a&gt;部分解释。&lt;/p&gt;
&lt;h3 id=&#34;opa-配置&#34;&gt;OPA 配置&lt;/h3&gt;
&lt;p&gt;对于本教程，我们在 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-jwt-opa/k8s/backend/config/opa-config.yaml&#34; title=&#34;opa-config.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opa-config.yaml&lt;/code&gt;&lt;/a&gt; 中创建了以下 OPA 配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;decision_logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_ext_authz_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;data.envoy.authz.allow&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;选项&lt;code&gt;decision_logs.console: true&lt;/code&gt;强制 OPA 将决策在控制台上以信息级别本地记录。稍后在教程中，我们将使用这些日志来检查不同请求的结果。&lt;/p&gt;
&lt;p&gt;接下来，让我们回顾一下&lt;code&gt;envoy_ext_authz_grpc&lt;/code&gt;插件的配置。&lt;code&gt;addr&lt;/code&gt;键设置实现 Envoy 外部授权 API 的 gRPC 服务器的监听地址。这必须与接下来的部分中详细描述的 Envoy 过滤器资源中配置的值匹配。&lt;code&gt;query&lt;/code&gt;键定义要查询的策略决策的名称。下一部分将关注为&lt;code&gt;query&lt;/code&gt;键指定的&lt;code&gt;envoy.authz.allow&lt;/code&gt;策略的细节。&lt;/p&gt;
&lt;h3 id=&#34;opa-策略&#34;&gt;OPA 策略&lt;/h3&gt;
&lt;p&gt;OPA 政策使用高级声明性语言 Rego 表达。对于本教程，我们创建了一个名为&lt;code&gt;allow&lt;/code&gt;的样本规则，该规则包含三个表达式（请参见 &lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-jwt-opa/k8s/backend/config/opa-policy.rego&#34; title=&#34;opa-policy.rego&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opa-policy.rego&lt;/code&gt;&lt;/a&gt;）。所有表达式必须为真，该规则才为真。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package envoy.authz

default allow = false

allow {
    valid_path
    http_request.method == &amp;#34;GET&amp;#34;
    svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们逐一查看每个表达式。&lt;code&gt;valid_path&lt;/code&gt;是一个用户定义的函数，用于确保只允许发送给允许的资源的请求。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import input.attributes.request.http as http_request

valid_path {
   glob.match(&amp;#34;/balances/*&amp;#34;, [], http_request.path)
}

valid_path {
   glob.match(&amp;#34;/profiles/*&amp;#34;, [], http_request.path)
}

valid_path {
   glob.match(&amp;#34;/transactions/*&amp;#34;, [], http_request.path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数&lt;code&gt;valid_path&lt;/code&gt;利用内置函数&lt;code&gt;glob.match(&lt;/code&gt; &lt;em&gt;pattern, delimiters, match&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;的输出，如果在由&lt;em&gt;delimiters&lt;/em&gt;分隔的&lt;em&gt;pattern&lt;/em&gt;中可以找到&lt;em&gt;match&lt;/em&gt;，则其输出为真。然后，要在 Rego 中表示逻辑 OR，你需要定义具有相同名称的多个规则。这就是为什么&lt;code&gt;valid_path&lt;/code&gt;有三个定义，每个有效资源一个。&lt;/p&gt;
&lt;p&gt;以下表达式定义了请求的 HTTP 方法必须等于&lt;code&gt;GET&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_request.method == &amp;#34;GET&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后一个表达式也对应于一个用户定义的函数，只有当 JWT-SVID 中编码的 SPIFFE ID 等于分配给&lt;code&gt;frontend&lt;/code&gt;服务的 SPIFFE ID 时，该函数才会为真。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数&lt;code&gt;svc_spiffe_id&lt;/code&gt;从请求中的&lt;code&gt;authorization&lt;/code&gt;头中提取服务的 SPIFFE ID。因为请求已经通过了第一个 Envoy 筛选器（以验证模式运行的 Envoy JWT Auth Helper），我们知道它有一个有效的 JWT，我们可以解码来提取调用服务的 SPIFFE ID。OPA 提供了一个处理 JWT 的特殊代码，我们可以利用它来解码 JWT 并提取 SPIFFE ID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id = payload.sub {
   [_, encoded_token] := split(http_request.headers.authorization, &amp;#34; &amp;#34;)
   [_, payload, _] := io.jwt.decode(encoded_token)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，只有当请求被发送到一个有效的资源（/balances/，/profiles/或/transactions/）并且请求的方法为&lt;code&gt;GET&lt;/code&gt;，且请求来自一个用等于 &lt;code&gt;spiffe://example.org/ns/default/sa/default/frontend&lt;/code&gt; 的 SPIFFE ID 认证的工作负载时，策略才会评估为真。在所有其他情况下，请求都不会被 OPA 授权，因此会被 Envoy 拒绝。&lt;/p&gt;
&lt;h3 id=&#34;在-envoy-中添加一个新的外部授权过滤器&#34;&gt;在 Envoy 中添加一个新的外部授权过滤器&lt;/h3&gt;
&lt;p&gt;Envoy 需要知道如何联系刚刚配置的 OPA Agent，以执行每个请求的授权。为了完成设置，我们在&lt;a href=&#34;https://github.com/spiffe/spire-tutorials/blob/main/k8s/envoy-jwt-opa/k8s/backend/config/envoy.yaml&#34; title=&#34;Envoy 配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 配置&lt;/a&gt;的&lt;code&gt;http_filters&lt;/code&gt;部分添加一个类型为 External Authorization Filter 的新过滤器，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.http.ext_authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;with_request_body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max_request_bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8192&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;allow_partial_message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failure_mode_allow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transport_api_version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;V3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;google_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;target_uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8182&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stat_prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ext_authz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该配置告诉 Envoy 联系 OPA Agent，地址为 127.0.0.1，端口为 8182。这与在&lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-jwt-opa/readme/#opa-configuration&#34; title=&#34;OPA 配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA 配置&lt;/a&gt;部分解释的 OPA 配置相匹配。&lt;/p&gt;
&lt;h3 id=&#34;应用新资源&#34;&gt;应用新资源&lt;/h3&gt;
&lt;p&gt;确保当前的工作目录是&lt;code&gt;.../spire-tutorials/k8s/envoy-jwt-opa&lt;/code&gt;，并使用以下命令部署新资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -k k8s/.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-envoy configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;configmap/backend-opa-policy-config created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/backend configured
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了使新配置生效，需要重启&lt;code&gt;backend&lt;/code&gt;服务。运行以下两个命令来强制重启：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl scale deployment backend --replicas&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;第二部分测试连接&#34;&gt;第二部分：测试连接&lt;/h2&gt;
&lt;p&gt;现在服务已经更新和部署，让我们测试我们已经配置的授权。&lt;/p&gt;
&lt;h3 id=&#34;测试有效请求&#34;&gt;测试有效请求&lt;/h3&gt;
&lt;p&gt;第一个测试将演示如何允许满足策略的请求显示关联数据。为了运行这个测试，我们需要找到组成用于访问数据的 URL 的 IP 地址和端口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get services
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME            TYPE           CLUSTER-IP    EXTERNAL-IP      PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backend-envoy   ClusterIP      None            &amp;lt;none&amp;gt;           9001/TCP         5m56s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend        LoadBalancer   10.96.194.108   172.18.255.200   3000:30824/TCP   5m56s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;frontend-2      LoadBalancer   10.96.61.216    172.18.255.201   3002:31960/TCP   5m56s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes      ClusterIP      10.96.0.1       &amp;lt;none&amp;gt;           443/TCP          14m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;frontend&lt;/code&gt;服务将在&lt;code&gt;EXTERNAL-IP&lt;/code&gt;值和端口&lt;code&gt;3000&lt;/code&gt;处可用，这是我们为容器配置的。在上面显示的示例输出中，导航到的 URL 是&lt;code&gt;http://172.18.255.200:3000&lt;/code&gt;。打开浏览器，并导航到你的环境中显示为&lt;code&gt;frontend&lt;/code&gt;的 IP 地址，添加端口&lt;code&gt;:3000&lt;/code&gt;。一旦页面加载，你将看到用户&lt;em&gt;Jacob Marley&lt;/em&gt;的账户详情。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/frontend_view_hu7970156023612014886.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/frontend_view.png&#34; data-img=&#34;/book/spiffe-and-spire/examples/envoy-jwt-opa/frontend_view.png&#34; data-width=&#34;1828&#34; data-height=&#34;735&#34; alt=&#34;image&#34; data-caption=&#34;前端&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;前端&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;让我们看看 OPA Agent 的日志，看看幕后发生了什么。使用以下 Bash 脚本获取运行在&lt;code&gt;backend&lt;/code&gt;服务旁的 OPA 实例的日志，并使用 &lt;a href=&#34;https://stedolan.github.io/jq/&#34; title=&#34;jq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;jq&lt;/a&gt; 处理输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/backend-opa-logs.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出显示了每个请求的决策。例如，对&lt;code&gt;frontend&lt;/code&gt;服务的请求可能会产生类似于以下的日志条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;decision_id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;96ed5a6c-c2d3-493a-bdd2-bf8b94036bfb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;input&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;attributes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:authority&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;localhost:3001&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:method&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;:path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/transactions/1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;accept-encoding&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gzip&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;authorization&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6ImU2d3JsNkw3Nm5HS3VVVDlJdVhoVEpFbFVIaExSZFJrIiwidHlwIjoiSldUIn0.eyJhdWQiOlsic3BpZmZlOi8vZXhhbXBsZS5vcmcvbnMvZGVmYXVsdC9zYS9kZWZhdWx0L2JhY2tlbmQiXSwiZXhwIjoxNTk0MjM5NzQ3LCJpYXQiOjE1OTQyMzk0NDcsInN1YiI6InNwaWZmZTovL2V4YW1wbGUub3JnL25zL2RlZmF1bHQvc2EvZGVmYXVsdC9mcm9udGVuZCJ9.YiS52Y44iOGgaRPcXmhm_FRHgjGIPknx3HqHvVsQNiQw4uJx3eICPECQqTpFOh3flEqvDizlpehipHHdhKEy8TvZtJRnPQ69Jofce4aCx5wF0KQtOBZ79bx9H0Y0gcWWzIDb3YW3uNVfZnHvojlLnzqJb3axIhAqgNbURmlm4STTISxJxNzYcr24Zio6uTYSEJmLtQlFVShhUUQr0zFyj_tbyc9RRcX3MNWLFrkWS8eVIQvkvKBO2zYt2FA0GACBnSFDcR6u2G-5QCU7mzlOnqCrMZ6q4aaRp86v33fYbKZKSfghfcmAeOKc-aai92sTlSPSpWnv5qLKIs6GpT6H7A&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;content-length&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;user-agent&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Go-http-client/1.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;x-forwarded-proto&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;x-request-id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;fad45df6-3cc1-4ce9-9cad-fb3b65eff037&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;localhost:3001&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10476077497628160603&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;method&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/transactions/1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HTTP/1.1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Decision Log&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;query&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;data.envoy.authz.allow&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;requested_by&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;result&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-07-08T20:17:27Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;timestamp&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-07-08T20:17:27.7568234Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;openpolicyagent.org/decision_logs&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意 &lt;code&gt;authorization&lt;/code&gt; 头中包含了 JWT。如 &lt;a href=&#34;https://spiffe.io/docs/latest/microservices/envoy-jwt-opa/readme/#opa-policy&#34; title=&#34;OPA 策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA 策略&lt;/a&gt; 部分所解释的，这个 JWT 使用 OPA 提供的专用代码进行解码，然后提取 SPIFFE ID。我们已经知道，&lt;code&gt;frontend&lt;/code&gt; 服务的 SPIFFE ID 与为 OPA Agent 配置的 Rego 策略中定义的 SPIFFE ID 匹配。此外，请求的路径和方法也匹配规则，所以决策的 &lt;code&gt;result&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，请求被允许通过过滤器并到达 &lt;code&gt;backend&lt;/code&gt; 服务。&lt;/p&gt;
&lt;h3 id=&#34;测试无效的请求&#34;&gt;测试无效的请求&lt;/h3&gt;
&lt;p&gt;另一方面，当你连接到 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 URL (例如 &lt;code&gt;http://172.18.255.201:3002&lt;/code&gt;) 时，浏览器只显示标题，没有任何账户详情。这是因为 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 SPIFFE ID（&lt;code&gt;spiffe://example.org/ns/default/sa/default/frontend-2&lt;/code&gt;）不满足 OPA Agent 的策略。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
&lt;/figure&gt;
&lt;p&gt;在尝试显示 &lt;code&gt;frontend-2&lt;/code&gt; 数据后，你可以使用与前一节中执行的相同的 &lt;code&gt;scripts/backend-opa-logs.sh&lt;/code&gt; 脚本来验证 OPA 做出的决定。对于 &lt;code&gt;frontend-2&lt;/code&gt; 服务，有一个类似的日志条目，但是由于 SPIFFE ID 不匹配，&lt;code&gt;result&lt;/code&gt; 等于 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;用新策略重新测试-frontend-2&#34;&gt;用新策略重新测试 frontend-2&lt;/h3&gt;
&lt;p&gt;让我们更新 Rego 策略以匹配 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 SPIFFE ID，然后再测试。你可以利用一个 Bash 脚本来完成这个任务。一旦执行，它会打开你的 &lt;code&gt;KUBE_EDITOR&lt;/code&gt; 或 &lt;code&gt;EDITOR&lt;/code&gt; 环境变量定义的编辑器，或者回退到 Linux 的 &lt;code&gt;vi&lt;/code&gt; 或 Windows 的 Notepad。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/backend-update-policy.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;打开编辑器后，寻找指定规则要匹配的 SPIFFE ID 的以下行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新该行以匹配 &lt;code&gt;frontend-2&lt;/code&gt; 服务的 SPIFFE ID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;svc_spiffe_id == &amp;#34;spiffe://example.org/ns/default/sa/default/frontend-2&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存更改并退出。&lt;code&gt;backend-update-policy.sh&lt;/code&gt; 脚本恢复。该脚本应用 ConfigMap 的新版本，然后重启 &lt;code&gt;backend&lt;/code&gt; pod 以获取新规则。在尝试再次在浏览器中查看 &lt;code&gt;frontend-2&lt;/code&gt; 服务之前，等待一些秒钟以便部署传播。一旦 pod 准备好，刷新使用 &lt;code&gt;frontend-2&lt;/code&gt; 服务的正确 URL（例如 &lt;code&gt;http://172.18.255.201:3002&lt;/code&gt;）的浏览器。结果，现在页面显示了用户 &lt;em&gt;Alex Fergus&lt;/em&gt; 的帐户详细信息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
  
  
&lt;/figure&gt;
&lt;p&gt;另一方面，如果你现在连接到 &lt;code&gt;frontend&lt;/code&gt; 服务的 URL（例如 &lt;code&gt;http://172.18.255.200:3000&lt;/code&gt;），浏览器只显示标题，没有任何账户详情。这是预期的行为，因为策略已经更新，现在 &lt;code&gt;frontend&lt;/code&gt; 服务的 SPIFFE ID 不再满足策略。&lt;/p&gt;
&lt;h2 id=&#34;清理&#34;&gt;清理&lt;/h2&gt;
&lt;p&gt;当你完成后，你可以使用以下命令清理为教程创建的环境。它将移除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为这个 SPIRE - Envoy JWT 与 OPA 集成教程创建的所有资源&lt;/li&gt;
&lt;li&gt;为 SPIRE - Envoy JWT 集成教程创建的所有资源&lt;/li&gt;
&lt;li&gt;SPIRE Agent、SPIRE Server 和命名空间的所有部署和配置&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bash scripts/clean-env.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
                           
    <item>
      <title>SPIFFE 和 SPIRE 概念介绍</title>
      <link>https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/</guid>
      <description>
        
        
        &lt;p&gt;在第三章介绍的概念基础上，本章说明了 SPIFFE 标准。解释 SPIRE 实现的组成部分以及它们是如何结合在一起的。最后，讨论威胁模型以及如果特定组件被破坏会发生什么。&lt;/p&gt;
&lt;h2 id=&#34;什么是-spiffe&#34;&gt;什么是 SPIFFE？&lt;/h2&gt;
&lt;p&gt;普适安全生产身份框架（SPIFFE）是一套软件身份的开源标准。为了以一种与组织和平台无关的方式实现可互操作的软件身份，SPIFFE 定义了必要的接口和文件，以完全自动化的方式获得和验证加密身份。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-1_hu12426573985564890803.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-1.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-1.jpg&#34; data-width=&#34;1088&#34; data-height=&#34;546&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;SPIFFE ID，代表软件服务的名称（或身份）。&lt;/li&gt;
&lt;li&gt;SPIFFE 可验证身份文件（SVID），这是一个可加密验证的文件，用于向对等者证明服务的身份。&lt;/li&gt;
&lt;li&gt;SPIFFE Workload API，这是一个简单的节点本地 API，服务用它来获得身份，而不需要认证。&lt;/li&gt;
&lt;li&gt;SPIFFE Trust Bundle（信任包），一种代表特定 SPIFFE 发行机构使用的公钥集合的格式。&lt;/li&gt;
&lt;li&gt;SPIFFE Federation，这是一个简单的机制，通过它可以共享 SPIFFE Trust Bundle。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spiffe-不是什么&#34;&gt;SPIFFE 不是什么&lt;/h3&gt;
&lt;p&gt;SPIFFE 旨在识别服务器、服务和其他通过计算机网络通信的非人类实体。这些都有一个共同点，那就是这些身份必须是&lt;strong&gt;可以自动发出的&lt;/strong&gt;（没有人类在其中参与）。虽然有可能使用 SPIFFE 来识别人或其他野生动物物种，但该项目特意将这些用例排除在范围之外。除了机器人和机器之外，没有其他特别的考虑。&lt;/p&gt;
&lt;p&gt;SPIFFE 向服务提供身份和相关信息，同时管理该身份的生命周期，但&lt;strong&gt;它仅仅作为提供者&lt;/strong&gt;，因为它不直接利用其提供的身份。利用 SPIFFE 身份是服务的责任。在使用 SPIFFE 身份时，有多种解决方案可以实现认证层，如端到端加密通信或服务间授权和访问控制，但是，这些功能也被认为不属于 SPIFFE 项目的范围，SPIFFE 不会直接解决这些问题。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-id&#34;&gt;SPIFFE ID&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 是一个字符串，作为服务的唯一名称。它被模拟成一个 URI，由几个部分组成。前缀 &lt;code&gt;spiffe://&lt;/code&gt;（作为 URI 的方案），信任域的名称（作为主机部分），以及特定工作负载的名称或身份（作为路径部分）。&lt;/p&gt;
&lt;p&gt;一个简单的 SPIFFE ID 可能只是 &lt;code&gt;spiffe://example.com/myservice&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-2_hu351730291389849872.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-2.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-2.jpg&#34; data-width=&#34;764&#34; data-height=&#34;464&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;SPIFFE ID 的第一个组成部分是 &lt;code&gt;spiffe:// &lt;/code&gt;URI 方案。虽然很普通，但包括它是一个重要的细节，因为它有助于将 SPIFFE ID 与 URL 或其他类型的 URL 区分开来。&lt;/p&gt;
&lt;p&gt;SPIFFE ID 的第二个组成部分是信任域名称（&lt;code&gt;example.com&lt;/code&gt;）。在某些情况下，整个组织只有一个信任域。在其他情况下，可能需要有许多信任域。信任域的语义将在本章后面介绍。&lt;/p&gt;
&lt;p&gt;最后一个组成部分是工作负载本身的名称部分，由 URI 路径表示。SPIFFE ID 的这一部分的具体格式和组成是因地制宜的。各机构可以自由选择对其最有意义的命名方案。例如，我们可以选择一个既能反映组织位置又能反映工作负载目的的命名方案，如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://example.com/bizops/hr/taxrun/withholding
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，SPIFFE ID 的主要目的是以一种灵活的方式来表示工作负载的身份，使人类和机器都能轻松使用。当试图在 SPIFFE ID 的格式中灌输太多的意义时，应该谨慎行事。例如，试图编纂后来被用作授权元数据的各个部分的属性，会导致互操作性和灵活性的挑战。相反，建议使用一个&lt;a href=&#34;https://en.wiktionary.org/wiki/lookaside&#34; title=&#34;单独的数据库&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单独的数据库&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-信任域&#34;&gt;SPIFFE 信任域&lt;/h3&gt;
&lt;p&gt;SPIFFE 规范引入了&lt;strong&gt;信任域&lt;/strong&gt;的概念。信任域被用来管理组织内部和组织之间的管理和安全边界，每个 SPIFFE ID 都有其信任域的名称，如上所述。具体来说，信任域是 SPIFFE ID 命名空间的一部分，在这个命名空间中，一组特定的公钥被认为是权威的。&lt;/p&gt;
&lt;p&gt;由于不同的信任域有不同的签发机构，一个信任域的破坏不会危及另一个信任域。这是一个重要的属性，使互不信任的各方之间能够进行安全通信，例如，在 staging 和生产之间或一个公司和另一个公司之间。&lt;/p&gt;
&lt;p&gt;跨越多个信任域验证 SPIFFE 身份的能力被称为 SPIFFE Federation，在本章后面介绍。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-可验证身份文件svid&#34;&gt;SPIFFE 可验证身份文件（SVID）&lt;/h3&gt;
&lt;p&gt;SPIFFE 可验证身份文件（SVID）是一个可加密验证的&lt;strong&gt;身份文件&lt;/strong&gt;，用于向对等体证明一个服务的身份。SVID 包括一个单一的 SPIFFE ID，并由代表服务所在的信任域的签发机构签署。&lt;/p&gt;
&lt;p&gt;与其发明一种新的文件类型让软件支持，SPIFFE 选择利用那些已经被广泛使用并被充分理解的文件类型。在撰写本报告时，有两种身份文件被定义为 SPIFFE 规范中的 SVID 使用：X.509 和 JWT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X509-SVID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;X509-SVID 将 SPIFFE 身份编码为&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; title=&#34;标准 X.509 证书&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准 X.509 证书&lt;/a&gt;。相应的 SPIFFE ID 被设置为主题替代名称（SAN）扩展字段中的 URI 类型。虽然 X509-SVID 上只允许设置一个 URI SAN 字段，但证书可以包含任何数量的其他类型的 SAN 字段，包括 DNS SAN。&lt;/p&gt;
&lt;p&gt;建议尽可能使用 X509-SVID，因为它们比 JWT-SVID 有更好的安全属性。具体来说，当与 TLS 结合使用时，X.509 证书不能被中间人记录和重放。&lt;/p&gt;
&lt;p&gt;利用 X509-SVID 可能有额外的要求，请参考 &lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/X509-SVID.md&#34; title=&#34;X509-SVID 规范部分&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;X509-SVID 规范部分&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JWT-SVID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JWT-SVID 将 SPIFFE 身份编码为一个标准的 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; title=&#34;JWT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT&lt;/a&gt;—— 特别是一个 &lt;a href=&#34;https://tools.ietf.org/html/rfc7515&#34; title=&#34;JWS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWS&lt;/a&gt;。JWT-SVID 被用作承载令牌，在应用层向对等者证明身份。与 X509-SVID 不同，JWT-SVID 受到一类被称为 &lt;a href=&#34;https://en.wikipedia.org/wiki/Replay_attack&#34; title=&#34;重放攻击&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重放攻击&lt;/a&gt;的威胁，即令牌被未经授权的一方获得并重新使用。&lt;/p&gt;
&lt;p&gt;SPIFFE 规定了三种机制来缓解这种攻击媒介。首先，JWT-SVID 必须只通过安全通道传输。其次，受众声明（ &lt;code&gt;aud&lt;/code&gt; 声明）必须被设置为与令牌的目的方严格匹配的字符串。最后，所有的 JWT-SVID 必须包括一个过期时间，限制被盗令牌的有效期限。&lt;/p&gt;
&lt;p&gt;尤其需要注意的是，尽管有这些缓解措施，JWT-SVID 从根本上说仍然容易受到重放攻击，因此应该谨慎使用并小心处理。也就是说，它们是 SPIFFE 规范集的一个重要部分，因为它们允许 SPIFFE 认证在不可能建立端到端通信渠道的情况下发挥作用。&lt;/p&gt;
&lt;p&gt;利用 JWT-SVID 可能有额外的要求，请参考 &lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/JWT-SVID.md&#34; title=&#34;JWT-SVID 规范部分&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT-SVID 规范部分&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-信任包&#34;&gt;SPIFFE 信任包&lt;/h3&gt;
&lt;p&gt;SPIFFE 信任包是一个包含信任域公钥的文件。每种 SVID 类型都有一个特定的方式在这个包中表示出来（例如，对于 X509-SVID，包括代表公钥的 CA 证书）。每个 SPIFFE 信任域都有一个与之相关的捆绑包，该捆绑包中的材料被用来验证声称位于该信任域中的 SVID。&lt;/p&gt;
&lt;p&gt;由于信任包不包含任何秘密（只有公钥），它可以安全地与公众分享。尽管这一事实，它确实需要安全地分发，以保护其内容不被擅自修改。换句话说，保密性是不需要的，但完整性是需要的。&lt;/p&gt;
&lt;p&gt;SPIFFE 捆绑包的格式是 JWK Set（或 JWKS 文档），与现有的认证技术如 &lt;a href=&#34;https://openid.net/connect/&#34; title=&#34;OpenID Connect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenID Connect&lt;/a&gt; 兼容。JWKS 是一种灵活且被广泛采用的格式，用于表示各种类型的加密密钥和文件，在新的 SVID 格式被定义的情况下，它提供了一些未来证明。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-federation&#34;&gt;SPIFFE Federation&lt;/h3&gt;
&lt;p&gt;通常，允许在不同信任域的服务之间进行安全通信是可取的。在许多情况下，你不能把所有的服务放在一个信任域中。一个常见的例子是两个不同的组织需要相互通信。另一个例子可能是一个组织需要建立安全边界，也许是在信任度较低的云环境和高度信任的内部服务之间。&lt;/p&gt;
&lt;p&gt;为了能够实现这一点，每个服务必须拥有远程服务所来自的外部信任域的&lt;strong&gt;捆绑包（Bundle）&lt;/strong&gt;。因此，SPIFFE 信任域必须公开或以其他方式分享其捆绑包内容，使外部信任域中的服务能够验证来自本地信任域的身份。用于共享信任域的捆绑内容的机制被称为&lt;strong&gt;捆绑端点（Bundle Endpoint）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;捆绑端点是简单的 TLS 保护的 HTTP 服务。希望与外部信任域联合的运营商必须用外部信任域的名称和捆绑端点的 URL 来配置他们的 SPIFFE 实现，允许定期获取捆绑包的内容。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-3_hu12129748874325890332.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-3.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-3.jpg&#34; data-width=&#34;1198&#34; data-height=&#34;418&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;spiffe-workload-api&#34;&gt;SPIFFE Workload API&lt;/h3&gt;
&lt;p&gt;SPIFFE Workload API 是一个本地的、非网络化的 API，工作负载用它来获取当前的身份文件、信任捆绑和相关信息。重要的是，这个 API 是&lt;strong&gt;未经认证的&lt;/strong&gt;，不要求工作负载拥有任何预先存在的证书。将这一功能作为本地 API 提供，允许 SPIFFE 实现者提出创造性的解决方案，在不需要直接认证的情况下识别调用者（例如，利用操作系统提供的功能）。Workload API 以 gRPC 服务器的形式公开，并使用双向流，允许根据需要将更新推入工作负载。&lt;/p&gt;
&lt;p&gt;Workload API 不要求调用的工作负载对自己的身份有任何了解，也不要求调用 API 时拥有任何凭证。这就避免了在工作负载旁边部署任何认证秘密的需要。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-4_hu6436837327193404565.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-4.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-4.jpg&#34; data-width=&#34;1216&#34; data-height=&#34;708&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;SPIFFE 工作负载 API 向工作负载提供 SVID 和信任包，并在必要时对其进行轮换。&lt;/p&gt;
&lt;h2 id=&#34;什么是-spire&#34;&gt;什么是 SPIRE？&lt;/h2&gt;
&lt;p&gt;SPIFFE 运行环境（SPIRE）是 SPIFFE 规范中所有五个部分的一个生产可用的开源实现。&lt;/p&gt;
&lt;p&gt;SPIRE 项目（以及 SPIFFE）由云原生计算基金会主办，该基金会由许多领先的基础设施技术公司成立，为有利于云原生社区的开源项目提供一个中立的家园。&lt;/p&gt;
&lt;p&gt;SPIRE 有两个主要组成部分：服务器和代理。服务器负责验证代理和构建 SVID，而代理则负责为 SPIFFE Workload API 提供服务。这两个组件都是使用面向插件的架构编写的，因此它们可以很容易地被扩展，以适应大量不同的配置和平台。&lt;/p&gt;
&lt;h3 id=&#34;spire-架构&#34;&gt;SPIRE 架构&lt;/h3&gt;
&lt;p&gt;SPIRE 的架构由两个关键组件组成，即 SPIRE 服务器和 SPIRE 代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPIRE 服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 服务器管理和发布 SPIFFE 信任域中的所有身份。它使用一个数据存储来保存关于其代理和工作负载等的信息。SPIRE 服务器通过使用注册条目获知其管理的工作负载，注册条目是为节点和工作负载分配 SPIFFE ID 的灵活规则。&lt;/p&gt;
&lt;p&gt;该服务器可以通过 API 或命令行命令进行管理。需要注意的是，由于服务器掌握着 SVID 的签名密钥，它被认为是一个重要的安全组件。在决定它的位置时应特别考虑。这一点将在本书后面讨论。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;数据存储&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 服务器使用一个&lt;strong&gt;数据存储&lt;/strong&gt;来跟踪其当前的注册条目，以及它所发布的 SVID 的状态。目前，支持几种不同的 SQL 数据库。SPIRE 内置 SQLite，这是一个内存中的嵌入式数据库，用于开发和测试目的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上游机构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个信任域中的所有 SVID 都由 SPIRE 服务器签署。默认情况下，SPIRE 服务器会生成一个自签名证书（用自己随机生成的私钥签名的证书）来签署 SVID，除非配置了一个 &lt;strong&gt;上游证书机构（Upstream Certificate Authority）&lt;/strong&gt; 插件接口。上游证书授权的插件接口允许 SPIRE 从另一个证书授权机构获得其签名证书。&lt;/p&gt;
&lt;p&gt;在许多简单的情况下，使用自签名的证书就可以了。然而，对于较大的安装，可能需要利用预先存在的证书颁发机构和 X.509 证书的分层性质，使多个 SPIRE 服务器（和其他生成 X.509 证书的软件）一起工作。&lt;/p&gt;
&lt;p&gt;在一些组织中，上游证书颁发机构可能是一个中央证书颁发机构，你的组织在其他方面使用它。如果你有许多不同种类的证书在使用，而且你希望它们在你的基础设施中都被信任，那么这就很有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPIRE 代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理只有一个功能，尽管是一个非常重要的功能：为 Workload API 服务。在完成这一壮举的过程中，它解决了一些相关的问题，如确定工作负载的身份，调用它，并安全地将自己介绍给 SPIRE 服务器。在这种安排中，它是执行所有重任的代理。&lt;/p&gt;
&lt;p&gt;代理不需要像 SPIRE 服务器那样的主动管理。虽然它们确实需要一个配置文件，但 SPIRE 代理从 SPIRE 服务器直接接收有关本地信任域和可能调用它的工作负载的信息。在给定的信任域中定义新的工作负载时，只需在 SPIRE 服务器中定义或更新记录，有关新工作负载的信息就会自动传播给相应的代理。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-5_hu10156839107902445946.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-5.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-5.jpg&#34; data-width=&#34;1218&#34; data-height=&#34;930&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;插件架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 是作为一套插件建立的，因此很容易扩展，以适应新的节点验证器、工作负载验证器和上游机构。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-6_hu5912244230489824181.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-6.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-6.jpg&#34; data-width=&#34;1310&#34; data-height=&#34;850&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;SVID 管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理使用其在节点认证期间获得的身份，向 SPIRE 服务器进行认证，并获得其被授权管理的工作负载的 SVID。由于 SVID 是有时间限制的，代理还负责根据需要更新 SVID，并将这些更新传达给相关工作负载。信任捆绑也会轮换和接收捆绑包，这些更新由代理跟踪并传达给工作负载。代理维护所有这些信息的内存缓存，因此，即使 SPIRE 服务器停机，也可以提供 SVID，而且还可以确保 Workload API 响应的性能，因为当有人调用工作负载 API 时，不需要往返于服务器。&lt;/p&gt;
&lt;h3 id=&#34;证明&#34;&gt;证明&lt;/h3&gt;
&lt;p&gt;证明是一个过程，通过这个过程可以发现和断言有关工作负载及其环境的信息。换句话说，它是一个利用现有信息作为证据证明工作负载身份的过程。&lt;/p&gt;
&lt;p&gt;在 SPIRE 中，有两种类型的证明：节点和工作负载证明。节点证明主张描述节点的属性（例如，特定 AWS 自动扩展组的成员，或节点位于哪个 Azure 区域），而工作负载证明主张描述工作负载的属性（例如，它正在运行的 Kubernetes 服务账户，或磁盘上的二进制文件的路径）。这些属性在 SPIRE 中的表述被称为&lt;strong&gt;选择器（Selector）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;SPIRE 支持几十种开箱即用的选择器类型，而且这个列表还在继续增加。截至本文撰写之时，节点验证器列表包括对裸机、Kubernetes、亚马逊网络服务、谷歌云平台、Azure 等的支持。工作负载验证器包括对 Docker、Kubernetes、Unix 等的支持。&lt;/p&gt;
&lt;p&gt;此外，SPIRE 的可插拔架构允许运营商轻松扩展系统，以支持他们认为合适的其他选择器类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;节点认证发生在代理首次启动时。在节点认证中，代理与 SPIRE 服务器联系并进行交流，服务器旨在积极识别代理正在运行的节点及其所有相关选择器。为了实现这一目标，在代理和服务器中都运行了一个特定平台的插件。例如，在 AWS 的情况下，代理插件从 AWS 收集只有该特定节点可以访问的信息（由 AWS 密钥签署的文件），并将其传递给服务器。然后，服务器插件验证 AWS 的签名，并进一步调用 AWS 的 API，以断定该声明的准确性，并收集有关该节点的额外选择器。&lt;/p&gt;
&lt;p&gt;成功的节点认证会导致其向有关的代理发放身份。然后，代理使用这个身份进行所有进一步的服务器通信。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-7_hu14539058622240868672.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-7.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-7.jpg&#34; data-width=&#34;840&#34; data-height=&#34;622&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;代理收集节点的身份证明，调用 AWS 的 API。&lt;/li&gt;
&lt;li&gt;代理将此身份证明发送给服务器。&lt;/li&gt;
&lt;li&gt;服务器通过调用 AWS API 验证步骤 2 中获得的身份证明，然后为代理创建一个 SPIFFE ID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;工作负载证明&#34;&gt;工作负载证明&lt;/h3&gt;
&lt;p&gt;工作负载认证是确定工作负载身份的过程，它将导致身份文件的发布和交付。在工作负载调用并建立与 SPIFFE Workload API 的连接时（在工作负载对 API 的每一次 RPC 调用中），都会进行认证，而此后的过程则由 SPIRE 代理上的一组插件驱动。&lt;/p&gt;
&lt;p&gt;当代理收到来自调用工作负载的新连接时，代理将利用操作系统功能来确定到底是哪个进程打开了新连接。所利用的操作系统功能将取决于代理运行的操作系统。在 Linux 的情况下，代理将进行系统调用，以检索进程 ID，用户标识符，以及在特定套接字上调用的远程系统的全局唯一标识符。在 BSD 和 Windows 中，要求的内核元数据将是不同的。反过来，代理将向验证器插件提供调用工作负载的 ID。从这里开始，验证器在其插件中扇出，提供关于调用者的额外进程信息，并以选择器的形式将其返回给代理。&lt;/p&gt;
&lt;p&gt;每个验证器插件负责对调用者进行内省，生成一组描述调用者的选择器。例如，一个插件可以查看内核级别的细节，并生成选择器，如进程以何种身份运行的用户和组，而另一个插件可以与 Kubernetes 通信，并生成选择器，如进程运行的命名空间和服务账户。第三个插件可以与 Docker 守护进程通信，并生成 Docker 镜像 ID、Docker 标签和容器环境变量的选择器。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-8_hu11708603855627491003.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-8.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-8.jpg&#34; data-width=&#34;526&#34; data-height=&#34;760&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;工作负载调用 Workload API 请求 SVID。&lt;/li&gt;
&lt;li&gt;代理询问节点的内核以获得调用进程的属性。&lt;/li&gt;
&lt;li&gt;代理得到发现的选择器。&lt;/li&gt;
&lt;li&gt;代理通过比较发现的选择器和注册条目来确定工作负载的身份，并向工作负载返回正确的 SVID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;登记条目&#34;&gt;登记条目&lt;/h3&gt;
&lt;p&gt;为了让 SPIRE 发布工作负载身份，它必须首先了解其环境中预期或允许的工作负载；哪些工作负载应该在哪里运行，它们的 SPIFFE ID 和一般组成应该是什么。SPIRE 通过&lt;strong&gt;注册条目&lt;/strong&gt;了解这些信息，注册条目是使用 SPIRE API 创建和管理的对象，包含上述信息。&lt;/p&gt;
&lt;p&gt;对于每个注册条目，有三个核心属性。第一个被称为 Parent ID—— 这实际上是告诉 SPIRE 一个特定的工作负载应该在哪里运行（以及延伸到哪些代理被授权代表它询问 SVID）。第二个是 SPIFFE ID—— 当我们看到这个工作负载时，我们应该向它发出什么 SPIFFE ID？最后，SPIRE 需要一些信息来帮助它识别工作负载，这就是证明中选择器的作用。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-9_hu5237852999372858202.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-9.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-9.jpg&#34; data-width=&#34;1056&#34; data-height=&#34;446&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;注册条目将 SPIFFE ID 与它们所代表的节点和工作负载绑定。&lt;/p&gt;
&lt;p&gt;注册条目既可以描述一组节点，也可以描述一个工作负载，后者通常使用 Parent ID 来引用前者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点条目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述一个节点（或一组节点）的注册条目使用由节点认证产生的选择器来分配一个 SPIFFE ID，这在以后注册工作负载时可以被引用。一个节点可以被证明有一组与多个节点条目相匹配的选择器，从而允许它加入一个以上的组。在决定一个特定的工作负载被允许运行的确切位置时，这提供了很大的灵活性。&lt;/p&gt;
&lt;p&gt;SPIRE 自带各种节点验证器可供使用，每个验证器都会生成特定平台的选择器。虽然 SPIRE 服务器支持一次加载多个节点验证器插件，但 SPIRE 代理只支持加载一个。目前可用的节点选择器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在谷歌云平台（GCP）上。&lt;/li&gt;
&lt;li&gt;在 Kubernetes 上，该节点所处的 Kubernetes 集群的名称。&lt;/li&gt;
&lt;li&gt;在亚马逊网络服务（AWS），节点的 AWS 安全组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点条目的 Parent ID 被设置为 SPIRE 服务器的 SPIFFE ID，因为是服务器在进行验证，并断言有关节点确实符合条目定义的选择器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作负载条目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述工作负载的注册条目使用由工作负载证明产生的选择器，在满足一定条件的情况下为工作负载分配一个 SPIFFE ID。当 Parent ID 和选择器的条件得到满足时，工作负载可以得到一个 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;工作负载条目的 Parent ID 描述了该工作负载被授权运行的地方。其值是一个节点或一组节点的 SPIFFE ID。在节点上运行的 SPIRE 代理会收到该工作负载条目的副本，包括在为该特定条目发出 SVID 之前必须证明的选择器。&lt;/p&gt;
&lt;p&gt;当工作负载调用代理时，代理进行工作负载验证，并将发现的选择器与条目中定义的选择器进行交叉对比。如果一个工作负载拥有整个定义的选择器集，那么条件就得到了满足，该工作负载就会得到一个带有定义的 SPIFFE ID 的 SVID。&lt;/p&gt;
&lt;p&gt;与节点认证不同，SPIRE 代理支持同时加载许多工作负载验证器插件。这允许在工作负载条目中混合匹配选择器。例如，工作负载条目可能要求工作负载在特定的 Kubernetes 命名空间中，在其 Docker 镜像上应用特定的标签，并具有特定的 SHA 和。&lt;/p&gt;
&lt;h2 id=&#34;spiffespire-应用的概念威胁模型&#34;&gt;SPIFFE/SPIRE 应用的概念威胁模型&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 所面临的一系列具体威胁是情景性的。了解 SPIFFE/SPIRE 的一般威胁模式是断言你的具体需求可以得到满足的重要步骤，也是发现可能需要进一步缓解的地方。&lt;/p&gt;
&lt;p&gt;在本节中，我们将描述 SPIFFE 和 SPIRE 的安全边界，以及系统中每个组件被破坏的影响。在本书的后面，我们将介绍不同的 SPIRE 部署模式所带来的具体安全考虑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 旨在作为分布式身份和认证的基础，与&lt;a href=&#34;https://github.com/cncf/toc/blob/master/DEFINITION.md&#34; title=&#34;云原生&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生&lt;/a&gt;设计架构一致。SPIRE 支持 Linux 和 BSD 系列（包括 MacOS）。目前不支持 Windows，尽管在这个领域已经做了一些早期的原型设计。&lt;/p&gt;
&lt;p&gt;SPIRE 坚持零信任网络安全模型，其中假定网络通信是敌对的或可能完全被破坏。也就是说，还假设 SPIRE 组件运行的硬件以及其操作人员是值得信赖的。如果硬件植入或内部威胁是威胁模型的一部分，应围绕 SPIRE 服务器的物理位置和其配置参数的安全性进行仔细考虑。&lt;/p&gt;
&lt;p&gt;根据所选择的节点和工作负载证明方法，可能进一步隐含对第三方平台或软件的信任。通过多个独立的机制来证明信任，可以提供更多的信任证明。例如，利用基于 AWS 或 GCP 的节点证明，意味着计算平台被认为是值得信赖的，而利用 Kubernetes 的工作负载证明，意味着 Kubernetes 的部署被认为是值得信赖的。由于完成证明的方式多种多样，而且 SPIRE 架构是完全可插拔的，因此本评估不考虑这些流程的安全性（和相关假设）。相反，它们应逐一进行评估。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-10_hu12167676130109906778.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-10.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-10.jpg&#34; data-width=&#34;742&#34; data-height=&#34;948&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;安全边界&#34;&gt;安全边界&lt;/h3&gt;
&lt;p&gt;安全边界在形式上被理解为两个不同信任程度的区域之间的交汇线。&lt;/p&gt;
&lt;p&gt;SPIFFE/SPIRE 定义了三个主要的安全边界：一个是工作负载和代理之间，一个是代理和服务器之间，还有一个是不同信任域的服务器之间。在这个模型中，工作负载是完全不受信任的，其他信任域中的服务器也是如此，如前所述，网络通信始终是完全不受信任的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-11_hu7482847200767802223.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-11.jpg&#34; data-img=&#34;/book/spiffe/introduction-to-spiffe-and-spire-concepts/f4-11.jpg&#34; data-width=&#34;1022&#34; data-height=&#34;996&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;工作负载 | 代理边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着人们在系统中的移动和跨越这些边界，信任程度会慢慢增加。从工作负载开始，我们跨越安全边界进入代理。通常预计（尽管不是必须的），工作负载和代理之间存在超越 SPIRE 设计的安全机制，例如利用 Linux 用户权限和 / 或容器化。&lt;/p&gt;
&lt;p&gt;代理不相信工作负载会提供任何形式的输入。代理对工作负载身份的所有断言都是通过带外检查做出的。在工作负载证明的背景下，这是一个重要的细节 —— 任何选择器的值可以被工作负载本身操纵，这本身就是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理 | 服务器边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个边界存在于代理和服务器之间。代理比工作负载更值得信任，但比服务器更不值得信任。SPIRE 的一个明确的设计目标是，它应该能够在节点受到威胁的情况下存活。由于工作负载是完全不可信的，我们在任何给定的时间点上离节点只有一到两次攻击威胁。代理有能力代表工作负载创建和管理身份，但也有必要将任何特定代理的权力限制在它完成任务所严格需要的范围内（遵循最小特权原则）。&lt;/p&gt;
&lt;p&gt;为了减轻节点（和代理）受到威胁的影响，SPIRE 需要了解特定工作负载被授权运行的地方（以 Parent ID 的形式）。代理必须能够证明注册条目的所有权，然后才能为其获得身份。因此，被攻击的代理不能获得任意的身份 —— 它们只能获得首先应该在节点上运行的工作负载的身份。&lt;/p&gt;
&lt;p&gt;值得注意的是，在节点认证过程中，SPIRE 服务器和 SPIRE 代理之间的通信可以在不同的时间点使用 TLS 和相互 TLS，这取决于节点是否尚未被认证，或者代理是否已经拥有有效的 SVID 并可以将其用于相互 TLS，此时服务器和代理之间的所有通信是安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器 | 服务器边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后的边界存在于不同信任域的服务器之间。SPIRE 服务器只被信任为在其直接管理的信任域内构造的 SVID。当 SPIRE 服务器相互联合并交换公钥信息时，它们收到的秘钥仍然是在它们所收到的信任域范围内的。与网络 PKI 不同，SPIFFE 不会简单地把所有的公钥扔到一个大的混合包里。其结果是，如果外部信任域的破坏不会导致本地信任域的 SVID 的构造能力。&lt;/p&gt;
&lt;p&gt;应该注意的是，SPIRE 服务器没有任何多方保护。信任域中的每个 SPIRE 服务器都可以访问签名密钥，它可以用这些密钥构造 SVID。服务器之间存在的安全边界严格限于不同信任域的服务器，不适用于同一信任域内的服务器。&lt;/p&gt;
&lt;h3 id=&#34;组件被破坏后的影响&#34;&gt;组件被破坏后的影响&lt;/h3&gt;
&lt;p&gt;虽然工作负载总是被认为是被破坏的，但预计代理一般不会被破坏。如果一个代理被破坏，攻击者将能够访问相应代理被授权管理的任何身份。在工作负载和代理之间存在 1:1 关系的部署中，这一点不太值得关注。在代理管理多个工作负载的部署中，这是一个需要理解的重要问题。&lt;/p&gt;
&lt;p&gt;当代理被引用为某一身份的父代时，它们被授权管理该身份。由于这个原因，在合理的范围内，将注册条目父身份的范围尽可能地缩小是一个好主意。&lt;/p&gt;
&lt;p&gt;在服务器被破坏的情况下，可以预计，攻击者将能够在该信任域内构造任意的身份。SPIRE 服务器无疑是整个系统中最敏感的组成部分。在管理和放置这些服务器时应小心谨慎。例如，SPIRE 解决了节点破坏的问题，因为工作负载不受信任，但如果 SPIRE 服务器与不受信任的工作负载在同一主机上运行，那么服务器就不再享有曾经由代理 / 服务器安全边界提供的保护。因此，强烈建议将 SPIRE 服务器放在与它们要管理的不受信任的工作负载不同的硬件上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 通过将一个代理的权限限定在它直接被授权管理的身份上，来说明节点的破坏&amp;hellip;&amp;hellip; 但如果攻击者可以破坏多个代理，或者也许是所有的代理，情况就明显要糟糕得多。&lt;/p&gt;
&lt;p&gt;SPIRE 代理之间没有任何通信途径，大大限制了代理之间横向移动的可能性。这是一个重要的设计决定，旨在减轻可能的代理漏洞的影响。然而，应该理解的是，某些配置或部署选择可能部分或全部破坏这种缓解。例如，SPIRE 代理支持暴露一个 Prometheus 指标端点，然而，如果所有代理都暴露这个端点，并且那里存在漏洞，那么横向移动就变得轻而易举，除非有足够的网络级别控制。出于这个原因，我们强烈不建议将 SPIRE 代理暴露于传入的网络连接。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>DevSecOps 组织准备、关键基本要素和实施</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/devsecops/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/devsecops/</guid>
      <description>
        
        
        &lt;p&gt;DevSecOps 在早期就将安全纳入了软件工程流程。它将安全流程和工具集成到 DevOps 的所有开发工作流程（或后面解释的管道）中，并使之自动化，从而实现无缝和连续。换句话说，它可以被看作是三个过程的组合。&lt;a href=&#34;https://medium.com/faun/devsecops-baking-security-into-development-process-9579418ad9a7&#34; title=&#34;开发 &amp;#43; 安全 &amp;#43; 运维&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发 + 安全 + 运维&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本节讨论了 DevSecOps 的以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组织对 DevSecOps 的准备情况&lt;/li&gt;
&lt;li&gt;开发安全运维平台&lt;/li&gt;
&lt;li&gt;开发安全运维的基本构件或关键原语&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;31-组织对-devsecops-的准备情况&#34;&gt;3.1 组织对 DevSecOps 的准备情况&lt;/h2&gt;
&lt;p&gt;DevSecOps 是一种软件开发、部署和生命周期管理方法，它涉及到从整个应用程序或平台的一次大型发布转变为持续集成、持续交付和持续部署（CI/CD）方法。这种转变又要求公司的 IT 部门的结构和工作流程发生变化。最明显的变化是组织一个 DevSecOps 小组，由软件开发人员、安全专家和 IT 运维专家组成，负责应用程序（即微服务）的每一部分。这个较小的团队不仅能促进最初的敏捷开发和部署的效率和效果，还能促进后续的生命周期管理活动，如监控应用行为、开发补丁、修复错误或扩展应用。这种具有三个领域专业知识的跨职能团队的组成，构成了在组织中引入 DevSecOps 的关键成功因素。&lt;/p&gt;
&lt;h2 id=&#34;32-devsecops-平台&#34;&gt;3.2 DevSecOps 平台&lt;/h2&gt;
&lt;p&gt;DevSecOps 是一个敏捷的、自动化的开发和部署过程，它使用称为 CI/CD 管道的原语，在自动化工具的帮助下，将软件从构建阶段带到部署阶段，最后到运行时间 / 操作阶段。这些管道是将开发者的源代码带过各个阶段的工作流程，如构建、测试、打包、交付，以及在各个阶段由测试工具支持的部署。&lt;/p&gt;
&lt;p&gt;DevSecOps 平台是指各种 CI/CD 管道（针对每种代码类型）运行的资源集合。至少，这个平台由以下部分组成。&lt;/p&gt;
&lt;p&gt;(a) 管道软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CI 软件 —— 从代码库中提取代码，调用构建软件，调用测试工具，并将测试后的工件存储到图像注册表中。&lt;/li&gt;
&lt;li&gt;CD 软件 —— 拉出工件、软件包，并根据 IaC 中的计算、网络和存储资源描述，部署软件包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(b) SDLC 软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建工具（例如，IDE）&lt;/li&gt;
&lt;li&gt;测试工具（SAST、DAST、SCA）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(c) 存储库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码库（如 GitHub）&lt;/li&gt;
&lt;li&gt;容器镜像存储库或注册表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(d) 可观测性或监测工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志和日志聚合工具&lt;/li&gt;
&lt;li&gt;产生指标的工具&lt;/li&gt;
&lt;li&gt;追踪工具（应用程序的调用顺序）&lt;/li&gt;
&lt;li&gt;可视化工具（结合上述数据生成仪表盘 / 警报）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 DevSecOps 平台中，通过内置的设计功能（如零信任）和使用一套全面的安全测试工具，如静态应用安全工具（SAST）、动态安全测试工具（DAST）和软件组成分析（SCA）工具进行测试，在构建和部署阶段提供安全保证。此外，在运行时 / 操作阶段，还通过持续的行为检测 / 预防工具提供安全保证，其中一些工具甚至可能使用人工智能（AI）和机器学习（ML）等复杂技术。因此，DevSecOps 平台不仅在构建和部署阶段运行，而且在运行时 / 操作阶段也运行。&lt;/p&gt;
&lt;p&gt;在一些 DevSecOps 平台中，执行应用程序安全分析的安全工具（例如 SAST、DAST 和 SCA），例如通过在后台的有效扫描来识别漏洞和错误，可以与集成开发环境（IDE）和其他 DevOps 工具紧密集成。这一功能的存在，使得这些工具对开发者来说是透明的，避免了他们为运行这些工具而 &lt;a href=&#34;https://sdtimes.com/security/appsec-vs-devsecops-and-what-that-means-for-developers/&#34; title=&#34;调用单独的 API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;调用单独的 API&lt;/a&gt;。根据集成开发环境、所执行的任务或工具所消耗的资源的不同，工具也可以与集成开发环境分开执行。&lt;/p&gt;
&lt;h2 id=&#34;321-devsecops-平台的可交付成果&#34;&gt;3.2.1 DevSecOps 平台的可交付成果&lt;/h2&gt;
&lt;p&gt;SAST、DAST 和 SCA 工具的使用可能不仅限于测试应用程序代码。DevSecOps 可能包括将这些工具用于其他代码类型，如 IaC，因为 IaC 定义了应用程序的部署架构，因此是自动评估和补救安全设计差距的关键途径。&lt;/p&gt;
&lt;p&gt;总之，DevSecOps 平台可以提供以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过在与应用环境中所有代码类型相关的管道内纳入充分的测试 / 检查，提供安全保证。安全性不是被归入一个单独的任务或阶段。&lt;/li&gt;
&lt;li&gt;DevSecOps 平台也在运行时（生产中）运行，通过协助执行零信任原则，并通过持续监控，随后的警报和纠正机制，提供实时的安全保证，从而实现持续授权操作（C-ATO）的认证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33-devsecops-关键原语和实施任务&#34;&gt;3.3 DevSecOps 关键原语和实施任务&lt;/h2&gt;
&lt;p&gt;所涉及的关键原语和实施任务是。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管道和 CI/CD 管道的概念&lt;/li&gt;
&lt;li&gt;CI/CD 管道的构建块&lt;/li&gt;
&lt;li&gt;设计和执行 CI/CD 管道&lt;/li&gt;
&lt;li&gt;自动化的战略&lt;/li&gt;
&lt;li&gt;CI/CD 管道中对安全自动化工具的要求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;331-管道的概念和-cicd-管道&#34;&gt;3.3.1 管道的概念和 CI/CD 管道&lt;/h3&gt;
&lt;p&gt;DevSecOps 作为一种敏捷应用开发、部署和运维的方法论或框架，与其他方法论一样，是由 &lt;a href=&#34;https://www.redhat.com/en/topics/devops/what-is-devsecops&#34; title=&#34;各个阶段&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;各个阶段&lt;/a&gt; 组成的。信息在各阶段中的顺序和流动被称为工作流，其中一些阶段可以平行执行，而其他阶段则必须遵循一个顺序。每个阶段可能需要调用一个独特的工作来执行该阶段的活动。&lt;/p&gt;
&lt;p&gt;DevSecOps 在流程工作流中引入的一个独特概念是 &lt;strong&gt;&lt;a href=&#34;https://www.redhat.com/en/topics/devops/what-is-ci-cd#:%7E:text=CI%2FCD%20is%20a%20method,continuous%20delivery%2C%20and%20continuous%20deployment&#34; title=&#34;管道&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管道&lt;/a&gt;&lt;/strong&gt; 的概念。有了管道，就不需要为启动 / 执行流程的每个阶段单独编写作业。相反，只有一个作业从初始阶段开始，自动触发与其他阶段有关的活动 / 任务（包括顺序的和并行的），并创建一个无错误的智能工作流程。&lt;/p&gt;
&lt;p&gt;DevSecOps 中的管道被称为 CI/CD 管道，这是基于它所完成的总体任务和它所包含的两个单独阶段。CD 可以表示持续交付或持续部署阶段。根据这后一个阶段，CI/CD 可以涉及以下任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建、测试、安全和交付：经过测试的修改后的代码被交付到暂存区。&lt;/li&gt;
&lt;li&gt;构建、测试、安全、交付和部署：暂存区的代码会自动部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前者中，自动化在交付阶段就结束了，接下来在托管平台基础设施中部署修改后的应用程序的任务是手动执行的。在后者中，部署也是自动化的。管道中任何阶段的自动化都可以通过将管道阶段表达为代码的工具来实现。&lt;/p&gt;
&lt;p&gt;CI/CD 管道的工作流程如下图 1 所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/service-mesh-devsecops/devsecops/f1_hu277347116966814924.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/service-mesh-devsecops/devsecops/f1.png&#34; data-img=&#34;/book/service-mesh-devsecops/devsecops/f1.png&#34; data-width=&#34;986&#34; data-height=&#34;302&#34; alt=&#34;image&#34; data-caption=&#34;图 1：CI/CD 管道工作流程&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 1：CI/CD 管道工作流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;图中所示的单元和集成测试使用了第 3.2 节中描述的 SAST、DAST 和 SCA 工具。应该注意的是，当测试失败时，组织可以选择继续构建过程。根据组织如何平衡风险容忍度和业务需求，当一个特定的测试失败时，它可以选择 fail-open（记录并继续）或 fail-closed（停止 / 中断）。在失败关闭的情况下，开发人员得到测试结果报告，必须修复问题，并重新启动 CI 过程。&lt;/p&gt;
&lt;p&gt;持续集成涉及到开发人员经常将代码变化合并到一个中央存储库中，在那里运行自动化的构建和测试。构建是将源代码转换为可执行代码的过程，以便在其上运行的平台。在 CI/CD 管道软件中，开发者的修改是通过创建构建和运行针对构建的自动测试来验证的。这个过程避免了在等待发布日将修改合并到发布分支时可能发生的 &lt;a href=&#34;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&#34; title=&#34;集成挑战&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集成挑战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;持续交付是持续集成之后的一个阶段，在这个阶段，代码的变化在构建阶段之后被部署到测试和 / 或暂存环境。持续交付到生产环境包括指定一个发布频率 —— 每天、每周、每两周或其他时期 —— 基于软件的性质或组织运营的市场。这意味着在自动化测试的基础上，有一个预定的发布过程，尽管应用程序可以通过点击一个按钮在任何时候被部署。持续交付中的部署过程的特点是手动，但诸如代码迁移到生产服务器、建立网络参数和指定运行时配置数据等任务可以由自动化脚本来完成。&lt;/p&gt;
&lt;p&gt;持续部署类似于持续交付，只是发布是 &lt;a href=&#34;https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment&#34; title=&#34;自动进行&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自动进行&lt;/a&gt; 的，代码的修改在完成后立即提供给客户。自动发布过程在很多情况下可能包括 A/B 测试，以促进新功能的缓慢上线，以便在出现错误 / 误差时减轻失败的影响。&lt;/p&gt;
&lt;p&gt;持续交付和持续部署之间的区别如图 2 中所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/service-mesh-devsecops/devsecops/f2_hu10727952567704643543.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/service-mesh-devsecops/devsecops/f2.png&#34; data-img=&#34;/book/service-mesh-devsecops/devsecops/f2.png&#34; data-width=&#34;1708&#34; data-height=&#34;704&#34; alt=&#34;image&#34; data-caption=&#34;图 2：持续交付和持续部署之间的区别&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 2：持续交付和持续部署之间的区别&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h3 id=&#34;332-cicd-管道的构建块&#34;&gt;3.3.2 CI/CD 管道的构建块&lt;/h3&gt;
&lt;p&gt;定义 CI/CD 管道资源、构建管道和执行这些管道的主要软件是 CI/CD 管道软件。这类软件的架构可能有轻微的变化，取决于特定的产品。以下是对 CI/CD 工具（管道软件）运行情况的概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些 CI/CD 工具在应用程序和相关资源托管的平台上自然运行（即容器编排和资源管理平台），而其他工具需要通过其 API 集成到应用程序托管平台。使用应用托管平台原生的 CI/CD 工具的一些优势是：
&lt;ul&gt;
&lt;li&gt;它使部署、维护和管理 CI/CD 工具本身更加容易。&lt;/li&gt;
&lt;li&gt;CI/CD 工具定义的每个管道都成为另一个平台原生资源，并以同样的方式管理。事实上，执行管道所需的所有实体，如任务和管道（然后分别作为其他实体的蓝图，如任务运行和管道运行），可以作为建立在平台原生资源之上的 &lt;a href=&#34;https://itnext.io/k8s-native-jenkins-x-and-tekton-pipelines-e2b5a61a1d22&#34; title=&#34;自定义资源定义&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义资源定义&lt;/a&gt;（CRD）来创建。具有这种架构的软件可以被其他 CI/CD 管道软件产品所使用，以促进管道的快速定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一些 CI/CD 工具与代码库集成，以扫描 / 检查应用程序代码。这些类型的工具与每个应用程序和每个环境的代码库有关联。当应用程序模块、基础设施或配置发生变化时，它们被存储在这些代码库中。通过 webhooks 或其他方式连接到代码库的 CI/CD 管道软件在提交时被激活（推送工作流模型）或通过来自这些存储库的拉取请求。&lt;/li&gt;
&lt;li&gt;一些 CI/CD 工具单独为本地平台执行 CD 功能（例如，Kubernetes 平台的 Jenkins X）或为多个技术栈执行 CD 功能（例如，多云部署的 Spinnaker）。这类工具的困难在于，它们可能缺乏完成 CI 功能的本地工具（例如，测试代码的工具，构建应用镜像，或将其推送到注册中心）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;333-准备和执行-cicd-管道&#34;&gt;3.3.3 准备和执行 CI/CD 管道&lt;/h3&gt;
&lt;p&gt;创建 CI/CD 管道的目的是为了实现源代码的频繁更新、重建，以及将更新的模块自动部署到生产环境中。&lt;/p&gt;
&lt;p&gt;涉及的 &lt;a href=&#34;https://aws.amazon.com/getting-started/hands-on/create-continuous-delivery-pipeline/?trk=gs_card&#34; title=&#34;关键任务&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关键任务&lt;/a&gt; 是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保 DevSecOps 平台中的所有单个组件（管道软件、SDLC 软件、代码库、可观测性工具等）都可用。&lt;/li&gt;
&lt;li&gt;通过认证、验证或定制测试，确保这些组件的安全。&lt;/li&gt;
&lt;li&gt;将 CI 和 CD 工具与 SDLC 工具整合起来 —— 访问令牌、调用脚本、管道定义。&lt;/li&gt;
&lt;li&gt;根据部署环境（即内部或云端的应用程序托管平台），在 IaC 工具（与 GitOps）中设置配置细节&lt;/li&gt;
&lt;li&gt;将运行时工具与部署环境相结合。&lt;/li&gt;
&lt;li&gt;设计仪表盘并定义要监控的事件、要生成的警报和要监控的应用程序状态变量（如内存利用率等），通过与日志聚合器、指标生成器和跟踪生成器等工具的连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行任务包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置源代码库。建立一个存储库（如 GitHub 或 GitLab），用于存储具有适当版本控制的应用程序源代码。&lt;/li&gt;
&lt;li&gt;构建过程。使用自动代码构建工具，配置并执行生成可执行文件的构建过程（对于那些需要更新的代码部分）。&lt;/li&gt;
&lt;li&gt;保证过程的安全。通过使用 SAST 和 DAST 工具进行单元测试，确保构建时没有静态和动态的漏洞。这和上面的任务是由 CI 工具激活的。&lt;/li&gt;
&lt;li&gt;描述部署环境。这可能涉及描述（使用 IaC）物理 / 虚拟资源，以便在云或企业数据中心部署应用程序。&lt;/li&gt;
&lt;li&gt;创建交付管道。创建一个将自动部署应用程序的管道。这个任务和前面的任务是由 CD 工具启用的。&lt;/li&gt;
&lt;li&gt;测试代码并执行管道。在适当的测试之后，只要有新的代码出现在资源库中，就执行 CI 工具。当构建过程成功后，执行 CD 工具，将应用程序部署到暂存 / 生产环境中。&lt;/li&gt;
&lt;li&gt;激活运行时工具和仪表板，启动运行时监控。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重申一下，CI/CD 流程的三个主要阶段是构建 / 测试、发布 / 打包和部署。以下功能将其转化为一个管道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当一个服务的源代码被更新时，推送到源代码库的代码变化会触发代码构建工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码开发环境或代码构建工具（如 IDE），通常与安全测试工具（如静态漏洞分析工具）集成，以促进安全编译代码工件的生成，从而将安全纳入 CI 管道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在代码构建工具中生成的编译代码工件会触发交付 / 打包工具，该工具可能与它自己的一套工具（例如，动态漏洞分析、动态渗透测试工具、用于识别所附库中的漏洞的软件组成分析工具）集成在一起，并且还创建与部署环境有关的配置参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后，发布 / 打包工具的输出被自动送入 CD 工具，该工具将软件包部署到 &lt;a href=&#34;https://aws.amazon.com/blogs/devops/setting-up-a-ci-cd-pipeline-by-integrating-jenkins-with-aws-codebuild-and-aws-codedeploy/&#34; title=&#34;所需的环境&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;所需的环境&lt;/a&gt; 中（例如，中转、生产）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CI/CD 管道的工作流程不应产生无人参与的印象。以下团队 / 角色对 CI/CD 管道做出 &lt;a href=&#34;https://medium.com/@mylocaldevstack/the-future-of-devops-assembly-lines-40227546d750&#34; title=&#34;贡献&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;贡献&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发团队：这个团队的成员为他们的应用程序申报第三方现成软件（OSS）的依赖性，审查 DevSecOps 系统围绕脆弱依赖性提出的建议，按照建议进行更新，并编写足够的测试案例以确保所有功能验证（消除运行时的错误）。&lt;/li&gt;
&lt;li&gt;首席信息安全官（CISO）：在与安全团队协商后，CISO 定义了 DevSecOps 系统的整体范围（深度和广度），从而可以适当地配置它，以满足应用程序的关键任务需求。&lt;/li&gt;
&lt;li&gt;安全团队：这个团队的成员按照最佳实践创建管道，包括执行所有必要的安全功能的任务（例如，SBOM 生成、漏洞扫描、代码构建、代码签名、引入新的测试工具、进行审计等）。具体来说，在某些情况下，安全团队的成员可能会负责设计、构建和维护策略即代码和相关管道。&lt;/li&gt;
&lt;li&gt;基础设施团队：这个团队的成员创建、维护和升级基础设施。&lt;/li&gt;
&lt;li&gt;QA 团队：这个团队的成员开发集成测试案例。&lt;/li&gt;
&lt;li&gt;部署团队 / 发布团队：这个团队的成员为各种环境（UAT/PreProd/Prod）创建管道和包，并为这些环境进行适当的配置和供应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些团队进行的许多活动中，有一些包括 CI/CD 管道中采用的工具的定制、更新和增强（例如，用最新的已知漏洞数据库更新静态漏洞分析工具）。在手工操作过程中，应谨慎行事，以免阻塞管道。在设定平均生产时间目标的同时，还应通过使用 &amp;ldquo;合并（GitLab）或拉取（GitHub）请求&amp;rdquo; 和这些请求的多个批准者来减少风险，如内部威胁。这个管道由发布后团队设计、维护和执行，该团队 —— 除了监控功能 —— 还执行 &lt;a href=&#34;https://faun.pub/best-terraform-tutorial-guides-an-overview-65a6fcee0a24&#34; title=&#34;其他流程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;其他流程&lt;/a&gt;，如合规管理、备份流程和资产跟踪。&lt;/p&gt;
&lt;h3 id=&#34;334-自动化的战略&#34;&gt;3.3.4 自动化的战略&lt;/h3&gt;
&lt;p&gt;与其他涉及从编码到发布的线性流程的软件开发模式相比，DevOps 使用了一个具有交付管道的前向过程（即构建 / 安全、交付 / 打包和发布）和一个具有反馈回路的反向过程（即计划和监控），形成一个递归的工作流程。自动化在这些活动中的作用是改善工作流程。持续集成强调测试自动化，以确保每当新的提交被集成到主分支时，应用程序不会被破坏。自动化带来了以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生有关软件静态和运行时流程的数据。&lt;/li&gt;
&lt;li&gt;减少开发和部署时间。&lt;/li&gt;
&lt;li&gt;架构的内置安全、隐私和合规性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是推荐的 &lt;a href=&#34;https://medium.com/searce/gitops-the-next-big-thing-for-devops-and-automation-2a9597e51559&#34; title=&#34;自动化策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自动化策略&lt;/a&gt;，以便于更好地利用组织资源，并在高效、安全的应用环境方面获得最大利益。&lt;/p&gt;
&lt;p&gt;选择要自动化的活动。例如，以下是测试活动自动化的有效候选项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试其功能需符合法规要求的模块（如 PCI-DSS、HIPAA、Sarbanes-Oxley）。&lt;/li&gt;
&lt;li&gt;具有中度至高度重复性的任务。&lt;/li&gt;
&lt;li&gt;测试执行时间序列操作的模块，如消息发布者和消息订阅者。&lt;/li&gt;
&lt;li&gt;测试涉及跨越多个服务的事务的工作流程（例如，请求跟踪）。&lt;/li&gt;
&lt;li&gt;测试那些资源密集型和可能成为性能瓶颈的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在根据上述标准选择自动化的候选者后，必须应用通常的风险分析来选择一个子集，以提供最佳的回报，并使理想的安全指标（如深度防御）最大化。一些推荐的策略包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用每年节省的小时数的成本效益比来确定哪些 &lt;a href=&#34;https://medium.com/searce/gitops-the-next-big-thing-for-devops-and-automation-2a9597e51559&#34; title=&#34;流程&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;流程&lt;/a&gt; 需要自动化的优先次序。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://searchitoperations.techtarget.com/feature/Understand-the-role-of-infrastructure-as-code-in-DevOps?utm_campaign=20210809_The&amp;#43;next&amp;#43;DevSecOps&amp;#43;challenge%3A&amp;#43;People&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;track=NL-1841&amp;amp;ad=939963&amp;amp;asrc=EM_NLN_174809933&#34; title=&#34;关键绩效指标（KPI）&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关键绩效指标（KPI）&lt;/a&gt;（例如，识别故障或问题、纠正或恢复的平均时间）作为标记来完善 DevSecOps 流程。&lt;/li&gt;
&lt;li&gt;根据应用，对基础设施服务应用不同的权重（例如，授权和其他策略的执行，监测系统状态以确保安全运行状态，在系统可用性、延迟、从中断中恢复的平均时间等方面的网络弹性），以确定对 DevSecOps 流程的资源分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;335-cicd-管道中对安全自动化工具的要求&#34;&gt;3.3.5 CI/CD 管道中对安全自动化工具的要求&lt;/h3&gt;
&lt;p&gt;在 CI/CD 管道中使用的各种功能（如静态漏洞分析、动态漏洞分析、软件构成分析）的安全自动化工具需要有不同的接口和警报 / 报告要求，因为它们必须根据使用管道阶段（如构建、打包、发布）而无缝运行。这些要求是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全自动化工具应与集成开发环境（IDE）工具一起工作，并帮助开发人员优先处理和补救静态漏洞。需要这些功能来促进开发人员的采用和提高生产力。&lt;/li&gt;
&lt;li&gt;安全自动化工具应该是灵活的，以支持特定的工作流程，并为安全服务提供扩展能力。&lt;/li&gt;
&lt;li&gt;在构建阶段进行静态漏洞检查的工具确保了数据流的安全，而那些进行动态漏洞检查的工具则确保了运行时应用程序状态的安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;必须提到的是，安全自动化工具是有成本的，因此，这些工具的使用程度是基于风险因素分析。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>简介</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes，经常被缩写为 &amp;ldquo;K8s&amp;rdquo;，是一个开源的容器或编排系统，用于自动部署、扩展和管理容器化应用程序。它管理着构成集群的所有元素，从应用中的每个微服务到整个集群。与单体软件平台相比，将容器化应用作为微服务使用可以提供更多的灵活性和安全优势，但也可能引入其他复杂因素。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f1_hu4412094343669439057.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f1.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/introduction/f1.jpg&#34; data-width=&#34;1721&#34; data-height=&#34;1080&#34; alt=&#34;image&#34; data-caption=&#34;图 1：Kubernetes 集群组件的高层视图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 1：Kubernetes 集群组件的高层视图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;本指南重点关注安全挑战，并尽可能提出适用于国家安全系统和关键基础设施管理员的加固策略。尽管本指南是针对国家安全系统和关键基础设施组织的，但也鼓励联邦和州、地方、部落和领土（SLTT）政府网络的管理员实施所提供的建议。Kubernetes 集群的安全问题可能很复杂，而且经常在利用其错误配置的潜在威胁中被滥用。以下指南提供了具体的安全配置，可以帮助建立更安全的 Kubernetes 集群。&lt;/p&gt;
&lt;h2 id=&#34;建议&#34;&gt;建议&lt;/h2&gt;
&lt;p&gt;每个部分的主要建议摘要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes Pod 安全
&lt;ul&gt;
&lt;li&gt;使用构建的容器，以非 root 用户身份运行应用程序&lt;/li&gt;
&lt;li&gt;在可能的情况下，用不可变的文件系统运行容器&lt;/li&gt;
&lt;li&gt;扫描容器镜像，以发现可能存在的漏洞或错误配置&lt;/li&gt;
&lt;li&gt;使用 Pod 安全政策来执行最低水平的安全，包括：
&lt;ul&gt;
&lt;li&gt;防止有特权的容器&lt;/li&gt;
&lt;li&gt;拒绝经常被利用来突破的容器功能，如 &lt;code&gt;hostPID&lt;/code&gt;、&lt;code&gt;hostIPC&lt;/code&gt;、&lt;code&gt;hostNetwork&lt;/code&gt;、&lt;code&gt;allowedHostPath&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;拒绝以 root 用户身份执行或允许提升为根用户的容器&lt;/li&gt;
&lt;li&gt;使用安全服务，如 SELinux®、AppArmor® 和 seccomp，加固应用程序，防止被利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络隔离和加固
&lt;ul&gt;
&lt;li&gt;使用防火墙和基于角色的访问控制（RBAC）锁定对控制平面节点的访问&lt;/li&gt;
&lt;li&gt;进一步限制对 Kubernetes etcd 服务器的访问&lt;/li&gt;
&lt;li&gt;配置控制平面组件，使用传输层安全（TLS）证书进行认证、加密通信&lt;/li&gt;
&lt;li&gt;设置网络策略来隔离资源。不同命名空间的 Pod 和服务仍然可以相互通信，除非执行额外的隔离，如网络策略&lt;/li&gt;
&lt;li&gt;将所有凭证和敏感信息放在 Kubernetes Secret 中，而不是配置文件中。使用强大的加密方法对 Secret 进行加密&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;认证和授权
&lt;ul&gt;
&lt;li&gt;禁用匿名登录（默认启用）&lt;/li&gt;
&lt;li&gt;使用强大的用户认证&lt;/li&gt;
&lt;li&gt;创建 RBAC 策略以限制管理员、用户和服务账户活动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志审计
&lt;ul&gt;
&lt;li&gt;启用审计记录（默认为禁用）&lt;/li&gt;
&lt;li&gt;在节点、Pod 或容器级故障的情况下，持续保存日志以确保可用性&lt;/li&gt;
&lt;li&gt;配置一个 metric logger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;升级和应用安全实践
&lt;ul&gt;
&lt;li&gt;立即应用安全补丁和更新&lt;/li&gt;
&lt;li&gt;定期进行漏洞扫描和渗透测试&lt;/li&gt;
&lt;li&gt;当组件不再需要时，将其从环境中移除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;架构概述&#34;&gt;架构概述&lt;/h2&gt;
&lt;p&gt;Kubernetes 使用集群架构。一个 Kubernetes 集群是由一些控制平面和一个或多个物理或虚拟机组成的，称为工作节点。工作者节点承载 Pod，其中包含一个或多个容器。容器是包含软件包及其所有依赖关系的可执行镜像。见图 2：Kubernetes 架构。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f2_hu9058503073069899201.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/kubernetes-hardening-guidance/introduction/f2.jpg&#34; data-img=&#34;/book/kubernetes-hardening-guidance/introduction/f2.jpg&#34; data-width=&#34;1752&#34; data-height=&#34;852&#34; alt=&#34;image&#34; data-caption=&#34;图 2：Kubernetes 架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 2：Kubernetes 架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;控制平面对集群进行决策。这包括调度容器的运行，检测 / 应对故障，并在部署文件中指定的副本数量没有得到满足时启动新的 Pod。以下逻辑组件都是控制平面的一部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controller manager（默认端口：10252）&lt;/strong&gt; - 监视 Kubernetes 集群，以检测和维护 Kubernetes 环境的几个方面，包括将 Pod 加入到服务中，保持一组 Pod 的正确数量，并对节点的丢失做出反应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud controller manager（默认端口：10258）&lt;/strong&gt; - 一个用于基于云的部署的可选组件。云控制器与云服务提供商接口，以管理集群的负载均衡器和虚拟网络。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes API Server（默认端口：6443 或 8080）&lt;/strong&gt; - 管理员操作 Kubernetes 的接口。因此，API 服务器通常暴露在控制平面之外。API 服务器被设计成可扩展的，可能存在于多个控制平面节点上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Etcd（默认端口范围：2379-2380）&lt;/strong&gt; - 持久化的备份存储，关于集群状态的所有信息都保存在这里。Etcd 不应该被直接操作，而应该通过 API 服务器来管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scheduler（默认端口：10251）&lt;/strong&gt; - 跟踪工作节点的状态并决定在哪里运行 Pod。Kube-scheduler 只可以由控制平面内的节点访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 工作节点是专门为集群运行容器化应用的物理或虚拟机。除了运行容器引擎外，工作节点还承载以下两个服务，允许从控制平面进行协调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kubelet（默认端口：10250）&lt;/strong&gt; - 在每个工作节点上运行，以协调和验证 Pod 的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kube-proxy&lt;/strong&gt; - 一个网络代理，使用主机的数据包过滤能力，确保 Kubernetes 集群中数据包的正确路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群通常使用云服务提供商（CSP）的 Kubernetes 服务或在企业内部托管。在设计 Kubernetes 环境时，组织应了解他们在安全维护集群方面的责任。CSP 管理大部分的 Kubernetes 服务，但组织可能需要处理某些方面，如认证和授权。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 信任域和 Bundle</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-trust-domain-and-bundle/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-trust-domain-and-bundle/</guid>
      <description>
        
        
        &lt;p&gt;SPIFFE 标准提供了一个规范，用于在异构环境和组织中引导和发放可互操作的服务身份。它定义了一个称为&amp;quot;信任域&amp;quot;的概念，用于划分管理和/或安全边界。信任域隔离发放机构并区分身份命名空间，但也可以松散耦合以提供联合身份。&lt;/p&gt;
&lt;p&gt;本文档描述了 SPIFFE 信任域的语义、表示方式以及它们如何耦合在一起的机制。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 信任域表示 SPIFFE ID 有资格的基础，指示任何给定 SPIFFE ID 已经发放的领域或发放机构。它们由发放机构支持，负责管理其相应信任域中的 SPIFFE 身份发放。尽管信任域的名称由一个简单的人类可读字符串组成，但还必须表达由信任域的发放机构使用的密码密钥，以使其他人能够验证其发放的身份。这些密钥被表示为&amp;quot;SPIFFE Bundle&amp;quot;，与其所代表的信任域紧密相连。&lt;/p&gt;
&lt;p&gt;本规范定义了 SPIFFE 信任域和 SPIFFE Bundle 的性质和语义。&lt;/p&gt;
&lt;h2 id=&#34;信任域&#34;&gt;信任域&lt;/h2&gt;
&lt;p&gt;SPIFFE 信任域是由一组密码密钥支持的身份命名空间。这些密钥共同为驻留在信任域中的所有身份提供了密码锚点。&lt;/p&gt;
&lt;p&gt;信任域与支持它们的密钥之间存在一对多的关系。一个信任域可以由多个密钥和密钥类型来表示。例如，前者可以在根密钥轮换期间使用，而后者在使用多个 SVID 类型时避免多协议攻击是必要的。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然可以在多个信任域之间共享密码密钥，但我们强烈建议每个授权密钥仅在一个信任域中使用。密钥的重复使用可能会降低信任域的隔离性（例如，在演练和生产之间），并引入额外的安全挑战（例如，需要为辅助发放机构实施名称约束系统）。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-spiffe-bundle&#34;&gt;SPIFFE Bundle (SPIFFE Bundle)&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 是包含信任域的密码密钥的对象。Bundle 中的密钥被视为代表 Bundle 所代表的信任域的权威，并用于证明驻留在该信任域中的 SVIDs 的有效性。&lt;/p&gt;
&lt;p&gt;SPIFFE Bundle 设计用于在 SPIFFE 控制平面实现内部和之间使用。然而，此规范不排除直接由工作负载消费的使用。&lt;/p&gt;
&lt;p&gt;在存储或管理 SPIFFE Bundle 时，独立记录 Bundle 所代表的信任域的名称至关重要，通常通过使用&lt;code&gt;&amp;lt;trust_domain_name, bundle&amp;gt;&lt;/code&gt;元组来实现。在验证 SVID 时，验证器必须选择与 SVID 所在的信任域对应的 Bundle，因此在大多数情况下需要维护此关系。&lt;/p&gt;
&lt;p&gt;请注意，信任域 Bundle 的内容预计会随时间变化，因为它所包含的密钥进行轮换。通过发放包含新密钥的新 Bundle 并省略已撤销的密钥来添加和撤销密钥。SPIFFE 实现负责根据需要将 Bundle 内容更新分发给工作负载。确切的格式和通过哪种方法传递这些更新超出了本规范的范围。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-格式&#34;&gt;SPIFFE Bundle 格式&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 被表示为 RFC 7517 兼容的 JWK 集合。选择 JWK 的原因有两个主要原因。首先，它提供了一种灵活的格式，用于表示各种类型的密码密钥（和 X.509 等文档），从而在定义新的 SVID 格式时提供了一定程度的未来证明。其次，它得到了广泛支持和部署，主要用于域间联合，这是 SPIFFE 项目的核心目标。&lt;/p&gt;
&lt;h3 id=&#34;jwk-集合&#34;&gt;JWK 集合&lt;/h3&gt;
&lt;p&gt;本节定义了 JWK 集合的参数。未在此处定义的参数可以根据实现者的需要包含，但是 SPIFFE 实现&lt;strong&gt;不能&lt;/strong&gt;要求它们的存在以使其正常工作。&lt;/p&gt;
&lt;h3 id=&#34;序列号&#34;&gt;序列号&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;spiffe_sequence&lt;/code&gt;&lt;strong&gt;应该&lt;/strong&gt;被设置。该序列号可以被 SPIFFE 控制平面用于许多目的，包括传播测量和更新顺序/替代。当存在时，其值&lt;strong&gt;必须&lt;/strong&gt;为单调递增的整数，并且当 bundle 的内容被更新时必须更改。&lt;/p&gt;
&lt;p&gt;值得注意的是，尽管 JSON 整数类型是可变宽度且没有定义最大限制，但许多实现可能将其解析为固定宽度类型。为了防止溢出，应该确保生成的类型至少具有 64 位的精度。&lt;/p&gt;
&lt;h3 id=&#34;刷新提示&#34;&gt;刷新提示&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;&lt;strong&gt;应该&lt;/strong&gt;被设置。刷新提示指示消费者应该多久检查更新。Bundle 发布者可以将刷新提示作为其密钥轮换频率的函数进行广告。值得注意的是，刷新提示还可能影响密钥撤销的传播速度。如果设置了刷新提示，其值&lt;strong&gt;必须&lt;/strong&gt;是表示建议的消费者刷新间隔的整数，以秒为单位。正如名称所示，刷新间隔只是一个提示，根据实现的不同，消费者可以更频繁或更不频繁地检查更新。&lt;/p&gt;
&lt;h3 id=&#34;密钥&#34;&gt;密钥&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;keys&lt;/code&gt;&lt;strong&gt;必须&lt;/strong&gt;存在。其值是一个 JWK 数组。遇到未知的密钥类型或用途的客户端&lt;strong&gt;必须&lt;/strong&gt;忽略相应的 JWK 元素。请参阅 RFC 7517 的第 5 节以了解有关&lt;code&gt;keys&lt;/code&gt;参数语义的更多信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keys&lt;/code&gt;参数可以包含一个空数组。发布空密钥数组的信任域表示该信任域已撤销先前发布的任何密钥。工作负载还可能遇到经处理后不产生可用密钥（即没有 JWK 通过下面描述的验证）的 bundle，并且实际上为空。这可能表明信任域已迁移到客户端不理解的新密钥类型或用途。在这两种情况下，工作负载&lt;strong&gt;必须&lt;/strong&gt;将来自信任域的所有 SVID 视为无效和不可信。&lt;/p&gt;
&lt;h3 id=&#34;jwk&#34;&gt;JWK&lt;/h3&gt;
&lt;p&gt;本节定义了作为 JWK 集合一部分包含的 JWK 元素的高级要求。JWK 元素表示单个密码密钥，用于对单个类型的 SVID 进行身份验证。虽然安全使用 JWK 的确切要求因 SVID 类型而异，但在本节中我们概述了一些顶级要求。SVID 规范必须为&lt;code&gt;use&lt;/code&gt;参数（参见下面的&lt;code&gt;Public Key Use&lt;/code&gt;节）定义适当的值，并且可以根据需要对其 JWK 元素设置进一步的要求或限制。&lt;/p&gt;
&lt;p&gt;实现者&lt;strong&gt;不应&lt;/strong&gt;包含在此处或相应的 SVID 规范中未定义的参数。&lt;/p&gt;
&lt;h3 id=&#34;密钥类型&#34;&gt;密钥类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kty&lt;/code&gt; 参数必须设置，并且其行为遵循 RFC 7517 的 Section 4.1。遇到未知密钥类型的客户端必须忽略整个 JWK 元素。&lt;/p&gt;
&lt;h3 id=&#34;公钥用途&#34;&gt;公钥用途&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt; 参数必须设置。其值表示其具有权威性的身份文档（或 SVID）的类型。截至本文撰写时，仅支持两种 SVID 类型：&lt;code&gt;x509-svid&lt;/code&gt; 和 &lt;code&gt;jwt-svid&lt;/code&gt;。值区分大小写。有关 &lt;code&gt;use&lt;/code&gt; 值的更多信息，请参见相应的 SVID 规范。遇到缺少 &lt;code&gt;use&lt;/code&gt; 参数或未知 &lt;code&gt;use&lt;/code&gt; 值的客户端必须忽略整个 JWK 元素。&lt;/p&gt;
&lt;h2 id=&#34;安全注意事项&#34;&gt;安全注意事项&lt;/h2&gt;
&lt;p&gt;本节概述了在实施和部署 SPIFFE 控制平面时应考虑的与安全相关的注意事项。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-bundle-刷新提示&#34;&gt;SPIFFE Bundle 刷新提示&lt;/h3&gt;
&lt;p&gt;SPIFFE Bundle 包括一个可选的 &lt;code&gt;refresh_hint&lt;/code&gt; 字段，用于指示消费者应尝试刷新其 Bundle 副本的频率。这个值对密钥的轮换速度有明显的影响，但它也影响了密钥的撤销速度。应该仔细选择刷新提示值。&lt;/p&gt;
&lt;p&gt;由于此字段不是必需的，因此可能会遇到没有设置 &lt;code&gt;refresh_hint&lt;/code&gt; 的 SPIFFE Bundle。在这种情况下，客户端可以通过检查 SVID 有效期来使用合适的间隔。应该认识到，省略 &lt;code&gt;refresh_hint&lt;/code&gt; 可能会影响信任域迅速撤销已被损坏密钥的能力。客户端应该默认使用相对较低（例如五分钟）的刷新间隔，以便及时获取更新的信任 Bundle。&lt;/p&gt;
&lt;h3 id=&#34;在信任域之间重用加密密钥&#34;&gt;在信任域之间重用加密密钥&lt;/h3&gt;
&lt;p&gt;本规范不鼓励在信任域之间共享加密密钥，因为这种做法会降低信任域的隔离性并引入额外的安全挑战。当一个根密钥在多个信任域之间共享时，认证和授权实现必须仔细检查标识的信任域名组件，并且信任域名组件在授权策略中必须易于表达和习惯性地表达。&lt;/p&gt;
&lt;p&gt;假设一个天真的实现导入（即完全信任）一个特定的根密钥，并且认证系统被配置为认证链到受信任根密钥的任何 SVID 的 SPIFFE 身份。如果天真的实现未配置为仅信任特定的信任域，则任何信任域中发行的标识都可以被认证（只要 SVID 链接到受信任的根密钥）。&lt;/p&gt;
&lt;p&gt;继续上述例子，其中天真的实现导入了特定的 CA 证书，假设认证未区分信任域并且接受链到受信任根密钥的任何 SVID。然后，授权系统将只授权特定的信任域。换句话说，授权策略需要明确配置以检查 SVID 的信任域名组件。这里的安全关注点是天真的授权实现可能盲目地相信认证系统已过滤掉不受信任的信任域。&lt;/p&gt;
&lt;p&gt;总之，安全性的最佳实践是在信任域和根密钥之间维持一对一的映射，以减少细微（但灾难性的）认证和授权实现错误。重新使用跨信任域的根密钥的系统应确保（a）SVID 发行系统（例如 CA）在发行 SVID 前正确实现授权检查，并且（b）依赖方（即使用 SVID 的系统）正确实现强大的认证和授权系统，能够区分多个信任域。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-spiffe-bundle-示例&#34;&gt;附录 A. SPIFFE Bundle 示例&lt;/h2&gt;
&lt;p&gt;在下面的示例中，我们为名为&lt;code&gt;example.com&lt;/code&gt;的信任域配置了初始的 SPIFFE Bundle，并演示了在根密钥轮换期间如何更新 Bundle。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt;信任域的初始 X.509 CA 证书：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Certificate #1:
     Data:
         Version: 3 (0x2)
         Serial Number:
             df:d0:ad:fd:32:9f:b8:15:76:f5:d4:b9:e3:be:b5:a7
     Signature Algorithm: sha256WithRSAEncryption
         Issuer: O = example.com
         Validity
             Not Before: Jan  1 08:00:45 2019 GMT
             Not After : Apr  1 08:00:45 2019 GMT
         Subject: O = example.com
         X509v3 extensions:
             X509v3 Key Usage: critical
                 Certificate Sign
             X509v3 Basic Constraints: critical
                 CA:TRUE
             X509v3 Subject Alternative Name:
                 URI:spiffe://example.com/
 [...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意以下事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证书是自签名的（颁发者和主题相同）；&lt;/li&gt;
&lt;li&gt;证书的 CA 标志设置为 true；&lt;/li&gt;
&lt;li&gt;证书是 SVID（具有 spiffe URI SAN）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt;的相应信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Trust bundle #1 for example.com:
 {
         &amp;#34;spiffe_sequence&amp;#34;: 1,
         &amp;#34;spiffe_refresh_hint&amp;#34;: 2419200,
         &amp;#34;keys&amp;#34;: [
                 {
                         &amp;#34;kty&amp;#34;: &amp;#34;RSA&amp;#34;,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #1&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 }
         ]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述信任 Bundle 是第 1 个版本，如&lt;code&gt;spiffe_sequence&lt;/code&gt;字段所示，并且指示客户端应该每 2419200 秒（或 28 天）轮询更新 Bundle。请注意，&lt;code&gt;x5c&lt;/code&gt;参数包含了基于 RFC7517 Section 4.7 中所指定的 base64 编码的 DER 证书。密钥特定值（例如&lt;code&gt;n&lt;/code&gt;和&lt;code&gt;e&lt;/code&gt;）的编码方法在 RFC7518 Section 6 中有描述。&lt;/p&gt;
&lt;p&gt;为了准备&lt;code&gt;example.com&lt;/code&gt;的 CA 证书的过期，生成了一个替换证书，并将其添加到信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Certificate #2:
     Data:
         Version: 3 (0x2)
         Serial Number:
             a4:dc:5f:05:8a:a2:bf:88:9d:a4:fa:1e:9a:a5:db:74
     Signature Algorithm: sha256WithRSAEncryption
         Issuer: O = example.com
         Validity
             Not Before: Feb  15 08:00:45 2019 GMT
             Not After : Jul  1 08:00:45 2019 GMT
         Subject: O = example.com
         X509v3 extensions:
             X509v3 Key Usage: critical
                 Certificate Sign
             X509v3 Basic Constraints: critical
                 CA:TRUE
             X509v3 Subject Alternative Name:
                 URI:spiffe://example.com/
 [...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 2 月 15 日发布的&lt;code&gt;example.com&lt;/code&gt;的更新后的信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Trust bundle #2 for example.com:
 {
         &amp;#34;spiffe_sequence&amp;#34;: 2,
         &amp;#34;spiffe_refresh_hint&amp;#34;: 2419200,
         &amp;#34;keys&amp;#34;: [
                 {
                         &amp;#34;kty&amp;#34;: “RSA”,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #1&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 },
                 {
                         &amp;#34;kty&amp;#34;: “RSA”,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #2&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 }
         ]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Bundle #2 中，请注意&lt;code&gt;spiffe_sequence&lt;/code&gt;参数已经增加，并添加了&lt;code&gt;example.com&lt;/code&gt;的第二个根证书。一旦发布并分发了这个新的信任 Bundle，验证器将接受由原始根证书或替换根证书签名的 SVID。通过提前发布替换证书，有效器有充分的机会刷新&lt;code&gt;example.com&lt;/code&gt;的信任 Bundle 并了解即将到期的替换证书。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIRE 集成示例</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/examples/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/examples/</guid>
      <description>
        
        
        

  &lt;ul&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy/&#34;&gt;Envoy&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-x509/&#34;&gt;Envoy &amp;#43; X.509&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt/&#34;&gt;Envoy &amp;#43; JWT-SVID&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-opa/&#34;&gt;使用 Envoy 和 X.509-SVID 进行 OPA 授权&lt;/a&gt;
        
      &lt;/li&gt;
    
      &lt;li&gt;
        &lt;a href=&#34;https://jimmysong.io/book/spiffe-and-spire/examples/envoy-jwt-opa/&#34;&gt;使用 Envoy 和 JWT-SVIDs 进行 OPA 授权&lt;/a&gt;
        
      &lt;/li&gt;
    
  &lt;/ul&gt;



      </description>
    </item>
                           
    <item>
      <title>开始前的准备</title>
      <link>https://jimmysong.io/book/spiffe/before-you-start/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/before-you-start/</guid>
      <description>
        
        
        &lt;p&gt;本章旨在让你为上线 SPIFFE/SPIRE 时需要做出的许多决定做好准备。&lt;/p&gt;
&lt;h2 id=&#34;准备人力&#34;&gt;准备人力&lt;/h2&gt;
&lt;p&gt;如果你读了前面的章节，你一定很想开始使用 SPIRE，以一种可以在许多不同类型的系统和所有组织的服务中利用的方式管理身份。然而，在你开始之前，你需要考虑，部署 SPIRE 是&lt;strong&gt;一个重大的基础设施变化&lt;/strong&gt;，有可能影响到许多不同的系统。本章是关于如何开始规划 SPIRE 的部署：获得认同，以不中断的方式启用 SPIRE 支持，然后利用它来实施新的安全控制。&lt;/p&gt;
&lt;h3 id=&#34;组建团队并确定其他利益相关者&#34;&gt;组建团队并确定其他利益相关者&lt;/h3&gt;
&lt;p&gt;要部署 SPIRE，你需要确定来自安全、软件开发和 DevOps 团队的利益相关者。谁来维护 SPIRE 服务器本身？谁来部署代理？谁来编写注册条目？谁将把 SPIFFE 功能集成到应用程序中？它将如何影响现有的 CI/CD 管道？如果发生了服务中断，谁来修复它？性能要求和服务水平目标是什么？&lt;/p&gt;
&lt;p&gt;在这本书中，以及许多公开的博客文章和会议演讲中，都有一些成功部署 SPIRE 的组织的例子，既可以作为一种模式，也可以作为向同事宣传 SPIRE 的有用材料。&lt;/p&gt;
&lt;h3 id=&#34;说明你的情况并获得支持&#34;&gt;说明你的情况并获得支持&lt;/h3&gt;
&lt;p&gt;SPIRE 跨越了几个不同的传统信息技术孤岛，因此，期望看到你的 DevOps 团队、软件开发团队和安全团队之间有更多的跨组织合作。重要的是，他们要一起工作，以确保成功和无缝部署。考虑到这些团队中的每一个都有不同的需求和优先事项，需要解决这些问题以获得他们的支持。&lt;/p&gt;
&lt;p&gt;在规划 SPIRE 部署时，你需要了解哪些成果对你的企业最重要，并将这些成果作为项目的驱动力和你将提供的解决方案的价值。每个团队都需要看到 SPIRE 对自己以及对整个企业的好处。本书第 2 章 &amp;ldquo;收益&amp;rdquo; 中描述了 SPIRE 部署的许多好处，在本节中，我们将把其中一些好处提炼成令人信服的论据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对安全团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减少安全团队的工作量是部署 SPIRE 的一个非常有说服力的案例：他们可以专注于设计正确的注册条目，以确保每个服务获得正确的身份，而不是部署临时的安全解决方案，以及手动管理数百或数千个证书。&lt;/p&gt;
&lt;p&gt;一个更长期的好处是，SPIRE 可以提高组织的整体安全态势，因为 SPIRE 没有容易被盗或误用的凭证。与盗用或歪曲凭证有关的大量攻击，以及敏感数据的暴露，都得到了缓解。有可能向外部审计师证明，正确的服务正在相互安全地进行通信，没有意外疏忽的可能。即使外部人员可以破坏一个服务，他们对其他服务发起攻击的能力也是有限的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对软件开发团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于应用程序开发团队来说，他们能够通过不等待工单或手动工作流程来提供证书而加快行动，这是最有说服力的案例。如果他们目前在代码旁边手动部署秘密，并被安全团队谈话，他们不再需要忍受这些。他们也不需要在秘密存储中管理秘密。&lt;/p&gt;
&lt;p&gt;一个次要的好处是，软件组件可能能够以它们以前无法安全进行的方式直接进行通信。如果云服务不能访问一个关键的数据库或基本的云服务，因为没有办法安全地做到这一点，那么就有可能使用 SPIFFE 身份来创建一个安全连接，为你的团队提供新的架构潜力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对 DevOps 团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署 SPIRE 的最大收益是针对 DevOps 团队。如果每个服务都有自己的安全身份，那么服务就可以部署在任何地方 —— 在任何内部数据中心、云供应商或一个云供应商中的区域。这种新的灵活性允许降低成本，提高可扩展性，并改善可靠性，因为部署决策可以独立于安全要求。&lt;/p&gt;
&lt;p&gt;对 DevOps 团队来说，另一个关键的好处是，每个服务的传入请求都被贴上 SPIFFE ID 的标签，这可以被记录、测量，并报告给监控系统。这对拥有数百或数千项服务的大型组织的性能管理是非常有帮助的。&lt;/p&gt;
&lt;h2 id=&#34;创建一个计划&#34;&gt;创建一个计划&lt;/h2&gt;
&lt;p&gt;规划 SPIRE 部署的第一个目标是确定是否每项服务都需要被 SPIFFE 感知，或者非 SPIFFE 服务的 &amp;ldquo;孤岛&amp;rdquo; 是否仍然可以满足要求。将每项服务都转移到 SPIFFE 是最直接的选择，但要一下子全部实施可能是个挑战，特别是在非常大的组织中。&lt;/p&gt;
&lt;h3 id=&#34;岛屿和桥梁的规划&#34;&gt;岛屿和桥梁的规划&lt;/h3&gt;
&lt;p&gt;有些环境很复杂，要么有多个组织，要么是传统和新开发的结合。在这种情况下，人们往往希望只让环境的一个子集启用 SPIFFE。需要考虑两种选择，这取决于系统之间的整合程度和它们之间的复杂性。让我们来看看这两种架构，我们称之为 &amp;ldquo;独立岛&amp;rdquo; 和“桥接岛”。&lt;/p&gt;
&lt;p&gt;每个岛被认为是它自己的信任域，在每个岛上有工作负载或“居民”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立岛&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-1_hu12364308003443049211.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-1.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-1.jpg&#34; data-width=&#34;912&#34; data-height=&#34;654&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;独立岛模式允许各个信任域相互独立运行。这通常是最简单的选择，因为每个岛可以以对该岛有意义的方式运行 SPIRE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接岛&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-2_hu11328748348261200009.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-2.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-2.jpg&#34; data-width=&#34;966&#34; data-height=&#34;672&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-3_hu9581986812159793039.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-3.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-3.jpg&#34; data-width=&#34;938&#34; data-height=&#34;652&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;桥接岛模式允许非 SPIFFE 岛上的非 SPIFFE 服务与网关对话。然后，网关将请求转发给支持 SPIFFE 的岛上的居民，我们称他们为 Zero。从 Zero 的角度来看，网关发出了请求。Zero 和他在支持 SPIFFE 的岛上的朋友可以向网关进行认证，并向非 SPIFFE 岛上的服务发送消息。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-4_hu12505063197063349275.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-4.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-4.jpg&#34; data-width=&#34;856&#34; data-height=&#34;634&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-5_hu14639859348411161260.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-5.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-5.jpg&#34; data-width=&#34;1142&#34; data-height=&#34;624&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;在桥接岛架构下，网关是在未启用 SPIFFE 的岛上创建的。这些非 SPIFFE 岛可能不容易采用 SPIFFE 架构，原因有很多：可能有遗留软件，不能轻易修改或更新；岛屿可能使用自己的识别生态系统，如 Kerberos 或 SPIFFE 与其他技术比较一章中描述的其他选项之一；或者系统可能在不太适合现有 SPIFFE 解决方案（如 SPIRE）模式的技术上运行工作负载。&lt;/p&gt;
&lt;p&gt;在这些情况下，使用&lt;strong&gt;网关&lt;/strong&gt;服务在 SPIFFE 世界和非 SPIFFE 岛之间架起连接的桥梁可能是有用的。当支持 SPIFFE 的工作负载想要与非 SPIFFE 岛的工作负载对话时，它与网关建立一个经过认证的连接，然后与目标工作负载建立一个连接。这个与目标工作负载的连接可能是未经认证的，或者使用该岛的非 SPIFFE 身份解决方案。同样，当非 SPIFFE 岛的工作负载想要连接到 SPIFFE 启用的工作负载时，非 SPIFFE 工作负载会连接到网关，然后创建一个 SPIFFE 认证的连接到目标 SPIFFE 启用的工作负载。&lt;/p&gt;
&lt;p&gt;在这种情况下，发生在网关和启用 SPIFFE 的工作负载之间的认证在网关处被&lt;strong&gt;终止&lt;/strong&gt;。这意味着支持 SPIFFE 的工作负载可以验证它是在与适当的网关对话，但不能验证它是在与网关另一端的正确工作负载对话。同样，目标工作负载只知道网关服务向它发送了一个请求，但却失去了原 SPIFFE 启用的工作负载的验证背景。这种模式允许这些复杂的组织开始采用 SPIFFE，而不必一下子转换。&lt;/p&gt;
&lt;p&gt;在请求和工作流通过非 SPIFFE 岛的情况下，利用 JWT-SVID 进行跨请求的传播会很有用。你可以使用 X509-SVID 来签署文件（如 HTTP 消息请求签署），而不是只使用服务间的相互认证的 TLS，这样整个消息的真实性就可以被另一边支持 SPIFFE 的工作负载所验证。这对已知安全属性较弱的岛屿特别有用，因为它提供了对通过中间生态系统的消息没有被操纵的信心。&lt;/p&gt;
&lt;h3 id=&#34;文档和监控工具&#34;&gt;文档和监控工具&lt;/h3&gt;
&lt;p&gt;在准备开始上线时，重要的是要对服务进行检测，使指标和流量日志以一种方式暴露出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监督上线的人知道哪些（以及有多少）服务是支持 SPIFFE 的，哪些（以及有多少）不是。&lt;/li&gt;
&lt;li&gt;客户端作者知道他们调用的哪些服务是支持 SPIFFE 的，哪些不是。&lt;/li&gt;
&lt;li&gt;服务所有者知道他们的哪些客户端以及有多少客户端在调用支持 SPIFFE 的端点，哪些在调用传统端点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是，要为客户端和服务器实施者创建参考文件，预测你将收到的支持请求的种类，从而为上线做准备。&lt;/p&gt;
&lt;p&gt;同样重要的是，创建工具来协助完成常见的调试和故障排除任务。回顾 SPIFFE 和 SPIRE 的收益，将 SPIFFE 引入你的组织应该赋予开发人员权力并消除路障。给利益相关者留下的印象是你在增加工作或制造摩擦，最终会减缓或停止更广泛的采用。为了减少这种情况，并确保文档和工具涵盖适当的主题，我们建议采取以下准备步骤。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;步骤&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;决定你将需要 SPIFFE 的哪些安全功能。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;SPIFFE 身份可用于创建相互的 TLS 连接，用于授权，或其他功能，如审计日志。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;确定使用什么格式的 SVID，用于什么目的。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;最常见的是将 X509-SVID 用于相互 TLS，但要确定这是否适用以及 SVID 是否将用于任何其他应用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;确定需要身份认证的工作负载的数量。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;不是每个工作负载都需要身份，特别是在早期。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;确定需要的独立信任域的数量。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;每个信任域都需要部署自己的 SPIRE 服务器。做出这一决定的细节在下一章。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;确定你的组织正在使用的语言、框架、IPC 技术等需要与 SPIFFE 兼容。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;如果使用 X.509-SVID 进行相互 TLS，请确定你的组织中使用了哪些 Web 服务器（Apache HTTPD、NGINX、Tomcat、Jetty 等）以及使用了哪些客户端库。如果客户端库期望执行 DNS 主机名验证，请确保你的 SPIFFE 部署与这种期望兼容。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;了解性能影响&#34;&gt;了解性能影响&lt;/h3&gt;
&lt;p&gt;应将性能影响作为部署规划的一部分加以考虑。&lt;/p&gt;
&lt;p&gt;作为上线准备的一部分，你应该检查一系列工作负载的基准，这些工作负载代表了你的组织在生产中运行的各种应用。这可以确保你至少意识到，并希望能准备好解决在推广过程中可能出现的任何性能问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在许多组织中，开发人员和运维团队提出的第一个担忧是，在服务之间建立相互的 TLS 连接会太慢。在现代硬件上，通过现代的 TLS 实现，TLS 的性能影响是最小的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;在我们的生产前端机器上，SSL/TLS 占 CPU 负载的比例不到 1%，每个连接占内存的比例不到 10KB，网络开销不到 2%。许多人认为，SSL/TLS 需要大量的 CPU 时间，我们希望前面的数字能帮助消除这种想法。&amp;quot;——Adam Langley， Google，&lt;a href=&#34;https://www.imperialviolet.org/2010/06/25/overclocking-ssl.html&#34; title=&#34;Overlocking SSL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Overlocking SSL&lt;/a&gt;，2010 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“我们已经使用硬件和软件负载均衡器大规模地部署了 TLS。我们发现，在商用 CPU 上运行的基于软件的现代 TLS 实现，其速度足以处理繁重的 HTTPS 追踪负载，而不需要求助于专用加密硬件。&amp;quot;——Doug Beaver，Facebook，&lt;a href=&#34;https://lists.w3.org/Archives/Public/ietf-http-wg/2012JulSep/0251.html&#34; title=&#34;HTTP2 Expression of Interest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP2 Expression of Interest&lt;/a&gt;，2012 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说，性能影响取决于多种因素，包括网络拓扑结构、API 网关、L4-L7 防火墙和其他许多因素。此外，你所使用的协议及其实现以及证书和密钥大小也可能影响性能，所以这是一个相当广泛的话题。&lt;/p&gt;
&lt;p&gt;下表提供了与 TCP 相比两个不同阶段的开销数据，特别是握手和数据传输阶段的数据。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;TLS 阶段&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;协议开销&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;延迟&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;CPU&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;内存&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;握手&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;TLS 为 2 kB mTLS 为 3 kB +1 kB/add&amp;rsquo;l Cert&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;12 - 17 ms&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比 TCP 多出约 0.5%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&amp;lt;10kb / 连接&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;数据传输&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;22B/packet&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&amp;lt;3 us&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;比 TCP 多不到 1%&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&amp;lt;10 kB / 连接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;向-spiffe-和-spire-转变&#34;&gt;向 SPIFFE 和 SPIRE 转变&lt;/h2&gt;
&lt;p&gt;关于组织如何对变化作出反应、影响和处理的研究有着丰富的历史。关于公众和组织对新技术的接受和采用，也有许多有趣的研究。对这些主题进行真正的公正研究超出了本书的范围，但如果我们不提及这些主题，那就是我们的失职，因为它们与 SPIFFE 的成功推广相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;令人信服的变化发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有几种方法可以说服他人，在你的组织内必须发生变化。下面的清单概述了你可以通过 SPIFFE 和 SPIRE 追求这种变革的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提升感知价值&lt;/strong&gt;：展示 SPIFFE 对工作绩效的积极影响是关键，让人们相信它对他们有实质帮助。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化易用性&lt;/strong&gt;：为了让 SPIFFE 易于使用，必须投入大量精力来提升开发者和运维人员的用户体验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同行影响力&lt;/strong&gt;：重视受尊敬人士对于 SPIFFE 的看法以及他们是否采用它，这将在组织内积累政治资本。说服关键人物通常比说服所有人更为重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升形象&lt;/strong&gt;：采用 SPIFFE 将对个人在组织中的地位产生显著影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自愿采用&lt;/strong&gt;：SPIFFE 潜在用户的自愿采用程度受公司文化和个性影响。在面对“被迫”采用者和拒绝采用者时，请务必牢记这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-6_hu18079566533230284815.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-6.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-6.jpg&#34; data-width=&#34;1316&#34; data-height=&#34;752&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;采用者角色&#34;&gt;采用者角色&lt;/h3&gt;
&lt;p&gt;采用者与技术曲线相对应，可以帮助设定对如何向 SPIFFE 和 SPIRE 转变的预期。在此，我们列出了技术曲线中所涉及的采用者，并增加了两个你可能会遇到的采用者。&lt;/p&gt;
&lt;p&gt;关于技术采用曲线中的采用者的更多信息可以在本书之外找到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创新者&lt;/strong&gt;：把你自己看作是组织中的创新者，因为你采取了这些步骤来阅读本书，走到这一步，并决定继续前进。你基本上是在开拓将 SPIFFE 和 SPIRE 添加到你的架构中的进程，你需要帮助！你需要一个 &amp;quot; 白手套“级别的支持和和帮助，所以一定要从低垂的果实和先导类别（下文有介绍）中挑选志愿者，并与他们保持良好的关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;早期采用者&lt;/strong&gt;：重要的是要从给予创新者的“白手套 &amp;ldquo;手把手支持水平中吸取经验教训，并将这些经验提炼成易于获取和理解的文档、有用的工具和可扩展的支持渠道。可能需要做大量的工作来实现 SPIFFE 的&amp;rdquo; 先驱者和推动者”（在本章后面会详细介绍），以便开发者能够解除障碍，然后能够实现 SPIFFE 的服务和客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;早期和晚期大众&lt;/strong&gt;：当你进入早期多数服务的时候，SPIFFE 的启用过程已经是一台运转良好的机器了。所有常用的使能器，如 CI/CD、工作流引擎、编排器、容器平台和服务网格，都应该启用 SPIFFE，以确保应用开发者在整个应用生命周期中得到支持，无论应用如何运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;落后者&lt;/strong&gt;：由于团队文化、个人性格以及监管或合规要求，你的组织可能有保守的落后者。重要的是，不要对服务所有者为什么会落入这个类别下结论，而是要调查根本原因并适当解决。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;被迫&amp;rdquo; 转型&lt;/strong&gt;：最后一个采用 SPIFFE 的服务的客户可能会感到被迫转型。重要的是要为被迫转型者做好准备，确保他们采用 SPIFFE 的经验是积极的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滞留者&lt;/strong&gt;：他们会出现，所以要让他们容易接受并受到激励。突出其他人目前正在享受生产力平台的例子。你应该期望提供额外的支持和帮助，因为在这个过程中会有很多人犹豫不决。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;时机选择的考虑因素&#34;&gt;时机选择的考虑因素&lt;/h3&gt;
&lt;p&gt;在你选择谁来做的时候，在你的组织中保持最大的兼容性是至关重要的考虑。服务应保持其现有的 API 接口和端口，并在新的端口上引入其启用 SPIFFE 的 API。这样可以实现平稳过渡，并在需要时方便回滚。有许多来自其他服务团队客户端的服务团队应该期望在很长一段时间内（&amp;gt;6 个月）维护和支持这两个端点。&lt;/p&gt;
&lt;p&gt;一旦一项服务的所有客户端都启用了 SPIFFE，并且不再使用非 SPIFFE 的 API，那么非 SPIFFE 的 API 就可以被关闭。&lt;/p&gt;
&lt;p&gt;要注意不要过早地关闭遗留的端点。要特别注意批处理作业、计划任务和其他类型的不经常或不规则的调用模式。你不希望成为导致季度末或财务年度末对账工作失败的人。&lt;/p&gt;
&lt;p&gt;如果你的环境太大或者太复杂，无法一下子完成，那么在选择服务启用 SPIFFE 的顺序时，一定要深思熟虑。从大石头、最低的果实和 &amp;quot; 先驱者和推动者“的角度来考虑可能会有帮助，以加速采用。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-7_hu12736003419319154615.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/before-you-start/f5-7.jpg&#34; data-img=&#34;/book/spiffe/before-you-start/f5-7.jpg&#34; data-width=&#34;1192&#34; data-height=&#34;978&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;大石头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大石头是指拥有最独特客户端的服务，以及与最多独特服务端连接的客户端。尽早处理大石头可能对加快采用速度很有诱惑力，但可能会导致得不偿失，造成问题，并使其他人不愿采用 SPIFFE。&lt;/p&gt;
&lt;p&gt;看一下上面的调用图，可以通过连接最多的节点来识别大石头。它们可能是被许多客户端调用的关键服务，如 Service 0；它们可能是调用许多服务端的客户端，如 Service 4。大石头还可能包括既是客户端又是服务端的服务，如 Service 7。应对这些服务的迁移，既有好处，也有风险。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;效益&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有吸引力的选择&lt;/li&gt;
&lt;li&gt;潜在的快速采用&lt;/li&gt;
&lt;li&gt;影响广泛的好处&lt;/li&gt;
&lt;li&gt;激励他人采用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;风险和挑战&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长期维护 2 个终端（传统的和支持 SPIFFE 的）&lt;/li&gt;
&lt;li&gt;只有在所有客户端都采用了 SPIFFE 之后，才会关闭传统的端点&lt;/li&gt;
&lt;li&gt;增加维护成本&lt;/li&gt;
&lt;li&gt;增加了复杂性&lt;/li&gt;
&lt;li&gt;扩展了组织能力&lt;/li&gt;
&lt;li&gt;强制采用&lt;/li&gt;
&lt;li&gt;不满的团队&lt;/li&gt;
&lt;li&gt;惊喜的是，角落里有一只乌龟！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;低垂的果实&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最低矮的果实是拥有一至几个客户端的服务，或与一个或几个服务连接的客户端。这些通常是最容易指导过渡的，并且是理想的第一批采用者。&lt;/p&gt;
&lt;p&gt;看一下上面的同一张图，低垂的果实是连接很少的节点。这些服务可能是单一的、其他服务的客户端，如 Service 2。低垂的果实也可能包括只有一个客户端的服务，比如 Service 8。在选择首先迁移哪些连接很少的服务时，明智的做法是选择那些最容易维持双端点的服务（传统的和 SPIFFE），或者那些必须在最短的时间内维持双堆栈的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效益&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果出了问题，风险更小&lt;/li&gt;
&lt;li&gt;由于需要较少的协调和规划，因此更容易从传统的方式完全转换到 SPIFFE 上&lt;/li&gt;
&lt;li&gt;良好做法和学习机会&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;风险和挑战&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推广工作可能被认为是缓慢的&lt;/li&gt;
&lt;li&gt;可能没有足够的可见性或影响力来激发关键服务所有者的采用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加速采用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些先导因素和推动因素可以促进 SPIFFE 在复杂和异构环境中的采用。它们中的每一个都有一系列不同的好处和挑战需要考虑。上面的考虑因素也适用于此；选择影响最广泛的系统，在确定所有非 SPIFFE 的消费者都已转换之前，不要转而使用非 SPIFFE 功能。&lt;/p&gt;
&lt;p&gt;先行者包括帮助他人采用 SPIFFE 的工具和服务（如 CI/CD 和工作流引擎）。开发和运维工具应该提供给第一批采用者（创新者），并随着早期采用者的加入而反复改进。我们的目标是使工具和服务在早期大多数人加入的时候达到成熟。如果没有足够的前期投资，后期的大多数人和落伍者将陷入困境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发者工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥有有助于提高生产力的工具是成功推广 SPIFFE 的关键。收集一份你的组织在应用生命周期中使用的现有工具清单，从开发到运维再到报废，并考虑哪些现有工具应该支持 SPIFFE，是否需要建立、购买或部署新的工具。花在创建、整合和改进工具上的时间和精力往往会产生倍增效应，为其他人节省时间和精力，从而帮助促进更顺利的过渡。&lt;/p&gt;
&lt;p&gt;值得注意的是，不应该孤立地建立或购买工具，而应该与他们的目标用户协商，最好是以渐进和迭代的方式。正确地做到这一点可能需要时间。&lt;/p&gt;
&lt;p&gt;选择什么时候一个工具对第一批和早期采用者来说足够好是一个判断。在极少数情况下，工具的第一次迭代对早期和后期的大多数人来说是足够好的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成和部署系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 CI/CD 工具中实施 SPIFFE 会对组织中其他服务部门采用这种 SPIFFE 产生很大的影响，因为大多数团队都会与 CI/CD 系统定期互动。然而，反过来说，这意味着要让 CI/CD 系统的所有消费者都能意识到 SPIFFE 是一项庞大的任务，所以可能需要很长的时间来关闭所有非 SPIFFE 的集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的组织已经在使用容器编排器，如 Kubernetes，那么你就成功了一半！你的组织已经在使用容器编排器。编排器使你的工作负载很容易通过 SPIFFE 感知代理前置，这样你的开发者就不需要再费心了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大型微服务服务网格架构作为 SPIFFE 部署的推动者尤其重要，因为在服务网格中引入 SPIFFE 支持是一种推出广泛支持的好方法，而不必让开发团队参与进来。&lt;/p&gt;
&lt;p&gt;服务网格的相关性也伴随着一些风险和挑战。你可以想象，破坏服务网格可能会在一个环境中产生广泛的影响，并可能以灾难性的失败告终。&lt;/p&gt;
&lt;h2 id=&#34;规划-spire-行动&#34;&gt;规划 SPIRE 行动&lt;/h2&gt;
&lt;h3 id=&#34;日复一日地运行-spire&#34;&gt;日复一日地运行 SPIRE&lt;/h3&gt;
&lt;p&gt;建议负责管理和支持 SPIRE 基础设施的团队尽可能早地参与。根据你的组织结构，很可能是你的安全或平台团队将负责整个生命周期的工作。&lt;/p&gt;
&lt;p&gt;另一个需要考虑的方面是你如何分割涉及任何会影响系统安全、性能和可用性的改变的操作。在改变任何与你的 PKI、HSM、密钥轮换和相关操作有关的东西时，可能需要更严格的控制和门槛。你可能已经有一个围绕它的变更管理过程，如果没有，这是一个开始实施它的绝佳时机。&lt;/p&gt;
&lt;p&gt;你的团队需要为不同的故障场景创建 Runbook，并对其进行测试，以了解该怎么做，需要观察哪些基本指标，并创建监控和警报。你可能已经知道你将使用什么监控和警报系统，但了解 SPIRE 服务器和代理提供的遥测数据和指标，以及这些数据意味着什么，将有助于你的团队避免停机时间。&lt;/p&gt;
&lt;h3 id=&#34;测试复原力&#34;&gt;测试复原力&lt;/h3&gt;
&lt;p&gt;故障注入练习帮助操作人员分析系统在某些故障条件下的表现。你可能对你的系统将如何基于架构做出反应有某些假设。尽管如此，在 SPIRE 部署中仍有多个潜在的故障点值得触发，以测试你的假设，并可作为运营团队的良好实践，以确保他们有所有的警报和 Runbook。&lt;/p&gt;
&lt;p&gt;我们整理了一个清单，其中包括一些你想在你的故障测试程序中包括的情景。这不是一个完整的指南，只是为你的特定环境和部署模式建立检查表的一个起点。最好是用不同的停机时间来执行所有这些测试：短于配置的 TTL 的一半和更长的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 SPIRE 的部署是使用一个单一的数据库实例，请关闭该数据库。&lt;/li&gt;
&lt;li&gt;如果 SPIRE 部署在一个集群中使用一个数据库，有一个写副本和多个读副本，请关闭写实例。&lt;/li&gt;
&lt;li&gt;模拟数据库丢失，测试数据恢复。如果你不能恢复数据或只能从一个月前的数据中恢复，怎么办？&lt;/li&gt;
&lt;li&gt;在 HA 部署中关闭几台 SPIRE 服务器。&lt;/li&gt;
&lt;li&gt;在 HA 部署中关闭负载均衡器。&lt;/li&gt;
&lt;li&gt;在代理被证明后关闭它，或完全模拟 SPIRE 服务器丢失。&lt;/li&gt;
&lt;li&gt;如果使用上游授权，模拟上游授权失败。&lt;/li&gt;
&lt;li&gt;模拟根和中间 CA 的破坏、轮换和撤销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义哪些指标在每个测试场景中是最有用的，记录这些数值的预期健康和危险范围，并随着时间的推移进行测量。&lt;/p&gt;
&lt;p&gt;这些场景应该被很好地记录下来，预期的输出被很好地定义，然后通过自动和定期运行的自动化测试来实现。&lt;/p&gt;
&lt;h3 id=&#34;日志&#34;&gt;日志&lt;/h3&gt;
&lt;p&gt;像所有系统一样，日志是 SPIRE 的一个重要组成部分。然而，SPIRE 产生的日志也可作为审计和安全事件的证据。包含身份签发信息以及可观察到的证明细节，可以用来证明某些工作负载和服务的状态。由于日志可以被视为证据，因此在组建日志解决方案时，你可能希望注意到以下几个注意事项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录的保留应符合你的组织的法律要求&lt;/li&gt;
&lt;li&gt;日志系统在接纳日志和存储方面都应具有高可用性&lt;/li&gt;
&lt;li&gt;日志应该是防篡改的，必须能够提供证据&lt;/li&gt;
&lt;li&gt;记录系统应该能够提供一个监管链&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;监控&#34;&gt;监控&lt;/h3&gt;
&lt;p&gt;除了通常的 SPIRE 组件的健康状况以确保系统正常运行外，你应该设置对服务器、代理和信任包的配置的监控，以检测未经授权的更改，因为这些组件是系统安全的基础。此外，还可以对身份的发放以及服务器和代理之间的通信进行监控，以发现异常情况。然而，根据系统中发布的身份信息量，你可能希望重新考虑监控的范围。&lt;/p&gt;
&lt;p&gt;SPIRE 通过&lt;a href=&#34;https://en.wikipedia.org/wiki/Telemetry&#34; title=&#34;遥测&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;遥测&lt;/a&gt;技术为指标报告提供灵活的支持，允许使用多个收集器收集指标。目前支持的指标收集器有 Prometheus、Statsd、DogStatsd 和 M3。在服务器和代理中都可以同时配置多个采集器。&lt;/p&gt;
&lt;p&gt;SPIRE 上有许多指标，其记录涵盖了所有的 API 和功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器
&lt;ul&gt;
&lt;li&gt;管理 API 操作&lt;/li&gt;
&lt;li&gt;每个 API 的 DB 操作&lt;/li&gt;
&lt;li&gt;SVID 发行的 API 操作&lt;/li&gt;
&lt;li&gt;轮换和秘钥管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代理
&lt;ul&gt;
&lt;li&gt;与服务器的交互&lt;/li&gt;
&lt;li&gt;SVID 轮换和缓存维护&lt;/li&gt;
&lt;li&gt;工作负载证明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>为参考平台实施 DevSecOps 原语</title>
      <link>https://jimmysong.io/book/service-mesh-devsecops/implement/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/service-mesh-devsecops/implement/</guid>
      <description>
        
        
        &lt;p&gt;各种 CI/CD 管道都涉及到参考平台（即基于微服务的应用，有提供基础设施服务的服务网格）。虽然参考应用是基于微服务的应用，但 DevSecOps 的原语可以应用于单体应用以及既在企业内部又基于云的应用（如混合云、单一公有云和多云）。&lt;/p&gt;
&lt;p&gt;在第 2.1 节中，我们提到了我们参考应用环境中的五种代码类型。我们还提到，也可以为这五种代码类型中的每一种创建单独的 CI/CD 管道。这五种代码类型在参考平台组件中的位置将被讨论，然后是描述相关 CI/CD 管道的单独章节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参考平台中的代码类型和相关的 CI/CD 管道（4.1 节）&lt;/li&gt;
&lt;li&gt;应用程序代码和应用服务代码的 CI/CD 管道（4.2 节）&lt;/li&gt;
&lt;li&gt;基础设施即代码（IaC）的 CI/CD 管道（4.3 节）&lt;/li&gt;
&lt;li&gt;策略即代码的 CI/CD 管道（4.4 节）&lt;/li&gt;
&lt;li&gt;可观测性即代码的 CI/CD 管道（4.5 节）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有 CI/CD 管道的实施问题，无论代码类型如何，都将在以下章节中讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 CI/CD 管道的安全（4.6 节）&lt;/li&gt;
&lt;li&gt;CI/CD 管道中的工作流模型（4.7 节）&lt;/li&gt;
&lt;li&gt;CI/CD 管道中的安全测试（4.8 节）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节还将考虑 DevSecOps 的整体优势，并在第 4.9 节和第 4.10 节分别介绍参考平台的具体优势和利用 DevSecOps 进行持续授权操作（C-ATO）的能力。&lt;/p&gt;
&lt;h2 id=&#34;41-代码类型和参考平台组件的描述&#34;&gt;4.1 代码类型和参考平台组件的描述&lt;/h2&gt;
&lt;p&gt;对上述五类代码（即应用、应用服务、基础设施、策略和监控）的简要描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序代码和应用服务代码：前者包含一组特定业务事务的数据和应用逻辑，而后者包含所有服务的代码，如网络连接、负载均衡和网络弹性。&lt;/li&gt;
&lt;li&gt;基础设施即代码（IaC）：用于提供和配置基础设施资源的代码，它以可重复和一致的方式承载 &lt;a href=&#34;https://searchitoperations.techtarget.com/feature/Understand-the-role-of-infrastructure-as-code-in-DevOps?utm_campaign=20210809_The&amp;#43;next&amp;#43;DevSecOps&amp;#43;challenge%3A&amp;#43;People&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;track=NL-1841&amp;amp;ad=939963&amp;amp;asrc=EM_NLN_174809933&#34; title=&#34;应用程序的部署&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用程序的部署&lt;/a&gt;。这种代码是用一种声明性语言编写的，当执行时，为正在部署的应用程序提供和配置基础设施。这种类型的代码就像在应用程序的微服务中发现的任何其他代码，只是它提供的是基础设施服务（例如，配置服务器）而不是事务服务（例如，在线零售应用程序的支付处理）。&lt;/li&gt;
&lt;li&gt;策略即代码：描述了许多策略，包括安全策略，作为 &lt;a href=&#34;https://www.magalix.com/blog/introducing-policy-as-code-the-open-policy-agent-opa&#34; title=&#34;可执行模块&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可执行模块&lt;/a&gt;。一个例子是授权策略，它的代码包含了策略（如允许、拒绝等）和适用领域（如 RESTAPI 的方法，GET、PUT 等，路径等动词或工件）这段代码可以用特殊用途的策略语言（如 Rego）或常规应用中使用的语言（如 Go）编写。这段代码可能与 IaC 的配置代码有一些重合。然而，对于实施与特定于应用领域的关键安全服务相关的策略，需要一个单独的策略作为代码，驻留在参考平台的策略执行点（PEP）中。&lt;/li&gt;
&lt;li&gt;可观测性即代码：推断系统内部状态的能力，并对系统内何时以及更重要的是为何发生错误提供可操作的洞察力。它是一种全栈式的可观测性，包括监测和分析，并对应用程序和承载它们的系统的整体性能提供关键的洞察力。在参考平台的背景下，可观测性即代码是指在代理中创建机构的那部分代码，并为从微服务应用中收集三种类型的数据（即日志、跟踪和遥测）&lt;a href=&#34;https://searchitoperations.techtarget.com/tip/Tackle-Kubernetes-observability-with-the-right-metrics?track=NL-1841&amp;amp;ad=938191&amp;amp;asrc=EM_NLN_153034984&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;utm_campaign=20210322_DevSecOps&amp;#43;leaves&amp;#43;Excel&amp;#43;in&amp;#43;the&amp;#43;dust&#34; title=&#34;创建功能&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;创建功能&lt;/a&gt;。这类代码还向外部工具提供或传输数据（例如，日志聚合工具，它聚合来自单个微服务的日志数据，为瓶颈服务提供跟踪数据分析，从遥测数据生成反映应用健康状况的指标等）。以下描述了对作为代码的可观测性所实现的三种功能：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;日志捕获详细的错误信息，以及用于故障排除的调试日志和堆栈跟踪。&lt;/li&gt;
&lt;li&gt;追踪应用程序的请求，因为它们通过多个微服务来完成一项事务，以确定分布式或基于微服务的生态系统中的问题或性能瓶颈。&lt;/li&gt;
&lt;li&gt;监测，或称度量，收集遥测从应用程序和服务中收集数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每种代码类型都有相关的 CI/CD 管道，并在第 4.2 到 4.5 节中进行了描述。应用服务代码、基础设施即代码、策略即代码和可观测性即代码类型之间可能存在重叠。&lt;/p&gt;
&lt;p&gt;托管这五种代码类型的参考平台的组成成分是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务功能组件（由几个微服务模块组成，每个模块通常作为一个容器实现），体现了应用逻辑（例如，与数据交互，执行事务等），从而形成应用代码。&lt;/li&gt;
&lt;li&gt;基础设施组件（包含计算机、网络和存储资源），其成员可以使用基础设施即代码进行配置。&lt;/li&gt;
&lt;li&gt;服务网格组件（通过控制面模块和服务代理的组合实现），提供应用服务，执行策略（例如，认证和授权），并包含应用服务代码和策略作为代码。&lt;/li&gt;
&lt;li&gt;监测组件（参与确定表明应用程序健康状况的参数的模块），执行功能（例如，日志聚合、生成指标、生成仪表板的显示等）并包含作为代码的可观测性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;策略和可观测性代码类型在服务网格中的分布情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理组件（入口、sidecar 和出口）。这些组件容纳了与会话建立、路由、认证和授权功能有关的编码策略。&lt;/li&gt;
&lt;li&gt;服务网格的控制平面。这里面有一些代码，用于转发来自服务的遥测信息，并由代理发送至专门的监控工具，认证证书的生成和维护，更新代理机构中的策略，监控服务协调平台中的整体配置，以生成新的代理，并删除与停用的微服务相关的过时代理。&lt;/li&gt;
&lt;li&gt;外部模块。这些内部模块在应用和企业层面执行专门的功能（例如，如集中授权或权利服务器、集中记录器、通过仪表板监测 / 提醒服务器状态等），并建立一个全面的应用状态视图。这些模块由来自代理或控制平面的代码调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-应用程序代码和应用服务代码的-cicd-管道&#34;&gt;4.2 应用程序代码和应用服务代码的 CI/CD 管道&lt;/h2&gt;
&lt;p&gt;应用程序代码和应用服务代码驻留在容器编排和资源管理平台中，而实现与之相关的工作流程的 CI/CD 软件通常驻留在同一平台中。应使用第 4.6 节所述的步骤对该管道进行保护，该管道控制下的应用程序代码应接受第 4.8 节所述的安全测试。此外，应用程序所在的调度平台本身应使用运行时安全工具（如 &lt;a href=&#34;https://betterprogramming.pub/kubernetes-security-with-falco-2eb060d3ae7d&#34; title=&#34;Falco&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falco&lt;/a&gt;）进行保护，该工具可以实时读取操作系统内核日志、容器日志和平台日志，并根据威胁检测规则引擎对其进行处理，以提醒用户注意恶意行为（例如，创建有特权的容器、未经授权的用户读取敏感文件等）。它们通常有一套默认（预定义）的规则，可以在上面添加自定义规则。在平台上安装它们，可以为集群中的每个节点启动代理，这些代理可以监控在该节点的各个 Pod 中运行的容器。这种类型的工具的优点是，它补充了现有平台的本地安全措施，如访问控制模型和 Pod 安全策略，通过实际检测它们的发生来 &lt;a href=&#34;https://searchitoperations.techtarget.com/tip/Terraform-cheat-sheet-Notable-commands-HCL-and-more?utm_campaign=20210726_Infrastructure&amp;#43;as&amp;#43;code&amp;#43;still&amp;#43;a&amp;#43;big&amp;#43;security&amp;#43;buzz&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;track=NL-1841&amp;amp;ad=939808&amp;amp;asrc=EM_NLN_172629823&#34; title=&#34;防止漏洞&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;防止漏洞&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;43-基础设施即代码的-cicd-管道&#34;&gt;4.3 基础设施即代码的 CI/CD 管道&lt;/h2&gt;
&lt;p&gt;为应用程序分配基础设施的传统方法包括最初用配置参数和持续的任务配置计算和网络资源，如补丁管理（如操作系统和库），建立符合合规法规（如数据隐私），并进行漂移（当前配置不再提供预期的操作状态）纠正。&lt;/p&gt;
&lt;p&gt;基础设施即代码（IaC）是一种声明式的代码，它对计算机指令进行编码，这些指令封装了通过服务的管理 API 在公共云服务或私有数据中心部署虚拟基础设施所需的 &lt;a href=&#34;https://searchitoperations.techtarget.com/tip/Terraform-cheat-sheet-Notable-commands-HCL-and-more?utm_campaign=20210726_Infrastructure&amp;#43;as&amp;#43;code&amp;#43;still&amp;#43;a&amp;#43;big&amp;#43;security&amp;#43;buzz&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;track=NL-1841&amp;amp;ad=939808&amp;amp;asrc=EM_NLN_172629823&#34; title=&#34;参数&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参数&lt;/a&gt;。换句话说，基础设施是以声明式的方式定义的，并使用用于应用程序代码的相同的源代码控制工具（如 GitOps）进行版本控制。根据特定的 IaC 工具，这种语言可以是脚本语言（如 JavaScript、Python、TypeScript 等）或专有配置语言（如 HCL），可能与标准化语言（如 JSON）兼容也可能不兼容。基本指令包括告诉系统如何配置和管理 &lt;a href=&#34;https://medium.com/4th-coffee/on-devops-8-infrastructure-as-code-introduction-best-practices-and-choosing-the-right-tool-2c8f46d1f34&#34; title=&#34;基础设施&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基础设施&lt;/a&gt;（无论是单个计算实例还是完整的服务器，如物理服务器或虚拟机）、容器、存储、网络连接、连接拓扑和负载均衡器。在某些情况下，基础设施可能是短暂的，基础设施的寿命（无论是不可变的还是可变的）不需要继续配置管理。配置可以与应用程序代码的单个提交相联系，使用的工具可以将应用程序代码和基础设施代码以一种合乎逻辑、富有表现力、为开发和运维团队所熟悉的方式连接起来，其中应用程序代码越来越多地定义了云应用的基础设施资源 &lt;a href=&#34;https://cdn2.hubspot.net/hubfs/4429525/Content/Pulumi-Delivering-CNI-as-Code.pdf&#34; title=&#34;要求&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;要求&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因此，IaC 涉及编码所有的软件部署任务（分配服务器的类型，如裸机、虚拟机或容器，服务器的资源内容）和这些服务器及其网络的配置。包含这种代码类型的软件也被称为资源管理器或部署管理器。换句话说，IaC 软件可以自动管理整个 IT 基础设施的生命周期（资源的配置和取消配置），并实现一个可编程的基础设施。将这种软件作为 CI/CD 管道的一部分进行整合，不仅可以实现敏捷的部署和维护，还可以实现安全和满足性能需求的强大应用平台。&lt;/p&gt;
&lt;h3 id=&#34;431-对-iac-的保护&#34;&gt;4.3.1 对 IaC 的保护&lt;/h3&gt;
&lt;p&gt;当基础设施是 IaC 中的代码时，它可能包括有可能成为漏洞的 bug 和疏忽，因此，就像在应用程序代码中一样被利用。因此，保护 IaC 就是保护基础设施的定义和最终的部署环境。任何一段 IaC 在进入 GitOps 并被合并之前，都必须进行潜在漏洞的扫描。&lt;/p&gt;
&lt;p&gt;此外，只有当有一个有条不紊的漂移管理过程时，才能获得安全应用平台的保证。只有当 IaC 中定义的架构是部署环境中实际存在的架构时，才能获得这种保证，因为这种等同性可能会被通过控制台或 CLI 进行的无意或有意的更改所改变，从而绕过 IaC。确保这种对等性必须在部署后立即进行，并在运行期间定期进行，因为对架构的任何改变都可能导致引入安全设计缺陷，并可能需要对 IaC 进行修改。&lt;/p&gt;
&lt;h3 id=&#34;432-配置和基础设施之间的区别&#34;&gt;4.3.2 配置和基础设施之间的区别&lt;/h3&gt;
&lt;p&gt;基础设施经常与 &lt;a href=&#34;https://cdn2.hubspot.net/hubfs/4429525/Content/Pulumi-Delivering-CNI-as-Code.pdf&#34; title=&#34;配置&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置&lt;/a&gt; 相混淆，后者将计算机系统、软件、依赖关系和设置维持在一个理想的、一致的状态。例如，将一台新购买的服务器放到机架上，并将其连接到交换机上，使其与现有网络相连（或启动一个新的虚拟机并为其分配网络接口），属于基础设施的定义。相反，在服务器启动后，安装 HTTPS 服务器并对其进行配置属于配置管理。&lt;/p&gt;
&lt;h2 id=&#34;44-策略即代码的-cicd-管道&#34;&gt;4.4 策略即代码的 CI/CD 管道&lt;/h2&gt;
&lt;p&gt;策略即代码涉及编纂所有策略，并作为 CI/CD 管道的一部分运行，使其成为应用程序运行时的一个组成部分。策略类别的例子包括授权策略、网络策略和实现工件策略（例如，容器策略）。典型的
策略即代码软件的策略管理能力可能带有一套预定义的策略类别和策略，也支持通过提供策略模板定义新的策略类别和 &lt;a href=&#34;https://www.datadoghq.com/blog/log-patterns/&#34; title=&#34;相关策略&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;相关策略&lt;/a&gt;。策略即代码所要求的尽职调查是，它应该提供保护，防止与应用环境（包括基础设施）相关的所有已知威胁，只有当该代码被定期扫描和更新，以应对与应用类别（如网络应用）和托管基础设施相关的威胁，才能确保这一点。下面的表 1 中给出了一些策略类别和相关策略的例子。&lt;/p&gt;
&lt;p&gt;表 1：策略类别和策略实例&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;策略类别&lt;/th&gt;
          &lt;th&gt;策略示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;网络策略和零信任策略&lt;/td&gt;
          &lt;td&gt;- 封锁指定端口 - 指定入口主机名称 - 一般来说，所有的网络访问控制策略&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;实施工件策略（例如，容器策略）&lt;/td&gt;
          &lt;td&gt;- 对服务器进行加固，对基础镜像进行漏洞扫描 - 确保容器不以 root 身份运行 - 阻止容器的权限升级&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;存储策略&lt;/td&gt;
          &lt;td&gt;- 设置持久性卷大小 - 设置持久性卷回收策略&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;访问控制策略&lt;/td&gt;
          &lt;td&gt;- 确保策略涵盖所有数据对象 - 确保策略涵盖管理和应用访问的所有角色 - 确保数据保护策略涵盖静态数据、传输中数据和使用中数据 - 确保所有类型的策略不存在冲突&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;供应链策略&lt;/td&gt;
          &lt;td&gt;- 只允许经批准的容器注册表 - 只允许经认证的库&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;审计和问责策略&lt;/td&gt;
          &lt;td&gt;- 确保有与审计和问责职能相关的策略&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在策略即代码软件中定义的策略可以转化为应用基础设施运行时配置参数中的以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强化策略的可执行性（例如，服务代理中的 WASM）。&lt;/li&gt;
&lt;li&gt;用于调用外部策略决策模块的触发器（例如，调用外部授权服务器，根据对与当前访问请求相关的访问控制策略的评估，做出允许 / 拒绝的决定）。&lt;/li&gt;
&lt;li&gt;它还可能影响 IaC，以确保在部署环境中提供适当的资源，以执行安全、隐私和合规要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;45-可观测性即代码的-cicd-管道&#34;&gt;4.5 可观测性即代码的 CI/CD 管道&lt;/h2&gt;
&lt;p&gt;可观测性即代码在应用程序的每个服务组件中部署一个监控代理，以收集三种类型的数据（在第 4.1 节中描述），将它们发送到专门的工具，将它们关联起来，进行分析，并在仪表板上显示分析后的综合数据，以呈现整个应用程序级别的情况。这种综合数据的一个例子是日志模式，它提供了一个日志数据的视图，该视图是在使用一些标准（例如，一个服务或一个事件）对日志数据进行过滤后呈现的。数据根据共同的模式（例如，基于时间戳或 IP 地址范围）被分组，以方便解释。不寻常的发生被识别出来，然后这些发现可以被用来指导和加速 &lt;a href=&#34;https://www.datadoghq.com/blog/log-patterns/&#34; title=&#34;进一步的调查&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;进一步的调查&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;46-确保-cicd-管道的安全&#34;&gt;4.6 确保 CI/CD 管道的安全&lt;/h2&gt;
&lt;p&gt;无论代码类型如何，CI/CD 管道都有一些共同的实施问题需要解决。确保流程安全涉及到为操作构建任务分配角色。自动化工具（例如，Git Secrets）可用于此目的。为保证 CI/CD 管道的安全，以下安全任务应被视为最低限度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强化托管代码和工件库的服务器。&lt;/li&gt;
&lt;li&gt;确保用于访问存储库的凭证，如授权令牌和生成拉动请求的凭证。&lt;/li&gt;
&lt;li&gt;控制谁可以在容器镜像注册处签入和签出，因为它们是 CI 管道产生的工件的存储处，是 CI 和 CD 管道之间的桥梁。&lt;/li&gt;
&lt;li&gt;记录所有的代码和构建更新活动。&lt;/li&gt;
&lt;li&gt;如果在 CI 管道中构建或测试失败 —— 向开发人员发送构建报告并停止进一步的管道任务。配置代码库自动阻止来自 CD 管道的所有拉取请求。&lt;/li&gt;
&lt;li&gt;如果审计失败，将构建报告发送给安全团队，并停止进一步的管道任务。&lt;/li&gt;
&lt;li&gt;确保开发人员只能访问应用程序代码，而不能访问五种管道代码类型中的任何一种。&lt;/li&gt;
&lt;li&gt;在构建和发布过程中，在每个需要的 CI/CD 阶段签署发布工件（最好是多方签署）。&lt;/li&gt;
&lt;li&gt;在生产发布期间，验证所有需要的签名（用多个阶段的密钥生成），以确保没有人绕过管道。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;47-cicd-管道中的工作流模型&#34;&gt;4.7 CI/CD 管道中的工作流模型&lt;/h2&gt;
&lt;p&gt;下一个常见问题涉及工作流模型。所有的 CI/CD 管道都可以有两种类型的工作流程模型，这取决于作为管道一部分部署的自动化工具。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于推的模式&lt;/li&gt;
&lt;li&gt;基于拉的模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在支持基于推模式的 CI/CD 工具中，在管道的一个阶段或阶段所做的改变会触发后续阶段或阶段的改变。例如，通过一系列的编码脚本，CI 系统中的新构建会触发管道中 CD 部分的变化，从而改变部署基础设施（如 Kubernetes 集群）。使用 CI 系统作为部署变化的基础，其安全方面的缺点是有可能将凭证暴露在部署环境之外，尽管已尽最大努力确保 CI 脚本的安全，因为 CI 脚本是在部署基础设施的信任域之外运行的。由于 CD 工具拥有生产系统的 key，基于推送的模式就变得不安全了。&lt;/p&gt;
&lt;p&gt;在基于拉的工作流程模型中，与部署环境有关的运维（例如 Kubernetes 运维、Flux、ArgoCD）一旦观察到有新镜像被推送到注册表，就会从环境内部拉动新镜像。新镜像被从注册表中拉出，部署清单被自动更新，新镜像被部署在环境（如集群）中。因此，实际的部署基础设施状态与 Git 部署库中声明性描述的状态实现了衔接。此外，部署环境凭证（例如集群凭证）不会暴露在生产环境之外。因此，强烈建议采用基于拉的模式，即通常使用 GitOps 仓库来存储源代码和构建。&lt;/p&gt;
&lt;h3 id=&#34;471-gitsops-的-cicd-工作流程模型--基于拉的模型&#34;&gt;4.7.1 GitsOps 的 CI/CD 工作流程模型 —— 基于拉的模型&lt;/h3&gt;
&lt;p&gt;GitOps 工作流模型是对 CI/CD 管道的改进（针对管道的交付部分），它使用了基于拉的工作流模型，而不是许多 CI/CD 工具支持的基于推的模型。在这个模型中，流水线的 CI 部分没有变化，因为 CI 引擎（如 Jenkins、GitLab CI）仍然用于为修改后的代码创建构建。&lt;/p&gt;
&lt;p&gt;回归测试，以及与相关存储库中的主要源代码集成 / 合并，尽管它不用于在管道中触发持续交付（直接推送更新）。&lt;/p&gt;
&lt;p&gt;相反，一个单独的 GitOps Operator 根据主干代码的更新来管理部署。&lt;/p&gt;
&lt;p&gt;Operator（例如，Flux、ArgoCD）是一个由协调平台管理的行为体，可以继承集群的配置、安全和可用性。使用这种行为体可以提高安全性，因为在集群内部的代理会监听它被允许访问的所有代码和镜像仓库的更新，并将镜像和配置更新拉入集群。代理使用的拉方式具有以下安全特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只执行协调平台中定义的授权策略所允许的操作；信任与集群共享，不单独管理。&lt;/li&gt;
&lt;li&gt;与所有协调平台对象进行原生绑定，并了解操作是否已经完成或需要重试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;48-安全测试所有代码类型的-cicd-管道的共同要求&#34;&gt;4.8 安全测试——所有代码类型的 CI/CD 管道的共同要求&lt;/h2&gt;
&lt;p&gt;最后一个常见的问题是安全测试。无论代码类型是什么（例如，应用服务、Iac、Pac 或可观测性），基于微服务的基础设施的 DevSecOps 的 CI/CD 管道与服务网格应包括由自动化工具或作为服务提供的应用安全测试（AST）。这些工具会分析和测试应用程序的安全漏洞。根据 Gartner 的说法，有 四种 主要的 AST 技术：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态 AST（SAST）工具：分析应用程序的源码、字节码或二进制代码的安全漏洞，通常在编程和 / 或测试软件生命周期（SLC）阶段。具体来说，这项技术涉及到在提交中查看应用程序并分析其依赖关系的 &lt;a href=&#34;https://sdtimes.com/test/a-guide-to-automated-testing-providers/&#34; title=&#34;技术&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术&lt;/a&gt;。如果任何依赖关系包含问题或已知的安全漏洞，提交将被标记为不安全的，不允许继续部署。这也可以包括在代码中找到应该被删除的硬编码密码 / 秘密。&lt;/li&gt;
&lt;li&gt;动态 AST（DAST）工具：在测试或运行阶段，分析应用程序的动态运行状态。它们模拟针对应用程序（通常是支持网络的应用程序、服务和 API）的攻击，分析应用程序的反应，并确定它是否有漏洞。特别是，DAST 工具比 SAST 更进一步，在 CI 工作中启动生产环境的副本，以扫描所产生的容器和 &lt;a href=&#34;https://sdtimes.com/test/a-guide-to-automated-testing-providers/&#34; title=&#34;可执行文件&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可执行文件&lt;/a&gt;。动态方面有助于系统捕捉在启动时正在加载的依赖关系，例如那些不会被 SAST 捕捉的依赖关系。&lt;/li&gt;
&lt;li&gt;交互式 AST（IAST）工具：将 DAST 的元素与被测试的应用程序的仪器相结合。它们通常作为测试运行环境中的一个代理来实现（例如，对 Java 虚拟机或.NET CLR 进行检测），观察操作或识别攻击漏洞。&lt;/li&gt;
&lt;li&gt;软件组成分析（SCA）工具：用于识别应用程序中使用的开源和第三方组件、其已知的安全漏洞以及典型的对抗性许可限制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;481-ast-工具的功能和覆盖要求&#34;&gt;4.8.1 AST 工具的功能和覆盖要求&lt;/h3&gt;
&lt;p&gt;一般来说，测试工具（包括特定类别的 AST 工具）应该满足的总体指标是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过识别安全、隐私和合规性方面的差距，提高应用程序的发布质量。&lt;/li&gt;
&lt;li&gt;与开发人员已经在使用的工具整合。&lt;/li&gt;
&lt;li&gt;要尽可能少的测试工具，但提供必要的风险覆盖。&lt;/li&gt;
&lt;li&gt;API 和微服务层面的低级单元测试应该有足够的可视性来确定覆盖率。&lt;/li&gt;
&lt;li&gt;包括更高层次的 UI/UX 和系统测试。&lt;/li&gt;
&lt;li&gt;具备深入的代码分析能力，以检测运行时的缺陷。&lt;/li&gt;
&lt;li&gt;提高发布的速度。&lt;/li&gt;
&lt;li&gt;要有成本效益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别是对 AST 工具的功能要求包括进行以下类型的扫描：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漏洞扫描。探测应用程序的安全弱点，这些弱点可能会使它们受到攻击。&lt;/li&gt;
&lt;li&gt;容器镜像扫描。分析容器镜像的内容和构建过程，以检测安全问题、漏洞或缺陷做法（例如，硬编码密码 / 秘密）。&lt;/li&gt;
&lt;li&gt;监管 / 合规性扫描。评估对特定合规要求的遵守情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每当源代码库中的代码被修改时，都要进行漏洞扫描，以确保当前的修订版不包含任何有漏洞的 &lt;a href=&#34;https://circleci.com/blog/security-best-practices-for-ci-cd/&#34; title=&#34;依赖&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;依赖&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;AST 工具和 / 或服务的理想特征，以及行为分析的技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析源码、字节码或二进制代码&lt;/li&gt;
&lt;li&gt;观察应用程序的行为，以确定引入安全漏洞的编码、设计、打包、部署和运行时条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为 CI/CD 管道任务的一部分，扫描应用程序代码的安全漏洞和错误配置应涉及以下工件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器镜像应被扫描以发现漏洞。&lt;/li&gt;
&lt;li&gt;在容器从基础镜像（如上所述进行扫描）构建之后，应该对容器的文件系统进行漏洞和错误配置的扫描。&lt;/li&gt;
&lt;li&gt;应该对 Git 存储库（包含应用程序源代码）进行扫描，以发现漏洞和错误配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器镜像包括操作系统包（如 Alpine、UBI、RHEL、CentOS 等）和特定语言包（如 Bundler、Composer、npm、yarn 等）。&lt;/p&gt;
&lt;p&gt;对基础设施即代码进行安全漏洞扫描，通过防止这些漏洞进入生产，减少了操作工作量，尽管它不能取代对运行时安全的检查，因为漂移的风险始终存在。然而，必须对架构的所有部署后（运行时）变化（由于漂移）的原因进行分析，并通过向 IaC 推送适当的更新来解决，从而使其成为管道的一部分，并在后续部署中不再出现。这种方法有利于使用运行时检查来补救安全设计缺陷。&lt;/p&gt;
&lt;p&gt;基础设施即代码的文件可以在下面找到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器编排平台本身，以促进部署（例如，Kubernetes YAML 基础设施即代码文件）。&lt;/li&gt;
&lt;li&gt;作为 CI/CD 管道软件的一部分而发现的专用基础设施即代码文件（例如，HashiCorp Terraform 基础设施即代码文件，AWS CloudFormation 基础设施即代码文件）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用服务代码、策略即代码和可观测性即代码文件可以在专门的应用服务组件（如服务网格）的数据平面和控制平面组件中找到，并且应该对安全漏洞（如授权策略的信息泄露）和错误配置进行扫描。&lt;/p&gt;
&lt;h2 id=&#34;49-devsecops-原语对服务网格中应用安全的好处&#34;&gt;4.9 DevSecOps 原语对服务网格中应用安全的好处&lt;/h2&gt;
&lt;p&gt;DevSecOps 的好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各个 IT 团队之间，特别是开发人员、运维和安全团队以及其他利益相关者之间更好的沟通和协作。导致 &lt;a href=&#34;https://whatis.techtarget.com/feature/Top-30-DevOps-interview-questions-and-answers?utm_campaign=20210712_New&amp;#43;Kubernetes&amp;#43;use&amp;#43;case%253A&amp;#43;Hacking&amp;amp;utm_medium=EM&amp;amp;utm_source=NLN&amp;amp;track=NL-1841&amp;amp;ad=939635&amp;amp;asrc=EM_NLN_170130891&#34; title=&#34;更好的生产力&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更好的生产力&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;简化软件开发、交付和部署过程 —— 由于自动化，停机时间减少，发布时间加快，基础设施和运维成本降低，效率提高。&lt;/li&gt;
&lt;li&gt;通过实施零信任来减少攻击面，这也限制了横向移动，从而防止攻击升级。具有现代行为预防能力的持续监控进一步促进了这一点。&lt;/li&gt;
&lt;li&gt;安全优势。通过对每个请求的验证监控、警报和反馈机制来提高安全性，因为可观测性是代码。这些将在以下段落中详细描述。具体的能力包括：
&lt;ul&gt;
&lt;li&gt;a.  运行时：杀死恶意容器。&lt;/li&gt;
&lt;li&gt;b.  反馈：由于一个错误的程序更新了代码并重新触发了管道，所以反馈到了正确的存储库。&lt;/li&gt;
&lt;li&gt;c.  监测新的和终止的服务，并调整相关服务（如服务代理）。&lt;/li&gt;
&lt;li&gt;d.  启用安全断言。不可绕过 —— 通过在同一空间执行的代理、安全会话、强大的认证和授权以及安全的状态转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;启用持续授权操作（C-ATO），在本节末尾详细描述。
对每个请求的验证和上述的反馈机制将在下面进一步描述：&lt;/li&gt;
&lt;li&gt;每个请求的验证。来自用户或客户端应用程序（服务）的每个请求都要经过验证和授权（使用 OPA 或任何外部授权引擎或 &lt;a href=&#34;https://medium.com/cloudlego/kubernetes-admission-controllers-request-interceptors-47a9b12c5303&#34; title=&#34;接纳控制器&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;接纳控制器&lt;/a&gt; 等机制，它们是平台的组成部分）。授权引擎提供特定于应用域的策略执行，而接纳控制器则提供与特定平台的端点对象（如 Pod、部署、命名空间）相关的平台特定策略。具体来说，接纳控制器会进行突变和验证。突变的接纳控制器解析每个请求，并在将其向下转发之前对请求进行修改（突变）。一个例子是为没有被用户在请求中设置的规格设置默认值，以确保在集群上运行的工作负载是统一的，并遵循集群管理员定义的特定标准。另一个例子是为 Pod 添加特定的资源限制（如果资源限制没有为该 Pod 设置），然后向下转发（如果请求中没有这个字段，通过添加这个字段来突变请求）。通过这样做，集群中的所有 Pod 将始终有一个根据规范设置的资源限制，除非明确说明。验证接纳控制器会拒绝那些不遵循特定规范的请求。例如，没有一个 Pod 请求可以将安全上下文设置为以根用户身份运行。&lt;/li&gt;
&lt;li&gt;反馈机制：
&lt;ul&gt;
&lt;li&gt;一些在运行时发现的问题的补救措施可能需要在源代码中处理或修复。应该有一个流程，针对正确的代码库自动打开一个问题，以修复问题并重新触发 DevSecOps 管道。&lt;/li&gt;
&lt;li&gt;向应用程序托管平台提供反馈回路（例如，杀死包含恶意容器的 Pod 的通知）。&lt;/li&gt;
&lt;li&gt;通过监控应用程序的配置，提供主动的动态安全（例如，监控引入到应用程序的新荚 / 容器，并生成和注入代理以照顾其安全通信需求）。&lt;/li&gt;
&lt;li&gt;启用关于应用程序的几个安全断言：不可绕过（即在所有使用场景下始终执行的策略）、整个应用程序代码的受信任和不受信任部分、没有凭证和特权泄漏、受信任的通信路径和安全状态转换。&lt;/li&gt;
&lt;li&gt;启用关于性能参数的断言（例如，网络弹性参数，如在故障、冗余和可恢复性功能下继续运行）。&lt;/li&gt;
&lt;li&gt;总的来说，更快地吸收反馈意见，使软件得到更快的改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>威胁建模</title>
      <link>https://jimmysong.io/book/kubernetes-hardening-guidance/threat-model/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/kubernetes-hardening-guidance/threat-model/</guid>
      <description>
        
        
        &lt;p&gt;Kubernetes 可以成为数据和 / 或计算能力盗窃的重要目标。虽然数据盗窃是传统上的主要动机，但寻求计算能力（通常用于加密货币挖掘）的网络行为者也被吸引到 Kubernetes 来利用其底层基础设施。除了资源盗窃，网络行为者还可能针对 Kubernetes 造成拒绝服务。下面的威胁代表了 Kubernetes 集群最可能的破坏源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;供应链风险&lt;/strong&gt; - 对供应链的攻击载体是多种多样的，并且在减轻风险方面具有挑战性。供应链风险是指对手可能颠覆构成系统的任何元素的风险，包括帮助提供最终产品的产品组件、服务或人员。这可能包括用于创建和管理 Kubernetes 集群的第三方软件和供应商。供应链的潜在威胁会在多个层面上影响 Kubernetes，包括：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器 / 应用层面&lt;/strong&gt; - 在 Kubernetes 中运行的应用及其第三方依赖的安全性，它们依赖于开发者的可信度和开发基础设施的防御能力。来自第三方的恶意容器或应用程序可以为网络行为者在集群中提供一个立足点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施&lt;/strong&gt; - 托管 Kubernetes 的底层系统有其自身的软件和硬件依赖性。系统作为工作节点或控制平面一部分的，任何潜在威胁都可能为网络行为者在集群中提供一个立足点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恶意威胁行为者&lt;/strong&gt; - 恶意行为者经常利用漏洞从远程位置获得访问权。Kubernetes 架构暴露了几个 API，网络行为者有可能利用这些 API 进行远程利用。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制平面&lt;/strong&gt; - Kubernetes 控制平面有各种组件，通过通信来跟踪和管理集群。网络行为者经常利用缺乏适当访问控制的暴露的控制平面组件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作节点&lt;/strong&gt; - 除了运行容器引擎外，工作者节点还承载着 &lt;code&gt;kubelet&lt;/code&gt; 和 &lt;code&gt;kube-proxy&lt;/code&gt; 服务，这些都有可能被网络行为者利用。此外，工作节点存在于被锁定的控制平面之外，可能更容易被网络行为者利用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器化的应用程序&lt;/strong&gt; - 在集群内运行的应用程序是常见的目标。应用程序经常可以在集群之外访问，使它们可以被远程网络行为者接触到。然后，网络行为者可以从已经被破坏的应用出发，或者利用暴露的应用程序的内部可访问资源在集群中提升权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部威胁&lt;/strong&gt; - 威胁者可以利用漏洞或使用个人在组织内工作时获得的特权。来自组织内部的个人被赋予特殊的知识和特权，可以用来威胁 Kubernetes 集群。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管理员&lt;/strong&gt; - Kubernetes 管理员对运行中的容器有控制权，包括在容器化环境中执行任意命令的能力。Kubernetes 强制的 RBAC 授权可以通过限制对敏感能力的访问来帮助降低风险。然而，由于 Kubernetes 缺乏双人制的完整性控制，即必须有至少一个管理账户才能够获得集群的控制权。管理员通常有对系统或管理程序的物理访问权，这也可能被用来破坏 Kubernetes 环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt; - 容器化应用程序的用户可能有知识和凭证来访问 Kubernetes 集群中的容器化服务。这种程度的访问可以提供足够的手段来利用应用程序本身或其他集群组件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云服务或基础设施供应商&lt;/strong&gt; - 对管理 Kubernetes 节点的物理系统或管理程序的访问可被用来破坏 Kubernetes 环境。云服务提供商通常有多层技术和管理控制，以保护系统免受特权管理员的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
                           
    <item>
      <title>SPIFFE 联邦</title>
      <link>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/</guid>
      <description>
        
        
        &lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;SPIFFE 规范定义了建立一个平台无关的工作负载身份框架所需的文档和接口，该框架能够在不需要实现身份转换或凭证交换逻辑的情况下连接不同域中的系统。它们定义了一个“&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain&#34; title=&#34;信任域&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任域&lt;/a&gt;”，它作为一个身份命名空间。&lt;/p&gt;
&lt;p&gt;SPIFFE 的本质是分散的。每个信任域都根据自己的授权行事，与驻留在其他信任域中的系统在管理上是隔离的。虽然信任域划定了行政和/或安全域，但核心的 SPIFFE 用例是在需要时跨越这些边界进行通信。因此，有必要定义一种机制，使实体可以被引入到外部信任域中，从而允许其验证由“其他”SPIFFE 授权机构颁发的凭证，并允许一个信任域中的工作负载安全地验证一个外部信任域中的工作负载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#3-spiffe-bundles&#34; title=&#34;SPIFFE 包&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 包&lt;/a&gt;是一个包含验证特定信任域凭证所需的公钥材料的资源。本文档介绍了一种规范，用于安全地获取 SPIFFE 包，以便验证外部机构颁发的身份。其中包括有关如何提供 SPIFFE 包、如何检索 SPIFFE 包以及如何验证提供它们的端点的信息。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;SPIFFE 联邦使得在信任域之间验证身份凭证 (SVIDs) 成为可能。具体来说，它是获取验证来自不同信任域颁发的 SVIDs 所需的 SPIFFE 包的行为，并将这些包提供给执行验证的工作负载。&lt;/p&gt;
&lt;p&gt;为了验证来自一个信任域的 SVIDs，必须拥有该信任域的包。因此，实现 SPIFFE 联邦需要在信任域之间交换 SPIFFE 包。这种交换应该定期发生，以允许信任域包的内容随时间变化。&lt;/p&gt;
&lt;p&gt;为了实现这一点，SPIFFE 联邦定义了一个“包端点”，它是一个 URL，用于为特定的信任域提供 SPIFFE 包。还定义了一组“端点配置文件”，它们指定了包端点服务器和客户端之间使用的协议和身份验证语义。最后，本文档进一步指定了包端点客户端和服务器的行为，以及联邦关系的管理和生成的包数据。&lt;/p&gt;
&lt;h2 id=&#34;目标用例&#34;&gt;目标用例&lt;/h2&gt;
&lt;p&gt;最终，SPIFFE 联邦使得工作负载能够对其他信任域中的对等方进行身份验证。这个功能对于支持各种用例至关重要，但我们希望重点关注三个核心用例。&lt;/p&gt;
&lt;p&gt;SPIFFE 信任域经常用于将同一公司或组织中不同信任级别的环境进行分割。例如，可以在暂存和生产环境之间、PCI 和非 PCI 环境之间进行分割。在这些情况下，每个域中使用的 SPIFFE 部署共享一个共同的管理机构，并且很可能由相同的实现支持。这是一个重要的区别，因为它意味着不同的部署可以就某些事情达成一致（例如命名方案），并且每个部署的安全姿态可以被其他部署了解和理解。&lt;/p&gt;
&lt;p&gt;其次，SPIFFE 联邦也被用于在不同公司或组织之间的信任域之间进行联邦。这种情况与第一种情况相似，我们正在对 SPIFFE 部署进行联邦，但由于可能存在的实现和管理差异，协调通常仅限于在此处描述的 SPIFFE 联邦协议中交换的数据。&lt;/p&gt;
&lt;p&gt;最后，SPIFFE 联邦还可以为尚未部署成熟 SPIFFE 控制平面的客户端提供用例。例如，托管产品可能希望使用客户端的 SPIFFE 身份对其客户进行身份验证，而无需内部实现或部署 SPIFFE。这可以通过允许工作负载直接获取客户端的信任域绑定来实现，以便对其调用者进行身份验证，从而避免了承诺部署完整的 SPIFFE 的需求。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-端点&#34;&gt;SPIFFE Bundle 端点&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 端点是一个资源（由 URL 表示），用于提供一个信任域的 SPIFFE Bundle 的副本。SPIFFE 控制平面可以同时暴露和使用这些端点，以便在它们之间传输 bundle，从而实现联邦。&lt;/p&gt;
&lt;p&gt;SPIFFE Bundle 端点的语义类似于 OpenID Connect 规范中定义的&lt;code&gt;jwks_uri&lt;/code&gt;机制，因为 bundle 包含了一个或多个用于在信任域内证明身份的公共加密密钥。Bundle 端点是一个 HTTPS URL，对 HTTP GET 请求做出 SPIFFE bundle 的响应。&lt;/p&gt;
&lt;h3 id=&#34;添加和删除密钥&#34;&gt;添加和删除密钥&lt;/h3&gt;
&lt;p&gt;信任域的操作者可以根据需要（例如，作为内部密钥轮换过程的一部分）引入或删除用于颁发 SVID 的密钥。在添加新密钥时，应提前发布包含密钥的更新信任捆绑包到捆绑包端点，以便外部信任域有机会检索和内部传播新捆绑包内容；建议提前时间为捆绑包的&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;的 3-5 倍。至少，在使用密钥颁发 SVID 之前，新密钥必须发布到捆绑包端点。&lt;/p&gt;
&lt;p&gt;当信任域不再颁发来自这些密钥的活动有效 SVID 时，应从信任捆绑包中删除已弃用的密钥。如果在将密钥添加到捆绑包中或从捆绑包中删除密钥时不遵循这些建议，可能会导致暂时的跨域身份验证失败。&lt;/p&gt;
&lt;p&gt;更新信任捆绑包的要求不适用于仅用于内部使用的颁发 SVID 的密钥。&lt;/p&gt;
&lt;p&gt;应定期轮询捆绑包端点以获取更新，因为其内容预计会随时间&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#appendix-a-spiffe-bundle-example&#34; title=&#34;更改&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更改&lt;/a&gt; - 常见的密钥有效期通常为几周甚至几天。客户端应以与捆绑包的&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;值相等的频率轮询。如果未设置，应适用合理低的默认值 - 建议为五分钟。&lt;/p&gt;
&lt;h3 id=&#34;管理获取的-bundle&#34;&gt;管理获取的 Bundle&lt;/h3&gt;
&lt;p&gt;Bundle 终端的客户端应在每次检索到 Bundle 时存储最新的 SPIFFE Bundle。当比较两个 Trust Bundle 的新鲜度或顺序时，应使用 Trust Bundle 的序列号字段。如果 Trust Bundle 省略了序列号，操作员应将最近检索到的 Bundle 视为最新的。&lt;/p&gt;
&lt;p&gt;操作员可以随时在外部信任域中本地更新 SPIFFE Bundle。在这种情况下，本地更新的 Bundle 版本将被视为最新版本，直到被后续的刷新替换。&lt;/p&gt;
&lt;p&gt;不同信任域的 Bundle 内容不得合并为单个更大的 Bundle。这样做将使一个信任域能够在验证器的眼中伪造属于另一个信任域的身份。因此，非常重要的是确保从外部信任域接收的 Bundle 保持清晰可辨，并明确反映它们所属的信任域名称。有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;终端地址的稳定性&#34;&gt;终端地址的稳定性&lt;/h3&gt;
&lt;p&gt;一旦外部信任域开始依赖于特定的终端 URL，将所有终端的客户端迁移到替代终端 URL 是一个复杂且容易出错的过程。因此，最安全的做法是优先选择稳定的终端 URL。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-终端的提供和使用&#34;&gt;SPIFFE Bundle 终端的提供和使用&lt;/h2&gt;
&lt;p&gt;本规范定义了两种基于 HTTPS 的 SPIFFE Bundle 终端服务器支持的配置文件。其中一种依赖于使用 Web PKI 对终端进行身份验证，另一种则利用 SPIFFE 身份验证。SPIFFE Bundle 终端客户端必须同时支持这两种配置文件，而 SPIFFE Bundle 终端服务器必须至少支持其中一种。&lt;/p&gt;
&lt;p&gt;支持基于 TLS 的配置文件（例如&lt;code&gt;https_web&lt;/code&gt;或&lt;code&gt;https_spiffe&lt;/code&gt;）的 Bundle 终端服务器必须遵守&lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29&#34; title=&#34;Mozilla 中间兼容性&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mozilla 中间兼容性&lt;/a&gt;要求，除非使用配置文件另有规定。&lt;/p&gt;
&lt;h3 id=&#34;端点参数&#34;&gt;端点参数&lt;/h3&gt;
&lt;p&gt;在从 SPIFFE 捆绑端点检索捆绑之前，客户端必须配置以下三个参数：（1）SPIFFE 捆绑端点的 URL，（2）端点配置文件类型，以及（3）与捆绑端点关联的信任域名称。前两个参数指示捆绑端点的位置和如何进行身份验证。由于信任捆绑不包含信任域名称，客户端使用第三个参数将已下载的捆绑与特定的信任域名称关联起来。特定的端点配置文件（例如&lt;code&gt;https_spiffe&lt;/code&gt;，如下所述）可以定义其他强制的配置参数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/production/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_web&amp;#34;
Trust Domain:			&amp;#34;prod.example.com&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 1：用于信任域&lt;a href=&#34;http://prod.example.com/&#34; title=&#34;prod.example.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prod.example.com&lt;/a&gt;的示例 SPIFFE 捆绑端点配置。管理员通过捆绑端点配置来检索外部信任捆绑。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当控制平面将信任捆绑分发给工作负载时，必须通信信任域名称和信任捆绑之间的关联。有关这些参数的敏感性，请参见安全注意事项部分。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_bundle_distribution_hu5237499082848154670.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_bundle_distribution.png&#34; data-img=&#34;/book/spiffe-and-spire/standard/spiffe-federation/spiffe_bundle_distribution.png&#34; data-width=&#34;624&#34; data-height=&#34;85&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;图 2：在检索到外部 SPIFFE 信任捆绑后，控制平面将信任域名称和相应的捆绑分发给内部工作负载。工作负载使用此配置来验证外部信任域中的身份。有关信任捆绑内容的详细信息，请参见&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md&#34; title=&#34;SPIFFE 信任域和捆绑&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 信任域和捆绑&lt;/a&gt; ，特别是&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#4-spiffe-bundle-format&#34; title=&#34;SPIFFE 捆绑格式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 捆绑格式&lt;/a&gt;和&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#appendix-a-spiffe-bundle-example&#34; title=&#34;SPIFFE 捆绑示例&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 捆绑示例&lt;/a&gt;部分。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本节中的要求适用于所有 SPIFFE 捆绑端点服务器和客户端。个别的 SPIFFE 捆绑端点配置文件可能会添加其他要求。&lt;/p&gt;
&lt;h3 id=&#34;端点配置文件&#34;&gt;端点配置文件&lt;/h3&gt;
&lt;p&gt;端点配置文件描述了在提供或使用捆绑端点时应使用的传输协议和身份验证方法。&lt;/p&gt;
&lt;p&gt;以下各节描述了受支持的捆绑端点配置文件。&lt;/p&gt;
&lt;h3 id=&#34;web-pkihttps_web&#34;&gt;Web PKI（&lt;code&gt;https_web&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_web&lt;/code&gt;配置文件利用公信任的证书颁发机构提供了一种低摩擦的方式来配置 SPIFFE 联邦。当访问网页时，它的行为与大多数人熟悉的“https”URL 完全相同。在此配置文件中，捆绑点服务器使用由公共 CA 颁发的证书，无需额外的客户端配置；使用&lt;code&gt;https_web&lt;/code&gt;配置文件类型的端点使用通常安装在现代操作系统中的相同公共 CA 证书进行身份验证。&lt;/p&gt;
&lt;p&gt;有关使用公共证书颁发机构的更多信息，请参见安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;端点-url-要求&#34;&gt;端点 URL 要求&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_web&lt;/code&gt;的捆绑点 URL 必须将方案设置为&lt;code&gt;https&lt;/code&gt;，并且在授权组件中不能包括用户信息。此规范不限制 URL 的其他组件（由&lt;a href=&#34;https://tools.ietf.org/html/rfc3986#section-3&#34; title=&#34;RFC 3986 第 3 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986 第 3 节&lt;/a&gt;定义）。&lt;/p&gt;
&lt;p&gt;例如，URL &lt;code&gt;https://host.example.com/trust_domain&lt;/code&gt; 是 &lt;code&gt;https_web&lt;/code&gt; 配置文件类型的有效 SPIFFE 捆绑点 URL。&lt;/p&gt;
&lt;h3 id=&#34;端点参数-1&#34;&gt;端点参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_web&lt;/code&gt;配置文件在功能上不需要任何额外的参数，除了每个配置文件都需要的参数（即信任域名、配置文件类型和端点 URL）。&lt;/p&gt;
&lt;h3 id=&#34;提供-bundle-端点&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_web&lt;/code&gt;传输类型的 SPIFFE bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。所使用的服务器证书应由公共证书颁发机构（根据 CA/Browser 论坛的成员名单定义）颁发，并且必须将端点的 DNS 名称或 IP 地址作为 X.509 主题备用名称（或通用名称）包含在内。&lt;/p&gt;
&lt;p&gt;作为互操作性问题，服务器不得要求对访问 bundle 端点进行客户端身份验证；这包括传输层（例如客户端证书）和 HTTP 层（例如身份验证标头）身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，bundle 端点服务器必须回复最新版本的可用 SPIFFE bundle。响应必须以 UTF-8 编码，并应在响应上设置&lt;code&gt;Content-Type&lt;/code&gt;标头为&lt;code&gt;application/json&lt;/code&gt;。此规范不限制提供 SPIFFE bundle 的路径。&lt;/p&gt;
&lt;p&gt;如果请求的 bundle 的授权机构已经更改，bundle 端点服务器可以使用 HTTP 重定向（根据&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; title=&#34;RFC 7231 第 6.4 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义）进行响应。重定向的目标 URL 也必须是符合此配置文件中定义的有效的 bundle 端点 URL。服务器应使用临时重定向；重定向的支持是为了操作考虑（例如通过 CDN 提供 bundle），而不是作为永久迁移 bundle 端点 URL 的手段。有关详细信息，请参阅安全考虑事项。&lt;/p&gt;
&lt;h3 id=&#34;web-pkihttps_web-1&#34;&gt;Web PKI（&lt;code&gt;https_web&lt;/code&gt;）&lt;/h3&gt;
&lt;h3 id=&#34;提供-bundle-端点-1&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_web&lt;/code&gt;传输类型的 SPIFFE bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。所使用的服务器证书应由公共证书颁发机构（根据 CA/Browser 论坛的成员名单定义）颁发，并且必须将端点的 DNS 名称或 IP 地址作为 X.509 主题备用名称（或通用名称）包含在内。&lt;/p&gt;
&lt;p&gt;作为互操作性问题，服务器不得要求对访问 bundle 端点进行客户端身份验证；这包括传输层（例如客户端证书）和 HTTP 层（例如身份验证标头）身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，bundle 端点服务器必须回复最新版本的可用 SPIFFE bundle。响应必须以 UTF-8 编码，并应在响应上设置&lt;code&gt;Content-Type&lt;/code&gt;标头为&lt;code&gt;application/json&lt;/code&gt;。此规范不限制提供 SPIFFE bundle 的路径。&lt;/p&gt;
&lt;p&gt;如果请求的 bundle 的授权机构已经更改，bundle 端点服务器可以使用 HTTP 重定向（根据&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; title=&#34;RFC 7231 第 6.4 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义）进行响应。重定向的目标 URL 也必须是符合此配置文件中定义的有效的 bundle 端点 URL。服务器应使用临时重定向；重定向的支持是为了操作考虑（例如通过 CDN 提供 bundle），而不是作为永久迁移 bundle 端点 URL 的手段。有关详细信息，请参阅安全考虑事项。&lt;/p&gt;
&lt;h3 id=&#34;使用-bundle-终点&#34;&gt;使用 Bundle 终点&lt;/h3&gt;
&lt;p&gt;当与&lt;code&gt;https_web&lt;/code&gt; bundle 终点进行交互时，SPIFFE bundle 终点客户端使用标准的 TLS 保护的 HTTP（即 HTTPS）。在连接到终点时，必须根据&lt;a href=&#34;https://tools.ietf.org/html/rfc6125&#34; title=&#34;RFC 6125&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 6125&lt;/a&gt;验证服务器证书。总结该文档，服务器证书必须由本地信任的证书颁发机构签发，且必须包含与配置的终点 URL 的主机组件匹配的 X.509 主体替代名称（或公共名称）。&lt;/p&gt;
&lt;p&gt;在建立与 bundle 终点的 TLS 连接并验证呈现的服务器证书后，客户端发出终点 URL 指定的 HTTP GET 请求。响应的正文是一个 SPIFFE bundle。在检索信任 bundle 之前，客户端必须知道终点 URL 代表的信任域的名称，最好通过显式配置；有关详细信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;p&gt;如果终点服务器具有 HTTP 重定向功能（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; title=&#34;RFC 7231 第 6.4 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义的），则 bundle 终点服务器可以响应 HTTP 重定向。如果 URL 满足有效 bundle 终点 URL 的所有要求，bundle 终点客户端应遵循重定向。连接到新 URL 时，必须应用与连接到原始 URL 相同的 TLS 注意事项。bundle 终点客户端应使用配置的终点 URL 进行每个 bundle 刷新，并不应永久存储位置以供将来获取。有关详细信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-身份验证https_spiffe&#34;&gt;SPIFFE 身份验证（&lt;code&gt;https_spiffe&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_spiffe&lt;/code&gt;配置文件使用由 SPIFFE 信任域（而不是由公共证书颁发机构签发的证书）颁发的 X509-SVID。该配置文件允许 bundle 终点避免使用网络定位器作为服务器标识的一种形式，并且通过标准 SPIFFE 机制支持自动根 CA 轮换和吊销。&lt;/p&gt;
&lt;p&gt;除了所有配置文件所需的终点参数之外，&lt;code&gt;https_spiffe&lt;/code&gt;配置文件还需要其他终点客户端参数，如下所述。&lt;/p&gt;
&lt;h3 id=&#34;终点-url-要求&#34;&gt;终点 URL 要求&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_spiffe&lt;/code&gt;的 bundle 终点 URL 的方案必须设置为&lt;code&gt;https&lt;/code&gt;，并且在授权组件中不能包含用户信息。此规范不限制 URL 的其他组件（如&lt;a href=&#34;https://tools.ietf.org/html/rfc3986#section-3&#34; title=&#34;RFC 3986 第 3 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986 第 3 节&lt;/a&gt;定义）。&lt;/p&gt;
&lt;p&gt;例如，URL &lt;code&gt;https://host.example.com/trust_domain&lt;/code&gt; 是&lt;code&gt;https_spiffe&lt;/code&gt;配置文件类型的有效 SPIFFE bundle 终点 URL。&lt;/p&gt;
&lt;h3 id=&#34;终端参数&#34;&gt;终端参数&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_spiffe&lt;/code&gt;配置文件的终端终端客户端必须配置终端终端服务器的 SPIFFE ID 以及获取终端终端服务器信任域的信任终端终端的安全方法。&lt;strong&gt;自助终端终端&lt;/strong&gt;是指终端终端服务器的 SPIFFE ID 与获取的终端终端相同信任域中。配置的终端终端终端可能是自助终端终端或非自助终端终端。&lt;/p&gt;
&lt;p&gt;如果终端是自助终端终端，则客户端需要配置一个最新的终端以启动联邦关系。客户端必须支持使用&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#4-spiffe-bundle-format&#34; title=&#34;SPIFFE Bundle 格式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE Bundle 格式&lt;/a&gt;指定终端，并且可以支持其他格式（例如 PEM），前提是它们提供必要的根证书以验证连接。客户端依赖于此配置的终端进行第一次检索，然后存储检索到的终端以验证后续连接。有关详细信息，请参见下面的使用终端终端。&lt;/p&gt;
&lt;p&gt;如果终端不是自助终端终端，则客户端必须单独为终端服务器的信任域进行配置。可以通过以下任何方式配置终端服务器的信任域和终端终端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信任域的终端参数，该参数配置客户端使用终端配置文件根据本文档中所述的终端配置进行终端检索。请注意，客户端可以使用任何可用配置文件，并不限于&lt;code&gt;https_spiffe&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;未定义且超出本文档范围的获取或配置终端终端的过程，无论是自动还是静态。有关如何保护此方法的指导，请参见安全注意事项部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/global/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_spiffe&amp;#34;
Trust Domain:			&amp;#34;example.com&amp;#34;
Endpoint SPIFFE ID:		&amp;#34;spiffe://example.com/spiffe-bundle-server&amp;#34;
Endpoint Trust Bundle:		{example.com bundle contents omitted}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 3：使用 SPIFFE 身份验证的&lt;code&gt;example.com&lt;/code&gt;信任域的 SPIFFE 捆绑点端点配置示例。在此示例中，捆绑点端点是自助的，并且配置包括捆绑点端点的 SPIFFE ID 和&lt;code&gt;example.com&lt;/code&gt;的信任捆绑，即此 SPIFFE ID 的信任域。此初始捆绑用于对捆绑点端点进行首次连接的身份验证并验证其 SVID。随后对该捆绑点端点的连接使用最新获取的副本进行身份验证。&lt;/em&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/production/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_spiffe&amp;#34;
Trust Domain:			&amp;#34;prod.example.com&amp;#34;
Endpoint SPIFFE ID:		&amp;#34;spiffe://example.com/spiffe-bundle-server&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 4：使用 SPIFFE 身份验证的&lt;code&gt;prod.example.com&lt;/code&gt;信任域的 SPIFFE 捆绑点端点配置示例。在此示例中，捆绑点端点不是自助的：&lt;code&gt;prod.example.com&lt;/code&gt;的信任捆绑可通过具有 SPIFFE ID &lt;code&gt;spiffe://example.com/spiffe-bundle-server&lt;/code&gt;的&lt;code&gt;example.com&lt;/code&gt;获取。通过上述联邦示例已经获取了用于验证&lt;a href=&#34;http://example.com/&#34; title=&#34;example.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example.com&lt;/a&gt;的信任捆绑。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;提供-bundle-端点-2&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_spiffe&lt;/code&gt;传输类型的 SPIFFE Bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。服务器证书必须是有效的 X509-SVID。&lt;/p&gt;
&lt;p&gt;作为互操作性的关注点，服务器不得要求客户端进行身份验证以访问 Bundle 端点；包括传输层（例如客户端证书）和 HTTP 层（例如身份验证头）的身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，Bundle 端点服务器必须响应最新版本的可用 SPIFFE Bundle。操作员可以选择确切的路径值，并将其作为 Bundle 端点 URL 的一部分显示。Bundle 端点服务器必须使用 UTF-8 编码传输 Bundle，并应在响应中设置&lt;code&gt;Content-Type&lt;/code&gt;头为&lt;code&gt;application/json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果用于提供所请求 Bundle 的授权发生了变化，Bundle 端点服务器可以使用 HTTP 重定向（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; title=&#34;RFC 7231 第 6.4 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;所定义）。重定向的目标 URL 也必须是此配置文件中定义的有效 Bundle 端点 URL，并且新目标呈现的服务器证书必须是具有与原始端点相同的 SPIFFE ID 的有效 X509-SVID。服务器应使用临时重定向；重定向的支持旨在用于运营考虑（例如通过 CDN 提供 Bundle），而不是作为永久迁移 Bundle 端点 URL 的手段。有关更多信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;使用-bundle-终端点&#34;&gt;使用 Bundle 终端点&lt;/h3&gt;
&lt;p&gt;SPIFFE bundle 终端点客户端在与&lt;code&gt;https_spiffe&lt;/code&gt; bundle 终端点交互时使用标准的 TLS 保护的 HTTP（即 HTTPS）。在连接到终端点时，必须验证服务器证书是否是提供的 bundle 终端点 SPIFFE ID 的有效 X509-SVID。有关验证 X509-SVID 的信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/X509-SVID.md#5-validation&#34; title=&#34;SPIFFE X509-SVID&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE X509-SVID&lt;/a&gt;规范。&lt;/p&gt;
&lt;p&gt;自服务 bundle 终端点是指 bundle 终端点服务器的 SPIFFE ID 与正在获取的 bundle 所属的信任域位于同一信任域中。在首次连接到自服务 bundle 终端点时，客户端使用操作员提供的 SPIFFE bundle（通过 bundle 终端点参数）来验证服务器证书。随后的连接必须使用最新的可用 bundle 来验证。这样可以使外部信任域旋转密钥而不中断联邦关系。&lt;/p&gt;
&lt;p&gt;非自服务 bundle 终端点是指 bundle 终端点服务器的 SPIFFE ID 不位于正在获取的 bundle 所属的信任域中。连接到非自服务终端点时，客户端使用与终端点 SPIFFE ID 的信任域对应的最新可用 SPIFFE bundle，该 bundle 可能是直接配置的，也可能是通过另一个联邦关系获取的。&lt;/p&gt;
&lt;p&gt;在与 bundle 终端点建立 TLS 连接并验证呈现的服务器证书之后，客户端发出终端点 URL 指定的 HTTP GET 请求。响应的正文是一个 SPIFFE bundle。在检索信任 bundle 之前，客户端必须知道终端点 URL 所代表的信任域的名称，最好通过显式配置来获取；有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;p&gt;终端点可以使用 HTTP 重定向进行响应（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; title=&#34;RFC 7231 第 6.4 节&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;所定义）。如果 URL 满足有效的 bundle 终端点 URL 的所有要求，则 bundle 终端点客户端应跟随重定向。连接到新 URL 时，必须应用与连接到原始 URL 相同的 TLS 考虑。特别是，必须呈现与最初配置的相同 SPIFFE ID 的有效 X509-SVID。bundle 终端点客户端应该对每个 bundle 刷新使用配置的终端点 URL，并且不应该永久存储用于将来获取的位置。有关更多信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h2 id=&#34;关系生命周期&#34;&gt;关系生命周期&lt;/h2&gt;
&lt;p&gt;本节描述了联邦“关系”的生命周期，包括建立第一个连接、进行持续维护和终止。&lt;/p&gt;
&lt;p&gt;联邦关系是单向的。换句话说，Alice 可以与 Bob 建立关系，但反过来不行。在这种情况下，Alice 能够验证由 Bob 颁发的身份，但 Bob 不知道如何验证由 Alice 颁发的身份。&lt;/p&gt;
&lt;p&gt;为了实现相互身份验证，需要形成两个关系 - 每个方向一个。&lt;/p&gt;
&lt;h3 id=&#34;建立关系&#34;&gt;建立关系&lt;/h3&gt;
&lt;p&gt;如“终端点参数”部分所述，为正确配置联邦关系，所有 bundle 终端点客户端需要至少三个信息：外部信任域名称、其 bundle 终端点 URL 和终端点配置文件。&lt;/p&gt;
&lt;p&gt;bundle 终端点 URL 提供了可以找到外部信任域的 bundle 的地址，而配置文件告知客户端在调用它时应使用哪个协议。配置文件可能需要额外的特定于配置文件的参数。有关如何连接和验证 bundle 终端点的详细信息，请参阅相关的终端点配置文件子部分。&lt;/p&gt;
&lt;p&gt;连接成功建立并接收到 bundle 副本后，将其与其所属的信任域名称一起存储。现在，可以分发 bundle 的内容（例如 CA 证书、JWT 签名密钥等），以验证源自外部信任域的 SVID。&lt;/p&gt;
&lt;p&gt;此分发的确切方式和机制是实现细节，超出了本文档的范围。有关 SPIFFE 感知工作负载如何接收 bundle 更新的更多信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Workload_API.md&#34; title=&#34;SPIFFE 工作负载 API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 工作负载 API&lt;/a&gt;规范。&lt;/p&gt;
&lt;h3 id=&#34;维护关系&#34;&gt;维护关系&lt;/h3&gt;
&lt;p&gt;SPIFFE bundle 终端点客户端应定期轮询 bundle 终端点以获取更新。检测到更新后，存储代表终端点外部信任域的存储的 bundle 将进行更新。然后，将更新的内容分发，以便验证者可以根据需要添加新的密钥并删除撤销的密钥。再次强调，将此更新分发给验证者的确切方法超出了本文档的范围。&lt;/p&gt;
&lt;p&gt;如果轮询 bundle 终端点的尝试失败，bundle 终端点客户端应在下一个轮询间隔重试，而不是立即或强制重试，因为这可能会导致 bundle 终端点服务器过载。如添加和删除密钥部分所讨论的那样，新密钥应足够提前发布，以使错过一两次轮询不会导致跨域身份验证失败。&lt;/p&gt;
&lt;h3 id=&#34;终止关系&#34;&gt;终止关系&lt;/h3&gt;
&lt;p&gt;终止联邦关系就是删除对外信任域的本地副本，停止轮询其信任域终点，并确保验证器也删除了该外部信任域的终点，不再成功验证从该终点呈现的 SVID。&lt;/p&gt;
&lt;p&gt;如果需要重新建立关系，则需要重新开始此生命周期。&lt;/p&gt;
&lt;h3 id=&#34;生命周期图&#34;&gt;生命周期图&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_lifecycle_hu17069739948407752112.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_lifecycle.png&#34; data-img=&#34;/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_lifecycle.png&#34; data-width=&#34;624&#34; data-height=&#34;480&#34; alt=&#34;image&#34; data-caption=&#34;生命周期图&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;生命周期图&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;安全考虑&#34;&gt;安全考虑&lt;/h2&gt;
&lt;p&gt;本节包含与该规范相关的安全信息和观察结果。实施者和用户都应熟悉这些信息。&lt;/p&gt;
&lt;h3 id=&#34;终点参数的分发&#34;&gt;终点参数的分发&lt;/h3&gt;
&lt;p&gt;联邦关系的配置参数，包括信任域名称、终点 URL 和配置文件本身对于篡改是高度敏感的。联邦关系配置的被篡改可能会削弱或完全破坏 SPIFFE 实现所隐含的安全保证。&lt;/p&gt;
&lt;p&gt;以下是一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;篡改信任域名称可以使控制相应终点束端点的一方冒充任意信任域&lt;/li&gt;
&lt;li&gt;篡改终点 URL，特别是与&lt;code&gt;https_web&lt;/code&gt;配置文件结合使用时，攻击者可以发出欺诈性密钥并冒充相应信任域中的任何身份&lt;/li&gt;
&lt;li&gt;篡改终点配置文件可以改变联邦的安全保证，例如用&lt;code&gt;https_spiffe&lt;/code&gt;替换&lt;code&gt;https_web&lt;/code&gt;。如果你的威胁模型包括 Web PKI 的妥协（请另请参阅下面的网络流量拦截部分），则这可能被认为是安全姿态的重大降级。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，控制平面管理员必须谨慎地安全源这些参数并安全地输入它们。终点束配置可以使用各种方法来获取，包括但不限于电子邮件、受 HTTPS 保护的网站、公司内部 wiki 等。无论使用的是哪种特定方法来初始分发终点配置，分发方法都需要抵御在途篡改、未经授权的静止修改以及恶意冒充。例如，电子邮件通常不具备抵御篡改或冒充（即&amp;quot;伪造&amp;quot;电子邮件）的抗性。&lt;/p&gt;
&lt;h3 id=&#34;明确定义的终结点参数&#34;&gt;明确定义的终结点参数&lt;/h3&gt;
&lt;p&gt;每个 SPIFFE 联邦关系至少配置以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信任域名&lt;/li&gt;
&lt;li&gt;终结点 URL&lt;/li&gt;
&lt;li&gt;终结点配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是这三个参数要明确配置，不能从彼此中安全地推断出值。&lt;/p&gt;
&lt;p&gt;例如，人们可能会试图从终结点 URL 的主机部分推断出 SPIFFE 信任域名。这是危险的，因为它可能允许任何可以从特定 DNS 名称提供文件的人断言同名 SPIFFE 信任域的信任根。&lt;/p&gt;
&lt;p&gt;想象一个名为 MyPage（&lt;code&gt;mypage.example.com&lt;/code&gt;）的网络托管公司，它允许客户 Alice 在&lt;code&gt;https://mypage.example.com/alice/&amp;lt;filename&amp;gt;&lt;/code&gt;这样的 URL 上提供网络内容，并且 MyPage 还通过 SPIFFE 联邦与 SPIFFE 信任域名&lt;code&gt;mypage.example.com&lt;/code&gt;运行 API。假设 Alice 与 Bob 建立了 SPIFFE 联邦关系，Bob 也是 MyPage 的客户，Alice 选择从&lt;code&gt;https://mypage.example.com/alice/spiffe-bundle&lt;/code&gt;提供她的信任捆绑包。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_mypage_example_hu16327104462779945901.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_mypage_example.png&#34; data-img=&#34;/book/spiffe-and-spire/standard/spiffe-federation/spiffe_federation_mypage_example.png&#34; data-width=&#34;622&#34; data-height=&#34;391&#34; alt=&#34;image&#34; data-caption=&#34;图 5：说明 Alice、Bob 和 MyPage 之间关系的图表。&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;图 5：说明 Alice、Bob 和 MyPage 之间关系的图表。&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;如果 Bob 的控制平面从 URL 中隐式获取信任域名，这将允许 Alice 冒充信任域&lt;code&gt;mypage.example.com&lt;/code&gt;！还值得强调的是，SPIFFE 信任域名不一定是已注册的 DNS 名称，这通常使得这种假设本来就是错误的。在这个例子中，Alice 的信任域名只是&lt;code&gt;alice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;终结点配置文件也不能从 URL 中安全地推断出。&lt;code&gt;https_web&lt;/code&gt;和&lt;code&gt;https_spiffe&lt;/code&gt;都使用具有相同要求的普通 HTTPS URL。没有安全的方法来区分它们。尝试使用&lt;code&gt;https_web&lt;/code&gt;并回退到&lt;code&gt;https_spiffe&lt;/code&gt;，或者反过来，是不充分的，原因与上述类似：从安全的角度来看，能够在特定的 HTTPS 终结点上托管使用 Web PKI 的文件与能够使用有效的 SPIFFE SVID 托管它是不等价的。&lt;/p&gt;
&lt;h3 id=&#34;保持-信任域名-捆绑包-的绑定&#34;&gt;保持 &lt;code&gt;&amp;lt;信任域名, 捆绑包&amp;gt;&lt;/code&gt; 的绑定&lt;/h3&gt;
&lt;p&gt;在对 SVID 进行身份验证时，验证者必须仅使用与 SPIFFE ID 所属的信任域名相对应的捆绑包。如果我们简单地将所有的捆绑包汇集起来，并且只要某个捆绑包对某个捆绑包有效，就接受一个 SVID，那么信任域之间就可以轻易地冒充对方的身份。换句话说，捆绑包是针对特定信任域的。&lt;/p&gt;
&lt;p&gt;由于捆绑包在信任域和发行捆绑包的终结点之间没有自我描述的特性，且自我发布，因此在存储和传播捆绑包时，需要将 SPIFFE 联邦关系的信任域名和捆绑包终结点之间的绑定转化为信任域名和捆绑包之间的绑定。这要求不同于传统的 Web PKI，传统的 Web PKI 使用单个根证书存储来验证所有证书，而不管实际发行验证的 CA 系统是哪个。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点服务器的可信性&#34;&gt;捆绑包终结点服务器的可信性&lt;/h3&gt;
&lt;p&gt;捆绑包终结点服务器的可信性和完整性对于确保捆绑包所代表的信任域的安全性至关重要。这不仅包括捆绑包终结点服务器本身，还包括其运行的平台以及对其或其平台具有管理控制权的任何实体。&lt;/p&gt;
&lt;p&gt;虽然这个事实可能看起来是不言自明的，但也有一些情况可能没有那么明显。例如，在非自服务捆绑包终结点的情况下，信任域 A 为信任域 B 提供捆绑包，信任域 B 隐式地信任信任域 A 及其管理员提供正确的捆绑包内容。类似地，如果从像 AWS S3 这样的托管平台提供捆绑包，那么代表涉及捆绑包的信任域的运营者隐式地信任 AWS 提供正确的捆绑包内容。&lt;/p&gt;
&lt;p&gt;在选择将提供 SPIFFE 捆绑包的位置时，重要的是考虑涉及的各方的可信性。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点的真实性&#34;&gt;捆绑包终结点的真实性&lt;/h3&gt;
&lt;p&gt;确保捆绑包终结点的真实性至关重要。这一点无法过于强调。本节探讨了确保捆绑包终结点真实性的一些考虑因素。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点-url-重定向&#34;&gt;捆绑包终结点 URL 重定向&lt;/h3&gt;
&lt;p&gt;URL 重定向有两种变体：临时重定向和永久重定向。该规范通过 SHOULD 指示建议服务器只发送临时重定向，并且客户端应将所有重定向视为临时重定向，即使服务器将其标记为永久重定向。&lt;/p&gt;
&lt;p&gt;如果客户端遵循永久重定向，那么永久重定向代表了终结点 URL 配置参数的带内自动重写。这会导致两个相关的安全风险。&lt;/p&gt;
&lt;p&gt;首先，信任域操作员可能会试图使用永久重定向作为迁移终结点 URL 的方法。然而，没有可靠的方法来确保所有客户端都已处理了重定向，并且没有办法确保它们将永久地遵守重定向（例如，通过重启、升级、重新部署等）。如果终结点 URL 转移所有权并且客户端继续从原始终结点 URL 获取捆绑包，那么这些客户端可能会检索到由意外所有者控制的捆绑包。这在使用基于 Web PKI 的方案（如&lt;code&gt;https_web&lt;/code&gt;）时尤其令人担忧，因为新域所有者有权获得公开受信任的与其相关的证书。因此，最安全的做法是选择具有长期稳定性的捆绑包终结点 URL。如果绝对需要 URL 迁移，最好使用首次获取捆绑包终结点配置的外带方法来处理，同时提前公布长期的迁移窗口。&lt;/p&gt;
&lt;p&gt;其次，永久重定向可能被滥用为将短暂的妥协升级为更持久的妥协的机制。由于重定向是自动的，捆绑包终结点客户端操作员可能会忽略这个重定向。&lt;/p&gt;
&lt;p&gt;临时重定向通常由 Web 主机用于操作目的：例如，允许在接收方附近的节点上提供全球稳定的 URL。禁止在 SPIFFE 联邦中使用重定向将从操作员的工具包中删除一个有用的工具。但是，临时重定向确实有安全考虑因素。并非所有的 Web 主机在其安全态势方面都是等价的，这意味着如果发生重定向，操作员可能无法获得预期的安全保证。本规范中对客户端“应该”遵循重定向的建议应该被解释为推荐的默认值：在操作价值和安全价值之间的平衡。依赖 SPIFFE 联邦捆绑包终结点的操作员可能希望禁用重定向，以避免出现意外情况。&lt;/p&gt;
&lt;h3 id=&#34;网络流量拦截&#34;&gt;网络流量拦截&lt;/h3&gt;
&lt;p&gt;虽然所有 SPIFFE 捆绑包终结点配置文件都使用的协议在很大程度上不受网络流量拦截和操纵的风险影响，但重要的是要注意，这并不一定意味着用于发放协议凭证的方案也不受影响。如果 SPIFFE 作为“零信任”解决方案的一部分部署，或者如果操作者的威胁模型中包括网络妥协，则必须特别关注用于发放捆绑包终结点服务器凭证的机制。&lt;/p&gt;
&lt;p&gt;常见的服务器凭证发放方法是通过使用挑战 - 响应机制，其中凭证请求的授权是基于请求者能够回答发送到特定网络地址或 DNS 名称的挑战。ACME 协议就是一个例子，如果希望使用公共证书颁发机构，则应考虑补偿控制措施。特别需要注意的是捆绑包终结点服务器所在的二层网络的安全性。&lt;/p&gt;
&lt;p&gt;最后，应指出，ACME 和公共证书颁发机构基础设施在历史上一直是稳定和可靠的。本节所描述的关注点是几十年的问题，然而，作为一种用于缓解对网络或 DNS 中信任的方式采用 SPIFFE 的操作者可能会发现这种行为令人惊讶。&lt;/p&gt;
&lt;h3 id=&#34;终结点参数&#34;&gt;终结点参数&lt;/h3&gt;
&lt;p&gt;破坏捆绑包终结点的一种方法是篡改终结点参数，无论是在传输中还是在终结点的客户端中以休息形式。修改其他方面真实的终结点参数可能导致降级的安全态势，甚至导致客户端与完全不同的终结点进行通信。请参阅终结点参数的分发部分以获取更多信息。&lt;/p&gt;
&lt;h3 id=&#34;使用-https_spiffe-进行信任链接&#34;&gt;使用 &lt;code&gt;https_spiffe&lt;/code&gt; 进行信任链接&lt;/h3&gt;
&lt;p&gt;在使用 SPIFFE 身份验证时，可以通过验证提供的 X509-SVID 来建立信任捆绑服务器的真实性，客户端可以通过各种方式获取到该信任捆绑。例如，信任域 A 的捆绑可以由信任域 B 中的一个端点提供，而信任域 B 的捆绑可以由信任域 C 中的一个端点提供，依此类推。&lt;/p&gt;
&lt;p&gt;通过这种方式，获取的捆绑通过链式关系与提供捆绑的信任域之间建立了信任。该链式关系最终会终止于以下几种情况之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过与自服务信任域的联邦关系&lt;/li&gt;
&lt;li&gt;通过与由 Web PKI 提供的捆绑端点的联邦关系&lt;/li&gt;
&lt;li&gt;在长期静态配置的信任捆绑中&lt;/li&gt;
&lt;li&gt;在本文档范围之外的某个过程中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如在 Bundle 端点服务器的可信性一节中所描述的那样，重要的是要理解该方案的安全性取决于链中的每个信任域能够履行其安全保证。链中信任域或捆绑端点服务器的妥协将导致“下一个”信任域的妥协。具有足够强大的网络拦截能力的攻击者可能会以某种方式升级此攻击，以导致链中后续的信任域可能被妥协。因此，通常不鼓励以这种方式形成长链。如果需要，管理员应花时间分析这些链，以确保所有参与的信任域符合其所需的标准。&lt;/p&gt;
&lt;p&gt;最后，应注意到该链中的“链接”是由各个 HTTPS 请求操作（针对链中不同的捆绑端点服务器）形成的，并且这些操作可能在不同的时间发生。SPIFFE 捆绑端点客户端应记录这些 HTTPS 请求操作，并且管理员应注意保留这些日志以备将来进行法医分析（如果有必要）。&lt;/p&gt;

      </description>
    </item>
                           
    <item>
      <title>设计一个 SPIRE 部署</title>
      <link>https://jimmysong.io/book/spiffe/designing-a-spire-deployment/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <author>Jimmy Song</author>
      <guid>https://jimmysong.io/book/spiffe/designing-a-spire-deployment/</guid>
      <description>
        
        
        &lt;p&gt;读者将了解到 SPIRE 部署的组成部分，有哪些部署模式，以及在部署 SPIRE 时需要考虑哪些性能和安全问题。&lt;/p&gt;
&lt;p&gt;你的 SPIRE 部署的设计应满足你的团队和组织的技术要求。它还应包括支持可用性、可靠性、安全性、可扩展性和性能的要求。该设计将作为你的部署活动的基础。&lt;/p&gt;
&lt;h2 id=&#34;身份命名方案&#34;&gt;身份命名方案&lt;/h2&gt;
&lt;p&gt;请记住，在前面的章节中，SPIFFE ID 是一个结构化的字符串，代表一个工作负载的身份名称，正如你在第四章中看到的那样。工作负载标识符部分（URI 的路径部分）附加在信任域名（URI 的主机部分）上，可以组成关于服务所有权的含义，以表示它在什么平台上运行，谁拥有它，它的预期目的，或其他惯例。它是特意为你定义的灵活和可定制的。&lt;/p&gt;
&lt;p&gt;你的命名方案可能是分层的，就像文件系统的路径。也就是说，为了减少歧义，命名方案不应该以尾部的正斜杠（&lt;code&gt;/&lt;/code&gt;）结束。下面你将看到一些不同的样例，它们遵循三种不同的约定，你可以遵循，或者如果你感到特别有灵感，也可以想出你自己的。&lt;/p&gt;
&lt;h3 id=&#34;直接命名服务&#34;&gt;直接命名服务&lt;/h3&gt;
&lt;p&gt;你可能会发现，作为软件开发生命周期的一部分，直接通过它从应用角度呈现的功能和它运行的环境来识别一个服务是很有用的。例如，管理员可能会规定，在特定环境中运行的任何进程都应该能够以特定身份出现。比如说。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://staging.example.com/payments/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://staging.example.com/payments/web-fe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的两个 SPIFFE ID 指的是两个不同的组件 ——MySQL 数据库服务和一个 Web 前端 —— 在 staging 环境中运行的支付服务。&lt;code&gt;staging&lt;/code&gt; 的意思是一个环境，&lt;code&gt;payment&lt;/code&gt; 是一个高级服务。&lt;/p&gt;
&lt;p&gt;前面两个例子和下面两个例子是说明性的，不是规定性的。实施者应该权衡自己的选择，决定自己喜欢的行动方案。&lt;/p&gt;
&lt;h3 id=&#34;识别服务所有者&#34;&gt;识别服务所有者&lt;/h3&gt;
&lt;p&gt;通常更高级别的编排器和平台都有自己的内置身份概念（如 Kubernetes 服务账户，或 AWS/GCP 服务账户），能够直接将 SPIFFE 身份映射到这些身份是有帮助的。比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://k8s-workload-cluster.example.com/ns/staging/sa/default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，信任域 &lt;code&gt;example.com&lt;/code&gt; 的管理员正在运行一个 Kubernetes 集群 &lt;code&gt;k8s-workload-cluster.example.com&lt;/code&gt;，它有一个 &lt;code&gt;staging&lt;/code&gt; 命名空间，在这个命名空间中，有一个名为 &lt;code&gt;default&lt;/code&gt; 的服务账户（SA）。&lt;/p&gt;
&lt;h3 id=&#34;不透明的-spiffe-身份&#34;&gt;不透明的 SPIFFE 身份&lt;/h3&gt;
&lt;p&gt;SPIFFE 路径可能是不透明的，然后元数据可以被保存在一个二级数据库中。这可以被查询以检索与 SPIFFE 标识符相关的任何元数据。比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://example.com/9eebccd2-12bf-40a6-b262-65fe0487d4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;spire-的部署模式&#34;&gt;SPIRE 的部署模式&lt;/h2&gt;
&lt;p&gt;我们将概述在生产中运行 SPIRE 的三种最常见的方式。这并不意味着我们要在这里限制可用的选择，但为了本书的目的，我们将把范围限制在这些部署 SPIRE 服务器的常见方式上。我们将只关注服务器的部署架构，因为每个节点通常安装一个代理。&lt;/p&gt;
&lt;h3 id=&#34;数量大信任域与小信任域的对比&#34;&gt;数量：大信任域与小信任域的对比&lt;/h3&gt;
&lt;p&gt;信任域的数量预计是相对固定的，只是偶尔重访，而且预计不会随时间漂移太多。另一方面，一个给定的信任域中的节点数量和工作负载的数量，预计会根据负载和增长而频繁波动。&lt;/p&gt;
&lt;p&gt;选择集中到一个大的信任域的单一信任根，还是分布和隔离到多个信任域，将由许多因素决定。本章的安全考虑部分谈到了使用信任域进行隔离的问题。还有一些原因，你可以选择多个小的信任域而不是一个大的信任域，包括增加可用性和租户的隔离。管理域边界、工作负载数量、可用性要求、云供应商数量和认证要求等变量也会影响这里的决策。&lt;/p&gt;
&lt;p&gt;例如，你可以选择为每一个行政边界设置一个单独的信任域，以便在组织中可能有不同开发实践的不同小组之间进行自治。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;类别&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;单信任域&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;嵌套&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;联合&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;部署规模&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;大&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;非常大&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;多区域&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;否&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;是&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;多云&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;否&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;是&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;是&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表 6.1: 信任域大小的决策表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一对一：单信任域中的单一 SPIRE 集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单一的 SPIRE 服务器，在高可用性的配置下，是单一信任域环境的最佳起点。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-1_hu2112316998957829838.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-1.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-1.jpg&#34; data-width=&#34;924&#34; data-height=&#34;366&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;然而，当将单个 SPIRE 服务器部署到跨越区域、平台和云提供商环境的信任域时，当 SPIRE 代理依赖于远处的 SPIRE 服务器时，会出现潜在的扩展问题。在单个部署将跨越多个环境的情况下，解决在单个信任域上使用共享数据存储的解决方案是将 SPIRE 服务器配置为嵌套拓扑结构。&lt;/p&gt;
&lt;h3 id=&#34;嵌套式-spire&#34;&gt;嵌套式 SPIRE&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器的嵌套拓扑结构可使您尽可能保持 SPIRE 代理和 SPIRE 服务器之间的通信。&lt;/p&gt;
&lt;p&gt;在这种配置中，顶级 SPIRE 服务器持有根证书和密钥，而下游服务器请求中间签名证书，作为下游服务器的 X.509 签名授权。如果顶层发生故障，中间服务器继续运行，为拓扑结构提供弹性。&lt;/p&gt;
&lt;p&gt;嵌套拓扑结构很适合多云部署。由于能够混合和匹配节点验证器，下游服务器可以在不同的云提供商环境中驻留并为工作负载和代理提供身份。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-2_hu17713764114228175626.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-2.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-2.jpg&#34; data-width=&#34;1018&#34; data-height=&#34;554&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;虽然嵌套式 SPIRE 是提高 SPIRE 部署的灵活性和可扩展性的理想方式，但它并不提供任何额外的安全性。由于 X.509 没有提供任何方法来限制中间证书颁发机构的权力，每个 SPIRE 服务器可以生成任何证书。即使你的上游证书颁发机构是你公司地下室混凝土掩体中的加固服务器，如果你的 SPIRE 服务器被破坏，你的整个网络可能会受到影响。这就是为什么必须确保每台 SPIRE 服务器都是安全的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-3_hu8353598433001189142.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-3.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-3.jpg&#34; data-width=&#34;1002&#34; data-height=&#34;648&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;spire-联邦&#34;&gt;SPIRE 联邦&lt;/h3&gt;
&lt;p&gt;部署可能需要多个信任根基，也许是因为一个组织有不同的组织部门，有不同的管理员，或者因为他们有独立的暂存和生产环境，偶尔需要沟通。&lt;/p&gt;
&lt;p&gt;另一个用例是组织之间的 SPIFFE 互操作性，如云供应商和其客户之间。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-4_hu7892101676017518050.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-4.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-4.jpg&#34; data-width=&#34;968&#34; data-height=&#34;422&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;这些多个信任域和互操作性用例都需要一个定义明确、可互操作的方法，以便一个信任域中的工作负载能够认证不同信任域中的工作负载。在联合 SPIRE 中，不同信任域之间的信任是通过首先认证各自的捆绑端点，然后通过认证的端点检索外部信任域的捆绑来建立的。&lt;/p&gt;
&lt;h3 id=&#34;独立的-spire-服务器&#34;&gt;独立的 SPIRE 服务器&lt;/h3&gt;
&lt;p&gt;运行 SPIRE 的最简单方法是在专用服务器上，特别是如果有一个单一的信任域，而且工作负载的数量不大。在这种情况下，你可以在同一节点上共同托管一个数据存储，使用 SQLite 或 MySQL 作为数据库，简化部署。然而，当使用共同托管的部署模式时，记得要考虑数据库的复制或备份。如果你失去了节点，你可以迅速在另一个节点上运行 SPIRE 服务器，但如果你失去了数据库，你的所有代理和工作负载都需要重新测试以获得新的身份。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-5_hu144859364326375108.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-5.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-5.jpg&#34; data-width=&#34;1102&#34; data-height=&#34;592&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;避免单点故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保持简单有利也有弊。如果只有一台 SPIRE 服务器，而它丢失了，一切都会丢失，需要重建。拥有一个以上的服务器可以提高系统的可用性。仍然会有一个共享的数据存储和安全连接及数据复制。我们将在本章后面讨论这种决定的不同安全影响。&lt;/p&gt;
&lt;p&gt;要横向扩展 SPIRE 服务器，请将同一信任域中的所有服务器配置为对同一共享数据存储进行读和写。&lt;/p&gt;
&lt;p&gt;数据存储是 SPIRE 服务器保存动态配置信息的地方，如注册条目和身份映射策略。SQLite 与 SPIRE 服务器捆绑在一起，是默认的数据存储。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-6_hu17914341003791562855.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-6.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-6.jpg&#34; data-width=&#34;1042&#34; data-height=&#34;802&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;数据存储建模&#34;&gt;数据存储建模&lt;/h2&gt;
&lt;p&gt;在进行数据存储设计时，你的首要关注点应该是冗余和高可用性。你需要确定每个 SPIRE 服务器集群是否有一个专用的数据存储，或者是否应该有一个共享的数据存储。&lt;/p&gt;
&lt;p&gt;数据库类型的选择可能受到整个系统可用性要求和你的运营团队能力的影响。例如，如果运维团队有支持和扩展 MySQL 的经验，这应该是首要选择。&lt;/p&gt;
&lt;h3 id=&#34;每个集群的专用数据存储&#34;&gt;每个集群的专用数据存储&lt;/h3&gt;
&lt;p&gt;多个数据存储允许系统的每个专用部分更独立。例如，AWS 和 GCP 云中的 SPIRE 集群可能有独立的数据存储，或者 AWS 中的每个 VPC 可能有一个专用数据存储。这种选择的好处是，如果一个地区或云提供商发生故障，在其他地区或云提供商中运行的 SPIRE 部署就不会受到影响。&lt;/p&gt;
&lt;p&gt;在发生重大故障时，每个集群的数据存储的缺点变得最为明显。如果一个地区的 SPIRE 数据存储（以及所有的 SPIRE 服务器）发生故障，就需要恢复本地数据存储，或者将代理切换到同一信任域的另一个 SPIRE 服务器集群上，假设信任域是跨区域的。&lt;/p&gt;
&lt;p&gt;如果有必要将代理切换到一个新的集群，必须特别考虑，因为新的集群将不知道另一个 SPIRE 集群发出的身份，或该集群包含的注册条目。代理将需要对这个新集群进行重新认证，并且需要通过备份或重建来恢复注册条目。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-7_hu398843349753751318.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-7.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-7.jpg&#34; data-width=&#34;1138&#34; data-height=&#34;558&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;共享的数据存储&#34;&gt;共享的数据存储&lt;/h3&gt;
&lt;p&gt;拥有一个共享的数据存储可以解决上述拥有单独数据存储的问题。然而，它可能会使设计和操作更加复杂，并依赖其他系统来检测故障，并在发生故障时更新 DNS 记录。此外，该设计仍然需要为每个 SPIRE 可用域、每个区域或数据中心的数据库基础设施的碎片，这取决于具体的基础设施。请查看 &lt;a href=&#34;https://github.com/spiffe/spire/blob/master/doc/plugin_server_datastore_sql.md&#34; title=&#34;SPIRE 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 文档&lt;/a&gt;以了解更多细节。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-8_hu15639579445884051540.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-8.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-8.jpg&#34; data-width=&#34;1220&#34; data-height=&#34;610&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;管理失败&#34;&gt;管理失败&lt;/h2&gt;
&lt;p&gt;当基础设施发生故障时，主要的问题是如何继续向需要 SVID 才能正常运行的工作负载发放 SVID。SPIRE 代理的 SVID 内存缓存被设计为应对短期宕机的主要防线。&lt;/p&gt;
&lt;p&gt;SPIRE 代理定期从 SPIRE 服务器获取授权发布的 SVID，以便在工作负载需要时将其交付给它们。这个过程是在工作负载请求 SVID 之前完成的。&lt;/p&gt;
&lt;h3 id=&#34;性能和可靠性&#34;&gt;性能和可靠性&lt;/h3&gt;
&lt;p&gt;SVID 缓存有两个优点：性能和可靠性。当工作负载要求获得其 SVID 时，代理不需要请求和等待 SPIRE 服务器提供 SVID，因为它已经有了缓存，这就避免了到 SPIRE 服务器的往返代价。此外，如果 SPIRE 服务器在工作负载请求其 SVID 时不可用，也不会影响 SVID 的发放，因为代理已经将其缓存起来了。&lt;/p&gt;
&lt;p&gt;我们需要对 X509-SVID 和 JWT-SVID 进行区分。JWT-SVID 不能提前构建，因为代理不知道工作负载所需的 JWT-SVID 的具体受众，代理只预先缓存 X509-SVID。然而，SPIRE 代理确实维护着已发布的 JWT-SVID 的缓存，只要缓存的 JWT-SVID 仍然有效，它就可以向工作负载发布 JWT-SVID，而无需与 SPIRE 服务器联系。&lt;/p&gt;
&lt;h3 id=&#34;存活时间&#34;&gt;存活时间&lt;/h3&gt;
&lt;p&gt;SVID 的一个重要属性是其存活时间（TTL）。如果一个 SVID 的剩余寿命小于 TTL 的一半，SPIRE 代理将更新缓存中的 SVID。这向我们表明，SPIRE 在对底层基础设施能够提供 SVID 的信心方面是保守的。它还提供了一个暗示，即 SVID TTL 在抵御中断方面的作用。较长的 TTL 可以提供更多的时间来修复和恢复任何基础设施的中断，但是在选择 TTL 的时候，需要在安全性和可用性之间做出妥协。长的 TTL 将提供充足的时间来修复故障，但代价是在较长的时间内暴露 SVID（及相关密钥）。较短的 TTL 可以减少恶意行为者利用被破坏的 SVID 的时间窗口，但需要更快地对故障作出反应。不幸的是，没有什么 &amp;ldquo;神奇&amp;rdquo; 的 TTL 可以成为所有部署的最佳选择。在选择 TTL 时，必须考虑在必须解决中断问题的时间窗口和已发布的 SVID 的可接受曝光度之间，你愿意接受什么样的权衡。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的-spire&#34;&gt;Kubernetes 中的 SPIRE&lt;/h2&gt;
&lt;p&gt;本节介绍了在 Kubernetes 中运行 SPIRE 的细节。Kubernetes 是一个容器编排器，可以在许多不同的云供应商上管理软件部署和可用性，也可以在物理硬件上管理。SPIRE 包括几种不同形式的 Kubernetes 集成。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-中的-spire-代理&#34;&gt;Kubernetes 中的 SPIRE 代理&lt;/h3&gt;
&lt;p&gt;Kubernetes 包括 DaemonSet 的概念，这是一个自动部署在所有节点上的容器，每个节点有一个副本运行。这是运行 SPIRE 代理的一种完美方式，因为每个节点必须有一个代理。&lt;/p&gt;
&lt;p&gt;随着新的 Kubernetes 节点上线，调度器将自动轮换 SPIRE 代理的新副本。首先，每个代理需要一份引导信任包的副本。最简单的方法是通过 Kubernetes ConfigMap 来分发。&lt;/p&gt;
&lt;p&gt;一旦代理拥有启动信任包，它就必须向服务器证明自己的身份。Kubernetes 提供两种类型的认证令牌：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务账户令牌（SAT）&lt;/li&gt;
&lt;li&gt;预计服务账户令牌（PSAT）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务账户令牌的安全性并不理想，因为它们永远有效，而且范围无限。预测的服务账户令牌要安全得多，但它们确实需要最新版本的 Kubernetes 和一个特殊的功能标志才能启用。SPIRE 支持用于节点证明的 SAT 和 PSAT。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-中的-spire-服务器&#34;&gt;Kubernetes 中的 SPIRE 服务器&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器以两种方式与 Kubernetes 交互。首先，每当它的信任包发生变化时，它必须将信任包发布到 Kubernetes ConfigMap。其次，当代理上线时，它必须使用 &lt;code&gt;TokenReview&lt;/code&gt; API 验证其 SAT 或 PSAT 令牌。这两者都是通过 SPIRE 插件配置的，需要相关的 Kubernetes API 权限。&lt;/p&gt;
&lt;p&gt;SPIRE 服务器可以完全在 Kubernetes 中运行，与工作负载一起。然而，为了安全起见，最好是在一个单独的 Kubernetes 集群上运行，或独立的硬件。这样一来，如果主集群被破坏，SPIRE 的私钥就不会有风险。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-9_hu5950014188506345241.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-9.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-9.jpg&#34; data-width=&#34;660&#34; data-height=&#34;332&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-10_hu6102222425031342058.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-10.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-10.jpg&#34; data-width=&#34;1084&#34; data-height=&#34;588&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h3 id=&#34;kubernetes-工作负载证明&#34;&gt;Kubernetes 工作负载证明&lt;/h3&gt;
&lt;p&gt;SPIRE 代理包括一个 Kubernetes 工作负载验证器插件。该插件首先使用系统调用来识别工作负载的 PID。然后，它使用对 Kubelet 的本地调用来识别工作负载的 pod 名称、镜像和其他特征。这些特征可以作为注册条目的选择器。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-负载条目自动注册&#34;&gt;Kubernetes 负载条目自动注册&lt;/h3&gt;
&lt;p&gt;一个名为 Kubernetes Workload Registrar 的 SPIRE 扩展可以自动创建节点和工作负载注册条目，充当 Kubernetes API 服务器和 SPIRE 服务器之间的桥梁。它支持几种不同的方法来识别正在运行的 pod，并在创建条目方面具有一定的灵活性。&lt;/p&gt;
&lt;h3 id=&#34;增加-sidecar&#34;&gt;增加 Sidecar&lt;/h3&gt;
&lt;p&gt;对于尚未适应使用工作负载 API 的工作负载（见第 7 章：与其他机构的集成中的本地 SPIFFE 支持一节），Kubernetes 可以很容易地添加支持的 sidecar。Sidecar 可以是一个 SPIFFE 感知的代理，比如 Envoy。或者，它可以是一个与 SPIRE 一起开发的 sidecar，名为“SPIFFE Helper&amp;quot;，它监控工作负载 API，并在其 SVID 发生变化时重新配置工作负载。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-11_hu15799656168411006375.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-11.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-11.jpg&#34; data-width=&#34;1288&#34; data-height=&#34;642&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;spire-的性能考虑因素&#34;&gt;SPIRE 的性能考虑因素&lt;/h2&gt;
&lt;p&gt;当连接到服务器的 SPIRE 代理数量增加时，也会给服务器、数据存储和网络本身带来更多的负荷。多个因素都会造成负载，包括节点数量和每个节点的工作负载，以及你轮换秘钥的频率。使用 JWT-SVID 与嵌套的 SPIRE 模型，公钥需要保持同步，这将增加代理和服务器之间需要传输的信息量。&lt;/p&gt;
&lt;p&gt;我们不想对每个代理的工作负载数量或每个服务器的代理数量提出具体的性能要求或建议，因为所有的数据 a）取决于硬件和网络特性，b）变化很快。仅举一例，最新的一个版本将数据的性能提高了 30%。&lt;/p&gt;
&lt;p&gt;正如你在前几章中所了解的，SPIRE 代理不断与服务器进行通信，以获得任何新的变化，如新工作负载的 SVID 或信任包的更新。在每次同步过程中，会有多个数据存储操作。默认情况下，同步时间为 5 秒，如果这对你的系统产生了太多的压力，你可以把它增加到一个更高的值来解决这些问题。&lt;/p&gt;
&lt;p&gt;非常短的 SVID TTL 可以减轻安全风险，但如果你使用非常短的 TTL，要准备好看到你的 SPIRE 服务器的额外负载，因为签名操作的数量与轮换频率成比例增加。&lt;/p&gt;
&lt;p&gt;另一个影响系统性能的关键因素可能是每个节点的工作负载数量。如果你在系统中的所有节点上增加一个新的工作负载，这将突然产生一个峰值，并对整个系统产生负荷。&lt;/p&gt;
&lt;p&gt;如果您的系统严重依赖 JWT-SVID 的使用，请记住，JWT-SVID 不是在代理端预先生成的，需要按要求进行签名。这可能会给 SPIRE 服务器和代理带来额外的负载，并在它们过载时增加延迟。&lt;/p&gt;
&lt;h2 id=&#34;验证器插件&#34;&gt;验证器插件&lt;/h2&gt;
&lt;p&gt;SPIRE 为节点和工作负载认证提供了各种验证器插件。选择使用哪种验证器插件取决于对认证的要求，以及底层基础设施 / 平台提供的可用支持。&lt;/p&gt;
&lt;p&gt;对于工作负载证明，这主要取决于被编排的工作负载的类型。例如，当使用 Kubernetes 集群时，Kubernetes 工作负载验证器将是合适的，同样，OpenStack 平台的 OpenStack 验证器也是如此。&lt;/p&gt;
&lt;p&gt;对于节点认证来说，确定安全和合规的要求是很重要的。有时需要执行工作负载的地理围栏。在这些情况下，使用来自云提供商的节点验证器，可以断言，将提供这些保证。&lt;/p&gt;
&lt;p&gt;在高度管制的行业，可能需要使用基于硬件的认证。这些机制通常依赖于底层基础设施提供支持，如 API 或像可信平台模块（TPM）的硬件模块。这可能包括对系统软件状态的测量，包括固件、内核版本、内核模块，甚至文件系统的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为不同的云平台设计证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在云环境中工作时，根据云提供商提供的元数据验证您的节点身份被认为是一种最佳做法。SPIRE 提供了一种简单的方法，通过专门为您的云设计的自定义节点验证器来实现这一点。大多数云提供商分配了一个 API，可以用来识别 API 调用者。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-12_hu7792818773455355869.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-12.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-12.jpg&#34; data-width=&#34;1316&#34; data-height=&#34;552&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;节点验证器和解析器可用于亚马逊网络服务（AWS）、Azure 和谷歌云平台（GCP）。云环境的节点验证器是特定于该云的。验证器的目的是在向运行在该节点上的 SPIRE 代理发布身份信息之前对节点进行验证。&lt;/p&gt;
&lt;p&gt;一旦建立了一个身份，SPIRE 服务器可能会安装一个 Resolver 插件，允许创建额外的选择器，与节点的元数据相匹配。可用的元数据是针对云的。&lt;/p&gt;
&lt;p&gt;在相反的范围内，如果云提供商不提供验明节点的能力，就有可能用加入令牌进行引导。然而，这提供了一套非常有限的保证，这取决于通过什么程序完成。&lt;/p&gt;
&lt;h2 id=&#34;注册条目的管理&#34;&gt;注册条目的管理&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器支持两种不同的方式来添加注册条目：通过命令行界面或注册 API（只允许管理员访问）。SPIRE 需要注册条目来运作。一种选择是由管理员手动创建。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-13_hu407121345697937896.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-13.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-13.jpg&#34; data-width=&#34;1266&#34; data-height=&#34;650&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;在大型部署或基础设施快速增长的情况下，手动流程将无法扩展。此外，任何手动程序都容易出错，而且可能无法跟踪所有的变化。&lt;/p&gt;
&lt;p&gt;对于有大量注册条目的部署来说，使用自动流程来创建注册条目是一个更好的选择。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-14_hu9154094758984641753.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-14.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-14.jpg&#34; data-width=&#34;1276&#34; data-height=&#34;806&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;h2 id=&#34;将安全考虑因素和威胁建模考虑在内&#34;&gt;将安全考虑因素和威胁建模考虑在内&lt;/h2&gt;
&lt;p&gt;无论你做出什么样的设计和架构决定，都会影响到整个系统的威胁模型，也可能影响到与之互动的其他系统。&lt;/p&gt;
&lt;p&gt;下面是一些重要的安全考虑因素和你在设计阶段应该考虑的安全问题。&lt;/p&gt;
&lt;h3 id=&#34;公钥基础设施pki设计&#34;&gt;公钥基础设施（PKI）设计&lt;/h3&gt;
&lt;p&gt;你的 PKI 的结构是什么，你如何定义你的信任域以建立安全边界，你把你的私钥放在哪里，以及它们多久轮换一次，这些都是你在这一点上需要问自己的关键问题。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-15_hu14086672601463071585.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-15.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-15.jpg&#34; data-width=&#34;1238&#34; data-height=&#34;1168&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;每个组织都会有不同的证书层次，因为每个组织有不同的要求。上图代表了一个潜在的证书层次结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TTL、撤销和更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在处理 PKI 时，围绕证书到期、重新签发和撤销的问题总是浮出水面。有几个考虑因素可以影响这里的决定。这些因素包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件过期 / 重新发行的性能开销&lt;/strong&gt;：可以容忍多少性能开销。TTL 越短，性能开销越大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递送文件的延迟&lt;/strong&gt;：TTL 必须长于身份文件的预期递送延迟，以确保服务在验证自己时不会出现空档。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PKI 生态系统的成熟度&lt;/strong&gt;：是否有撤销机制？它们是否得到维护并保持更新？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组织的风险偏好&lt;/strong&gt;：如果不启用撤销功能，如果身份被破坏并被发现，可接受的有效时间是多少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象的预期寿命&lt;/strong&gt;：根据对象的预期寿命，TTL 不应该被设置为太长的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;爆炸半径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 PKI 设计阶段，考虑其中一个组件的破坏会如何影响基础设施的其他部分是非常重要的。例如，如果你的 SPIRE 服务器将密钥保存在内存中，而服务器被攻破，那么所有下游的 SVID 都需要被取消并重新发行。为了尽量减少这种攻击的影响，你可以设计 SPIRE 基础设施，为不同的网段、虚拟私有云或云供应商提供多个信任域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保存你的私人钥匙的秘密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重要的是你把你的钥匙放在哪里。正如你先前可能已经了解到的，SPIRE 有一个密钥管理器的概念，它管理 CA 密钥。如果你打算把 SPIRE 服务器作为你的 PKI 的根，你可能想让你的根密钥具有持久性，但把它存储在磁盘上并不是一个好主意。&lt;/p&gt;
&lt;p&gt;存储 SPIRE 密钥的解决方案可能是一个软件或硬件密钥管理服务（KMS）。有独立的产品可以作为 KMS，也有每个主要云供应商的内置服务。&lt;/p&gt;
&lt;p&gt;将 SPIRE 与现有 PKI 集成的另一种可能的设计策略是使用 SPIRE 上游授权插件接口。在这种情况下，SPIRE 服务器通过使用支持的插件之一与现有的 PKI 进行通信来签署其中间 CA 证书。&lt;/p&gt;
&lt;h3 id=&#34;spire-数据存储的安全考虑&#34;&gt;SPIRE 数据存储的安全考虑&lt;/h3&gt;
&lt;p&gt;我们有意将 SPIRE 服务器的数据存储从第四章的威胁模型中删除。数据存储是 SPIRE 服务器保存动态配置的地方，如从 SPIRE 服务器 API 检索的注册条目和身份映射策略。SPIRE 服务器数据存储支持不同的数据库系统，它可以作为数据存储使用。数据存储的妥协将允许攻击者在任何节点上注册工作负载，并可能是节点本身。攻击者还将能够将密钥添加到信任捆绑中，并进入下游基础设施的信任链。&lt;/p&gt;
&lt;p&gt;攻击者的另一个可能的表面是对数据库或 SPIRE 服务器连接到数据库的拒绝服务攻击，这将导致对其他基础设施的拒绝服务。&lt;/p&gt;
&lt;p&gt;当你考虑为生产中的 SPIRE 服务器基础设施设计任何数据库时，你不可能使用数据库进程与服务器共存于同一主机的模式。尽管对数据库的有限访问，以及与服务器共存的模式大大限制了攻击面，但它很难在生产环境中扩展。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-16_hu2195629638187252520.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/book/spiffe/designing-a-spire-deployment/f6-16.jpg&#34; data-img=&#34;/book/spiffe/designing-a-spire-deployment/f6-16.jpg&#34; data-width=&#34;1122&#34; data-height=&#34;1038&#34; alt=&#34;image&#34; data-caption=&#34;&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
&lt;/figure&gt;
&lt;p&gt;出于可用性和性能的考虑，SPIRE 数据存储通常会是一个网络连接的数据库。但你应该考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这是一个与其他服务共享的数据库，还有谁可以访问它和管理它？&lt;/li&gt;
&lt;li&gt;SPIRE 服务器将如何对数据库进行认证？&lt;/li&gt;
&lt;li&gt;数据库连接是否允许 TLS 保护的安全通信？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是需要考虑的相关问题，因为 SPIRE 服务器如何连接到数据库在很大程度上决定了整个部署的安全程度。在使用 TLS 和基于密码的认证的情况下，SPIRE 服务器的部署应依靠秘密管理器或 KMS 来保证数据安全。&lt;/p&gt;
&lt;p&gt;在某些部署中，您可能需要添加另一个较低级别的&lt;strong&gt;元 PKI&lt;/strong&gt; 基础设施，使你能够确保与 SPIRE 服务器的所有低级别的依赖性的通信，包括您的配置管理或部署软件。&lt;/p&gt;
&lt;h3 id=&#34;spire-代理配置和信任包&#34;&gt;SPIRE 代理配置和信任包&lt;/h3&gt;
&lt;p&gt;你分配和部署 SPIRE 生态系统组件的方式，以及它在你的环境中的配置可能会对你的威胁模型和整个系统的安全模型产生严重的影响。这不仅是 SPIRE 的低级依赖，也是你所有安全系统的低级依赖，所以这里我们只关注 SPIFFE 和 SPIRE 特有的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信任包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有不同的方法来交付代理的&lt;strong&gt;引导信任包（bootstrap trust bundle）&lt;/strong&gt;。这是代理在最初启动时使用的信任包，以便对 SPIRE 服务器进行验证。如果攻击者能够将密钥添加到初始信任包中并进行中间人攻击，那么它将对工作负载进行同样的攻击，因为它们从受害代理那里接收 SVID 和信任包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理的配置也需要保持安全。如果攻击者可以修改这个配置文件，那么他们可以将其指向被攻击的 SPIRE 服务器并控制代理。&lt;/p&gt;
&lt;h3 id=&#34;节点验证器插件的影响&#34;&gt;节点验证器插件的影响&lt;/h3&gt;
&lt;p&gt;通过多个独立的机制来证明信任，可以提供更大的信任断言。你选择的节点证明可能会大大影响你的 SPIRE 部署的安全性，并将它的信任根基转向另一个系统。当决定使用什么类型的证明时，你应该把它纳入你的威胁模型，并在每次发生变化时审查该模型。&lt;/p&gt;
&lt;p&gt;例如，任何其他基于占有证明的证明都会转移信任的根基，所以你要确保你作为下级依赖的系统符合你的组织的安全和可用性标准。&lt;/p&gt;
&lt;p&gt;当设计一个使用加入令牌的证明模式的系统时，仔细评估添加和使用令牌的操作程序，无论是由操作者还是供应系统。&lt;/p&gt;
&lt;h3 id=&#34;遥测和健康检查&#34;&gt;遥测和健康检查&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器和代理都支持健康检查和不同类型的遥测。启用或错误配置健康检查和遥测可能会增加 SPIRE 基础设施的攻击面，这一点可能并不明显。SPIFFE 和 SPIRE 威胁模型假设代理只通过本地 Unix 套接字暴露工作负载 API 接口。该模型没有考虑到错误配置（或有意配置）的健康检查服务监听不在本地主机上，可能会使代理暴露于潜在的攻击，如 DoS、RCE 和内存泄漏。在选择遥测集成模型时，最好采取类似的预防措施，因为一些遥测插件（如 Prometheus）可能会暴露出额外的端口。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
