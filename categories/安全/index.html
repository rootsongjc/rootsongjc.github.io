<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>安全专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="在开源专栏中，我将分享关于云原生安全相关的内容。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/%E5%AE%89%E5%85%A8/" />
  <meta property="og:title" content="安全专栏 | Jimmy Song" />
  <meta property="twitter:title" content="安全专栏 | Jimmy Song" />

  
  <meta property="og:description" content="在开源专栏中，我将分享关于云原生安全相关的内容。" />
  <meta property="twitter:description" content="在开源专栏中，我将分享关于云原生安全相关的内容。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    安全专栏
                </p>
                <p class="page-description">
                    在开源专栏中，我将分享关于云原生安全相关的内容。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/cilium-native-authentication/">[译] 解密 Cilium 原生认证功能</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/08/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://blog.teknews.cloud/aks/security/network/2024/07/30/About_Cilium_native_authentication_feature.html" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('解密 Cilium 原生认证功能', '在本文中，我们更深入地探讨了 Cilium 的功能，特别是它从服务网格获得的相互认证功能。', '\n我们已经讨论了 Cilium 一段时间了，但是这个话题有很多值得关注的地方，我们知道我们会再次回到这个话题。今天，我建议我们探索一个用于认证工作负载的功能。在讨论这个话题之前，我们需要一些定义。\n\n我们的议程将按照以下顺序进行：\n\n1. 了解 Cilium 认证功能\n2. 尝试认证功能\n\n## Cilium 认证功能\n\n### 为什么我们需要认证\n\n在基于微服务的架构中，安全是一个巨大的话题。在 Kubernetes 环境中，我们可以查看网络，并通过限制只允许必要端口和协议的流量来实施最小权限原则。在这种情况下，我们可以依赖网络策略。例如，这个策略拒绝 \u0060basic\u0060 命名空间中的所有入站流量：\n\n\u0060\u0060\u0060yaml\nkind: NetworkPolicy\napiVersion: networking.k8s.io\/v1\nmetadata:\n  name: default-deny-all\n  namespace: basics\nspec:\n  podSelector: {}\n  ingress: []\n\u0060\u0060\u0060\n\n这个策略仅允许标有 \u0060app=userprofile\u0060 标签的 pod 在端口 \u00608082\u0060 上从带有标签 \u0060tier=front\u0060 和 \u0060app=tripsinsights\u0060 的命名空间中的 pod 接收流量。\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-tripviewer-ingress-apiprofile\n  namespace: api\nspec:\n  podSelector: \n    matchLabels:\n      app: userprofile\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          tier: front\n          app: tripinsights\n    ports:\n    - protocol: TCP\n      port: 8082   \n\u0060\u0060\u0060\n\n但这可能还不够，全局管理也相当困难，这是分布式安全的悖论。\n\n我们在之前的文章中谈到了服务网格，其目的是为网络流量提供一个集中的控制平面。我们还看到，在标准化的倡议中，我们有一些特定的流量控制对象，其中包括了认证功能。\n\n\u0060\u0060\u0060yaml\napiVersion: access.smi-spec.io\/v1alpha4\nkind: IdentityBinding\nmetadata:\n name: service-a\n namespace: default\nspec:\n schemes:\n   podLabelSelector:\n    matchLabels:\n      app: service-a\n   spiffeIdentities:\n     - \u0022cluster.local\/ns\/default\/sa\/service-a\u0022\n     - \u0022federated.trustdomain\/boundary\/boundaryName\/identifierType\/identifier\u0022\n   serviceAccount: service-a\n\u0060\u0060\u0060\n\n我们将在 Cilium 服务网格中，尤其是基于身份的安全性方面探讨这一点。在基础设施层拥有这样的功能是有趣的，因为应用层不总是能够包含认证功能，尤其是当我们考虑多服务时。最多，不幸的是，我们可能在前端获得认证，但不会更多。这里，我们提出了增加基于身份的安全性的建议。\n\n让我们看看它是如何工作的。\n\n### Cilium 认证功能的底层原理\n\n认证意味着，某种程度上，身份。正如之前在 smi 规范中暗示的，并在 [Cilium 文档](https:\/\/docs.cilium.io\/en\/stable\/network\/servicemesh\/mutual-authentication\/mutual-authentication\/#identity-management)中记录的，所使用的技术是 [SPIFFE](https:\/\/spiffe.io\/)，即每个人的安全生产身份框架。它也是 [CNCF](https:\/\/www.cncf.io\/projects\/spiffe\/) 中的一个毕业项目，自 2022 年 8 月以来。Spiffe 规范在一个 [专用的 github](https:\/\/github.com\/spiffe\/spiffe)上定义。\n\n此时，我们将在 github 仓库中描述的 SPIFFE 标准的高层概述，其中包括：\n\n- SPIFFE ID，一个结构化的字符串（表示为 URI），用作实体的“名称”。\n- SPIFFE 可验证身份文档（SVID）是携带 SPIFFE ID 的文档。它是护照的功能等同物 - 一个携带提供者身份的文档。\n- 工作负载 API 是工作负载或计算过程获取其 SVID 的方法。它通常在本地暴露（例如，通过 Unix 域套接字），并且明确不包括来自工作负载的认证握手或认证令牌。\n\n此外，重要的是要提到信任域，这是一个身份命名空间，由一组加密密钥支持的发行机构支持。这些密钥共同作为居住在信任域中的所有身份的加密锚点。\n\n再次强调，由于 SPIFFE 是一组规范，所有这些概念\/标准实际上都在 [github 仓库](https:\/\/github.com\/spiffe\/spiffe\/tree\/main\/standards)中详细说明。\n\n现在我们知道了规范和标准，但还有很多工作要做，因为，毕竟，这只是规范。幸运的是，还有 [SPIRE 项目](https:\/\/spiffe.io\/docs\/latest\/spire-about\/spire-concepts\/)，[另一个毕业的 CNCF 项目](https:\/\/www.cncf.io\/projects\/spire\/)，这是 SPIFFE 规范的一个生产就绪实现。\n\n在 Cilium 中，SPIFFE 的实现基于 SPIRE 中央服务器。这个 SPIRE 服务器扮演我们之前在规范和标准中提到的信任域的角色。它与每个节点的 SPIRE 代理一起工作，这些代理从服务器获取自己的身份，然后验证工作负载的身份请求。\n\n要了解 SPIRE 是如何工作的，我们需要再次一些概念：\n\n- **工作负载注册**是 SPIRE 将能够识别所述工作负载的过程。它告诉 SPIRE 如何识别工作负载以及给它分配哪个 SPIFFE ID。\n- SPIRE 实现工作负载的**认证**，即断言其身份，通过收集来自工作负载和运行 SPIRE 代理的节点的属性。还值得注意的是，认证是由称为 *认证器* 的软件完成的。在我们的案例中，我们将有一个 Kubernetes 认证器用于托管在 Kubernetes 上的工作负载，但也有节点认证器用于需要首先注册的 SPIRE 代理，然后才能进行工作负载认证。在 Azure 上，节点认证\/注册依赖于具有托管身份的 Azure VMs。\n\n节点认证遵循以下步骤：\n\n1. 代理节点认证器插件查询平台以获取节点身份的证明，并将该信息提供给代理。\n2. 代理将这个身份证明传递给服务器。服务器将这些数据传递给其节点认证器。\n3. 服务器节点认证器通过调用平台 API 验证身份证明，使用它在第 2 步中获得的信息。节点认证器还为代理创建一个 SPIFFE ID，并将此 ID 以及它发现的任何节点选择器一起传回服务器进程。\n4. 服务器为代理节点发送回一个 SVID。\n\n![图 1：节点认证流程](nodeattestation.webp)\n\n一个请求身份的工作负载遵循以下步骤：\n\n1. 它调用代理公开的工作负载 API 请求一个 SVID。\n2. 代理询问调用工作负载认证器插件，向其提供有关工作负载的信息。\n3. 工作负载认证器通过查询邻近的平台特定组件（如 Kubernetes kubelet）发现有关工作负载的额外信息。\n4. 认证器将发现的信息以选择器的形式返回给代理。\n5. 代理通过将发现的选择器与注册条目进行比较来确定工作负载的身份，并将正确的缓存 SVID 返回给工作负载。\n\n![图 2：工作负载认证流程](wlattest.webp)\n\n好了，这就是这个概述的全部内容。SPIFFE 规范中还有更多细节，我只能建议进行更彻底的阅读以获得更好的理解。让我们看看当我们在 AKS 集群中部署时情况如何。\n\n## 尝试 Cilium 认证\n\n### 准备环境\n\n为了尝试这个功能，我们将使用一个仅包含 AKS 集群及其默认节点池的环境，位于虚拟网络中。\n\n**shcemainfra**\n\n认证需要在安装 Cilium 时指定，参数 \u0060authentication.mutual.spire.enabled\u0060 和 \u0060authentication.mutual.spire.install.enabled\u0060 必须设置为 true。\n\n我们使用的 Helm 参数的完整列表如下所示\n\n| Helm 参数                                   | 值                                                           | 描述                                                         |\n| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| hubble.relay.enabled                        | true                                                         | 启用 Hubble Relay                                            |\n| hubble.ui.enabled                           | true                                                         | 是否启用 Hubble UI                                           |\n| aksbyocni.enabled                           | true                                                         | 启用 AKS BYOCNI 集成。注意，这与未在 BYOCNI 模式下创建的 AKS 集群不兼容：改用 Azure 集成（azure.enabled）。 |\n| nodeinit.enabled                            | true                                                         | 启用节点初始化 DaemonSet                                     |\n| kubeProxyReplacement                        | true                                                         | 替换 kubeproxy                                               |\n| k8sServiceHost                              | “\u0022                                                           | Kubernetes 服务主机 - 使用“auto”从集群信息 ConfigMap 中自动查找（仅限基于 kubeadm 的集群） |\n| k8sServicePort                              | 443                                                          | Kubernetes 服务端口                                          |\n| cluster.id                                  | 1                                                            | 集群的唯一 ID。必须在所有连接的集群中是唯一的，并且在 1 到 255 的范围内。只有在使用 Cluster Mesh 时才需要，如果不使用 Cluster Mesh 可以为 0。 |\n| cluster.name                                | “\u0022                                                           | 集群的名称。只有在使用 Cluster Mesh 和与 SPIRE 的互相认证时才需要。它必须满足以下限制：* 最多包含 32 个字符；* 必须以小写字母或数字字符开头和结尾；* 之间可以包含小写字母或数字字符和破折号。如果集群 ID 不同于 0，则不能使用“default”名称。 |\n| azure.resourceGroup                         | “\u0022                                                           | AKS 资源组                                                   |\n| ipam.operator.clusterPoolIPv4PodCIDRList    | “{Ip_Range}”                                                 | PoolIPv4PodCIDRList 列表 [“10.0.0.0\/8”] IPv4 CIDR 范围列表，分配给单个节点用于 IPAM。 |\n| prometheus.enabled                          | true                                                         | 启用 prometheus 指标                                         |\n| operator.prometheus.enabled                 | true                                                         | 启用以 OpenMetrics 格式导出 hubble 指标。                    |\n| hubble.metrics.enableOpenMetrics            | false                                                        | 启用以 OpenMetrics 格式导出 hubble 指标。                    |\n| hubble.metrics.enabled                      | “{dns,drop,tcp,flow,port-distribution,icmp,httpV2:exemplars=true;labelsContext=source_ip,source_namespace,source_workload,destination_ip,destination_namespace,destination_workload,traffic_direction}” | 配置要收集的指标列表。如果为空或 null，则禁用指标。示例：enabled: - dns:query;ignoreAAAA - drop - tcp - flow - icmp - http 您可以从 helm CLI 指定指标列表：–set hubble.metrics.enabled=”{dns:query;ignoreAAAA,drop,tcp,flow,icmp,http}” |\n| authentication.mutual.spire.enabled         | true                                                         | mutual.spire.enabled bool false 启用 SPIRE 集成（beta）      |\n| authentication.mutual.spire.install.enabled | true                                                         | ion.mutual.spire.install.enabled bool true 启用 SPIRE 安装。这将仅在 authentication.mutual.spire.enabled 为 true 时生效 |\n\n安装完成后，我们可以查看 Cilium 的状态。\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ cilium status\n    \/¯¯\\\n \/¯¯\\__\/¯¯\\    Cilium:             OK\n \\__\/¯¯\\__\/    Operator:           OK\n \/¯¯\\__\/¯¯\\    Envoy DaemonSet:    OK\n \\__\/¯¯\\__\/    Hubble Relay:       OK\n    \\__\/       ClusterMesh:        disabled\n\nDeployment             hubble-ui          Desired: 1, Ready: 1\/1, Available: 1\/1\nDaemonSet              cilium-envoy       Desired: 3, Ready: 3\/3, Available: 3\/3\nDaemonSet              cilium             Desired: 3, Ready: 3\/3, Available: 3\/3\nDeployment             hubble-relay       Desired: 1, Ready: 1\/1, Available: 1\/1\nDeployment             cilium-operator    Desired: 2, Ready: 2\/2, Available: 2\/2\nContainers:            cilium             Running: 3\n                       hubble-ui          Running: 1\n                       cilium-envoy       Running: 3\n                       cilium-operator    Running: 2\n                       hubble-relay       Running: 1\nCluster Pods:          29\/29 managed by Cilium\nHelm chart version:    1.16.0\nImage versions         cilium             quay.io\/cilium\/cilium:v1.16.0@sha256:46ffa4ef3cf6d8885dcc4af5963b0683f7d59daa90d49ed9fb68d3b1627fe058: 3\n                       hubble-ui          quay.io\/cilium\/hubble-ui:v0.13.1@sha256:e2e9313eb7caf64b0061d9da0efbdad59c6c461f6ca1752768942bfeda0796c6: 1\n                       hubble-ui          quay.io\/cilium\/hubble-ui-backend:v0.13.1@sha256:0e0eed917653441fded4e7cdb096b7be6a3bddded5a2dd10812a27b1fc6ed95b: 1\n                       cilium-envoy       quay.io\/cilium\/cilium-envoy:v1.29.7-39a2a56bbd5b3a591f69dbca51d3e30ef97e0e51@sha256:bd5ff8c66716080028f414ec1cb4f7dc66f40d2fb5a009fff187f4a9b90b566b: 3\n                       cilium-operator    quay.io\/cilium\/operator-generic:v1.16.0@sha256:d6621c11c4e4943bf2998af7febe05be5ed6fdcf812b27ad4388f47022190316: 2\n                       hubble-relay       quay.io\/cilium\/hubble-relay:v1.16.0@sha256:33fca7776fc3d7b2abe08873319353806dc1c5e07e12011d7da4da05f836ce8d: 1\n\u0060\u0060\u0060\n\n我们还可以查看其他 Kubernetes 对象：\n\n- 一个 SPIRE 服务器的部署\n- 在每个节点上运行的代理的守护进程集。\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ k get all -n cilium-spire \nNAME                    READY   STATUS    RESTARTS   AGE\npod\/spire-agent-65sh2   1\/1     Running   0          7h2m\npod\/spire-agent-hqnsm   1\/1     Running   0          7h2m\npod\/spire-agent-lcqrz   1\/1     Running   0          7h2m\npod\/spire-server-0      2\/2     Running   0          24h\n\nNAME                   TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE\nservice\/spire-server   ClusterIP   100.65.61.5   \u003cnone\u003e        8081\/TCP   27h\n\nNAME                         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE\ndaemonset.apps\/spire-agent   3         3         3       3            3           \u003cnone\u003e          27h\n\nNAME                            READY   AGE\nstatefulset.apps\/spire-server   1\/1     27h\n\u0060\u0060\u0060\n\n在进行一些测试之前，让我们看看我们的 SPIRE 服务器。我们可以在[相应文档](https:\/\/docs.cilium.io\/en\/stable\/network\/servicemesh\/mutual-authentication\/mutual-authentication-example\/)中找到查看它的命令。\n\n首先我们可以检查 SPIRE 服务器的健康状况：\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server healthcheck\nServer is healthy.\n\u0060\u0060\u0060\n\n然后我们可以看看 SPIRE 代理及其认证状态。因为我们有 3 个节点，所以在守护进程集中有 3 个 pod\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ k get ds -n cilium-spire \nNAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE\nspire-agent   3         3         3       3            3           \u003cnone\u003e          27h\n\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server agent list\nFound 3 attested agents:\n\nSPIFFE ID         : spiffe:\/\/spiffe.cilium\/spire\/agent\/k8s_psat\/cluster1\/c0c6afc3-1e0a-4ffb-b61e-18442b04123d\nAttestation type  : k8s_psat\nExpiration time   : 2024-07-30 17:27:15 \u002b0000 UTC\nSerial number     : 8338212869267325996294354393424215766\nCan re-attest     : true\n\nSPIFFE ID         : spiffe:\/\/spiffe.cilium\/spire\/agent\/k8s_psat\/cluster1\/08af80d6-0166-4f46-b575-0aa0dc6a5152\nAttestation type  : k8s_psat\nExpiration time   : 2024-07-30 17:27:15 \u002b0000 UTC\nSerial number     : 317183292034746089049553637864798125627\nCan re-attest     : true\n\nSPIFFE ID         : spiffe:\/\/spiffe.cilium\/spire\/agent\/k8s_psat\/cluster1\/bdd0dfa9-20ec-4f24-a82f-c646754588ce\nAttestation type  : k8s_psat\nExpiration time   : 2024-07-30 17:27:15 \u002b0000 UTC\nSerial number     : 215301213544348190052950735212628656167\nCan re-attest     : true\n\u0060\u0060\u0060\n\n接下来我们可以检查 SPIFFE 身份。\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server entry show -parentID spiffe:\/\/spiffe.cilium\/ns\/cilium-spire\/sa\/spire-agent\nFound 2 entries\nEntry ID         : 53b6506b-ebe3-4cd8-89b4-9647fa535c37\nSPIFFE ID        : spiffe:\/\/spiffe.cilium\/cilium-agent\nParent ID        : spiffe:\/\/spiffe.cilium\/ns\/cilium-spire\/sa\/spire-agent\nRevision         : 0\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:ns:kube-system\nSelector         : k8s:sa:cilium\n\nEntry ID         : 8c361104-31a1-480e-b97d-83673a63ce72\nSPIFFE ID        : spiffe:\/\/spiffe.cilium\/cilium-operator\nParent ID        : spiffe:\/\/spiffe.cilium\/ns\/cilium-spire\/sa\/spire-agent\nRevision         : 0\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:ns:kube-system\n\u0060\u0060\u0060\n### 使用相互认证\n\n现在让我们部署一些工作负载。为了简单起见，我们将创建一系列基于 nginx 的部署：\n\n一个目标应用：\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: demodeployment\n  name: demodeployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: demodeployment\n  strategy: {}\n  template:\n    metadata:\n      labels:\n        app: demodeployment\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n        resources: {}\nstatus: {}\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: demodeployment\n  name: demodeployment\nspec:\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  selector:\n    app: demodeployment\nstatus:\n  loadBalancer: {}\n\u0060\u0060\u0060\n\n以及客户端：\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: client1\n  name: client1\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: client1\n  strategy: {}\n  template:\n    metadata:\n      labels:\n        app: client1\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n        resources: {}\nstatus: {}\n---\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: client2\n  name: client2\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: client2\n  strategy: {}\n  template:\n    metadata:\n      labels:\n        app: client2\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n        resources: {}\nstatus: {}\n\u0060\u0060\u0060\n\n如果我们查看 Cilium 端点，我们应该能看到关联身份的信息：\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ k get ciliumendpoint -o wide\nNAME                             SECURITY IDENTITY   INGRESS ENFORCEMENT   EGRESS ENFORCEMENT   VISIBILITY POLICY   ENDPOINT STATE   IPV4           IPV6\nclient1-599c487979-dqm4v         76513                                                                              ready            100.64.1.197   \nclient1-599c487979-qqzvl         76513                                                                              ready            100.64.0.206   \nclient1-599c487979-t8728         76513                                                                              ready            100.64.2.214   \nclient2-d64dd865b-cj56m          77602                                                                              ready            100.64.0.77    \nclient2-d64dd865b-kb7cs          77602                                                                              ready            100.64.1.51    \nclient2-d64dd865b-qskqc          77602                                                                              ready            100.64.2.25    \ndemodeployment-bf5d895b5-6s4xn   108597                                                                             ready            100.64.0.124   \ndemodeployment-bf5d895b5-pmzkm   108597                                                                             ready            100.64.1.244   \ndemodeployment-bf5d895b5-vz4gq   108597                                                                             ready            100.64.2.127   \n\u0060\u0060\u0060\n\n使用安全身份值，我们可以在 SPIRE 服务器上检查相应的身份。我们将使用 \u0060\u0027{.items[0].status.identity.id}\u0027\u0060 作为 jsonpath 值来提取安全身份作为变量。\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ k get deployment --show-labels \nNAME             READY   UP-TO-DATE   AVAILABLE   AGE   LABELS\nclient1          3\/3     3            3           14h   app=client1\nclient2          3\/3     3            3           14h   app=client2\ndemodeployment   3\/3     3            3           15h   app=demodeployment\nyumemaru@azure:~$ export client1=$(k get ciliumendpoints.cilium.io -l app=client1 -o=jsonpath=\u0027{.items[0].status.identity.id}\u0027)id}\u0027)\nyumemaru@azure:~$ export client2Id=$(k get ciliumendpoints.cilium.io -l app=client2 -o=jsonpath=\u0027{.items[0].status.identity.id}\u0027)\nyumemaru@azure:~$ export demoId=$(k get ciliumendpoints.cilium.io -l app=demodeployment -o=jsonpath=\u0027{.items[0].status.identity.id}\u0027)\n\u0060\u0060\u0060\n\n在 SPIRE 服务器 pod 内部，我们现在可以检查每个工作负载对应的身份：\n\n\u0060\u0060\u0060bash\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server entry show -spiffeID spiffe:\/\/spiffe.cilium\/identity\/$client1Id\nFound 1 entry\nEntry ID         : 7bf9a3b0-a06c-480e-8f0c-1fd654d3ec56\nSPIFFE ID        : spiffe:\/\/spiffe.cilium\/identity\/76513\nParent ID        : spiffe:\/\/spiffe.cilium\/cilium-operator\nRevision         : 0\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : cilium:mutual-auth\n\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server entry show -spiffeID spiffe:\/\/spiffe.cilium\/identity\/$client2Id\nFound 1 entry\nEntry ID         : 62b158d0-c90b-449a-9b30-a8a24ba012ba\nSPIFFE ID        : spiffe:\/\/spiffe.cilium\/identity\/77602\nParent ID        : spiffe:\/\/spiffe.cilium\/cilium-operator\nRevision         : 0\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : cilium:mutual-auth\n\nyumemaru@azure:~$ kubectl exec -n cilium-spire spire-server-0 -c spire-server -- \/opt\/spire\/bin\/spire-server entry show -spiffeID spiffe:\/\/spiffe.cilium\/identity\/$demoId\nFound 1 entry\nEntry ID         : 07f27f3c-7a94-450b-aecc-bb006f57b97e\nSPIFFE ID        : spiffe:\/\/spiffe.cilium\/identity\/108597\nParent ID        : spiffe:\/\/spiffe.cilium\/cilium-operator\nRevision         : 0\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : cilium:mutual-auth\n\u0060\u0060\u0060\n\n但也可以直接作为 cilium api 对象查看身份。以下是 \u0060client1\u0060 应用的结果：\n\n\u0060\u0060\u0060bash\nyumemary@azure:~$ k describe ciliumidentities.cilium.io $client1Id \nName:         76513\nNamespace:    \nLabels:       app=client1\n              io.cilium.k8s.policy.cluster=cluster1\n              io.cilium.k8s.policy.serviceaccount=default\n              io.kubernetes.pod.namespace=default\nAnnotations:  \u003cnone\u003e\nAPI Version:  cilium.io\/v2\nKind:         CiliumIdentity\nMetadata:\n  Creation Timestamp:  2024-07-30T16:46:43Z\n  Generation:          1\n  Resource Version:    224640\n  UID:                 433dd70b-58ba-41c0-abef-c9d5785eaddb\nSecurity - Labels:\n  k8s:app:                                                         client1\n  k8s:io.cilium.k8s.namespace.labels.kubernetes.io\/metadata.name:  default\n  k8s:io.cilium.k8s.policy.cluster:                                cluster1\n  k8s:io.cilium.k8s.policy.serviceaccount:                         default\n  k8s:io.kubernetes.pod.namespace:                                 default\nEvents:                                                            \u003cnone\u003e\n\u0060\u0060\u0060\n\n我们会注意到 Cilium 身份名称、Cilium 端点上显示的安全身份和我们在 SPIRE 服务器上得到的 SPIFFE ID \u0060spiffe:\/\/spiffe.cilium\/identity\/76513\u0060 之间的对应关系。\n\n那很好。现在，我们如何强制执行相互认证呢？实际上很简单，我们只需要在 Cilium 网络策略中添加适当的参数：\n\n\u0060\u0060\u0060yaml\nauthentication:\n    mode: \u0022required\u0022\n\u0060\u0060\u0060\n\n让我们编写 3 个网络策略：\n\n- 首先，按应有的方式，一个拒绝所有策略。\n\n\u0060\u0060\u0060yaml\napiVersion: \u0022cilium.io\/v2\u0022\nkind: CiliumNetworkPolicy\nmetadata:\n  name: \u0022demo1-default-deny\u0022\n  namespace: default\nspec:\n  description: \u0022Default-deny ingress policy for demo app\u0022\n  endpointSelector:\n    matchLabels:\n      app: demodeployment\n  ingress:\n  - {}\n\u0060\u0060\u0060\n\n- 其次，一个允许 app1 流量到 demo 应用的策略。\n- 第三，一个网络策略允许 app2 到 demo 应用，但这次需要认证。\n\n如果我们仅应用第一个策略，我们应该无法再访问 demo 应用。这可以通过 \u0060hubble observe\u0060 命令看到\n\n\u0060\u0060\u0060bash\nyumemary@azure:~$ k exec deployments\/client1 -- curl -i -X GET http:\/\/demodeployment\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:--  0:02:09 --:--:--     0\ncurl: (28) Failed to connect to demodeployment port 80 after 129180 ms: Couldn\u0027t connect to server\ncommand terminated with exit code 28\nyumemary@azure:~$ hubble observe --to-label app=demodeployment\nJul 31 09:54:42.541: default\/client1-599c487979-t8728:54548 (ID:76513) -\u003e default\/demodeployment-bf5d895b5-pmzkm:80 (ID:108597) to-overlay FORWARDED (TCP Flags: SYN)\n\u0060\u0060\u0060\n\n然而，我们仍然可以访问 client2 部署的一个 pod，因为我们只针对其标签的 demo 应用。\n\n\u0060\u0060\u0060bash\nyumemary@azure:~$ k get pod -o custom-columns=Name:.metadata.name,PodIp:.status.podIP,HostIp:.status.hostIP\nName                             PodIp          HostIp\nclient1-599c487979-dqm4v         100.64.1.197   172.21.14.69\nclient1-599c487979-qqzvl         100.64.0.206   172.21.14.68\nclient1-599c487979-t8728         100.64.2.214   172.21.14.70\nclient2-d64dd865b-cj56m          100.64.0.77    172.21.14.68\nclient2-d64dd865b-kb7cs          100.64.1.51    172.21.14.69\nclient2-d64dd865b-qskqc          100.64.2.25    172.21.14.70\nclient3-6fbfd96c6f-bwhqh         100.64.1.150   172.21.14.69\nclient3-6fbfd96c6f-cfhhv         100.64.0.91    172.21.14.68\nclient3-6fbfd96c6f-wldx5         100.64.2.95    172.21.14.70\ndemodeployment-bf5d895b5-6s4xn   100.64.0.124   172.21.14.68\ndemodeployment-bf5d895b5-pmzkm   100.64.1.244   172.21.14.69\ndemodeployment-bf5d895b5-vz4gq   100.64.2.127   172.21.14.70\nyumemary@azure:~$ k exec deployments\/client1 -- curl -i -X GET http:\/\/100.64.2.25\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   615  100   615    0     0   499k      0 --:--:-- --:--:-- --:--:--  600k\nHTTP\/1.1 200 OK\nServer: nginx\/1.27.0\nDate: Wed, 31 Jul 2024 10:01:58 GMT\nContent-Type: text\/html\nContent-Length: 615\nLast-Modified: Tue, 28 May 2024 13:22:30 GMT\nConnection: keep-alive\nETag: \u00226655da96-267\u0022\nAccept-Ranges: bytes\n\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003ctitle\u003eWelcome to nginx!\u003c\/title\u003e\n\u003cstyle\u003e\nhtml { color-scheme: light dark; }\nbody { width: 35em; margin: 0 auto;\nfont-family: Tahoma, Verdana, Arial, sans-serif; }\n\u003c\/style\u003e\n\u003c\/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eWelcome to nginx!\u003c\/h1\u003e\n\u003cp\u003eIf you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.\u003c\/p\u003e\n\n\u003cp\u003eFor online documentation and support please refer to\n\u003ca href=\u0022http:\/\/nginx.org\/\u0022\u003enginx.org\u003c\/a\u003e.\u003cbr\/\u003e\nCommercial support is available at\n\u003ca href=\u0022http:\/\/nginx.com\/\u0022\u003enginx.com\u003c\/a\u003e.\u003c\/p\u003e\n\n\u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c\/em\u003e\u003c\/p\u003e\n\u003c\/body\u003e\n\u003c\/html\u003e\n\u0060\u0060\u0060\n\n### 实施策略 2 和 3\n\n现在我们来从客户端 1 和客户端 2 使用命令 \u0060kubectl exec deployments\/\u003cdeploymentname\u003e -- curl -i -X GET http:\/\/demodeployment\u0060 访问 demo 应用，我们可以通过 hubble 观察到客户端 1 的流量被授权：\n\n\u0060\u0060\u0060bash\nyumemary@azure:~$ hubble observe --to-label app=demodeployment --from-label app=client1\nJul 31 11:33:48.647: default\/client1-599c487979-t8728:54594 (ID:76513) \u003c\u003e default\/demodeployment-bf5d895b5-vz4gq (ID:108597) pre-xlate-rev TRACED (TCP)\nJul 31 11:33:48.647: default\/client1-599c487979-t8728 (ID:76513) \u003c\u003e default\/demodeployment-bf5d895b5-vz4gq:80 (ID:108597) post-xlate-fwd TRANSLATED (TCP)\nJul 31 11:33:48.647: default\/client1-599c487979-t8728:54594 (ID:76513) -\u003e default\/demodeployment-bf5d895b5-vz4gq:80 (ID:108597) policy-verdict:L3-L4 INGRESS ALLOWED (TCP Flags: SYN)\nJul 31 11:33:48.647: default\/client1-599c487979-t8728:54594 (ID:76513) -\u003e default\/demodeployment-bf5d895b5-vz4gq:80 (ID:108597) to-endpoint FORWARDED (TCP Flags: SYN)\nJul 31 11:33:48.647: default\/client1-599c487979-t8728:54594 (ID:76513) -\u003e default\/demodeployment-bf5d895b5-vz4gq:80 (ID:108597) to-endpoint FORWARDED (TCP Flags: ACK)\n\u0060\u0060\u0060\n\n以及客户端 2 的认证步骤：\n\n\u0060\u0060\u0060bash\nyumemary@azure:~$ hubble observe --to-label app=demodeployment --from-label app=client2\nJul 31 11:35:18.651: default\/client2-d64dd865b-qskqc (ID:77602) \u003c\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) post-xlate-fwd TRANSLATED (TCP)\nJul 31 11:35:18.651: default\/client2-d64dd865b-qskqc:50986 (ID:77602) -\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) to-overlay FORWARDED (TCP Flags: SYN)\nJul 31 11:35:18.651: default\/client2-d64dd865b-qskqc:50986 (ID:77602) \u003c\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) policy-verdict:L3-L4 INGRESS DENIED (TCP Flags: SYN; Auth: SPIRE)\nJul 31 11:35:18.651: default\/client2-d64dd865b-qskqc:50986 (ID:77602) \u003c\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) Authentication required DROPPED (TCP Flags: SYN)\nJul 31 11:35:19.661: default\/client2-d64dd865b-qskqc:50986 (ID:77602) -\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) policy-verdict:L3-L4 INGRESS ALLOWED (TCP Flags: SYN; Auth: SPIRE)\nJul 31 11:35:19.661: default\/client2-d64dd865b-qskqc:50986 (ID:77602) -\u003e default\/demodeployment-bf5d895b5-6s4xn:80 (ID:108597) to-endpoint FORWARDED (TCP Flags: SYN)\n\u0060\u0060\u0060\n\n到此为止就是所有的内容了。让我们来总结一下。\n\n## 总结\n\n在本文中，我们更深入地探讨了 Cilium 的功能，特别是它从服务网格获得的相互认证功能。这一功能依赖于实现 SPIFFE 框架的 SPIRE 服务器部署。之后，实际上非常简单。网络策略中的简单规范确保了工作负载间的身份验证。而且在 hubble 上也很容易看到这一点。下一步应该是在 hubble 部分以及 SPIRE 服务器上配置更多的监控。这就是为什么在图表配置中添加了与指标相关的值。目前这对我来说还不起作用，所以我稍后还得回来处理这个问题。还需要对 SPIRE 服务器的可观测性进行一些思考。可能查看 loki 或类似工具的日志会很不错。但那将是下一次的内容。\n', '\/trans\/cilium-native-authentication\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在本文中，我们更深入地探讨了 Cilium 的功能，特别是它从服务网格获得的相互认证功能。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/what-is-microsegmentation/">[译] 微分段安全技术解析：云原生环境下的零信任实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2024/07/24</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.paloaltonetworks.com/cyberpedia/what-is-microsegmentation" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('微分段安全技术解析：云原生环境下的零信任实践', '深入探索微分段技术在云原生架构中的应用，如何通过零信任框架增强数据安全与合规性。', '\n## 什么是微分段？\n\n微分段（Microsegmentation）是一种网络安全管理方法，它通过将网络划分为多个小段，并根据各段的安全需求应用安全控制，从而管理工作负载间的网络访问权限。这种方法结合了[最小权限原则](https:\/\/www.paloaltonetworks.com\/cyberpedia\/what-is-least-privilege-access)和[零信任架构](https:\/\/www.paloaltonetworks.com\/cyberpedia\/what-is-a-zero-trust-architecture)，让管理员可以精确管理安全策略，限制流量，有效减少攻击面，加强数据泄露的防护，并增强合规性。\n\n### 微分段的工作原理\n\n微分段通过网络虚拟化技术，在云部署中创建安全区域，这些小的安全区可以隔离[工作负载](https:\/\/www.paloaltonetworks.com\/cyberpedia\/what-is-workload)，并为每个工作负载定制安全策略。这种粒度级的安全控制对于运行多个应用的现代云环境至关重要。企业可以为每个工作负载和应用程序单独应用安全控制，而不是采用针对服务器的统一安全策略。\n\n![图 1: 微分段通过零信任框架限制流量，将网络划分为多个小段。](microsegmentation.jpg)\n\n### 工作负载的定义\n\n工作负载广泛地定义为运行应用程序所需的资源和过程。主机、虚拟机和容器是几种常见的工作负载形式。公司可以在数据中心、混合云和多云环境中运行工作负载，而随着应用程序越来越多地部署在不同的云原生计算架构上，这种分布式趋势根据业务需求不断加速。\n\n## 超越边界安全\n\n边界安全是大多数组织网络安全控制的重要部分。网络安全设备，如网络防火墙，会检查穿越安全边界的“南北”（客户端到服务器）流量，并阻止恶意流量。边界内的资产被隐含信任，意味着“东西”（工作负载间）的流量可能未经检查。\n\n![图 2: “南北”与“东西”流量示意图](what-is-microsegmentation-img-1.jpg)\n\n对于大多数组织来说，东西向通信占据了数据中心和云流量模式的大部分，而基于边界的防御对东西向流量缺乏可见性。考虑到这些因素，恶意行为者可能利用这一点，在工作负载间横向移动。\n\n网络在工作负载间创建可靠的路径，并决定两个端点是否可以相互访问。微分段则通过创建隔离来决定两个端点是否应该相互访问。通过最小权限访问的强制实施，微分段减少了横向移动的范围，并包含数据泄露。\n\n![图 3: 微分段可以帮助你隔离攻击。](what-is-microsegmentation-img2.gif)\n\n## 网络分段的挑战\n\n网络分段是一种将网络划分为多个小的子网的方法，这不仅有助于提升性能，还能增强安全：\n\n- **性能：** 将网络划分为较小的子网和 VLAN 可以减少广播数据包的范围，从而提高网络性能。\n- **安全：** 网络安全团队可以将访问控制列表（ACL）应用于 VLAN 和子网，隔离不同网络段上的机器。如果发生数据泄露，ACL 可以防止威胁扩散到其他网络段。\n\n利用网络分段进行安全管理存在挑战。分段需求并不总是与网络架构相匹配。重新架构网络或重新配置 VLAN 和子网以满足分段要求既困难又耗时。\n\n![网络分段 - 使用 VLAN 和子网 - 是通过打破网络广播域来提供最佳网络性能的一种方法](what-is-microsegmentation-img-3.jpg)\n*图 4: 网络分段 - 使用 VLAN 和子网 - 是通过打破网络广播域来提供最佳网络性能的一种方法。*\n\n## 微分段的工作方式\n\n微分段，也被称为零信任或基于身份的分段，不需要重新架构就可以满足分段要求。安全团队可以在网络中隔离工作负载，限制恶意横向移动的影响。微分段控制可以分为三类：\n\n- **基于代理的**解决方案在工作负载上使用软件代理，并实施粒度隔离至单个主机和容器。基于代理的解决方案可能利用内置的基于主机的防火墙，或根据工作负载的身份或属性实现隔离能力。\n- **基于网络的**分段控制依赖于网络基础设施。这种方式利用物理和虚拟设备，如负载均衡器、交换机、软件定义网络（SDN）和覆盖网络来执行策略。\n- **云原生控制**利用嵌入在云服务提供商中的功能（例如，Amazon 安全组、Azure 防火墙或 Google Cloud 防火墙）。\n\n微分段通过三个关键原则提供一致的安全性：可见性、粒度安全和动态适应。\n\n一个微分段解决方案应该提供对所有网络流量的可见性，无论是在数据中心内部还是跨云流量。虽然监控流量的方式有很多，但最有效的方法是能够看到与工作负载上下文（例如，云、应用、编排器）相关联的流量，而不仅仅是包含 IP 地址和端口的日志。\n\n粒度安全意味着网络管理员可以通过为关键应用程序创建特定策略来加强和精确安全。其目标是通过精确控制特定工作负载的进出流量（例如，每周的工资运行或人力资源数据库的更新），防止威胁的横向移动。\n\n微分段为动态环境提供保护。例如，云原生架构如容器和 Kubernetes 可以在几秒钟内启动并关闭。分配给云工作负载的 IP 地址是短暂的，使基于 IP 的规则管理成为不可能。在微分段中，安全策略以身份或属性（env=prod, app=hrm 等）而不是网络构造（例如，10.100.0.10 tcp\/80）的形式表达。应用或基础设施的更改会触发安全策略的实时自动修订，无需人工干预。\n\n## 微分段的类型\n\n微分段为动态环境提供保护。例如，云原生架构如[容器](https:\/\/www.paloaltonetworks.com\/cyberpedia\/what-is-a-container)和 Kubernetes 可以在几秒钟内启动并关闭。分配给云工作负载的 IP 地址是短暂的，使得基于 IP 的规则管理成为不可能。在微分段中，安全策略以身份或属性（env=prod, app=hrm 等）而不是网络构造（例如，10.100.0.10 tcp\/80）的形式表达。应用或基础设施的变化会触发安全策略的实时自动修订，无需人工干预。\n\n### 容器分段\n\n容器分段涉及将容器从彼此及宿主系统隔离开来，以提高安全性并减少攻击面。容器化是一种广泛使用的技术，允许在单个宿主系统上的不同容器中运行多个应用程序或服务。如果没有适当的分段，容器可能会访问彼此的数据和配置文件，这可能导致安全漏洞。\n\n#### 容器分段的最佳实践\n\n- **容器隔离：** 每个容器应从运行在同一宿主系统上的其他容器中隔离开来，以防止未授权访问。这可以通过使用 Docker 和 Kubernetes 等提供内置隔离机制的容器技术来实现。\n\n- **网络分段：** 可以使用网络分段技术将容器彼此分开。这涉及为每个容器创建独立的网络，并配置防火墙规则以允许或拒绝容器之间的流量。\n\n- **基于角色的访问控制：** 可以使用基于角色的访问控制（RBAC）定义不同容器的访问策略，根据用户角色和权限进行管理。这有助于确保容器只被授权的用户和过程访问。\n\n- **镜像签名：** 容器镜像可以进行数字签名，以确保只有经过验证的镜像才能在生产环境中部署。这有助于防止容器镜像被篡改或修改，从而减少安全漏洞的风险。\n- **运行时保护：** 运行时保护工具可以用来监控容器活动并检测可能表明安全漏洞的异常行为。这些工具有助于实时检测和防止攻击，提高容器化环境的安全态势。\n\n容器分段有助于确保容器化应用程序和服务的安全。通过隔离容器并应用访问控制策略，组织可以减少攻击面，并防止未授权访问敏感数据和资源。容器分段应作为整体安全策略的一部分实施，包括网络安全、访问控制和运行时保护。\n\n### 云安全中的用户分段\n\n云安全中的用户分段涉及根据组织内不同角色和职责划分用户访问权限，以确保用户只能访问其工作功能所需的资源。用户分段通过限制敏感数据和资源的暴露范围，仅限于授权用户，从而减少攻击面。\n\n由于云环境的动态性和快速变化，用户分段是全面云安全策略的关键组成部分。以下是云安全中用户分段的一些关键考虑因素：\n\n- **基于角色的访问控制（RBAC）：** RBAC 涉及创建和定义角色的权限，然后根据工作职能将用户分配到适当的角色。这种方法确保用户只能访问其工作功能所需的资源，减少意外或故意数据泄露的风险。\n- **多因素认证（MFA）：** MFA 要求用户提供多种形式的认证才能访问资源。这可能包括密码、安全令牌或生物识别数据。MFA 是一种有效的方法，特别是与 RBAC 结合使用时，可以防止未授权访问云资源。\n- **持续监控：** 持续监控用户活动对于实时检测和响应安全事件至关重要。这涉及分析日志数据和用户行为，以识别威胁和漏洞。\n- **职责分离：** 职责分离涉及在多个用户之间划分责任，以防止任何单一用户对系统或过程拥有过多控制权。这有助于降低欺诈或错误的风险，并确保敏感操作由多个用户执行。\n- **定期访问审查：** 定期访问审查涉及定期审查用户访问权限和权限，以确保它们仍然是必需的。访问审查有助于识别和移除不必要的访问权限，减少未授权访问的风险。\n\n通过实施 RBAC、MFA、持续监控、职责分离和定期访问审查，组织可以增强其云安全态势，保护免受不断变化的威胁影响。\n\n## 微分段的益处\n\n采用微分段的组织能够实现具体的益处，具体包括：\n\n- **减少攻击面**：微分段提供了对完整网络环境的可见性，不会延缓开发或创新的速度。应用开发人员可以在开发周期早期集成安全策略定义，确保应用部署或更新不会产生新的攻击向量。这在快速发展的 DevOps 世界中尤为重要。\n- **改善数据泄露的防护**：微分段使安全团队能够根据预定义的策略监控网络流量，同时缩短对数据泄露的响应和修复时间。\n- **加强监管合规性**：利用微分段，监管官员可以创建政策，将受监管系统从基础设施的其余部分隔离开来。精细控制与受监管系统的通信，降低非合规使用的风险。\n- **简化策略管理**：转向微分段网络或零信任安全模型提供了简化策略管理的机会。一些微分段解决方案提供自动应用发现和基于学习的应用行为的策略建议。\n\n## 微分段的应用案例\n\n微分段的应用范围广泛且日益增长。以下是一些代表性的例子：\n\n- **开发与生产系统**：在最佳情况下，组织会仔细区分开发和测试环境与生产系统。然而，这些措施可能无法阻止疏忽行为，如开发人员为测试目的从生产数据库取用客户信息。微分段可以通过精细地限制两个环境之间的连接来强制执行更严格的分离。\n- **保护软资产**：公司有巨大的财务和声誉动机来保护“软”资产，如机密的客户和员工信息、知识产权和公司财务数据。微分段为防止数据外泄和其他恶意行为提供了额外的安全级别，这些行为可能导致停机并干扰业务运营。\n- **混合云管理**：微分段可以为跨多个云的应用程序提供无缝的保护，并在由多个数据中心和云服务提供商组成的混合环境中实施统一的安全策略。\n- **事件响应**：如前所述，微分段限制了威胁的横向移动和泄露的影响。此外，微分段解决方案提供的日志信息有助于事件响应团队更好地理解攻击策略，并通过遥测数据帮助确定特定应用程序的政策违规情况。\n\n## 微分段常见问题解答\n\n### 网络分段与微分段有何不同？\n\n虽然网络分段和微分段都有助于提升网络安全和性能，但它们在基础上有所不同。传统的网络分段侧重于进出网络的南北流量，并使用 VLAN、防火墙、路由器等设备实施。这些设备可以配置来执行网络层面的安全策略，如访问控制列表（ACL）或防火墙规则。\n\n另一方面，微分段侧重于东西流量，通常使用基于软件的安全解决方案实施，如基于虚拟机的防火墙或端点保护平台（EPP）。微分段在个别工作负载或应用层面而非网络层面应用安全策略。\n\n### 什么是防火墙策略？\n\n防火墙策略定义了组织的防火墙应如何处理针对某些 IP 地址和地址范围的进出网络流量。策略可能关注用户身份、网络活动和应用程序，以及 IP 地址。\n\n### 什么是虚拟网络？\n\n虚拟网络使用软件连接计算机、虚拟机（VM）和服务器或虚拟服务器，与传统的物理网络不同，后者通过硬件和电缆固定在特定位置。\n\n### 什么是应用依赖？\n\n应用依赖是指软件、应用程序、服务器和其他组件相互依赖以执行其功能的情况。为确保服务不间断，应在将组件迁移到云、移到新的云环境或实施微分段之前绘制应用依赖关系图。', '\/trans\/what-is-microsegmentation\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">深入探索微分段技术在云原生架构中的应用，如何通过零信任框架增强数据安全与合规性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/how-ciliums-mutual-authentication-can-compromise-security/">[译] Cilium 的相互认证如何危及安全</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/12/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://istio.io/latest/blog/2023/egress-sni/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cilium 的相互认证如何危及安全', '这篇文章是关于如何使用 Cilium 来实现 互相认证 (mTLS) 的，以及这种方法可能带来的安全问题。文章介绍了 Cilium 的特点和功能，以及如何使用 Cilium CLI 或 Hubble UI 来创建和管理证书和策略。文章还分析了 Cilium 的互相认证的局限和风险，例如证书过期，撤销，泄露和伪造等。文章的目的是帮助用户了解和使用 Cilium 来提高服务间的安全性。', '\n最近，Cilium 项目宣布支持一种[新的双向认证机制](https:\/\/docs.cilium.io\/en\/latest\/network\/servicemesh\/mutual-authentication\/mutual-authentication\/)，可以通过简单的配置标志透明地部署到应用程序中。从表面上看，这似乎是一种简单的方法，可以使用 Cilium 为 Kubernetes 工作负载实现服务之间的双向认证。然而，这种设计存在一个严重的缺陷，不容忽视：\n\nCilium 中的双向认证的整个基础是*最终一致性*。\n\n在安全实现的数据路径中，最终一致性可能导致意图中的安全属性失败，并且可能导致在不应该允许的情况下服务之间的流量继续传递。\n\n## Cilium 双向认证的工作原理\n\nCilium 的自定义双向认证机制会透明地对服务之间的流进行身份验证，并构建在 Cilium 的现有扩展伯克利数据包过滤器（[eBPF](https:\/\/thenewstack.io\/ebpf-offers-a-new-way-to-secure-cloud-native-systems\/)）数据平面之上。Cilium 使用 eBPF 来实现诸如服务网络、网络策略和连接处理等功能。\n\nCilium 使用“无双向传输层安全（mTLS-less）”（或 mTLess）来对服务进行身份验证。我称之为“less”，因为它没有使用 mTLS 来完成 mTLS 设计的任务：验证、加密和检查在两个对等方之间传输的数据的完整性。Cilium 的双向认证实现*不是 mTLS*，我将在下面解释。\n\n当服务（或 Pod）A 想要与服务（或 Pod）B 通信时，Cilium 会尝试对这两个对等方进行身份验证，然后标记一个特殊的本地节点“身份验证缓存”，指示是否允许特定流。\n\n![图 1：由于未经身份验证而丢弃的初始连接。](f1.png)\n\n当 Pod A 想要与 Pod B 通信时，它会通过正常的 Cilium eBPF 数据平面流动，但 eBPF 代码会检查该连接是否已通过检查本地节点身份验证缓存进行身份验证。在第一次尝试时，该调用将不会得到身份验证，因此[Cilium 将丢弃数据包](https:\/\/github.com\/cilium\/cilium\/issues\/23808)。但这将触发一个在幕后进行的机制，尝试对 Pod A 和 Pod B 之间的流进行身份验证。如果成功，它将更新本地节点身份验证缓存。\n\n期望的是，在幕后的机制能够快速进行 Pod A 呼叫 Pod B 的身份验证，以便最初丢弃的数据包将被重试，不会导致太多延迟。在幕后使用的机制是从运行在 Pod B 所在节点上的 cilium-agent（使用[Go](https:\/\/roadmap.sh\/golang)编写）到另一个 cilium-agent 的“mTLess”连接。所有这些都不会在 eBPF 数据平面中发生，而是在用户空间的 Cilium 代理中进行。\n\n![图 2：如果两个不同节点上运行的 cilium-agent 之间的 mTLS 连接成功，则认为流是经过身份验证的。](f2.png)\n\n我将这个连接称为“mTLess”，因为它用于测试身份验证并立即关闭，并且所有用于加密和完整性的协商的会话密钥都会被丢弃。也就是说，Cilium 不会在连接的整个生命周期内保留 mTLS 安全属性；它只使用握手的身份验证部分。\n\n![图 3：在握手后，Cilium 终止 mTLess 连接。](f3.png)\n\n如果此 mTLess 连接成功（即握手成功），Cilium 将考虑将来自 Pod A 到 Pod B 的流程视为“已验证”。此时，本地节点身份验证缓存中的条目将被更新，以指示应允许来自 Pod A 到 Pod B 的流程。\n\n![图 4：Cilium 更新身份验证缓存，指示 Pod A 具有呼叫 Pod B 的身份验证。](f4.png)\n\n现在，当它重试连接数据包时，身份验证缓存将指示流程已经通过身份验证，应允许连接并继续 eBPF 数据平面的其余部分（该部分强制执行网络和其他策略）。这个本地节点身份验证缓存确实表现出最终一致性的迹象，可能会失去同步，但这并不是最令人担忧的最终一致性属性。\n\n![图 5：一旦缓存已更新并重试数据包，连接将会流动。](f5.png)\n\n\n## Cilium 方法的主要问题\n\n对于真正的 mTLS 连接，在成功握手之后，您希望使用在参与各方之间协商的密钥来加密剩余的数据。Cilium 中流的成功认证并不意味着它是加密的（它将是纯文本），也不保证流量以一种仅对相关方可见的方式进行加密。如果您需要加密，可以使用基于 WireGuard（或 IPSec）的 Cilium 加密选项，但这只是两个 Kubernetes 节点之间的加密，而不是特定的已认证的工作负载。在“mTLess”连接检查和将实际（敏感）数据放入线路之间，可能会发生很多事情。\n\n随着一些 Cilium 开发人员继续迭代这个实现，有关将 mTLS 连接中协商的某些密钥转移到底层节点到节点加密方法（例如 IPSec）的谈论。这个实现还有待观察。\n\n![图 6：具有不同会话密钥的流量](f6.png)\n\n![图 7：基于 WireGuard 的加密。](f7.png)\n\nCilium 最终一致性双向认证实现的真正问题出现在 Cilium 的核心身份模型周围。我在上面简要介绍了 TLS 握手，但如果您阅读 Cilium 文档，您会看到用于“mTLess”的 X509 证书具有可选基于[SPIFFE](https:\/\/thenewstack.io\/the-rise-of-workload-identity-in-cloud-native-with-spiffe-spire\/)（Secure Production Identity Framework For Everyone）的身份模型。实际上，在部署实现 Cilium 双向认证所需的组件时，您可以选择部署 SPIFFE Runtime Environment（SPIRE），这是 SPIFFE 的一个实现，Cilium 使用它来生成代表工作负载及其身份的证书。\n\n这个 SPIFFE 身份用于握手所使用的证书，*但 SPIFFE 不是 Cilium 中使用的基础通用工作负载身份*。SPIFFE 用作独立的身份层，映射到 Cilium 现有身份实现。Cilium 在其[核心身份](https:\/\/doc.crds.dev\/github.com\/cilium\/cilium\/cilium.io\/CiliumIdentity\/v2@1.9.3)概念周围构建了所有的网络策略。CiliumIdentity 实现将一个整数映射到一组 IP 地址（与一组 Pod 关联的 Pod IP）。这个“整数”及其映射到 Pod IP 地址的方式代表了*Cilium 中的核心身份原语*。\n\n![图 8：Cilium 的核心身份原语基于在每个节点上的本地缓存中映射到 IP 地址的整数。](f8.png)\n\n我们在博客文章“[网络基于缓存的身份可能会被误解吗？](https:\/\/www.solo.io\/blog\/could-network-cache-based-identity-be-mistaken\/)”中详细讨论了这个问题。由于这个问题，我们建议在考虑使用依赖身份到 IP 地址映射的容器网络接口（CNI）和[服务网格](https:\/\/thenewstack.io\/secure-your-service-mesh-a-13-item-checklist\/)进行网络安全时采取深度防御姿态。\n\n问题的关键在于：\n\n为集群中的每个身份的所有 IP 映射*都存在于集群中每个节点上的本地缓存中*。\n\n![图 9：显示每个身份的 IP 的图表](f9.png)\n\n![图 10：最终一致性问题的图表](f10.png)\n\n为了使 Cilium 的双向认证和策略执行正常工作，必须使用正确的 IP 到身份映射更新这些缓存。然而，在集群中的所有节点上更新单独的缓存*是一种最终一致性操作*。当 Cilium 的 eBPF 数据平面尝试推理连接策略时，它将参考其节点本地缓存中的 IP 到身份映射。*如果该缓存过期或延迟*，将导致不正确的网络策略（可能不符合要求，允许恶意活动，威胁数据等）。无论您是否使用 WireGuard 或 IPSec 来加密节点之间的流量，这都不会影响此身份混淆场景。\n\n这个演示说明了在使用 Cilium 的双向认证时可能导致违反网络策略的身份混淆：\n\n## 总结\n\n因此，总结一下：\n\n- Cilium 项目引入了一种新颖的 Kubernetes 工作负载的双向认证机制。\n- Cilium 中的双向认证建立在最终一致性之上，可能会危及安全性。\n- Cilium 使用“mTLess”进行身份验证，但不会维护整个连接的加密。\n- Cilium 的身份模型包括 SPIFFE，但其核心身份是一个基于整数的单独身份层。\n- 核心问题在于，IP 到身份的映射存储在每个节点上的本地缓存中，这可能导致最终一致性的更新。\n- 在 Cilium 的双向认证中的最终一致性可能导致不正确的网络策略和安全漏洞。\n\n要正确使用依赖身份到 IP 地址映射的 CNI，请考虑采用深度防御姿态，将一个服务网格（如 Istio Ambient）叠加在其上。Istio Ambient 实现了一种无 sidecar 的服务网格，在服务之间的数据路径上使用 mTLS（无论其 IP 地址如何）。在[像 Istio 这样的服务网格](https:\/\/thenewstack.io\/solo-io-istio-is-winning-the-service-mesh-war\/)中，身份模型是由 SPIFFE 定义的，并根据负责签署用于身份验证流量的证书的证书颁发机构建立的。\n', '\/trans\/how-ciliums-mutual-authentication-can-compromise-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">这篇文章是关于如何使用 Cilium 来实现 互相认证 (mTLS) 的，以及这种方法可能带来的安全问题。文章介绍了 Cilium 的特点和功能，以及如何使用 Cilium CLI 或 Hubble UI 来创建和管理证书和策略。文章还分析了 Cilium 的互相认证的局限和风险，例如证书过期，撤销，泄露和伪造等。文章的目的是帮助用户了解和使用 Cilium 来提高服务间的安全性。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/technical-deep-dive-securing-automation-acme-dns-challenge-validation/">[译] 深入探讨：ACME DNS 质询验证的自动化</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/01/10</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.eff.org/deeplinks/2018/02/technical-deep-dive-securing-automation-acme-dns-challenge-validation" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('深入探讨：ACME DNS 质询验证的自动化', '本文深入探讨了 DNS 质询的自动化。', '\n注：原文发布于 2018 年 2 月 26 日。\n\n2018 年 [Let\u0027s Encrypt](https:\/\/www.letsencrypt.org\/) （免费、自动化、开放的证书颁发机构 EFF 在两年前帮助推出）达到了一个巨大的里程碑： [颁发了超过 5000 万个有效证书](https:\/\/www.eff.org\/deeplinks\/2018\/02\/lets-encrypt-hits-50-million-active-certificates-and-counting)。而且这个数字只会继续增长，因为几周后 Let\u0027s Encrypt 也将开始颁发“通配符”证书 —— 这是许多系统管理员一直要求的功能。\n\n## 什么是通配符证书？\n\n为了验证 HTTPS 证书，用户的浏览器会检查以确保证书中实际列出了网站的域名。例如，来自 \u0060www.eff.org\u0060 的证书实际上必须将 \u0060www.eff.org\u0060 列为该证书的有效域。如果所有者只想对他的所有域使用一个证书，则证书还可以列出多个域（例如，\u0060www.eff.org\u0060、\u0060ssd.eff.org\u0060、\u0060sec.eff.org\u0060 等）。通配符证书只是一个证书，上面写着“我对这个域中的所有子域都有效”，而不是明确地将它们全部列出。（在证书中，这是通过使用通配符来表示的，用星号表示。所以如果你今天检查 eff.org 的证书，它会说它对 *.eff.org 有效。）这样，\n\n为了颁发通配符证书，Let\u0027s Encrypt 将要求用户通过使用基于 [DNS](https:\/\/en.wikipedia.org\/wiki\/Domain_Name_System) 的质询来证明他们对域的控制，DNS 是一种域名系统，可将 \u0060www.eff.org\u0060 等域名转换为 69.50.232.54 等 IP 地址。从像 Let\u0027s Encrypt 这样的证书颁发机构 (CA) 的角度来看，没有比修改其 DNS 记录更好的证明您控制域的方法，因为控制域是 DNS 的本质。\n\n但 Let\u0027s Encrypt 背后的一个关键思想是获取证书应该是一个自动过程。但是，为了实现自动化，请求证书的软件还需要能够修改该域的 DNS 记录。为了修改 DNS 记录，该软件还需要能够访问 DNS 服务的凭据（例如登录名和密码，或加密令牌），并且这些凭据必须存储在自动化发生的任何地方。在许多情况下，这意味着如果处理该过程的机器受到威胁，DNS 凭据也会受到威胁，这才是真正的危险所在。在本文的其余部分，我们将深入探讨该过程中涉及的组件，以及使它更安全的选项。\n\n## DNS 质询如何运作？\n\n在高层次上，DNS 质询的工作方式与作为 ACME 协议一部分的所有其他自动质询一样 —— 证书颁发机构 (CA)（如 Let\u0027s Encrypt）和客户端软件（如 Certbot）使用该协议来就服务器请求的证书进行通信，以及服务器应该如何证明相应域名的所有权。在 DNS 质询中，用户使用支持 DNS 质询类型的 Certbot 等 ACME 客户端软件向 CA 申请证书。当客户端请求证书时，CA 要求客户端通过向其 DNS 区域添加特定的 TXT 记录来证明对该域的所有权。更具体地说，CA 向 ACME 客户端发送一个唯一的随机令牌，并且控制域的任何人都应该将此 TXT 记录放入其 DNS 区域，在名为 \u0060_acme-challenge\u0060 的预定义记录中。当令牌值添加到 DNS 区域时，客户端告诉 CA 继续验证质询，之后 CA 将向域的权威服务器执行 DNS 查询。如果权威 DNS 服务器回复包含正确质询令牌的 DNS 记录，则证明域的所有权并且证书颁发过程可以继续。\n\n## DNS 控制数字身份\n\nDNS 区域泄露之所以如此危险，是因为 DNS 是用户的浏览器所依赖的，以了解他们在尝试访问您的域时应该联系的 IP 地址。这适用于在您的域下使用可解析名称的每项服务，从电子邮件到 Web 服务。当 DNS 受到威胁时，恶意攻击者可以轻松拦截指向您的电子邮件或其他受保护服务的所有连接，终止 TLS 加密（因为他们现在可以证明对该域的所有权并为其获取自己的有效证书），阅读明文数据，然后重新加密数据并将连接传递到您的服务器。对于大多数人来说，这很难被发现。\n\n## 独立和有限的特权\n\n严格来说，为了让 ACME 客户端以自动方式处理更新，客户端只需要访问可以更新 \u0060_acme-challenge\u0060 子域的 TXT 记录的凭据。不幸的是，大多数 DNS 软件和 DNS 服务提供商不提供允许限制这些权限的精细访问控制，或者根本不提供 API 来处理基本 DNS 区域更新或传输之外的自动化。这使得可能的自动化方法无法使用或不安全。\n\n一个简单的技巧可以帮助克服这些限制：使用 [CNAME 记录](https:\/\/en.wikipedia.org\/wiki\/CNAME_record)。CNAME 记录本质上充当到另一个 DNS 记录的链接。Let\u0027s Encrypt 遵循 CNAME 记录链，并将解析链中最后一条记录的质询验证令牌。\n\n## 缓解问题的方法\n\n即使使用 CNAME 记录，潜在的问题仍然存在，即 ACME 客户端仍然需要访问允许它修改某些 DNS 记录的凭据。有不同的方法可以缓解这个潜在的问题，在泄露的情况下具有不同程度的复杂性和安全影响。在接下来的部分中，本文将介绍其中一些方法，同时尝试解释如果凭据被泄露可能产生的影响。除了一个例外，它们都使用 CNAME 记录。\n\n### 只允许更新 TXT 记录\n\n第一种方法是创建一组具有仅允许更新 TXT 记录的权限的凭证。在泄露的情况下，此方法将影响限制为攻击者能够为 DNS 区域内的所有域颁发证书（因为他们可以使用 DNS 凭据来获取自己的证书），以及中断邮件传递。对邮件传递的影响源于邮件特定的 TXT 记录，即 [SPF](https:\/\/en.wikipedia.org\/wiki\/Sender_Policy_Framework)、 [DKIM](https:\/\/en.wikipedia.org\/wiki\/DomainKeys_Identified_Mail)、其扩展名 [ADSP](https:\/\/en.wikipedia.org\/wiki\/Author_Domain_Signing_Practices) 和 [DMARC](https:\/\/en.wikipedia.org\/wiki\/DMARC)。泄露这些还可以很容易地发送网络钓鱼电子邮件，这些电子邮件冒充来自相关受感染域的发件人。\n\n### 使用“一次性”验证域\n\n第二种方法是为 \u0060_acme-challenge\u0060 子域手动创建 CNAME 记录，并将它们指向一个验证域，该验证域位于由一组不同的凭据控制的区域中。例如，如果您想获得涵盖 \u0060yourdomain.tld\u0060 和 \u0060www.yourdomain.tld\u0060 的证书，则必须创建两个 CNAME 记录 ——\u0060_acme-challenge.yourdomain.tld\u0060 和 \u0060_acme-challenge.www.yourdomain.tld\u0060—— 并将它们都指向外部域以进行验证。\n\n用于质询验证的域应位于外部 DNS 区域或具有自己的一组管理凭据的子委托 DNS 区域中。（子委托 DNS 区域是使用 NS 记录定义的，它有效地将对该区域的一部分的完全控制委托给外部机构。）\n\n这种方法的泄露影响相当有限。由于实际存储的凭据是针对外部 DNS 区域的，因此获得凭据的攻击者只能获得为指向该区域中的记录的所有域颁发证书的能力。\n\n然而，弄清楚哪些域确实指向那里是微不足道的：攻击者只需阅读 [证书透明度](https:\/\/www.certificate-transparency.org\/) 日志并检查这些证书中的域是否具有指向受感染 DNS 区域的神奇子域。\n\n### 有限的 DNS 区域访问\n\n如果您的 DNS 软件或提供商允许创建绑定到子域的权限，这可以帮助您缓解整个问题。不幸的是，在发布时，我们发现唯一允许这样做的提供商是 [Microsoft Azure DNS](https:\/\/docs.microsoft.com\/en-us\/azure\/dns\/dns-protect-zones-recordsets)。据推测，Dyn 也有细粒度的权限，但我们无法在他们的服务中找到除“更新记录”之外的更低级别的权限，这仍然使该区域完全容易受到攻击。\n\nRoute53 和其他可能允许他们的用户创建子委托区域、新用户凭据、将 NS 记录指向新区域，并使用 CNAME 记录将 \u0060_acme-challenge\u0060 验证子域指向他们。使用这种方法正确地进行特权分离需要做很多工作，因为人们需要为他们想要使用 DNS 挑战的每个域完成所有这些步骤。\n\n### 使用 ACME-DNS\n\n作为免责声明，下面讨论的软件由作者编写，并用作以安全方式处理 DNS 质询自动化所需凭据所需功能的示例。最后一种方法是一款名为 ACME-DNS 的软件，专为解决这个问题而编写，它能够完全缓解这个问题。一个缺点是它为您的基础设施增加了一项需要维护的东西，以及对公共互联网开放 DNS 端口 (53) 的要求。ACME-DNS 充当具有有限 HTTP API 的简单 DNS 服务器。API 本身只允许更新自动生成的随机子域的 TXT 记录。没有方法可以请求丢失的凭据、更新或添加其他记录。它提供了两个端点：\n\n- \/register：此端点生成一个新的子域供您使用，并附有用户名和密码。作为可选参数，注册端点采用 CIDR 范围列表，以从中进行白名单更新。\n- \/update：此端点用于将实际质询令牌更新到服务器。\n\n为了使用 ACME-DNS，您首先必须为其创建 A\/AAAA 记录，然后将 NS 记录指向它以创建委托节点。之后，您只需通过 \/register 端点创建一组新的凭据，并将 CNAME 记录从原始区域的 \u0060_acme-challenge\u0060 验证子域指向新生成的子域。\n\n唯一保存在本地的凭据是用于 ACME-DNS 的凭据，它们仅适用于更新验证子域的确切 TXT 记录。这有效地限制了可能的危害对攻击者能够为这些域颁发证书的影响。有关 ACME-DNS 的更多信息，请访问 \u003chttps:\/\/github.com\/joohoi\/acme-dns\/\u003e。\n\n## 结论\n\n为了缓解 ACME DNS 挑战验证的问题，已经讨论了向 IETF 的 ACME 工作组提出的[辅助 DNS 等提案，但目前仍未得到解决](https:\/\/mailarchive.ietf.org\/arch\/msg\/acme\/6_j3fecaxIgwNTpJ3693U_n0Kec)。由于限制泄露的唯一方法是将 DNS 区域凭据权限限制为仅更改特定的 TXT 记录，因此当前安全地实现 DNS 验证自动化的可能性很小。唯一可持续的选择是让 DNS 软件和服务提供商要么实施方法来创建更细粒度的区域凭据，要么为这个确切的用例提供全新类型的凭据。\n', '\/trans\/technical-deep-dive-securing-automation-acme-dns-challenge-validation\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文深入探讨了 DNS 质询的自动化。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/the-top-6-zero-trust-principles-for-kubernetes-security/">[译] Kubernetes 安全的 6 大零信任原则</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://tetrate.io/blog/top-3-mtls-best-practices-for-zero-trust-kubernetes-security/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Kubernetes 安全的 6 大零信任原则', '本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。', '\n传统的网络安全依赖于围绕可信内部网络的强大防御边界，以将不良行为者拒之门外，将敏感数据拒之门外。在日益复杂的网络环境中，维护强大的边界越来越困难。\n\n零信任安全正在成为企业保护其传统和现代云原生应用程序的首选方法。零信任网络架构颠覆了边界安全的假设。在零信任网络中，每个资源都在内部受到保护，就好像它暴露在开放的互联网中一样。\n\n为了为行业和美国联邦政府建立零信任安全指南，美国国家标准与技术研究院 (NIST) 在一系列出版物中建立了零信任安全指南，从 SP 800-207 开始，介绍一般的零信任架构及其配套[SP 800-204 微服务安全标准系列](https:\/\/tetr8.io\/3zi85IC)。\n\n以下是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。\n\n## 零信任网络的六项原则\n\n1. **无论网络位置如何，所有通信都应该是安全的**。网络位置和可达性并不意味着信任。企业拥有或其他专用网络内部的访问请求必须满足与来自任何其他位置的通信相同的安全要求。零信任系统的一个标准是，您可以将它暴露在开放的互联网上，并且它仍然是安全的，没有未经授权的系统、数据或通信访问。\n2. **所有通信都应加密**。线路上的加密可防止窃听，并确保消息真实且未被篡改。这意味着至少为所有通信实施 TLS，将[mTLS 和相关的安全工作负载身份作为服务间通信的最佳实践](https:\/\/tetr8.io\/3Na982k)。\n3. **对每个资源的访问都应该根据动态策略进行身份验证和授权**。在允许任何访问之前，对服务身份和最终用户凭据进行动态身份验证和授权。访问请求的动态上下文应该是访问决策的一部分。这可能包括行为属性，如与观察到的使用模式的偏差或请求资产的状态，如安装的软件版本、网络位置和请求的时间 \/ 日期。授予访问权限时，应以所需的最低权限授予它。\n4. **对资源的访问应该在空间上有界**。围绕资源的信任范围应尽可能小 —— 理想情况下为零。访问应该由每个能够检索和执行访问决策的资源前面的策略执行点 (PEP) 进行调解。这应该适用于所有入站、出站和服务到服务的访问。\n5. **应及时限制对资源的访问**。身份验证和授权绑定到一个短暂的会话，之后它们必须重新建立。这可确保频繁做出访问决策，并使用最新的可用上下文。\n6. **对资源的访问应该是可观察的**。应收集并使用尽可能多的信息来改善安全态势。这允许持续监控所有资产的完整性和安全状况，并持续确保策略执行。此外，应反馈从观察中获得的见解以改进政策。\n\n## 为什么零信任安全性更好\n\n- **网络可达性不是授权**。与边界安全性不同，对服务的访问不会仅仅因为该服务可访问而被授予。它也必须经过明确的身份验证和授权。\n- **周边突破口的有限爆炸半径可防止攻击者横向移动**。经过身份验证和授权的工作负载免受边界破坏。及时限制凭证泄露的风险。\n- **细粒度策略**。空间边界允许高粒度的策略执行。\n- **频繁的政策评估**。通过在短期会话上执行动态策略来及时绑定可确保授权基于最新的策略。\n- **安全、真实的通信**。加密和强大的工作负载身份限制了侦察并提供了通信的真实性。\n- **安全状况和合规性的实时和可审计保证**。细粒度的可观测性允许实时保证和政策实施的事后审计以及故障排除和分析所需的数据。\n\n## 如何使用 Istio 在 Kubernetes 中实现零信任安全：现代微服务应用程序的参考架构\n\n作为 NIST 的一般零信任架构标准的补充，NIST 还发布了如何将零信任原则专门应用于微服务应用程序的标准。这些标准由 Tetrate 创始工程师 Zack Butcher 共同编写，并编入[NIST 的 SP 800-204 系列](https:\/\/tetr8.io\/3zi85IC)。\n\n在该标准中，NIST 建立了一个由 Kubernetes 组成的参考平台，用于编排和资源管理，并使用 Istio 服务网格提供核心安全功能。\n\n## Kubernetes 安全漏洞\n\n由于 Kubernetes 主要专注于编排、资源管理和基本连接，因此它将零信任网络安全问题留给其他方解决。Kubernetes 中的主要网络安全漏洞是（NIST SP 800-204B，§2.1.1）：\n\n- 默认情况下不安全的通信\n- 缺少在 pod 之间强制执行 TLS 所需的内置证书管理机制\n- 缺乏身份和访问管理机制\n- 在 OSI L3 而非 L7 运行的防火墙策略，因此无法窥视数据包或做出元数据驱动的决策\n\n## 服务网格填补了 Kubernetes 的安全漏洞：微服务应用程序的安全内核\n\n为了增强 Kubernetes 的安全性，Istio 充当 NIST 参考架构中的安全内核。Istio 满足参考监视器的三个要求（NIST SP 800-204B，§5.1）。Istio 是：\n\n- 不可旁路\n- 防止修改\n- 验证和测试是正确的\n\nEnvoy 数据平面通过每个服务前面以及每个入口和出口网关的不可绕过的策略执行点 (PEP) 提供参考监视器。服务网格代码独立于应用程序，因此它的生命周期可以独立管理，并且不能在运行时修改。而且，网格是系统的一个严格控制的元素，可以通过更多的眼睛和更仔细的检查来强化（NIST SP 800-204B，§5.1）。\n\n而且，作为专用的基础架构层，Istio 提供：\n\n- 解决**横切应用程序问题的**统一方法；\n- **快速解决这些问题的标准插件**和构建自定义插件的框架；\n- **简化**操作复杂性；\n- **易于管理**第三方开发人员和集成商；\n- **降低**开发和运营成本。\n\n## 下一步\n\n\u003e 要从联邦安全标准的合著者那里了解有关**如何实施零信任架构的更多信息，**[请阅读 Zack Butcher 的零信任架构白皮书](https:\/\/tetr8.io\/zta-wp)。\n\u003e\n\u003e 有关 NIST 安全建议的深入指南以及 Tetrate 如何帮助您实施该标准，请查看[Tetrate 的微服务联邦安全要求指南](https:\/\/tetr8.io\/3Ccg6Qt)。\n\n如果您正在寻找使用 Istio 投入生产的最快方式，请查看我们的开源[Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/)。TID 是经过审查的 Istio 上游发行版 ——Istio 的强化映像，具有持续支持，更易于安装、管理和升级。对于在联邦监管环境中运营的组织，Tetrate Istio Distro 是唯一[具有可用 FIPS 验证构建](https:\/\/istio.tetratelabs.io\/fips-request\/)的 Istio 发行版。\n\n如果您需要一种统一且一致的方式来保护和管理一系列应用程序中的服务，请查看 [Tetrate Service Bridge (TSB)](https:\/\/tetrate.io\/tetrate-service-bridge\/)，这是我们基于 Istio 和 Envoy 构建的全面的边缘到工作负载应用程序连接平台。\n', '\/trans\/the-top-6-zero-trust-principles-for-kubernetes-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 NIST 的核心零信任架构原则以及建议在实践中应用它们的 Kubernetes 和 Istio 参考架构。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/top-3-mtls-best-practices-for-zero-trust-kubernetes-security/">[译] 零信任 Kubernetes 安全的三大 mTLS 最佳实践</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/12/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('零信任 Kubernetes 安全的三大 mTLS 最佳实践', '我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。', '\n[Kubernetes](https:\/\/kubernetes.io\/) 是编排现代云原生工作负载的事实标准。但是，它不提供开箱即用的安全通信。这意味着每个需要实施传输中加密以对其 Kubernetes 部署[采用零信任安全态势的](https:\/\/tetr8.io\/3FCXsDn)人都需要自己解决这个问题。\n\n幸运的是，有很多易于理解的方法可以实现，在本文中，我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。\n\n## 什么是 mTLS，为什么对安全来说很重要？\n\n传输层安全性（SSL 的后继者）是部署最广泛的安全通信标准，在 HTTPS 中最为明显。TLS 非常适合在需要向客户端证明其身份的服务器之间建立既保密（防窃听）又真实（防篡改）的安全通信。但是，在双方都需要向对方证明身份的情况下（例如在 Kubernetes 应用程序中的微服务之间），TLS 是不够的。\n\n这就是双向 TLS (mTLS) 的用武之地。mTLS 是 TLS，但双方在建立安全通信通道之前向对方证明自己的身份。这是 Kubernetes 中安全通信所需的必要部分。mTLS 提供：\n\n- 在线加密以确保机密性和防篡改\n- 相互的、加密的安全身份证明以确保真实性\n\n要深入了解 mTLS 的工作原理，请参阅我们关于 [mTLS 的文章](https:\/\/tetr8.io\/3NEcL0Q)。\n\n## mTLS 的困难部分：证明身份\n\n困难的部分是为服务建立一个安全机制来向彼此证明它们的身份。\n\n对于常规 TLS，过去很难管理向其客户端证明服务器身份的证书。[随着 Let\u0027s Encrypt](https:\/\/letsencrypt.org\/) 和 [ACME 协议](https:\/\/en.wikipedia.org\/wiki\/Automatic_Certificate_Management_Environment)的出现，这变得容易多了。然而，在像 Kubernetes 这样的动态（并且主要是私有的）环境中管理服务身份和证书更加困难，因为有许多通常是短暂的服务需要强大的、可证明的身份，但实际上不能使用公共 ACME 服务。\n\n推出自己的自动化证书管理系统是不切实际且有风险的。正确管理 mTLS 证书很困难，错误的后果很严重。您需要一种可信赖的、经过验证的方法来做到这一点；这就是服务网格的用武之地。\n\n## 使用服务网格，NIST 微服务安全标准\n\n在[微服务安全标准](https:\/\/tetr8.io\/3zi85IC)中，美国国家标准与技术研究院 (NIST) 建议使用服务网格作为专用基础设施层来提供核心网络安全功能。这些核心功能之一是支持 mTLS 的强大服务身份和证书管理。而且，Istio——[使用最广泛的服务网格](https:\/\/tetr8.io\/3UsARgY)—— 为您提供开箱即用的 mTLS 支持。Istio 透明地提供基础设施 —— 包括安全命名、强大的服务身份和证书管理 —— 用于 Kubernetes 工作负载之间的安全通信以及与外界的连接。\n\n如果您想详细了解 NIST 的微服务安全标准以及 Tetrate 如何帮助满足这些标准，请查看 [Tetrate 的微服务联邦安全要求指南](https:\/\/tetr8.io\/3Ccg6Qt)。\n\n## 最佳实践一：不要使用自签名证书\n\n虽然 Istio 将为您实施 mTLS，但它默认使用自签名证书，因此您可以立即看到网格工作，只需最少的配置。这使得初始用户体验变得简单，但它并非不适合生产环境。NIST 的指南（NIST SP 800-204A，SM-DR12）是完全禁用生成自签名证书的能力。\n\n## 最佳实践二：将 Istio 的信任根植于现有 PKI\n\n如果不应该使用 Istio 的默认自签名证书，还有什么选择？简短的回答是，您应该 [将 Istio 的信任根植于您现有的公钥基础设施 (PKI) 中](https:\/\/tetr8.io\/3DDcAOJ)。这将通过确保它们都具有相同的信任根来实现跨其他集群中的 Istio 部署的通信。观看我们关于 [使用 Istio 的外部 CA 的视频，了解更多信息](https:\/\/www.youtube.com\/watch?v=4b3H7isIAnQ)。\n\n## 最佳实践三：使用中间证书\n\n确切地说，您如何让 Istio 信任您现有的 PKI？Tetrate 的创始工程师和 NIST 微服务安全标准的合著者 Zack Butcher [在此处提供了所有详细信息](https:\/\/tetr8.io\/3DDcAOJ)。但是，简而言之，我们的建议是使用您组织的根证书颁发机构颁发的中间证书。这将：\n\n- 允许细粒度的证书撤销，而无需同时在整个基础架构中强制使用新证书。\n- 启用签名证书的轻松轮换。\n\n有关如何自动化 Istio 证书颁发机构 (CA) 轮换的分步说明，请参阅我们关于 [在大规模生产中自动化 Istio CA 轮换的](https:\/\/tetrate.io\/blog\/automate-istio-ca-rotation-in-production-at-scale\/)文章。\n\n## 下一步\n\n如果您不熟悉服务网格和 Kubernetes 安全性，我们在 [Tetrate Academy](https:\/\/tetr8.io\/academy) 提供一系列免费在线课程，可以让您快速了解 Istio 和 Envoy。\n\n如果您正在寻找一种快速将 Istio 投入生产的方法，请查看 [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid)。TID 是 Tetrate 的强化、完全上游的 Istio 发行版，具有经过 FIPS 验证的构建和支持。这是开始使用 Istio 的好方法，因为您知道您有一个值得信赖的发行版，有一个支持您的专家团队，并且如果需要，还可以选择快速获得 FIPS 合规性。\n\n一旦启动并运行 Istio，您可能需要更简单的方法来管理和保护您的服务，而不仅仅是 Istio 中可用的方法，这就是 Tetrate Service Bridge 的用武之地。您可以[在这里](https:\/\/tetr8.io\/tsb)详细了解 Tetrate Service Bridge 如何使服务网格更安全、更易于管理和弹性，或[联系我们进行快速演示](https:\/\/tetr8.io\/contact)。\n\n## 更多资源\n\n观看我们的视频：\n\n- [使用 Istio 的外部 CA](https:\/\/www.youtube.com\/watch?v=4b3H7isIAnQ)\n- [Istio Ingress Gateway 中的 SSL 证书](https:\/\/www.youtube.com\/watch?v=nYJJ57WCkxE)\n- [如何将服务网格用于混合云和遗留工作负载](https:\/\/www.youtube.com\/watch?v=o8AnLk4Da7M)\n- [如何将 VM 工作负载连接到网格](https:\/\/www.youtube.com\/watch?v=mHR7rR83KjM)\n- [Tetrate 如何帮助美国国防部将 Istio 用于零信任架构](https:\/\/www.youtube.com\/watch?v=E_D4bjvX8Xw\u0026t=2s)\n', '\/trans\/top-3-mtls-best-practices-for-zero-trust-kubernetes-security\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">我们将介绍在 Kubernetes 中实现双向 TLS（mTLS）的三大最佳实践。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/zero-trust-network-for-microservices/">[译] 零信任网络的微服务基本要素概述</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/01/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tetrate.io/blog/zero-trust-network-for-microservices/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('零信任网络的微服务基本要素概述', '本博客将向您介绍零信任网络及其基本要素，这是 CISO（首席信息安全官）必须考虑的，以使网络强大，在当今的数字转型中没有安全漏洞，并减少潜在的财务损失。', '\n\u003e **编者按**\n\u003e\n\u003e 本博客将向您介绍零信任网络及其基本要素，这是 CISO（首席信息安全官）必须考虑的，以使网络强大，在当今的数字转型中没有安全漏洞，并减少潜在的财务损失。\n\n当今所有主要组织都在经历大规模的数字化转型，采用云、移动、微服务和容器技术来高效地提供服务，满足关键业务需求，赶上市场预期。企业的平台和 DevOps 团队必须对分布式和多云的应用程序和服务进行建模，以便随时随地进行访问，从而实现敏捷性。这在组织内部产生了两个重要的趋势：\n\n1. 随着越来越多的组织采用多云，他们将其应用程序部署到公有云（谷歌、亚马逊、Azure 等），这意味着数据离开了他们所认为的安全的内部数据中心。\n2. 企业使用微服务和分布式架构来实现大规模和敏捷。\n\n然而，应用程序开发人员现在需要解决一系列新的可靠性和安全性问题，因为越来越多的依赖性是通过网络调用消耗的。当集中式系统在使用时，网络和端点安全在十年前很容易实现和管理。安全团队可以利用防火墙充分保障周边的安全。随着多云中的分散数据和微服务导致的分布式工作负载的新趋势，IT 安全组织需要评估他们的安全态势，并重新思考他们的网络架构。当然，安全不是一个人或一个部门的工作，它是一个组织中的 IT 安全、DevOps 和 Ops 团队的共同责任。\n\n## 什么是零信任网络？\n\n零信任是一个指导原则，它强调 IT 组织在构建网络架构时不信任任何个人、应用程序或设备。在这里，“零 \u0022信任意味着\u0022 不隐含 \u0022 信任。企业 IT 部门不能假设外部和内部实体是值得信任的，或者对任何实体的安全风险进行一次性评估就足够了（实体可以是应用、人或流量）。\n\n零信任通常与网络安全相关，因为只有在有数据交换的情况下，信任才会出现。零信任网络是一种通过认证和监控每个网络访问来识别任何外部实体的可信度的方法。\n\n[点击下载零信任架构白皮书](https:\/\/www.tetrate.io\/white-paper-zero-trust-architecture\/)\n\n## 为什么我们比以往任何时候都更需要零信任网络？\n\n我们想强调零信任网络比以往任何时候都更重要的最常见原因。\n\n### 云中的数据泄露现在很普遍\n\n数据泄露事件在逐年上升，损害了公司的声誉。我仍然记忆犹新，一个分水岭事件是 2020 年的 Solarwinds 攻击事件。Solarwinds Orion 是一个基于 SaaS 的网络监控工具，它被入侵了，木马使用恶意软件攻击来掌握整个网络基础设施。虽然没有任何企业的敏感数据或文件被窃取等附带损害，但入侵是跨领域和跨地域的。即使是先进的公司，对云的网络钓鱼攻击和恶意软件攻击通常也很难发现，而且在未来可能会上升。根据 Verizon [最近的研究结果](https:\/\/www.verizon.com\/business\/resources\/reports\/dbir\/2021\/masters-guide\/)，云计算漏洞已经超过了内部数据漏洞 ——2021 年 73% 的网络安全事件涉及外部云资产。而 CISO 的一个标准建议是尽快应用零信任网络的原则以避免安全漏洞。\n\n### 分布式工作负载也不安全，由于运行时矢量攻击\n\n虽然企业采用 Kubernetes 技术的速度比以往任何时候都快，但它们并不是 100% 安全的。Kubernetes 和容器化应用经常出现漏洞和黑客攻击的情况。根据 [2021 年 RedHat 的报告](https:\/\/www.redhat.com\/en\/resources\/kubernetes-adoption-security-market-trends-2021-overview)，90% 的受访者在过去一年中经历了涉及其容器和 Kubernetes 环境的安全事件。\n\n分布式系统失败的常见原因之一是 Kubernetes 集群在运行时（或实时）的矢量攻击，并带来了一系列新的安全挑战。如果黑客攻破一个 Kubernetes 容器，他们将试图攻破整个集群，这是一种复杂的矢量攻击。美国国家安全局（NSA）指出，黑客针对 Kubernetes 来[窃取数据和计算能力](https:\/\/www.zdnet.com\/article\/hacker-target-kubernetes-to-steal-data-and-processing-power-now-the-nsa-has-tips-to-protect-yourself\/)。\n\n根本原因往往是隐性信任，假设集群间的资源是可信的，集群内不安全的网络通信是安全的。\n\n### 安全配置不是开发人员的核心能力\n\n尽管 Kubernetes 给基础设施和应用交付领域带来了敏捷性和规模，但要确保安全是个挑战。有人可能会说，Kubernetes 中有一些固有的安全功能，如使用 ClusterRoleBinding 的 RBAC，Kubernetes 服务的 TLS 等，应该足够了。然而，Kubernetes 需要大量的配置来使工作负载免受外部和内部威胁。例如，在 pod 之间强制执行 TLS，在某些时候需要维护数百个 TLS 证书。\n\n而那些已经专注于开发业务功能的开发人员可能不会优先考虑安全问题。红帽公司最近发布的一份关于 [Kubernetes 安全状况](https:\/\/www.redhat.com\/en\/blog\/state-kubernetes-security)的报告显示，大型企业面临的安全事件大多与错误配置、重大漏洞有关，并遭遇到运行时安全事件。\n\n### 应用程序的交付在 CI\/CD 的帮助下获得了快速发展，而安全问题却没有\n\n通过 CI\/CD 流程、交付协调工具、GitOps 风格的部署，DevOps 团队加快了软件交付速度。许多组织可以每天将应用程序部署到生产中（如果需要，往往在几个小时内）。这种创新速度适合于组织的蓬勃发展和成长，但如果不注重强大的安全性和合规性，就会带来漏洞。\n\n我们所接触的大多数组织都在他们的 DevOps 流程中逐步发展并开始采用 DevSecOps，将安全检查整合到他们的 SDLC 过程中。作为一种实践，他们的 DevOps 团队、合规经理、安全经理、网络管理员在部署前合作讨论安全要求和构建威胁模型。\n\n## 实施零信任网络的关键因素\n\n不同的安全组织、分析师和作者提出了许多框架。例如，Forrester 建议零信任扩展（ZTX 模型），并主张保护不同的数据管道以保护数据本身。Gartner 有一个概念，叫做持续适应性风险和信任评估（CARTA），它主要侧重于分析与身份和设备相关的风险态势。\n\n我们相信，没有任何一个放之四海而皆准的框架能适用于所有的场景和所有的组织。我们为使用微服务范式开发和部署应用程序的企业提供一个零信任框架，以确保网络和应用程序的安全。\n\nTetrate 与[美国国家标准与技术研究所（NIST）](https:\/\/www.nist.gov\/news-events\/events\/2022\/01\/zta-and-devsecops-cloud-native-applications-virtual)合作，为联邦机构开发标准，以便为其微服务实施零信任架构。\n\n**你可以在 NIST 和 Tetrate 共同编写的 NIST 特别出版物中阅读在微服务中实现零信任的详细指南：《**[**微服务的安全策略**](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-204.pdf)**》、《**[**使用服务网格构建安全的微服务**](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-204A.pdf)**》、《**[**使用服务网格的基于属性的微服务访问控制**](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-204B-draft.pdf)**》、《**[**使用服务网格实现微服务的 DevSecOps**](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-204C-draft.pdf)**》和《**[**零信任架构**](https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-207.pdf)**》。**\n\n对于 CISO 和 CTO 来说，基于上述研究文件，我们主张采用持续安全框架，以实现其微服务和服务网格的零信任，避免数据泄露。在这个框架下，有 4 个关键因素需要考虑。\n\n![微服务的零信任网络框架](008i3skNly1gygh9tlkvlj31gw0skgnr.jpg)\n\n微服务的零信任网络框架\n\n**1. 安全网络**\n\nDevSecOps 团队的首要任务是确保网络和数据的完整性。到你的应用程序的流量可以来自任何地方：包括企业自有网络内部和外部。任何设备或请求都不应该被信任，不管它们是否属于企业网络。所有的通信都应该以加密、认证和授权的方式进行，以保护数据的机密性，防止恶意行为者从网络中窃取数据。\n\n**2. 保障资源**\n\n资源可以是小型应用（服务或工作负载），可以向网络内的其他应用发送流量。一个网络可能由多个服务组成，每个服务将通过网络使用 API 调用与其他服务对话，以执行某些业务功能和逻辑。在授予访问权以发送处理请求之前，必须根据已建立的资源身份，对每个服务的信任进行评估。认证和授权检查服务身份必须发生在一个会话中，而且服务不应该默认继承对所有资源的访问。\n\n**3. 确保用户安全**\n\n对一个应用程序的威胁可能是由内部或外部用户造成的。这就是为什么在授予访问权之前要通过适当的认证来评估每个请求者的可信度。就像保护资源一样，对用户的访问应该以完成任务所需的最小权限来授予，而且应该是基于会话的。当然，各种用户会根据他们的角色获得访问权限。DevOps 团队和安全部门应该谨慎地分配权限，定义角色，并对用户进行治理，以避免安全和合规性威胁。\n\n**4. 最大限度地提高可见性**\n\n为了实施零信任网络，IT 安全组织必须不断实时评估其 IT 环境的安全态势，特别是微服务。为了对任何安全事件做出反应，安全团队必须配备适当的信息和可见性，以加快诊断和分流。应该有一个适当的机制，从企业网络的资源中追踪和隔离损坏的或脆弱的资源或用户或设备。\n\n## Tetrate Service Bridge（TSB）如何帮助开箱即用？\n\n[Tetrate Service Bridge(TSB)](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 通过一个与云无关的集中式平台为所有从边缘到工作负载的应用和 API 实现安全、敏捷和可观测性。它为平台所有者提供所有环境的内置安全和集中的可见性和治理，同时授权开发人员为其应用程序做出本地决定。\n\nTSB 通过为您的应用程序和云平台提供 FIPS 认证的构建，Istio 和 Envoy 的生命周期管理，以及其他增强功能以提高可用性，将 Istio 和 Envoy 增强为企业级服务网格。\n\nTetrate Service Bridge（TSB）位于应用边缘，负责控制所有计算集群的请求级流量、多云、Kubernetes 和传统计算集群之间的流量转换，并提供南北 API 网关功能。TSB 还提供了一个带有 [NGAC](https:\/\/www.tetrate.io\/blog\/unpacking-next-generation-access-control-ngac-and-tetrate-q\/) 框架的全局管理平面，以定义安全策略和配置，获取遥测数据，并在整个网络拓扑结构中处理 Istio 和 Envoy 的生命周期。有了 TSB，安全团队可以将安全从应用代码栈中剥离出来，放在属于他们的透明网络层中 —— 避免开发人员为安全而耗费精力修改代码。\n\nDevOps 团队仍然可以继续执行他们的计划，根据业务需求更快地将应用程序部署到多云中，而安全方面可以对微服务的安全策略进行集中控制。让我们看看 TSB 组件如何帮助实现安全。\n\n![微服务的零信任网络的 Tetrate 实现](008i3skNly1gyggs2hdtaj30wi0q20uz.jpg)\n\n微服务的零信任网络的 Tetrate 实现\n\nTSB 提供保护您的资源、网络、用户和最大限度地提高可见性。\n\n**1. 安全命名，用于服务间的授权，以确保资源安全**\n\n由于 Tetrate Service Bridge（TSB）建立在 Istio 上，默认情况下它提供安全命名，以确保工作负载（VM 和 Pod）属于同一个微服务。TSB 为每个工作负载（VM 或 Pod）创建服务身份，并将信息存储在安全名称信息中。服务器身份在证书中进行编码，但服务名称是通过发现服务或 DNS 检索的。安全命名信息将服务器身份映射到服务名称。从（例如）服务 A 到服务名称 B 的身份映射意味着 \u0022A 被授权与服务 B 对话”。\n\n**2. 基于 mTLS 的服务认证，确保网络安全**\n\nTSB 提供 Istio 点对点认证资源，以验证客户端与安全工作负载的连接。它使你能够通过 Envoy 代理在你的服务网格中实现 mTLS 认证，这是一个与每个服务一起工作的小应用程序（也被称为 sidecar 代理）。客户端 Envoy 代理与服务端 Envoy 代理进行握手，只有当相互的 TLS 连接建立后，流量才从客户端转移到服务器端。\n\n基于 mTLS 的认证被称为点对点（P2P）认证，不需要改变任何服务代码。基于 mTLS 的 p2p 认证为每个服务提供了一个强大的识别，以实现跨集群和多云的互操作性。安全管理人员现在可以在 TSB 管理平面中定义基于 mTLS 的认证策略，对网络中的服务间的通信进行加密。有了安全的网络，就没有中间人攻击的机会。\n\nTSB 提供了一个证书管理系统，自动生成、分发和轮换私钥和证书，以解密请求中的数据。\n\n**3. 基于 JWT 的认证，以确保来自内部和外部用户的应用安全**\n\n对于终端用户的认证，以验证附加在请求上的凭证，TSB 提供现有的 Istio 资源（也称为请求认证）。安全管理人员现在可以利用 Istio 资源，通过验证 JSON 网络令牌（JWT）来验证凭证。该令牌将有令牌的位置、发行者的详细信息和公共 JSON 网络密钥集。安全经理可以根据他们的组织标准指定认证策略和规则，TSB 将根据令牌与策略的匹配程度拒绝或接受用户请求。\n\n由于 TSB 全局管理使用 Istio，它提供了灵活性，可以与您选择的认证供应商连接，如 OpenID Connect 供应商，例如，KeyCloak、OAuth 2.0、Google Auth、Firebase Auth 等。\n\n**4. 对安全资源和用户进行访问控制的授权策略**\n\nTSB 授权策略允许安全经理创建跨服务网格、命名空间和工作负载的访问控制。比如说，一个真实的用户已经进入了一个系统，但是应该限制他在该系统下采取任何行动。\n\n安全经理现在可以使用单一资源定义工作负载之间和最终用户之间授权的细化规则（如允许、拒绝或自定义请求）；易于使用和维护。最重要的是，TSB 中的 Istio 授权策略支持通信框架，如 gRPC、HTTP、HTTPS 和 HTTP\/2、TCP。\n\n**5. 可观测性和实时可见性**\n\nTetrate Service Bridge（TSB）允许安全管理人员主动监控和测量微服务的完整性和安全态势。TSB 控制平面产生运行时遥测数据，帮助安全人员、网络管理员和 SRE 不断跟踪服务的行为。除了生成指标，TSB 还提供运行时的可观测性，如每个服务的流量和服务依赖关系。TSB 管理平面提供对信息的可见性，如谁被授权使用什么服务，什么被加密等。\n\n安全团队现在可以看到每个服务是如何与其他服务互动的，在发生恶意攻击的情况下，他们可以迅速隔离被破解的应用程序，以免损害其声誉，然后准备发布补丁。此外，TSB 为选定的时间段生成审计日志，提供每个访问信息的方式、内容、时间和地点的完整视图。审计日志帮助审计人员和安全经理追踪潜在的安全漏洞或任何违反策略的行为，并帮助迅速找到问题的根源。\n\n## 总结\n\n如果安全团队能够保护网络，在每笔交易中验证服务和用户的身份，并获得 360 度的可见性，以便在发生事故时做出更快的反应，他们就达到了微服务的零信任。通过零信任架构，安全团队可以消除从网络中窃取数据（用户凭证、网络访问和横向移动能力）的风险。另一方面，终端用户可以获得一致的、稳定的，更重要的是安全的体验，无论他们在什么地方，使用什么终端，或者他们的应用程序是在企业内部还是在云中。\n\n如果你对此感兴趣的话，你可以：\n\n- 注册参加即将举行的关于 [ZTA 和云原生应用的 DevSecOps 的](https:\/\/www.tetrate.io\/zta-devsecops-conference-2022\/)安全会议\n- 阅读更多关于 [TSB 提供的服务](https:\/\/www.tetrate.io\/zero-trust\/)如何[帮助您在微服务中实现零信任的信息](https:\/\/www.tetrate.io\/zero-trust\/)\n- 下载我们的白皮书，了解[为什么使用 Istio 服务网格来实现零信任安全](https:\/\/www.tetrate.io\/white-paper-zero-trust-architecture\/)\n', '\/trans\/zero-trust-network-for-microservices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本博客将向您介绍零信任网络及其基本要素，这是 CISO（首席信息安全官）必须考虑的，以使网络强大，在当今的数字转型中没有安全漏洞，并减少潜在的财务损失。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/can-ztna-replace-vpn/">[译] ZTNA 能取代 VPN 吗？——三种远程访问方法对比</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/10/13</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://assets.ctfassets.net/slt3lc6tev37/IcpGyTHplQhOeB60k1Egp/e49211fc4482b67f3bf264c22923ef5c/Can_ZTNA_replace_your_VPN" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('ZTNA 能取代 VPN 吗？——三种远程访问方法对比', '本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。', '\n## 编者按\n\n本文译自 Cloudflare 出品的白皮书 [*Can ZTNA replace your VPN? Compare 3 remote access approaches*](https:\/\/assets.ctfassets.net\/slt3lc6tev37\/IcpGyTHplQhOeB60k1Egp\/e49211fc4482b67f3bf264c22923ef5c\/Can_ZTNA_replace_your_VPN)，本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。\n\n## 简介\n\n安全、无缝的远程访问是一个业务促进因素——提高远程用户的生产力，减少 IT 团队花在入职和维护用户与应用连接的时间，并具有灵活性和弹性。然而，远程访问对许多企业来说仍然是一个挑战。\n\n很久以前，VPN 提供了一种简单的方法，将一些远程用户短暂地连接到企业网络。然而，随着劳动力的分布越来越广——企业需要在更长时间内保持远程用户的安全连接——这种方法的缺陷变得很明显，从性能低下、安全风险增加到扩展性问题。\n\n随着远程访问需求的增长，企业正越来越多地从传统的 VPN 实施方式转向更安全、性能更高的远程访问解决方案。零信任网络访问（Zero Trust Network Access），或称 ZTNA，围绕特定的应用程序、私有 IP 和主机名创建安全边界，用基于身份和背景授予访问权的默认拒绝策略取代默认允许的 VPN 连接。\n\n![](008i3skNly1gvco15q2jsj619a0nead202.jpg) \n\n2020 年，大约 5% 的远程访问使用主要由 ZTNA 提供服务。由于传统 VPN 访问的局限性以及提供更精确的访问和会话控制的需要，预计到 2024 年，这一数字将跃升至 40%。\n\n虽然 ZTNA 为企业提供了比 VPN 更明显的优势和更多的功能，但许多组织发现它并不能完全替代 VPN 基础设施。但是，随着 ZTNA 变得更加强大，VPN 问题变得更加严重，这种情况正在迅速改变。本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。它解释了 Cloudflare 如何提供 ZTNA，并推荐了一套行动步骤，将传统的 VPN 基础设施过渡到更快、更安全的远程用户零信任连接。\n\n## 方法 1：传统的 VPN\n\n几十年来，VPN 使组织能够将其远程用户连接到公司网络，并具有一定的隐私和安全性。在公共互联网上访问敏感信息，任何攻击者都可能窥探或窃取数据，而 VPN 允许用户通过加密连接安全访问内部资源。\n\n两种最常见的 VPN 实施模式是基于客户端的 VPN 和无客户端的 SSL-VPN。每种模式都有各自的好处和挑战。\n\n基于客户端的 VPN 通过加密的隧道将远程用户连接到一个私人网络。这种连接是通过一个软件应用程序或客户端建立的，它要求用户用用户名和密码进行一次认证，以获得对该网络内任何资源的持续访问。\n\n**优点**\n\n一旦建立连接，就自由的横向移动使用户很容易通过访问应用程序和连接到内部主机来快速访问多种资源。\n\n**挑战**\n\n- 不是为漫游用户和移动设备设计的。当用户四处漫游时，他们的笔记本电脑和移动设备都会随着无线网络的变化而无缝地重新连接。然而，VPN 客户端不善于流畅地处理这些重新连接，要求用户反复强迫 VPN 客户端重新启动和重新认证——造成生产力的损失，并产生 IT 票据。\n\n- 可见性差。采用这种方法，VPN 基础设施在数据中心的内部防火墙背后终止了来自 VPN 客户端的加密隧道。虽然这些连接被记录下来，但没有特定的应用集中日志来显示用户访问了哪些应用或他们在应用中采取了哪些行动。\n\n无客户端的 SSL-VPN 门户允许少数远程用户连接到私人网络中的一些基于浏览器的应用程序。这种连接是通过运行 VPN 服务的网络设备中内置的 Web 服务器实现的。\n\n**挑战**\n\n- 安全问题。数据中心内的大多数 VPN 设置允许用户完全访问，这给那些不希望非雇员（如承包商）不受限制地访问敏感资源和应用程序的组织带来了问题。\n\n- 不是为支持大量的并发用户而建立的。与现代云服务不同，门户网站的网络服务器不能弹性扩展以满足更高需求。相反，必须安装更多的网络设备并进行负载均衡，以扩大门户的规模，这通常是昂贵、复杂和无效的，因为设备的其他功能可能没有被充分利用。\n\n- 无客户端的 SSL-VPN 门户使防火墙端口和网络服务器暴露在攻击之下。为了让托管门户的网络服务器能够到达内部应用，管理员必须开放入站防火墙端口，使其暴露在外部攻击之下。开放的端口和网络服务器本身都必须屏蔽 DDoS 和网络应用的攻击，这需要更复杂的配置和更高的成本，以确保这种连接方法的安全。\n\nwpsfkrjr5.png) \n\n 虽然 VPN 为远程用户提供了基本的隐私，但在设计时并没有考虑到安全性或可扩展性。传统上，企业使用 VPN 将少数远程用户短期连接到企业网络。然而，随着远程工作变得越来越普遍，VPN 问题开始成倍增加。\n\n- 用户体验到性能低下。如果 VPN 基础设施没有能力处理其员工创造的流量吞吐量和并发连接，用户的互联网连接就会变慢。此外，当 VPN 距离用户和他们试图访问的应用服务器都很远时，就会造成访问延迟。\n\n- 企业网络容易受到攻击。VPN 通常采用城堡和山丘模式，即用户一旦连接到网络，就可以不受限制地访问所有企业资源。由于没有内置的方法来限制对关键基础设施和数据的访问，企业被迫配置昂贵、复杂的安全服务，如下一代防火墙和网络访问控制——或者容易受到恶意的横向移动，导致更大的数据泄露。\n\n**托管 VPN 服务的挑战**\n\n一些供应商已经将运行 VPN 服务的网络设备转移到公有云中，作为虚拟机在一个或多个数据中心运行。VPN 可能与其他安全服务捆绑在一起，也可能不与之捆绑在一起（或与之串联）。\n\n将 VPN 置于云中，似乎可以解决硬件 VPN 设备固有的一些可扩展性问题。然而，这样做也带来了一些重大的安全和可扩展性挑战。\n\n例如有一个组织托管一个完整的 NGFW（下一代防火墙），将 VPN 与防火墙和其他安全功能结合起来。由于 NGFW 是作为一个捆绑服务提供的，因此不可能根据需求独立扩展任何特定功能。扩大一个功能需要扩大整个服务；要做到这一点，必须启动更多的虚拟机，以平衡每个虚拟机中执行的少量计算的负载。这不仅是一个不切实际且不便的解决方案，而且随着组织的远程访问需求不断扩大，很可能会产生高额费用。\n\n## 方法 2：零信任网络访问\n\n零信任安全规避了 VPN 所固有的许多挑战。它所依据的原则是，网络内部或外部的任何用户或设备都不能被默认信任。为了减少数据泄露、内部攻击和其他威胁的风险和影响，零信任方法——\n\n- 对每一次登录和请求进行认证和记录。\n\n- 要求对所有用户和设备进行严格的核查。\n\n- 根据身份和背景，限制每个用户和设备可以访问的信息。\n\n- 并增加了端对端加密，以隔离网络中的应用和数据。\n\n![](008i3skNly1gvcoksofzvj61o80u0q5q02.jpg) \n\n与 VPN 一样，ZTNA 有两种配置方式：\n\n1. 无客户端（或服务发起的）ZTNA 使用现有的浏览器，而不是客户端，来创建一个安全连接并验证用户设备。传统上，无客户端 ZTNA 仅限于具有 HTTP\/HTTPS 协议的应用，但兼容性正在快速发展。 \n\n- 优点：无客户端 ZTNA 使用反向代理连接，防止直接访问应用程序，阻止用户访问他们可能没有权限查看的应用程序和数据，并允许管理员在管理方面有更强的控制和灵活性。\n\n2. 基于客户端（终端启动）的 ZTNA 在控制代理和授权应用之间建立加密连接之前，在用户设备上安装软件。\n\n- 优点：基于客户端的 ZTNA 使管理员能够更深入地了解用户访问应用程序的设备状态、位置和风险背景，因此可以创建和执行更精细的策略。而且，由于这种方法不限于 HTTP\/HTTPS，它可以用来访问更广泛的非 HTTP 应用——例如那些依赖 SSH、RDP、VNC、SMB 和其他 TCP 连接的应用。\n\n**实施 ZTNA 的挑战**\n\n虽然 ZTNA 与传统的 VPN 相比具有明显的优势，但它并不是一个确保远程用户网络访问安全的完美方法。当企业权衡采用零信任的利弊时，他们可能会遇到以下一个或多个挑战。\n\n1. 解决方案并不是真正的云原生。\n\n如果供应商不提供基于云的 ZTNA——意味着他们的客户需要在自己的数据中心部署软件，那么用户就会失去即时可扩展性和无限吞吐量等关键优势。\n\n2. 供应商可能不提供基于客户端和无客户端的 ZTNA 选项。\n\n这限制了那些需要将用户连接到非 HTTP 应用（如远程桌面、SSH 应用或文件共享）的组织的价值。\n\n3. 配置可能是复杂和耗时的。\n\n不提供策略协调和自动化支持的供应商（通过 Terraform 等工具）可能会给管理员带来更多的手动工作——除了在身份提供者中已经发生的配置之外。\n\n## 方法 3：Cloudflare 的远程访问方法\n\n保护和扩展远程访问应该是一个无缝的过程，一个不分层的笨重的安全解决方案，创造性能的权衡，减少不必要的成本。Cloudflare 使团队能够处理所有的远程访问用例，具有以下好处。\n\n- 为用户和管理员提供简单、无风险的入职培训。Cloudflare 很容易与现有的身份供应商和终端保护平台集成，以执行限制访问企业应用程序和资源的零信任政策。\n\n- 基于客户端和无客户端的 ZTNA 部署的灵活性。Cloudflare 为网络、SSH、VNC（以及即将推出的 RDP）应用程序的连接提供无客户端支持，为非 HTTP 应用程序和内部 IP（以及即将推出的主机名）的私有路由提供基于客户端的支持。\n\n![](wpsxPzRG3.png)  \n\n表 1：Cloudflare 如何应对远程访问挑战\n\n| 问题             | 解决方案        | Cloudflare 的实施                                   |\n| -------------------------- | ------------------------- | ------------------------------------------------------------ |\n| 难以扩展                   | 全局边缘网络            | 可扩展性问题困扰着非云原生的 VPN 和 ZTNA 服务，使远程用户难以访问应用程序和数据。Cloudflare 的全球 Anycast 网络不仅使用户的连接速度比 VPN 快，而且还确保任何规模的远程工作者都能根据需要安全、迅速地连接到企业资源，而不需要管理员进行额外的耗时配置。 |\n| 与移动设备的兼容性差       | 轻量级客户端              | 利用 IPSec 和 SSL 协议的 VPN 和 ZTNA 解决方案在移动和漫游设备上的性能往往不佳。Cloudflare 的 WARP 客户端利用更现代的 Wireguard 协议，该协议在用户空间运行，支持更广泛的操作系统选项，与传统选项相比，用户体验更好。Cloudflare 的 WARP 客户端可以在 Windows、MacOS、iOS、Android 和即将到来的 Linux 设备上配置。 |\n| 没有集成的或薄弱的 DDoS 保护 | 内置行业领先的 DDoS 保护    | 如果没有集成的 DDoS 保护，企业往往被迫以 daisy-chain 方式提供额外的安全服务，这可能会造成配置上的麻烦、可扩展性问题和安全挑战。Cloudflare 的 67\u002bTbps 网络为任何 ZTNA 模式提供内置的 DDoS 保护，抵御最大规模的攻击。 |\n| 协议的限制             | 非网络应用程序支持        | 模式兼容性：用于 SSH\/VNC 应用的无客户端 ZTNA；用于所有其他非网络应用的基于客户端的 ZTNA。 |\n| 没有集成的网络防火墙       | 内置网络防火墙            | 随着企业网络的发展，企业必须平衡的安全硬件堆栈也在不断增加——导致成本、性能和安全方面的折衷。Cloudflare 使管理员能够在边缘执行网络防火墙策略，使他们能够精细地控制哪些数据允许进出网络，并提高流量流经网络的可见性。  ✓ 模式兼容性：基于客户端的 ZTNA |\n| 缺乏细粒度的控制           | 内置安全网关（SWG） | 未经批准使用应用程序会给企业带来严重的安全问题；如果没有严格的政策，用户可能会访问和篡改敏感数据和其他企业资源。结合 ZTNA 和 SWG，Cloudflare 允许管理员对应用程序内的用户和设备访问权限进行更精细的控制，因此用户和基于角色的组只能访问他们需要的资源。✓ 模式兼容性：基于客户端的 ZTNA |\n\n## 用零信任网络访问取代传统 VPN\n\n在向无 VPN 安全过渡的漫长而痛苦的过程中，IT 安全领导可能会觉得零信任的承诺很空洞。但是，用零信任网络访问取代 VPN 是可能的，而不需要在协议支持或功能上做出取舍。\n\n推荐的迁移路径根据驱动你的项目的业务专家而有所不同。\n\n- 如果更快连接到应用程序是你的首要任务，请部署基于客户端的 ZTNA，首先用于非网络应用。\n\n- 如果加强你的应用程序访问规则的安全性更为重要，那么就从网络应用开始。替换 VPN 只是整个网络转型的第一步。由于向 SASE 模式的过渡可能是压倒性的，我们根据客户采取的方法，分解了一条通往零信任安全的常见路径。\n\n\n![](008i3skNly1gvcoknm2onj61tx0u0thb02.jpg)  \n', '\/trans\/can-ztna-replace-vpn\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文对比了 VPN 和 ZTNA 远程访问解决方案，阐明了它们的好处和局限性，同时阐明了迁移项目的最重要考虑因素。同时给出了 Cloudflare 的解决方案及迁移到 ZTNA 的步骤建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/zero-trust-architecture/">[译] 零信任架构白皮书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%89%e5%85%a8"> 
             安全
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.tetrate.io/white-paper-zero-trust-architecture/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('零信任架构白皮书', '本文译自 Tetrate 发布的《零信任架构白皮书》。', '\n## 背景介绍\n\n传统的数据中心网络安全架构试图在一个优美的内部花园周围建立强大的围墙。这种堡垒模型长久以来存在一个固有的弱点，即当（而不是如果）入侵者渗透到周边时，他们就可以控制整个花园。虽然这个弱点早就存在，但随着进入数据中心的入口的增加及工作负载的扩展的趋势增加，这个弱点越发严重。\n\n零信任网络架构提供了一条前进的道路，它解决了基于周界安全的弱点，采取的立场是网络本身就是敌对的；周界背后的安全是一种幻觉，野蛮人已经撞开了大门。\n\n虽然零信任需要对现状进行重大反思，但它远不是一个崇高的、不可实现的目标。现在就有一些工具可以开始实施零信任网络架构。这些工具和实践可以逐步实施，以满足你的需要，而不是要求你全盘重新构建你的整个网络安全基础设施。\n\n## 传统安全模式的弱点\n\n周边安全薄弱的原因与现代军队放弃大规模固定防御的原因类似：一旦被渗透，战斗就会失败；而周边安全最终也会被渗透。\n\n**单纯的周边安全提供了糟糕的控制粒度。**如果周界内的所有流量都是可信的，那么一个漏洞就会使周界内的一切都变得脆弱。当网络服务只有几十种时，这可能是可控的，而且可以通过物理位置严格限制访问，但服务激增到几十万种，而且都是以相同的访问水平相互通信，这使得目前的技术状态无法维持，特别是由于一个被破坏的服务可以转移到许多其他服务。\n\n多年来，业务需求已经削弱了外围的完整性。出于需要，防火墙上被打了很多洞，导致了多个暴露的入口点和难以管理的防火墙规则的扩散，使外围更像是一条马奇诺防线，而不是围墙和城堡。\n\n面对周界几乎消失的情况，为改善周界安全模式所做的新努力，如微分割和软件定义网络，有助于减少服务周围的攻击面。但是，它们也只是部分解决方案，其代价是复杂性的增加和配置规则的爆炸。分割仍然提供了糟糕的粒度。例如，隔离网络服务器和数据库服务器可以减少这些服务周围的攻击面，但网络服务器可能支持许多应用程序，它们各自可能引入的漏洞仍然是不透明的。\n\n## 零信任的信条\n\n\u0022*信任不是理想的状态，信任是你想避免的失败点*\u0022——约翰·金德瓦格\n\n零信任是一种方法，一种对网络安全的思考方式，而不是任何特定的架构或实现。它从一个假设开始，即网络上没有安全的地方。你应该把你的数据中心，不管它是否喜欢，当作它所有的数据和服务都暴露在公共互联网上。\n\n在零信任模式中，与传统的周边安全不同，可及性并不意味着授权。零信任旨在缩小资源周围的隐性信任区域，最好是缩小到零。在一个零信任的网络中，所有对资源的访问都应该是这样的。\n\n- **经过认证和动态授权**：不仅在网络层和服务间层，而且在应用层。网络位置并不意味着信任。在允许任何访问之前，服务身份和终端用户凭证是经过认证和动态授权的。\n- **有时间限制**：认证和授权被约束在一个短暂的会话中，之后必须重新建立。\n- **在空间上有界限**：一个服务周围的信任周界应该尽可能小。加密，既是为了防止窃听，也是为了确保信息的真实性和未被篡改。\n- **可观察**：所以所有资产的完整性和安全态势可以被持续监控，策略的执行可以持续得到保证。另外，从观察中获得的洞察力应该被反馈到改进策略上。\n\n### 为什么它更好？\n\n- 可访问性不是授权——与周边安全不同，对一个服务的访问并不仅仅是因为该服务是可以到达的，它还必须经过明确的认证和授权。\n\n- 经过认证和授权的工作负载受到保护，不受周边漏洞的影响。\n- 在时间上的约束限制了凭证受损的风险。\n- 在空间上的约束允许策略执行的高颗粒度。\n- 动态策略执行确保授权策略是最新的。\n- 加密限制了侦查，并提供了通信的真实性。\n- 细粒度的可观测性允许实时保证策略的执行，以及对历史上如何执行策略的事后审计，还有用于故障排除和分析的必要数据。\n\n零信任系统的试金石是，部署在该系统中的应用程序在公开曝光时不会有任何变化。如果实施得当，一个零信任的安全架构在公开的互联网上运行时与在防火墙后面运行时一样安全。\n\n### 我什么时候需要它？\n\n虽然每个组织都可能从采用零信任原则中受益，但期望几十年的基础设施和业务流程全盘转变为新模式是不现实的。\n\n特定的压力可能会促使你尽早这样做。当你的基础设施跨越不同的供应商时，例如，分裂的企业内部和云部署或混合云部署，在这些扩展的网络上大规模应用 VPN 和 NAT 的复杂性和脆弱性可能使得在短期内对这些部署应用零信任网络原则具有成本效益和风险效率。\n\n## ZTA 组件\n\nNIST 提出了三个逻辑组件来实现动态授权和认证。\n\n1.    一个策略引擎（Policy Engine，简称 PE），负责确定授权。\n2.    一个策略管理员（Policy Aadminstrator，简称 PA），用于根据策略引擎的结果建立和\/或关闭通往资源的通信路径。\n3.    策略执行点（Policy Enforcement Point，简称 PEP），位于提出请求的主体和目标资源之间，启用、监测和终止它们之间的连接。\n\n![图一](008i3skNly1gpsrzpm3cvj31n40u0whm.jpg)\n\n在这种模式下，主体要求的所有工作负载必须有一个身份，可以在 PEP 进行认证和授权。策略决策点对这些身份执行策略，并在允许访问之前执行认证和授权。在这里，授权是基于细粒度的策略；可及性不算作授权。数据平面的 PEP 允许在运行时对系统进行观察，并确保持续的合规性和治理控制。\n\n## 实施\n\n由于零信任不是一个蓝图，而更像是一种设计理念，因此有许多潜在的方法来实现零信任架构。作为服务网格和下一代访问控制（NGAC）技术的创始人和实施者，我们认为服务网格与 NGAC 相结合，为建立零信任架构网络提供了最佳基础。\n\n服务网格提供了你所需要的重要基元：\n\n- 集中管理的策略授权\n- 分布式策略执行点——PEP 与资源访问点（RAP 共同部署）\n- 内置支持基于运行时身份而非网络位置的工作负载身份\n- 内置支持终端用户的应用级认证和授权，允许对网状结构中的每个应用进行全局和一致的策略执行\n- 对线上数据进行加密\n- 内置可观测性\n\n网格提供了操作上的保证，你可以在部署认证和授权系统时使用网格，使它们更安全，更容易管理。我们可以很容易地用服务网格中的组件来重新绘制图一中所代表的 NIST 的逻辑架构。\n\n![图二](008i3skNly1gpsrzq4xikj31da0u0acq.jpg)\n\n\n服务网格的透明性允许我们逐步采用，而不需要对你的安全基础设施和业务流程全面推倒重建。网格对应用程序、部署和安全问题的解耦意味着你可以开始在现有的基础设施上建立一个零信任的架构，而不扰乱你的业务流程和应用程序交付生命周期。\n\n\n## 案例研究——美国国防部 Platform One\n\n\u0022老实说，我任务在没有服务网格的情况下无法获得任何有意义的成功；也许在 2018 年可以，但在 2020 年和这以后不可能。\u0022 ——美国空军首席软件官尼古拉斯·M·查兰（Nicolas M. Chaillan）。\n\n美国国防部在空军首席软件官 Nicolas M. Chaillan 的主持下，对其开发和运营软件的方式进行了革新。由 Chaillan 领导的在整个国防部发展 DevSecOps 实践的团队 Platform One，提供了多种企业服务，将 \u0022自动化的软件工具、服务和标准带到国防部的项目中，使作战人员能够在安全、灵活的情况下创建、部署和操作软件应用。\n\n这些服务包括他们的 DevSecOps 平台（DSOP），这是一个经批准的、符合 CNCF 标准的 Kubernetes 发行版的集合，还有 Istio、基础设施即代码的手册和加固的容器。\n\n根据 Chaillan 的说法，\u0022拥有一个集中的、由政府提供的、团队可以来使用的 DevSecOps 堆栈，这改变了游戏规则。\u0022过去，软件更新周期长达数年，而现在国防部 \u0022每天都在推送代码，一天推送多次......每个项目的初始计划时间每 5 年平均节省 12 至 18 个月。\u0022\n\nIstio 是他们架构的一个主要支柱，它提供了服务网格的能力，特别是它实现零信任模型的方式。当被问及为什么他们使用服务网格而不是仅使用入口控制器时，他不仅提到每个应用程序默认都有 mTLS 传输加密，而且 \u0022一旦你转向微服务和容器，你必须管理东西向流量，这与南北向完全不同……你需要确保横向移动受到限制。你不希望一个坏人获得一个容器的访问权，并能够......横向移动到其他容器。除了 SSO 和 mTLS，Platform One 的架构使用 Istio 来执行东西向白名单，并在容器之间提供策略执行点。\n\n该网格将策略执行从应用堆栈中剥离出来，并将其透明地转移到 sidecar 代理上。Platform One 能够将不同应用团队独立构建的多个 \u0022雪花 \u0022应用级 SSO 和加密实现整合为一个加固的单点登录和授权库，可供企业范围内所有应用使用。这就减轻了开发团队在每个应用中构建安全的负担。它还通过对单一的、经过严格审查的实施方案进行标准化，大大降低了漏洞风险。\n\nChaillan 说，\u0022如果你不使用服务网格，你最终不得不按语言、按微服务来做。而现在你是紧密耦合的。而且，比方说，在过去如果你想要更新加密位数，你就必须更新所有容器，而现在只需要更新服务网格中的 sidecar，现在你已经解耦了。仅此一点，就值得使用服务网格。”\n\n## 总结\n\n周边安全模式及其渐进式的后继者过于脆弱和复杂，无法满足现代应用开发和部署的需要。现在应用程序的构建方式需要一个动态的、灵活的安全解决方案，一个既能集中管理又能普遍适用于所有应用程序开发团队的解决方案。零信任架构在网络和应用层面提供了急需的安全改进，而服务网格为实现零信任提供了最强大、动态和灵活的方式。\n\n在所有服务和所有应用之间部署全局管理的策略执行点，服务网格提供了插入零信任功能的模拟点，如 SSO、mTLS 和动态授权。通过在全局范围内将安全责任从单个应用程序抽离到服务网格，企业有可能逐步采用零信任原则，而无需重写应用程序或改变现有流程。\n', '\/trans\/zero-trust-architecture\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文译自 Tetrate 发布的《零信任架构白皮书》。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(71)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(41)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(18)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-data-plane-deployment-modes/">深入解析服务网格的四种数据平面部署模式：性能、安全性与成本分析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/service-mesh-sidecar-vs-sidecarless-debate/">服务网格架构：Sidecar vs. Sidecarless，谁才是未来？</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/hong-kong-trip/">香港——内地的一面的镜子</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
