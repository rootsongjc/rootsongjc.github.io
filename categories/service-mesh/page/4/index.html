<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>服务网格专栏 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/service-mesh/" />
  <meta property="og:title" content="服务网格专栏 | Jimmy Song" />
  <meta property="twitter:title" content="服务网格专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。" />
  <meta property="twitter:description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/service-mesh/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    服务网格专栏
                </p>
                <p class="page-description">
                    欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-in-action-by-yangzhangxian-review/">《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感', '顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。', '\n最近在回顾 Service Mesh 技术在 2018 年的发展，想再看看 Linkerd，正好**杨彰显**的这本《Service Mesh 实战——基于 Linkerd 和 Kubernetes 的微服务实践》上市发售了，**机械工业出版社**的编辑送了我一本，🙏**杨福川**编辑，我看了下抽空写了点读后感，我看了下抽空写了点读后感，其实也说不上是读后感，就当是自己的一点感悟吧，就当拿此书借题发挥吧，这个知识爆炸的年代，技术发展如此迅速，可以说是 IT 人员的幸运，也是不幸！有多少写开源软件的书推出一版后能撑过三年的？如果软件红得发紫，持续迭代 N 个版本，例如 Kubernetes，最近两年以每三个月一个版本的速度迭代，之前的书早就跟不上节奏，要么就要不断推出新版，直到软件稳定后不再有大的改动。还有种可能就是软件推广和发展的不理想，无人问津，写这样软件的书就不会有再版了。\n\n拿到本书后我的第一反应就是看看这本书定稿的时候 Istio 是什么版本，Linkerd 又是什么版本。因为在这一年内两款开源软件都有较大的版本变动，如果书籍定稿的时候基于的软件版本太低，软件架构可能会有较大的变化，影响书中示例和部分章节的时效性。这也是大多技术书籍名短的症结所在，技术发展是在太快，传统的书籍出版流程往往过于繁琐和冗长，等到书籍出版后所介绍的软件都出了好几个版本。例如 Kubernetes 这种的软件，每三个月一个版本，而写一般书从策划到发行少说半年，一般也要一年的时间。\n\n## 关于书籍定稿时的软件版本\n\n**Istio 0.8**\n\n本书第一章「Service Mesh 简介」对 Service Mesh 相关开源产品介绍时提到本书定稿时 Istio 是 0.8 版本，而 Istio 在 2018 年 7 月 31 日发布了 1.0 版本。\n\n这本书定稿时，Istio 的最新版本是 0.8。\n\n**Linkerd 1.3.6**\n\n本书从序言开始一直到第二章结束也没有提及写作时基于的 Linkerd 版本，我在第二章的安装步骤中看到了说明。\n\n可以看到本书写作时是基于 Linkerd 1.3.6 版本，而 Linkerd 在同年的 9 月 18 日发布了 [2.0 GA](https:\/\/cloudnative.to\/blog\/linkerd-2-0-in-general-availability\/)，这一版本跟 1.x 版本相比有重大变化——它还将项目从集群范围的 service mesh 转换为可组合的 *service sidecar* ，旨在为开发人员和服务所有者提供在云原生环境中成功所需的关键工具。\n\n## Linkerd vs Envoy\n\nLinkerd 2.0 的 service sidecar 设计使开发人员和服务所有者能够在他们的服务上运行 Linkerd，提供自动可观测性、可靠性和运行时诊断，而无需更改配置或代码。通过提供轻量级的增量路径来获得平台范围的遥测、安全性和可靠性的传统 service mesh 功能，service sidecar 方法还降低了平台所有者和系统架构师的风险。该版本还用 Rust 重写了代理部分，在延迟，吞吐量和资源消耗方面产生了数量级的改进。\n\n而 Linkerd 1.x 继承自 Twitter 开源的 Finagle 高性能 RPC，所有想要深度学习 Linkerd 1.x 还需要了解 Finagle，这就跟 Istio 将 Envoy 作为默认的数据平面一样，要想深度学习 Istio 必须了解 Envoy。\n\n二者几乎使用了完全不同的术语，假如你已经了解了 [Envoy](https:\/\/envoyproxy.io) 想要再切换到 Linkerd 上，那么就要再费很多心力来学习它的概念和原理，例如如下这些术语或配置（Linkerd 中独有的配置）：\n\n- **dtab（委托表）**：由一系列路由组成，由一系列路由规则组成，以逻辑路径为输入，然后经过路由规则做一系列转换生成具体名字。这是 Linkerd 路由机制的根本，就像 Envoy 中的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)一样，本书的第四章「深入 Linkerd 数据访问流」专门讲解了 dtab 的实现机制。\n- **dentry（委托表记录）**：委托表的每条路由规则称为 dentry，如 \/consul =\u003e \/#\/io.l5d.consul\/dc1。\n- **namer**：配置 Linkerd 支持的服务发现工具。\n- **namerd**：Linkerd 的控制平面，相当于 Istio 中的 Pilot，对接各种服务发现。当然 Linkerd 也可以直接与某个服务发现平台对接如 consul，而不使用 namerd 这个集中路由和配置管理组件。\n- **interpreter**：interpreter 决定如何解析服务名字和客户端名字。\n\n虽然 Linkerd 也是 [CNCF 中的项目](https:\/\/www.cncf.io\/projects\/)，但它目前还处于孵化阶段，而 Envoy 的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)已经被众多开源项目所支持，如 [Istio](https:\/\/istio.io\/zh)、[SOFAMesh](https:\/\/github.com\/alipay\/sofa-mesh)、[NginxMesh](https:\/\/github.com\/nginxinc\/nginmesh) 等，且 Envoy 已经从 CNCF 中毕业，以后可能成为 Service Mesh 领域的标准协议，Linkerd 的生存状况堪忧。\n\n## 关于本书\n\n本书中所有示例都提供了虚拟机的快速上手环境，只要使用 Vagrant 即可创建虚拟机和应用，所以在本书的[示例代码](https:\/\/github.com\/yangzhares\/linkerd-in-action)有大量的 Vagrantfile。\n\n本书第三部分「实战篇」花了大量篇幅（本书一半的页数）来讲解如何使用 Linkerd 和 Kubernetes 来管理微服务，可以参考我 2017 年 8 月 1 日写的这篇[微服务管理框架 service mesh——Linkerd 安装试用笔记](https:\/\/jimmysong.io\/posts\/linkerd-user-guide\/)，那时候还是基于 Linkerd 1.1.2，还有 [Linkerd 官方示例](https:\/\/github.com\/linkerd\/linkerd-examples\/)，这些示例基本都不怎么更新了。\n\n因为该书定稿时所基于的 Linkerd 版本距离本书发售时的 Linkerd 已经落后一个大版本（最新版本是 [Linkerd 2.1](https:\/\/blog.linkerd.io\/2018\/12\/06\/announcing-linkerd-2-1\/)），所以读者一定要注意这一点，老实说我只花了两个夜晚快速过了一下本书，无法对本书内容给出具体评论，所以本书是否是你所需要的就要你自己去思考了。\n\n', '\/blog\/service-mesh-in-action-by-yangzhangxian-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-routing-of-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/26</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发', 'Sidecar proxy 中 Indbound\/Outbound 流量处理过程详解。', '\n本文以 Istio 官方的 [bookinfo 示例](https:\/\/preliminary.istio.io\/zh\/docs\/examples\/bookinfo)来讲解在进入 Pod 的流量被 iptables 转交给 Envoy sidecar 后，Envoy 是如何做路由转发的，详述了 Inbound 和 Outbound 处理过程。关于流量拦截的详细分析请参考[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)。\n\n下面是 Istio 官方提供的 bookinfo 的请求流程图，假设 bookinfo 应用的所有服务中没有配置 DestinationRule。\n\n![Bookinfo 示例](006tNbRwgy1fvlwjd3302j31bo0ro0x5.jpg)\n\n下面是 Istio 自身组件与 Bookinfo 示例的连接关系图，我们可以看到所有的 HTTP 连接都在 9080 端口监听。\n\n![Bookinfo 示例与 Istio 组件连接关系图](006tNbRwly1fyitp0jsghj31o70u0x6p.jpg)\n\n\n可以在 [Google Drive](https:\/\/drive.google.com\/open?id=19ed3_tkjf6RgGboxllMdt_Ytd5_cocib) 上下载原图。\n\n## Sidecar 注入及流量劫持步骤概述\n\n下面是从 Sidecar 注入、Pod 启动到 Sidecar proxy 拦截流量及 Envoy 处理路由的步骤概览。\n\n**1.** Kubernetes 通过 Admission Controller 自动注入，或者用户使用 \u0060istioctl\u0060 命令手动注入 sidecar 容器。\n\n**2.** 应用 YAML 配置部署应用，此时 Kubernetes API server 接收到的服务创建配置文件中已经包含了 Init 容器及 sidecar proxy。\n\n**3.** 在 sidecar proxy 容器和应用容器启动之前，首先运行 Init 容器，Init 容器用于设置 iptables（Istio 中默认的流量拦截方式，还可以使用 BPF、IPVS 等方式）将进入 pod 的流量劫持到 Envoy sidecar proxy。所有 TCP 流量（Envoy 目前只支持 TCP 流量）将被 sidecar 劫持，其他协议的流量将按原来的目的地请求。\n\n**4.** 启动 Pod 中的 Envoy sidecar proxy 和应用程序容器。这一步的过程请参考[通过管理接口获取完整配置](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#%E9%80%9A%E8%BF%87%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE)。\n\n\u003e **Sidecar proxy 与应用容器的启动顺序问题**\n\u003e\n\u003e 启动 sidecar proxy 和应用容器，究竟哪个容器先启动呢？正常情况是 Envoy Sidecar 和应用程序容器全部启动完成后再开始接收流量请求。但是我们无法预料哪个容器会先启动，那么容器启动顺序是否会对 Envoy 劫持流量有影响呢？答案是肯定的，不过分为以下两种情况。\n\u003e\n\u003e **情况 1：应用容器先启动，而 sidecar proxy 仍未就绪**\n\u003e\n\u003e 这种情况下，流量被 iptables 转移到 15001 端口，而 Pod 中没有监听该端口，TCP 链接就无法建立，请求失败。\n\u003e\n\u003e **情况 2：Sidecar 先启动，请求到达而应用程序仍未就绪**\n\u003e\n\u003e 这种情况下请求也肯定会失败，至于是在哪一步开始失败的，留给读者来思考。\n\n**问题**：如果为 sidecar proxy 和应用程序容器添加[就绪和存活探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)是否可以解决该问题呢？\n\n**5.** 不论是进入还是从 Pod 发出的 TCP 请求都会被 iptables 劫持，inbound 流量被劫持后经 Inbound Handler 处理后转交给应用程序容器处理，outbound 流量被 iptables 劫持后转交给 Outbound Handler 处理，并确定转发的 upstream 和 Endpoint。\n\n**6.** Sidecar proxy 请求 Pilot 使用 xDS 协议同步 Envoy 配置，其中包括 LDS、EDS、CDS 等，不过为了保证更新的顺序，Envoy 会直接使用 ADS 向 Pilot 请求配置更新。\n\n## Envoy 如何处理路由转发\n\n 下图展示的是 \u0060productpage\u0060 服务请求访问 \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060，当流量进入 \u0060reviews\u0060 服务内部时，\u0060reviews\u0060 服务内部的 Envoy Sidecar 是如何做流量拦截和路由转发的。可以在 [Google Drive](https:\/\/drive.google.com\/file\/d\/1n-h235tm8DnL_RqxTTA95rgGtrLkBsyr\/view?usp=sharing) 上下载原图。\n\n![Envoy sidecar 流量劫持与路由转发示意图](envoy-sidecar-traffic-interception-zh-20210818.png)\n\n\n第一步开始时，\u0060productpage\u0060 Pod 中的 Envoy sidecar 已经通过 EDS 选择出了要请求的 \u0060reviews\u0060 服务的一个 Pod，知晓了其 IP 地址，发送 TCP 连接请求。\n\nIstio 官网中的 Envoy 配置深度解析中是以发起 HTTP 请求的一方来详述 Envoy 做流量转发的过程，而本文中考虑的是接受 downstream 的流量的一方，它既要接收 downstream 发来的请求，自己还需要请求其他服务，例如 \u0060reviews\u0060 服务中的 Pod 还需要请求 \u0060ratings\u0060 服务。\n\n\u0060reviews\u0060 服务有三个版本，每个版本有一个实例，三个版本中的 sidecar 工作步骤类似，下文只以 \u0060reviews-v1-cb8655c75-b97zc\u0060 这一个 Pod 中的 Sidecar 流量转发步骤来说明。\n\n## 理解 Inbound Handler\n\nInbound handler 的作用是将 iptables 拦截到的 downstream 的流量转交给 localhost，与 Pod 内的应用程序容器建立连接。\n\n查看下 \u0060reviews-v1-cb8655c75-b97zc\u0060 pod 中的 Listener。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc\u0060 查看该 Pod 中的具有哪些 Listener。\n\n\u0060\u0060\u0060ini\nADDRESS            PORT      TYPE \n172.33.3.3         9080      HTTP \u003c--- 接收所有 Inbound HTTP 流量，该地址即为当前 Pod 的 IP 地址\n10.254.0.1         443       TCP  \u003c--\u002b\n10.254.4.253       80        TCP     |\n10.254.4.253       8080      TCP     |\n10.254.109.182     443       TCP     |\n10.254.22.50       15011     TCP     |\n10.254.22.50       853       TCP     |\n10.254.79.114      443       TCP     | \n10.254.143.179     15011     TCP     |\n10.254.0.2         53        TCP     | 接收与 0.0.0.0_15001 监听器配对的 Outbound 非 HTTP 流量\n10.254.22.50       443       TCP     |\n10.254.16.64       42422     TCP     |\n10.254.127.202     16686     TCP     |\n10.254.22.50       31400     TCP     |\n10.254.22.50       8060      TCP     |\n10.254.169.13      14267     TCP     |\n10.254.169.13      14268     TCP     |\n10.254.32.134      8443      TCP     |\n10.254.118.196     443       TCP  \u003c--\u002b\n0.0.0.0            15004     HTTP \u003c--\u002b\n0.0.0.0            8080      HTTP    |\n0.0.0.0            15010     HTTP    | \n0.0.0.0            8088      HTTP    |\n0.0.0.0            15031     HTTP    |\n0.0.0.0            9090      HTTP    | \n0.0.0.0            9411      HTTP    | 接收与 0.0.0.0_15001 配对的 Outbound HTTP 流量\n0.0.0.0            80        HTTP    |\n0.0.0.0            15030     HTTP    |\n0.0.0.0            9080      HTTP    |\n0.0.0.0            9093      HTTP    |\n0.0.0.0            3000      HTTP    |\n0.0.0.0            8060      HTTP    |\n0.0.0.0            9091      HTTP \u003c--\u002b    \n0.0.0.0            15001     TCP  \u003c--- 接收所有经 iptables 拦截的 Inbound 和 Outbound 流量并转交给虚拟监听器处理\n\u0060\u0060\u0060\n\n当来自 \u0060productpage\u0060 的流量抵达 \u0060reviews\u0060 Pod 的时候已经，downstream 必须明确知道 Pod 的 IP 地址为 \u0060172.33.3.3\u0060 所以才会访问该 Pod，所以该请求是 \u0060172.33.3.3:9080\u0060。\n\n**\u0060virtual\u0060 Listener**\n\n从该 Pod 的 Listener 列表中可以看到，0.0.0.0:15001\/TCP 的 Listener（其实际名字是 \u0060virtual\u0060）监听所有的 Inbound 流量，下面是该 Listener 的详细配置。\n\n\u0060\u0060\u0060json\n{\n    \u0022name\u0022: \u0022virtual\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u00220.0.0.0\u0022,\n            \u0022portValue\u0022: 15001\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.tcp_proxy\u0022,\n                    \u0022config\u0022: {\n                        \u0022cluster\u0022: \u0022BlackHoleCluster\u0022,\n                        \u0022stat_prefix\u0022: \u0022BlackHoleCluster\u0022\n                    }\n                }\n            ]\n        }\n    ],\n    \u0022useOriginalDst\u0022: true\n}\n\u0060\u0060\u0060\n\n**UseOriginalDst**：从配置中可以看出 \u0060useOriginalDst\u0060 配置指定为 \u0060true\u0060，这是一个布尔值，缺省为 false，使用 iptables 重定向连接时，proxy 接收的端口可能与原始目的地址的端口不一样，如此处 proxy 接收的端口为 15001，而原始目的地端口为 9080。当此标志设置为 true 时，Listener 将连接重定向到与原始目的地址关联的 Listener，此处为 \u0060172.33.3.3:9080\u0060。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理，即该 \u0060virtual\u0060 Listener，经过 \u0060envoy.tcp_proxy\u0060 过滤器处理转发给 \u0060BlackHoleCluster\u0060，这个 Cluster 的作用正如它的名字，当 Envoy 找不到匹配的虚拟监听器时，就会将请求发送给它，并返回 404。这个将于下文提到的 Listener 中设置 \u0060bindToPort\u0060 相呼应。\n\n**注意**：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将 iptables 拦截的流量经由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n**Listener 172.33.3.3_9080**\n\n上文说到进入 Inbound handler 的流量被 \u0060virtual\u0060 Listener 转移到 \u0060172.33.3.3_9080\u0060 Listener，我们在查看下该 Listener 配置。\n\n运行 \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json\u0060 查看。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022172.33.3.3_9080\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u0022172.33.3.3\u0022,\n            \u0022portValue\u0022: 9080\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022raw_buffer\u0022\n            },\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.http_connection_manager\u0022,\n                    \u0022config\u0022: {\n                        ... \n                        \u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        },\n                        \u0022use_remote_address\u0022: false,\n                        ...\n                    }\n                }\n            ]，\n            \u0022deprecatedV1\u0022: {\n                \u0022bindToPort\u0022: false\n            }\n        ...\n        },\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022tls\u0022\n            },\n            \u0022tlsContext\u0022: {...\n            },\n            \u0022filters\u0022: [...\n            ]\n        }\n    ],\n...\n}]\n\u0060\u0060\u0060\n\n**bindToPort**：注意其中有一个 [\u0060bindToPort\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.6.0\/api-v1\/listeners\/listeners) 的配置，其值为 \u0060false\u0060，该配置的缺省值为 \u0060true\u0060，表示将 Listener 绑定到端口上，此处设置为 \u0060false\u0060 则该 Listener 只能处理其他 Listener 转移过来的流量，即上文所说的 \u0060virtual\u0060 Listener，我们看其中的 filterChains.filters 中的 \u0060envoy.http_connection_manager\u0060 配置部分：\n\n\u0060\u0060\u0060json\n\u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n\u0060\u0060\u0060\n\n该配置表示流量将转交给 Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060 处理。\n\n**Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060**\n\n运行 \u0060istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json\u0060 查看该 Cluster 的配置如下。\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n        \u0022connectTimeout\u0022: \u00221.000s\u0022,\n        \u0022hosts\u0022: [\n            {\n                \u0022socketAddress\u0022: {\n                    \u0022address\u0022: \u0022127.0.0.1\u0022,\n                    \u0022portValue\u0022: 9080\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {}\n            ]\n        }\n    }\n]\n\u0060\u0060\u0060\n\n可以看到该 Cluster 的 Endpoint 直接对应的就是 localhost，再经过 iptables 转发流量就被应用程序容器消费了。\n\n## 理解 Outbound Handler\n\n因为 \u0060reviews\u0060 会向 \u0060ratings\u0060 服务发送 HTTP 请求，请求的地址是：\u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060，Outbound handler 的作用是将 iptables 拦截到的本地应用程序发出的流量，经由 Envoy 判断如何路由到 upstream。\n\n应用程序容器发出的请求为 Outbound 流量，被 iptables 劫持后转移给 Envoy  Outbound handler 处理，然后经过 \u0060virtual\u0060 Listener、\u00600.0.0.0_9080\u0060 Listener，然后通过 Route 9080 找到 upstream 的 cluster，进而通过 EDS 找到 Endpoint 执行路由动作。这一部分可以参考 Istio 官网中的 Envoy 深度配置解析。\n\n**Route 9080**\n\n\u0060reviews\u0060 会请求 \u0060ratings\u0060 服务，运行 \u0060istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json\u0060 查看 route 配置，因为 Envoy 会根据 HTTP header 中的 domains 来匹配 VirtualHost，所以下面只列举了 \u0060ratings.default.svc.cluster.local:9080\u0060 这一个 VirtualHost。\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n    \u0022domains\u0022: [\n        \u0022ratings.default.svc.cluster.local\u0022,\n        \u0022ratings.default.svc.cluster.local:9080\u0022,\n        \u0022ratings\u0022,\n        \u0022ratings:9080\u0022,\n        \u0022ratings.default.svc.cluster\u0022,\n        \u0022ratings.default.svc.cluster:9080\u0022,\n        \u0022ratings.default.svc\u0022,\n        \u0022ratings.default.svc:9080\u0022,\n        \u0022ratings.default\u0022,\n        \u0022ratings.default:9080\u0022,\n        \u002210.254.234.130\u0022,\n        \u002210.254.234.130:9080\u0022\n    ],\n    \u0022routes\u0022: [\n        {\n            \u0022match\u0022: {\n                \u0022prefix\u0022: \u0022\/\u0022\n            },\n            \u0022route\u0022: {\n                \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                \u0022timeout\u0022: \u00220.000s\u0022,\n                \u0022maxGrpcTimeout\u0022: \u00220.000s\u0022\n            },\n            \u0022decorator\u0022: {\n                \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n            },\n            \u0022perFilterConfig\u0022: {...\n            }\n        }\n    ]\n},\n..]\n\u0060\u0060\u0060\n\n从该 Virtual Host 配置中可以看到将流量路由到 Cluster \u0060outbound|9080||ratings.default.svc.cluster.local\u0060。\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nIstio 1.1 以前版本不支持使用 \u0060istioctl\u0060 命令直接查询 Cluster 的 Endpoint，可以使用查询 Pilot 的 debug 端点的方式折中。\n\n\u0060\u0060\u0060bash\nkubectl exec reviews-v1-cb8655c75-b97zc -c istio-proxy curl http:\/\/istio-pilot.istio-system.svc.cluster.local:9093\/debug\/edsz \u003e endpoints.json\n\u0060\u0060\u0060\n\n\u0060endpoints.json\u0060 文件中包含了所有 Cluster 的 Endpoint 信息，我们只选取其中的 \u0060outbound|9080||ratings.default.svc.cluster.local\u0060 Cluster 的结果如下。\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nEndpoint 可以是一个或多个，Envoy 将根据一定规则选择适当的 Endpoint 来路由。\n\n**注**：Istio 1.1 将支持 \u0060istioctl pc endpoint\u0060 命令来查询 Endpoint。\n\n## 参考\n\n- 调试 Envoy 和 Pilot - istio.io\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/posts\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [Istio 流量管理实现机制深度解析 - zhaohuabing.com](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/)\n\n', '\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Sidecar proxy 中 Indbound/Outbound 流量处理过程详解。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-service-and-traffic-model/">Istio 中的服务和流量的抽象模型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/12/17</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 中的服务和流量的抽象模型', '本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。', '\n本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。虽然 Istio 一开始确定的抽象模型与对接的底层平台无关，但目前来看基本绑定 Kubernetes，本文仅以 Kubernetes 说明。另外在 ServiceMesher 社区中最近有很多关于 Istio、Envoy、Kubernetes 之中的服务模型关系的讨论，本文作为一个开篇说明，Kubernetes 和 Isito 之间有哪些共有的服务模型，Istio 在 Kubernetes 的服务模型之上又增加了什么。\n\n**服务具有多个版本。** 在 CI\/CD 过程中，同一个服务可能同时部署在多个环境中，如开发、生产和测试环境等，这些服务版本不一定具有不同的 API，可能只是一些小的更改导致的迭代版本。在 A\/B 测试和灰度发布中经常遇到这种情况。\n\n## Kubernetes 与 Istio 中共有的模型\n\n因为 Istio 基本就是绑定在 Kubernetes 上，下面是我们熟知的 Kubernetes 及 Istio 中共有的服务模型。\n\nKubernetes 中 iptables 代理模式（另外还有 IPVS 模式）下的 service，管理员可以在 kube-proxy 中配置简单的负载均衡，对整个 node 生效，无法配置到单个服务的负载均衡和其他微服务的高级功能，例如熔断、限流、追踪等，这些功能只能在应用中实现了，而在 Istio 的概念模型中完全去掉了 \u0060kube-proxy\u0060  这个组件，将其分散到每个应用 Pod 中同时部署的 Envoy 中实现。\n\n下面列举的是 Kubernetes 和 Istio 中共有的模型。\n\n### Service\n\n这实际上跟 Kubernetes 中的 service 概念是一致的，请参考 [Kubernetes 中的 service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)。Istio 推出了比 service 更复杂的模型 \u0060VirtualService\u0060，这不单纯是定义一个服务了，而是在服务之上定义了路由规则。\n\n每个服务都有一个完全限定的域名（FQDN），监听一个或多个端口。服务还可以有与其相关联的单个负载均衡器或虚拟 IP 地址。针对 FQDN 的 DNS 查询将解析为该负载均衡器或者虚拟 IP 的地址。\n\n例如 Kubernetes 中一个服务为 \u0060foo.default.svc.cluster.local\u0060 ，虚拟 IP \/ClusterIP 是 10.0.1.1，监听的端口是 80 和 8080。\n\n### Endpoint\n\n这里指的是 Kubernetes 中的 endpoint，一个 endpoint 是实现了某服务的具体实例，一个服务可能有一个或者多个 Endpoint，表示为 IP 地址加端口，也可以为 DNS 名称加端口。\n\n其实到底哪些实例属于同一个 service，还是需要 通过 label 匹配来选择。\n\n### Label\n\n服务的版本、对应的引用名称等是通过 label 来标记的，例如下面 Kubernetes 中一个应用的 YAML 配置。\n\n\u0060\u0060\u0060yaml\napiVersion: extensions\/v1beta1\nkind: Deployment\nmetadata:\n  name: ratings-v1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: ratings\n        version: v1\n    spec:\n      containers:\n      - name: ratings\n        image: istio\/examples-bookinfo-ratings-v1:1.8.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n\u0060\u0060\u0060\n\n \u0060version: v1\u0060 标记该服务是 v1 版本，\u0060version\u0060 是一个约定俗称的标签，建议大家的服务上都带上该标签。\n\n当然服务的 label 可以设置任意多个，这样的好处是在做路由的时候可以根据标签匹配来做细粒度的流量划分。\n\n## 数据平面 Envoy\n\nEnvoy 是 Istio 中默认的 sidecar proxy，负责服务间的流量管控、认证与安全加密、可观测性等。\n\n下面是 Envoy 的架构图。\n\n![Envoy 架构图](envoy-arch-20190114.png)\n\n我再给大家介绍 Envoy 中的如下几个重要概念。\n\n### Cluster\n\n集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n这个与 Kubernetes 中的 Service 概念类似，只不过 Kubernetes 中的服务发现中并不包含健康状况检查，而是通过[配置 Pod 的 liveness 和 readiness 探针](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/configure-liveness-readiness-probes.html)来实现，服务发现默认也是通过 DNS 来实现。\n\n### Listener\n\n监听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n### Listener filter\n\nListener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n## Istio 中增加的流量模型\n\n\u0060VirtualService\u0060、\u0060DestinationRule\u0060、\u0060Gateway\u0060、\u0060ServiceEntry\u0060 和 \u0060EnvoyFilter\u0060 都是 Istio 中为流量管理所创建的 CRD，这些概念其实是做路由配置和流量管理的，而 Kubernetes 中的 service 只是用来做服务发现。Service Mesh 中真正的服务模型应该是 Envoy 的 [xDS 协议](https:\/\/cloudnative.to\/blog\/envoy-xds-protocol\/)，其中包括了服务的流量治理，服务的端点是通过 EDS 来配置的。\n\n![Istio pilot 架构图](istio-pilot.png)\n\n上图是 Pilot 设计图，来自[Istio Pilot design overview](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/design.md)。\n\n### Routing\n\nKubernetes 中的 service 是没有任何路由属性可以配置的，Istio 在设计之初就通过在同一个 Pod 中，在应用容器旁运行一个 sidecar proxy 来透明得实现细粒度的路由控制。\n\n### VirtualService\n\n\u0060VirtualService\u0060 定义针对指定服务流量的路由规则。每个路由规则都针对特定协议的匹配规则。如果流量符合这些特征，就会根据规则发送到服务注册表中的目标服务（或者目标服务的子集或版本）。对于 A\/B 测试和灰度发布等场景，通常需要使用划分 \u0060subset\u0060，VirtualService 中根据 destination 中的 subset 配置来选择路由，但是这些 subset 究竟对应哪些服务示例，这就需要 \u0060DestionationRule\u0060。\n\n### DestinationRule\n\n\u0060DestinationRule\u0060 所定义的策略，决定了经过路由处理之后的流量的访问策略。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n\n### Gateway\n\n\u0060Gateway\u0060 描述了一个负载均衡器，用于承载网格边缘的进入和发出连接。这一规范中描述了一系列开放端口，以及这些端口所使用的协议、负载均衡的 SNI 配置等内容。\n\n这个实际上就是定义服务网格的边缘路由。\n\n### ServiceEntry\n\n\u0060ServiceEntry\u0060 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\u0060ServiceEntry\u0060 描述了服务的属性（DNS 名称、VIP、端口、协议以及端点）。这类服务可能是网格外的 API，或者是处于网格内部但却不存在于平台的服务注册表中的条目（例如需要和 Kubernetes 服务沟通的一组虚拟机服务）。\n\n如果没有配置 ServiceEntry 的话，Istio 实际上是无法发现服务网格外部的服务的。\n\n### EnvoyFilter\n\n\u0060EnvoyFilter\u0060 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这一功能一定要谨慎使用。错误的配置内容一旦完成传播，可能会令整个服务网格进入瘫痪状态。\n\nEnvoy 中的 listener 可以配置多个 filter，这也是一种通过 Istio 来扩展 Envoy 的机制。\n\n## 参考\n\n- [Kubernetes 中的 service - jimmysong.io](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html)\n- [Istio services model - github.com](https:\/\/github.com\/istio\/old_pilot_repo\/blob\/master\/doc\/service-registry.md)\n- [Istio 文档 - istio.io](https:\/\/istio.io)\n', '\/blog\/istio-service-and-traffic-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Istio 和 Kubernetes 中的一些服务和流量的抽象模型。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/09/11</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持', '以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。', '\n本文最新更新于 2022 年 3 月 7 日。\n\n\u003e 以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。\n\n在讲解 Istio 如何将 Envoy 代理注入到应用程序 Pod 中之前，我们需要先了解以下几个概念：\n\n- Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式。\n- Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n- iptables：流量劫持是通过 iptables 转发实现的。\n\n查看目前 \u0060reviews-v1-745ffc55b7-2l2lw\u0060 Pod 中运行的容器：\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod reviews-v1-745ffc55b7-2l2lw -o=jsonpath=\u0027{..spec.containers[*].name}\u0027\nreviews istio-proxy\n\u0060\u0060\u0060\n\n\u0060reviews\u0060 即应用容器，\u0060istio-proxy\u0060 即 Envoy 代理的 sidecar 容器。另外该 Pod 中实际上还运行过一个 Init 容器，因为它执行结束就自动终止了，所以我们看不到该容器的存在。关注 \u0060jsonpath\u0060 的用法请参考 [JSONPath Support](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)。\n\n## Sidecar 模式\n\n在了解 Istio 使用 Sidecar 注入之前，需要先说明下什么是 Sidecar 模式。Sidecar 是容器应用模式的一种，也是在 Service Mesh 中发扬光大的一种模式。\n\n使用 Sidecar 模式部署服务网格时，无需在节点上运行代理（因此您不需要基础结构的协作），但是集群中将运行多个相同的 Sidecar 副本。从另一个角度看：我可以为一组微服务部署到一个服务网格中，你也可以部署一个有特定实现的服务网格。在 Sidecar 部署方式中，你会为每个应用的容器部署一个伴生容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边运行一个 Sidecar 容器，可以理解为两个容器共享存储、网络等资源，可以广义的将这个注入了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。\n\n下图展示的是 Service Mesh 的架构图，其中的位于每个 Pod 中的 proxy  组成了数据平面，而这些 proxy 正是以 sidecar 模式运行的。\n\n![Istio 架构](istio-sidecar.jpg)\n\n**注意**：下文中所指的 Sidecar 都是指的 Envoy 代理容器。\n\n## Init 容器\n\nInit 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。\n\n一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。\n\nInit 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。\n\n在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 \u0060restartPolicy\u0060 指定的策略进行重试。然而，如果 Pod 的 \u0060restartPolicy\u0060 设置为 Always，Init 容器失败时会使用 \u0060RestartPolicy\u0060 策略。\n\n在所有的 Init 容器没有成功之前，Pod 将不会变成 \u0060Ready\u0060 状态。Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 \u0060Pending\u0060 状态，但应该会将 \u0060Initializing\u0060 状态设置为 true。Init 容器运行完成以后就会自动终止。\n\n关于 Init 容器的详细信息请参考 [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册](\/book\/kubernetes-handbook\/objects\/init-containers\/)。\n\n## Sidecar 注入示例分析\n\n本文我们将以 Istio 官方示例 \u0060bookinfo\u0060 中 \u0060reivews\u0060 服务为例，来接讲解 Sidecar 容器注入的额流程，每个注入了 Sidecar 的 Pod 中除了原先应用的应用本身的容器外，都会多出来这样两个容器：\n\n- \u0060istio-init\u0060：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发\n- \u0060istio-proxy\u0060：Envoy 代理容器，运行 Envoy 代理\n\n接下来将分别解析下这两个容器。\n\n### Init 容器解析\n\nIstio 在 Pod 中注入的 Init 容器名为 \u0060istio-init\u0060，如果你查看 \u0060reviews\u0060 Deployment 配置，你将看到其中 \u0060initContaienrs\u0060 的启动参数：\n\n\u0060\u0060\u0060bash\n      initContainers:\n        - name: istio-init\n          image: docker.io\/istio\/proxyv2:1.13.1\n          args:\n            - istio-iptables\n            - \u0027-p\u0027\n            - \u002715001\u0027\n            - \u0027-z\u0027\n            - \u002715006\u0027\n            - \u0027-u\u0027\n            - \u00271337\u0027\n            - \u0027-m\u0027\n            - REDIRECT\n            - \u0027-i\u0027\n            - \u0027*\u0027\n            - \u0027-x\u0027\n            - \u0027\u0027\n            - \u0027-b\u0027\n            - \u0027*\u0027\n            - \u0027-d\u0027\n            - 15090,15021,15020\n\u0060\u0060\u0060\n\n我们看到 \u0060istio-init\u0060 容器的入口是 \u0060istio-iptables\u0060 命令，该命令是用于初始化路由表的。\n\n### Init 容器启动入口\n\nInit 容器的启动入口是 \u0060\/usr\/local\/bin\/istio-iptable\u0060 命令，该命令的用法如下：\n\n\u0060\u0060\u0060bash\n$ istio-iptables -p PORT -u UID -g GID [-m mode] [-b ports] [-d ports] [-i CIDR] [-x CIDR] [-h]\n  -p: 指定重定向所有 TCP 流量的 Envoy 端口（默认为 $ENVOY_PORT = 15001）\n  -u: 指定未应用重定向的用户的 UID。通常，这是代理容器的 UID（默认为 $ENVOY_USER 的 uid，istio_proxy 的 uid 或 1337）\n  -g: 指定未应用重定向的用户的 GID。（与 -u param 相同的默认值）\n  -m: 指定入站连接重定向到 Envoy 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE)\n  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS）\n  -d: 指定要从重定向到 Envoy 中排除（可选）的入站端口列表，以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS）\n  -i: 指定重定向到 Envoy（可选）的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR）\n  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。\n  -z: 所有入站 TCP 流量重定向端口（默认为 $INBOUND_CAPTURE_PORT 15006）\n\u0060\u0060\u0060\n\n关于该命令的详细代码请[查看 GitHub：\u0060tools\/istio-iptables\/pkg\/cmd\/root.go\u0060](https:\/\/github.com\/istio\/istio\/blob\/master\/tools\/istio-iptables\/pkg\/cmd\/root.go)。\n\n再参考 \u0060istio-init\u0060 容器的启动参数，完整的启动命令如下：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/istio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b * -d \u002215090,15201,15020\u0022\n\u0060\u0060\u0060\n\n该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。\n\n**命令解析**\n\n这条启动命令的作用是：\n\n- 将应用容器的所有流量都转发到 Envoy 的 15006 端口。\n- 使用 \u0060istio-proxy\u0060 用户身份运行，UID 为 1337，即 Envoy 所处的用户空间，这也是 \u0060istio-proxy\u0060 容器默认使用的用户，见 YAML 配置中的 \u0060runAsUser\u0060 字段。\n- 使用默认的 \u0060REDIRECT\u0060 模式来重定向流量。\n- 将所有出站流量都重定向到 Envoy 代理。\n- 将除了 15090、15201、15020 端口以外的所有端口的流量重定向到 Envoy 代理。\n\n因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 Sidecar 容器中。\n\n### istio-proxy 容器解析\n\n为了查看 iptables 配置，我们需要登陆到 Sidecar 容器中使用 root 用户来查看，因为 \u0060kubectl\u0060 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 \u0060reviews\u0060 Pod 所在的主机上使用 \u0060docker\u0060 命令登陆容器中查看。\n\n查看 \u0060reviews\u0060 Pod 所在的主机。\n\n\u0060\u0060\u0060bash\n$ kubectl -n default get pod -l app=reviews -o wide\nNAME                              READY     STATUS    RESTARTS   AGE       IP             NODE\nreviews-v1-745ffc55b7-2l2lw   2\/2       Running   0          1d        172.33.78.10   node3\n\u0060\u0060\u0060\n\n从输出结果中可以看到该 Pod 运行在 \u0060node3\u0060 上，使用 \u0060vagrant\u0060 命令登陆到 \u0060node3\u0060 主机中并切换为 root 用户。\n\n\u0060\u0060\u0060bash\n$ vagrant ssh node3\n$ sudo -i\n\u0060\u0060\u0060\n\n查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给  \u0060istio-iptables.sh\u0060 传递的参数中指定将入站流量重定向到 Envoy 的模式为“REDIRECT”，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 \u0060TPROXY\u0060 还会有 \u0060mangle\u0060 表配置。\u0060iptables\u0060 命令的详细用法请参考 [iptables](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)，规则配置请参考 [iptables 规则配置](http:\/\/www.zsythink.net\/archives\/1517)。\n\n## 理解 iptables\n\n\u0060iptables\u0060 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。\n\n在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。\n\n下图展示了 iptables 调用链。\n\n![iptables 调用链](iptables_packetflow.png)\n\n### iptables 中的表\n\nInit 容器中使用的的 iptables 版本是 \u0060v1.6.0\u0060，共包含 5 张表：\n\n1. \u0060raw\u0060 用于配置数据包，\u0060raw\u0060 中的数据包不会被系统跟踪。\n2. \u0060filter\u0060 是用于存放所有与防火墙相关操作的默认表。\n3. \u0060nat\u0060 用于 [网络地址转换](https:\/\/en.wikipedia.org\/wiki\/Network_address_translation)（例如：端口转发）。\n4. \u0060mangle\u0060 用于对特定数据包的修改（参考[损坏数据包](https:\/\/en.wikipedia.org\/wiki\/Mangled_packet)）。\n5. \u0060security\u0060 用于[强制访问控制](https:\/\/wiki.archlinux.org\/index.php\/Security#Mandatory_access_control) 网络规则。\n\n**注**：在本示例中只用到了 \u0060nat\u0060 表。\n\n不同的表中的具有的链类型如下表所示：\n\n| 规则名称    | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      | ✓    | ✓      | ✓        |\n| OUTPUT      |      | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     | ✓    | ✓      |      | ✓      | ✓        |\n\n下图是 iptables 的调用链顺序。\n\n![iptables 调用链顺序](iptables-chains.jpg)\n\n\n### iptables 命令\n\n\u0060iptables\u0060 命令的主要用途是修改这些表中的规则。\u0060iptables\u0060 命令格式如下：\n\n\u0060\u0060\u0060bash\n$ iptables [-t 表名] 命令选项［链名]［条件匹配］[-j 目标动作或跳转］\n\u0060\u0060\u0060\n\nInit 容器中的 \u0060\/istio-iptables.sh\u0060 启动入口脚本就是执行 iptables 初始化的。\n\n### 理解 iptables 规则\n\n查看 \u0060istio-proxy\u0060 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\n我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为 INPUT\/FORWARD\/OUTPUT），后跟默认策略（ACCEPT）。\n\n每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。\n\n- **pkts**：处理过的匹配的报文数量\n- **bytes**：累计处理的报文大小（字节数）\n- **target**：如果报文与规则匹配，指定目标就会被执行。\n- **prot**：协议，例如 \u0060tdp\u0060、\u0060udp\u0060、\u0060icmp\u0060 和 \u0060all\u0060。 \n- **opt**：很少使用，这一列用于显示 IP 选项。\n- **in**：入站网卡。\n- **out**：出站网卡。\n- **source**：流量的源 IP 地址或子网，后者是 \u0060anywhere\u0060。\n- **destination**：流量的目的地 IP 地址或子网，或者是 \u0060anywhere\u0060。\n\n还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。\u0060prot\u0060、\u0060opt\u0060、\u0060in\u0060、\u0060out\u0060、\u0060source\u0060 和 \u0060destination\u0060 和显示在 \u0060destination\u0060 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 \u0060target\u0060。\n\n\n**target 支持的类型**\n\n\u0060target\u0060 类型包括 ACCEPT\u0060、REJECT\u0060、\u0060DROP\u0060、\u0060LOG\u0060 、\u0060SNAT\u0060、\u0060MASQUERADE\u0060、\u0060DNAT\u0060、\u0060REDIRECT\u0060、\u0060RETURN\u0060 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 \u0060RETURN\u0060 类型，类似编程语言中的 \u0060return\u0060 语句，返回到它的调用点，继续执行下一条规则。\u0060target\u0060 支持的配置详解请参考 [iptables 详解（1）：iptables 概念](http:\/\/www.zsythink.net\/archives\/1199)。\n\n从输出结果中可以看到 Init 容器没有在 iptables 的默认链路中创建任何规则，而是创建了新的链路。\n\n## 查看 iptables nat 表中注入的规则\n\nInit 容器通过向 iptables nat 表中注入转发规则来劫持流量的，下图显示的是三个 reviews 服务示例中的某一个 Pod，其中有 init 容器、应用容器和 sidecar 容器，图中展示了 iptables 流量劫持的详细过程。\n\n![Envoy sidecar 流量劫持与路由转发示意图](istio-iptables.svg)\n\nInit 容器启动时命令行参数中指定了 \u0060REDIRECT\u0060 模式，因此只创建了 NAT 表规则，接下来我们查看下 NAT 表中创建的规则，这是全文中的**重点部分**，前面讲了那么多都是为它做铺垫的。\n\n### 进入到 reviews pod\n\nReviews 服务有三个版本，我们进入到其中任意一个版本，例如 reviews-1，首先你需要搞清楚这个 pod 运行在哪个节点上，知道那个容器的具体 ID，然后使用 SSH 登录那个节点，使用 \u0060ps\u0060 命令查看到那个容器的具体 IP，使用 \u0060nsenter\u0060 命令进入该容器。\n\n\u0060\u0060\u0060sh\nnsenter -t{PID} -n\n\u0060\u0060\u0060\n\n**为什么不直接使用 kubectl 进入容器？**\n\nIstio 向 pod 中自动注入的 sidecar 容器（名为 \u0060istio-proxy\u0060）其中默认的用户是 \u0060istio-proxy\u0060，该用户没有权限查看路由表规则，即当你在该容器中运行 \u0060iptabes\u0060 命令时会得到 \u0060iptables -t nat -L -v\u0060 这样的结果，而且你又没有 root 权限。对于 reviews 容器也是一样，默认用户的 UID 是 \u00601000\u0060，而且这个用户又没有名字，一样也无法切换为 root 用户，系统中默认没有安装 iptabels 命令。所以我们只能登录到 Pod 的宿主节点上，使用 \u0060nsenter\u0060 命令进入容器内部。\n\n### 查看路由表\n\n下面是查看 nat 表中的规则，其中链的名字中包含 \u0060ISTIO\u0060 前缀的是由 Init 容器注入的，规则匹配是根据下面显示的顺序来执行的，其中会有多次跳转。\n\n\u0060\u0060\u0060bash\n# 查看 NAT 表中规则配置的详细信息\n$ iptables -t nat -L -v\n# PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链\nChain INPUT (policy ACCEPT 2 packets, 120 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上\nChain OUTPUT (policy ACCEPT 41146 packets, 3845K bytes)\n pkts bytes target     prot opt in     out     source               destination\n   93  5580 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理\nChain POSTROUTING (policy ACCEPT 41199 packets, 3848K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND 链：将所有目的地为 9080 端口的入站流量重定向到 ISTIO_IN_REDIRECT 链上\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere             tcp dpt:9080\n\n# ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 Envoy \nChain ISTIO_IN_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    2   120 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUPT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 ISTIO_REDIRECT  all  --  any    lo      anywhere            !localhost\n   40  2400 RETURN     all  --  any    any     anywhere             anywhere             owner UID match istio-proxy\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match istio-proxy\t\n    0     0 RETURN     all  --  any    any     anywhere             localhost\n   53  3180 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere\n\n# ISTIO_REDIRECT 链：将所有流量重定向到 Envoy（即本地） 的 15001 端口\nChain ISTIO_REDIRECT (2 references)\n pkts bytes target     prot opt in     out     source               destination\n   53  3180 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\n\u0060iptables\u0060 显示的链的顺序，即流量规则匹配的顺序。其中要特别注意 \u0060ISTIO_OUTPUT\u0060 链中的规则配置。为了避免流量一直在 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 \u0060ISTIO_OUTPUT\u0060 规则之后就进入下一条链 \u0060POSTROUTING\u0060。\n\n\u0060ISTIO_OUTPUT\u0060 链规则匹配的详细过程如下：\n\n- 如果目的地非 localhost 就跳转到 ISTIO_REDIRECT 链\n- 所有来自 istio-proxy 用户空间的非 localhost 流量跳转到它的调用点 \u0060OUTPUT\u0060 继续执行 \u0060OUTPUT\u0060 链的下一条规则，因为 \u0060OUTPUT\u0060 链中没有下一条规则了，所以会继续执行 \u0060POSTROUTING\u0060 链然后跳出 iptables，直接访问目的地\n- 如果流量不是来自 istio-proxy 用户空间，又是对 localhost 的访问，那么就跳出 iptables，直接访问目的地\n- 其它所有情况都跳转到 \u0060ISTIO_REDIRECT\u0060 链\n\n其实在最后这条规则前还可以增加 IP 地址过滤，让某些 IP 地址段不通过 Envoy 代理。\n\n以上 iptables 规则都是 Init 容器启动的时使用 [istio-iptables](https:\/\/github.com\/istio\/istio\/tree\/master\/tools\/istio-iptables) 命令生成的，详细过程可以查看该命令行程序。\n\n## 参考\n\n- [Init 容器 - Kubernetes 中文指南\/云原生应用架构实践手册 - jimmysong.io](\/book\/kubernetes-handbook\/objects\/init-containers\/)\n- [JSONPath Support - kubernetes.io](https:\/\/kubernetes.io\/docs\/reference\/kubectl\/jsonpath\/)\n- [iptables 命令使用说明 - wangchujiang.com](https:\/\/wangchujiang.com\/linux-command\/c\/iptables.html)\n- [How To List and Delete Iptables Firewall Rules - digitalocean.com](https:\/\/www.digitalocean.com\/community\/tutorials\/how-to-list-and-delete-iptables-firewall-rules)\n- [一句一句解说 iptables 的详细中文手册 - cnblog.com](https:\/\/www.cnblogs.com\/fhefh\/archive\/2011\/04\/04\/2005249.html)\n', '\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">以往有很多文章讲解 Istio 是如何做 Sidecar 注入的，但是没有讲解注入之后 Sidecar 工作的细节。本文将带大家详细了解 Istio 是如何将 Envoy 作为 Sidecar 的方式注入到应用程序 Pod 中，及 Sidecar 是如何做劫持流量的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial/">蚂蚁集团开源 SOFAMesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/07/16</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('蚂蚁集团开源 SOFAMesh', '蚂蚁集团开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。', '\n{{\u003ccallout warning 注意\u003e}}\n\nSOFAMesh 已闭源，本文已过时。\n\n{{\u003c\/callout\u003e}}\n\n4 月，蚂蚁集团自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）启动开源计划，并开放多个组件，（相关背景请点击链接阅读《[开源 | 蚂蚁集团启动分布式中间件开源计划，用于快速构建金融级云原生架构](http:\/\/mp.weixin.qq.com\/s?__biz=MzI0Nzc3MTQyMw==\u0026mid=2247484729\u0026idx=1\u0026sn=0d8dbee2739fb0eef3e4ad699661fd13\u0026chksm=e9abbd49dedc345fd5d6898fd1989710f249d6386bf3d52ae1603365a4a1c3696538bc8b9a8f\u0026scene=21#wechat_redirect) 》、《[开源 | 蚂蚁集团分布式中间件开源第二弹：丰富微服务架构体系](http:\/\/mp.weixin.qq.com\/s?__biz=MzI0Nzc3MTQyMw==\u0026mid=2247485026\u0026idx=1\u0026sn=0a367bc67d5fe3a268e3715b17e020ab\u0026chksm=e9abbe12dedc370489102d9307b832457891fdb0530eec5c35c0fb82bc2a3e6dbbc7db8436c4\u0026scene=21#wechat_redirect) 》），这一系列的动作受到大家的关注和支持，SOFA 社区也日益壮大。\n\n在两轮开源之后，蚂蚁集团自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）在今天推出了**第三轮的开源产品：SOFAMesh**。和前两轮开源的历经多年沉淀和打磨的成熟产品不同，本轮的开源主角 SOFAMesh，将探索一条和以往产品有所不同的开源道路。下面我们就来看看到底有哪些不同吧！\n\n## SOFAMesh 的开源探索之路\n\nSOFAMesh 尝试在以下几个方面进行自我突破和勇敢探索：\n\n**全新的技术领域**\n\nService Mesh 是目前技术社区最为炙手可热的新技术方向，有下一代微服务的明显趋势。但是目前 Service Mesh 技术还处于发展早期，暂时还没有成熟的产品，尤其缺乏大规模的落地实践。\n\n**较早的开源时间**\n\n在上述背景下，我们选择了将启动不久的 Service Mesh 产品开源在开发早期，也就是还未成熟之时，就对社区开放，开放源码并寻求社区合作。\n\n**更加开放的态度**\n\n在 SOFAMesh 上，我们愿意以开源共建的方式来和社区一起推进 Service Mesh 技术的更好发展和实现落地实践，共同打造一个技术先进，功能丰富，具备良好的性能和稳定性，可以实实在在的生产落地的优秀产品。欢迎国内技术社区的朋友们和我们开展不同层面的交流与合作。\n\n**务实的产品路线**\n\nSOFAMesh 在产品路线上，选择了跟随社区主流，我们选择了目前 Service Mesh 中最有影响力和前景的 Istio。SOFAMesh 会在 Istio 的基础上，提升性能，增加扩展性，并在落地实践上做探索和补充，以弥补目前 Istio 的不足，同时保持与 Istio 社区的步骤一致和持续跟进。\n\n## SOFAMesh 介绍\n\nSOFAMesh 将在兼容 Istio 整体架构和协议的基础上，做出部分调整：\n\n1. 使用 Golang 语言开发全新的 Sidecar，替代 Envoy\n2. 为了避免 Mixer 带来的性能瓶颈，合并 Mixer 部分功能进入 Sidecar\n3. Pilot 和 Citadel 模块进行了大幅的扩展和增强\n\n我们的目标：打造一个更加务实的 Istio 落地版本！\n\n{{\u003ccallout note 备注\u003e}}\n\n以上架构调整的细节以及我们做调整的出发点和原因，请浏览 [蚂蚁集团大规模微服务架构下的 Service Mesh 探索之路](https:\/\/cloudnative.to\/blog\/the-way-to-service-mesh-in-ant-financial\/) 一文，有非常详尽的解释。\n\n{{\u003c\/callout\u003e}}\n\n## 开源内容\n\n在本轮开源中，我们将推出 SOFAMesh 目前正在开发的两大模块：MOSN 和 SOFAPilot。\n\n## MOSN\n\nSOFAMesh 中 Golang 版本的 Sidecar，是一个名为 MOSN (Modular Observable Smart Netstub) 的全新开发的模块，实现 Envoy 的功能，兼容 Envoy 的 API，可以和 Istio 集成。\n\n![MOSN 架构图](mosn-with-service-mesh.png)\n\n此外，我们会增加对 SOFARPC、Dubbo 等通讯协议的支持，以便更好的迎合国内用户包括我们自身的实际需求。\n\n由于 Sidecar 相对独立，而且我们也预期会有单独使用 MOSN 的场景，因此 MOSN 的代码仓库是独立于 SOFAMesh 的，地址为：https:\/\/github.com\/mosn\/mosn\n\n欢迎大家使用，提供需求、反馈问题、贡献代码或者合作开发。\n\n## SOFAPilot\n\n我们将大幅扩展和增强 Istio 中的 Pilot 模块：\n\n1. 增加 SOFARegistry 的 Adapter，提供超大规模服务注册和发现的解决方案\n2. 增加数据同步模块，以实现多个服务注册中心之间的数据交换。\n3. 增加 Open Service Registry API，提供标准化的服务注册功能\n\nMOSN 和 SOFAPilot 配合，将可以提供让传统侵入式框架（如 Spring Cloud，Dubbo，SOFA RPC 等）和 Service Mesh 产品可以相互通讯的功能，以便可以平滑的向 Service Mesh 产品演进和过渡。\n\n**Pilot 和后面会陆续开放的 Mixer，Citadel 等 Istio 模块**，会统一存放在同一个从 Istio Fork 出来的代码仓库中。未来会持续更新 Istio 最新代码，以保持和 Istio 的一致。\n\n## 附录\n\n本文中提到的链接地址集合：\n\n- [MOSN](https:\/\/github.com\/mosn\/mosn)\n- [蚂蚁集团大规模微服务架构下的 Service Mesh 探索之路](https:\/\/cloudnative.to\/blog\/the-way-to-service-mesh-in-ant-financial\/)\n', '\/blog\/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">蚂蚁集团开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/tracing-grpc-with-istio/">[译] 在 Istio 中跟踪 gRPC</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/06/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 中跟踪 gRPC', '本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等', '\nAspen Mesh 很喜欢用[gRPC](https:\/\/grpc.io\/docs\/)。Apen Mesh 面向公众的 API 和许多内部 API 大多都是使用 gRPC 构建的。如果您还没有听说过 gRPC（熟练掌握 gRPC 真的很难），那么我先为您简单的介绍下，它是一种新型、高效和优化的远程过程调用（RPC）框架。gRPC 基于[protocol buffer](https:\/\/developers.google.com\/protocol-buffers\/)序列化格式和[HTTP\/2](https:\/\/http2.github.io\/)网络协议。\n\n使用 HTTP\/2 协议，gRPC 应用程序可以利用多路复用请求显著提高连接利用率，而且比起如 HTTP\/1.1 等[其他协议](https:\/\/http2.github.io\/faq\/)具有更多增强功能。此外，protocal buffer 是以二进制方式对结构化数据进行序列化，这比起基于文本的序列化方式更简单且可扩展，还可以显着提高性能。将这两个结果组合在一个低延迟和高度可扩展的 RPC 框架中，这实质上就是 gRPC。此外，不断增长的 gRPC 生态支持使用多种语言编写应用程序，例如（C \u002b\u002b、Java、Go 等），还包括大量第三方[库](https:\/\/github.com\/grpc-ecosystem)。\n\n除了上面列出的好处之外，gRPC 让我最喜欢的一点是可以让我以简单直观的方式指定 RPC（使用 protobuf IDL）以及客户端调用服务器端的方法，就好像是调用本地函数一样。很多代码（服务描述和处理程序、客户端方法等）都可以自动生成，这使得 gRPC 非常好用。\n\n现在我已经介绍了 gRPC 的一些背景知识，我们再把注意力转回到博客的主题。在这里，我将介绍如何在基于 gRPC 的应用程序中添加跟踪，特别是如果您使用 Istio 或 Aspen Mesh。\n\n跟踪（Tracing）非常适合于调试和理解应用程序的行为。理解所有跟踪数据的关键是能够关联来自与单个客户端请求相关的多个不同微服务的跨度（span）。\n\n为了实现这一点，应用程序中的所有微服务应该传播跟踪 header。如果您使用的是像 Istio 或 Aspen Mesh 这样的服务网格，ingress 和 sidecar 代理会自动添加适当的跟踪 header，并将这些 span 报告给跟踪收集器后端，如 Jaeger 或 Zipkin。应用程序唯一要做的就是将传入请求（sidecar 或 ingress 代理添加的）的跟踪 header 传播到其对其他微服务的所有传出请求。\n\n## gRPC 到 grpc 请求传播 header\n\n使用 gRPC，跟踪 header 传播的最简单方法是使用[grpc opentracing middleware](https:\/\/github.com\/grpc-ecosystem\/go-grpc-middleware\/tree\/master\/tracing\/opentracing)库的客户端拦截器。如果您的 gRPC 应用程序在收到传入请求时发出新的出站 gRPC 请求，则可以使用此功能。以下是将传入的跟踪 header 正确传播到传出的 gRPC 请求的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022github.com\/grpc-ecosystem\/go-grpc-middleware\/tracing\/opentracing\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address for the new outbound request\n  func createGRPCConn(ctx context.Context, addr string) (*grpc.ClientConn, error) {\n  \tvar opts []grpc.DialOption\n  \topts = append(opts, grpc.WithStreamInterceptor(\n  \t\tgrpc_opentracing.StreamClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \topts = append(opts, grpc.WithUnaryInterceptor(\n  \t\tgrpc_opentracing.UnaryClientInterceptor(\n  \t\t\tgrpc_opentracing.WithTracer(ot.GlobalTracer()))))\n  \tconn, err := grpc.DialContext(ctx, addr, opts...)\n  \tif err != nil {\n  \t\tglog.Error(\u0022Failed to connect to application addr: \u0022, err)\n  \t\treturn nil, err\n  \t}\n  \treturn conn, nil\n  }\n\u0060\u0060\u0060\n\n很简单对吧？\n\n添加 opentracing 客户端拦截器可确保在客户端连接上创建任何新的一元（unary）或流式 gRPC 请求注入正确的跟踪 header。如果传递的上下文中存在跟踪 header（如使用 Aspen Mesh 或 Istio 传入入站 gRPC 请求上下文），则新创建的 span 将作为传递的上下文中已存在的 span 的子 span。另外，如果上下文中没有跟踪信息，则会为出站 gRPC 请求创建新的根 span。\n\n## gRPC 到 HTTP 请求传播 header\n\n我们再来看下这个场景，如果您的应用程序在收到一个新传入的 gRPC 请求时发出一个出站 HTTP\/1.1 请求。以下是在此情况下完成 header 传播的示例代码：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022golang.org\/x\/net\/context\/ctxhttp\u0022\n    \u0022ot \u0022github.com\/opentracing\/opentracing-go\u0022\n  )\n\n  \/\/ ctx is the incoming gRPC request\u0027s context\n  \/\/ addr is the address of the application being requested\n  func makeNewRequest(ctx context.Context, addr string) {\n    if span := ot.SpanFromContext(ctx); span != nil {\n      req, _ := http.NewRequest(\u0022GET\u0022, addr, nil)\n\n      ot.GlobalTracer().Inject(\n        span.Context(),\n        ot.HTTPHeaders,\n        ot.HTTPHeadersCarrier(req.Header))\n\n      resp, err := ctxhttp.Do(ctx, nil, req)\n      \/\/ Do something with resp\n    }\n  }\n\u0060\u0060\u0060\n\n这是序列化传入请求（HTTP 或 gRPC）上下文中跟踪 header 的标准方式。\n\n很好，至此我们已经能够使用库或标准实用程序代码来实现我们想要的功能。\n\n## 使用 grpc-gateway 时传播 header\n\ngRPC 应用程序中有一个常用的库[grpc-gateway](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway)，可以将 gRPC 服务作为 RESTful JSON API 暴露出来。当您想要了解 gRPC 或维护 RESTful 架构，使用 curl、web 浏览器等客户端时，这非常有用。有关如何使用\u0060grpc-gateway\u0060从 gRPC 中暴露 RESTful API 的更多细节请参考[这个博客](https:\/\/coreos.com\/blog\/grpc-protobufs-swagger.html)。如果您对此架构不熟悉，我强烈建议您阅读。\n\n当您开始使用\u0060grpc-gateway\u0060并想传播跟踪 header 时，有一些值得一提的非常有趣的交互。 \u0060grpc-gateway\u0060 [文档](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway#mapping-grpc-to-http)指出，作为 gRPC 请求 header，所有 IANA（互联网号码分配局）永久 HTTP header 都以\u0060grpcgateway-\u0060作为前缀并添加。这很好，但是像\u0060x-b3-traceid\u0060、\u0060x-b3-spanid\u0060等跟踪 header 不是 IANA 认可的永久 HTTP header，当\u0060grpc-gateway\u0060代理 HTTP 请求时，它们不会被复制到 gRPC 请求中。这意味着只要将\u0060grpc-gateway\u0060添加到您的应用程序中，header 传播逻辑就会停止工作。\n\n这是个特例吗？添加一个东西打断了当前的工作。不用担心，我为您解决问题！\n\n这是一种确保使用\u0060grpc-gateway\u0060在 HTTP 和 gRPC 之间进行代理时不会丢失跟踪信息的方法：\n\n\u0060\u0060\u0060go\n  import (\n    \u0022net\/http\u0022\n    \u0022golang.org\/x\/net\/context\u0022\n    \u0022google.golang.org\/grpc\/metadata\u0022\n    \u0022github.com\/grpc-ecosystem\/grpc-gateway\/runtime\u0022\n  )\n\n  const (\n  \tprefixTracerState  = \u0022x-b3-\u0022\n  \tzipkinTraceID      = prefixTracerState \u002b \u0022traceid\u0022\n  \tzipkinSpanID       = prefixTracerState \u002b \u0022spanid\u0022\n  \tzipkinParentSpanID = prefixTracerState \u002b \u0022parentspanid\u0022\n  \tzipkinSampled      = prefixTracerState \u002b \u0022sampled\u0022\n  \tzipkinFlags        = prefixTracerState \u002b \u0022flags\u0022\n  )\n\n  var otHeaders = []string{\n  \tzipkinTraceID,\n  \tzipkinSpanID,\n  \tzipkinParentSpanID,\n  \tzipkinSampled,\n  \tzipkinFlags}\n\n  func injectHeadersIntoMetadata(ctx context.Context, req *http.Request) metadata.MD {\n  \tpairs := []string{}\n  \tfor _, h := range otHeaders {\n  \t\tif v := req.Header.Get(h); len(v) \u003e 0 {\n  \t\t\tpairs = append(pairs, h, v)\n  \t\t}\n  \t}\n  \treturn metadata.Pairs(pairs...)\n  }\n\n  type annotator func(context.Context, *http.Request) metadata.MD\n\n  func chainGrpcAnnotators(annotators ...annotator) annotator {\n  \treturn func(c context.Context, r *http.Request) metadata.MD {\n  \t\tmds := []metadata.MD{}\n  \t\tfor _, a := range annotators {\n  \t\t\tmds = append(mds, a(c, r))\n  \t\t}\n  \t\treturn metadata.Join(mds...)\n  \t}\n  }\n\n  \/\/ Main function of your application. Insert tracing headers into gRPC\n  \/\/ metadata using annotators\n  func run() {\n    ...\n\t  annotators := []annotator{injectHeadersIntoMetadata}\n\n\t  gwmux := runtime.NewServeMux(\n\t\t  runtime.WithMetadata(chainGrpcAnnotators(annotators...)),\n\t  )\n    ...\n  }\n\u0060\u0060\u0060\n\n在上面的代码中，我使用了\u0060grpc-gateway\u0060库中的[\u0060runtime.WithMetadata\u0060](https:\/\/github.com\/grpc-ecosystem\/grpc-gateway\/blob\/master\/runtime\/mux.go#L88)。该 API 从 HTTP 请求中读取属性并将其添加到 gRPC 元数据中，这一点非常有用，这正是我们想要的！虽然多了一步，但仍然使用库提供的 API。\n\n\u0060injectHeadersIntoMetadata\u0060注解器在 HTTP 请求中查找跟踪 header 并将其附加到 gRPC 元数据中，从而确保跟踪 header 可以使用前面部分中提到的技术从 gRPC 进一步传播到出站请求。\n\n您可能观察到的另一个有趣的事情是\u0060chainGrpcAnnotators\u0060包装函数。\u0060runtime.WithMetadata\u0060 API 只允许添加一个注释器，这可能不足以满足所有场景。在我们的例子中，我们有一个跟踪注释器（如上面的一个示例）和一个认证注释器，它将来自 HTTP 请求的认证数据附加到 gRPC 元数据。使用\u0060chainGrpcAnnotators\u0060允许您添加多个注释器，并且包装函数将来自各种注释器的元数据加入到 gRPC 请求的单个元数据中。\n', '\/trans\/tracing-grpc-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍的是如何在 Istio 中使用 grpc 并设置跟踪（tracing）与 header 传播，包括 gRPC 到 grpc 请求传播 header、gRPC 到 HTTP 请求传播 header、使用 grpc-gateway 时传播 header 等</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-tutorial/">Istio Service Mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/18</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Service Mesh 教程', '本文是 Istio 管理 Java 微服务的案例教程。', '\n本文是 Istio 管理 Java 微服务的案例教程，使用的所有工具和软件全部基于开源方案，替换了 [redhat-developer-demos\/istio-tutorial](https:\/\/github.com\/redhat-developer-demos\/istio-tutorial) 中的 minishift 环境，使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 替代，沿用了原有的微服务示例，使用 Zipkin 做分布式追踪而不是 Jaeger。\n\n本文中的代码和 YAML 文件见 \u003chttps:\/\/github.com\/rootsongjc\/istio-tutorial\u003e。\n\n## 准备环境\n\n在进行本教程前需要先准备以下工具和环境。\n\n- 8G 以上内存\n- Vagrant 2.0\u002b\n- Virtualbox 5.0 \u002b\n- 提前下载 kubernetes1.9.1 的 release 压缩包\n- docker 1.12\u002b\n- kubectl 1.9.1\u002b\n- maven 3.5.2\u002b\n- istioctl 0.7.1\n- git\n- curl、gzip、tar\n- [kubetail](https:\/\/github.com\/johanhaleby\/kubetail)\n- [siege](https:\/\/github.com\/JoeDog\/siege)\n\n## 安装 Kubernetes\n\n请参考 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 在本地启动拥有三个节点的 kubernetes 集群。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster.git\ncd kubernetes-vagrant-centos-cluster\nvagrant up\n\u0060\u0060\u0060\n\n## 安装 Istio\n\n在 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 中的包含 Istio 0.7.1 的安装 YAML 文件，运行下面的命令安装 Istio。\n\n\u0060\u0060\u0060bash\nkubectl apply -f addon\/istio\/\n\u0060\u0060\u0060\n\n**运行示例**\n\n\u0060\u0060\u0060bash\nkubectl apply -n default -f \u003c(istioctl kube-inject -f yaml\/istio-bookinfo\/bookinfo.yaml)\n\u0060\u0060\u0060\n\n在您自己的本地主机的\u0060\/etc\/hosts\u0060文件中增加如下配置项。\n\n\u0060\u0060\u0060ini\n172.17.8.102 grafana.istio.jimmysong.io\n172.17.8.102 servicegraph.istio.jimmysong.io\n172.17.8.102 zipkin.istio.jimmysong.io\n\u0060\u0060\u0060\n\n我们可以通过下面的 URL 地址访问以上的服务。\n\n| Service      | URL                                                          |\n| ------------ | ------------------------------------------------------------ |\n| grafana      | \u0060http:\/\/grafana.istio.jimmysong.io\u0060                          |\n| servicegraph | \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060，\u0060http:\/\/servicegraph.istio.jimmysong.io\/graph\u0060 |\n| zipkin       | \u0060http:\/\/zipkin.istio.jimmysong.io\u0060                           |\n\n详细信息请参阅 [Istio 文档](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/)。\n\n## 部署示例应用\n\n在打包成镜像部署到 kubernetes 集群上运行之前，我们先在本地运行所有示例。\n\n本教程中三个服务之间的依赖关系如下：\n\n\u0060\u0060\u0060ini\ncustomer → preference → recommendation\n\u0060\u0060\u0060\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务是基于 Spring Boot 构建的，\u0060recommendation\u0060 微服务是基于 [vert.x](https:\/\/vertx.io) 构建的。\n\n\u0060customer\u0060 和 \u0060preference\u0060 微服务的 \u0060pom.xml\u0060 文件中都引入了 OpenTracing 和 Jeager 的依赖。\n\n\u0060\u0060\u0060xml\n\u003cdependency\u003e\n\t\u003cgroupId\u003eio.opentracing.contrib\u003c\/groupId\u003e\n\t\u003cartifactId\u003eopentracing-spring-cloud-starter\u003c\/artifactId\u003e\n\t\u003cversion\u003e0.1.7\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u003cdependency\u003e\n\t\u003cgroupId\u003ecom.uber.jaeger\u003c\/groupId\u003e\n\t\u003cartifactId\u003ejaeger-tracerresolver\u003c\/artifactId\u003e\n    \u003cversion\u003e0.25.0\u003c\/version\u003e\n\u003c\/dependency\u003e\n\u0060\u0060\u0060\n\n### 本地运行\n\n我们首先在本地确定所有的微服务都可以正常运行，然后再打包镜像在 kubernetes 集群上运行。\n\n**启动 Jaeger**\n\n使用 docker 来运行 jagger。\n\n\u0060\u0060\u0060bash\ndocker run -d \\\n  --rm \\\n  -p5775:5775\/udp \\\n  -p6831:6831\/udp \\\n  -p6832:6832\/udp \\\n  -p16686:16686 \\\n  -p14268:14268 \\\n  jaegertracing\/all-in-one:1.3\n\u0060\u0060\u0060\n\nJaeger UI 地址 \u0060http:\/\/localhost:16686\u0060\n\n**Customer**\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nJAEGER_SERVICE_NAME=customer mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址： \u0060http:\/\/localhost:8280\u0060\n\n**Preference**\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nJAEGER_SERVICE_NAME=preference mvn \\\n  spring-boot:run \\\n  -Drun.arguments=\u0022--spring.config.location=src\/main\/resources\/application-local.properties\u0022\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8180\u0060\n\n**Recommendation**\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn vertx:run\n\u0060\u0060\u0060\n\n服务访问地址：\u0060http:\/\/localhost:8080\u0060\n\n所有服务都启动之后，此时访问 \u0060http:\/\/localhost:8280\u0060 将会看到如下输出。\n\n\u0060\u0060\u0060bash\ncustomer =\u003e preference =\u003e recommendation v1 from \u0027unknown\u0027: 1\n\u0060\u0060\u0060\n\n每访问一次最后的数字就会加 1。\n\n**Jaeger**\n\n此时访问 \u0060http:\/\/localhost:16686\u0060 将看到 Jaeger query UI，所有应用将 metrics 发送到 Jeager 中。\n\n可以在 Jaeger UI 中搜索 \u0060customer\u0060 和 \u0060preference\u0060 service 的 trace 并查看每次请求的 tracing。\n\n![Jaeger query UI](jaeger-query-ui.webp)\n\n### 构建镜像\n\n在本地运行测试无误之后就可以构建镜像了。本教程中的容器镜像都是在 [fabric8\/java-jboss-openjdk8-jdk](https:\/\/hub.docker.com\/r\/fabric8\/java-jboss-openjdk8-jdk\/~\/dockerfile\/) 的基础上构建的。只要将 Java 应用构建出 Jar 包然后放到 \u0060\/deployments\u0060 目录下基础镜像就可以自动帮我们运行，所以我们看到着几个应用的 \u0060Dockerfile\u0060 文件中都没有执行入口，真正的执行入口是 [run-java.sh](https:\/\/github.com\/fabric8io-images\/java\/blob\/master\/images\/jboss\/openjdk8\/jdk\/run-java.sh)。\n\n**Customer**\n\n构建 Customer 镜像。\n\n\u0060\u0060\u0060bash\ncd customer\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-customer:v1 .\ndocker push jimmysong\/istio-tutorial-customer:v1\n\u0060\u0060\u0060\n\n第一次构建和上传需要花费一点时间，下一次构建就会很快。\n\n**Preference**\n\n构建 Preference 镜像。\n\n\u0060\u0060\u0060bash\ncd preference\/java\/springboot\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-preference:v1 .\ndocker push jimmysong\/istio-tutorial-preference:v1\n\u0060\u0060\u0060\n\n**Recommendation**\n\n构建 Recommendation 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v1 .\ndocker push jimmysong\/istio-tutorial-recommendation:v1\n\u0060\u0060\u0060\n\n现在三个 docker 镜像都构建完成了，我们检查一下。\n\n\u0060\u0060\u0060bash\n$ docker images | grep istio-tutorial\nREPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE\njimmysong\/istio-tutorial-recommendation   v1                  d31dd858c300        51 seconds ago      443MB\njimmysong\/istio-tutorial-preference       v1                  e5f0be361477        6 minutes ago       459MB\njimmysong\/istio-tutorial-customer         v1                  d9601692673e        13 minutes ago      459MB\n\u0060\u0060\u0060\n\n### 部署到 Kubernetes\n\n使用下面的命令将以上服务部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# create new namespace\nkubectl create ns istio-tutorial\n\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f recommendation\/kubernetes\/Service.yml\n\n# deploy preferrence\nkubectl apply -f \u003c(istioctl kube-inject -f preference\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f preference\/kubernetes\/Service.yml\n\n# deploy customer\nkubectl apply -f \u003c(istioctl kube-inject -f customer\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl apply -f customer\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n**注意：**\u0060preference\u0060 和 \u0060customer\u0060 应用启动速度比较慢，我们将 livenessProb 配置中的 \u0060initialDelaySeconds\u0060 设置为 **20** 秒。\n\n查看 Pod 启动状态：\n\n\u0060\u0060\u0060bash\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加 Ingress 配置\n\n为了在 kubernetes 集群外部访问 customer 服务，我们需要增加 ingress 配置。\n\n\u0060\u0060\u0060bash\nkubectl apply -f ingress\/ingress.yaml\n\u0060\u0060\u0060\n\n修改本地的 \u0060\/etc\/hosts\u0060 文件，增加一条配置。\n\n\u0060\u0060\u0060ini\n172.17.8.102 customer.istio-tutorial.jimmysong.io\n\u0060\u0060\u0060\n\n现在访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\u0060 将看到如下输出：\n\n\u0060\u0060\u0060ini\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 1\n\u0060\u0060\u0060\n\n批量访问该地址。\n\n\u0060\u0060\u0060bash\n.\/bin\/poll_customer.sh\n\u0060\u0060\u0060\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务的分布式追踪和依赖关系。\n\n![分布式追踪](istio-tutorial-zipkin-trace.webp)\n\n![依赖关系](istio-tutorial-zipkin-dependency.webp)\n\n访问 \u0060http:\/\/servicegraph.istio.jimmysong.io\/dotviz\u0060 查看服务间的关系图和 QPS。\n\n![服务关系图和 QPS](istio-tutorial-Servicegraph-dotviz.webp)\n\n访问 \u0060http:\/\/grafana.istio.jimmysong.io\u0060 查看 Service Mesh 的监控信息。\n\n![Grafana 监控](istio-tutorial-grafana.webp)\n\n## Istio 使用示例\n\n为了试用 Istio 中的各种功能，我们需要为应用构建多个版本，我们为 recommendation 构建 v2 版本的镜像，看看如何使用 Istio 控制微服务的流量。\n\n### 构建 recommendation:v2\n\n我们将构建新版的 \u0060recommendation\u0060 服务的镜像，并观察 \u0060customer\u0060 对不同版本的 \u0060recommendataion\u0060 服务的访问频率。\n\n修改 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 程序中代码。\n\n将 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v1 from \u0027%s\u0027: %d\\n\u0022;\u0060 修改为 \u0060private static final String RESPONSE_STRING_FORMAT = \u0022recommendation v2 from \u0027%s\u0027: %d\\n\u0022;\u0060\n\n并构建 \u0060recommendation:v2\u0060 镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n将应用部署到 kubernetes。\n\n\u0060\u0060\u0060bash\n# deploy recommendation\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务，将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3581\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3582\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3583\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 4\n\u0060\u0060\u0060\n\n我们可以看到 v1 和 v2 版本的 \u0060recommendation\u0060 服务会被间隔访问到。\n\n我们再将 v2 版本的 \u0060recommendation\u0060 实例数设置成 2 个。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=2 deployment\/recommendation-v2 -n istio-tutorial\nkubectl get pod -w -n istio-tutorial\n\u0060\u0060\u0060\n\n观察 \u0060recommendation-v2\u0060 Pod 达到两个之后再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 1\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 71\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3651\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 2\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 72\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3652\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-j9fgj\u0027: 3\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 73\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3653\n\u0060\u0060\u0060\n\n观察输出中 v1 和 v2 版本 \u0060recommendation\u0060 的访问频率。\n\n将 \u0060recommendataion\u0060 服务的实例数恢复为 1。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=1 deployment\/recommendation-v2\n\u0060\u0060\u0060\n\n### 修改 Istio RouteRules\n\n以下所有路有规则都是针对 \u0060recommendation\u0060 服务，并在 repo 的根目录下执行。\n\n**将所有流量打给 v2**\n\n下面将演示如何动态的划分不同版本服务间的流量，将所有的流量都打到 \u0060recommendation:v2\u0060。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务将看到所有的流量都会打到 \u0060recommendation:v2\u0060。\n\n删除 RouteRules 后再访问 \u0060customer\u0060 服务将看到又恢复了 v1 和 v2 版本的 \u0060recommendation\u0060 服务的间隔访问。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-default\n\u0060\u0060\u0060\n\n**切分流量**\n\n将 90% 的流量给 v1，10% 的流量给 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行\u0060bin\/poll_customer.sh\u0060 观察访问情况。\n\n要想动态切分流量只要修改 RouteRules 中的 \u0060weight\u0060 配置即可。\n\n\u0060\u0060\u0060yaml\napiVersion: config.istio.io\/v1alpha2\nkind: RouteRule\nmetadata:\n  name: recommendation-v1-v2\nspec:\n  destination:\n    namespace: istio-tutorial\n    name: recommendation\n  precedence: 5\n  route:\n  - labels:\n      version: v1\n    weight: 90\n  - labels:\n      version: v2\n    weight: 10\n\u0060\u0060\u0060\n\n因为 RouteRule 有优先级，为了继续后面的实验，在验证完成后删除该 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 故障注入\n\n有时候我们为了增强系统的健壮性，需要对系统做混沌工程，故意注入故障，并保障服务可以自动处理这些故障。\n\n**注入 HTTP 503 错误**\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-503.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n有 50% 的几率报 503 错误。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 135\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3860\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 136\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 3861\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\ncustomer =\u003e preference =\u003e recommendation v2 from \u002777b9f6cc68-5xs27\u0027: 137\ncustomer =\u003e 503 preference =\u003e 503 fault filter abort\n\u0060\u0060\u0060\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 增加延迟\n\n增加服务的访问延迟。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-delay.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n会有 50% 的几率访问 \u0060recommendation\u0060 服务有 7 秒的延迟。百分比和延迟时间可以在 RouteRule 中配置。\n\n清理 RouteRule。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-delay -n istio-tutorial\n\u0060\u0060\u0060\n\n### 重试\n\n让服务不是直接失败，而是增加重试机制。\n\n我们下面将同时应用两条 RouteRule，让访问 \u0060recommendation\u0060 服务时有 50% 的几率出现 503 错误，并在出现错误的时候尝试访问 v2 版本，超时时间为 2 秒。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v2_503.yml -n istio-tutorial\nistioctl create -f istiofiles\/route-rule-recommendation-v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n执行 \u0060bin\/poll_customer.sh\u0060 我们看到一开始有些 503 错误，然后所有的流量都流向了 v2。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v2-retry -n istio-tutorial\nistioctl delete routerule recommendation-v2-503 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 超时\n\n设置超时时间，只有服务访问超时才认定服务访问失败。\n\n取消注释 \u0060recommendation\/java\/vertx\/src\/main\/java\/com\/redhat\/developer\/demos\/recommendation\/RecommendationVerticle.java\u0060 中的下面一行，增加超时时间为 3 秒。\n\n\u0060\u0060\u0060java\nrouter.get(\u0022\/\u0022).handler(this::timeout);\n\u0060\u0060\u0060\n\n重新生成镜像。\n\n\u0060\u0060\u0060bash\ncd recommendation\/java\/vertx\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-recommendation:v2 .\ndocker push jimmysong\/istio-tutorial-recommendation:v2\n\u0060\u0060\u0060\n\n重新部署到 kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl delete -f recommendation\/kubernetes\/Deployment-v2.yml\n\u0060\u0060\u0060\n\n因为我们重新构建的镜像使用了同样的名字和 tag，而之前在 \u0060Deployment-v2.yml\u0060 中配置的镜像拉取策略是 \u0060IfNotPresent\u0060，这样的话即使我们构建了新的镜像也无法应用到集群上，因此将镜像拉取策略改成 \u0060Always\u0060 确保每次启动 Pod 的时候都会拉取镜像。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f recommendation\/kubernetes\/Deployment-v2.yml) -n istio-tutorial\n\u0060\u0060\u0060\n\n启用超时 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-timeout.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n访问 \u0060customer\u0060 服务将看到如下输出：\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4002\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4003\ncustomer =\u003e 503 preference =\u003e 504 upstream request timeout\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 4004\n\u0060\u0060\u0060\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-timeout -n istio-tutorial\n\u0060\u0060\u0060\n\n### 基于 user-agent 的智能路由（金丝雀发布）\n\nUser-agent 是一个字符串，其中包含了浏览器的信息，访问 https:\/\/www.whoishostingthis.com\/tools\/user-agent 获取你的 user-agent。\n\n我的 user-agent 是：\n\n\u0060\u0060\u0060ini\nMozilla\/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/65.0.3325.181 Safari\/537.36\n\u0060\u0060\u0060\n\n将所有的流量打到 v1。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n将使用 Safari 浏览器访问的流量打到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-safari-recommendation-v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n谁用 Safari 或者 Chrome（Chrome 浏览器的 user-agent 中也包含 Safari 字段）访问 \u0060http:\/\/customer.istio-tutorial.jimmysong.io\/\u0060 在经过 3 秒钟（我们在前面重新编译 v2 镜像，设置了 3 秒超时时间）后将看到访问 v2 的输出。\n\n或者使用 curl 访问。\n\n\u0060\u0060\u0060bash\ncurl -A Safari http:\/\/customer.istio-tutorial.jimmysong.io\/\ncurl -A Firefox http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察返回的结果。\n\n将移动端用户的流量导到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-mobile-recommendation-v2.yml -n istio-tutorial\n\ncurl -A \u0022Mozilla\/5.0 (iPhone; U; CPU iPhone OS 4(KHTML, like Gecko) Version\/5.0.2 Mobile\/8J2 Safari\/6533.18.5\u0022 http:\/\/customer.istio-tutorial.jimmysong.io\/\n\u0060\u0060\u0060\n\n观察输出的结果。\n\n清理 RouteRules。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-mobile -n istio-tutorial\nistioctl delete routerule recommendation-safari -n istio-tutorial\nistioctl delete routerule recommendation-default -n istio-tutorial\n\u0060\u0060\u0060\n\n### 镜像流量\n\n确保当前至少运行了两个版本的 \u0060recommendation\u0060 服务，并且没有 RouteRule。\n\n注：可以使用 \u0060istioctl get routerule\u0060 获取 RouteRule。\n\n设置流量镜像，将所有 v1 的流量都被镜像到 v2。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1-mirror-v2.yml -n istio-tutorial\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n查看 recommendation-v2 的日志。\n\n\u0060\u0060\u0060bash\nkubectl logs -f \u0060oc get pods|grep recommendation-v2|awk \u0027{ print $1 }\u0027\u0060 -c recommendation\n\u0060\u0060\u0060\n\n### 访问控制\n\nIstio 可以设置服务访问的黑白名单，如果没有权限的话会返回 HTTP 404 Not Found。\n\n#### 白名单\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 404 NOT_FOUND:preferencewhitelist.listchecker.istio-tutorial:customer is not whitelisted\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-whitelist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n#### 黑名单\n\n设置黑名单，所有位于黑名单中的流量将获得 403 Forbidden 返回码。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e 403 PERMISSION_DENIED:denycustomerhandler.denier.istio-tutorial:Not allowed\n\u0060\u0060\u0060\n\n重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/acl-blacklist.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### 负载均衡\n\nKubernetes 中默认的负载均衡策略是 round-robin，当然我们可以使用 Istio 把它修改成 random。\n\n增加 v1 的实例数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v1 --replicas=2 -n istio-tutorial\n\u0060\u0060\u0060\n\n持续访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\nbin\/poll_customer.sh\n\u0060\u0060\u0060\n\n保持前台输出，观察流量的行为。\n\n应用负载均衡策略。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n观察一段时间流量的行为后，重置环境。\n\n\u0060\u0060\u0060bash\nistioctl delete -f istiofiles\/recommendation_lb_policy_app.yml -n istio-tutorial\nkubectl scale deployment recommendation-v1 --replicas=1 -n istio-tutorial\n\u0060\u0060\u0060\n\n### 速率限制\n\n暂时不可用\n\n### 断路器\n\n当达到最大连接数和最大挂起请求数时快速失败。\n\n将流量在 v1 和 v2 之间均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n未开启断路器的时候启动负载测试。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\nNew configuration template added to \/Users\/jimmysong\/.siege\nRun siege -C to view the current settings in that file\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.10 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.13 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.12 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.17 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.20 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.05 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.25 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.26 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.14 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.58 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.03 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.04 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.11 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     6.71 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     3.52 secs:      75 bytes ==\u003e GET  \/\n^C\nLifting the server siege...\nTransactions:\t\t          31 hits\nAvailability:\t\t      100.00 %\nElapsed time:\t\t        7.99 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        2.99 secs\nTransaction rate:\t        3.88 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t       11.60\nSuccessful transactions:          31\nFailed transactions:\t           0\nLongest transaction:\t        6.71\nShortest transaction:\t        0.05\n\u0060\u0060\u0060\n\n所有的请求都成功了，但是性能很差，因为 v2 版本设置了 3 秒的超时时间。\n\n我们启用下断路器。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n重新测试一下。\n\n\u0060\u0060\u0060bash\n$ siege -r 2 -c 20 -v customer.istio-tutorial.jimmysong.io\n** SIEGE 4.0.4\n** Preparing 20 concurrent users for battle.\nThe server is now under siege...\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.07 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.12 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.16 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.16 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.21 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.14 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.29 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.13 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.11 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.39 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.24 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.44 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.44 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.40 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.47 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.42 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.06 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.07 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.15 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.12 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.57 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.18 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.52 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.65 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.42 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.09 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.43 secs:      75 bytes ==\u003e GET  \/\nHTTP\/1.1 503     0.04 secs:      92 bytes ==\u003e GET  \/\nHTTP\/1.1 200     4.15 secs:      74 bytes ==\u003e GET  \/\nHTTP\/1.1 200     0.01 secs:      75 bytes ==\u003e GET  \/\n\nTransactions:\t\t          19 hits\nAvailability:\t\t       47.50 %\nElapsed time:\t\t        4.16 secs\nData transferred:\t        0.00 MB\nResponse time:\t\t        0.72 secs\nTransaction rate:\t        4.57 trans\/sec\nThroughput:\t\t        0.00 MB\/sec\nConcurrency:\t\t        3.31\nSuccessful transactions:          19\nFailed transactions:\t          21\nLongest transaction:\t        4.15\nShortest transaction:\t        0.01\n\u0060\u0060\u0060\n\n我们可以看到在启用了断路器后各项性能都有提高。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_version_v2.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Pool Ejection\n\n所谓的 Pool Ejection 就是当某些实例出现错误（如返回 5xx 错误码）临时将该实例弹出一段时间后（窗口期，可配置），然后再将其加入到负载均衡池中。我们的例子中配置的窗口期是 15 秒。\n\n将 v1 和 v2 的流量均分。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/route-rule-recommendation-v1_and_v2_50_50.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n增加 v2 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=2 -n istio-tutorial\nkubectl get pods -w\n\u0060\u0060\u0060\n\n等待所有的 Pod 的状态都启动完成。\n\n现在到 v2 的容器中操作。\n\n\u0060\u0060\u0060bash\n$ kubectl exec recommendation-v2-785465d9cd-225ms -c recommendation \/bin\/bash\n$ curl localhost:8080\/misbehave\nFollowing requests to \u0027\/\u0027 will return a 503\n\u0060\u0060\u0060\n\n增加 Pool Ejection 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n此时再访问 \u0060customer\u0060 服务。\n\n\u0060\u0060\u0060bash\n$ bin\/poll_customer.sh\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10505\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2407\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10506\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2408\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10507\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10508\ncustomer =\u003e preference =\u003e recommendation v1 from \u00276fc97476f8-m2ntp\u0027: 10509\ncustomer =\u003e 503 preference =\u003e 503 recommendation misbehavior from \u0027785465d9cd-ldc6j\u0027\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2409\ncustomer =\u003e preference =\u003e recommendation v2 from \u0027785465d9cd-225ms\u0027: 2410\n\u0060\u0060\u0060\n\n我们看到窗口期生效了，当出现 503 错误后至少 15 秒后才会出现第二次。\n\n即使有了负载均衡池弹出策略对于系统的弹性来说依然还不够，如果你的服务有多个可用实例，可以将**断路器**、**重试**、**Pool Ejection** 等策略组合起来使用。\n\n例如在以上的 Pool Ejection 的基础上增加重试策略。\n\n\u0060\u0060\u0060bash\nistioctl replace -f istiofiles\/route-rule-recommendation-v1_and_v2_retry.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n现在再访问 \u0060customer\u0060 服务就看不到 503 错误了。\n\n清理配置。\n\n\u0060\u0060\u0060bash\nkubectl scale deployment recommendation-v2 --replicas=1 -n istio-tutorial\nistioctl delete routerule recommendation-v1-v2 -n istio-tutorial\nistioctl delete -f istiofiles\/recommendation_cb_policy_pool_ejection.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n### Egress\n\nEgress 是用来配置 Istio Service mesh 中的服务对外部服务的访问策略。\n\n具体配置请参考 [控制 Egress 流量](http:\/\/istio.doczh.cn\/docs\/tasks\/traffic-management\/egress.html)。\n\n以下示例还有问题，无法正常工作。\n\n构建示例镜像 egresshttpbin。\n\n\u0060\u0060\u0060bash\ncd egress\/egresshttpbin\/\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egresshttpbin:v1 .\ndocker push jimmysong\/istio-tutorial-egresshttpbin:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egresshttpbin\/src\/main\/kubernetes\/Deployment.yml) -n istio-toturial\nkubectl create -f egress\/egresshttpbin\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n为了在 kubernetes 集群外部访问到该服务，修改增加 ingress 配置并修改本地的\u0060\/etc\/hosts\u0060 文件，我们在前面已经完成了，此处不再赘述。\n\n构建示例镜像 egressgithub。\n\n\u0060\u0060\u0060bash\ncd egress\/egressgithub\nmvn clean package\ndocker build -t jimmysong\/istio-tutorial-egressgithub:v1 .\ndocker push jimmysong\/istio-tutorial-egressgithub:v1\n\u0060\u0060\u0060\n\n部署到 Kubernetes。\n\n\u0060\u0060\u0060bash\nkubectl apply -f \u003c(istioctl kube-inject -f egress\/egressgithub\/src\/main\/kubernetes\/Deployment.yml) -n istio-tutorial\nkubectl create -f egress\/egressgithub\/src\/main\/kubernetes\/Service.yml\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_httpbin.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egresshttpbin 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egresshttpbin,version=v1) -c egresshttpbin \/bin\/bash\n\ncurl localhost:8080\n\ncurl httpbin.org\/user-agent\n\ncurl httpbin.org\/headers\n\nexit\n\u0060\u0060\u0060\n\n增加对 [jimmysong.io](https:\/\/jimmysong.io) 的 egress 配置。\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | istioctl create -f -\napiVersion: config.istio.io\/v1alpha2\nkind: EgressRule\nmetadata:\n  name: jimmysong-egress-rule\n  namespace: istio-tutorial\nspec:\n  destination:\n    service: jimmysong.io\n  ports:\n    - port: 443\n      protocol: https\nEOF\n\u0060\u0060\u0060\n\n增加 Egress 配置。\n\n\u0060\u0060\u0060bash\nistioctl create -f istiofiles\/egress_github.yml -n istio-tutorial\n\u0060\u0060\u0060\n\n到 egressgithub 容器中测试。\n\n\u0060\u0060\u0060bash\nkubectl exec -it $(oc get pods -o jsonpath=\u0022{.items[*].metadata.name}\u0022 -l app=egressgithub,version=v1) -c egressgithub \/bin\/bash\n\ncurl http:\/\/jimmysong:443\n\nexit\n\u0060\u0060\u0060\n\n清理环境。\n\n\u0060\u0060\u0060bash\nistioctl delete egressrule httpbin-egress-rule jimmysong-egress-rule github-egress-rule -n istio-tutorial\n\u0060\u0060\u0060\n\n## 参考\n\n- https:\/\/github.com\/redhat-developer-demos\/istio-tutorial\n- [Book - Introducing Istio Service Mesh for Microservices](https:\/\/developers.redhat.com\/books\/introducing-istio-service-mesh-microservices\/)\n', '\/blog\/istio-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Istio 管理 Java 微服务的案例教程。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-community-tips/">Istio 社区介绍与社区参与注意事项</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/14</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 社区介绍与社区参与注意事项', '本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。', '\n本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。\n\n### 工作组\n\n绝大多数复杂的开源项目都是以工作组的方式组织的，要想为 Istio 社区做贡献可以加入到以下的工作组（Working Group）：\n\n- [API Management](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#api-management)\n- [Config](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#config)\n- [Environments](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#environments)\n- [Networking](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#networking)\n- [Performance \u0026 Scalability](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#performance-and-scalability)\n- [Policies \u0026 Telemetry](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#policies-and-telemetry)\n- [Security](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#security)\n- [Test \u0026 Release](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md#test-and-release)\n\n### 代码规范\n\nIstio 的代码规范沿用 [CNCF 社区的代码规范](https:\/\/github.com\/cncf\/foundation\/blob\/master\/code-of-conduct.md)。\n\n### 开发指南\n\n进行 Istio 开发之前需要做下面几件事情：\n\n- 配置基础环境，如 Kubernetes\n- 配置代码库、下载依赖和测试\n- 配置 CircleCI 集成环境\n- 编写参考文档\n- Git workflow 配置\n\n详见 [Dev Guide wiki](https:\/\/github.com\/istio\/istio\/wiki\/Dev-Guide)。\n\n### 设计文档\n\n所有的设计文档都保存在 [Google Drive](https:\/\/drive.google.com\/drive\/u\/0\/folders\/0AIS5p3eW9BCtUk9PVA) 中，其中包括以下资源：\n\n- Technical Oversight Committee：ToC 管理的文档\n- Misc：一些杂项\n- Working Groups：最重要的部分，各个工作组相关的设计文档\n- Presentations：Istio 相关的演讲幻灯片，从这些文稿中可以快速了解 Istio\n- Logo：Istio logo\n- Eng：社区相关的维护文档\n\n### 社区角色划分\n\n根据对开发者和要求和贡献程度的不同，Istio 社区中包含以下角色：\n\n- [Collaborator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#collaborator)：非正式贡献者，偶尔贡献，任何人都可以成为该角色\n- [Member](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#member)：正式贡献者，经常贡献，必须有 2 个已有的 member 提名\n- [Approver](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#approver)：老手，可以批准 member 的贡献\n- [Lead](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#lead)：管理功能、项目和提议，必须由 [ToC](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUP-PROCESSES.md) 提名\n- [Administrator](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#administrator)：管理员，管理和控制权限，必须由 ToC 提名\n- [Vendor](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md#vendor)：贡献 Istio 项目的扩展\n\n详见 [Istio Community Roles](https:\/\/github.com\/istio\/community\/blob\/master\/ROLES.md)。\n\n### 各种功能的状态\n\nIstio 中的所有 feature 根据**是否生产可用**、**API 兼容性**、**性能**、**维护策略**分为三种状态：\n\n- Alpha：仅仅可以作为 demo，无法生产上使用，也没有性能保证，随时都可能不维护\n- Beta：可以在生产上使用了，也有版本化的 API 但是无法保证性能，保证三个月的维护\n- Stable：可以上生产而且还能保证性能，API 向后兼容，保证一年的维护\n\nIstio 的 feature 分为四大类：\n\n- 流量管理：各种协议的支持、路由规则配置、Ingress TLS 等\n- 可观测性：监控、日志、分布式追踪、服务依赖拓扑\n- 安全性：各种 checker 和安全性配置\n- Core：核心功能\n\n功能划分与各种功能的状态详情请见：\u003chttps:\/\/istio.io\/latest\/about\/feature-stages\/\u003e\n\n### 云原生社区 Istio 讨论组\n\n[云原生社区](https:\/\/cloudnative.to)专门成立里 Istio SIG（微信讨论群），将原来 ServiceMesher 中关注 Istio 的人群专门集中到一个讨论组中，其中包含了百度、阿里巴巴、腾讯、网易、Tetrate、Intel、字节跳动等公司的服务网格专家及众多的终端用户，欢迎大家[申请加入群聊](https:\/\/i.cloudnative.to\/istio)。\n', '\/blog\/istio-community-tips\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文讲述了参与 Istio 社区和进行 Istio 开发时需要注意的事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/what-is-a-service-mesh/">什么是 Service Mesh（服务网格）？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/09/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('什么是 Service Mesh（服务网格）？', '本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。', '\nService Mesh 又译作“服务网格”，作为服务间通信的基础设施层。Buoyant 公司的 CEO Willian Morgan 在他的这篇文章 WHAT’S A Service Mesh? AND WHY DO I NEED ONE? 中解释了什么是 Service Mesh，为什么云原生应用需要 Service Mesh。\n\n下面是 [Willian Morgan](https:\/\/twitter.com\/wm) 对 Service Mesh 的解释。\n\n\u003e A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\n翻译成中文是：\n\n\u003e 服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。\n\n## Service Mesh 的特点\n\nService Mesh 有如下几个特点：\n\n- 应用程序间通信的中间层\n- 轻量级网络代理\n- 应用程序无感知\n- 解耦应用程序的重试\/超时、监控、追踪和服务发现\n\n目前两款流行的 Service Mesh 开源软件 [Istio](https:\/\/istio.io) 和 [Linkerd](https:\/\/linkerd.io) 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 中的项目。\n\n## 理解 Service Mesh\n\n如果用一句话来解释什么是 Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP\/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP\/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原本通过服务框架实现的事情，比如 Spring Cloud、Netflix OSS 和其他中间件，现在只要交给 Service Mesh 就可以了。\n\n[Phil Calçado](http:\/\/philcalcado.com\/) 在他的这篇博客 [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html) 中详细解释了 Service Mesh 的来龙去脉：\n\n1. 从最原始的主机之间直接使用网线相连\n2. 网络层的出现\n3. 集成到应用程序内部的控制流\n4. 分解到应用程序外部的控制流\n5. 应用程序的中集成服务发现和断路器\n6. 出现了专门用于服务发现和断路器的软件包\/库，如 [Twitter 的 Finagle](https:\/\/finagle.github.io\/) 和 [Facebook  的 Proxygen](https:\/\/code.facebook.com\/posts\/1503205539947302)，这时候还是集成在应用程序内部\n7. 出现了专门用于服务发现和断路器的开源软件，如 [Netflix OSS](http:\/\/netflix.github.io\/)、Airbnb 的 [synapse](https:\/\/github.com\/airbnb\/synapse) 和 [nerve](https:\/\/github.com\/airbnb\/nerve)\n8. 最后作为微服务的中间层 Service Mesh 出现\n\nService Mesh 的架构如下图所示：\n\n![Service Mesh 架构图](service-mesh-arch.png)\n\n图片来自：[Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n\nService Mesh 作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 Service mesh 中实现。\n\n## Service Mesh 如何工作？\n\n下面以 Istio 为例讲解 Service Mesh 如何工作，后续文章将会详解 Istio 如何在 Kubernetes 中工作。\n\n1. Sidecar（Istio 中使用 [Envoy](https:\/\/envoyproxy.io) 作为 sidecar 代理）将服务请求路由到目的地址，根据请求中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。这些配置是由服务网格的控制平面推送给各个 sidecar 的，\n2. 当 sidecar 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。\n3. Sidecar 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。\n4. Sidecar 将请求发送给该实例，同时记录响应类型和延迟数据。\n5. 如果该实例挂了、不响应了或者进程不工作了，sidecar 会将把请求发送到其他实例上重试。\n6. 如果该实例持续返回 error，sidecar 会将该实例从负载均衡池中移除，稍后再周期性得重试。\n7. 如果请求的截止时间已过，sidecar 主动标记该请求为失败，而不是再次尝试添加负载。\n8. SIdecar 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。\n\n## 为何使用 Service Mesh？\n\nService Mesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。\n\n在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 twitter 开发的 [Finagle](https:\/\/twitter.github.io\/finagle\/)、Netflix 开发的 [Hystrix](https:\/\/github.com\/Netflix\/Hystrix) 和 Google 的 Stubby 这样的“胖客户端”库，这些就是早期的 Service Mesh，但是它们都仅适用于特定的环境和特定的开发语言，并不能作为平台级的 Service Mesh 支持。\n\n在 Cloud Native 架构下，容器的使用赋予了异构应用程序更多的可能性，Kubernetes 增强了应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情，进而专注于程序开发，赋予开发者更多的创造性。\n\n## 参考\n\n- What\u0027s a Service Mesh? And why do I need one?\n- [So what even is a Service Mesh? Hot take on Istio and Linkerd](http:\/\/redmonk.com\/jgovernor\/2017\/05\/31\/so-what-even-is-a-service-mesh-hot-take-on-istio-and-linkerd)\n- [linkerd: A Service Mesh for AWS ECS](https:\/\/medium.com\/attest-engineering\/linkerd-a-service-mesh-for-aws-ecs-937f201f847a)\n- [Introducing Istio: A robust Service Mesh for microservices](https:\/\/istio.io\/blog\/istio-service-mesh-for-microservices.html)\n- [Application Network Functions With ESBs, API Management, and Now.. Service Mesh?](http:\/\/blog.christianposta.com\/microservices\/application-network-functions-with-esbs-api-management-and-now-service-mesh\/)\n- [Pattern: Service Mesh](http:\/\/philcalcado.com\/2017\/08\/03\/pattern_service_mesh.html)\n- [Envoy 官方文档](https:\/\/envoyproxy.io)\n- [Istio 官方文档](https:\/\/istio.io\/)\n\n', '\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Service Mesh 是什么，其工作原理并提供了一些有用的链接。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/service-mesh/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/service-mesh/page/3/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/service-mesh/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(39)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(21)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(16)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/kubecon-china-2024-recap/">KubeCon China 2024 回顾：引领云原生技术的前沿动态</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/black-myth-wukong-game-life/">从黑神话悟空聊起：我心目中的 3A 大作</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/envoy-gateway-integration-istio-mesh/">集成 Envoy Gateway 作为 Istio 服务网格中的入口网关</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
