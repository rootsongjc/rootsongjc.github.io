<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>服务网格专栏 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.43f1d27d1f7f43d4b95a5eea89dbb0853793f223820fe3dfeac768d5b1b02ea9.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.43f1d27d1f7f43d4b95a5eea89dbb0853793f223820fe3dfeac768d5b1b02ea9.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/service-mesh/" />
  <meta property="og:title" content="服务网格专栏 | Jimmy Song" />
  <meta property="twitter:title" content="服务网格专栏 | Jimmy Song" />

  
  <meta property="og:description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。" />
  <meta property="twitter:description" content="欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/service-mesh/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    服务网格专栏
                </p>
                <p class="page-description">
                    欢迎来到服务网格专栏，这里是关于服务网格技术的全面资源和深入解读。涵盖了从基础概念到高级应用的各种主题，包括服务发现、负载均衡、流量管理、安全策略和可观测性。无论你是初学者还是资深开发者，都能在这里找到有价值的内容。通过我们的教程、指南和最佳实践，你将能够更好地理解和应用服务网格技术，提升你的微服务架构的可靠性、可管理性和安全性。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/using-traefik-ingress-controller-with-istio-service-mesh/">[译] 在 Istio 服务网格中使用 Traefik Ingress Controller</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://thenewstack.io/using-traefik-ingress-controller-with-istio-service-mesh/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Istio 服务网格中使用 Traefik Ingress Controller', '本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。', '\nIstio 服务网格自带 ingress，但我们经常看到有要求使用非 Istio ingress 的客户。此前，我们已经介绍过[将 NGINX 与 Istio 集成](https:\/\/www.tetrate.io\/blog\/using-istio-with-other-ingress-proxies\/)的情况。最近，我们一直在与使用 [Traefik](https:\/\/traefik.io\/) ingress 的客户合作。通过对我们之前建议的方法进行一些轻微调整，我将向你介绍如何实现 Traefik 作为 Istio 服务网格的入口网关。\n\n流量的流向如下图所示。一旦请求从 Traefik Ingress 到达服务网格，Istio 就能够对请求应用安全性、可观测性和流量引导规则。\n\n![](008eGmZEly1gp4j5v18z8j31hc0u07ad.jpg)\n\n传入的流量绕过 Istio sidecar，直接到达 Traefik，所以请求终止在 Traefik ingress。\n\nTraefik 使用 \u0060IngressRoute\u0060 配置重写 Host 头以匹配目的地，并将请求转发到目标服务，这是一个多步骤的过程。\n\n- 从 Traefik Ingress 出来的请求被重定向到 Istio sidecar（由 iptables）。\n- Sidecar 接收请求，对其进行加密（因为我们的 Istio \u0060PeerAuthentication\u0060 策略要求使用 STRICT mTLS），然后将请求转发到目标服务的 pod。\n\n下面是一个端到端的部署示例，使用 Istio 的 bookinfo 演示应用，但用 Traefik ingress 来支撑整个部署。简而言之，要想在自己的环境中实现这个功能。\n\n- 用 Istio sidecar 部署 Traefik 控制器，注释部署，使入站流量绕过 Istio Sidecar:\n\n\u0060\u0060\u0060\n# Exclude the ports that Traefik receives traffic on\ntraffic.sidecar.istio.io\/excludeInboundPorts: “80” \n\n# Make sure Traefik controller can talk to the Kubernetes API server \n\ntraffic.sidecar.istio.io\/excludeOutboundIPRanges: X.X.X.X\/32 \n\u0060\u0060\u0060\n\n- 在应用程序命名空间中启用 Istio sidecar 注入，并部署任何你需要的 Istio 特定配置。\n- 用 Traefik \u0060Middleware\u0060 对象创建 \u0060IngressRoute\u0060，将主机名改写为网格识别的主机名（即集群中的服务；下文将通过一个例子详细讨论）。\n\n## 使用 Traefik Ingress 的 Bookinfo\n\n这篇文章的其余部分涵盖了部署 Istio 的 Bookinfo 示例应用程序，使用 Traefik 作为部署的 Ingress 代理。\n\n### 设置环境\n\n参考以下步骤。\n\n1. 部署一个至少 1.17 版本的 Kuberentes 集群（最小支持 Istio 1.8 版本）。我们使用 Google Kubernetes Engine 创建的集群。\n\n\u0060\u0060\u0060sh\ngcloud container clusters create istio-traefik \\\n  --cluster-version=1.17 \\\n  --region \u003cGCP region\u003e \\\n  --machine-type=e2-standard-4 \\\n  --project \u003cGCP Project\u003e \\\n  --num-nodes 1 \\\n  --node-locations \u003cGCP Zone\u003e # i.e us-west2-b (otherwise 1 node per zone)\n\u0060\u0060\u0060\n\n1. 下载 Istio 1.8\n\n\u0060\u0060\u0060sh\ncurl -sL https:\/\/git.io\/getLatestIstio |\\\nISTIO_VERSION=1.8.1 sh -\n\u0060\u0060\u0060\n\n1. 在启用 HTTP 访问日志的情况下进行安装。\n\n\u0060\u0060\u0060sh\n.\/istio-1.8.1\/bin\/istioctl install \\\n  --set meshConfig.accessLogFile=\/dev\/stdout \\\n  --skip-confirmation\n\u0060\u0060\u0060\n\n### 部署 Bookinfo 应用\n\n安装好 Istio 后，我们就可以开始部署我们的应用程序了。我们将使用 Istio 的 Bookinfo 应用程序进行演示。这个示例应用程序是 Istio 发行版的一部分（在\u0060.\/istio-1.8.1\/samples\/\u0060 文件夹中）。\n\n1. 创建 bookinfo namespace。\n\n\u0060\u0060\u0060sh\nkubectl create ns bookinfo\n\u0060\u0060\u0060\n\n1. 设置 label，让 sidecar 自动注入。\n\n\u0060\u0060\u0060sh\nkubectl label namespace bookinfo istio-injection=enabled\n\u0060\u0060\u0060\n\n1. 在该 namespace 中部署 bookinfo 应用程序。\n\n\u0060\u0060\u0060sh\nkubectl apply -f istio-1.8.1\/samples\/bookinfo\/platform\/kube\/bookinfo.yaml -n bookinfo\n\u0060\u0060\u0060\n\n确认所有的吊舱都已启动，并部署了侧车。\n\n启用 Istio mTLS 为应用程序命名空间的服务到服务通信。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: bookinfo\nspec:\n  mtls:\n    mode: STRICT\nEOF\n\u0060\u0060\u0060\n\n### 部署 Traefik 入口\n\n现在是时候按照 v2.3 文档来部署 Traefik 了（本篇文章中 Traefik 的最新版本是 2.3，但如果你根据你的版本调整了 \u0060IngressRoute\u0060 和 \u0060Middleware\u0060 资源，它将适用于任何版本的 Traefik）。\n\n1. 部署 Traefik。请注意，Traefik 网站上的文档部署有一些修改（代替 Traefik 文档中的默认命名空间，将指定 bookinfo 命名空间）。该文件可以在这里访问并应用如下。\n\n\u0060\u0060\u0060sh\n$ kubectl apply -f http:\/\/bit.ly\/Traefik-CRDs-and-Roles\ncustomresourcedefinition.apiextensions.k8s.io\/ingressroutes.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/middlewares.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/ingressroutetcps.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/ingressrouteudps.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/tlsoptions.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/tlsstores.traefik.containo.us created\ncustomresourcedefinition.apiextensions.k8s.io\/traefikservices.traefik.containo.us created\nclusterrole.rbac.authorization.k8s.io\/traefik-ingress-lb created\nclusterrolebinding.rbac.authorization.k8s.io\/traefik-ingress-lb created\n\u0060\u0060\u0060\n\n1. 为传入的请求创建一个服务。该服务将接收外部 IP 地址。(Traefik 网站上的例子有一些变化)。\n\n- 需要指定 Namespace。\n- 只发布两个端口：80 用于 Bookinfo 应用，8080 用于 Traefik 管理。\n- 服务需要使用的标签（traefik-ingress-lb）指向 Traefik。\n- \u0060Type: Loadbalancer\u0060 是为了告诉 GCP 给服务分配一个外部 IP。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: v1\nkind: Service\nmetadata:\n  name: traefik\n  namespace: bookinfo\nspec:\n  ports:\n    - protocol: TCP\n      name: web\n      port: 80\n    - protocol: TCP\n      name: admin\n      port: 8080\n  selector:\n    app: traefik-ingress-lb\n  type: LoadBalancer\nEOF\n\u0060\u0060\u0060\n\n1. 确认服务的创建符合预期。\n\n\u0060\u0060\u0060sh\n$ kubectl get svc traefik -n bookinfo\nNAME      TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                       AGE\ntraefik   LoadBalancer   10.35.244.227   35.236.XXX.XXX   80:31718\/TCP,8080:31334\/TCP   2m6s\n\u0060\u0060\u0060\n\n1. 正如 [Traefik 网站](https:\/\/doc.traefik.io\/traefik\/user-guides\/crd-acme\/)中介绍的，需要应用 \u0060ServiceAccount\u0060 的 Kubernetes 部署。除了名称和命名空间，网站示例还引入了以下变化。\n\n- 为了简单起见，删除了安全端点。\n  - \u0060Accesslog\u0060：增加了 \u0060=true\u0060，因为没有这个值就不行。\n  - \u0060Log.level\u0060 设置为 DEBUG 将帮助我们看到发生了什么。\n  - 增加了 \u0060traffic.sidecar.istio.io\u0060 注释（更多细节请参考之前提到的 Tetrate [NGINX 文章](https:\/\/www.tetrate.io\/blog\/using-istio-with-other-ingress-proxies\/)）。\n\n\u0060\u0060\u0060sh\nKUBERNETES_SVC_IP=$( kubectl get svc kubernetes -n default -o jsonpath=\u0027{.spec.clusterIP}\u0027 )\n \ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: bookinfo\n  name: traefik-ingress-lb\n \n---\nkind: Deployment\napiVersion: apps\/v1\nmetadata:\n  namespace: bookinfo\n  name: traefik-ingress-lb\n  labels:\n    app: traefik-ingress-lb\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: traefik-ingress-lb\n  template:\n    metadata:\n      labels:\n        app: traefik-ingress-lb\n      annotations:\n        traffic.sidecar.istio.io\/excludeInboundPorts: \u002280\u0022\n        traffic.sidecar.istio.io\/excludeOutboundIPRanges: ${KUBERNETES_SVC_IP}\/32\n    spec:\n      serviceAccountName: traefik-ingress-lb\n      containers:\n        - name: traefik-ingress-lb\n          image: traefik:v2.3\n          args:\n            - --api.insecure\n            - --accesslog=true\n            - --providers.kubernetescrd\n            - --entrypoints.web.address=:80\n            - --log.level=DEBUG\n          ports:\n            - name: web\n              containerPort: 80\n            - name: admin\n              containerPort: 8080\nEOF\n\u0060\u0060\u0060\n\n1. 确认 Traefik 在 Bookinfo 命名空间的部署。\n\n\u0060\u0060\u0060\n$  kubectl get pods -n bookinfo -l app=traefik-ingress-lb\nNAME                                  READY   STATUS    RESTARTS   AGE\ntraefik-ingress-lb-669fc4b77d-74mpx   2\/2     Running   0          2m35s\n\u0060\u0060\u0060\n\n1. 获取服务 IP 并记录 BOOKINFO_IP 变量值。\n\n\u0060\u0060\u0060\nBOOKINFO_IP=$(kubectl -n bookinfo get service traefik -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\n1. 测试来自 Ingress 80 端口的响应，看看它是否有通往应用的路由。\n\n\u0060\u0060\u0060sh\ncurl -I $BOOKINFO_IP\n\u0060\u0060\u0060\n\n确保它返回“404 Not Found”—— 由于尚未实施 Ingress 规则，所以预计会有 not-200 响应。\n\n### 配置 Traefik Ingress 规则\n\n1. Traefik 的 \u0060Middleware\u0060 头重写功能将使 Istio 服务网格正常运行。本例中，需要将主机定义为 \u0060productpage.bookinfo.svc\u0060。头可以根据 Traefik 文档来定义。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: traefik.containo.us\/v1alpha1\nkind: Middleware\nmetadata:\n  name: productpage-header\n  namespace: bookinfo\nspec:\n  headers:\n    customRequestHeaders:\n      Host: productpage.bookinfo.svc\nEOF\n\u0060\u0060\u0060\n\n1. 最后一步是指定 ingress 请求的路由逻辑，因为本文的重点是服务网格集成。这个定义非常简单，将所有到达 80 端口的入站请求转发到名为 ProductPage 的前沿 bookinfo 应用服务（服务于 9080 端口的流量）。它还使用了上一步创建的中间件对象。\n\n\u0060\u0060\u0060sh\ncat \u003c\u003cEOF | kubectl apply -f - \napiVersion: traefik.containo.us\/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: productpage\n  namespace: bookinfo\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: PathPrefix(\u0060\/\u0060)\n    kind: Rule\n    middlewares:\n    - name: productpage-header\n    services:\n    - name: productpage\n      port: 9080\nEOF\n\u0060\u0060\u0060\n\n### 验证部署功能\n\n1. 重新测试应用程序的响应。\n\n\u0060\u0060\u0060sh\ncurl -I $BOOKINFO_IP\n\u0060\u0060\u0060\n\n我们会收到“200 OK“的回复。也可以通过浏览器测试，使用 \u0060http:\/\/\u003cBOOKINFO_IP\u003e\/productpage\u0060。\n\n1. 如果在 \u0060http:\/\/\u003cBOOKINFO_IP\u003e\/productpage\u0060，就会返回应用响应。\n\n![](008eGmZEly1gp4jrzhuugj30iq0aqaam.jpg)\n\n1. 通过查询 istio-proxy 容器的 bookinfo 命名空间中的 Traefik pod 日志，可以在 istio-proxy 日志中看到向应用程序发出的请求。没有传入请求，因为它们直接到达 Traefik Ingress。\n\n\u0060\u0060\u0060sh\nTRAEFIK_POD=$( kubectl -n bookinfo get pods -l app=traefik-ingress-lb -o jsonpath=\u0027{.items[0].metadata.name}\u0027 )\nkubectl -n bookinfo logs ${TRAEFIK_POD} -c istio-proxy\n\u0060\u0060\u0060\n\n请注意，请求处理后，日志需要几秒钟才能显示。只有在 Istio 安装时使用 \u0060meshConfig.accessLogFile=\/dev\/stdout\u0060 标志的情况下，才会显示日志。\n\n\u0060\u0060\u0060ini\n[2021-01-05T20:13:55.015Z] \u0022GET \/productpage HTTP\/1.1\u0022 200 - \u0022-\u0022 0 5179 1069 1069 \u002210.32.0.1\u0022 \u0022Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/87.0.4280.88 Safari\/537.36\u0022 \u00224bd443e9-1a2e-4d30-b1e3-398a5005f240\u0022 \u0022productpage.bookinfo.svc\u0022 \u002210.32.0.18:9080\u0022 outbound|9080||productpage.bookinfo.svc.cluster.local 10.32.0.19:51810 10.32.0.18:9080 10.32.0.1:0 - default\n[2021-01-05T20:13:56.301Z] \u0022GET \/static\/bootstrap\/fonts\/glyphicons-halflings-regular.woff2 HTTP\/1.1\u0022 200 - \u0022-\u0022 0 18028 3 3 \u002210.32.0.1\u0022 \u0022Mozilla\/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/87.0.4280.88 Safari\/537.36\u0022 \u00228cb44552-c3c8-45dd-8674-4af207ce1648\u0022 \u0022productpage.bookinfo.svc\u0022 \u002210.32.0.18:9080\u0022 outbound|9080||productpage.bookinfo.svc.cluster.local 10.32.0.19:51810 10.32.0.18:9080 10.32.0.1:0 - default\n\u0060\u0060\u0060\n\n## 总结\n\n本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。这里应用的基本方法应该是适用的，即使你的环境与我们例子中使用的环境不同。当引入服务网格时，Traefik \/ 服务网格集成可以在不同的云中成功实施，并使用全新或现有（也就是棕地）部署 Traefik。最终，您将获得两者最好的东西：Istio 服务网格与您所选择的 Ingress 控制器相集成！\n', '\/trans\/using-traefik-ingress-controller-with-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文演示了如何将 Traefik Ingress 作为 Istio 服务网格的入口点。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/multi-cluster-service-mesh/">[译] 是否选择多集群——使用服务网格的集群间通信</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/03/31</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://www.infoq.com/articles/kubernetes-multicluster-comms/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('是否选择多集群——使用服务网格的集群间通信', '是否该使用服务网格构建多集群？本文会给你答案。', '\n本文翻译自 [To Multicluster, or Not to Multicluster: Inter-Cluster Communication Using a Service Mesh](https:\/\/www.infoq.com\/articles\/kubernetes-multicluster-comms\/)。Istio 服务网格是解决 Kubernetes 集群间通信的一个关键，虽然翻译这篇文章距离原文发表也有快 2 年时间了，但是其中的很多观点仍不过时。\n\n## 主要观点\n\n- Kubernetes 已经成为容器编排的事实标准，许多组织都运行着多个集群。集群内的通信是一个解决了的问题，但是跨集群的通信需要更多的设计和操作开销。\n- 在决定是否实施多集群支持之前，你应该了解你的通信用例。\n- 你还应该确定你想要从解决方案中获得什么（单一界面的观察性、统一信任域等），然后制定一个关于如何实现这些的计划。\n- 有几种多集群服务网格方法，如共同管理、集群感知服务通过网关路由、扁平网络和 split-horizon 端点发现服务（EDS）。\n- Istio 有现有的多集群支持，在 1.1 中还有额外的新功能，甚至未来还会有更多的功能出现。\n\nKubernetes 已经成为企业中容器编排的事实标准。这是有充分理由的 —— 它提供了一系列功能，使管理容器化应用变得更加容易。Kubernetes 也带来了一些新的挑战，一个主要的挑战就是需要部署和管理多个 Kubernetes 集群，以便有效地管理大规模分布式系统。\n\n想象一下，你已经设计和编码了一个应用，并且你已经构建了容器 —— 你只需要运行它们。从代码到运行应用是令人振奋的，但正如任何构建了容器化应用的人所知道的那样，它并不像乍看起来那样简单。在部署到生产之前，有各种开发 \/ 测试 \/ 阶段周期。此外，还有一个扩展方面的问题 —— 你的生产应用可能需要在许多不同的地方运行，原因包括水平扩展性、弹性或接近最终用户。\n\n## 环境越多，（集群）问题越多\n\n即使是一个简单的绿地应用概念，最终也需要多个部署环境。如果你正在迁移一个现有的应用，你一定会遇到更多的挑战，比如不同的安全域，不同的组织 \/ 计费，以及对一个云供应商的机器学习工具包的亲和力。\n\n解决这个问题最常见的方法是创建多个 Kubernetes 集群，每个集群都致力于在其特定环境中运行你的应用组件。在高安全领域，你将广泛使用基于角色的访问控制（RBAC），并具有审计功能。测试环境应该重现很多生产行为，但要为便于调试和检查而定制。对于你的开发环境…… 好吧，也许你像我一样，你就打开 Docker 偏好设置，然后勾选 Kubernetes 框。易用性和短暂性是常态。\n\n你很可能最终会有多个 Kubernetes 集群，每个集群都会托管微服务。集群中这些微服务之间的通信可以通过服务网格来加强。在集群内部，Istio 提供了通用的通信模式来提高弹性、安全性和可观测性。那么集群之间和跨集群呢？\n\n运行多个 Kubernetes 集群并不一定可怕，但运行多个集群确实需要你考虑它们如何通信和交互，以便轻松交付运行在上面的优秀应用。像 Istio 这样的服务网格可以让多集群通信变得毫无痛苦。Istio 拥有多集群支持，在 1.1 中增加了新功能，并计划在未来增加更多的功能。团队也应该考虑采用服务网格来简化跨多个集群的通信。\n\n## 常见的使用案例\n\n运行多集群服务网格最常见的是这些用户需求。\n\n- 由于我的组织规模，我有多个集群，我想在一个地方查看和管理它们。我的集群一般不做集群间的流量，或者当它们做的时候，是通过定义好的 API。\n- 我有多个集群以实现高可用性，它们是彼此的克隆，如果一个集群发生故障，另一个集群可以接管，这一点非常重要。\n- 我有多个集群，它们组合成一个更高级别的应用。其中一个集群中的微服务需要与另一个集群中的微服务进行通信，以提供适当的端到端应用体验。\n\n第三类多集群需要集群间的流量。如果你想要集群间流量支持，你的实现将取决于集群之间的网络，以及你对容错的要求。\n\n### 你能从多集群中得到什么？\n\n当你考虑多集群和服务网格时，你应该从确定你想要什么开始，然后转移到如何获得它。\n\n### 单一界面\n\n你的多个服务网格从一个地方操作。你可以在一个单一的接口中查看所有集群的配置、指标和跟踪。\n\n### 统一信任域\n\n你使用服务网格来提供工作负载识别，并由强大的 mTLS 加密保护。这种零信任模型比基于源 IP 等拓扑信息来信任工作负载更好：你依靠的是它们是什么的加密证明，而不是脆弱的外围堆栈来控制它们的来源。\n\n统一的信任域意味着所有的工作负载都可以通过绑定到一个共同的信任根来相互认证（它们是什么）。服务网格控制平面都是为这个共同的信任根配置的，无论这些平面有一个还是几个。\n\n### 独立的故障域\n\n一个不依赖其他集群和相关基础设施，本身就可以正常运行的集群是一个独立的故障域。我是把服务网格列为相关基础设施 —— 如果你要安装服务网格，你是为了把通信弹性转移到应用下面的基础设施层。如果一个集群中的服务网格的故障可以破坏另一个集群中的服务网格，那么它就不能算是一个独立的故障域。\n\n### 集群间的流量\n\n如果你想让一个集群中的服务与另一个集群中的服务直接通信，并且你想让这种通信具有服务网格的好处，如高级路由、可观测性或透明加密，那么你需要集群之间的流量保持为服务网格的一部分。换句话说，你希望你的东\/西流量离开一个集群，中转一些中间网络，比如互联网，然后进入另一个集群。\n\n这可能是大多数人在考虑多集群服务网格时的第一想法，但我在这里单独把它列出来，因为它对容错有影响。\n\n### 异构\/非扁平化的网络\n\n非平面网络支持跨多个集群的服务，没有平面网络的要求。这意味着你可以做一些事情，比如在一个网格中分配 IP，而不考虑另一个网格，你不需要 VPN 或网络隧道来进行跨网格的通信。\n\n如果你的组织已经创建了一堆不同的集群，而没有冲突的 pod IP 地址范围，或者你只是永远不想再进入这种泥潭，这将是一个对你有吸引力的属性。\n\n## 多集群服务网格方法\n\n在阐述了你可能需要从多集群中寻找的不同属性之后，我可以介绍一下各种方法所带来的好处。\n\n### 独立集群\n\n这就是解多集群。仅仅因为你有多个集群，而且每个集群都使用一个服务网格，并不意味着你必须采用统一的多集群服务网格。扪心自问，你当初为什么会有多个集群。如果你希望每个集群都是自己独立的故障域，那么隔离和消除跨集群的依赖关系是有意义的。如果这能满足你的需求，那么把服务网格当作另一个单集群的服务，比如 pod 调度或持久性磁盘管理，也没有什么坏处。\n\n### 共同管理\n\n在独立集群方法之上的下一步是多个集群的共同管理系统。在这种模式下，每个集群都是独立运行的，但你通过一个共同的管理界面来管理这套网格。让你用来监控和调试系统（或者，在这种情况下，系统）的东西驻留在系统本身之外是一个很好的设计，这样当系统坏了的时候，你仍然可以检查和修复它。\n\n如果你选择在这些集群中使用一个共同的信任根（证书授权或签名证书），那么你也可以拥有一个统一的信任域。\n\n如果独立的故障域是首要任务，那么这是一个不错的选择。这种选择很适合将软件作为服务来消费，因为你可以得到一个外部的接口来统一一切，并得到服务级别协议的支持。\n\n### 通过网关进行集群感知的服务路由选择\n\nIstio 中的这种方法涉及多个独立的服务网格，每个集群中一个，以及一些配置技巧，以允许一个集群中的服务与另一个集群中的服务通信。首先，你要为所有网格创建一个统一的信任域。接下来，你配置一个入口网关，以接受来自另一个对等集群中的服务的可信流量。最后，配置服务条目，以允许某些服务的流量从一个集群路由出来并发送到另一个集群。\n\n这是第一种允许不同集群中的服务直接相互通信的方法。同时，每个集群仍然是一个独立的网格控制平面和故障域。这意味着，如果集群 B 中的服务网格发生故障，集群 A 仍然可以工作，只是看起来集群 B 中的服务不可用。配置这种跨集群流量的负担就落在了用户身上。\n\n### 扁平网络\n\n这种模式决定了你所有集群的服务网格。你安排它，使每个集群中的 pod 具有非重叠的 IP 地址，因此任何 pod 可以将流量路由到任何集群中的其他 pod。你可能在一个共同的防火墙后面有一堆集群，或者你可能在集群间建立 VPN 隧道。你配置服务网格，以将发现的 pod、服务和来自每个集群的配置结合到一个整体视图中。\n\n扁平化的网络使它看起来就像你有一个超级服务网格，横跨你的所有集群。也有一些缺点。这个超级服务网格由一个控制平面管理，所以如果它出现问题，所有集群的服务网格都会出现问题。如果你原来为了容错而划分成多个 Kubernetes 集群，这种方式就否定了这一点。另外一个考虑是控制平面必须要扩展来管理所有集群。而且你必须让这个扁平网络的性能足够好，以处理控制平面和跨集群的流量。\n\n### 分割区域端点发现服务（EDS）\n\n这种方法也可以在集群间创建一个服务网格，但不需要扁平网络。你仍然有一个控制平面，可以从每个集群中发现 pod、服务和配置，但 Istio 的 EDS，其功能类似于分裂水平 DNS，取代了对扁平网络的要求。\n\n一个集群中的 pod 的 sidecar 被配置了它想要通信的每个服务的端点列表。如果 pod 在同一个集群中，它就会直接显示在 EDS 列表中。如果 pod 在另一个集群中，则会出现另一个集群的入口网关。pod 选择一个端点进行对话并发送流量 —— 如果端点是本地的，则通信是直接的 pod 到 pod。如果 pod 选择了一个远程端点，它就会将流量发送到相关入口网关的地址，并标记为 pod 想要访问的服务。入口网关接收流量，并将其发送到其集群中实现服务的 pod 之一。入口网关使用服务器名称指示（SNI）来了解流量的目的地。\n\n与扁平网络方式一样，这种方式创建了一个统一的服务网格控制平面，并增加了一个单一故障域和单一信任域。它不需要扁平网络，只需要一个集群可以将流量发送到其他集群的入口网关的公共地址。\n\n## 要不要多集群？\n\n如果你出于开发和组织的原因要运行多个集群，那么了解你的需求并决定是否要在多集群环境中连接这些需求是很重要的，如果是这样，了解各种方法和每个选项的相关权衡。\n\n如果你已经读到这里，你可能已经决定了多集群。真正的问题是什么是最好的实现方法。希望下面的表格能帮助你决定适合你的方法。\n\n| 方法                               | 统一管理 | 统一信任 | 异构网络 | 独立故障域 | 跨集群通信 |\n| ---------------------------------- | -------- | -------- | -------- | ---------- | ---------- |\n| 独立集群                           |          |          | √        |            |            |\n| 共同管理                           | √        |          | √        | √          |            |\n| 扁平网络                           | √        | √        |          |            | √          |\n| 分割区域端点发现服务（EDS）        | √        | √        | √        |            | √          |\n| 通过网关进行集群感知的服务路由选择 |          | √        | √        | √          | √          |\n\n像 Istio 这样的服务网格可以提供帮助，如果使用得当，可以让多集群通信变得不痛苦。如果你想了解更多关于我对为什么以及团队应该如何考虑采用服务网格来简化跨多个集群的通信的看法。\n\n## 关于作者\n\nAndrew Jenkins 是 Aspen Mesh 的首席技术官，他正在构建一个企业服务网格，以帮助企业减轻管理微服务的负担。作为容器环境（如 Kubernetes）的软件和网络架构师，Jenkins 曾担任技术领导，推动快速发展的团队取得切实成果。他的专长包括 C\u002b\u002b、JavaScript（Node.js）、Python、C、Go 和 Java 的软件开发。Jenkins 还在软件和硬件测试、FPGA 和空间科学仪器的电路板设计方面拥有丰富的经验。\n', '\/trans\/multi-cluster-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">是否该使用服务网格构建多集群？本文会给你答案。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-you-should-choose-ngac-as-your-access-control-model/">为什么应该选择使用 NGAC 作为权限控制模型</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/02/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么应该选择使用 NGAC 作为权限控制模型', '本文将向你介绍下一代权限控制模型——NGAC，并对比 ABAC、RABC，说明为什么要选择 NGAC。', '\n本文为我跟 Ignasi Barrera 共同创作，本文英文版首发于 [TheNewStack](https:\/\/thenewstack.io\/why-you-should-choose-ngac-as-your-access-control-model\/)。\n\n不同的公司或软件供应商已经设计了无数种方法来控制用户对功能或资源的访问，如酌情访问控制（DAC）、强制访问控制（MAC）、基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。从本质上讲，无论何种类型的访问控制模型，都可以抽象出三个基本要素：用户、系统 \/ 应用和策略。\n\n在本文中，我们将介绍 ABAC、RBAC 以及一种新的访问控制模型 —— 下一代访问控制（NGAC），并比较三者之间的异同，以及为什么你应该考虑 NGAC。\n\n## 什么是 RBAC？\n\nRBAC，即基于角色的访问控制，采用的方法是根据用户在组织中的角色授予（或拒绝）对资源的访问。每个角色都被分配了一系列的权限和限制，这很好，因为你不需要跟踪每个系统用户和他们的属性。你只需要更新相应的角色，将角色分配给用户，或者删除分配。但这可能很难管理和扩展。使用 RBAC 静态角色模型的企业经历了角色爆炸：大公司可能有数万个相似但不同的角色或用户，他们的角色会随着时间的推移而改变，因此很难跟踪角色或审计不需要的权限。RBAC 具有固定的访问权限，没有规定短暂的权限，也没有考虑位置、时间或设备等属性。使用 RBAC 的企业很难满足复杂的访问控制要求，以满足其他组织需求的监管要求。\n\n### RBAC 示例\n\n下面是 Kubernetes 中 \u0060default\u0060 命名空间中的一个 Role，可以用来授予 pod 的读取权限。\n\n\u0060\u0060\u0060yaml\napiVersion: rbac.authorization.k8s.io\/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n- apiGroups: [\u0022v1\u0022]\n  resources: [\u0022pods\u0022]\n  verbs: [\u0022get\u0022, \u0022watch\u0022, \u0022list\u0022]\n\u0060\u0060\u0060\n\n## 什么是 ABAC？\n\nABAC 是“基于属性的访问控制“的缩写。从高层次上讲，[NIST](https:\/\/www.nist.gov\/publications\/guide-attribute-based-access-control-abac-definition-and-considerations-1) 将 ABAC 定义为一种访问控制方法，“在这种方法中，根据分配的主体属性、环境条件以及用这些属性和条件指定的一组策略，批准或拒绝主体对对象进行操作的请求。”ABAC 是一个细粒度的模型，因为你可以给用户分配任何属性，但同时它也成为一种负担，很难管理：\n\n- 在定义权限的时候，用户和对象之间的关系无法可视化。\n- 如果规则设计的有点复杂或者混乱，对于管理员来说，维护和跟踪会很麻烦。\n\n当有大量的权限需要处理时，会造成性能问题。\n\n### ABAC 示例\n\nKubernetes 最初使用 ABAC 作为访问控制，并通过 JSON 行配置，例如：\n\nAlice 可以只读取命名空间 \u0060foo\u0060 中的 pod。\n\n\u0060\u0060\u0060json\n {\u0022apiVersion\u0022: \u0022abac.authorization.kubernetes.io\/v1beta1\u0022, \u0022kind\u0022: \u0022Policy\u0022, \u0022spec\u0022: {\u0022user\u0022: \u0022alice\u0022, \u0022namespace\u0022: \u0022foo\u0022, \u0022resource\u0022: \u0022pods\u0022, \u0022readonly\u0022: true}}\n\u0060\u0060\u0060\n\n## 什么是 NGAC？\n\nNGAC，即下一代访问控制，采用将访问决定数据建模为图的方法。NGAC 可以实现系统化、策略一致的访问控制方法，以高精细度授予或拒绝用户管理能力。NGAC 由 [NIST](https:\/\/www.nist.gov\/)（美国国家标准与技术研究所）开发，目前用于 [Tetrate Q](https:\/\/www.tetrate.io\/blog\/introducing-tetrate-q\/) 和 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)。\n\n有几种类型的实体；它们代表了您要保护的资源、它们之间的关系以及与系统互动的行为者。这些实体是：\n\n- 用户\n- 对象\n- 用户属性，如组织单位\n- 对象属性，如文件夹\n- 策略类，如文件系统访问、位置和时间\n\nNIST 的 David Ferraiolo 和 [Tetrate](https:\/\/www.tetrate.io\/) 的 Ignasi Barrera 在旧金山举行的 2019 年服务网格日（Service Mesh Day 2019）上发表了关于下一代访问控制的 [演讲](https:\/\/www.tetrate.io\/blog\/unpacking-next-generation-access-control-ngac-and-tetrate-q\/)，分享了 NGAC 的工作原理。\n\nNGAC 是基于这样一个假设：你可以用一个图来表示你要保护的系统，这个图代表了你要保护的资源和你的组织结构，这个图对你有意义，并且符合你的组织语义。在这个对你的组织非常特殊的模型之上，你可以叠加策略。在资源模型和用户模型之间，定义了权限。这样 NGAC 提供了一种优雅的方式来表示你要保护的资源，系统中的不同角色，以及如何用权限把这两个世界联系在一起。\n\n![NGAC 模型中的 DAG](008eGmZEly1gnu26nral2j30ke0ay0ue.jpg)\n\n图片来自于 [Linear Time Algorithms to Restrict Insider Access using Multi-Policy Access Control Systems](https:\/\/tsapps.nist.gov\/publication\/get_pdf.cfm?pub_id=922390)\n\n### NGAC 示例\n\n下面的例子展示了一个简单的 NGAC 图，其中有一个代表组织结构的用户 DAG，一个代表文件系统中的文件和文件夹的对象 DAG，一个文件的分类，以及两个不同的策略 —— 文件系统和范围，可以结合起来做出访问决策。两个 DAG 之间的关联边定义了行为者对目标资源的权限。\n\n![NGAC 示例图](008eGmZEly1gnu27wttcnj30lx0f7my9.jpg)\n\n在这张图中，我们可以看到 \u0060\/hr-docs\u0060 文件夹中的两个文件 \u0060resume\u0060 和 \u0060contract\u0060 的表示，每个文件都链接到一个类别（\u0060public\u0060\/\u0060confidential\u0060）。还有两个策略类，\u0060File System\u0060 和 \u0060Scope\u0060，图中的对象被连接在这里 —— 需要满足这些条件才能获得对每个文件的访问权。\n\n在例子中，用户 Allice 对两个文件都有读写访问权限，因为有一个路径将 Allice 链接到每个文件，而且路径授予了两个策略类的权限。但是，用户 Bob 只有对 \u0060resume\u0060 文件的访问权，因为虽然存在一个从 Bob 到 \u0060contract\u0060 文件的路径，该路径满足 \u0060File System\u0060 策略类的“读 \u0022 权限，但没有授予 \u0060Scope\u0060 策略类权限的路径。所以，Bob 对 \u0060contract\u0060 文件的访问被拒绝。\n\n## 为什么选择 NGAC？\n\n在 ABAC 的情况下，需要跟踪所有对象的属性，这造成了可管理性的负担。RBAC 减少了负担，因为我们提取了所有角色的访问信息，但是这种模式存在角色爆炸的问题，也会变得不可管理。有了 NGAC，我们在图中就有了我们所需要的一切 —— 以一种紧凑、集中的方式。\n\n当访问决策很复杂时，ABAC 的处理时间会成倍上升。RBAC 在规模上变得特别难以管理，而 NGAC 则可以线性扩展。\n\nNGAC 真正出彩的地方在于灵活性。它可以被配置为允许或不允许访问，不仅基于对象属性，而且基于其他条件 —— 时间、位置、月相等。\n\nNGAC 的其他关键优势包括能够一致地设置策略（以满足合规性要求）和设置历时性策略的能力。例如，NGAC 可以在中断期间授予开发人员一次性的资源访问权，而不会留下不必要的权限，以免日后导致安全漏洞。NGAC 可以在一个访问决策中评估和组合多个策略，同时保持其线性时间的复杂度。\n\n## 总结\n\n下表从几个方面对 ABAC、RBAC 和 NGAC 进行了比较。\n\n| 权限模型 | 优点                                 | 缺点                                   |\n| -------- | ------------------------------------ | -------------------------------------- |\n| ABAC     | 灵活                                 | 性能和审计问题                         |\n| RBAC     | 简单                                 | 角色爆炸、固定的访问权限、合规需求挑战 |\n| NGAC     | 细粒度、利于审计、灵活、组合权限策略 | 复杂                                   |\n\n总而言之：\n\n- RBAC 比较简单，性能好，但在规模上会受到影响。\n- ABAC 很灵活，但性能和可审计性是个问题。\n- NGAC 通过使用一种新颖、优雅的革命性方法来修复这些差距：在用户提供的现有世界表示之上叠加访问策略。你也可以对 RBAC 和 ABAC 策略进行建模。\n\n## 参考\n\n- [Guide to Attribute-Based Access Control (ABAC) Definition and Considerations](https:\/\/nvlpubs.nist.gov\/nistpubs\/specialpublications\/NIST.SP.800-162.pdf)\n- [RBAC vs. ABAC: What’s the Difference?](https:\/\/www.comparitech.com\/net-admin\/rbac-vs-abac\/)\n- [Role Explosion: The Unintended Consequence of RBAC](https:\/\/www.linkedin.com\/pulse\/role-explosion-unintended-consequence-rbac-oren-ohayon-harel\/)\n- [Exploring the Next Generation of Access Control Methodologies](https:\/\/www.nist.gov\/publications\/exploring-next-generation-access-control-methodologies)\n', '\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将向你介绍下一代权限控制模型——NGAC，并对比 ABAC、RABC，说明为什么要选择 NGAC。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/eks-eksd-istio-hybrid-cloud/">使用 EKS-D 和 Istio 保证混合云环境一致性</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 EKS-D 和 Istio 保证混合云环境一致性', '本文将为你解析 EKS-D 的战略意义，说明它是如何与 Istio 共同保证混合云环境一致性的。', '\nAWS 在 2020 年 12 月举行的 re:Invent 大会上发布了 [EKS-D](https:\/\/distro.eks.amazonaws.com\/)，此举旨在联合合作伙伴，开源 AWS 维护大规模 EKS 集群的经验，帮助用户实现混合云场景下 Kubernetes 的一致性的体验。本文将为你解析 EKS-D 的战略意义，说明它是如何与 Istio 共同保证混合云环境一致性的。\n\n## 什么是 EKS-D？\n\nEKS-D 是 Amazon EKS 的一个发行版，可以运行在企业内部、云端或自己的系统上。EKS-D 保持与 Kubernetes 新版本同期发布。在不久的将来，将以 EKS Anywhere（EKS-A）为名，提供 EKS-D 的支持、打包产品和安装方法。\n\n下图展示了 AWS、EKS-D、Kubernetes 及用户之间的关系。\n\n![](0081Kckwly1gm3oyi69h3j31af0u0ju1.jpg)\n\nEKS-D 对于 AWS、合作伙伴及用户来说具有不同的意义。\n\n- AWS：增加 AWS 的市场拥有率\n- 合作伙伴：整合 AWS 的渠道和客户资源以触达更多用户\n- 用户：保证了异构环境下的 Kubernetes 的一致性，简化运维\n\n如今企业要考虑选择哪个云供应商要考虑很多因素，同时，还有很多企业的 IT 难以跨入云，而是继续依赖究竟考验的传统 IT 架构以开展业务。\n\n在上云的时候客户希望在企业内部和云端获得一致的体验，以便进行迁移或实现混合云设置。不是所有应用都适合跨云迁移，为了合规、数据安全等种种原因，多集群、混合云的使用场景将很普遍。\n\n## 为什么使用多集群和混合云\n\n我们在很多情况下或使用多集群、混合云等部署方式，例如：\n\n- 为了避免厂商锁定，便于应用跨集群迁移；\n- 为了实现应用的高可用；\n- 当一个集群的规模过大造成性能瓶颈时；\n- 为了合规和数据安全；\n- 为了就近部署，降低网络延迟，提高用户体验；\n- 为了进行一些测试；\n- 突发业务，需要集群扩容；\n\n以上情况经常发生，对集群的管理造成了挑战。Kubernetes 统一了容器编排的标准，随着其进一步普及，更有望成为云原生应用的底层 API。但是对于如何管理多集群和混合云环境中的 Kubernetes 集群，又为我们带来了新的挑战。\n\n## 使用 Istio service mesh 管理混合云\n\nIstio 服务网格作为云原生应用的网络基础设施层，可以同时管理 Kubernetes 及非容器负载，如[虚拟机](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)。Istio 可以在[多种平台](https:\/\/istio.io\/latest\/docs\/setup\/platform-setup\/)中部署，又支持多种[部署模式](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/deployment-models\/)，兼具管理多集群和混合云的功能。在部署时需要充分考虑 Region、Zone 的分布、网络隔离、多租户、控制平面的高可用等因素。\n\n假如我们同时使用 EKS 和部署在私有数据中心中的 EKS-D，那么如何将两个集群使用一个统一的控制平面管理起来呢？如下图所示，cluster1 和 cluster2 分别表示部署在 EKS 和 EKS-D 的 Kubernetes 集群，这两个集群的网络是隔离的，现因为上文所说的适合使用混合云某个场景，现在为了将它们纳入同一个服务网格使用一个控制平面来管理，我们采用了 [Primary-Remote 多网络](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/primary-remote_multi-network\/)的部署模式。\n\n![](0081Kckwly1gm3oyiyq4fj315m0u0wi2.jpg)\n\n图示：\n\n- 图中黑色箭头表示控制平面内获取服务和端点配置的请求；\n- 图中蓝色箭头表示服务 A 访问服务 B 的路由；\n- 图中绿色箭头表示服务 A\/B 向控制平面获取服务端点的路由；\n\n使用该模式部署 Istio 时，需要保证控制平面对 Kubernetes 的 API Server 的连接性，具体的安装过程请参考 [Istio 文档](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/primary-remote_multi-network\/)。\n\n## 总结\n\nEKS-D 保证了在混合云环境下 Kubernetes 集群的一致性，降低了集群的运维成本。Istio 固有的多集群感知能力，进一步从服务层面增强了用户体验的一致性，帮助我们将多集群中的服务纳入统一的控制平面管理。EKS-D 发布的时有众多的合作伙伴的响应，其中 Tetrate 作为 Istio service mesh 的解决方案供应商提供了 [Tetrate Service Bridge（TSB）](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)在 EKS 和 EKS-D 上实现了跨工作负载的统一应用连接和安全性。', '\/blog\/eks-eksd-istio-hybrid-cloud\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为你解析 EKS-D 的战略意义，说明它是如何与 Istio 共同保证混合云环境一致性的。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-vm-odysssey/">Istio 对虚拟机支持史话</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/12/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 对虚拟机支持史话', '本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 WorkloadGroup 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。', '\n本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 \u0060WorkloadGroup\u0060 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。\n\n## 前言\n\n在我[之前的博客](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)中谈到 Istio 1.7 如何支持虚拟机，但那时虚拟机仍然无法无缝的集成到 Istio 中，因为还需要做很多手动的操作。现在，Istio 1.8 新增了 WorkloadGroup 及[智能 DNS 代理](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)，这使得如虚拟机这样的非 Kubernetes 工作负载可以在 Istio 中成为像 Pod 一样的一等公民。\n\n不论有没有为虚拟机安装 sidecar，虚拟机通常情况下无法直接访问 Kubernetes 集群中的 DNS 服务器以解析 Kubernetes  服务的 Cluster IP 的（虽然你也许可以通过一些黑客的手段做到），这是在 Istio 中集成虚拟的最后一块短板，终于在 Istio 1.8 中完成了突破。\n\n## 为什么要支持虚拟机？\n\n在我们将应用在迁移到云原生架构，不断容器化的过程中，将经历三个阶段，如下图所示。\n\n![云原生应用的三个阶段](0081Kckwly1gm0d6t775lj31s80k8go8.jpg)\n\n- 阶段一：应用全部部署在虚拟机上\n- 阶段二：应用既部署在虚拟机上也部署在容器里，正在从虚拟机向容器中迁移，并使用 Kubernetes 管理容器\n- 阶段三：所有的应用优先部署在容器里，使用 Kubernetes 管理容器，使用 Istio 管理应用间的通信\n\n上图仅是对以上三个阶段的最简化描述，实际上还会有多混合云、多机房、多集群等情况，且阶段三只是个理想化的阶段，容器和虚拟机将是长期共存的，但是容器化趋势不变。\n\n在阶段二中，人们通常会将新业务和少量应用率先实现容器化，并部署到 Kubernetes 中，在应用尚未完全实现容器化的时候，处于过度状态时会遇到很多问题，如何让应用与部署在虚拟机中的服务交互？虚拟机如何访问容器中的服务？在服务迁移的过程中如何保证稳定无缝？是否可以将容器和虚拟机纳入一个统一的控制平面来管理？Istio 从开源初期就考虑并着手解决这一问题。\n\n## Istio 支持虚拟机的历史\n\nIstio 对于虚拟机的支持是个漫长的过程，堪称是一部奥德赛。\n\n### Istio mesh 扩张\n\nIstio 从 0.2 版本开始通过 [Istio Mesh Expansion](https:\/\/istio.io\/v0.2\/docs\/setup\/kubernetes\/mesh-expansion.html) 将虚拟机加入的 Mesh 中，但是需要满足以下前提条件：\n\n- 虚拟机必须可以通过 IP 地址直接访问到应用的 Pod，这就要求容器与 VM 之间通过 VPC 或者 VPN 建立扁平网络，虚拟机不需要访问 Cluster IP，直接对服务的 Endpoint 端点访问即可。\n- 虚拟机必须可以访问到 Istio 的控制平面服务（Pilot、Mixer、CA，现在已正整合为 Istiod），可以通过在 Istio Mesh 中部署负载均衡器将控制平面端点暴露给虚拟机。\n- （可选）虚拟机可以访问到 Mesh 内部的（部署在 Kubernetes 中）的 DNS server。\n\n集成虚拟机的步骤如下：\n\n1. 为 Istio 控制平面服务及 Kubernetes 集群的 DNS 服务创建 Internal 负载均衡器；\n2. 生成 Istio Service CIDR、Service Account token、安全证书、Istio 控制平面服务的 IP（通过 Internal 负载均衡器暴露出来的 IP）的配置文件并发送给虚拟机；\n3. （可选）在虚拟机中安装、配置并启动 Istio 的组件、dnsmaq（用于 DNS 发现），此时虚拟机可以使用   FQDN 访问 mesh 中的服务了，这一步是为了保证虚拟机可以正确解析出 mesh 中服务的 Cluster IP；\n4. 若要在虚拟机中运行服务，需要配置 sidecar，新增需要拦截的 inbound 端口，然后重启 istio，还需要运行 istioctl 为服务注册\n\n下图展示的从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程。\n\n![图一：从集成虚拟机到在 mesh 中访问虚拟机中服务的详细流程](0081Kckwly1gm0d6rogojj30u00yhdil.jpg)\n\n1. DNS 被虚拟机中部署的 \u0060dnsmasq\u0060 劫持，这使得它可以正确的获取 Istio 服务、Kubernetes 内置 DNS 的端点 IP；\n2. 访问 Kubernetes 的内置 DNS 服务（该服务已通过 Internal 负载均衡器暴露到集群外，可以直接访问）；\n3. 返回 \u0060productpage.bookinfo.svc.cluster.local\u0060 被解析出来的 Cluster IP，注意该 IP 地址无法直接访问，但是如果无法被 DNS 解析的话将导致 VM 对该服务的请求失败；\n4. 虚拟机对 mesh 中服务的访问被 sidecar proxy 劫持；\n5. 因为 proxy 已连接 Istio 控制平面，可通过 xDS 查询到该服务的端点，因此流量将被转发到其中的一个端点。\n6. 要想在 mesh 中访问 VM 中的服务，需要使用 \u0060istioctl register\u0060 命令手动将 VM 中的服务添加到 mesh 中，这本质上是将 VM 中的服务，注册到 Kubernetes 中的 service 和 endpoint；\n7. mesh 中的服务可以使用 VM 注册的服务名称（FQDN，例如 \u0060mysql.vm.svc.cluster.local\u0060）来访问；\n\n以上 Istio 对虚拟机支持的方式一直延续到 Istio 1.0，在 Istio 1.1 的时候引入了新的 API [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/)，使用它可以在 Istio 的内部服务注册表中添加额外的条目，这样 mesh 中的服务就可以访问\/路由到这些手动指定的服务了，不再需要运行 \u0060istioctl register\u0060 命令，而且该命令在 Istio 1.9 中将被废弃。\n\nIstio 1.5 中增加了 \u0060istioctl experimental add-to-mesh\u0060 命令，可以将虚拟机中的服务添加到 mesh 中，其功能与 \u0060istioctl register\u0060 一样。\n\n### 新增资源抽象\n\nIstio 从 [1.6 版本](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/)开始在[流量管理](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/change-notes\/)中引入了新的资源类型 [WorkloadEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-entry\/)，用以将虚拟机进行抽象，使得虚拟机在加入 mesh 后可以作为与 Kubernetes 中的 Pod 等同的负载，具备流量管理、安全管理、可视化等能力。通过 \u0060WorkloadEntry\u0060 可以简化虚拟机的网格化配置过程。\u0060WorkloadEntry\u0060 对象可以根据服务条目中指定的标签选择器选择多个工作负载条目和 Kubernetes pod。\n\nIstio 1.8 中增加了 [\u0060WorkloadGroup\u0060](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) 的资源对象，它提供了一个规范，可以同时包括虚拟机和 Kubernetes 工作负载，旨在模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n下面是虚拟机与 Kubernetes 中负载的资源抽象层级对比。\n\n| 对比项         | Kubernetes | 虚拟机        |\n| -------------- | ---------- | ------------- |\n| 基础调度单位   | Pod        | WorkloadEntry |\n| 编排组合       | Deployment | WorkloadGroup |\n| 服务注册与发现 | Service    | ServiceEntry  |\n\n从上面的图表中我们可以看到，对于虚拟机工作负载是可以与 Kubernetes 中的负载一一对对应的。\n\n此时看似一切都比较完美了，但是直接将 Kubernetes 集群中的 DNS server 暴露出来会带来很大的[安全风险](https:\/\/blog.aquasec.com\/dns-spoofing-kubernetes-clusters)，因此我们一般手动将虚拟机需要访问的服务的域名和 Cluster IP 对写到本机的 \u0060\/etc\/hosts\u0060 中，但是对于一个节点数量庞大的分布式集群来说，这种做法又有些不现实。\n\n通过配置虚拟机本地 \u0060\/etc\/hosts\u0060 访问 mesh 内服务的流程，如下图所示。\n\n![图二：通过配置虚拟机本地 \/etc\/hosts 访问 mesh 内服务的流程](0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg)\n\n1. 将虚拟机中的服务注册到 mesh 中；\n2. 将要访问的服务的域名、Cluster IP 对手动写入虚拟机本地的 \u0060\/etc\/hosts\u0060 文件中；\n3. 虚拟机获得访问服务的 Cluster IP；\n4. 流量被 sidecar proxy 拦截并解析出要访问的服务的端点地址；\n5. 访问服务的指定端点；\n\n在 Kubernetes 中我们一般使用 Service 对象来实现服务的注册和发现，每个服务都有一个独立的 DNS 名称，应用程序可以使用服务名称来互相调用。我们可以使用 ServiceEntry 将虚拟机中的服务注册到 Istio 的服务注册表中，但是在 Kubernetes 集群中的 DNS server 无法对 mesh 外部暴露的情况下，虚拟机无法访问 Kubernetes 集群中的 DNS 服务以获取服务的 Cluster IP，从而导致虚拟机访问 mesh 中的服务失败。如果能在虚拟机中增加一个 sidecar 可以透明地拦截 DNS 请求，可获取 mesh 内所有服务的 ClusterIP，类似于图一中的 \u0060dnsmasq\u0060 的角色，这样不就可以解决问题了吗？\n\n### 智能 DNS 代理\n\nIstio 1.8 中引入了[智能 DNS 代理](https:\/\/cloudnative.to\/blog\/istio-dns-proxy\/)，虚拟机访问 mesh 内服务无需再配置 \u0060\/ect\/hosts\u0060，如下图所示。\n\n![图三：引入了智能 DNS 代理后虚拟机访问 mesh 内服务的流程](0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg)\n\nDNS proxy 是用 Go 编写的 Istio sidecar 代理。Sidecar 上的 Istio agent 将附带一个由 Istiod 动态编程的缓存 DNS 代理。来自应用程序的 DNS 查询会被 pod 或 VM 中的 Istio 代理透明地拦截和服务，该代理会智能地响应 DNS 查询请求，可以实现虚拟机到服务网格的无缝多集群访问。\n\n至此，Istio 1.8 中引入的 WordloadGroup 及智能 DNS 代理，补足了 Istio 对虚拟机支持的最后一块短板，使得部署在虚拟机中的遗留应用可以跟 Kubernetes 中的 Pod 一样完全等同看待。\n\n## 总结\n\n在这部 Istio 支持虚拟机的奥德赛中，我们可以看到：从最初的将 mesh 中的 DNS server 暴露给外部，在虚拟机中安装配置 \u0060dnsmasq\u0060，到最后的使用智能 DNS 代理，并使用 \u0060WorkloadEntry\u0060、\u0060WorkloadGroup\u0060 和 \u0060ServiceEntry\u0060 等资源抽象，逐步实现了虚拟机和 pod 的统一管理。本文仅仅是针对单集群的情况，在实际的生产中使用还远远不够，我们还需要处理安全、多集群、多租户等诸多问题，欢迎关注 Tetrate 的旗舰产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 了解更多关于 Istio 应用在生产上的最佳实践。\n', '\/blog\/istio-vm-odysssey\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文将为你介绍 Istio 历史上对虚拟机负载的支持情况，尤其是 Istio 1.8 中引入的智能 DNS 代理及 WorkloadGroup 使得虚拟机与容器在资源抽象层面可以等同视之。我将为你展现一幅 Istio 支持虚拟机的波澜壮阔的奥德赛。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/istio-18-release/">Istio 1.8——用户至上的选择</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/11/20</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8——用户至上的选择', 'Istio 信守了年初的承诺，从 1.1 开始，几乎每三个月一个版本，更能体会用户的需求了。此次是 2020 年的最后一个版本，引入了 WorkloadGroup 和 DNS proxy，对如虚拟机的非 Kubernetes 负载的支持更进了一步。', '\n今天 [Istio 1.8](https:\/\/istio.io\/latest\/news\/releases\/1.8.x\/announcing-1.8\/) 发布了，这是 Istio 在 2020 年发布的最后一个版本，按照 Istio 社区在[今年初设定的目标](https:\/\/istio.io\/latest\/blog\/2020\/tradewinds-2020\/)继续推进，该版本主要有以下更新：\n\n- 支持使用 Helm 3 进行安装和升级\n- 正式移除了 Mixer\n- 新增了 Istio DNS proxy，透明地拦截应用程序的 DNS 查询，实现智能应答\n- 新增了 \u0060WorkloadGroup\u0060 以简化对虚拟机的引入\n\n\u0060WorkloadGroup \u0060是一个新的 API 对象，旨在与虚拟机等非 Kubernetes 工作负载一起使用，模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n## 安装与升级\n\nIstio 从 1.5 版本开始弃用了 Helm，使用 \u0060istioctl manifest\u0060 方式安装，后来又改成了 \u0060istioctl install\u0060，现在又重新回归了 Helm，Helm 作为 Kubernetes 环境下最常用的应用安装管理组件，此次回归也是倾听用户声音，优化安装体验的的反应吧，不过 Istio Operator 依然将是 Istio 安装的最终形式，从 1.8 版本开始 Istio 支持使用 [Helm](https:\/\/istio.io\/latest\/docs\/setup\/install\/helm\/) 进行 in-place 升级和 canary 升级。\n\n## 增强 Istio 的易用性\n\n\u0060istioctl\u0060 命令行工具新的了 bug reporting 功能（\u0060istioctl bug-report\u0060），可以用来收集调试信息和获取集群状态。\n\n[安装 add-on](https:\/\/istio.io\/latest\/blog\/2020\/addon-rework\/) 的方式变了，在 1.7 中已经不推荐使用 istioctl 来安装，在 1.8 中直接被移除了，这样有利于解决 add-on 落后于上游及难以维护的问题。\n\n正式移除了 Mixer，推荐使用 [WebAssembly](https:\/\/istio.io\/latest\/blog\/2020\/wasm-announce\/) 通过扩展 Envoy 的方式来扩展 Istio，也推荐大家使用 [GetEnvoy Toolkit](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 来进行 Envoy 的扩展开发。\n\n## 对虚拟机的支持\n\n在我[之前的博客](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)中谈到 Istio 1.7 如何支持虚拟机，在 Istio 1.8 中新增了[智能 DNS 代理](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)，它是由 Go 编写的 Istio sidecar 代理，sidecar 上的 Istio agent 将附带一个由 Istiod 动态编程的缓存 DNS 代理。来自应用程序的 DNS 查询会被 pod 或 VM 中的 Istio 代理透明地拦截和服务，该代理会智能地响应 DNS 查询请求，可以实现虚拟机到服务网格的无缝多集群访问。\n\n新增了 [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) ，它描述了工作负载实例的集合。提供了一个规范，工作负载实例可以用来引导它们的代理，包括元数据和身份。它只打算与虚拟机等非 Kubernetes 工作负载一起使用，旨在模仿现有的用于 Kubernetes 工作负载的 sidecar 注入和部署规范模型来引导 Istio 代理。\n\n在 [Tetrate](https:\/\/tetrate.io)，我们在客户的多集群部署中广泛使用这种机制，以使 sidecar 能够为暴露在网格中所有集群的入口网关的主机解析 DNS，并通过 mTLS 访问。\n\n## 总结\n\n总而言之，Istio 团队履行了[年初的承诺](https:\/\/istio.io\/latest\/blog\/2020\/tradewinds-2020\/)，自 2018 年发布 1.1 版本发布起，保持了固定的发布节奏，每 3 个月发布一个版本，在性能、用户体验上持续优化，以满足 brownfiled 应用与 greenfield 应用在 Istio 上的无缝体验。我们期待 Istio 在 2021 年可以给我们带来更多惊喜。\n\n最后，感谢[马若飞](https:\/\/github.com\/malphi)对本文的审阅。', '\/blog\/istio-18-release\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Istio 信守了年初的承诺，从 1.1 开始，几乎每三个月一个版本，更能体会用户的需求了。此次是 2020 年的最后一个版本，引入了 WorkloadGroup 和 DNS proxy，对如虚拟机的非 Kubernetes 负载的支持更进了一步。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/">如何在 Istio Service Mesh 中集成虚拟机？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/11/02</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('如何在 Istio Service Mesh 中集成虚拟机？', '将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 Tetrate Service Bridge 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。', '\nIstio 是目前最流行的服务网格，用于连接、保护、控制和观察服务。当其 2017 年开源时，Kubernetes 已赢得容器编排之战，Istio 为了满足组织转向微服务的需求。虽然 Istio 声称支持异构环境，如 Nomad、Consul、Eureka、Cloud Foundry、Mesos 等，但实际上，它一直与 Kubernetes 合作得最好–它的服务发现就是基于 Kubernetes。\n\nIstio 在发展初期就因为一些问题而饱受诟病，比如组件数量多、安装和维护复杂、调试困难、由于引入了太多的新概念和对象（多达 50 个 CRD）而导致学习曲线陡峭，以及 Mixer 组件对性能的影响。但这些问题正在被 Istio 团队逐渐克服。从 2020 年初发布的[路线图](https:\/\/istio.io\/latest\/zh\/blog\/2020\/tradewinds-2020\/)中可以看出，Istio 已经取得了长足的进步。\n\n将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。\n\n## Istio 为什么要支持虚拟机？\n\n虽然现在容器和 Kubernetes 已经被广泛使用，但仍然有很多部署在虚拟机上的服务和 Kubernetes 集群之外的 API 需要由 Istio mesh 来管理。如何将棕地环境与绿地环境统一管理，这是一个巨大的挑战。\n\n## 将虚拟机引入到网格中需要具备什么条件？\n\n在介绍如何集成虚拟机之前，我先介绍一下将虚拟机添加到 Mesh 中需要什么条件。在支持虚拟机流量时，Istio 必须知道几件事：哪些虚拟机的服务要添加到 Mesh 中，以及如何访问虚拟机。每个虚拟机还需要一个身份，以便与服务网格的其他部分安全地通信。这些需求可以和 Kubernetes CRD 一起工作，也可以和 Consul 这样的完整的服务注册表一起工作。而基于服务账户的身份引导机制，为没有平台身份的虚拟机分配工作负载身份。对于有平台身份的虚拟机（如 EC2、GCP、Azure 等），Istio 正在进行这方面的工作，将平台身份与 Kubernetes 身份进行交换，方便设置 mTLS 通信。\n\n## Istio 如何支持虚拟机？\n\nIstio 对虚拟机的支持始于其服务注册表机制。Istio mesh 中的服务和实例信息来自 Istio 的服务注册表，到目前为止，Istio 的服务注册表只关注或跟踪 pod。在新的版本中，Istio 现在有资源类型来跟踪和观察虚拟机。网格内的 sidecar 无法观察和控制网格外服务的流量，因为它们没有任何信息。\n\nIstio 社区和 [Tetrate](https:\/\/www.tetrate.io\/) 在 Istio 对虚拟机的支持上做了[很多工作](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/)。1.6 版本中增加了 WorkloadEntry，它允许你像描述 Kubernetes 中运行的主机一样描述虚拟机。在 1.7 版本中，该版本开始增加了通过令牌将虚拟机自动引导到 service mesh 中的基础，Istio 做了大量的工作。Istio 1.8 将首次推出另一个名为 WorkloadGroup 的抽象，它类似于 Kubernetes Deployment 对象 —— 但适用于虚拟机。\n\n下图显示了 Istio 如何在网格中对服务进行建模。最主要的信息来源来自于 Kubernetes 这样的平台服务注册表，或者 Consul 这样的系统。此外，ServiceEntry 作为用户定义的服务注册表，对虚拟机上的服务或组织外部的服务进行建模。\n\n![Istio 中的服务注册发现模型](0081Kckwly1gkc4ldbqzhj30p30ehwf5.jpg)\n\n**为什么不直接使用 ServiceEntry 引入虚拟机中的服务，却还要大费周折在虚拟机中安装 Istio？**\n\n使用 ServiceEntry，你可以让网格内部的服务发现和访问外部服务；此外，还可以管理这些外部服务的流量。结合 VirtualService，你还可以为相应的外部服务配置访问规则，比如请求超时、故障注入等，从而实现对指定外部服务的控制访问。即便如此，它也只能控制客户端的流量，而不能控制引入的外部服务对其他服务的访问。也就是说，它不能控制作为调用发起者的服务的行为。在虚拟机中部署 sidecar，通过工作负载选择器引入虚拟机工作负载，可以像 Kubernetes 中的 pod 一样，对虚拟机进行无差别管理。\n\n## Demo\n\n在下面这个 demo 中我们将使在 GKE 中部署 Istio 并运行 bookinfo 示例，其中 ratings 服务的后端使用的是部署在虚拟机上的 MySQL，该示例可以在 Istio 官方文档中找到，我作出了部分改动，最终的流量路由如下图所示。\n\n![Bookinfo 示例中的流量示意图](0081Kckwly1gkc4lch5epj318g0avwfx.jpg)\n\n### 安装流程\n\n下面是示例的安装步骤：\n\n1. 在 Google Cloud 中部署 Kubernetes 集群，Kubernetes 版本是 1.16.13；\n2. 在 GKE 中安装 Istio 1.7.1；\n3. 在 Google Cloud 中启动一台虚拟机并配置 Istio，将其加入到 Istio Mesh 中，这一步需要很多手动操作，生成证书、创建 token、配置 hosts 等；\n4. 在 Istio Mesh 中部署 bookinfo 示例；\n5. 在虚拟机中安装 MySQL；\n6. 为虚拟机设置 VPC 防火箱规则；\n7. 将虚拟机中的 MySQL 服务作为 ServiceEntry 引入到 Mesh 中并作为 rating 服务的后端；\n8. 修改 MySQL 表中的数据，验证 bookinfo 中的 rating 相应的行为符合预期；\n\n## 未来方向\n\n从 bookinfo 的演示中可以看出，在这个过程中涉及到的人工工作太多，很容易出错。在未来，Istio 会改进虚拟机测试的可操作性，根据平台身份自动引导，改进 DNS 支持和 istioctl 调试等。大家可以关注 [Istio 环境工作组](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md)，了解更多关于虚拟机支持的细节。\n\n## 参考阅读\n\n- [Virtual Machine Installation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- Virtual Machines in Single-Network Meshes\n- [Istio: Bringing VMs into the Mesh (with Cynthia Coan)](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/)\n- [Bridging Traditional and Modern Workloads](https:\/\/www.tetrate.io\/blog\/bridging-traditional-and-modern-workloads\/)\n\n', '\/blog\/how-to-integrate-virtual-machines-into-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">将基于虚拟机的工作负载更好地集成到服务网格中，是 Istio 团队今年的一大重点。Tetrate 还通过其产品 Tetrate Service Bridge 提供了无缝的多云连接、安全性和可观测性，包括针对虚拟机的。本文将带您了解为什么 Istio 需要与虚拟机整合，以及如何整合。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-the-microservices-in-post-kubernetes-era/">Service Mesh——后 Kubernetes 时代的微服务</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2020/04/01</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh——后 Kubernetes 时代的微服务', '本文是以前所写内容的重新修订并收录于 ServiceMesher 社区的 Istio Handbook 中，其他章节仍在编纂中。', '\n如果你刚听说 Service Mesh 不久，并试用过 [Istio](https:\/\/istio.io) 的话，那么你可能都会有下面几个疑问：\n\n1. 为什么 Istio 要运行在 Kubernetes 上呢？\n1. Kubernetes 和 Service Mesh 分别在云原生中扮演什么角色？\n1. Istio 扩展了 Kubernetes 的哪些方面？解决了哪些问题？\n1. Kubernetes、xDS 协议（[Envoy](https:\/\/github.com\/envoyproxy\/envoy)、[MOSN](https:\/\/github.com\/mosn\/mosn) 等）与 Istio 之间又是什么关系？\n1. 到底该不该上 Service Mesh？\n\n这一节我们将试图带您梳理清楚 Kubernetes、xDS 协议以及 Istio Service Mesh 之间的内在联系。此外，本节还将介绍 Kubernetes 中的负载均衡方式，xDS 协议对于 Service Mesh 的意义以及为什么说及时有了 Kubernetes 还需要 Istio。\n\n使用 Service Mesh 并不是说与 Kubernetes 决裂，而是水到渠成的事情。Kubernetes 的本质是通过声明式配置对应用进行生命周期管理，而 Service Mesh 的本质是提供应用间的流量和安全性管理以及可观测性。假如你已经使用 Kubernetes 构建了稳定的应用平台，那么如何设置服务间调用的负载均衡和流量控制？\n\nEnvoy 创造的 xDS 协议被众多开源软件所支持，如 [Istio](https:\/\/github.com\/istio\/istio)、[MOSN](https:\/github.com\/mosn\/mosn) 等。Envoy 对于 Service Mesh 或云原生来说最大的贡献就是定义了 xDS，Envoy 本质上是一个 proxy，是可通过 API 配置的现代版 proxy，基于它衍生出来很多不同的使用场景，如 API Gateway、Service Mesh 中的 Sidecar proxy 和边缘代理。\n\n**本节包含以下内容**\n\n- 说明 kube-proxy 的作用。\n- Kubernetes 在微服务管理上的局限性。\n- 介绍 Istio Service Mesh 的功能。\n- 介绍 xDS 包含哪些内容。\n- 比较 Kubernetes、Envoy 和 Istio Service Mesh 中的一些概念。\n\n## 重要观点\n\n如果你想要提前了解下文的所有内容，那么可以先阅读下面列出的本文中的一些主要观点：\n\n- Kubernetes 的本质是应用的生命周期管理，具体来说就是部署和管理（扩缩容、自动恢复、发布）。\n- Kubernetes 为微服务提供了可扩展、高弹性的部署和管理平台。\n- Service Mesh 的基础是透明代理，通过 sidecar proxy 拦截到微服务间流量后再通过控制平面配置管理微服务的行为。\n- Service Mesh 将流量管理从 Kubernetes 中解耦，Service Mesh 内部的流量无需 \u0060kube-proxy\u0060 组件的支持，通过为更接近微服务应用层的抽象，管理服务间的流量、安全性和可观测性。\n- xDS 定义了 Service Mesh 配置的协议标准。\n- Service Mesh 是对 Kubernetes 中的 service 更上层的抽象，它的下一步是 serverless。\n\n## Kubernetes vs Service Mesh\n\n下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系（每个 pod 一个 sidecar 的模式）。\n\n![kubernetes 对比 service mesh](kubernetes-vs-service-mesh.png)\n\n**流量转发**\n\nKubernetes 集群的每个节点都部署了一个 \u0060kube-proxy\u0060 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 [service](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html) 信息，然后设置 iptables 规则，直接将对某个 service 的请求发送到对应的 Endpoint（属于同一组 service 的 pod）上。\n\n**服务发现**\n\n![Service Mesh 中的服务注册](istio-service-registry.png)\n\nIstio 可以沿用 Kubernetes 中的 service 做服务注册，还可以通过控制平面的平台适配器对接其他服务发现系统，然后生成数据平面的配置（使用 CRD 声明，保存在 etcd 中），数据平面的**透明代理**（transparent proxy）以 sidecar 容器的形式部署在每个应用服务的 pod 中，这些 proxy 都需要请求控制平面来同步代理配置。之所以说是透明代理，是因为应用程序容器完全无感知代理的存在，该过程 kube-proxy 组件一样需要拦截流量，只不过 \u0060kube-proxy\u0060 拦截的是进出 Kubernetes 节点的流量，而 sidecar proxy 拦截的是进出该 Pod 的流量，详见[理解 Istio Service Mesh 中 Envoy Sidecar 代理的路由转发](https:\/\/jimmysong.io\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/)。\n\n**Service Mesh 的劣势**\n\n因为 Kubernetes 每个节点上都会运行众多的 Pod，将原先 \u0060kube-proxy\u0060 方式的路由转发功能置于每个 pod 中，因为有 sidecar 拦截流量会多一次跳转时，增加响应延迟，同时大量的配置分发、配置同步，可能会影响应用性能。为了细粒度地进行流量管理，必将添加一系列新的抽象，从而会进一步增加用户的学习成本，但随着技术的普及，这样的情况会慢慢地得到缓解。\n\n**Service Mesh 的优势**\n\n\u0060kube-proxy\u0060 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 Service Mesh 通过 sidecar proxy 的方式将 Kubernetes 中对流量的控制从 service 一层抽离出来，可以做更多的扩展。\n\n## kube-proxy 组件\n\n在 Kubernetes 集群中，每个 Node 运行一个 \u0060kube-proxy\u0060 进程。\u0060kube-proxy\u0060 负责为 \u0060Service\u0060 实现了一种 VIP（虚拟 IP）的形式。在 Kubernetes v1.0 版本，代理完全在 userspace 实现。Kubernetes v1.1 版本新增了 [iptables 代理模式](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html#iptables-代理模式)，但并不是默认的运行模式。从 Kubernetes v1.2 起，默认使用 iptables 代理。在 Kubernetes v1.8.0-beta.0 中，添加了 [ipvs 代理模式](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/service.html#ipvs-代理模式)。关于 kube-proxy 组件的更多介绍请参考 [kubernetes 简介：service 和 kube-proxy 原理](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/) 和 [使用 IPVS 实现 Kubernetes 入口流量负载均衡](https:\/\/jishu.io\/kubernetes\/ipvs-loadbalancer-for-kubernetes\/)。\n\n### kube-proxy 的缺陷\n\n[kube-proxy 的不足之处](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/)：\n\n首先，如果转发的 pod 不能正常提供服务，它不会自动尝试另一个 pod，每个 pod 都有一个健康检查的机制，当有 pod 健康状况有问题时，kubelet 会重启对应的 pod，kube-proxy 会删除对应的转发规则。另外，\u0060nodePort\u0060 类型的服务也无法添加 TLS 或者更复杂的报文路由机制。\n\nKube-proxy 实现了流量在 Kubernetes service 多个 pod 实例间的负载均衡，但是如何对这些 service 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 service，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 [使用 Deployment 做金丝雀发布的方法](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments)，该方法本质上就是通过修改 pod 的 [label](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/label.html) 来将不同的 pod 划归到 Deployment 的 Service 上。\n\n## Kubernetes Ingress vs Istio Gateway\n\n上文说到 \u0060kube-proxy\u0060 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 Pod 位于 [CNI](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/cni.html) 创建的网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 [ingress](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/ingress.html) 这个资源对象，它由位于 Kubernetes [边缘节点](https:\/\/jimmysong.io\/kubernetes-handbook\/practice\/edge-node-configuration.html)（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理**南北向流量**，Ingress 必须对接各种 Ingress Controller 才能使用，比如 [nginx ingress controller](https:\/\/github.com\/kubernetes\/ingress-nginx)、[traefik](https:\/\/traefik.io\/)。Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 service、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。要想直接路由南北向的流量，只能使用 Service 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 Service 来暴露，Ingress 本身是不支持的，例如 [nginx ingress controller](https:\/\/kubernetes.github.io\/ingress-nginx\/user-guide\/exposing-tcp-udp-services\/)，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。\n\nIstio Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。Istio \u0060Gateway\u0060 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 [CRD 扩展](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/crd.html)，它同时复用了 sidecar proxy 的能力，详细配置请参考 [Istio 官网](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/)。\n\n## xDS 协议\n\n下面这张图大家在了解 Service Mesh 的时候可能都看到过，每个方块代表一个服务的实例，例如 Kubernetes 中的一个 Pod（其中包含了 sidecar proxy），xDS 协议控制了 Istio Service Mesh 中所有流量的具体行为，即将下图中的方块链接到了一起。\n\n![Service Mesh 示意图](service-mesh-schematic-diagram.png)\n\nxDS 协议是由 [Envoy](https:\/\/envoyproxy.io\/) 提出的，在 Envoy v2 版本 API 中最原始的 xDS 协议指的是 CDS（Cluster Discovery Service）、EDS（Endpoint Discovery service）、LDS（Listener Discovery Service）和 RDS（Route Discovery Service），后来在 v3 版本中又发展出了 Scoped Route Discovery Service（SRDS）、Virtual Host Discovery Service（VHDS）、Secret Discovery Service（SDS）、Runtime Discovery Service（RTDS）等，详见 [xDS REST and gRPC protocol](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)。\n\n下面我们以各有两个实例的 service，来看下 xDS 协议。\n\n![xDS 协议](xds-protocol.png)\n\n上图中的箭头不是流量进入 Proxy 后的路径或路由，也不是实际顺序，而是想象的一种 xDS 接口处理顺序，其实 xDS 之间也是有交叉引用的。\n\n支持 xDS 协议的代理通过查询文件或管理服务器来动态发现资源。概括地讲，对应的发现服务及其相应的 API 被称作 *xDS*。Envoy 通过 **订阅（subscription）** 的方式来获取资源，订阅方式有以下三种：\n\n- **文件订阅**：监控指定路径下的文件，发现动态资源的最简单方式就是将其保存于文件，并将路径配置在 ConfigSource 中的 \u0060path\u0060 参数中。\n- **gRPC 流式订阅**：每个 xDS API 可以单独配置 \u0060ApiConfigSource\u0060，指向对应的上游管理服务器的集群地址。\n- **轮询 REST-JSON 轮询订阅**：单个 xDS API 可对 REST 端点进行的同步（长）轮询。\n\n以上的 xDS 订阅方式详情请参考 [xDS 协议解析](https:\/\/jimmysong.io\/istio-handbook\/concepts\/envoy-xds-protocol.html)。Istio 使用 gRPC 流式订阅的方式配置所有的数据平面的 sidecar proxy。\n\n### xDS 协议要点\n\n最后总结下关于 xDS 协议的要点：\n\n- CDS、EDS、LDS、RDS 是最基础的 xDS 协议，它们可以分别独立更新。\n- 所有的发现服务（Discovery Service）可以连接不同的 Management Server，也就是说管理 xDS 的服务器可以是多个。\n- Envoy 在原始 xDS 协议的基础上进行了一些列扩充，增加了 SDS（秘钥发现服务）、ADS（聚合发现服务）、HDS（健康发现服务）、MS（Metric 服务）、RLS（速率限制服务）等 API。\n- 为了保证数据一致性，若直接使用 xDS 原始 API 的话，需要保证这样的顺序更新：CDS --\u003e EDS --\u003e LDS --\u003e RDS，这是遵循电子工程中的**先合后断**（Make-Before-Break）原则，即在断开原来的连接之前先建立好新的连接，应用在路由里就是为了防止设置了新的路由规则的时候却无法发现上游集群而导致流量被丢弃的情况，类似于电路里的断路。\n- CDS 设置 Service Mesh 中有哪些服务。\n- EDS 设置哪些实例（Endpoint）属于这些服务（Cluster）。\n- LDS 设置实例上监听的端口以配置路由。\n- RDS 最终服务间的路由关系，应该保证最后更新 RDS。\n\n## Envoy\n\nEnvoy 是 Istio Service Mesh 中默认的 Sidecar，Istio 在 Envoy 的基础上按照 Envoy 的 xDS 协议扩展了其控制平面，在讲到 Envoy xDS 协议之前我们还需要先熟悉下 Envoy 的基本术语。下面列举了 Envoy 里的基本术语及其数据结构解析，关于 Envoy 的详细介绍请参考 [Envoy 官方文档](https:\/\/cloudnative.to\/envoy\/)，至于 Envoy 在 Service Mesh（不仅限于 Istio）中是如何作为转发代理工作的请参考网易云刘超的这篇[深入解读 Service Mesh 背后的技术细节 ](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)以及[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，本文引用其中的一些观点，详细内容不再赘述。\n\n![Envoy proxy 架构图](envoy-arch.jpg)\n\n### 基本术语\n\n下面是您应该了解的 Envoy 里的基本术语：\n\n- **Downstream（下游）**：下游主机连接到 Envoy，发送请求并接收响应，即发送请求的主机。\n- **Upstream（上游）**：上游主机接收来自 Envoy 的连接和请求，并返回响应，即接受请求的主机。\n- **Listener（监听器）**：监听器是命名网地址（例如，端口、unix domain socket 等)，下游客户端可以连接这些监听器。Envoy 暴露一个或者多个监听器给下游主机连接。\n- **Cluster（集群）**：集群是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到集群的哪个成员。\n\nEnvoy 中可以设置多个 Listener，每个 Listener 中又可以设置 filter chain（过滤器链表），而且过滤器是可扩展的，这样就可以更方便我们操作流量的行为，例如设置加密、私有 RPC 等。\n\nxDS 协议是由 Envoy 提出的，现在是 Istio 中默认的 sidecar proxy，但只要实现 xDS 协议理论上都是可以作为 Istio 中的 sidecar proxy 的，例如蚂蚁集团开源的 [MOSN](https:\/\/github.com\/mosn\/mosn)。\n\n## Istio Service Mesh\n\n![Istio service mesh 架构图](istio-mesh-arch.png)\n\nIstio 是一个功能十分丰富的 Service Mesh，它包括如下功能：\n\n- 流量管理：这是 Istio 的最基本的功能。\n- 策略控制：通过 Mixer 组件和各种适配器来实现，实现访问控制系统、遥测捕获、配额管理和计费等。\n- 可观测性：在 sidecar proxy 中实现。\n- 安全认证：Citadel 组件做密钥和证书管理。\n\n### Istio 中的流量管理\n\nIstio 中定义了如下的 [CRD](https:\/\/jimmysong.io\/kubernetes-handbook\/concepts\/custom-resource.html) 来帮助用户进行流量管理：\n\n- **Gateway**：[Gateway](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) 描述了在网络边缘运行的负载均衡器，用于接收传入或传出的 HTTP \/ TCP 连接。\n- **VirtualService**：[VirtualService](https:\/\/istio.io\/docs\/reference\/config\/networking\/virtual-service\/) 实际上将 Kubernetes 服务连接到 Istio Gateway。它还可以执行更多操作，例如定义一组流量路由规则，以便在主机被寻址时应用。\n- **DestinationRule**：[\u0060DestinationRule\u0060](https:\/\/istio.io\/zh\/docs\/reference\/config\/networking\/destination-rule\/) 所定义的策略，决定了经过路由处理之后的流量的访问策略。简单的说就是定义流量如何路由。这些策略中可以定义负载均衡配置、连接池尺寸以及外部检测（用于在负载均衡池中对不健康主机进行识别和驱逐）配置。\n- **EnvoyFilter**：[\u0060EnvoyFilter\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/envoy-filter\/) 对象描述了针对代理服务的过滤器，这些过滤器可以定制由 Istio Pilot 生成的代理配置。这个配置初级用户一般很少用到。\n- **ServiceEntry**：默认情况下 Istio Service Mesh 中的服务是无法发现 Mesh 外的服务的，[\u0060ServiceEntry\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/service-entry\/) 能够在 Istio 内部的服务注册表中加入额外的条目，从而让网格中自动发现的服务能够访问和路由到这些手工加入的服务。\n\n## Kubernetes vs xDS vs Istio\n\n在阅读完上文对 Kubernetes 的 \u0060kube-proxy\u0060 组件、xDS 和 Istio 中流量管理的抽象概念之后，下面将带您仅就流量管理方面比较下三者对应的组件\/协议（注意，三者不可以完全等同）。\n\n| Kubernetes | xDS      | Istio Service Mesh |\n| ---------- | -------- | ------------------ |\n| Endpoint   | Endpoint | WorkloadEntry      |\n| Service    | Route    | VirtualService     |\n| kube-proxy | Route    | DestinationRule    |\n| kube-proxy | Listener | EnvoyFilter        |\n| Ingress    | Listener | Gateway            |\n| Service    | Cluster  | ServiceEntry       |\n\n## 总结\n\n如果说 Kubernetes 管理的对象是 Pod，那么 Service Mesh 中管理的对象就是一个个 Service，所以说使用 Kubernetes 管理微服务后再应用 Service Mesh 就是水到渠成了，如果连 Service 你也不想管了，那就用如 [knative](https:\/\/github.com\/knative\/) 这样的 serverless 平台，但这就是后话了。\n\nEnvoy\/MOSN 的功能也不只是做流量转发，以上概念只不过是 Istio 在 Kubernetes 之上新增一层抽象层中的冰山一角，但因为流量管理是服务网格最基础也是最重要的功能，所以这将成为本书的开始。\n\n## 参考\n\n- [深入解读 Service Mesh 背后的技术细节 - cnblogs.com](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [kubernetes 简介：service 和 kube-proxy 原理 - cizixs.com](https:\/\/cizixs.com\/2017\/03\/30\/kubernetes-introduction-service-and-kube-proxy\/)\n- [使用 IPVS 实现 Kubernetes 入口流量负载均衡 - jishu.io](https:\/\/jishu.io\/kubernetes\/ipvs-loadbalancer-for-kubernetes\/)\n- [xDS REST and gRPC protocol](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n', '\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是以前所写内容的重新修订并收录于 ServiceMesher 社区的 Istio Handbook 中，其他章节仍在编纂中。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/cloud-native-service-mesh-istio-book/">云原生服务网格 Istio 图书</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/08/03</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('云原生服务网格 Istio 图书', '云原生服务网格 Istio（华为云原生技术丛书）图书读后感，原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）。', '\n[《云原生服务网格 Istio：原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）》](https:\/\/item.jd.com\/12538407.html)是 2019 年国内出版的第四本 Istio 相关图书，前三本分别是：\n\n- [深入浅出 Istio：Service Mesh 快速入门与实践，崔秀龙 著](https:\/\/item.jd.com\/12527008.html)\n- [Service Mesh 实战：用 Istio 软负载实现服务网格，周遥 著](https:\/\/item.jd.com\/12516473.html)\n- [Istio 入门与实战，毛广献 著](https:\/\/item.jd.com\/12601120.html)\n\n在这四本书刚上市时我都获得了作者的赠书，这本书是由四位华为的同学编写，于 2019 年  7 月第一次印刷，全书共 24 章，606 页，售价 139 元。我是在 KubeCon China 2019 的上海大会现场张超盟亲手赠与我的，张超盟也是 2018 年第三届 Service Mesh Meetup 的讲师。\n\n![右侧是云原生服务网格 Istio（华为云原生技术丛书）作者之一张超盟](006tNc79ly1g60ml3q3i4j30xc0m8wg2.jpg)\n\n## 本书结构\n\n全书共分四个篇章，24 个章节，606 页，每个章节的页数占比统计如下图所示。\n\n![云原生服务网格 Istio：原理、实践、架构与源码解析》图书章节页数占全书百分比 - 表格](006tNc79ly1g5nsbm4pkej30u00uj0vw.jpg)\n\n![《云原生服务网格 Istio：原理、实践、架构与源码解析》图书章节页数占全书百分比 - 饼图](006tNc79ly1g60mjr3lirj30v20u0q5g.jpg)\n\n从统计结果中可以看出书中第 3 章（非侵入的流量治理）、第 14 章（司令官 Pilot）一共占全书的页数百分比为 24%，几乎占了四分之一的篇幅。\n\n这本书是目前（2019 年 08 月 15 日）市面上能买到的最全的一本 Istio 相关的图书了，话说国外还一本 Istio 的书也出来，国内到现在都出了四本了，是不是有种墙外开花墙内香的感觉？\n\n建议大家结合 [Istio 官方文档](https:\/\/istio.io)一起来看这本书，Istio 版本更新虽然没有 Kubernetes 那么快，但是在本书发行一个多月后也要发布 1.2 版本了，欢迎大家加入 ServiceMesher 社区来学习 Istio！\n\n', '\/blog\/cloud-native-service-mesh-istio-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">云原生服务网格 Istio（华为云原生技术丛书）图书读后感，原理、实践、架构与源码解析（张超盟、章鑫、徐中虎、徐飞编著）。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/service-mesh-in-action-by-yangzhangxian-review/">《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('《Service Mesh 实战—基于 Linkerd 和 Kubernetes 的微服务实践》读后感', '顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。', '\n最近在回顾 Service Mesh 技术在 2018 年的发展，想再看看 Linkerd，正好**杨彰显**的这本《Service Mesh 实战——基于 Linkerd 和 Kubernetes 的微服务实践》上市发售了，**机械工业出版社**的编辑送了我一本，🙏**杨福川**编辑，我看了下抽空写了点读后感，我看了下抽空写了点读后感，其实也说不上是读后感，就当是自己的一点感悟吧，就当拿此书借题发挥吧，这个知识爆炸的年代，技术发展如此迅速，可以说是 IT 人员的幸运，也是不幸！有多少写开源软件的书推出一版后能撑过三年的？如果软件红得发紫，持续迭代 N 个版本，例如 Kubernetes，最近两年以每三个月一个版本的速度迭代，之前的书早就跟不上节奏，要么就要不断推出新版，直到软件稳定后不再有大的改动。还有种可能就是软件推广和发展的不理想，无人问津，写这样软件的书就不会有再版了。\n\n拿到本书后我的第一反应就是看看这本书定稿的时候 Istio 是什么版本，Linkerd 又是什么版本。因为在这一年内两款开源软件都有较大的版本变动，如果书籍定稿的时候基于的软件版本太低，软件架构可能会有较大的变化，影响书中示例和部分章节的时效性。这也是大多技术书籍名短的症结所在，技术发展是在太快，传统的书籍出版流程往往过于繁琐和冗长，等到书籍出版后所介绍的软件都出了好几个版本。例如 Kubernetes 这种的软件，每三个月一个版本，而写一般书从策划到发行少说半年，一般也要一年的时间。\n\n## 关于书籍定稿时的软件版本\n\n**Istio 0.8**\n\n本书第一章「Service Mesh 简介」对 Service Mesh 相关开源产品介绍时提到本书定稿时 Istio 是 0.8 版本，而 Istio 在 2018 年 7 月 31 日发布了 1.0 版本。\n\n这本书定稿时，Istio 的最新版本是 0.8。\n\n**Linkerd 1.3.6**\n\n本书从序言开始一直到第二章结束也没有提及写作时基于的 Linkerd 版本，我在第二章的安装步骤中看到了说明。\n\n可以看到本书写作时是基于 Linkerd 1.3.6 版本，而 Linkerd 在同年的 9 月 18 日发布了 [2.0 GA](https:\/\/cloudnative.to\/blog\/linkerd-2-0-in-general-availability\/)，这一版本跟 1.x 版本相比有重大变化——它还将项目从集群范围的 service mesh 转换为可组合的 *service sidecar* ，旨在为开发人员和服务所有者提供在云原生环境中成功所需的关键工具。\n\n## Linkerd vs Envoy\n\nLinkerd 2.0 的 service sidecar 设计使开发人员和服务所有者能够在他们的服务上运行 Linkerd，提供自动可观测性、可靠性和运行时诊断，而无需更改配置或代码。通过提供轻量级的增量路径来获得平台范围的遥测、安全性和可靠性的传统 service mesh 功能，service sidecar 方法还降低了平台所有者和系统架构师的风险。该版本还用 Rust 重写了代理部分，在延迟，吞吐量和资源消耗方面产生了数量级的改进。\n\n而 Linkerd 1.x 继承自 Twitter 开源的 Finagle 高性能 RPC，所有想要深度学习 Linkerd 1.x 还需要了解 Finagle，这就跟 Istio 将 Envoy 作为默认的数据平面一样，要想深度学习 Istio 必须了解 Envoy。\n\n二者几乎使用了完全不同的术语，假如你已经了解了 [Envoy](https:\/\/envoyproxy.io) 想要再切换到 Linkerd 上，那么就要再费很多心力来学习它的概念和原理，例如如下这些术语或配置（Linkerd 中独有的配置）：\n\n- **dtab（委托表）**：由一系列路由组成，由一系列路由规则组成，以逻辑路径为输入，然后经过路由规则做一系列转换生成具体名字。这是 Linkerd 路由机制的根本，就像 Envoy 中的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)一样，本书的第四章「深入 Linkerd 数据访问流」专门讲解了 dtab 的实现机制。\n- **dentry（委托表记录）**：委托表的每条路由规则称为 dentry，如 \/consul =\u003e \/#\/io.l5d.consul\/dc1。\n- **namer**：配置 Linkerd 支持的服务发现工具。\n- **namerd**：Linkerd 的控制平面，相当于 Istio 中的 Pilot，对接各种服务发现。当然 Linkerd 也可以直接与某个服务发现平台对接如 consul，而不使用 namerd 这个集中路由和配置管理组件。\n- **interpreter**：interpreter 决定如何解析服务名字和客户端名字。\n\n虽然 Linkerd 也是 [CNCF 中的项目](https:\/\/www.cncf.io\/projects\/)，但它目前还处于孵化阶段，而 Envoy 的 [xDS 协议](https:\/\/jimmysong.io\/istio-handbook\/data-plane\/envoy-xds.html)已经被众多开源项目所支持，如 [Istio](https:\/\/istio.io\/zh)、[SOFAMesh](https:\/\/github.com\/alipay\/sofa-mesh)、[NginxMesh](https:\/\/github.com\/nginxinc\/nginmesh) 等，且 Envoy 已经从 CNCF 中毕业，以后可能成为 Service Mesh 领域的标准协议，Linkerd 的生存状况堪忧。\n\n## 关于本书\n\n本书中所有示例都提供了虚拟机的快速上手环境，只要使用 Vagrant 即可创建虚拟机和应用，所以在本书的[示例代码](https:\/\/github.com\/yangzhares\/linkerd-in-action)有大量的 Vagrantfile。\n\n本书第三部分「实战篇」花了大量篇幅（本书一半的页数）来讲解如何使用 Linkerd 和 Kubernetes 来管理微服务，可以参考我 2017 年 8 月 1 日写的这篇[微服务管理框架 service mesh——Linkerd 安装试用笔记](https:\/\/jimmysong.io\/posts\/linkerd-user-guide\/)，那时候还是基于 Linkerd 1.1.2，还有 [Linkerd 官方示例](https:\/\/github.com\/linkerd\/linkerd-examples\/)，这些示例基本都不怎么更新了。\n\n因为该书定稿时所基于的 Linkerd 版本距离本书发售时的 Linkerd 已经落后一个大版本（最新版本是 [Linkerd 2.1](https:\/\/blog.linkerd.io\/2018\/12\/06\/announcing-linkerd-2-1\/)），所以读者一定要注意这一点，老实说我只花了两个夜晚快速过了一下本书，无法对本书内容给出具体评论，所以本书是否是你所需要的就要你自己去思考了。\n\n', '\/blog\/service-mesh-in-action-by-yangzhangxian-review\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">顺便对比了下 Linkerd 和 Envoy，给读者一些我自己的建议。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/service-mesh/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/service-mesh/page/2/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/service-mesh/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/categories/service-mesh/page/4/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/service-mesh/page/4/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(69)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-configuration-safety-common-misconfigurations/">Istio 配置安全：如何避免错误配置</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
