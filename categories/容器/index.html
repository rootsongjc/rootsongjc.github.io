<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>容器专栏 · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="在容器专栏中，我将深入探讨容器技术及其在现代软件开发中的应用。容器化不仅改变了应用的部署方式，也极大地提高了开发效率和资源利用率。在这里，我会分享关于 Docker、容器编排以及相关工具的知识和实践。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f25e1ff9bcb6a5d029ef3c0c4c5c51aec8832388d6321236cc72e9dc323217d6.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f25e1ff9bcb6a5d029ef3c0c4c5c51aec8832388d6321236cc72e9dc323217d6.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/%E5%AE%B9%E5%99%A8/" />
  <meta property="og:title" content="容器专栏 | Jimmy Song" />
  <meta property="twitter:title" content="容器专栏 | Jimmy Song" />

  
  <meta property="og:description" content="在容器专栏中，我将深入探讨容器技术及其在现代软件开发中的应用。容器化不仅改变了应用的部署方式，也极大地提高了开发效率和资源利用率。在这里，我会分享关于 Docker、容器编排以及相关工具的知识和实践。" />
  <meta property="twitter:description" content="在容器专栏中，我将深入探讨容器技术及其在现代软件开发中的应用。容器化不仅改变了应用的部署方式，也极大地提高了开发效率和资源利用率。在这里，我会分享关于 Docker、容器编排以及相关工具的知识和实践。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    容器专栏
                </p>
                <p class="page-description">
                    在容器专栏中，我将深入探讨容器技术及其在现代软件开发中的应用。容器化不仅改变了应用的部署方式，也极大地提高了开发效率和资源利用率。在这里，我会分享关于 Docker、容器编排以及相关工具的知识和实践。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/docker-multi-platform-image-building/">Docker 多平台构建指南：构建 WebAssembly 镜像</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/04/25</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%b9%e5%99%a8"> 
             容器
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Docker 多平台构建指南：构建 WebAssembly 镜像', '本文介绍了 Docker buildx 的多平台构建指南，包括构建器、并行器、缓存管理器和输出器等组件，以及常用的 docker buildx 命令及其用法。同时还介绍了如何管理和维护 Docker buildx 的构建环境，以及构建 WebAssembly 镜像的一般步骤和注意事项。', '\nDocker 多平台构建是一种用于构建 Docker 镜像以在多种 CPU 架构和操作系统上运行的技术。它可以让用户在一个 Dockerfile 中定义一个通用的构建过程，然后使用 Docker CLI 命令将其构建为多个不同平台的镜像。这些镜像可以在不同的计算机、云平台和容器编排系统上运行，从而为用户提供更广泛的部署选项。\n\n在多平台构建中，用户需要使用 Docker Buildx 插件来构建镜像。Docker Buildx 可以构建并输出多个不同平台的镜像，包括 x86、ARM、IBM Power 等。用户可以使用该插件创建多种平台的构建环境，并使用这些环境构建镜像。\n\n需要注意的是，多平台构建需要在支持多平台的 Docker 主机上进行。在这种主机上，Docker 可以使用 QEMU 等模拟器来模拟其他平台的环境，从而实现构建多种平台的镜像。\n\n## 什么是 docker buildx? {#what-is-docker-buildx}\n\nDocker Buildx 是 Docker 的一个插件，它提供了一种简单、高效的方式来构建和打包 Docker 镜像。它能够在多个平台上构建和输出 Docker 镜像，包括 Linux、Windows、macOS 等，支持 CPU 架构和操作系统等多种参数的设置。\n\nDocker Buildx 在构建镜像时使用了 [BuildKit](https:\/\/docs.docker.com\/build\/buildkit\/)，这是 Docker 官方推出的一个基于 Go 语言实现的高性能构建引擎。BuildKit 提供了更快的构建速度、更小的镜像体积、更好的缓存管理等优势，也可以在 Docker Buildx 之外使用。\n\n使用 Docker Buildx，可以将不同平台上的 Docker 镜像构建合并到一个 manifest 中，使得用户只需要下载一个 manifest，就可以获取多个平台的镜像。这为跨平台开发和分发应用程序提供了很大的便利。\n\n## Docker buildx 实现多平台构建的原理 {#docker-buildx-principles}\n\nDocker [buildx](https:\/\/github.com\/docker\/buildx) 实现多平台镜像构建的原理是基于 Docker 的多架构支持。Docker 可以在一个主机上运行多个容器，每个容器运行在自己的隔离环境中，相互独立。而 Docker 镜像则是用于创建容器的基础文件系统。\n\n在 Docker 中，不同的 CPU 架构和操作系统可以使用不同的 base image（基础镜像）进行构建。而 Docker buildx 可以自动识别当前主机的架构和操作系统，并选择合适的 base image 进行构建。在构建过程中，Docker buildx 会使用 BuildKit 引擎进行构建，支持多平台的交叉编译和镜像打包。\n\n在构建完成后，Docker buildx 会将不同平台上的镜像打包成一个 manifest 文件，其中包含了所有平台的镜像信息。用户可以通过 Docker CLI 命令或者 Docker registry 接口来操作 manifest 文件，获取不同平台上的镜像。对于不支持多架构的 Docker 版本，可以通过安装 Docker CLI 的 experimental 版本来使用 Docker buildx。\n\nDocker buildx 利用了 Docker 的多架构支持和 BuildKit 引擎，实现了跨平台的 Docker 镜像构建和分发。\n\n## Docker BuildKit 引擎简介 {#docker-buildkit}\n\n[BuildKit](https:\/\/docs.docker.com\/build\/buildkit\/) 是 Docker 官方推出的一个高性能的构建引擎，它可以用于构建 Docker 镜像、构建应用程序以及执行其他构建任务。BuildKit 引擎采用了分布式的架构，可以并行地执行多个构建任务，提高构建效率。\n\nBuildKit 引擎的主要特点包括：\n\n1. 高性能：BuildKit 引擎采用了高效的缓存管理机制，能够快速地执行增量构建，减少构建时间。同时，它还能够自动优化构建过程，选择最佳的构建路径和策略，进一步提高构建性能。\n2. 多平台支持：BuildKit 引擎支持多种 CPU 架构和操作系统，能够在不同平台上构建和输出 Docker 镜像。在 Docker buildx 中，BuildKit 引擎可以自动识别当前主机的架构和操作系统，并选择合适的构建方案。\n3. 模块化设计：BuildKit 引擎采用了模块化的设计，可以根据需要动态加载和卸载不同的模块。这使得 BuildKit 引擎更加灵活和可扩展，可以支持各种不同的构建任务。\n4. 安全性：BuildKit 引擎采用了安全的构建方式，可以自动执行一系列的安全检查，确保构建过程中不会引入漏洞或其他安全问题。同时，BuildKit 引擎还支持签名和加密等安全功能，保护用户的构建数据和镜像。\n\n## Docker buildx 支持哪些平台？{#platforms}\n\nDocker buildx 支持的平台主要包括以下几种：\n\n1. Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。\n2. Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。\n3. macOS：支持 Intel、Apple M1 架构。\n\n除了以上平台外，Docker buildx 还支持构建和输出多种其他平台的 Docker 镜像，包括 FreeBSD、Solaris 等。用户可以通过指定对应的 \u0060platform\u0060 参数来构建和输出不同平台的 Docker 镜像，例如：\n\n\u0060\u0060\u0060bash\ndocker buildx build --platform linux\/amd64,linux\/arm64 .\n\u0060\u0060\u0060\n\n这个命令将会构建一个同时支持 x86_64 和 ARM64 架构的 Docker 镜像。用户也可以通过指定不同的 buildx 构建配置来支持更多的平台，例如使用 qemu-user-static 等模拟器来支持其他的 CPU 架构。总之，Docker buildx 的多平台支持非常强大，为跨平台开发和分发应用程序提供了便利。\n\n## Docker buildx 引擎的架构与组成 {#arch}\n\nDocker buildx 引擎的架构是一个分布式的构建系统，通过多阶段、多组件的设计，实现了高性能、多平台支持、安全性等优点，为 Docker 镜像构建和应用程序构建提供了强大的支持。它由以下几个主要组成部分组成：\n\n1. CLI：提供了命令行接口，用户可以通过命令行来执行构建任务、管理构建配置等操作。\n2. BuildKit 引擎：作为 Docker buildx 的构建引擎，它负责执行构建任务，生成 Docker 镜像等。BuildKit 引擎具有高性能、多平台支持、安全性等优点。\n3. 构建器（Builder）：构建器是一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。在 Docker buildx 中，可以配置多个构建器，以支持多个平台和多个构建环境。\n4. 并行器（Scheduler）：并行器是负责协调和管理多个构建器的组件，它可以自动选择最佳的构建器执行构建任务，并将任务分配给合适的构建器。并行器还可以执行构建任务的并行处理，提高构建效率。\n5. 缓存管理器（Cache Manager）：缓存管理器是负责管理构建过程中的缓存数据，可以快速执行增量构建，减少构建时间。在 Docker buildx 中，缓存管理器可以自动选择合适的缓存方案，包括本地缓存和远程缓存等。\n6. 输出器（Exporter）：输出器负责将构建生成的 Docker 镜像输出到指定的仓库或者本地文件系统中。在 Docker buildx 中，输出器可以自动识别当前平台和目标平台，选择合适的镜像格式和输出路径。\n\n## docker buildx 命令的使用{#command}\n\n使用 docker buildx 命令可以方便地进行 Docker 镜像的构建和输出。下面是一些常用的 docker buildx 命令及其用法：\n\n查看当前的 buildx 构建器列表\n\n\u0060\u0060\u0060bash\ndocker buildx ls\n\u0060\u0060\u0060\n\n创建新的 buildx 构建器\n\n\u0060\u0060\u0060bash\ndocker buildx create --name mybuilder\n\u0060\u0060\u0060\n\n切换到指定名称的 buildx 构建器\n\n\u0060\u0060\u0060bash\ndocker buildx use mybuilder\n\u0060\u0060\u0060\n\n设置 buildx 构建器的平台支持\n\n\u0060\u0060\u0060bash\ndocker buildx inspect --bootstrap\ndocker buildx inspect --platform\ndocker buildx build --platform linux\/amd64,linux\/arm64 .\n\u0060\u0060\u0060\n\n构建 Docker 镜像：\n\n\u0060\u0060\u0060bash\ndocker buildx build --tag myimage .\n\u0060\u0060\u0060\n\n输出 Docker 镜像到本地文件系统\n\n\u0060\u0060\u0060bash\ndocker buildx build --output=type=local,dest=.\/output .\n\u0060\u0060\u0060\n\n输出 Docker 镜像到 Docker Hub 或其他远程仓库\n\n\u0060\u0060\u0060bash\ndocker buildx build --tag myrepo\/myimage --push .\n\u0060\u0060\u0060\n\n删除指定名称的 buildx 构建器\n\n\u0060\u0060\u0060bash\ndocker buildx rm mybuilder\n\u0060\u0060\u0060\n\n除了以上命令外，docker buildx 还支持许多其他的参数和选项，例如设置构建缓存、并行处理、构建标签等。用户可以通过查看官方文档或者使用 --help 选项来了解更多详情。\n\n## 理解 buildx 构建器 {#builder}\n\n在 Docker 中，构建器（Builder）是指一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。Docker buildx 构建器是指使用 BuildKit 引擎的多平台构建器，可以通过 Docker CLI 命令进行管理和操作。在使用 Docker buildx 构建器时，用户可以配置多个构建器，以支持多个平台和多个构建环境。\n\n用户可以通过创建、切换、查看和删除构建器，来管理和维护 Docker buildx 的构建环境。构建器的主要作用是提供一个干净、独立的构建环境，避免构建过程中的依赖冲突和环境污染。此外，构建器还可以方便地进行版本管理和共享，以便多个用户或者团队协同构建 Docker 镜像。\n\nDocker buildx 构建器还支持多平台构建，用户可以在同一个构建器中设置多个平台，以便生成跨平台的 Docker 镜像。通过 Docker buildx 构建器，用户可以轻松实现 Docker 镜像的多平台构建，提高构建效率和应用程序的兼容性。\n\n## 为什么本地看不到 Docker buildx 构建的镜像？{#where-is-my-images}\n\n这通常是因为你当前使用的 Docker context 不支持编译出来的镜像架构。例如 [Orbstack](https:\/\/orbstack.dev\/)，虽然它支持编译跨平台的镜像，但是执行 \u0060docker buildx\u0060 构建出来的镜像不会直接保存在本地的 Docker 镜像仓库中，而是保存在构建器（Builder）的缓存中。这是因为 Docker buildx 采用了分层构建的方式，构建出的每一层镜像都可以被重用，以减少构建时间和磁盘空间的占用。\n\n你应该使用 \u0060docker context\u0060 命令切换会 Docker 默认的上下文环境再执行构建，这样构建出来的跨平台镜像就可以在本地看见了。\n\n## 如何将多平台镜像保存到本地？{#local-storage}\n\n要将 Docker buildx 构建的多平台镜像保存到本地，可以使用 \u0060--output\u0060 选项指定输出类型为 \u0060type=local\u0060，并指定输出目录，例如：\n\n\u0060\u0060\u0060bash\ndocker buildx build --platform linux\/amd64,linux\/arm64 --output type=local,dest=.\/output .\n\u0060\u0060\u0060\n\n上述命令将构建包含 \u0060linux\/amd64\u0060 和 \u0060linux\/arm64\u0060 两种平台的镜像，并将输出类型设置为本地（\u0060type=local\u0060），输出目录为 \u0060.\/output\u0060。\n\n构建完成后，输出目录中会生成多个子目录，每个子目录分别对应一个平台，其中包含该平台下的镜像文件。\n\n如果只想保存其中一个平台的镜像，可以在 \u0060--output\u0060 选项中指定要保存的平台，例如：\n\n\u0060\u0060\u0060bash\ndocker buildx build --platform linux\/amd64,linux\/arm64 --output type=local,dest=.\/output\/linux\/amd64 .\n\u0060\u0060\u0060\n\n上述命令将只保存 \u0060linux\/amd64\u0060 平台的镜像，输出到 \u0060.\/output\/linux\/amd64\u0060 目录中。\n\n需要注意的是，\u0060--output\u0060 选项只支持部分输出类型，如果要将镜像保存到其他类型的输出（例如 tar 包、OCI 存储、Docker registry 等），需要使用其他的输出插件和选项。具体细节可以参考 [Docker 官方文档](https:\/\/docs.docker.com\/build\/building\/multi-platform\/)。\n\n## 如何使用构建 Wasm 镜像？{#wasm}\n\nWebAssembly 是一种中间代码格式，需要使用编译器将源代码编译为 WebAssembly 格式的二进制文件，再将其打包成镜像。以下是构建 WebAssembly 镜像的一般步骤：\n\n1. 编写 WebAssembly 源代码，并使用编译器将其编译为 WebAssembly 格式的二进制文件。例如使用 Rust 编写代码，并使用 Cargo 编译出 \u0060.wasm\u0060 文件。\n\n2. 编写 Dockerfile 将 Wasm 二进制文件添加到空镜像中。例如：\n\n   \u0060\u0060\u0060Dockerfile\n   # syntax=docker\/dockerfile:1\n   FROM scratch\n   COPY .\/target\/wasm32-wasi\/debug\/hello-wasm.wasm \/hello.wasm\n   ENTRYPOINT [ \u0022hello.wasm\u0022 ]\n   \u0060\u0060\u0060\n\n3.   使用 \u0060docker buildx\u0060 命令构建镜像，例如 \u0060docker buildx build --platform wasi\/wasm32 -t jimmysong\/hello-wasm .\u0060  将在本地构建。若你想将该镜像同时同时推送到 Docker Hub，可以在命令中加上 \u0060--push\u0060标志。基于 WebAssembly 平台的镜像并上传到 Docker Hub。\n\n## 注意事项 {#notice}\n\n除了构建多平台镜像、导出和加载镜像外，还有一些 Docker buildx 命令的常用操作及注意事项，包括：\n\n1. \u0060-progress\u0060 选项：可以使用 \u0060-progress\u0060 选项指定构建过程的输出格式，包括 \u0060auto\u0060、\u0060plain\u0060、\u0060tty\u0060 三种格式。\n2. \u0060-no-cache\u0060 选项：可以使用 \u0060-no-cache\u0060 选项禁用构建过程中的缓存机制，强制重新构建镜像。\n3. \u0060-push\u0060 选项：可以使用 \u0060-push\u0060 选项将构建的镜像推送到 Docker registry 中。\n4. \u0060-tag\u0060 选项：可以使用 \u0060-tag\u0060 选项为构建的镜像指定标签。\n5. \u0060-file\u0060 选项：可以使用 \u0060-file\u0060 选项指定 Dockerfile 文件的路径。\n6. \u0060-build-arg\u0060 选项：可以使用 \u0060-build-arg\u0060 选项传递构建参数给 Dockerfile 中的指令。\n7. 构建上下文的注意事项：构建上下文指的是 Dockerfile 文件所在的目录，以及构建过程中需要用到的其他文件。在构建过程中需要尽量减少构建上下文的大小，避免构建过程中传输大量不必要的文件。可以使用 \u0060.dockerignore\u0060 文件排除不需要传输的文件。\n\n需要注意的是，Docker buildx 是一个比较新的命令，不同版本的 Docker Engine 可能会存在差异，因此在使用时需要注意查阅官方文档，并根据实际情况进行操作。\n', '\/blog\/docker-multi-platform-image-building\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Docker buildx 的多平台构建指南，包括构建器、并行器、缓存管理器和输出器等组件，以及常用的 docker buildx 命令及其用法。同时还介绍了如何管理和维护 Docker buildx 的构建环境，以及构建 WebAssembly 镜像的一般步骤和注意事项。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/why-docker-support-wasm/">为什么 Docker 要增加 WebAssembly 运行时？</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/04/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%b9%e5%99%a8"> 
             容器
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('为什么 Docker 要增加 WebAssembly 运行时？', '本文介绍了 Docker 为什么要增加对 WebAssembly 的支持，以及在 Docker 中运行 WebAssembly 应用的优势和方法。WebAssembly 应用相对于 Linux 镜像有更高的性能、可移植性和安全性，适用于边缘计算、云原生应用和微服务等场景。Docker 支持四种 WebAssembly 运行时，分别为 spin、spiderlightning、WasmEdge 和 wasmtime。', '\n在 [Docker 发展史：四个重大举措，影响深远！](\/blog\/docker-four-milestones\/) 这篇文章中我提到了 Docker 从一开始引领容器运行时，再到在容器编排这一维度上落后于 Kubernetes。为了在保住容器运行时的统治地位，Docker 公司提出了 OCI 并通过 [containerd-wasm-shim](https:\/\/github.com\/deislabs\/containerd-wasm-shims) 支持更多的 WebAssembly 运行时。\n\n为了解决 Docker 在安全、稳定性、性能及可移植性方面的局限性，Kubernetes 社区开发了具有不同实现和功能的其他容器运行时，并为其制定了容器运行时接口（CRI）规范。目前实现该规范的容器运行时有 containerd、cri-o。还有 katacontainers、gvisor 等未实现 CRI 但是可以通过添加虚拟化层在 Kubernetes 上运行的其他容器运行时。\n\n开放容器倡议 (OCI) 旨在定义容器镜像格式和运行时的行业标准，Docker 捐赠了其运行时 runc 作为该标准的第一个实现。最近，WASM 社区对 OCI 工具链表现出了兴趣，Docker 现在支持 WebAssembly 模块作为其工件之一。现在 Docker Hub 已经支持除了镜像以外的，Helm、Volume 和 WebAssembly 等常用工件。\n\n使用 Docker 构建包含 WebAssembly 模块的镜像，并保存在 Docker Hub 中。通过 [containerd-wasm-shim](https:\/\/github.com\/deislabs\/containerd-wasm-shims)，可以让它们在 Kubernetes 中运行，如下图所示。\n\n![在 Kubernetes 中运行 WebAssembly 模块](oci.svg)\n\nContainerd 是一种符合 CRI（Container Runtime Interface）规范的容器运行时，是由 Docker 公司开源并贡献给 CNCF 的。只要支持 CRI 规范的运行时都可以在 Kubernetes 中运行。\n\n关于以上提到的名词 containerd、CRI、OCI 等的关系介绍，可以参考 [Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了](https:\/\/zhuanlan.zhihu.com\/p\/490585683)\n\n## 在 Docker 中运行 WebAssembly 应用相对 Linux 镜像有什么优势？{#advantages}\n\n使用 Docker 运行 WebAssembly 应用相对运行 Linux 镜像有以下优势。\n\n**更高的性能**\n\nWebAssembly 应用的启动时间更短，因为它不需要启动整个操作系统，而 Linux 容器需要。WebAssembly 模块的冷启动时间比 Docker 容器快 100 倍。WebAssembly 模块的内存占用更小，因为它是一个二进制格式，可以高效地压缩代码和依赖，而 Docker 容器需要打包整个镜像。WebAssembly 模块的大小一般在 1MB 以内，而 Docker 镜像的大小可以达到 100 或 200 MB。\n\n**更高的可移植性**\n\nWebAssembly 应用是一个架构中立的格式，只要有相应的运行时，就可以在任何底层架构上运行，而不需要考虑不同架构之间的兼容性问题。Docker 容器需要针对不同的架构构建不同的镜像，可能会存在一些潜在的安全风险或漏洞。\n\n**更好的安全性和隔离性**\n\nWebAssembly 应用可以提供代码级别的安全性，防止恶意代码访问系统资源，具体来说：\n\n- WebAssembly 应用是运行在一个沙箱环境中的二进制字节码，不需要访问主机系统的资源，也不会受到主机系统的影响。Docker 容器虽然也是运行在一个隔离的环境中，但是仍然需要在主机系统上运行，可能会受到主机系统的攻击或干扰。\n- WebAssembly 应用是通过 WebAssembly System Interface (WASI) 来与外部交互的，WASI 是一种标准化的 API 集合，可以提供一些基本的系统功能，比如文件操作、网络访问、环境变量等。WASI 可以限制 WebAssembly 应用的权限和能力，防止它们做一些危险的操作。Docker 容器虽然也可以通过设置一些安全选项来限制容器的权限和能力，但是仍然需要依赖主机系统提供的功能和服务。\n- WebAssembly 应用是一个架构中立的格式，只要有相应的运行时，就可以在任何底层架构上运行，而不需要考虑不同架构之间的兼容性问题。Docker 容器需要针对不同的架构构建不同的镜像，可能会存在一些潜在的安全风险或漏洞。\n\n因为有以上优势，WebAssembly 在一些场景下比 Docker 容器更有优势，例如边缘计算、云原生应用和微服务。当然，WebAssembly 应用也有一些局限性，比如不支持多线程、垃圾回收和二进制打包等。因此，并不是所有的场景都适合使用 WebAssembly 应用。你可以根据你的具体需求和偏好来选择合适的技术方案。\n\n## 如何在 Docker 中运行 WebAssembly 应用？{#how-to-run-wasm-with-docker}\n\n在 Docker 中运行 WebAssembly 应用的方式与普通的 Linux 镜像没有太大的不同，只是在运行时需要指定下平台和运行时。下面的例子来自 [Docker 官方文档](https:\/\/docs.docker.com\/desktop\/wasm\/)，以在 Docker Desktop 中为例运行 WebAssembly 应用：\n\n\u0060\u0060\u0060bash\ndocker run -dp 8080:8080 --name=wasm-example --runtime=io.containerd.wasmedge.v1 --platform=wasi\/wasm32 michaelirwin244\/wasm-example\n\u0060\u0060\u0060\n\n其中：\n\n- \u0060--runtime=io.containerd.wasmedge.v1\u0060 指定使用 WasmEdge 运行时，替代默认的 Linux 容器运行时。\n- \u0060--platform=wasi\/wasm32\u0060 指定镜像的架构。通过利用 Wasm 架构，无需为不同的机器架构构建单独的镜像。Wasm 运行时负责将 Wasm 二进制文件转换为机器指令的最后一步。\n\n目前 Docker 支持四种 WebAssembly 运行时，分别为：\n\n| 运行时名称 | API 名称 | 开发者 | 基金会托管 |\n| --- | --- | --- | --- |\n| [spin](https:\/\/github.com\/fermyon\/spin) | \u0060io.containerd.spin.v1\u0060 | Fermyon | 无 |\n| [SpiderLightning](https:\/\/github.com\/deislabs\/spiderlightning) | \u0060io.containerd.slight.v1\u0060 | DeisLabs | 无 |\n| [WasmEdge](https:\/\/github.com\/WasmEdge\/WasmEdge) | \u0060io.containerd.wasmedge.v1\u0060 | SecondState | CNCF 沙箱项目 |\n| [Wasmtime](https:\/\/github.com\/bytecodealliance\/wasmtime) | \u0060io.containerd.wasmtime.v1\u0060 | Mozilla、Fastly、Intel、Red Hat 等公司 | 字节码联盟项目 |\n\n在命令行终端中输入以下命令可以查看 WebAssembly 应用的运行情况：\n\n\u0060\u0060\u0060bash\ncurl http:\/\/localhost:8080\/\n\u0060\u0060\u0060\n\n你将看到如下输出：\n\n\u0060\u0060\u0060bash\nHello world from Rust running with Wasm! Send POST data to \/echo to have it echoed back to you\n\u0060\u0060\u0060\n\n你还可以向\u0060\/echo\u0060端点发送 POST 测试请求：\n\n\u0060\u0060\u0060bash\ncurl localhost:8080\/echo -d \u0027{\u0022message\u0022:\u0022Hello\u0022}\u0027 -H \u0022Content-type: application\/json\u0022\n\u0060\u0060\u0060\n\n你将看到如下输出：\n\n\u0060\u0060\u0060json\n{\u0022message\u0022:\u0022hello\u0022}\n\u0060\u0060\u0060\n\n## 总结 {#summary}\n\n本文介绍了 Docker 为什么要增加对 WebAssembly 的支持，以及在 Docker 中运行 WebAssembly 应用的优势和方法。WebAssembly 应用相对于 Linux 镜像有更高的性能、可移植性和安全性，适用于边缘计算、云原生应用和微服务等场景。Docker 支持四种 WebAssembly 运行时，分别为 spin、spiderlightning、WasmEdge 和 wasmtime。在接下来的文章中我将介绍如何开发一个 WebAssembly 应用，敬请期待。\n\n## 参考 {#reference}\n\n- [Announcing Docker Hub OCI Artifacts Support](https:\/\/www.docker.com\/blog\/announcing-docker-hub-oci-artifacts-support\/)\n- [Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了](https:\/\/zhuanlan.zhihu.com\/p\/490585683)\n- [Build, Share, and Run WebAssembly Apps Using Docker](https:\/\/www.docker.com\/blog\/build-share-run-webassembly-apps-docker\/)\n- [Why Containers and WebAssembly Work Well Together](https:\/\/www.docker.com\/blog\/why-containers-and-webassembly-work-well-together\/)\n- [Docker \u002b WebAssembly: a quick intro](https:\/\/medium.com\/@guglielmino\/docker-webassembly-a-quick-intro-730c38e8390c)\n', '\/blog\/why-docker-support-wasm\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Docker 为什么要增加对 WebAssembly 的支持，以及在 Docker 中运行 WebAssembly 应用的优势和方法。WebAssembly 应用相对于 Linux 镜像有更高的性能、可移植性和安全性，适用于边缘计算、云原生应用和微服务等场景。Docker 支持四种 WebAssembly 运行时，分别为 spin、spiderlightning、WasmEdge 和 wasmtime。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/docker-four-milestones/">Docker 发展史：四个重大举措，影响深远！</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2023/04/06</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%b9%e5%99%a8"> 
             容器
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Docker 发展史：四个重大举措，影响深远！', '在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。', '\n在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。\n\n## 当我们在谈论 Docker 时我们在谈论什么？{#what-are-we-talking-about-docker}\n\n首先我们需要先确定 Docker 这个词的含义。当人们在谈论 Docker 时可能指的是：\n\n1. Docker 公司\n2. Docker 软件栈\n3. Docker 命令行工具\n4. Docker 容器运行时\n\n为什么同一个词会有这么多不同的意思呢？这都是有历史原因的。Docker 软件于 2013 年发布，起初定位为开发者工具。作为最早发布的容器工具，它迅速走红，并成为容器技术的代名词。但它最初只是在单机上运行，有太多耦合的接口设计。后来容器集群出现，才需要用到容器编排调度工具。因为 Kubernetes 具有丰富的功能和扩展性，Docker 公司推出的 Swarm 在这场容器编排大战中败下阵来。归根结底，Docker 面向开发者，而容器运行时则面向机器，只需要对应的接口即可，不需要那么丰富的管理工具。如今，Docker 仍然是最受开发者喜爱的容器工具之一，其 Docker Hub 是全球最大的镜像仓库。\n\n## 将 Docker 项目改名为 Moby {#rename-docker-to-moby}\n\n2017 年 4 月，Docker 公司将 Docker 项目重命名为 Moby，详见 [Introducing Moby Project: a new open-source project to advance the software containerization movement](https:\/\/www.docker.com\/blog\/introducing-the-moby-project\/)：\n\n- [Moby Project](https:\/\/github.com\/moby\/moby) 是 Docker 公司为了应对容器技术在各个领域和用例中普及的趋势而发起的一个开源项目。\n- Moby Project 是 Docker 公司作为一个开放的研发实验室，与整个生态系统合作，实验，开发新的组件，并协作构建容器技术的未来。\n- Moby Project 不是 Docker 产品的替代品，而是 Docker 产品的基础。\n- Moby Project 包括三个层次：组件层，框架层和装配层。\n    - 组件层包括一些可复用的开源组件，如 runc, containerd, LinuxKit, InfraKit 等，可以用于构建各种类型的容器系统。\n    - 框架层提供了一些工具和库，用于将组件组装成系统，并管理其生命周期。\n    - 装配层是一个社区驱动的平台，用于分享和协作构建基于 Moby 框架的系统。\n\nMoby Project 是一个新的开源项目，旨在推动软件容器化运动的发展，帮助生态系统让容器技术走向主流。它提供了一个组件库，一个用于将组件组装成定制的基于容器的系统的框架，以及一个让所有容器爱好者可以实验和交流想法的地方。\n\nMoby Project 和 Docker 的区别和联系是：\n\n- Moby Project 是一个开源项目，Docker 是一个商业产品。\n- Moby Project 是 Docker 产品的基础，Docker 产品是 Moby Project 的一个实例。\n- Moby Project 是一个通用的框架，可以用于构建各种类型和用例的容器系统，Docker 是一个针对特定用例的容器系统，即构建，运行和共享应用程序。\n- Moby Project 是一个开放的研发实验室，用于实验和协作开发新的容器技术，Docker 是一个成熟的产品，用于提供稳定和可靠的容器服务。\n\n## 支持 Kubernetes 调度 {#support-kubernetes}\n\nDocker 公司在 2017 年 12 月发布的 Docker 17.12 版本中开始支持 Kubernetes。在此之前，Docker 公司一直在发展自己的容器编排和调度工具 Docker Swarm。然而，Kubernetes 在容器编排和调度方面具有更广泛的支持和社区贡献，已经成为了业界标准。因此，Docker 公司决定将 Kubernetes 集成到 Docker 平台中，以提供更广泛的选择和更好的用户体验。Docker 公司在 Docker Desktop 和 Docker Enterprise 中提供了 Kubernetes 的集成支持，使得 Kubernetes 和 Docker 容器可以更加方便地部署和管理。同时，Docker 公司也开发了一些工具，如 Kompose 和 Docker Compose，使得用户可以将 Docker Compose 配置文件转换为 Kubernetes YAML 文件，以便更加方便地将应用程序从 Docker Swarm 迁移到 Kubernetes。\n\n## Kubernetes 不再支持 Docker 运行时 {#kubernetes-not-support-docker}\n\nKubernetes 从 v1.20 起不再支持 Docker 运行时并在 2022 年 4 月发布的 v1.24 中被完全移除，如下图所示。这意味着在 Kubernetes 中只能使用 containerd 或 CRI-O 容器运行时，不过你依然可以使用 Docker 镜像，只是无需使用 docker 命令或 Docker 守护程序。\n\n![Kubernetes v1.24 正式移除 Docker 运行时](cri.svg)\n\nKubernetes v1.24 正式移除 Docker 运行时\n\n## 腾退开源组织账号 {#deprecate-open-source-organization}\n\n2023 年 3 月，据 [Alex Ellis 的博客](https:\/\/blog.alexellis.io\/docker-is-deleting-open-source-images\/) 介绍，Docker 公司决定删除一些开源组织的账户和镜像，除非他们升级到付费的团队计划，这对开源社区造成了很大的困扰和不安。很多 Docker 忠实拥护者和贡献者对 Docker 的这一举动表示了不满和失望。\n\n这一事件是这样的：\n\n- Docker 公司给所有创建过组织的 Docker Hub 用户发了一封邮件，告知他们如果不升级到付费的团队计划，他们的账户和镜像都将被删除。\n- 这一举动只影响开源社区经常使用的组织账户，个人账户没有变化。\n- 付费的团队计划每年需要 420 美元，很多开源项目没有足够的资金支持。\n- Docker 公司的开源项目计划（DSOS）要求非常苛刻，与开源项目的可持续性相悖。\n- Docker 公司的沟通方式非常脱节，引起了开源社区的反感和担忧。\n- 文章作者建议开源项目使用其他的容器镜像仓库，如 GitHub Container Registry、[Quay.io](http:\/\/quay.io\/)、各大云厂商的镜像仓库等。\n- 开源社区还提供了一些迁移镜像和重命名镜像的方法和工具。\n\n## 增加对 WebAssembly 运行时的支持 {#support-webassembly-runtime}\n\n2022 年 10 月，Docker 公司发布了 Docker\u002bWasm 技术预览，这是一个特殊的构建，可以让开发者更容易地使用 Docker 运行 Wasm 工作负载。作为这次发布的一部分，Docker 还宣布将加入 Bytecode Alliance 作为一个投票成员。\n\nWasm 是一种新技术，可让你在沙箱环境中运行 40 多种语言的应用程序代码，包括 Rust，C，C\u002b\u002b，JavaScript 和 Golang。最初，Wasm 的用例是在浏览器中运行本地代码，如 Figma，AutoCAD 和 Photoshop 等。现在，一些公司如 Vercel，Fastly，Shopify 和 Cloudflare 等支持使用 Wasm 在边缘和云端运行代码。\n\nDocker\u002bWasm 技术预览包括：\n\n- Docker 的目标是帮助开发者通过克服应用开发的复杂性来实现他们的想法。\n- Docker 将 Wasm 视为与 Linux 容器相辅相成的技术，开发者可以根据用例选择使用哪种技术（或两者都用）。\n- Docker 想要帮助开发者更容易地使用熟悉的经验和工具来开发，构建和运行 Wasm 应用。\n- 要获取技术预览，需要下载并安装适合你系统的版本，然后启用 containerd 镜像存储（设置 \u003e 开发中的功能 \u003e 使用 containerd 拉取和存储镜像）。\n- 这个预览支持使用 WasmEdge 运行时引擎运行 Wasm 容器，并可以通过容器仓库如 DockerHub 等分享。\n\n2023 年 3 月 Docker 公司又发布了 Docker\u002bWasm 技术预览 2，包括了三个新的 Wasm 运行时引擎：Fermyon 的 spin，Deislabs 的 slight，和 Bytecode Alliance 的 wasmtime。\n\n该版本的主要更新是：\n\n- Docker\u002bWasm 技术预览 2 是在 Docker Desktop 4.15 版本中发布的，旨在让开发者更容易地运行 Wasm 工作负载，并扩展运行时支持。\n- Docker\u002bWasm 技术预览 2 支持四种 Wasm 运行时引擎，包括之前已经支持的 WasmEdge，以及新增加的 spin，slight，和 wasmtime。\n- 这四种 Wasm 运行时引擎都基于 runwasi 库，这是一个 Rust 库，可以让容器管理器 containerd 运行 Wasm 工作负载，并创建一种新的容器类型。\n- runwasi 库基于 WASI 标准，这是一个为 WebAssembly 提供通用平台接口的模块化系统接口。这意味着如果一个程序编译成目标是 WASI，它就可以在任何符合 WASI 的运行时上运行。\n- Wasm 容器通常只包含一个编译好的 Wasm 字节码文件，不需要任何额外的二进制库，这使得它比 Linux 容器更小。这也意味着 Wasm 容器通常启动更快，更可移植。\n- 由于 Wasm 容器直接被 containerd 支持，在 Docker Desktop 最新版本中尝试 Docker\u002bWasm 技术预览 2 只需要启用“使用 containerd”选项。\n- 通过这种方式，Wasm 容器可以与 Linux 容器一起使用 Docker Compose 或其他编排平台如 Kubernetes 运行。\n- 此外，Docker Desktop 还能够将一个 Wasm 应用打包成一个 OCI 容器，并在其中嵌入一个 Wasm 运行时，以便通过容器仓库如 DockerHub 等分享。\n\n## 总结 {#summary}\n\n本文介绍了 Docker 发展过程中的四个重大举措：Moby Project、支持 Kubernetes、删除开源组织账号和增加对 WebAssembly 运行时的支持。其中，Moby Project 旨在推动容器技术走向主流，支持 Kubernetes 的举措提供了更广泛的选择和更好的用户体验，删除开源组织账号的举措引起了开源社区的不满和失望，增加对 WebAssembly 运行时的支持的举措则扩展了 Docker 的应用场景。\n\n## 参考 {#reference}\n\n- [Introducing Moby Project: a new open-source project to advance the software containerization movement](https:\/\/www.docker.com\/blog\/introducing-the-moby-project\/)\n- [Docker for Windows Desktop… Now With Kubernetes!](https:\/\/www.docker.com\/blog\/docker-windows-desktop-now-kubernetes\/)\n- [Introducing the Docker\u002bWasm Technical Preview](https:\/\/www.docker.com\/blog\/docker-wasm-technical-preview\/)\n- [Announcing Docker\u002bWasm Technical Preview 2](https:\/\/www.docker.com\/blog\/announcing-dockerwasm-technical-preview-2\/)\n- [Docker is deleting Open Source organisations - what you need to know](https:\/\/blog.alexellis.io\/docker-is-deleting-open-source-images\/)\n- [别慌：Kubernetes 和 Docker](https:\/\/kubernetes.io\/zh-cn\/blog\/2020\/12\/02\/dont-panic-kubernetes-and-docker\/)\n', '\/blog\/docker-four-milestones\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/yarn-on-docker/">容器技术在大数据场景下的应用——YARN on Docker</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2017/04/04</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/%e5%ae%b9%e5%99%a8"> 
             容器
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('容器技术在大数据场景下的应用——YARN on Docker', '基于 docker swarm。', '\n## 前言\n\n我已就该话题已在 2016 年上海 Qcon 上发表过演讲。另外 InfoQ 网站上的文字版[数据中心的 YARN on Docker 集群方案](https:\/\/www.infoq.cn\/article\/YARNOnDocker-forDCCluster\/)，即本文。\n\n项目代码开源在 Github 上：[Magpie](https:\/\/github.com\/rootsongjc\/magpie)\n\n## 当前数据中心存在的问题\n\n数据中心中的应用一般独立部署，为了保证环境隔离与方便管理，保证应用最大资源  数据中心中普遍存在如下问题：\n\n1. 主机资源利用率低\n2. 部署和扩展复杂\n3. 资源隔离无法动态调整\n4. 无法快速响应业务\n\n## 为何使用 YARN on Docker\n\n**彻底隔离队列**\n\n- 为了合理利用 Hadoop YARN 的资源，队列间会互相抢占计算资源，造成重要任务阻塞\n- 根据部门申请的机器数量划分 YARN 集群方便财务管理\n- 更细粒度的资源分配 \n\n**统一的资源分配**\n\n- 每个 NodeManager 和容器都可以限定 CPU、内存资源\n- YARN 资源划分精确到 CPU 核数和内存大小 \n\n**弹性伸缩性服务**\n\n- 每个容器中运行一个 NodeManager，增减 YARN 资源只需增减容器个数\n- 可以指定每个 NodeManager 拥有的计算资源多少，按需申请资源 \n\n## 给我们带来什么好处？ \n\n**Swarm 统一集群资源调度**\n\n- 统一资源\n- 增加 Docker 虚拟化层，降低运维成本\n\n**增加 Hadoop 集群资源利用率**\n\n- 对于数据中心：避免了静态资源隔离\n\n- 对于集群：加强集群内部资源隔离\n\n## 系统架构\n\n![YARN 在 swarm 上运行的架构](td_yarn_arch.jpg)\n\n比如数据中心中运行的 Hadoop 集群，我们将 HDFS 依然运行在物理机上，即 DataNode 依然部署在实体机器上，将 YARN 计算层运行在 Docker 容器中，整个系统使用二层资源调度，Spark、Flink、MapReduce 等应用运行在 YARN 上。\n\nSwarm 调度最底层的主机硬件资源，CPU 和内存封装为 Docker 容器，容器中运行 NodeManager，提供给 YARN 集群，一个 Swarm 集群中可以运行多个 YARN 集群，形成圈地式的 YARN 计算集群。\n\n![YARN 在 Swarm 上的架构之资源分配](td_yarn_arch2.jpg)\n\n**具体流程**\n\n1. swarm node 向 swarm master 注册主机资源并加入到 swarm cluster 中\n2. swarm master 向 cluster 申请资源请求启动容器\n3. swarm 根据调度策略选择在某个 node 上启动 docker container\n4. swarm node 的 docker daemon 根据容器启动参数启动相应资源大小的 NodeManager\n5. NodeManager 自动向 YARN 的 ResourceManager 注册资源一个 NodeManager 资源添加完成。\n\nSwarm 为数据中心做容器即主机资源调度，每个 swarmnode 的节点结构如图：\n\n![YARN 在 swarm 上的架构之单节点资源分配](td_yarn_arch3.jpg)\n\n一个 Swarm node 就是一台物理机，每台主机上可以起多个同类型的 docker container，每个 container 的资源都有限制包括 CPU、内存 NodeManager 容器只需要考虑本身进程占用的资源和需要给主机预留资源。假如主机是 24 核 64G，我们可以分给一个容器 5 核 12G，NodeManager 占用 4 核 10G 的资源提供给 YARN。\n\n**Kubernetes VS Swarm**\n\n关于容器集群管理系统的选型，用 Kubernetes 还是 Swarm？我们结合自己的经验和业务需求，对比如下：\n\n![Kubernetes vs Swarm](td_yarn_compare.jpg)\n\n基于以上四点，我们当时选择了 Swarm，它基本满足我们的需求，掌握和开发时常较短。\n\n## 镜像制作与发布\n\n镜像制作和发布流程如下图：\n\n![CI 流程](td_yarn_ci.jpg)\n\n用户从客户端提交代码到 Gitlab 中，需要包含 Dockerfile 文件，通过集成了 docker 插件的 Jenkins 的自动编译发布机制，自动 build 镜像后 push 到 docker 镜像仓库中，同一个项目每提交一次代码都会重新 build 一次镜像，生成不同的 tag 来标识镜像，Swarm 集群使用该镜像仓库就可以直接拉取镜像。\n\n### Dockerfile 的编写技巧\n\n![Dockerfile 编写技巧](td_yarn_dockerfile.jpg)\n\nDockerfile 相当于 docker 镜像的编译打包流程说明，其中也不乏一些技巧。     \n\n很多应用需要配置文件，如果想为每次启动容器的时候使用不同的配置参数，可以通过传递环境变量的方式来修改配置文件，前提是需要写一个 bash 脚本，脚本中来处理配置文件，再将这个脚本作为 entrypoint 入口，每当容器启动时就会执行这个脚本从而替换配置文件中的参数，也可以通过 CMD 传递参数给该脚本。\n\n启动容器的时候通过传递环境变量的方式修改配置文件：\n\n\u0060\u0060\u0060Shell\ndocker run -d \n--net=mynet \n-e NAMESERVICE=nameservice \n-e ACTIVE_NAMENODE_ID=namenode29 \\\n-e STANDBY_NAMENODE_ID=namenode63 \\\n-e HA_ZOOKEEPER_QUORUM=zk1:2181,zk2:2181,zk3:2181 \\\n-e YARN_ZK_DIR=rmstore \\\n-e YARN_CLUSTER_ID=yarnRM \\\n-e YARN_RM1_IP=rm1 \\\n-e YARN_RM2_IP=rm2 \\\n-e CPU_CORE_NUM=5\n-e NODEMANAGER_MEMORY_MB=12288 \\\n-e YARN_JOBHISTORY_IP=jobhistory \\\n-e ACTIVE_NAMENODE_IP=active-namenode \\\n-e STANDBY_NAMENODE_IP=standby-namenode \\\n-e HA=yes \\\ndocker-registry\/library\/hadoop-yarn:v0.1 resourcemanager\n\u0060\u0060\u0060\n\n最后传递 Resource Manager 或者 Node Manager 参数指定启动相应的服务。\n\n## 集群管理\n\n我开发的命令行工具[magpie](https:\/\/github.com\/rootsongjc\/magpie)，也可以通过其他开源可视化页面来管理集群，比如 shipyard。\n\n![Shipyard](td_yarn_shipyard.jpg)\n\n## 自定义网络\n\nDocker 容器跨主机互访一直是一个问题，Docker 官方为了避免网络上带来的诸多麻烦，故将跨主机网络开了比较大的口子，而由用户自己去实现。我们开发并开源了 Shrike 这个 docker 网络插件，大家可以在这里下载到：[GitHub - docker-ipam-plugin](https:\/\/github.com\/rootsongjc\/docker-ipam-plugin)\n\n目前 Docker 跨主机的网络实现方案也有很多种，主要包括端口映射、ovs、fannel 等。但是这些方案都无法满足我们的需求，端口映射服务内的内网 IP 会映射成外网的 IP，这样会给开发带来困惑，因为他们往往在跨网络交互时是不需要内网 IP 的，而 ovs 与 fannel 则是在基础网络协议上又包装了一层自定义协议，这样当网络流量大时，却又无端的增加了网络负载，最后我们采取了自主研发扁平化网络插件，也就是说让所有的容器统统在大二层上互通。架构如下：\n\n![YARN 网络](td_yarn_network.jpg)\n\n \n\n我们首先需要创建一个 br0 自定义网桥，这个网桥并不是通过系统命令手动建立的原始 Linux 网桥，而是通过 Docker 的 cerate network 命令来建立的自定义网桥，这样避免了一个很重要的问题就是我们可以通过设置 DefaultGatewayIPv4 参数来设置容器的默认路由，这个解决了原始 Linux 自建网桥不能解决的问题。用 Docker 创建网络时我们可以通过设置 subnet 参数来设置子网 IP 范围，默认我们可以把整个网段给这个子网，后面可以用 ipamdriver（地址管理插件）来进行控制。还有一个参数 gateway 是用来设置 br0 自定义网桥地址的，其实也就是你这台宿主机的地址。\n\n\u0060\u0060\u0060Shell\ndocker network create \n--opt=com.docker.network.bridge.enable_icc=true\n--opt=com.docker.network.bridge.enable_ip_masquerade=false\n--opt=com.docker.network.bridge.host_binding_ipv4=0.0.0.0\n--opt=com.docker.network.bridge.name=br0\n--opt=com.docker.network.driver.mtu=1500\n--ipam-driver=talkingdata\n--subnet=容器IP的子网范围\n--gateway=br0网桥使用的IP,也就是宿主机的地址\n--aux-address=DefaultGatewayIPv4=容器使用的网关地址\nmynet\n\u0060\u0060\u0060\n\n![IPAM 插件](td_yarn_ipam.jpg)\n\nIPAM 驱动是专门管理 Docker 容器 IP 的，Docker 每次启停与删除容器都会调用这个驱动提供的 IP 管理接口，然后 IP 接口会对存储 IP 地址的 Etcd 有一个增删改查的操作。此插件运行时会起一个 UnixSocket, 然后会在\u0060docker\/run\/plugins\u0060目录下生成一个.sock 文件，Dockerdaemon 之后会和这个 sock 文件进行沟通去调用我们之前实现好的几个接口进行 IP 管理，以此来达到 IP 管理的目的，防止 IP 冲突。 \n\n通过 Docker 命令去创建一个自定义的网络起名为\u0060mynet\u0060，同时会产生一个网桥 br0，之后通过更改网络配置文件（在\u0060\/etc\/sysconfig\/network-scripts\/\u0060下 ifcfg-br0、ifcfg-默认网络接口名）将默认网络接口桥接到 br0 上，重启网络后，桥接网络就会生效。Docker 默认在每次启动容器时都会将容器内的默认网卡桥接到 br0 上，而且宿主机的物理网卡也同样桥接到了 br0 上了。其实桥接的原理就好像是一台交换机，Docker 容器和宿主机物理网络接口都是服务器，通过 vethpair 这个网络设备像一根网线插到交换机上。至此，所有的容器网络已经在同一个网络上可以通信了，每一个 Docker 容器就好比是一台独立的虚拟机，拥有和宿主机同一网段的 IP，可以实现跨主机访问了。\n\n## 性能瓶颈与优化\n\n大家可能会担心自定义网络的性能问题，为此我们用 iperf 进行了网络性能测试。我们对比了不同主机容器间的网速，同一主机上的不同容器和不同主机间的网速，结果如下表：\n\n![网络性能对比](td_yarn_iperf.jpg)\n\n从表中我们可以看到，在这一组测试中，容器间的网速与容器是在想通主机还是在不同主机上的差别不大，说明我们的网络插件性能还是很优异的。 \n\n## Hadoop 配置优化 \n\n因为使用 docker 将原来一台机器一个 nodemanager 给细化为了多个，会造成 nodemanager 个数的成倍增加，因此 hadoop 的一些配置需要相应优化。\n\u0060\u0060\u0060ini\n- yarn.nodemanager.localizer.fetch.thread-count 随着容器数量增加，需要相应调整该参数\n- yarn.resourcemanager.amliveliness-monitor.interval-ms 默认1秒，改为10秒，否则时间太短可能导致有些节点无法注册\n- yarn.resourcemanager.resource-tracker.client.thread-count 默认50，改为100，随着容器数量增加，需要相应调整该参数\n- yarn.nodemanager.pmem-check-enabled 默认true，改为false，不检查任务正在使用的物理内存量\n- 容器中hadoop ulimit值修改，默认4096，改成655350\n\u0060\u0060\u0060\n\n**集群监控** \n\n如果使用 shipyard 管理集群会有一个单独的监控页面，可以看到一定时间段内的 CPU、内存、IO、网络使用状况。\n\n![集群监控](td_yarn_monitor.jpg)\n\n## 关于未来\n\n![YARN 的未来](td_yarn_os.jpg) \n\n我们未来规划做的是 DC\/OS，基于 Docker 的应用自动打包编译分发系统，让开发人员可以很便捷的申请资源，上下线服务，管理应用。要达到这个目标还有很多事情要做：\n\n-  Service Control Panel：统一的根据服务来管理的 web 页面\n-  Loadbalance：容器根据机器负载情况自动迁移\n-  Scheduler：swarm 调度策略优化\n-  服务配置文件：提供镜像启动参数的配置文件，所有启动参数可通过文件配置\n-  监控：服务级别的监控\n\n## 后记\n\n这篇文章写好的时候是 2016 年 10 月，距离现在我添加**前言**和**后记**的已经快半年时间了，这段时间内业界也发生了很多变化，比如 docker 推出 CE 和 SE 版本，Kubernetes 发布了 1.6 版本，人工智能依然大热，在可预见的未来，可以说\u003cu\u003eKubernetes 一定会远远超越 Docker 成为容器编排领域的王者\u003c\/u\u003e，这是毋庸置疑的，对于 docker 17.03-CE 我也研究过了一段时间，其 disgusting 的 plugin 让我对于 Docker 的编排已经失去信心。\n\n其实当时容器在大数据场景下的应用并不是很多，毕竟 Hadoop 那套笨重的东西放在容器下运行，上生产环境实属不易。如果说做原型验证、研发测试那还可以。这样就大大限制了容器技术在大数据场景下的应用场景。使用容器的编排调度来实现大数据集群的资源优化有点舍本逐末，\u003cu\u003e如果真的要优化集群资源利用率的话，应该让不同的应用混跑，而不应该让集群之间资源隔离，比如 Web 应用跟大数据应用混布。\u003c\/u\u003e目前的这种**YARN on Docker**方案实质上是将原来的整体 Hadoop YARN 集群划分成多个不同的 YARN，将存储和计算分离了。其实这跟**Nutanix**的超融合架构有点像，Nutanix 是由前 Google 的工程师创立的，解决虚拟化计算环境下的存储问题，也是将存储和计算分离，共享存储，计算根据需要调度。事实上 Yahoo 已经有解决 Hadoop 集群的资源细粒度分配和调度问题的方案，这应该是从 YARN 的 scheduler 层来处理。\n\nSwarm 已死，Swarmkit 将继续发展，Docker 的 Swarm Mode 还会在艰难中前行，目前看到的趋势仍然是模仿 Kubernentes 为主，没有自己鲜明的特色（除了部署管理方便意外，谁让它就集成在了 Docker 里呢，就像当年 Windows 集成 IE 打败 Netscape，不过这不会再此上演了），Kubernentes 又是一个通用的资源调度框架，它的最小资源划分是**Pod**而不是 Docker，它还可以运行 rkt、containerd。\n\n上周起我开始将注意力全部转移到了 Kubernentes，以后请关注我的[Kuberentes 实践](https:\/\/jimmysong.io\/tags\/kubernetes\/)相关文章。\n', '\/blog\/yarn-on-docker\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">基于 docker swarm。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(68)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(38)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(24)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(20)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(15)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(13)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
      
        <a href="/categories/%e5%ae%b9%e5%99%a8" class="sidebar-item">
            <span>容器</span>
            <span>(4)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(4)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(1)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">保障 Istio 安全：解决关键安全漏洞及最佳实践</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/ulanqab-trip/">乌兰察布之旅：探索火山与失落的村庄</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/explore-tetrate-enterprise-gateway/">介绍 Tetrate Enterprise Gateway 及与 Istio 集成：云原生应用的全面网关解决方案</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024 圆桌论坛预告：Istio 和现代 API 网关——引领服务网格的未来</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/cloud-native-meetup-dalian-2024/">2024 大连云原生技术开放日</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
