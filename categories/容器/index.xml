<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song – 容器专栏</title>
    <link>https://jimmysong.io/categories/%E5%AE%B9%E5%99%A8/</link>
    <description>Recent content in 容器专栏 on Jimmy Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 25 Apr 2023 19:09:28 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/categories/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docker 多平台构建指南：构建 WebAssembly 镜像</title>
      <link>https://jimmysong.io/blog/docker-multi-platform-image-building/</link>
      <pubDate>Tue, 25 Apr 2023 19:09:28 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-multi-platform-image-building/</guid>
      <description>
        
        
        &lt;p&gt;Docker 多平台构建是一种用于构建 Docker 镜像以在多种 CPU 架构和操作系统上运行的技术。它可以让用户在一个 Dockerfile 中定义一个通用的构建过程，然后使用 Docker CLI 命令将其构建为多个不同平台的镜像。这些镜像可以在不同的计算机、云平台和容器编排系统上运行，从而为用户提供更广泛的部署选项。&lt;/p&gt;
&lt;p&gt;在多平台构建中，用户需要使用 Docker Buildx 插件来构建镜像。Docker Buildx 可以构建并输出多个不同平台的镜像，包括 x86、ARM、IBM Power 等。用户可以使用该插件创建多种平台的构建环境，并使用这些环境构建镜像。&lt;/p&gt;
&lt;p&gt;需要注意的是，多平台构建需要在支持多平台的 Docker 主机上进行。在这种主机上，Docker 可以使用 QEMU 等模拟器来模拟其他平台的环境，从而实现构建多种平台的镜像。&lt;/p&gt;
&lt;h2 id=&#34;what-is-docker-buildx&#34;&gt;什么是 docker buildx?&lt;/h2&gt;
&lt;p&gt;Docker Buildx 是 Docker 的一个插件，它提供了一种简单、高效的方式来构建和打包 Docker 镜像。它能够在多个平台上构建和输出 Docker 镜像，包括 Linux、Windows、macOS 等，支持 CPU 架构和操作系统等多种参数的设置。&lt;/p&gt;
&lt;p&gt;Docker Buildx 在构建镜像时使用了 &lt;a href=&#34;https://docs.docker.com/build/buildkit/&#34; title=&#34;BuildKit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildKit&lt;/a&gt;，这是 Docker 官方推出的一个基于 Go 语言实现的高性能构建引擎。BuildKit 提供了更快的构建速度、更小的镜像体积、更好的缓存管理等优势，也可以在 Docker Buildx 之外使用。&lt;/p&gt;
&lt;p&gt;使用 Docker Buildx，可以将不同平台上的 Docker 镜像构建合并到一个 manifest 中，使得用户只需要下载一个 manifest，就可以获取多个平台的镜像。这为跨平台开发和分发应用程序提供了很大的便利。&lt;/p&gt;
&lt;h2 id=&#34;docker-buildx-principles&#34;&gt;Docker buildx 实现多平台构建的原理&lt;/h2&gt;
&lt;p&gt;Docker &lt;a href=&#34;https://github.com/docker/buildx&#34; title=&#34;buildx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;buildx&lt;/a&gt; 实现多平台镜像构建的原理是基于 Docker 的多架构支持。Docker 可以在一个主机上运行多个容器，每个容器运行在自己的隔离环境中，相互独立。而 Docker 镜像则是用于创建容器的基础文件系统。&lt;/p&gt;
&lt;p&gt;在 Docker 中，不同的 CPU 架构和操作系统可以使用不同的 base image（基础镜像）进行构建。而 Docker buildx 可以自动识别当前主机的架构和操作系统，并选择合适的 base image 进行构建。在构建过程中，Docker buildx 会使用 BuildKit 引擎进行构建，支持多平台的交叉编译和镜像打包。&lt;/p&gt;
&lt;p&gt;在构建完成后，Docker buildx 会将不同平台上的镜像打包成一个 manifest 文件，其中包含了所有平台的镜像信息。用户可以通过 Docker CLI 命令或者 Docker registry 接口来操作 manifest 文件，获取不同平台上的镜像。对于不支持多架构的 Docker 版本，可以通过安装 Docker CLI 的 experimental 版本来使用 Docker buildx。&lt;/p&gt;
&lt;p&gt;Docker buildx 利用了 Docker 的多架构支持和 BuildKit 引擎，实现了跨平台的 Docker 镜像构建和分发。&lt;/p&gt;
&lt;h2 id=&#34;docker-buildkit&#34;&gt;Docker BuildKit 引擎简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/build/buildkit/&#34; title=&#34;BuildKit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildKit&lt;/a&gt; 是 Docker 官方推出的一个高性能的构建引擎，它可以用于构建 Docker 镜像、构建应用程序以及执行其他构建任务。BuildKit 引擎采用了分布式的架构，可以并行地执行多个构建任务，提高构建效率。&lt;/p&gt;
&lt;p&gt;BuildKit 引擎的主要特点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高性能：BuildKit 引擎采用了高效的缓存管理机制，能够快速地执行增量构建，减少构建时间。同时，它还能够自动优化构建过程，选择最佳的构建路径和策略，进一步提高构建性能。&lt;/li&gt;
&lt;li&gt;多平台支持：BuildKit 引擎支持多种 CPU 架构和操作系统，能够在不同平台上构建和输出 Docker 镜像。在 Docker buildx 中，BuildKit 引擎可以自动识别当前主机的架构和操作系统，并选择合适的构建方案。&lt;/li&gt;
&lt;li&gt;模块化设计：BuildKit 引擎采用了模块化的设计，可以根据需要动态加载和卸载不同的模块。这使得 BuildKit 引擎更加灵活和可扩展，可以支持各种不同的构建任务。&lt;/li&gt;
&lt;li&gt;安全性：BuildKit 引擎采用了安全的构建方式，可以自动执行一系列的安全检查，确保构建过程中不会引入漏洞或其他安全问题。同时，BuildKit 引擎还支持签名和加密等安全功能，保护用户的构建数据和镜像。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;platforms&#34;&gt;Docker buildx 支持哪些平台？&lt;/h2&gt;
&lt;p&gt;Docker buildx 支持的平台主要包括以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。&lt;/li&gt;
&lt;li&gt;Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。&lt;/li&gt;
&lt;li&gt;macOS：支持 Intel、Apple M1 架构。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了以上平台外，Docker buildx 还支持构建和输出多种其他平台的 Docker 镜像，包括 FreeBSD、Solaris 等。用户可以通过指定对应的 &lt;code&gt;platform&lt;/code&gt; 参数来构建和输出不同平台的 Docker 镜像，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个命令将会构建一个同时支持 x86_64 和 ARM64 架构的 Docker 镜像。用户也可以通过指定不同的 buildx 构建配置来支持更多的平台，例如使用 qemu-user-static 等模拟器来支持其他的 CPU 架构。总之，Docker buildx 的多平台支持非常强大，为跨平台开发和分发应用程序提供了便利。&lt;/p&gt;
&lt;h2 id=&#34;arch&#34;&gt;Docker buildx 引擎的架构与组成&lt;/h2&gt;
&lt;p&gt;Docker buildx 引擎的架构是一个分布式的构建系统，通过多阶段、多组件的设计，实现了高性能、多平台支持、安全性等优点，为 Docker 镜像构建和应用程序构建提供了强大的支持。它由以下几个主要组成部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CLI：提供了命令行接口，用户可以通过命令行来执行构建任务、管理构建配置等操作。&lt;/li&gt;
&lt;li&gt;BuildKit 引擎：作为 Docker buildx 的构建引擎，它负责执行构建任务，生成 Docker 镜像等。BuildKit 引擎具有高性能、多平台支持、安全性等优点。&lt;/li&gt;
&lt;li&gt;构建器（Builder）：构建器是一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。在 Docker buildx 中，可以配置多个构建器，以支持多个平台和多个构建环境。&lt;/li&gt;
&lt;li&gt;并行器（Scheduler）：并行器是负责协调和管理多个构建器的组件，它可以自动选择最佳的构建器执行构建任务，并将任务分配给合适的构建器。并行器还可以执行构建任务的并行处理，提高构建效率。&lt;/li&gt;
&lt;li&gt;缓存管理器（Cache Manager）：缓存管理器是负责管理构建过程中的缓存数据，可以快速执行增量构建，减少构建时间。在 Docker buildx 中，缓存管理器可以自动选择合适的缓存方案，包括本地缓存和远程缓存等。&lt;/li&gt;
&lt;li&gt;输出器（Exporter）：输出器负责将构建生成的 Docker 镜像输出到指定的仓库或者本地文件系统中。在 Docker buildx 中，输出器可以自动识别当前平台和目标平台，选择合适的镜像格式和输出路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;command&#34;&gt;docker buildx 命令的使用&lt;/h2&gt;
&lt;p&gt;使用 docker buildx 命令可以方便地进行 Docker 镜像的构建和输出。下面是一些常用的 docker buildx 命令及其用法：&lt;/p&gt;
&lt;p&gt;查看当前的 buildx 构建器列表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建新的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx create --name mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切换到指定名称的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx use mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;设置 buildx 构建器的平台支持&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx inspect --bootstrap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx inspect --platform
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;构建 Docker 镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --tag myimage .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出 Docker 镜像到本地文件系统&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --output&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出 Docker 镜像到 Docker Hub 或其他远程仓库&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --tag myrepo/myimage --push .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除指定名称的 buildx 构建器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx rm mybuilder
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了以上命令外，docker buildx 还支持许多其他的参数和选项，例如设置构建缓存、并行处理、构建标签等。用户可以通过查看官方文档或者使用 &amp;ndash;help 选项来了解更多详情。&lt;/p&gt;
&lt;h2 id=&#34;builder&#34;&gt;理解 buildx 构建器&lt;/h2&gt;
&lt;p&gt;在 Docker 中，构建器（Builder）是指一个 Docker 容器，它包含了构建所需要的环境和工具，可以执行构建任务。Docker buildx 构建器是指使用 BuildKit 引擎的多平台构建器，可以通过 Docker CLI 命令进行管理和操作。在使用 Docker buildx 构建器时，用户可以配置多个构建器，以支持多个平台和多个构建环境。&lt;/p&gt;
&lt;p&gt;用户可以通过创建、切换、查看和删除构建器，来管理和维护 Docker buildx 的构建环境。构建器的主要作用是提供一个干净、独立的构建环境，避免构建过程中的依赖冲突和环境污染。此外，构建器还可以方便地进行版本管理和共享，以便多个用户或者团队协同构建 Docker 镜像。&lt;/p&gt;
&lt;p&gt;Docker buildx 构建器还支持多平台构建，用户可以在同一个构建器中设置多个平台，以便生成跨平台的 Docker 镜像。通过 Docker buildx 构建器，用户可以轻松实现 Docker 镜像的多平台构建，提高构建效率和应用程序的兼容性。&lt;/p&gt;
&lt;h2 id=&#34;where-is-my-images&#34;&gt;为什么本地看不到 Docker buildx 构建的镜像？&lt;/h2&gt;
&lt;p&gt;这通常是因为你当前使用的 Docker context 不支持编译出来的镜像架构。例如 &lt;a href=&#34;https://orbstack.dev/&#34; title=&#34;Orbstack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Orbstack&lt;/a&gt;，虽然它支持编译跨平台的镜像，但是执行 &lt;code&gt;docker buildx&lt;/code&gt; 构建出来的镜像不会直接保存在本地的 Docker 镜像仓库中，而是保存在构建器（Builder）的缓存中。这是因为 Docker buildx 采用了分层构建的方式，构建出的每一层镜像都可以被重用，以减少构建时间和磁盘空间的占用。&lt;/p&gt;
&lt;p&gt;你应该使用 &lt;code&gt;docker context&lt;/code&gt; 命令切换会 Docker 默认的上下文环境再执行构建，这样构建出来的跨平台镜像就可以在本地看见了。&lt;/p&gt;
&lt;h2 id=&#34;local-storage&#34;&gt;如何将多平台镜像保存到本地？&lt;/h2&gt;
&lt;p&gt;要将 Docker buildx 构建的多平台镜像保存到本地，可以使用 &lt;code&gt;--output&lt;/code&gt; 选项指定输出类型为 &lt;code&gt;type=local&lt;/code&gt;，并指定输出目录，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 --output &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述命令将构建包含 &lt;code&gt;linux/amd64&lt;/code&gt; 和 &lt;code&gt;linux/arm64&lt;/code&gt; 两种平台的镜像，并将输出类型设置为本地（&lt;code&gt;type=local&lt;/code&gt;），输出目录为 &lt;code&gt;./output&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;构建完成后，输出目录中会生成多个子目录，每个子目录分别对应一个平台，其中包含该平台下的镜像文件。&lt;/p&gt;
&lt;p&gt;如果只想保存其中一个平台的镜像，可以在 &lt;code&gt;--output&lt;/code&gt; 选项中指定要保存的平台，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker buildx build --platform linux/amd64,linux/arm64 --output &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;local,dest&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;./output/linux/amd64 .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述命令将只保存 &lt;code&gt;linux/amd64&lt;/code&gt; 平台的镜像，输出到 &lt;code&gt;./output/linux/amd64&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;--output&lt;/code&gt; 选项只支持部分输出类型，如果要将镜像保存到其他类型的输出（例如 tar 包、OCI 存储、Docker registry 等），需要使用其他的输出插件和选项。具体细节可以参考 &lt;a href=&#34;https://docs.docker.com/build/building/multi-platform/&#34; title=&#34;Docker 官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;wasm&#34;&gt;如何使用构建 Wasm 镜像？&lt;/h2&gt;
&lt;p&gt;WebAssembly 是一种中间代码格式，需要使用编译器将源代码编译为 WebAssembly 格式的二进制文件，再将其打包成镜像。以下是构建 WebAssembly 镜像的一般步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写 WebAssembly 源代码，并使用编译器将其编译为 WebAssembly 格式的二进制文件。例如使用 Rust 编写代码，并使用 Cargo 编译出 &lt;code&gt;.wasm&lt;/code&gt; 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写 Dockerfile 将 Wasm 二进制文件添加到空镜像中。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# syntax=docker/dockerfile:1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; ./target/wasm32-wasi/debug/hello-wasm.wasm /hello.wasm&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hello.wasm&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;docker buildx&lt;/code&gt; 命令构建镜像，例如 &lt;code&gt;docker buildx build --platform wasi/wasm32 -t jimmysong/hello-wasm .&lt;/code&gt;  将在本地构建。若你想将该镜像同时同时推送到 Docker Hub，可以在命令中加上 &lt;code&gt;--push&lt;/code&gt;标志。基于 WebAssembly 平台的镜像并上传到 Docker Hub。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;notice&#34;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;除了构建多平台镜像、导出和加载镜像外，还有一些 Docker buildx 命令的常用操作及注意事项，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-progress&lt;/code&gt; 选项：可以使用 &lt;code&gt;-progress&lt;/code&gt; 选项指定构建过程的输出格式，包括 &lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;plain&lt;/code&gt;、&lt;code&gt;tty&lt;/code&gt; 三种格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-no-cache&lt;/code&gt; 选项：可以使用 &lt;code&gt;-no-cache&lt;/code&gt; 选项禁用构建过程中的缓存机制，强制重新构建镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-push&lt;/code&gt; 选项：可以使用 &lt;code&gt;-push&lt;/code&gt; 选项将构建的镜像推送到 Docker registry 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tag&lt;/code&gt; 选项：可以使用 &lt;code&gt;-tag&lt;/code&gt; 选项为构建的镜像指定标签。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-file&lt;/code&gt; 选项：可以使用 &lt;code&gt;-file&lt;/code&gt; 选项指定 Dockerfile 文件的路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-build-arg&lt;/code&gt; 选项：可以使用 &lt;code&gt;-build-arg&lt;/code&gt; 选项传递构建参数给 Dockerfile 中的指令。&lt;/li&gt;
&lt;li&gt;构建上下文的注意事项：构建上下文指的是 Dockerfile 文件所在的目录，以及构建过程中需要用到的其他文件。在构建过程中需要尽量减少构建上下文的大小，避免构建过程中传输大量不必要的文件。可以使用 &lt;code&gt;.dockerignore&lt;/code&gt; 文件排除不需要传输的文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，Docker buildx 是一个比较新的命令，不同版本的 Docker Engine 可能会存在差异，因此在使用时需要注意查阅官方文档，并根据实际情况进行操作。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>为什么 Docker 要增加 WebAssembly 运行时？</title>
      <link>https://jimmysong.io/blog/why-docker-support-wasm/</link>
      <pubDate>Fri, 07 Apr 2023 18:45:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/why-docker-support-wasm/</guid>
      <description>
        
        
        &lt;p&gt;在 &lt;a href=&#34;https://jimmysong.io/blog/docker-four-milestones/&#34; title=&#34;Docker 发展史：四个重大举措，影响深远！&#34;&gt;Docker 发展史：四个重大举措，影响深远！&lt;/a&gt; 这篇文章中我提到了 Docker 从一开始引领容器运行时，再到在容器编排这一维度上落后于 Kubernetes。为了在保住容器运行时的统治地位，Docker 公司提出了 OCI 并通过 &lt;a href=&#34;https://github.com/deislabs/containerd-wasm-shims&#34; title=&#34;containerd-wasm-shim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd-wasm-shim&lt;/a&gt; 支持更多的 WebAssembly 运行时。&lt;/p&gt;
&lt;p&gt;为了解决 Docker 在安全、稳定性、性能及可移植性方面的局限性，Kubernetes 社区开发了具有不同实现和功能的其他容器运行时，并为其制定了容器运行时接口（CRI）规范。目前实现该规范的容器运行时有 containerd、cri-o。还有 katacontainers、gvisor 等未实现 CRI 但是可以通过添加虚拟化层在 Kubernetes 上运行的其他容器运行时。&lt;/p&gt;
&lt;p&gt;开放容器倡议 (OCI) 旨在定义容器镜像格式和运行时的行业标准，Docker 捐赠了其运行时 runc 作为该标准的第一个实现。最近，WASM 社区对 OCI 工具链表现出了兴趣，Docker 现在支持 WebAssembly 模块作为其工件之一。现在 Docker Hub 已经支持除了镜像以外的，Helm、Volume 和 WebAssembly 等常用工件。&lt;/p&gt;
&lt;p&gt;使用 Docker 构建包含 WebAssembly 模块的镜像，并保存在 Docker Hub 中。通过 &lt;a href=&#34;https://github.com/deislabs/containerd-wasm-shims&#34; title=&#34;containerd-wasm-shim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd-wasm-shim&lt;/a&gt;，可以让它们在 Kubernetes 中运行，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/why-docker-support-wasm/oci.svg&#34; data-img=&#34;/blog/why-docker-support-wasm/oci.svg&#34; alt=&#34;image&#34; data-caption=&#34;在 Kubernetes 中运行 WebAssembly 模块&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;在 Kubernetes 中运行 WebAssembly 模块&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Containerd 是一种符合 CRI（Container Runtime Interface）规范的容器运行时，是由 Docker 公司开源并贡献给 CNCF 的。只要支持 CRI 规范的运行时都可以在 Kubernetes 中运行。&lt;/p&gt;
&lt;p&gt;关于以上提到的名词 containerd、CRI、OCI 等的关系介绍，可以参考 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/490585683&#34; title=&#34;Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;advantages&#34;&gt;在 Docker 中运行 WebAssembly 应用相对 Linux 镜像有什么优势？&lt;/h2&gt;
&lt;p&gt;使用 Docker 运行 WebAssembly 应用相对运行 Linux 镜像有以下优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更高的性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly 应用的启动时间更短，因为它不需要启动整个操作系统，而 Linux 容器需要。WebAssembly 模块的冷启动时间比 Docker 容器快 100 倍。WebAssembly 模块的内存占用更小，因为它是一个二进制格式，可以高效地压缩代码和依赖，而 Docker 容器需要打包整个镜像。WebAssembly 模块的大小一般在 1MB 以内，而 Docker 镜像的大小可以达到 100 或 200 MB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更高的可移植性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly 应用是一个架构中立的格式，只要有相应的运行时，就可以在任何底层架构上运行，而不需要考虑不同架构之间的兼容性问题。Docker 容器需要针对不同的架构构建不同的镜像，可能会存在一些潜在的安全风险或漏洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的安全性和隔离性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly 应用可以提供代码级别的安全性，防止恶意代码访问系统资源，具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebAssembly 应用是运行在一个沙箱环境中的二进制字节码，不需要访问主机系统的资源，也不会受到主机系统的影响。Docker 容器虽然也是运行在一个隔离的环境中，但是仍然需要在主机系统上运行，可能会受到主机系统的攻击或干扰。&lt;/li&gt;
&lt;li&gt;WebAssembly 应用是通过 WebAssembly System Interface (WASI) 来与外部交互的，WASI 是一种标准化的 API 集合，可以提供一些基本的系统功能，比如文件操作、网络访问、环境变量等。WASI 可以限制 WebAssembly 应用的权限和能力，防止它们做一些危险的操作。Docker 容器虽然也可以通过设置一些安全选项来限制容器的权限和能力，但是仍然需要依赖主机系统提供的功能和服务。&lt;/li&gt;
&lt;li&gt;WebAssembly 应用是一个架构中立的格式，只要有相应的运行时，就可以在任何底层架构上运行，而不需要考虑不同架构之间的兼容性问题。Docker 容器需要针对不同的架构构建不同的镜像，可能会存在一些潜在的安全风险或漏洞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为有以上优势，WebAssembly 在一些场景下比 Docker 容器更有优势，例如边缘计算、云原生应用和微服务。当然，WebAssembly 应用也有一些局限性，比如不支持多线程、垃圾回收和二进制打包等。因此，并不是所有的场景都适合使用 WebAssembly 应用。你可以根据你的具体需求和偏好来选择合适的技术方案。&lt;/p&gt;
&lt;h2 id=&#34;how-to-run-wasm-with-docker&#34;&gt;如何在 Docker 中运行 WebAssembly 应用？&lt;/h2&gt;
&lt;p&gt;在 Docker 中运行 WebAssembly 应用的方式与普通的 Linux 镜像没有太大的不同，只是在运行时需要指定下平台和运行时。下面的例子来自 &lt;a href=&#34;https://docs.docker.com/desktop/wasm/&#34; title=&#34;Docker 官方文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 官方文档&lt;/a&gt;，以在 Docker Desktop 中为例运行 WebAssembly 应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -dp 8080:8080 --name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasm-example --runtime&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;io.containerd.wasmedge.v1 --platform&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasi/wasm32 michaelirwin244/wasm-example
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--runtime=io.containerd.wasmedge.v1&lt;/code&gt; 指定使用 WasmEdge 运行时，替代默认的 Linux 容器运行时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--platform=wasi/wasm32&lt;/code&gt; 指定镜像的架构。通过利用 Wasm 架构，无需为不同的机器架构构建单独的镜像。Wasm 运行时负责将 Wasm 二进制文件转换为机器指令的最后一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 Docker 支持四种 WebAssembly 运行时，分别为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运行时名称&lt;/th&gt;
&lt;th&gt;API 名称&lt;/th&gt;
&lt;th&gt;开发者&lt;/th&gt;
&lt;th&gt;基金会托管&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/fermyon/spin&#34; title=&#34;spin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io.containerd.spin.v1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Fermyon&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/deislabs/spiderlightning&#34; title=&#34;SpiderLightning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SpiderLightning&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io.containerd.slight.v1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;DeisLabs&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/WasmEdge/WasmEdge&#34; title=&#34;WasmEdge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io.containerd.wasmedge.v1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SecondState&lt;/td&gt;
&lt;td&gt;CNCF 沙箱项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/bytecodealliance/wasmtime&#34; title=&#34;Wasmtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasmtime&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io.containerd.wasmtime.v1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mozilla、Fastly、Intel、Red Hat 等公司&lt;/td&gt;
&lt;td&gt;字节码联盟项目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在命令行终端中输入以下命令可以查看 WebAssembly 应用的运行情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://localhost:8080/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你将看到如下输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello world from Rust running with Wasm! Send POST data to /echo to have it echoed back to you
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你还可以向&lt;code&gt;/echo&lt;/code&gt;端点发送 POST 测试请求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl localhost:8080/echo -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;message&amp;#34;:&amp;#34;Hello&amp;#34;}&amp;#39;&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-type: application/json&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你将看到如下输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;summary&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了 Docker 为什么要增加对 WebAssembly 的支持，以及在 Docker 中运行 WebAssembly 应用的优势和方法。WebAssembly 应用相对于 Linux 镜像有更高的性能、可移植性和安全性，适用于边缘计算、云原生应用和微服务等场景。Docker 支持四种 WebAssembly 运行时，分别为 spin、spiderlightning、WasmEdge 和 wasmtime。在接下来的文章中我将介绍如何开发一个 WebAssembly 应用，敬请期待。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/announcing-docker-hub-oci-artifacts-support/&#34; title=&#34;Announcing Docker Hub OCI Artifacts Support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Announcing Docker Hub OCI Artifacts Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/490585683&#34; title=&#34;Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/build-share-run-webassembly-apps-docker/&#34; title=&#34;Build, Share, and Run WebAssembly Apps Using Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Build, Share, and Run WebAssembly Apps Using Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/why-containers-and-webassembly-work-well-together/&#34; title=&#34;Why Containers and WebAssembly Work Well Together&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Why Containers and WebAssembly Work Well Together&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@guglielmino/docker-webassembly-a-quick-intro-730c38e8390c&#34; title=&#34;Docker &amp;#43; WebAssembly: a quick intro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker + WebAssembly: a quick intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docker 发展史：四个重大举措，影响深远！</title>
      <link>https://jimmysong.io/blog/docker-four-milestones/</link>
      <pubDate>Thu, 06 Apr 2023 21:25:40 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-four-milestones/</guid>
      <description>
        
        
        &lt;p&gt;在 2017 年的容器编排大战中，Docker 公司失败后沉寂了几年，但近年来又开始频繁行动，例如腾退开源组织账号，支持 WebAssembly 等。本文将回顾 Docker 公司发展过程中的四个重大举措，这些措施深深地影响了 Docker 公司的发展，也对 Docker 甚至 Kubernetes 社区产生了深远的影响。&lt;/p&gt;
&lt;h2 id=&#34;what-are-we-talking-about-docker&#34;&gt;当我们在谈论 Docker 时我们在谈论什么？&lt;/h2&gt;
&lt;p&gt;首先我们需要先确定 Docker 这个词的含义。当人们在谈论 Docker 时可能指的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker 公司&lt;/li&gt;
&lt;li&gt;Docker 软件栈&lt;/li&gt;
&lt;li&gt;Docker 命令行工具&lt;/li&gt;
&lt;li&gt;Docker 容器运行时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么同一个词会有这么多不同的意思呢？这都是有历史原因的。Docker 软件于 2013 年发布，起初定位为开发者工具。作为最早发布的容器工具，它迅速走红，并成为容器技术的代名词。但它最初只是在单机上运行，有太多耦合的接口设计。后来容器集群出现，才需要用到容器编排调度工具。因为 Kubernetes 具有丰富的功能和扩展性，Docker 公司推出的 Swarm 在这场容器编排大战中败下阵来。归根结底，Docker 面向开发者，而容器运行时则面向机器，只需要对应的接口即可，不需要那么丰富的管理工具。如今，Docker 仍然是最受开发者喜爱的容器工具之一，其 Docker Hub 是全球最大的镜像仓库。&lt;/p&gt;
&lt;h2 id=&#34;rename-docker-to-moby&#34;&gt;将 Docker 项目改名为 Moby&lt;/h2&gt;
&lt;p&gt;2017 年 4 月，Docker 公司将 Docker 项目重命名为 Moby，详见 &lt;a href=&#34;https://www.docker.com/blog/introducing-the-moby-project/&#34; title=&#34;Introducing Moby Project: a new open-source project to advance the software containerization movement&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Moby Project: a new open-source project to advance the software containerization movement&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/moby/moby&#34; title=&#34;Moby Project&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Moby Project&lt;/a&gt; 是 Docker 公司为了应对容器技术在各个领域和用例中普及的趋势而发起的一个开源项目。&lt;/li&gt;
&lt;li&gt;Moby Project 是 Docker 公司作为一个开放的研发实验室，与整个生态系统合作，实验，开发新的组件，并协作构建容器技术的未来。&lt;/li&gt;
&lt;li&gt;Moby Project 不是 Docker 产品的替代品，而是 Docker 产品的基础。&lt;/li&gt;
&lt;li&gt;Moby Project 包括三个层次：组件层，框架层和装配层。
&lt;ul&gt;
&lt;li&gt;组件层包括一些可复用的开源组件，如 runc, containerd, LinuxKit, InfraKit 等，可以用于构建各种类型的容器系统。&lt;/li&gt;
&lt;li&gt;框架层提供了一些工具和库，用于将组件组装成系统，并管理其生命周期。&lt;/li&gt;
&lt;li&gt;装配层是一个社区驱动的平台，用于分享和协作构建基于 Moby 框架的系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moby Project 是一个新的开源项目，旨在推动软件容器化运动的发展，帮助生态系统让容器技术走向主流。它提供了一个组件库，一个用于将组件组装成定制的基于容器的系统的框架，以及一个让所有容器爱好者可以实验和交流想法的地方。&lt;/p&gt;
&lt;p&gt;Moby Project 和 Docker 的区别和联系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moby Project 是一个开源项目，Docker 是一个商业产品。&lt;/li&gt;
&lt;li&gt;Moby Project 是 Docker 产品的基础，Docker 产品是 Moby Project 的一个实例。&lt;/li&gt;
&lt;li&gt;Moby Project 是一个通用的框架，可以用于构建各种类型和用例的容器系统，Docker 是一个针对特定用例的容器系统，即构建，运行和共享应用程序。&lt;/li&gt;
&lt;li&gt;Moby Project 是一个开放的研发实验室，用于实验和协作开发新的容器技术，Docker 是一个成熟的产品，用于提供稳定和可靠的容器服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;support-kubernetes&#34;&gt;支持 Kubernetes 调度&lt;/h2&gt;
&lt;p&gt;Docker 公司在 2017 年 12 月发布的 Docker 17.12 版本中开始支持 Kubernetes。在此之前，Docker 公司一直在发展自己的容器编排和调度工具 Docker Swarm。然而，Kubernetes 在容器编排和调度方面具有更广泛的支持和社区贡献，已经成为了业界标准。因此，Docker 公司决定将 Kubernetes 集成到 Docker 平台中，以提供更广泛的选择和更好的用户体验。Docker 公司在 Docker Desktop 和 Docker Enterprise 中提供了 Kubernetes 的集成支持，使得 Kubernetes 和 Docker 容器可以更加方便地部署和管理。同时，Docker 公司也开发了一些工具，如 Kompose 和 Docker Compose，使得用户可以将 Docker Compose 配置文件转换为 Kubernetes YAML 文件，以便更加方便地将应用程序从 Docker Swarm 迁移到 Kubernetes。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-not-support-docker&#34;&gt;Kubernetes 不再支持 Docker 运行时&lt;/h2&gt;
&lt;p&gt;Kubernetes 从 v1.20 起不再支持 Docker 运行时并在 2022 年 4 月发布的 v1.24 中被完全移除，如下图所示。这意味着在 Kubernetes 中只能使用 containerd 或 CRI-O 容器运行时，不过你依然可以使用 Docker 镜像，只是无需使用 docker 命令或 Docker 守护程序。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          &lt;img src=&#34;https://jimmysong.io/blog/docker-four-milestones/cri.svg&#34; data-img=&#34;/blog/docker-four-milestones/cri.svg&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes v1.24 正式移除 Docker 运行时&#34;&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes v1.24 正式移除 Docker 运行时&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Kubernetes v1.24 正式移除 Docker 运行时&lt;/p&gt;
&lt;h2 id=&#34;deprecate-open-source-organization&#34;&gt;腾退开源组织账号&lt;/h2&gt;
&lt;p&gt;2023 年 3 月，据 &lt;a href=&#34;https://blog.alexellis.io/docker-is-deleting-open-source-images/&#34; title=&#34;Alex Ellis 的博客&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Alex Ellis 的博客&lt;/a&gt; 介绍，Docker 公司决定删除一些开源组织的账户和镜像，除非他们升级到付费的团队计划，这对开源社区造成了很大的困扰和不安。很多 Docker 忠实拥护者和贡献者对 Docker 的这一举动表示了不满和失望。&lt;/p&gt;
&lt;p&gt;这一事件是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 公司给所有创建过组织的 Docker Hub 用户发了一封邮件，告知他们如果不升级到付费的团队计划，他们的账户和镜像都将被删除。&lt;/li&gt;
&lt;li&gt;这一举动只影响开源社区经常使用的组织账户，个人账户没有变化。&lt;/li&gt;
&lt;li&gt;付费的团队计划每年需要 420 美元，很多开源项目没有足够的资金支持。&lt;/li&gt;
&lt;li&gt;Docker 公司的开源项目计划（DSOS）要求非常苛刻，与开源项目的可持续性相悖。&lt;/li&gt;
&lt;li&gt;Docker 公司的沟通方式非常脱节，引起了开源社区的反感和担忧。&lt;/li&gt;
&lt;li&gt;文章作者建议开源项目使用其他的容器镜像仓库，如 GitHub Container Registry、&lt;a href=&#34;http://quay.io/&#34; title=&#34;Quay.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quay.io&lt;/a&gt;、各大云厂商的镜像仓库等。&lt;/li&gt;
&lt;li&gt;开源社区还提供了一些迁移镜像和重命名镜像的方法和工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;support-webassembly-runtime&#34;&gt;增加对 WebAssembly 运行时的支持&lt;/h2&gt;
&lt;p&gt;2022 年 10 月，Docker 公司发布了 Docker+Wasm 技术预览，这是一个特殊的构建，可以让开发者更容易地使用 Docker 运行 Wasm 工作负载。作为这次发布的一部分，Docker 还宣布将加入 Bytecode Alliance 作为一个投票成员。&lt;/p&gt;
&lt;p&gt;Wasm 是一种新技术，可让你在沙箱环境中运行 40 多种语言的应用程序代码，包括 Rust，C，C++，JavaScript 和 Golang。最初，Wasm 的用例是在浏览器中运行本地代码，如 Figma，AutoCAD 和 Photoshop 等。现在，一些公司如 Vercel，Fastly，Shopify 和 Cloudflare 等支持使用 Wasm 在边缘和云端运行代码。&lt;/p&gt;
&lt;p&gt;Docker+Wasm 技术预览包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker 的目标是帮助开发者通过克服应用开发的复杂性来实现他们的想法。&lt;/li&gt;
&lt;li&gt;Docker 将 Wasm 视为与 Linux 容器相辅相成的技术，开发者可以根据用例选择使用哪种技术（或两者都用）。&lt;/li&gt;
&lt;li&gt;Docker 想要帮助开发者更容易地使用熟悉的经验和工具来开发，构建和运行 Wasm 应用。&lt;/li&gt;
&lt;li&gt;要获取技术预览，需要下载并安装适合你系统的版本，然后启用 containerd 镜像存储（设置 &amp;gt; 开发中的功能 &amp;gt; 使用 containerd 拉取和存储镜像）。&lt;/li&gt;
&lt;li&gt;这个预览支持使用 WasmEdge 运行时引擎运行 Wasm 容器，并可以通过容器仓库如 DockerHub 等分享。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2023 年 3 月 Docker 公司又发布了 Docker+Wasm 技术预览 2，包括了三个新的 Wasm 运行时引擎：Fermyon 的 spin，Deislabs 的 slight，和 Bytecode Alliance 的 wasmtime。&lt;/p&gt;
&lt;p&gt;该版本的主要更新是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker+Wasm 技术预览 2 是在 Docker Desktop 4.15 版本中发布的，旨在让开发者更容易地运行 Wasm 工作负载，并扩展运行时支持。&lt;/li&gt;
&lt;li&gt;Docker+Wasm 技术预览 2 支持四种 Wasm 运行时引擎，包括之前已经支持的 WasmEdge，以及新增加的 spin，slight，和 wasmtime。&lt;/li&gt;
&lt;li&gt;这四种 Wasm 运行时引擎都基于 runwasi 库，这是一个 Rust 库，可以让容器管理器 containerd 运行 Wasm 工作负载，并创建一种新的容器类型。&lt;/li&gt;
&lt;li&gt;runwasi 库基于 WASI 标准，这是一个为 WebAssembly 提供通用平台接口的模块化系统接口。这意味着如果一个程序编译成目标是 WASI，它就可以在任何符合 WASI 的运行时上运行。&lt;/li&gt;
&lt;li&gt;Wasm 容器通常只包含一个编译好的 Wasm 字节码文件，不需要任何额外的二进制库，这使得它比 Linux 容器更小。这也意味着 Wasm 容器通常启动更快，更可移植。&lt;/li&gt;
&lt;li&gt;由于 Wasm 容器直接被 containerd 支持，在 Docker Desktop 最新版本中尝试 Docker+Wasm 技术预览 2 只需要启用“使用 containerd”选项。&lt;/li&gt;
&lt;li&gt;通过这种方式，Wasm 容器可以与 Linux 容器一起使用 Docker Compose 或其他编排平台如 Kubernetes 运行。&lt;/li&gt;
&lt;li&gt;此外，Docker Desktop 还能够将一个 Wasm 应用打包成一个 OCI 容器，并在其中嵌入一个 Wasm 运行时，以便通过容器仓库如 DockerHub 等分享。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了 Docker 发展过程中的四个重大举措：Moby Project、支持 Kubernetes、删除开源组织账号和增加对 WebAssembly 运行时的支持。其中，Moby Project 旨在推动容器技术走向主流，支持 Kubernetes 的举措提供了更广泛的选择和更好的用户体验，删除开源组织账号的举措引起了开源社区的不满和失望，增加对 WebAssembly 运行时的支持的举措则扩展了 Docker 的应用场景。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/introducing-the-moby-project/&#34; title=&#34;Introducing Moby Project: a new open-source project to advance the software containerization movement&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Moby Project: a new open-source project to advance the software containerization movement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/docker-windows-desktop-now-kubernetes/&#34; title=&#34;Docker for Windows Desktop… Now With Kubernetes!&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker for Windows Desktop… Now With Kubernetes!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/docker-wasm-technical-preview/&#34; title=&#34;Introducing the Docker&amp;#43;Wasm Technical Preview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing the Docker+Wasm Technical Preview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com/blog/announcing-dockerwasm-technical-preview-2/&#34; title=&#34;Announcing Docker&amp;#43;Wasm Technical Preview 2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Announcing Docker+Wasm Technical Preview 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.alexellis.io/docker-is-deleting-open-source-images/&#34; title=&#34;Docker is deleting Open Source organisations - what you need to know&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker is deleting Open Source organisations - what you need to know&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/zh-cn/blog/2020/12/02/dont-panic-kubernetes-and-docker/&#34; title=&#34;别慌：Kubernetes 和 Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;别慌：Kubernetes 和 Docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>CentOS7 官方 Docker 发行版现重大 Bug</title>
      <link>https://jimmysong.io/blog/docker-exec-bug-on-centos7/</link>
      <pubDate>Thu, 06 Dec 2018 21:08:02 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-exec-bug-on-centos7/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/openshift/origin/issues/21590&#34; title=&#34;Cannot ssh into a running pod/container &amp;amp;ndash; rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:247: starting container process caused &amp;amp;ldquo;process_linux.go:110: decoding init error from pipe caused &amp;amp;quot;read parent: connection reset by peer&amp;amp;quot;&amp;amp;rdquo; command terminated with exit code 126 #21590&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cannot ssh into a running pod/container &amp;ndash; rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:247: starting container process caused &amp;ldquo;process_linux.go:110: decoding init error from pipe caused &amp;quot;read parent: connection reset by peer&amp;quot;&amp;rdquo; command terminated with exit code 126 #21590&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;bug-影响&#34;&gt;Bug 影响&lt;/h2&gt;
&lt;p&gt;如果你使用的是 CentOS7，需要用到 &lt;code&gt;kubectl exec&lt;/code&gt; 或者为 Pod 配置了&lt;strong&gt;基于命令返回值&lt;/strong&gt;的健康检查（非常用的 HTTP Get 方式）的话，该 Bug 将导致命令返回错误，Pod 无法正常启动，引起大规模故障，而且也无法使用 &lt;code&gt;kubectl exec&lt;/code&gt; 或者 &lt;code&gt;docker exec&lt;/code&gt; 与容器交互。&lt;/p&gt;
&lt;p&gt;例如下面的健康检查配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;livenessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/local/bin/sidecar-injector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;probe&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;probe-path=/health&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;interval=4s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readinessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/local/bin/sidecar-injector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;probe&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;probe-path=/health&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;interval=4s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failureThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上 YAML 配置摘自 &lt;a href=&#34;https://istio.io/zh&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 发行版中的 &lt;code&gt;istio-demo.yaml&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h2 id=&#34;bug-成因&#34;&gt;Bug 成因&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1655214&#34; title=&#34;RedHat 的 Bug 报告&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RedHat 的 Bug 报告&lt;/a&gt;，导致该 Bug 的原因是：&lt;/p&gt;
&lt;p&gt;CentOS7 发行版中的 Docker 使用的 docker-runc 二进制文件使用旧版本的 golang 构建的，这里面一些可能导致  &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/FIPS_Mode_-_an_explanation&#34; title=&#34;FIPS 模式&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FIPS 模式&lt;/a&gt;崩溃的错误。&lt;/p&gt;
&lt;p&gt;至于该 Bug 是如何触发的官方只是说因为某些镜像导致的。&lt;/p&gt;
&lt;h2 id=&#34;发现过程&#34;&gt;发现过程&lt;/h2&gt;
&lt;p&gt;本周 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-1.13-changelog.html&#34; title=&#34;Kubernetes 1.13&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 1.13&lt;/a&gt; 发布，想着更新下我的 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster&#34; title=&#34;kubernetes-vagrant-centos-cluster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-vagrant-centos-cluster&lt;/a&gt; 使用 Vagrant 和 VirtualBox 在本地搭建分布式 Kubernetes 1.13 集群和 &lt;a href=&#34;https://istio.io/zh&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; Service Mesh 的最新版本 1.0.4，可是在安装 Istio 的时候发现 Istio 有两个 Pod 启动不起来，&lt;code&gt;istio-sidecar-injector&lt;/code&gt; 和 &lt;code&gt;istio-galley&lt;/code&gt; 这两个 Pod，检查其启动过程，发现它们都是因为 Readiness Probe 和 Liveness Probe 失败导致的。再联想到之前安装较老版本的 Istio 的时候也遇到该问题，见 &lt;a href=&#34;https://github.com/istio/istio/pull/6610&#34; title=&#34;Increase health probe interval #6610&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Increase health probe interval #6610&lt;/a&gt; 通过增加健康检查的时间间隔可以解决该问题，可是经过反复的测试后发现还是不行。然后我想到先去掉健康检查，然后我手动使用 &lt;code&gt;kubectl exec&lt;/code&gt; 来执行健康检查的命令，解决却遇到下面的错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; -it istio-sidecar-injector-6fc974b6c8-pts4t -- istio-sidecar-injector-b484dfcbb-9x9l9 probe --probe-path&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/health --interval&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;4s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Cannot ssh into a running pod/container -- rpc error: &lt;span class=&#34;nv&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;desc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; oci runtime error: &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; failed: container_linux.go:247: starting container process caused &lt;span class=&#34;s2&#34;&gt;&amp;#34;process_linux.go:110: decoding init error from pipe caused &amp;#34;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;read&lt;/span&gt; parent: connection reset by peer&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;command&lt;/span&gt; terminated with &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; code &lt;span class=&#34;m&#34;&gt;126&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后直接到 Pod 所在的主机使用 &lt;code&gt;docker exec&lt;/code&gt; 命令执行，依然报上面的错误，我就确定这不是 Kubernetes 的问题了。更何况前之前 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster&#34; title=&#34;kubernetes-vagrant-centos-cluster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-vagrant-centos-cluster&lt;/a&gt; 屡试不爽，突然出现问题，有点让人摸不着头脑。知道我搜到了这个四天前才有人提出的 &lt;a href=&#34;https://github.com/openshift/origin/issues/21590&#34; title=&#34;issue&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue&lt;/a&gt;。根据网友反馈，现在 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster&#34; title=&#34;kubernetes-vagrant-centos-cluster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-vagrant-centos-cluster&lt;/a&gt; 中已经通过降级 Docker 的方式临时修复了该问题，并支持 Kubernetes 1.13 和  Istio 1.0.4，欢迎试用。&lt;/p&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;有两种解决方法，都需要替换 Docker 版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、降级到旧的 RedHat CentOS 官方源中的 Docker 版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 RedHat 官方源中的 Docker 版本降级，这样做的好处是所有的配置无需改动，参考 &lt;a href=&#34;https://github.com/openshift/origin/issues/21590&#34; title=&#34;https://github.com/openshift/origin/issues/21590&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/openshift/origin/issues/21590&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;查看 Docker 版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ rpm -qa &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep -i docker
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-common-1.13.1-84.git07f3374.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-client-1.13.1-84.git07f3374.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-1.13.1-84.git07f3374.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;降级 Docker 版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;yum downgrade docker-1.13.1-75.git8633870.el7.centos.x86_64 docker-client-1.13.1-75.git8633870.el7.centos.x86_64 docker-common-1.13.1-75.git8633870.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;降级之后再查看 Docker 版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ rpm -qa &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep -i docker
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-common-1.13.1-75.git8633870.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-1.13.1-75.git8633870.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-client-1.13.1-75.git8633870.el7.centos.x86_64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此为临时解决方法，RedHat 也在着手解决该问题，为了可能会提供补丁，见 &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1655214&#34; title=&#34;&amp;lt;strong&amp;gt;Bug 1655214&amp;lt;/strong&amp;gt;&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Bug 1655214&lt;/strong&gt;&lt;/a&gt; - docker exec does not work with registry.access.redhat.com/rhel7:7.3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、更新到 Docker-CE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Docker 自 1.13 版本之后更改了版本的命名方式，也提供了官方的 CentOS 源，替换为 Docker-CE 亦可解决该问题，不过 Docker-CE 的配置可能会与 Docker 1.13 有所不同，所以可能需要修改配置文件。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html&#34; title=&#34;配置 Pod 的 liveness 和 readiness 探针 - jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 Pod 的 liveness 和 readiness 探针 - jimmysong.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1655214&#34; title=&#34;Bug 1655214 - docker exec does not work with registry.access.redhat.com/rhel7:7.3 - redhat.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bug 1655214 - docker exec does not work with registry.access.redhat.com/rhel7:7.3 - redhat.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster&#34; title=&#34;kubernetes-vagrant-centos-cluster - github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-vagrant-centos-cluster - github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/FIPS_Mode_-_an_explanation&#34; title=&#34;FIPS Mode - an explanation - mozilla.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FIPS Mode - an explanation - mozilla.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>使用 Wercker 进行持续构建与发布</title>
      <link>https://jimmysong.io/blog/continuous-integration-with-wercker/</link>
      <pubDate>Thu, 22 Jun 2017 18:08:51 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/continuous-integration-with-wercker/</guid>
      <description>
        
        
        &lt;p&gt;本文介绍了 wercker 和它的基本用法，并用我 GitHub 上的&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34; title=&#34;magpie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;magpie&lt;/a&gt;应用作为示例，讲解如何给 GitHub 项目增加 wercker 构建流程，并将生成的镜像自动上传到 Docker Hub 上。&lt;/p&gt;
&lt;p&gt;注：本文参考了&lt;a href=&#34;https://jimmysong.io/book/cloud-native-go&#34; title=&#34;Cloud Native Go&#34;&gt;Cloud Native Go&lt;/a&gt;书中的”持续交付“章节。&lt;/p&gt;
&lt;h2 id=&#34;ci-工具&#34;&gt;CI 工具&lt;/h2&gt;
&lt;p&gt;开源项目的构建离不开 CI 工具，你可能经常会在很多 GitHub 的开源项目首页上看到这样的东西：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-budget_huba1b89127fb4208c8a245a2e816f934a_20467_391x290_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-budget.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-budget.jpg&#34; data-width=&#34;391&#34; data-height=&#34;290&#34; alt=&#34;image&#34; data-caption=&#34;wercker status badge&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;wercker status badge&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;这些图标都是 CI 工具提供的，可以直观的看到当前的构建状态，例如 wercker 中可以在&lt;code&gt;Application&lt;/code&gt;-&lt;code&gt;magpie&lt;/code&gt;-&lt;code&gt;options&lt;/code&gt;中看到：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-status-budge-setting_hu8b8d820bcb4251de94c1093388f41c18_42223_1652x294_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-status-budge-setting.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-status-budge-setting.jpg&#34; data-width=&#34;1652&#34; data-height=&#34;294&#34; alt=&#34;image&#34; data-caption=&#34;wercker status badge 设置&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;wercker status badge 设置&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;将文本框中的代码复制到你的项目的&lt;code&gt;README&lt;/code&gt;文件中，就可以在项目主页上看到这样的标志了。&lt;/p&gt;
&lt;p&gt;现在市面上有很多流行的 CI/CD 工具和 DevOps 工具有很多，这些工具提高了软件开发的效率，增加了开发人员的幸福感。这些工具有：&lt;/p&gt;
&lt;p&gt;适用于 GitHub 上的开源项目，可以直接使用 GitHub 账户登陆，对于公开项目可以直接使用：&lt;a href=&#34;https://travis-ci.org&#34; title=&#34;Travis-ci&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Travis-ci&lt;/a&gt;、&lt;a href=&#34;https://circleci.com&#34; title=&#34;CircleCI&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CircleCI&lt;/a&gt;、&lt;a href=&#34;http://www.wercker.com/&#34; title=&#34;Wercker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wercker&lt;/a&gt;。从目前 GitHub 上开源项目的使用情况来看，Travis-ci 的使用率更高一些。&lt;/p&gt;
&lt;p&gt;适用于企业级的：&lt;a href=&#34;https://jenkins.io/&#34; title=&#34;Jenkins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不仅包括 CI/CD 功能的 DevOps 平台：&lt;a href=&#34;https://www.jfrog.com/&#34; title=&#34;JFrog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JFrog&lt;/a&gt;、&lt;a href=&#34;https://spinnaker.io&#34; title=&#34;Spinnaker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spinnaker&lt;/a&gt;、&lt;a href=&#34;https://fabric8.io&#34; title=&#34;Fabric8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fabric8&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;wercker-简介&#34;&gt;Wercker 简介&lt;/h2&gt;
&lt;p&gt;Wercker 是一家为现代云服务提供容器化应用及微服务的快速开发、部署工具的初创企业，成立于 2012 年，总部位于荷兰阿姆斯特丹。其以容器为中心的平台可以对微服务和应用的开发进行自动化。开发者通过利用其命令行工具能够生成容器到桌面，然后自动生成应用并部署到各种云平台上面。其支持的平台包括 Heroku、AWS 以及 Rackspace 等。&lt;/p&gt;
&lt;p&gt;Wercker 于 2016 年获得 450 万美元 A 轮融资，此轮融资由 Inkef Capital 领投，Notion Capital 跟投，融资所得将用于商业版产品的开发。此轮融资过后其总融资额为 750 万美元。&lt;/p&gt;
&lt;p&gt;Wercker 于 2017 年 4 月被 Oracle 甲骨文于收购。&lt;/p&gt;
&lt;h2 id=&#34;为什么使用-wercker&#34;&gt;为什么使用 Wercker&lt;/h2&gt;
&lt;p&gt;所有的 CI 工具都可以在市面上获取，但为何要建议使用 Wercker 呢？依据云之道的准则评估了所有工具，发现 Wercker 正是我们需要的。&lt;/p&gt;
&lt;p&gt;首先，无须在工作站中安装 Wecker，仅安装一个命令行客户端即可，构建过程全部在云端进行。&lt;/p&gt;
&lt;p&gt;其次，不用通过信用卡就可使用 Wercker。当我们迫切希望简化流程时，这是一件令人赞叹的事。付款承诺这一条件大大增加了开发者的压力，这通常是不必要的。&lt;/p&gt;
&lt;p&gt;最后，Wercker 使用起来非常简单。它非常容易配置，不需要经过高级培训或拥有持续集成的博士学位，也不用制定专门的流程。&lt;/p&gt;
&lt;p&gt;通过 Wercker 搭建 CI 环境只需经过三个基本步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Wercker 网站中创建一个应用程序。&lt;/li&gt;
&lt;li&gt;将 wercker.yml 添加到应用程序的代码库中。&lt;/li&gt;
&lt;li&gt;选择打包和部署构建的位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;可以使用 GitHub 帐号直接登录&lt;a href=&#34;http://www.wercker.com&#34; title=&#34;Wercker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wercker&lt;/a&gt;，整个创建应用 CI 的流程一共 3 步。&lt;/p&gt;
&lt;p&gt;一旦拥有了账户，那么只需简单地点击位于顶部的&lt;strong&gt;应用程序&lt;/strong&gt;菜单，然后选择&lt;strong&gt;创建&lt;/strong&gt;选项即可。如果系统提示是否要创建组织或应用程序，请选择&lt;strong&gt;应用程序&lt;/strong&gt;。Wercker 组织允许多个 Wercker 用户之间进行协作，而无须提供信用卡。下图为设置新应用程序的向导页面。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-create-application_hu4f4070571011ef3b41d0135c0040380b_39319_1856x954_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-create-application.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-create-application.jpg&#34; data-width=&#34;1856&#34; data-height=&#34;954&#34; alt=&#34;image&#34; data-caption=&#34;向导页面&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;向导页面&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;选择了 GitHub 中的 repo 之后，第二步配置访问权限，最后一步 Wercker 会尝试生成一个 wercker.yml 文件（后面会讨论）。不过至少对于 Go 应用程序来说，这个配置很少会满足要求，所以我们总是需要创建自己的 Wercker 配置文件。&lt;/p&gt;
&lt;h2 id=&#34;安装-wercker-命令行程序&#34;&gt;安装 Wercker 命令行程序&lt;/h2&gt;
&lt;p&gt;这一步是可选的，如果你希望在本地进行 wercker 构建的话才需要在本地安装命令行程序。本地构建和云端构建都依赖于 Docker 的使用。基本上，代码会被置于所选择的 docker 镜像中（在 wercker.yml 中定义），然后再选择执行的内容和方法。&lt;/p&gt;
&lt;p&gt;要在本地运行 Wercker 构建，需要使用 Wercker CLI。有关如何安装和测试 CLI 的内容，请查看 &lt;a href=&#34;http://devcenter.wercker.com/docs/cli&#34; title=&#34;http://devcenter.wercker.com/docs/cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://devcenter.wercker.com/docs/cli&lt;/a&gt;。Wercker 更新文档的频率要比本书更高，所以请在本书中做个标记，然后根据 Wercker 网站的文档安装 Wercker CLI。&lt;/p&gt;
&lt;p&gt;如果已经正确安装了 CLI，应该可以查询到 CLI 的版本，代码如下所示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;Version: 1.0.882&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;Compiled at: 2017-06-02 06:49:39 +0800 CST&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;Git commit: da8bc056ed99e27b4b7a1b608078ddaf025a9dc4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;No new version available&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;本地构建只要在项目的根目录下输入&lt;code&gt;wercker build&lt;/code&gt;命令即可，wercker 会自动下载依赖的 docker 镜像在本地运行所有构建流程。&lt;/p&gt;
&lt;h2 id=&#34;创建-wercker-配置文件-werckeryml&#34;&gt;创建 Wercker 配置文件 wercker.yml&lt;/h2&gt;
&lt;p&gt;Wercker 配置文件是一个 YAML 文件，该文件必须在 GitHub repo 的最顶层目录，该文件主要包含三个部分，对应可用的三个主要管道。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dev&lt;/strong&gt;：定义了开发管道的步骤列表。与所有管道一样，可以选定一个&lt;strong&gt;box&lt;/strong&gt;用于构建，也可以全局指定一个 box 应用于所有管道。box 可以是 Wercker 内置的预制 Docker 镜像之一，也可以是 Docker Hub 托管的任何 Docker 镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build&lt;/strong&gt;：定义了在 Wercker 构建期间要执行的步骤和脚本的列表。与许多其他服务（如 Jenkins 和 TeamCity）不同，构建步骤位于代码库的配置文件中，而不是隐藏在服务配置里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deploy&lt;/strong&gt;：在这里可以定义构建的部署方式和位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wercker 中还有&lt;strong&gt;工作流&lt;/strong&gt;的概念，通过使用分支、条件构建、多个部署目标和其他高级功能扩展了管道的功能，这些高级功能读着可以自己在 wercker 的网站中探索。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;我们以我用 Go 语言开发的管理 yarn on docker 集群的命令行工具&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34; title=&#34;magpie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;magpie&lt;/a&gt;为例，讲解如何使用 wercker 自动构建，并产生 docker 镜像发布到 Docker Hub 中。&lt;/p&gt;
&lt;p&gt;下面是 magpie 这个项目中使用的&lt;code&gt;wercker.yml&lt;/code&gt;文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Yaml&#34; data-lang=&#34;Yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;golang&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;steps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Sets the go workspace and places you package&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# at the right place in the workspace tree&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;setup-go-workspace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Gets the dependencies&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;go get&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          go get github.com/rootsongjc/magpie&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Build the project&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;go build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          go build -o magpie main.go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Test the project&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;go test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          go test ./...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;copy files to wercker output &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          cp -R ./ ${WERCKER_OUTPUT_DIR}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deploy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;steps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;internal/docker-push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;$USERNAME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;$PASSWORD &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/pipeline/source/magpie&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;repository&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;jimmysong/magpie&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此文件包含两个管道：build 和 deploy。在开发流程中，我们使用 Wercker 和 Docker 创建一个干净的 Docker 镜像，然后将它 push 到 Docker Hub 中。Wercker 包含一个叫做&lt;code&gt;Internal/docker-push&lt;/code&gt;的 deploy plugin，可以将构建好的 docker 镜像 push 到镜像仓库中，默认是 Docker Hub，也可以配置成私有镜像仓库。&lt;/p&gt;
&lt;p&gt;box 键的值是 golang。这意味着我们使用的是一个基础的 Docker 镜像，它已经安装了 Go 环境。这一点至关重要，因为执行 Wercker 构建的基准 Docker 镜像需要包含应用程序所需的构建工具。&lt;/p&gt;
&lt;p&gt;这部分存在一些难以理解的概念。当使用 Wercker 进行构建时，其实并没有使用本地工作站的资源（即使在技术层面上，构建也是在本地执行的），相反，使用的是 Docker 镜像中的可用资源。因此，如果要使用 Wercker 编译 Go 应用程序，需要首先运行包含 Go 的 Docker 镜像。如果想要构建唯一的工件，无论它是在本地还是在 Wercker 的云端运行，使用 Docker 镜像都是完全合理的。&lt;/p&gt;
&lt;p&gt;本次构建中运行的第一个脚本是 go get。这一步可以 go get 可能需要的、但不包含在基础镜像中的任何东西。无论为脚本设置什么名称，构建输出都会有所显示，如下图所示。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-pipline-output_hue4769d879542641d421b10b42d7416f4_38494_1850x953_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-pipline-output.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-pipline-output.jpg&#34; data-width=&#34;1850&#34; data-height=&#34;953&#34; alt=&#34;image&#34; data-caption=&#34;构建流程输出&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;构建流程输出&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;在 build 管道中，接下来的两个脚本执行的构建和测试流程，最后一个脚本是将构建后的文件拷贝到 wercker 的输出目录中，我们将使用该目录构建 docker 镜像。&lt;/p&gt;
&lt;p&gt;我们注意到 deploy 中有两个变量：&lt;code&gt;$USERNAME&lt;/code&gt;、&lt;code&gt;$PASSWORD&lt;/code&gt;，这是我们自定义的变量，当你不希望将隐私内容直接写在代码中的时候，可以在 wercker 中自定义变量，变量可以只作用于单个 pipeline，也可以是所有 pipeline 共享的。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-enviroment_hu29098a0e79d0348d46d5953d2e361882_87432_1849x811_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-enviroment.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-enviroment.jpg&#34; data-width=&#34;1849&#34; data-height=&#34;811&#34; alt=&#34;image&#34; data-caption=&#34;在 wercker 中设置环境变量&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;在 wercker 中设置环境变量&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;可以将变量设置成&lt;strong&gt;Protected&lt;/strong&gt;模式，这样只有设置者本人才知道该变量的值是什么，其他人即使有共享访问权限，也看不到该变量的值，但可以重新设置来覆盖原值。&lt;/p&gt;
&lt;p&gt;Deploy 管道中配置的 docker 镜像的 repo、tag 和 cmd 命令，其他容器配置都在代码顶层目录的&lt;code&gt;Dockerfile&lt;/code&gt;中定义。当整个构建流程完成后，就可以在 docker 镜像仓库中看到刚构建的镜像&lt;code&gt;jimmysong/magpie:latest&lt;/code&gt;了。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-docker-magpie_huc960b6513f3e1f23a06cbbc89f3d042e_74710_1352x708_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/continuous-integration-with-wercker/wercker-docker-magpie.jpg&#34; data-img=&#34;/blog/continuous-integration-with-wercker/wercker-docker-magpie.jpg&#34; data-width=&#34;1352&#34; data-height=&#34;708&#34; alt=&#34;image&#34; data-caption=&#34;使用 wercker 自动构建的 docker 镜像 magpie&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;使用 wercker 自动构建的 docker 镜像 magpie&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;当然以上只是一个很简单的示例，还有很多可以优化的流程，比如我们在示例使用&lt;code&gt;latest&lt;/code&gt;作为 docker 镜像的 tag，wercker 本身提供了很多内置和构建时&lt;a href=&#34;http://devcenter.wercker.com/docs/environment-variables/available-env-vars&#34; title=&#34;环境变量&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;环境变量&lt;/a&gt;，我们可以在&lt;code&gt;wercker.yml&lt;/code&gt;文件里获取这些变量作为命令中的值。&lt;/p&gt;
&lt;p&gt;当比于其他 CI 工具，wercker 配置简单，更易于使用，同时在 wercker 的 registry 中还可以看到很多别人构建的 pipline 可供参考，还有十分友好的&lt;a href=&#34;http://devcenter.wercker.com/docs/workflows&#34; title=&#34;workflows&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;workflows&lt;/a&gt;可用于编排构建流程和依赖。&lt;/p&gt;
&lt;p&gt;当然 CI 工具的功能不止这些，利用它可以实现很多自动化流程，节约我们的时间，解放生产力，更多玩法就要大家自己去探索了。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://36kr.com/p/5042850.html&#34; title=&#34;容器化应用开发部署平台 Wercker 获 450 万美元 A 轮融资&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;容器化应用开发部署平台 Wercker 获 450 万美元 A 轮融资&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;[http://www.admin5.com/article/20170418/737167.shtml&#34; title=&#34;甲骨文收购创业公司 Wercker 为开发人员自动化代码测试部署&#34;&gt;甲骨文收购创业公司 Wercker 为开发人员自动化代码测试部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://devcenter.wercker.com/docs/home&#34; title=&#34;Wercker docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wercker docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://devcenter.wercker.com/docs/workflows&#34; title=&#34;Wercker workflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wercker workflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34; title=&#34;magpie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;magpie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>容器技术在大数据场景下的应用——YARN on Docker</title>
      <link>https://jimmysong.io/blog/yarn-on-docker/</link>
      <pubDate>Tue, 04 Apr 2017 00:19:04 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/yarn-on-docker/</guid>
      <description>
        
        
        &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;我已就该话题已在 2016 年上海 Qcon 上发表过演讲。另外 InfoQ 网站上的文字版&lt;a href=&#34;https://www.infoq.cn/article/YARNOnDocker-forDCCluster/&#34; title=&#34;数据中心的 YARN on Docker 集群方案&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据中心的 YARN on Docker 集群方案&lt;/a&gt;，即本文。&lt;/p&gt;
&lt;p&gt;项目代码开源在 Github 上：&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34; title=&#34;Magpie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Magpie&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;当前数据中心存在的问题&#34;&gt;当前数据中心存在的问题&lt;/h2&gt;
&lt;p&gt;数据中心中的应用一般独立部署，为了保证环境隔离与方便管理，保证应用最大资源  数据中心中普遍存在如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机资源利用率低&lt;/li&gt;
&lt;li&gt;部署和扩展复杂&lt;/li&gt;
&lt;li&gt;资源隔离无法动态调整&lt;/li&gt;
&lt;li&gt;无法快速响应业务&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为何使用-yarn-on-docker&#34;&gt;为何使用 YARN on Docker&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;彻底隔离队列&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了合理利用 Hadoop YARN 的资源，队列间会互相抢占计算资源，造成重要任务阻塞&lt;/li&gt;
&lt;li&gt;根据部门申请的机器数量划分 YARN 集群方便财务管理&lt;/li&gt;
&lt;li&gt;更细粒度的资源分配 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;统一的资源分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 NodeManager 和容器都可以限定 CPU、内存资源&lt;/li&gt;
&lt;li&gt;YARN 资源划分精确到 CPU 核数和内存大小 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;弹性伸缩性服务&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个容器中运行一个 NodeManager，增减 YARN 资源只需增减容器个数&lt;/li&gt;
&lt;li&gt;可以指定每个 NodeManager 拥有的计算资源多少，按需申请资源 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;给我们带来什么好处&#34;&gt;给我们带来什么好处？ &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Swarm 统一集群资源调度&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一资源&lt;/li&gt;
&lt;li&gt;增加 Docker 虚拟化层，降低运维成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增加 Hadoop 集群资源利用率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于数据中心：避免了静态资源隔离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于集群：加强集群内部资源隔离&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统架构&#34;&gt;系统架构&lt;/h2&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch_hub9c0e50fdb57d51b987a72e16255d0e2_87359_530x908_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_arch.jpg&#34; data-width=&#34;530&#34; data-height=&#34;908&#34; alt=&#34;image&#34; data-caption=&#34;YARN 在 swarm 上运行的架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;YARN 在 swarm 上运行的架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;比如数据中心中运行的 Hadoop 集群，我们将 HDFS 依然运行在物理机上，即 DataNode 依然部署在实体机器上，将 YARN 计算层运行在 Docker 容器中，整个系统使用二层资源调度，Spark、Flink、MapReduce 等应用运行在 YARN 上。&lt;/p&gt;
&lt;p&gt;Swarm 调度最底层的主机硬件资源，CPU 和内存封装为 Docker 容器，容器中运行 NodeManager，提供给 YARN 集群，一个 Swarm 集群中可以运行多个 YARN 集群，形成圈地式的 YARN 计算集群。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch2_hub9c0e50fdb57d51b987a72e16255d0e2_40476_518x328_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch2.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_arch2.jpg&#34; data-width=&#34;518&#34; data-height=&#34;328&#34; alt=&#34;image&#34; data-caption=&#34;YARN 在 Swarm 上的架构之资源分配&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;YARN 在 Swarm 上的架构之资源分配&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;具体流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;swarm node 向 swarm master 注册主机资源并加入到 swarm cluster 中&lt;/li&gt;
&lt;li&gt;swarm master 向 cluster 申请资源请求启动容器&lt;/li&gt;
&lt;li&gt;swarm 根据调度策略选择在某个 node 上启动 docker container&lt;/li&gt;
&lt;li&gt;swarm node 的 docker daemon 根据容器启动参数启动相应资源大小的 NodeManager&lt;/li&gt;
&lt;li&gt;NodeManager 自动向 YARN 的 ResourceManager 注册资源一个 NodeManager 资源添加完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Swarm 为数据中心做容器即主机资源调度，每个 swarmnode 的节点结构如图：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch3_hub9c0e50fdb57d51b987a72e16255d0e2_29441_392x324_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_arch3.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_arch3.jpg&#34; data-width=&#34;392&#34; data-height=&#34;324&#34; alt=&#34;image&#34; data-caption=&#34;YARN 在 swarm 上的架构之单节点资源分配&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;YARN 在 swarm 上的架构之单节点资源分配&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;一个 Swarm node 就是一台物理机，每台主机上可以起多个同类型的 docker container，每个 container 的资源都有限制包括 CPU、内存 NodeManager 容器只需要考虑本身进程占用的资源和需要给主机预留资源。假如主机是 24 核 64G，我们可以分给一个容器 5 核 12G，NodeManager 占用 4 核 10G 的资源提供给 YARN。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes VS Swarm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于容器集群管理系统的选型，用 Kubernetes 还是 Swarm？我们结合自己的经验和业务需求，对比如下：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_compare_hub9c0e50fdb57d51b987a72e16255d0e2_48394_1002x256_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_compare.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_compare.jpg&#34; data-width=&#34;1002&#34; data-height=&#34;256&#34; alt=&#34;image&#34; data-caption=&#34;Kubernetes vs Swarm&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Kubernetes vs Swarm&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;基于以上四点，我们当时选择了 Swarm，它基本满足我们的需求，掌握和开发时常较短。&lt;/p&gt;
&lt;h2 id=&#34;镜像制作与发布&#34;&gt;镜像制作与发布&lt;/h2&gt;
&lt;p&gt;镜像制作和发布流程如下图：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_ci_hub9c0e50fdb57d51b987a72e16255d0e2_47384_732x352_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_ci.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_ci.jpg&#34; data-width=&#34;732&#34; data-height=&#34;352&#34; alt=&#34;image&#34; data-caption=&#34;CI 流程&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;CI 流程&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;用户从客户端提交代码到 Gitlab 中，需要包含 Dockerfile 文件，通过集成了 docker 插件的 Jenkins 的自动编译发布机制，自动 build 镜像后 push 到 docker 镜像仓库中，同一个项目每提交一次代码都会重新 build 一次镜像，生成不同的 tag 来标识镜像，Swarm 集群使用该镜像仓库就可以直接拉取镜像。&lt;/p&gt;
&lt;h3 id=&#34;dockerfile-的编写技巧&#34;&gt;Dockerfile 的编写技巧&lt;/h3&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_dockerfile_hub9c0e50fdb57d51b987a72e16255d0e2_41498_642x236_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_dockerfile.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_dockerfile.jpg&#34; data-width=&#34;642&#34; data-height=&#34;236&#34; alt=&#34;image&#34; data-caption=&#34;Dockerfile 编写技巧&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Dockerfile 编写技巧&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;Dockerfile 相当于 docker 镜像的编译打包流程说明，其中也不乏一些技巧。     &lt;/p&gt;
&lt;p&gt;很多应用需要配置文件，如果想为每次启动容器的时候使用不同的配置参数，可以通过传递环境变量的方式来修改配置文件，前提是需要写一个 bash 脚本，脚本中来处理配置文件，再将这个脚本作为 entrypoint 入口，每当容器启动时就会执行这个脚本从而替换配置文件中的参数，也可以通过 CMD 传递参数给该脚本。&lt;/p&gt;
&lt;p&gt;启动容器的时候通过传递环境变量的方式修改配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Shell&#34; data-lang=&#34;Shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -d 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--net&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;mynet 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-e &lt;span class=&#34;nv&#34;&gt;NAMESERVICE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;nameservice 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-e &lt;span class=&#34;nv&#34;&gt;ACTIVE_NAMENODE_ID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;namenode29 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;STANDBY_NAMENODE_ID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;namenode63 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;HA_ZOOKEEPER_QUORUM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;zk1:2181,zk2:2181,zk3:2181 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;YARN_ZK_DIR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;rmstore &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;YARN_CLUSTER_ID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;yarnRM &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;YARN_RM1_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;rm1 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;YARN_RM2_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;rm2 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;CPU_CORE_NUM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-e &lt;span class=&#34;nv&#34;&gt;NODEMANAGER_MEMORY_MB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12288&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;YARN_JOBHISTORY_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;jobhistory &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;ACTIVE_NAMENODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;active-namenode &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;STANDBY_NAMENODE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;standby-namenode &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;-e &lt;span class=&#34;nv&#34;&gt;HA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;yes &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;docker-registry/library/hadoop-yarn:v0.1 resourcemanager
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后传递 Resource Manager 或者 Node Manager 参数指定启动相应的服务。&lt;/p&gt;
&lt;h2 id=&#34;集群管理&#34;&gt;集群管理&lt;/h2&gt;
&lt;p&gt;我开发的命令行工具&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34; title=&#34;magpie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;magpie&lt;/a&gt;，也可以通过其他开源可视化页面来管理集群，比如 shipyard。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_shipyard_hub9c0e50fdb57d51b987a72e16255d0e2_73793_982x370_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_shipyard.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_shipyard.jpg&#34; data-width=&#34;982&#34; data-height=&#34;370&#34; alt=&#34;image&#34; data-caption=&#34;Shipyard&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;Shipyard&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;自定义网络&#34;&gt;自定义网络&lt;/h2&gt;
&lt;p&gt;Docker 容器跨主机互访一直是一个问题，Docker 官方为了避免网络上带来的诸多麻烦，故将跨主机网络开了比较大的口子，而由用户自己去实现。我们开发并开源了 Shrike 这个 docker 网络插件，大家可以在这里下载到：&lt;a href=&#34;https://github.com/rootsongjc/docker-ipam-plugin&#34; title=&#34;GitHub - docker-ipam-plugin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub - docker-ipam-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前 Docker 跨主机的网络实现方案也有很多种，主要包括端口映射、ovs、fannel 等。但是这些方案都无法满足我们的需求，端口映射服务内的内网 IP 会映射成外网的 IP，这样会给开发带来困惑，因为他们往往在跨网络交互时是不需要内网 IP 的，而 ovs 与 fannel 则是在基础网络协议上又包装了一层自定义协议，这样当网络流量大时，却又无端的增加了网络负载，最后我们采取了自主研发扁平化网络插件，也就是说让所有的容器统统在大二层上互通。架构如下：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_network_hub9c0e50fdb57d51b987a72e16255d0e2_85753_828x434_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_network.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_network.jpg&#34; data-width=&#34;828&#34; data-height=&#34;434&#34; alt=&#34;image&#34; data-caption=&#34;YARN 网络&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;YARN 网络&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;我们首先需要创建一个 br0 自定义网桥，这个网桥并不是通过系统命令手动建立的原始 Linux 网桥，而是通过 Docker 的 cerate network 命令来建立的自定义网桥，这样避免了一个很重要的问题就是我们可以通过设置 DefaultGatewayIPv4 参数来设置容器的默认路由，这个解决了原始 Linux 自建网桥不能解决的问题。用 Docker 创建网络时我们可以通过设置 subnet 参数来设置子网 IP 范围，默认我们可以把整个网段给这个子网，后面可以用 ipamdriver（地址管理插件）来进行控制。还有一个参数 gateway 是用来设置 br0 自定义网桥地址的，其实也就是你这台宿主机的地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Shell&#34; data-lang=&#34;Shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker network create 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--opt&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.docker.network.bridge.enable_icc&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--opt&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.docker.network.bridge.enable_ip_masquerade&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--opt&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.docker.network.bridge.host_binding_ipv4&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.0.0.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--opt&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.docker.network.bridge.name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;br0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--opt&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;com.docker.network.driver.mtu&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1500&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--ipam-driver&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;talkingdata
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--subnet&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;容器IP的子网范围
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--gateway&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;br0网桥使用的IP,也就是宿主机的地址
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--aux-address&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;DefaultGatewayIPv4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;容器使用的网关地址
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mynet
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_ipam_hub9c0e50fdb57d51b987a72e16255d0e2_26678_502x390_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_ipam.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_ipam.jpg&#34; data-width=&#34;502&#34; data-height=&#34;390&#34; alt=&#34;image&#34; data-caption=&#34;IPAM 插件&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;IPAM 插件&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;IPAM 驱动是专门管理 Docker 容器 IP 的，Docker 每次启停与删除容器都会调用这个驱动提供的 IP 管理接口，然后 IP 接口会对存储 IP 地址的 Etcd 有一个增删改查的操作。此插件运行时会起一个 UnixSocket, 然后会在&lt;code&gt;docker/run/plugins&lt;/code&gt;目录下生成一个.sock 文件，Dockerdaemon 之后会和这个 sock 文件进行沟通去调用我们之前实现好的几个接口进行 IP 管理，以此来达到 IP 管理的目的，防止 IP 冲突。 &lt;/p&gt;
&lt;p&gt;通过 Docker 命令去创建一个自定义的网络起名为&lt;code&gt;mynet&lt;/code&gt;，同时会产生一个网桥 br0，之后通过更改网络配置文件（在&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;下 ifcfg-br0、ifcfg-默认网络接口名）将默认网络接口桥接到 br0 上，重启网络后，桥接网络就会生效。Docker 默认在每次启动容器时都会将容器内的默认网卡桥接到 br0 上，而且宿主机的物理网卡也同样桥接到了 br0 上了。其实桥接的原理就好像是一台交换机，Docker 容器和宿主机物理网络接口都是服务器，通过 vethpair 这个网络设备像一根网线插到交换机上。至此，所有的容器网络已经在同一个网络上可以通信了，每一个 Docker 容器就好比是一台独立的虚拟机，拥有和宿主机同一网段的 IP，可以实现跨主机访问了。&lt;/p&gt;
&lt;h2 id=&#34;性能瓶颈与优化&#34;&gt;性能瓶颈与优化&lt;/h2&gt;
&lt;p&gt;大家可能会担心自定义网络的性能问题，为此我们用 iperf 进行了网络性能测试。我们对比了不同主机容器间的网速，同一主机上的不同容器和不同主机间的网速，结果如下表：&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_iperf_hub9c0e50fdb57d51b987a72e16255d0e2_50415_676x364_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_iperf.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_iperf.jpg&#34; data-width=&#34;676&#34; data-height=&#34;364&#34; alt=&#34;image&#34; data-caption=&#34;网络性能对比&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;网络性能对比&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;p&gt;从表中我们可以看到，在这一组测试中，容器间的网速与容器是在想通主机还是在不同主机上的差别不大，说明我们的网络插件性能还是很优异的。 &lt;/p&gt;
&lt;h2 id=&#34;hadoop-配置优化&#34;&gt;Hadoop 配置优化 &lt;/h2&gt;
&lt;p&gt;因为使用 docker 将原来一台机器一个 nodemanager 给细化为了多个，会造成 nodemanager 个数的成倍增加，因此 hadoop 的一些配置需要相应优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;- yarn.nodemanager.localizer.fetch.thread-count 随着容器数量增加，需要相应调整该参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;- yarn.resourcemanager.amliveliness-monitor.interval-ms 默认1秒，改为10秒，否则时间太短可能导致有些节点无法注册&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;- yarn.resourcemanager.resource-tracker.client.thread-count 默认50，改为100，随着容器数量增加，需要相应调整该参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;- yarn.nodemanager.pmem-check-enabled 默认true，改为false，不检查任务正在使用的物理内存量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;- 容器中hadoop ulimit值修改，默认4096，改成655350&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;集群监控&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;如果使用 shipyard 管理集群会有一个单独的监控页面，可以看到一定时间段内的 CPU、内存、IO、网络使用状况。&lt;/p&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_monitor_hub9c0e50fdb57d51b987a72e16255d0e2_32484_722x382_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_monitor.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_monitor.jpg&#34; data-width=&#34;722&#34; data-height=&#34;382&#34; alt=&#34;image&#34; data-caption=&#34;集群监控&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;集群监控&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;关于未来&#34;&gt;关于未来&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_os_hub9c0e50fdb57d51b987a72e16255d0e2_43784_820x374_resize_q75_h2_lanczos.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/yarn-on-docker/td_yarn_os.jpg&#34; data-img=&#34;/blog/yarn-on-docker/td_yarn_os.jpg&#34; data-width=&#34;820&#34; data-height=&#34;374&#34; alt=&#34;image&#34; data-caption=&#34;YARN 的未来&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;YARN 的未来&lt;/figcaption&gt;
  
&lt;/figure&gt;
 &lt;/p&gt;
&lt;p&gt;我们未来规划做的是 DC/OS，基于 Docker 的应用自动打包编译分发系统，让开发人员可以很便捷的申请资源，上下线服务，管理应用。要达到这个目标还有很多事情要做：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Control Panel：统一的根据服务来管理的 web 页面&lt;/li&gt;
&lt;li&gt;Loadbalance：容器根据机器负载情况自动迁移&lt;/li&gt;
&lt;li&gt;Scheduler：swarm 调度策略优化&lt;/li&gt;
&lt;li&gt;服务配置文件：提供镜像启动参数的配置文件，所有启动参数可通过文件配置&lt;/li&gt;
&lt;li&gt;监控：服务级别的监控&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;这篇文章写好的时候是 2016 年 10 月，距离现在我添加&lt;strong&gt;前言&lt;/strong&gt;和&lt;strong&gt;后记&lt;/strong&gt;的已经快半年时间了，这段时间内业界也发生了很多变化，比如 docker 推出 CE 和 SE 版本，Kubernetes 发布了 1.6 版本，人工智能依然大热，在可预见的未来，可以说&lt;u&gt;Kubernetes 一定会远远超越 Docker 成为容器编排领域的王者&lt;/u&gt;，这是毋庸置疑的，对于 docker 17.03-CE 我也研究过了一段时间，其 disgusting 的 plugin 让我对于 Docker 的编排已经失去信心。&lt;/p&gt;
&lt;p&gt;其实当时容器在大数据场景下的应用并不是很多，毕竟 Hadoop 那套笨重的东西放在容器下运行，上生产环境实属不易。如果说做原型验证、研发测试那还可以。这样就大大限制了容器技术在大数据场景下的应用场景。使用容器的编排调度来实现大数据集群的资源优化有点舍本逐末，&lt;u&gt;如果真的要优化集群资源利用率的话，应该让不同的应用混跑，而不应该让集群之间资源隔离，比如 Web 应用跟大数据应用混布。&lt;/u&gt;目前的这种&lt;strong&gt;YARN on Docker&lt;/strong&gt;方案实质上是将原来的整体 Hadoop YARN 集群划分成多个不同的 YARN，将存储和计算分离了。其实这跟&lt;strong&gt;Nutanix&lt;/strong&gt;的超融合架构有点像，Nutanix 是由前 Google 的工程师创立的，解决虚拟化计算环境下的存储问题，也是将存储和计算分离，共享存储，计算根据需要调度。事实上 Yahoo 已经有解决 Hadoop 集群的资源细粒度分配和调度问题的方案，这应该是从 YARN 的 scheduler 层来处理。&lt;/p&gt;
&lt;p&gt;Swarm 已死，Swarmkit 将继续发展，Docker 的 Swarm Mode 还会在艰难中前行，目前看到的趋势仍然是模仿 Kubernentes 为主，没有自己鲜明的特色（除了部署管理方便意外，谁让它就集成在了 Docker 里呢，就像当年 Windows 集成 IE 打败 Netscape，不过这不会再此上演了），Kubernentes 又是一个通用的资源调度框架，它的最小资源划分是&lt;strong&gt;Pod&lt;/strong&gt;而不是 Docker，它还可以运行 rkt、containerd。&lt;/p&gt;
&lt;p&gt;上周起我开始将注意力全部转移到了 Kubernentes，以后请关注我的&lt;a href=&#34;https://jimmysong.io/tags/kubernetes/&#34; title=&#34;Kuberentes 实践&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuberentes 实践&lt;/a&gt;相关文章。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docker 17.03-CE 插件开发案例</title>
      <link>https://jimmysong.io/blog/docker-plugin-develop/</link>
      <pubDate>Wed, 15 Mar 2017 13:57:26 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-plugin-develop/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;当你看到这篇文章时，如果你也正在进行 docker1.13+ 版本下的 plugin 开发，恭喜你也入坑了，如果你趟出坑，麻烦告诉你的方法，感恩不尽🙏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看了文章后你可能会觉得，官网上的可能是个假🌰。&lt;strong&gt;虽然官网上的文档写的有点不对，不过你使用 docker-ssh-volume 的开源代码自己去构建 plugin 的还是可以成功的！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker-plugin-开发文档&#34;&gt;Docker plugin 开发文档&lt;/h2&gt;
&lt;p&gt;首先 docker 官方给出了一个&lt;a href=&#34;https://docs.docker.com/engine/extend/legacy_plugins/&#34; title=&#34;docker legacy plugin 文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker legacy plugin 文档&lt;/a&gt;，这篇文章基本就是告诉你 docker 目前支持哪些插件，罗列了一系列连接，不过对不起，这些不是 docker 官方插件，有问题去找它们的开发者去吧😂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker plugin 貌似开始使用了新的 v2 plugin 了，legacy 版本的 plugin 可以能在后期被废弃。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 docker 的源码&lt;strong&gt;plugin/store.go&lt;/strong&gt;中可以看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* allowV1PluginsFallback determines daemon&amp;#39;s support for V1 plugins.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * When the time comes to remove support for V1 plugins, flipping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * this bool is all that will be needed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;allowV1PluginsFallback&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/* defaultAPIVersion is the version of the plugin API for volume, network,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   IPAM and authz. This is a very stable API. When we update this API, then
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   pluginType should include a version. e.g. &amp;#34;networkdriver/2.0&amp;#34;.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;defaultAPIVersion&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;1.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;随着 docker 公司是的战略调整，推出了 docker-CE 和 docker-EE 之后，未来有些插件就可能要收费了，v2 版本的插件都是在 docker store 中下载了，而这种插件在创建的时候都是打包成 docker image，如果不开放源码的话，你即使 pull 下来插件也无法修改和导出的，&lt;strong&gt;docker plugin 目前没有导出接口&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;真正要开发一个 docker plugin 还是得看&lt;a href=&#34;https://docs.docker.com/engine/extend/plugin_api/&#34; title=&#34;docker plugin API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker plugin API&lt;/a&gt;，这篇文档告诉我们：&lt;/p&gt;
&lt;h3 id=&#34;插件发现&#34;&gt;插件发现&lt;/h3&gt;
&lt;p&gt;当你开发好一个插件&lt;strong&gt;docker engine&lt;/strong&gt;怎么才能发现它们呢？有三种方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;-&lt;/span&gt; **.sock**，linux 下放在/run/docker/plugins 目录下，或该目录下的子目录比如[flocker](https://github.com/ClusterHQ/flocker)插件的`.sock`文件放在`/run/docker/plugins/flocker/flocker.sock`下
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;-&lt;/span&gt; **.spec**，比如**convoy**插件在`/etc/docker/plugins/convoy.spec &lt;span class=&#34;sb&#34;&gt;`定义，内容为`&lt;/span&gt;unix:///var/run/convoy/convoy.sock`
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;-&lt;/span&gt; **.json**，比如**infinit**插件在`/usr/lib/docker/plugins/infinit.json &lt;span class=&#34;sb&#34;&gt;`定义，内容为`&lt;/span&gt;{&amp;#34;Addr&amp;#34;:&amp;#34;https://infinit.sh&amp;#34;,&amp;#34;Name&amp;#34;:&amp;#34;infinit&amp;#34;}`
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文章中的其它部分&lt;strong&gt;貌似都过时&lt;/strong&gt;了，新的插件不是作为&lt;strong&gt;systemd&lt;/strong&gt;进程运行的，而是完全通过&lt;strong&gt;docker plugin&lt;/strong&gt;命令来管理的。&lt;/p&gt;
&lt;p&gt;当你使用**docker plugin enable &amp;lt;plugin_name&amp;gt;**来激活了插件后，理应在&lt;code&gt;/run/docker/plugins&lt;/code&gt;目录下生成插件的&lt;code&gt;.sock&lt;/code&gt;文件，但是现在只有一个以 runc ID 命名的目录，这个问题下面有详细的叙述过程，你也可以跳过，直接看&lt;a href=&#34;https://github.com/docker/docker/issues/31723&#34; title=&#34;issue-31723&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue-31723&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/extend/&#34; title=&#34;docker plugin 管理&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker plugin 管理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-sshfs-volume-plugin&#34;&gt;创建 sshfs volume plugin&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/docker/docker/blob/17.03.x/docs/extend/index.md#developing-a-plugin&#34; title=&#34;官方示例文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方示例文档&lt;/a&gt;（这个文档有问题）&lt;a href=&#34;https://github.com/docker/docker/issues/29886&#34; title=&#34;docker-issue29886&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker-issue29886&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方以开发一个&lt;strong&gt;sshfs&lt;/strong&gt;的 volume plugin 为例。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;docker plugin create&lt;/code&gt;命令的目录下必须包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;config.json&lt;/strong&gt;文件，里面是插件的配置信息，&lt;a href=&#34;https://github.com/docker/docker/blob/17.03.x/docs/extend/config.md&#34; title=&#34;plugin config 参考文档&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;plugin config 参考文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rootfs&lt;/strong&gt;目录，插件镜像解压后的目录。v2 版本的 docker plugin 都是以 docker 镜像的方式包装的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ git clone https://github.com/vieux/docker-volume-sshfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; docker-volume-sshfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ go get github.com/docker/go-plugins-helpers/volume
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ go build -o docker-volume-sshfs main.go  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker build -t rootfsimage .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nv&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;docker create rootfsimage &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# id was cd851ce43a403 when the image was created&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo mkdir -p myplugin/rootfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$id&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tar -x -C myplugin/rootfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker rm -vf &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$id&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker rmi rootfsimage
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到&lt;strong&gt;sshfs&lt;/strong&gt;的 Dockerfile 是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; alpine&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; apk update &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apk add sshfs&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; mkdir -p /run/docker/plugins /mnt/state /mnt/volumes&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; docker-volume-sshfs docker-volume-sshfs&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;docker-volume-sshfs&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上是编译好的可执行文件复制到 alpine linux 容器中运行。&lt;/p&gt;
&lt;p&gt;编译 rootfsimage 镜像的过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t rootfsimage .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Sending build context to Docker daemon 11.71 MB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 1/5 : FROM alpine
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 4a415e366388
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 2/5 : RUN apk update &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apk add sshfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; Running in 1551ecc1c847
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fetch http://dl-cdn.alpinelinux.org/alpine/v3.5/main/x86_64/APKINDEX.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fetch http://dl-cdn.alpinelinux.org/alpine/v3.5/community/x86_64/APKINDEX.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;v3.5.2-2-ge626ce8c3c &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;http://dl-cdn.alpinelinux.org/alpine/v3.5/main&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;v3.5.1-71-gc7bb9a04f0 &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;http://dl-cdn.alpinelinux.org/alpine/v3.5/community&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK: &lt;span class=&#34;m&#34;&gt;7959&lt;/span&gt; distinct packages available
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;1/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing openssh-client &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;7.4_p1-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing fuse &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.9.7-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;3/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing libffi &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;3.2.1-r2&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;4/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing libintl &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;0.19.8.1-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;5/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing libuuid &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.28.2-r1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;6/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing libblkid &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.28.2-r1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;7/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing libmount &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.28.2-r1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing pcre &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8.39-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;9/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing glib &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.50.2-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;10/10&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; Installing sshfs &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;2.8-r0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Executing busybox-1.25.1-r0.trigger
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Executing glib-2.50.2-r0.trigger
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK: &lt;span class=&#34;m&#34;&gt;11&lt;/span&gt; MiB in &lt;span class=&#34;m&#34;&gt;21&lt;/span&gt; packages
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 1a73c501f431
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container 1551ecc1c847
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 3/5 : RUN mkdir -p /run/docker/plugins /mnt/state /mnt/volumes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; Running in 032af3b2595a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 30c7e8463e96
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container 032af3b2595a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 4/5 : COPY docker-volume-sshfs docker-volume-sshfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; a924c6fcc1e4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container ffc5e3c97707
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 5/5 : CMD docker-volume-sshfs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; Running in 0dc938fe4f4e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 0fd2e3d94860
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container 0dc938fe4f4e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully built 0fd2e3d94860
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编写&lt;code&gt;config.json&lt;/code&gt;文档&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Json&#34; data-lang=&#34;Json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sshFS plugin for Docker&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;documentation&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://docs.docker.com/engine/extend/plugins/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;entrypoint&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;/docker-volume-sshfs&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;env&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;DEBUG&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;settable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;interface&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;socket&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;sshfs.sock&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;types&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;docker.volumedriver/1.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;linux&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;capabilities&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s2&#34;&gt;&amp;#34;CAP_SYS_ADMIN&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;devices&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nt&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/dev/fuse&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;mounts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;destination&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/mnt/state&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;options&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;rbind&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;source&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/lib/docker/plugins/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;bind&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;network&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;propagatedmount&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/mnt/volumes&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该插件使用 host 网络类型，使用/run/docker/plugins/sshfs.sock 接口与 docker engine 通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意官网上的这个文档有问题，config.json 与代码里的不符，尤其是 Entrypoint 的二进制文件的位置不对。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;strong&gt;socket&lt;/strong&gt;配置的地址不要写详细地址，默认会在/run/docker/plugins 目录下生成 socket 文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建 plugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;docker plugin create &amp;lt;plugin_name&amp;gt; /path/to/plugin/data/&lt;/code&gt;命令创建插件。&lt;/p&gt;
&lt;p&gt;具体到 sshfs 插件，在 myplugin 目录下使用如下命令创建插件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker plugin create jimmmysong/sshfs:latest .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在就可以看到刚创建的插件了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker plugin ls
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ID                  NAME                 DESCRIPTION               ENABLED
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8aa1f6098fca        jimmysong/sshfs:latest   sshFS plugin &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Docker   &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;push plugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先登录你的 docker hub 账户，然后使用&lt;code&gt;docker plugin push jimmysong/sshfs:latest&lt;/code&gt;即可以推送 docker plugin 到 docker hub 中。&lt;/p&gt;
&lt;p&gt;目前推送到&lt;strong&gt;harbor&lt;/strong&gt;镜像仓库有问题，报错信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c08c951b53b7: Preparing 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;denied: requested access to the resource is denied
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;已给 harbor 提&lt;a href=&#34;https://github.com/vmware/harbor/issues/1532&#34; title=&#34;issue-1532&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue-1532&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;plugin 的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有发现了个问题&lt;a href=&#34;https://github.com/docker/docker/issues/31723&#34; title=&#34;docker issue-31723&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker issue-31723&lt;/a&gt;，使用 plugin 创建 volume 的时候居然找不到&lt;code&gt;sshfs.sock&lt;/code&gt;文件！😢刚开始手动创建 plugin 的时候测试了下是正常的，不知道为啥弄到这台测试机器上出问题了。&lt;/p&gt;
&lt;h2 id=&#34;关于-docker-plugin-enable-失败的问题&#34;&gt;关于 docker plugin enable 失败的问题&lt;/h2&gt;
&lt;p&gt;当 docker  plugin 创建成功并 enable 的时候 docker 并没有报错，这与 docker plugin 的&lt;strong&gt;activate&lt;/strong&gt;机制有关，只有当你最终使用该 plugin 的时候才会激活它。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;sshfs&lt;/strong&gt;插件创建 volume。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker volume create -d jimmysong/sshfs --name sshvolume -o &lt;span class=&#34;nv&#34;&gt;sshcmd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1.2.3.4:/remote -o &lt;span class=&#34;nv&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;password
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;报错如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Error response from daemon: create sshvolume: Post http://%2Frun%2Fdocker%2Fplugins%2F8f7b8f931b38a4ef53d0e4f8d738e26e8f10ef8bd26c8244f4b8dcc7276b685f%2Fsshfs.sock/VolumeDriver.Create: dial unix /run/docker/plugins/8f7b8f931b38a4ef53d0e4f8d738e26e8f10ef8bd26c8244f4b8dcc7276b685f/sshfs.sock: connect: no such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Docker daemon 在 enable 这个插件的时候会寻找这个**.sock**文件，然后在自己的 plugindb 中注册它，相关代码在这个文件里：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;https://github.com/docker/docker/blob/17.03.x/plugin/manager_linux.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相关代码片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;enable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Plugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;force&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pluginPostStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pluginPostStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Plugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//这里需要获取.sock文件的地址 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//pm.conifg.ExecRoot就是/run/docker/plugins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//p.GetID()返回的就是很长的那串plugin ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;sockAddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;filepath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ExecRoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetSocket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientWithTimeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unix://&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sockAddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeoutInSecs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;shutdownPlugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;containerdClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetPClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;maxRetries&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;retries&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;retries&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;retries&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxRetries&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;logrus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Debugf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;error net dialing plugin: %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;shutdownPlugin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;containerdClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;// net dial into the unix socket to see if someone&amp;#39;s listening.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Dial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unix&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sockAddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CallHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;save&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意这段代码里的&lt;strong&gt;sockAddr := filepath.Join(pm.config.ExecRoot, p.GetID(), p.GetSocket())&lt;/strong&gt;，我在上面添加了注释。&lt;/p&gt;
&lt;p&gt;这个**.sock&lt;strong&gt;文件应该有 docker plugin 来生成，具体怎样生成的呢？还以&lt;/strong&gt;docker-volume-ssh**这个插件为例。&lt;/p&gt;
&lt;p&gt;整个项目就一个&lt;strong&gt;main.go&lt;/strong&gt;文件，里面最后一行生成了**/run/docker/plugins/sshfs.sock**这个 sock。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;logrus.Error(h.ServeUnix(socketAddress, 0))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这行代码调用&lt;strong&gt;docker/go-plugin-helpers/sdk/handler.go&lt;/strong&gt;中的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ServeUnix makes the handler to listen for requests in a unix socket.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// It also creates the socket file on the right directory for docker to read.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ServeUnix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gid&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newUnixListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;spec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Serve sets up the handler to serve requests on the passed in listener
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//unix_listener_unsupoorted.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newUnixListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginName&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gid&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;errOnlySupportedOnLinuxAndFreeBSD&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看了上面这这些，你看出 socket 文件是怎么创建的吗？&lt;/p&gt;
&lt;p&gt;这又是一个&lt;a href=&#34;https://github.com/vieux/docker-volume-sshfs/issues/19&#34; title=&#34;issue-19&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue-19&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你修改&lt;strong&gt;config.json&lt;/strong&gt;文件，将其中的&lt;strong&gt;interfaces - socket&lt;/strong&gt;指定为&lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt;然后创建 plugin，则能成功生成 socket 文件，但是当你 enable 它的时候又会报错&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Error response from daemon: Unix socket path &amp;#34;/run/docker/plugins/ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7/run/docker/plugins/sshfs.sock&amp;#34; is too long
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 docker daemon 的日志里可以看到详细报错：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mar &lt;span class=&#34;m&#34;&gt;13&lt;/span&gt; 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;51757&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: &lt;span class=&#34;nv&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2017-03-13T17:15:20+08:00&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;info &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;standard_init_linux.go:178: exec user process caused \&amp;#34;no such file or directory\&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;plugin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mar &lt;span class=&#34;m&#34;&gt;13&lt;/span&gt; 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;51757&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: &lt;span class=&#34;nv&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2017-03-13T17:15:20.321277088+08:00&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;error &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Sending SIGTERM to plugin failed with error: rpc error: code = 2 desc = no such process&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mar &lt;span class=&#34;m&#34;&gt;13&lt;/span&gt; 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;51757&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: &lt;span class=&#34;nv&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2017-03-13T17:15:20.321488680+08:00&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;error &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Handler for POST /v1.26/plugins/sshfs/enable returned error: Unix socket path \&amp;#34;/run/docker/plugins/ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7/run/docker/plugins/sshfs.sock\&amp;#34; is too long\ngithub.com/docker/docker/plugin.(*Manager).pluginPostStart\n\t/root/rpmbuild/BUILD/docker-engine/.gopath/src/github.com/docker/docker/plugin/manager_linux.go:84\ngithub.com/docker/docker/plugin.(*Manager).enable\n\t/root/rpmbuild/BUILD/docker-
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正好验证了上面的&lt;strong&gt;enable&lt;/strong&gt;代码，docker 默认是到&lt;code&gt;/run/docker/plugins&lt;/code&gt;目录下找&lt;strong&gt;sshfs.sock&lt;/strong&gt;这个文件的。&lt;/p&gt;
&lt;p&gt;我在 docker daemon 中发现一个很诡异的错误，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Mar &lt;span class=&#34;m&#34;&gt;13&lt;/span&gt; 17:29:41 sz-pg-oam-docker-test-001.tendcloud.com dockerd&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;51757&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: &lt;span class=&#34;nv&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2017-03-13T17:29:41+08:00&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;info &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;standard_init_linux.go:178: exec user process caused \&amp;#34;no such file or directory\&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;plugin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;85760810b4850009fc965f5c20d8534dc9aba085340a2ac0b4b9167a6fef7d53
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我查看了下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;github.com/libnetwork/vendor/github.com/opencontainers/run/libcontainer/standard_init_linux.go
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文件，这个那个文件只有 114 行，见&lt;a href=&#34;https://github.com/docker/libnetwork/blob/master/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go&#34; title=&#34; standard_init_linux.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; standard_init_linux.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是在&lt;strong&gt;opencontainers&lt;/strong&gt;的 github 项目里才有那么多行，见 &lt;a href=&#34;https://github.com/opencontainers/runc/blob/master/libcontainer/standard_init_linux.go&#34; title=&#34;standard_init_linux.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;standard_init_linux.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个报错前后的函数是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// PR_SET_NO_NEW_PRIVS isn&amp;#39;t exposed in Golang so we define it ourselves copying the value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// the kernel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PR_SET_NO_NEW_PRIVS&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x26&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;linuxStandardInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NoNewKeyring&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;ringname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;keepperms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newperms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getSessionRingParams&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;// do not inherit the parent&amp;#39;s session keyring
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;sessKeyId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;JoinSessionKeyring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ringname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;// make session keyring searcheable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ModKeyringPerm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sessKeyId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;keepperms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newperms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Seccomp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NoNewPrivileges&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;c1&#34;&gt;//下面这行是第178行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;seccomp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;InitSeccomp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Seccomp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newSystemErrorWithCause&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;init seccomp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// close the statedir fd before exec because the kernel resets dumpable in the wrong order
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;syscall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stateDirFD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;syscall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newSystemErrorWithCause&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;exec user process&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结论&#34;&gt;&lt;del&gt;结论&lt;/del&gt;&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;到此了问题还没解决。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;问题的关键是执行&lt;strong&gt;docker create plugin&lt;/strong&gt;之后**.sock&lt;strong&gt;文件创建到哪里去了？为什么在&lt;/strong&gt;config.json&lt;strong&gt;指定成&lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt;就可以在指定的目录下创建出.sock 文件，说明&lt;/strong&gt;创建 socket 的定义和 get socket 时寻找的路径不一样**，创建 socket 时就是固定在/run/docker/plugins 目录下创建，而 enable plugin 的时候，Get socket 的时候还要加上 docker plugin 的 ID，可是按照官网的配置在本地 create plugin 后并没有在/run/docker/plugins 目录下生成插件的 socket 文件，直到 enable 插件的时候才会生成以 plugin ID 命名的目录，但是 socket 文件没有！☹️&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;问题解决&#34;&gt;问题解决&lt;/h2&gt;
&lt;p&gt;之所以出现上面的那些问题，是因为 create docker plugin 的时候有问题，也就是那个二进制文件有问题，我在&lt;strong&gt;Mac&lt;/strong&gt;上 build 的 image，而且还没有用&lt;strong&gt;Dockerfile.dev&lt;/strong&gt;这个专门用来搭建二进制文件编译环境的 Dockerfile 来创建 golang 的编译环境，虽然 docker plugin 是创建成功了，但是当 docker plugin enable 的时候，这个热紧张文件不能正确的运行，所以就没能生成&lt;strong&gt;sshfs.sock&lt;/strong&gt;文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请在 Linux 环境下使用&lt;strong&gt;make all&lt;/strong&gt;命令来创建 plugin。&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Docker 对比 Kubernetes 第二部分</title>
      <link>https://jimmysong.io/blog/docker-vs-kubernetes-part2/</link>
      <pubDate>Fri, 10 Mar 2017 22:06:32 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-vs-kubernetes-part2/</guid>
      <description>
        
        
        &lt;p&gt;本文是&lt;code&gt;Docker v.s Kubernetes &lt;/code&gt;系列第二篇，续接上文&lt;a href=&#34;https://jimmysong.io/blog/docker-vs-kubernetes-part1/&#34; title=&#34;Docker 对比 Kuberntes 第一部分&#34;&gt;Docker 对比 Kuberntes 第一部分&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 是典型的&lt;strong&gt;Master/Slave&lt;/strong&gt;架构模式，本文简要的介绍 kubenetes 的架构和组件构成。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-核心架构&#34;&gt;Kubernetes 核心架构&lt;/h2&gt;
&lt;h3 id=&#34;master-节点&#34;&gt;master 节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;apiserver：作为 kubernetes 系统的入口，封装了核心对象的增删改查操作，以 RESTFul 接口方式提供给外部客户和内部组件调用。它维护的 REST 对象将持久化到 etcd（一个分布式强一致性的 key/value 存储）。&lt;/li&gt;
&lt;li&gt;scheduler：负责集群的资源调度，为新建的 Pod 分配机器。这部分工作分出来变成一个组件，意味着可以很方便地替换成其他的调度器。&lt;/li&gt;
&lt;li&gt;controller-manager：负责执行各种控制器，目前有两类：
&lt;ol&gt;
&lt;li&gt;endpoint-controller：定期关联 service 和 Pod(关联信息由 endpoint 对象维护)，保证 service 到 Pod 的映射总是最新的。&lt;/li&gt;
&lt;li&gt;replication-controller：定期关联 replicationController 和 Pod，保证 replicationController 定义的复制数量与实际运行 Pod 的数量总是一致的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;node-节点&#34;&gt;node 节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;kubelet：负责管控 docker 容器，如启动/停止、监控运行状态等。它会定期从 etcd 获取分配到本机的 Pod，并根据 Pod 信息启动或停止相应的容器。同时，它也会接收 apiserver 的 HTTP 请求，汇报 Pod 的运行状态。&lt;/li&gt;
&lt;li&gt;proxy：负责为 Pod 提供代理。它会定期从 etcd 获取所有的 service，并根据 service 信息创建代理。当某个客户 Pod 要访问其他 Pod 时，访问请求会经过本机 proxy 做转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;mx-auto text-center&#34;&gt;
  
  
  
    
      
        
          
          &lt;picture&gt;
           &lt;source srcset=&#34;https://jimmysong.io/blog/docker-vs-kubernetes-part2/kubernetes-masterslave_hu4e54eea13006228807598531a76b4a3e_35433_928x768_resize_q75_h2_lanczos_3.webp&#34; type=&#34;image/webp&#34;&gt;
           &lt;img src=&#34;https://jimmysong.io/blog/docker-vs-kubernetes-part2/kubernetes-masterslave.png&#34; data-img=&#34;/blog/docker-vs-kubernetes-part2/kubernetes-masterslave.png&#34; data-width=&#34;928&#34; data-height=&#34;768&#34; alt=&#34;image&#34; data-caption=&#34;master slave 架构&#34;&gt;
          &lt;/picture&gt;
        
      
    
  
  
  &lt;figcaption&gt;master slave 架构&lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;h2 id=&#34;kubernetes-组件详细介绍&#34;&gt;Kubernetes 组件详细介绍&lt;/h2&gt;
&lt;h3 id=&#34;etcd&#34;&gt;etcd&lt;/h3&gt;
&lt;p&gt;虽然不是 Kubernetes 的组件但是有必要提一下，etcd 是一个分布式协同数据库，基于 Go 语言开发，&lt;code&gt;CoreOS&lt;/code&gt;公司出品，使用 raft 一致性算法协同。Kubernetes 的主数据库，在安装 kubernetes 之前就要先安装它，很多开源下项目都用到，老版本的&lt;code&gt;docker swarm&lt;/code&gt;也用到了它。目前主要使用的是&lt;code&gt;2.7.x&lt;/code&gt;版本，&lt;code&gt;3.0+&lt;/code&gt;版本的 API 变化太大。&lt;/p&gt;
&lt;h3 id=&#34;apiserver&#34;&gt;APIServer&lt;/h3&gt;
&lt;p&gt;APIServer 负责对外提供 kubernetes API 服务，它运行在 master 节点上。任何对资源的增删改查都要交给 APIServer 处理后才能提交给 etcd。APIServer 总体上由两部分组成：HTTP/HTTPS 服务和一些功能性插件。这些功能性插件又分为两种：一部分与底层 IaaS 平台（Cloud Provide）相关；另一部分与资源管理控制（Admission Control）相关。&lt;/p&gt;
&lt;h3 id=&#34;scheduler&#34;&gt;Scheduler&lt;/h3&gt;
&lt;p&gt;Scheduler 的作用是&lt;strong&gt;根据特定的调度算法将 pod 调度到 node 节点上&lt;/strong&gt;，这一过程也被称为绑定。Scheduler 调度器的输入是待调度的 pod 和可用的工作节点列表，输出则是一个已经绑定了 pod 的节点，这个节点是通过调度算法在工作节点列表中选择的最优节点。&lt;/p&gt;
&lt;p&gt;工作节点从哪里来？工作节点并不是由 Kubernetes 创建，它是由 IaaS 平台创建，或者就是由用户管理的物理机或者虚拟机。但是 Kubernetes 会创建一个 Node 对象，用来描述这个工作节点。描述的具体信息由创建 Node 对象的配置文件给出。一旦用户创建节点的请求被成功处理，Kubernetes 又会立即在内部创建一个 node 对象，再去检查该节点的健康状况。只有那些当前可用的 node 才会被认为是一个有效的节点并允许 pod 调度到上面运行。&lt;/p&gt;
&lt;p&gt;工作节点可以通过资源配置文件或者 kubectl 命令行工具来创建。Kubernetes 主要维护工作节点的两个属性：spec 和 status 来描述一个工作节点的期望状态和当前状态。其中，所谓的当前状态信息由 3 个信息组成：&lt;code&gt;HostIp&lt;/code&gt;、&lt;code&gt;NodePhase&lt;/code&gt;和&lt;code&gt;Node Condition&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;工作节点的动态维护过程依靠&lt;strong&gt;Node Controller&lt;/strong&gt;来完成，它是&lt;code&gt;Kubernetes Controller Manager&lt;/code&gt;下属的一个控制器。它会一直不断的检查 Kubernetes 已知的每台 node 节点是否正常工作，如果一个之前已经失败的节点在这个检查循环中被检查为可以工作的，那么 Node Controller 会把这个节点添加到工作节点中，Node Controller 会从工作节点中删除这个节点。&lt;/p&gt;
&lt;h3 id=&#34;controller-manager&#34;&gt;Controller Manager&lt;/h3&gt;
&lt;p&gt;Controller Manager 运行在集群的 Master 节点上，是基于 pod API 的一个独立服务，它&lt;strong&gt;重点实现 service Endpoint（服务端点）的动态更新&lt;/strong&gt;。管理着 Kubernetes 集群中各种控制节点，包括&lt;strong&gt;replication Controller&lt;/strong&gt;和&lt;strong&gt;node Controller&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与 APIServer 相比，APIServer 负责接受用户请求并创建对应的资源，而 Controller Manager 在系统中扮演的角色是在一旁旁默默的管控这些资源，确保他们永远保持在预期的状态&lt;/strong&gt;。它采用各种管理器定时的对 pod、节点等资源进行预设的检查，然后判断出于预期的是否一致，若不一致，则通知 APIServer 采取行动，比如重启、迁移、删除等。&lt;/p&gt;
&lt;h3 id=&#34;kubelet&#34;&gt;kubelet&lt;/h3&gt;
&lt;p&gt;kubelet 组件工作在 Kubernetes 的 node 上，&lt;strong&gt;负责管理和维护在这台主机上运行着的所有容器&lt;/strong&gt;。kubelet 与 cAdvisor 交互来抓取 docker 容器和主机的资源信息。kubelet 垃圾回收机制，包括容器垃圾回收和镜像垃圾回收。kubelet 工作节点状态同步。&lt;/p&gt;
&lt;h3 id=&#34;kube-proxy&#34;&gt;kube-proxy&lt;/h3&gt;
&lt;p&gt;kube-proxy 提供两种功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供算法将客服端流量负载均衡到 service 对应的一组后端 pod。&lt;/li&gt;
&lt;li&gt;使用 etcd 的 watch 机制，实现服务发现功能，维护一张从 service 到 endpoint 的映射关系，从而保证后端 pod 的 IP 变化不会对访问者的访问造成影响。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docker 对比 Kubernetes 第一部分</title>
      <link>https://jimmysong.io/blog/docker-vs-kubernetes-part1/</link>
      <pubDate>Fri, 10 Mar 2017 21:09:47 +0800</pubDate>
      
      <guid>https://jimmysong.io/blog/docker-vs-kubernetes-part1/</guid>
      <description>
        
        
        &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这一系列文章是对比 kubernetes 和 docker 两者之间的差异，鉴于我之前从 docker1.10.3 起开始使用 docker，对原生 docker 的了解比较多，最近又正在看《Kunernetes 权威指南（第二版）》这本书（P.S 感谢电子工业出版社的编辑朋友赠送此书）。这系列文章不是为了比较孰优孰劣，&lt;strong&gt;适合自己的才是最好的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此系列文章中所说的 Docker 指的是 &lt;code&gt;17.03-ce&lt;/code&gt; 版本。&lt;/p&gt;
&lt;h2 id=&#34;概念性的差别&#34;&gt;概念性的差别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解一样东西首先要高屋建瓴的了解它的概念，kubernetes 包括以下几种资源对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Volume&lt;/li&gt;
&lt;li&gt;Namespace&lt;/li&gt;
&lt;li&gt;ReplicaSet&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;li&gt;DaemonSet&lt;/li&gt;
&lt;li&gt;Job&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 的资源对象相对于 kubernetes 来说就简单多了，只有以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Node&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就这么简单，使用一个 &lt;em&gt;docker-compose.yml&lt;/em&gt; 即可以启动一系列服务。当然简单的好处是便于理解和管理，但是在功能方面就没有 kubernetes 那么强大了。&lt;/p&gt;
&lt;h2 id=&#34;功能性差别&#34;&gt;功能性差别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 资源限制 CPU 100m 千分之一核为单位，绝对值，requests 和 limits，超过这个值可能被杀掉，资源限制力度比 docker 更细。&lt;/li&gt;
&lt;li&gt;Pod 中有个最底层的 pause 容器，其他业务容器共用他的 IP，docker 因为没有这层概念，所以没法共用 IP，而是使用 overlay 网络同处于一个网络里来通信。&lt;/li&gt;
&lt;li&gt;Kubernetes 在 rc 中使用环境变量传递配置（1.3 版本是这样的，后续版本还没有研究过）&lt;/li&gt;
&lt;li&gt;Kuberentes Label 可以在开始和动态的添加修改，所有的资源对象都有，这一点 docker 也有，但是资源调度因为没有 kubernetes 那么层级，所有还是相对比较弱一些。&lt;/li&gt;
&lt;li&gt;Kubernetes 对象选择机制继续通过 label selector，用于对象调度。&lt;/li&gt;
&lt;li&gt;Kubernetes 中有一个比较特别的镜像，叫做 &lt;code&gt;google_containers/pause&lt;/code&gt;，这个镜像是用来实现 Pod 概念的。&lt;/li&gt;
&lt;li&gt;HPA horizontal pod autoscaling 横向移动扩容，也是一种资源对象，根据负载变化情况针对性的调整 pod 目标副本数。&lt;/li&gt;
&lt;li&gt;Kubernetes 中有三个 IP，Node,Pod,Cluster IP 的关系比较复杂，docker 中没有 Cluster IP 的概念。&lt;/li&gt;
&lt;li&gt;持久化存储，在 Kubernetes 中有 Persistent volume 只能是网络存储，不属于任何 node，独立于 pod 之外，而 docker 只能使用 &lt;code&gt;volume plugin&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;多租户管理，kubernetes 中有 `Namespace，docker 暂时没有多租户管理功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说 Docker 架构更加简单，使用起来也没有那么多的配置，只需要每个结点都安装 docker 即可，调度和管理功能没 kubernetes 那么复杂。但是 kubernetes 本身就是一个通用的数据中心管理工具，不仅可以用来管理 docker，&lt;em&gt;pod&lt;/em&gt; 这个概念里就可以运行不仅是 docker 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以后的文章中将结合 docker 着重讲 Kubernetes，基于 1.3 版本。&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
  </channel>
</rss>
