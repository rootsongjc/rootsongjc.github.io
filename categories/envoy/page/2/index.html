<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  
  <title>Envoy 专栏 - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="在 Envoy 专栏中，我将分享关于 Envoy 代理和网关的深入分析和实战经验。无论是流量管理、服务发现还是负载均衡，Envoy 都是现代服务架构中的关键组件。最近，我特别关注 Envoy Gateway，探索它如何优化微服务通信。欢迎与我一起深入了解和讨论 Envoy 的各种应用场景和最佳实践。">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/categories/envoy/" />
  <meta property="og:title" content="Envoy 专栏 | Jimmy Song" />
  <meta property="twitter:title" content="Envoy 专栏 | Jimmy Song" />

  
  <meta property="og:description" content="在 Envoy 专栏中，我将分享关于 Envoy 代理和网关的深入分析和实战经验。无论是流量管理、服务发现还是负载均衡，Envoy 都是现代服务架构中的关键组件。最近，我特别关注 Envoy Gateway，探索它如何优化微服务通信。欢迎与我一起深入了解和讨论 Envoy 的各种应用场景和最佳实践。" />
  <meta property="twitter:description" content="在 Envoy 专栏中，我将分享关于 Envoy 代理和网关的深入分析和实战经验。无论是流量管理、服务发现还是负载均衡，Envoy 都是现代服务架构中的关键组件。最近，我特别关注 Envoy Gateway，探索它如何优化微服务通信。欢迎与我一起深入了解和讨论 Envoy 的各种应用场景和最佳实践。" />

  
  <meta property="og:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />
  <meta property="twitter:image" content="https://jimmysong.io/images/backgrounds/favicon.png" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/blog">博客</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/book">资料</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/tags">标签</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/notice">公告</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/contact">联系</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/about">关于</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/community/">社区</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener">视频 <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i></a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    <a class="nav-link" href="/en/categories/envoy/">English</a>
                    
                  
                
              
              
              
                
                  
                    
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>搜索</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>站内搜索</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="关闭"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="请输入搜索词" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="请输入搜索词">
        
        <div class="mt-4">
          <span>搜索类型: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">所有</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">原创</label>
              <input type="radio" id="trans" name="search_type" value="trans">
              <label for="trans">译文</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">资料</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">公告</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Envoy 专栏
                </p>
                <p class="page-description">
                    在 Envoy 专栏中，我将分享关于 Envoy 代理和网关的深入分析和实战经验。无论是流量管理、服务发现还是负载均衡，Envoy 都是现代服务架构中的关键组件。最近，我特别关注 Envoy Gateway，探索它如何优化微服务通信。欢迎与我一起深入了解和讨论 Envoy 的各种应用场景和最佳实践。
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/migrating-millions-of-concurrent-websockets-to-envoy/">[译] Slack 将数百万个并发的 Websockets 迁移到 Envoy 上经验分享</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2022/04/08</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://slack.engineering/migrating-millions-of-concurrent-websockets-to-envoy/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Slack 将数百万个并发的 Websockets 迁移到 Envoy 上经验分享', '本文是 Slack 花半年时间从 HAProxy 迁移到 Envoy 上的经验分享。', '本文译自 [Migrating Millions of Concurrent Websockets to Envoy](https:\/\/slack.engineering\/migrating-millions-of-concurrent-websockets-to-envoy\/)，原文发布于 2021 年。作者是 **Ariane van der Steldt** Staff Software Engineer, Site Reliability，**Radha Kumari** Sr. Software Engineer, Site Reliability。\n\nSlack 有一个全球客户群，在高峰期有数百万同时连接的用户。用户之间的大部分通信涉及到向对方发送大量的微小信息。在 Slack 的大部分历史中，我们一直使用 [HAProxy](https:\/\/www.haproxy.com\/) 作为所有传入流量的负载均衡器。今天，我们将讨论我们在使用 HAProxy 时所面临的问题，我们如何用 [Envoy Proxy](https:\/\/www.envoyproxy.io\/) 来解决这些问题，迁移所涉及的步骤，以及结果是什么。让我们开始吧！\n\n## **Slack 的 Websockets**\n\n为了即时传递信息，我们使用 [websocket 连接](https:\/\/tools.ietf.org\/html\/rfc6455)，这是一种双向的通信链接，负责让你看到 \u0022有几个人在打字......\u0022，然后是他们打的东西，速度几乎是光速的。websocket 连接被摄取到一个叫做 \u0022wss\u0022（WebSocket 服务）的系统中，可以通过 \u0060wss-primary.slack.com\u0060 和 \u0060wss-backup.slack.com\u0060（这不是网站，如果去访问，只会得到一个 HTTP 404）从互联网上访问。\n\n![显示 websockets 工作原理的图表](e6c9d24ely1h1277posyqj20cg0b8dfz.jpg)\n\nWebsocket 连接一开始是普通的 HTTPS 连接，然后客户端发出协议切换请求，将连接升级为 Websocket。在 Slack，我们有不同的 websocket 服务，专门用于消息、在线（列出哪些联系人在线）和其他服务。其中一个 websocket 端点是专门为需要与 Slack 互动的应用程序制作的（因为应用程序也想要实时通信）。\n\n![解释流量如何被路由到后端服务的流程图](e6c9d24ely1h1277nk5l3j20hr0bbq3e.jpg)\n\n过去，我们在多个 [AWS](https:\/\/aws.amazon.com\/) Region 有一组专门用于 websockets 的 HAProxy 实例，以终止靠近用户的 websocket 连接，并将请求转发给相应的后端服务。\n\n## **迁移到 Envoy Proxy 的动机**\n\n虽然我们从 Slack 开始就一直在使用 HAproxy，并且知道如何大规模地操作它，但有一些操作上的挑战让我们考虑替代方案，比如 Envoy Proxy。\n\n### **热重启**\n\n在 Slack，后端服务端点列表的变化是一个常见的事件（由于实例被添加或删除）。HAProxy 提供两种方法来更新其配置，以适应端点列表的变化。一种是使用 HAProxy Runtime API。我们在其中一套 HAProxy 实例中使用了这种方法，我们的经验在另一篇博文中有所描述 —— [在 Slack 的可怕的、恐怖的、没有好处的、非常糟糕的一天](https:\/\/slack.engineering\/a-terrible-horrible-no-good-very-bad-day-at-slack\/)。另一种方法，我们用于 websockets 负载均衡器（LB），是将后端渲染到 HAProxy 配置文件中，然后重新加载 HAProxy。\n\n每次 HAProxy 重载时，都会创建一组新的进程来处理新进入的连接。我们会让旧的进程持续运行很多小时，以便让长寿的 websocket 连接耗尽，避免用户频繁断开连接。然而，我们不能有太多的 HAProxy 进程，每个进程都运行着它自己 \u0022当时\u0022 的配置副本 —— 我们希望实例能更快地汇聚到新版本的配置上。我们不得不定期收割旧的 HAProxy 进程，并限制 HAProxy 重新加载的频率，以防底层后端出现混乱。\n\n无论我们使用哪种方法，都需要一些额外的基础设施来管理 HAProxy 的重新加载。\n\nEnvoy 允许我们使用[动态配置的集群和端点](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#arch-overview-service-discovery-types-eds)，这意味着如果端点列表发生变化，它不需要重新加载。如果代码或配置确实发生了变化，Envoy 有能力在不放弃任何连接的情况下[热重启](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/operations\/hot_restart)自己。Envoy 通过 [inotify](https:\/\/en.wikipedia.org\/wiki\/Inotify) 观察文件系统配置的更新。在热重启过程中，Envoy 还将统计数据从父进程复制到子进程中，因此仪表和计数器不会被重置。\n\n这一切都使 Envoy 的运营开销大大减少，而且不需要额外的服务来管理配置变化或重新启动。\n\n### **负载均衡功能**\n\nEnvoy 提供了一些先进的负载均衡功能，如：\n\n- 内置支持区域感知路由的功能\n- 通过[异常值检测](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/outlier#arch-overview-outlier-detection)进行被动健康检查\n- [恐慌路由](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/load_balancing\/panic_threshold)：Envoy 通常只将流量路由到健康的后端，但是如果健康主机的百分比低于某个阈值，它可以被配置为将流量发送到所有的后端，不管是健康的还是不健康的。这在我们 [2021 年 1 月 4 日的故障](https:\/\/slack.engineering\/slacks-outage-on-january-4th-2021\/)中非常有帮助，这次故障是由我们基础设施中的一个广泛的网络问题引起的。\n\n由于上述原因，在 2019 年，我们决定将我们的入口负载均衡层从 HAproxy 迁移到 Envoy Proxy，从 websockets 堆栈开始。迁移的主要目标是提高可操作性，获得 Envoy 提供的新功能，以及更加标准化。通过在整个 Slack 中从 HAProxy 迁移到 Envoy，我们的团队将不再需要了解两个软件的怪异之处，不再需要维护两种不同的配置，不再需要管理两个构建和发布管道，诸如此类。那时，我们已经在使用 Envoy Proxy 作为我们服务网格中的[数据平面](https:\/\/blog.envoyproxy.io\/service-mesh-data-plane-vs-control-plane-2774e720f7fc)。我们内部也有经验丰富的 Envoy 开发人员，所以我们可以随时获得 Envoy 的专业知识。\n\n## 生成 Envoy 配置\n\n这次迁移的第一步是审查我们现有的 websocket 层配置，并生成一个同等的 Envoy 配置。在迁移过程中，管理 Envoy 配置是我们最大的挑战之一。Envoy 有丰富的功能集，其配置与 HAProxy 的配置有很大的不同。Envoy 配置涉及四个主要概念：\n\n- **Listener**，接收请求，又称 TCP 套接字、SSL 套接字或 unix 域套接字。\n- **Cluster**，代表我们发送请求的内部服务，如消息服务器和存在服务器\n- **Route**，将 Listener 和 Cluster 连接在一起\n- **Filter**，它对请求进行操作\n\nSlack 的配置管理主要是通过 [Chef](https:\/\/www.chef.io\/) 完成的。当我们开始使用 Envoy 时，我们把 Envoy 配置作为 [chef 模板文件](https:\/\/docs.chef.io\/resources\/template\/)来部署，但它的管理变得很麻烦，而且容易出错。为了解决这个问题，我们建立了 chef 库和[自定义资源](https:\/\/docs.chef.io\/custom_resources_notes\/)来生成 Envoy 配置。\n\n![Chef 资源的结构和流程图](e6c9d24ely1h1277ob5drj20hs07wq2z.jpg)\n\n在 Chef 内部，配置是一个[单例](https:\/\/en.wikipedia.org\/wiki\/Singleton_pattern)，模拟了每个主机只有一个 Envoy 配置的情况。所有的 Chef 资源都在这个单例上操作，添加监听器、路由或集群。在 Chef 运行的最后，\u0060envoy.yaml\u0060 被生成、验证，然后安装 —— 我们从不写中间配置，因为这些配置可能是无效的。\n\n这个例子展示了我们如何创建一个有两条路由的 HTTP 监听器，将流量路由到两个[动态](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/upstream\/service_discovery#endpoint-discovery-service-eds)集群。\n\n![调用 Chef 资源以创建带有集群和路由的监听器的例子](e6c9d24ely1h1277otk25j20hs0ao74o.jpg)\n\n要在 Envoy 中复制我们复杂的 HAProxy 配置需要一些努力。大部分需要的功能在 Envoy 中已经有了，所以只需要在 chef 库中加入对它的支持就可以了。我们实现了一些缺失的 Envoy 功能（有些是[上游](https:\/\/github.com\/envoyproxy\/envoy\/pull\/12206)贡献的，有些是内部维护的扩展）。\n\n## 对我们的新配置进行测试和验证\n\n测试新的 Envoy websockets 层是一个迭代的过程。我们经常用手工编码的 Envoy 配置做原型，并在本地的开发机器上测试，每个监听器、路由和集群都有一个。手工编码的修改一旦成功，就会被移到 chef 库中。\n\nHTTP 路由是用 [curl](https:\/\/curl.se\/docs\/manpage.html) 测试的：\n\n- 基于头和 cookie 的特定路由到特定后端\n- 基于路径、前缀和查询参数的路由到特定后端\n- SSL 证书\n\n当事情没有达到预期效果时，我们在机器上使用 Envoy 调试日志。调试日志清楚地解释了为什么 Envoy 选择将一个特定的请求路由到一个特定的集群。Envoy 的调试日志非常有用，但也很冗长，而且很昂贵（你真的不想在生产环境中启用这个功能）。调试日志可以通过 Curl 启用，如下所示。\n\n\u0060\u0060\u0060bash\ncurl -X POST http:\/\/localhost:\u003cenvoy_admin_port\u003e\/logging?level=debug\n\u0060\u0060\u0060\n\nEnvoy 管理接口在初始调试时也很有用，特别是这些端点：\n\n- **clusters**：显示所有配置的集群，包括每个集群中所有上游主机的信息以及每个主机的统计数据。\n- **\/certs**：以 JSON 格式显示所有加载的 TLS 证书，包括文件名、序列号、主体替代名称和到期前的天数。\n- **\/listeners**：显示所有配置的监听器及其名称和地址。\n\n我们的 Chef 库使用 \u0060-mode validate\u0060 命令行选项运行 Envoy，作为一个验证步骤，以防止安装无效的配置。这也可以手动完成。\n\n\u0060\u0060\u0060bash\nsudo \/path\/to\/envoy\/binary -c \u003c\/path\/to\/envoy.yaml\u003e --mode validate\n\u0060\u0060\u0060\n\nEnvoy 提供 JSON 格式的监听器日志。我们将这些日志录入我们的日志管道（当然是在对日志进行 [PII](https:\/\/en.wikipedia.org\/wiki\/Personal_data) 处理后），这对调试工作经常很有帮助。\n\n一旦对开发环境中的配置有信心，我们就准备做一些更多的测试 -- 在生产中！\u0022。\n\n## 迁移至生产\n\n为了将迁移过程中的风险降到最低，我们建立了一个新的 Envoy websocket 栈，其配置与现有的 HAProxy 层相当。这意味着我们可以逐步、有控制地将流量转移到新的 Envoy 堆栈，并且在必要时可以快速切换回 HAProxy。缺点是我们的 AWS 成本 —— 我们在迁移过程中使用了双倍的资源，但我们愿意花费时间和资源为我们的客户透明地进行迁移。\n\n我们通过 [NS1](https:\/\/ns1.com\/) 管理我们的 DNS 记录 **wss-primary.slack.com** 和 **wss-backup.slack.com**。我们使用加权路由将流量从 **haproxy-wss** 转移到 **envoy-wss** [NLB](https:\/\/docs.aws.amazon.com\/elasticloadbalancing\/latest\/network\/introduction.html) DNS 名称。第一批区域是以 10%、25%、50%、75% 和 100% 的步骤单独上线的。由于我们对新的 Envoy 层和上线过程有信心，所以最后的区域上线速度更快（25%、50%、75%、100% 只需两天，而之前的一个区域需要一周的时间）。\n\n尽管迁移工作很顺利，没有出现故障，但还是出现了一些小问题，比如超时值和 header 的差异。在迁移过程中，我们多次恢复、修复，并再次上线。\n\n![流程图显示 DNS 迁移过程中涉及的组件和步骤](e6c9d24ely1h1277p8k19j20hs07c3yp.jpg)\n\n经过漫长而激动人心的 6 个月，迁移完成了，整个 HAProxy websocket 堆栈在全球范围内被 Envoy Proxy 取代，对客户的**影响为零**。\n\n## 哪些进展顺利，哪些不顺利\n\n迁移本身是相对平淡和无聊的。**枯燥是一件好事**：刺激意味着事情的中断，枯燥意味着一切顺利。\n\n我们发现，旧的 HAProxy 配置随着时间的推移而有机地增长。它在很大程度上是由 HAProxy 使用的模型形成的 —— 一个包括所有监听器的大型配置。Envoy 的配置模型比 HAProxy 的模型使用更多的定义范围。一旦一个监听器被输入，只有该监听器内的规则适用于请求。一旦输入一个路由，只有该路由上的规则适用。这使得将规则与相关的请求联系起来更加容易。\n\n我们花了很长时间从旧的 HAProxy 配置中提取重要的东西，这实际上是技术债务。通常很难弄清楚为什么会有某个规则，哪些是有意的，哪些是无意的，以及其他服务所依赖的行为是什么。例如，有些服务应该只在两个虚拟主机（vhosts）中的一个下，但实际上在 HAProxy 的两个 vhosts 下都可用。我们不得不复制这个错误，因为现有的代码依赖于这种行为。\n\n我们在 HAProxy 堆栈中错过了一些细微的东西。有时这些是很重要的 —— 我们破坏了 Slack 的每日活跃用户（DAU）指标（哎呀！）。也有很多小问题需要解决。负载均衡器的行为很复杂，除了花时间调试外，没有真正的办法解决这个问题。\n\n我们开始迁移时，没有为负载均衡器的配置提供测试框架。我们没有自动测试来验证测试的 URL 路由到正确的端点以及与请求和响应头相关的行为，而是有...... 一个 HAProxy 配置。在迁移过程中，测试是很有帮助的，因为它们可以提供很多关于预期行为的原因的背景。因为我们缺乏测试，所以我们经常不得不向服务所有者询问，以了解他们所依赖的行为。\n\n我们建立的 Chef 资源有意只支持 Envoy 功能的一个子集。这使我们的库更简单 —— 我们只需要考虑我们实际使用的功能。缺点是，每次我们想使用新的 Envoy 功能时，都必须在我们的 Chef 库中添加对这些功能的支持。例如，[SNI](https:\/\/en.wikipedia.org\/wiki\/Server_Name_Indication)（https）监听器是在开发过程中编写的，当时我们认为这比向现有的监听器添加支持更简单。然而，当涉及到 vhost 支持时，我们已经开发了很多代码并在使用中，重构整个公司其他地方正在使用的资源将花费很长时间。我们的 Chef 库中的 vhost 支持是一个 hack（很快有一天我们会修复它）。\n\n为了使改变 Envoy 资源 Chef 库更加安全，换句话说，确保我们不会破坏其他使用我们库的团队，我们引入了一套全面的测试，生成这些团队的整个配置。这使得我们可以很容易地知道，当我们更新 Envoy Chef 资源时，我们生成的所有 Envoy 配置会（或不会）受到什么影响。\n\n这次迁移（和其他迁移一样）的关键事项之一是沟通。我们努力让每个人都了解并配合我们正在进行的改变。我们的客户体验（CE）团队是一个很好的合作伙伴 —— 他们能够监控传入的工单，以发现任何可能表明用户因这次迁移而受到影响的情况。\n\n## 下一步是什么？\n\n尽管偶尔会遇到一些小挫折，但 envoy websocket 的迁移还是非常成功的。我们已经跟进，将另一个关键的 Slack 服务，即我们的软件客户端指标摄取管道 —— 与我们的其他入口负载均衡器隔离 —— 迁移到 Envoy Proxy。我们几乎已经完成了将我们的网络和 API 流量的内部负载均衡器迁移到 Envoy。这场史诗般的迁移的最后一部分是将我们的（常规的、非 websocket 的）HTTP 堆栈从 HAProxy 迁移到 Envoy，这也是正在进行的。\n\n我们的最终目标是在入口负载均衡器和服务网格数据平面上实现 Envoy Proxy 的标准化，这将大大降低团队的认知负荷和操作复杂性，并使 Envoy 的先进功能在我们的负载均衡基础设施中得到应用。自从迁移到 Envoy 后，我们已经大大超过了以前的峰值负载，没有任何问题。\n', '\/trans\/migrating-millions-of-concurrent-websockets-to-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是 Slack 花半年时间从 HAProxy 迁移到 Envoy 上的经验分享。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/envoy-oss-5-year/">[译] 网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/09/15</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fas fa-language"></i>
              <a href="https://mattklein123.dev/2021/09/14/5-years-envoy-oss/" target="_blank" rel="noopener">原文</a>
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('网络代理 Envoy 开源五周年，创始人 Matt Klein 亲述开源心路历程及经验教训', '开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？', '\n译者注：本文译自 Envoy 代理的创始人 Matt Klein 于昨晚在个人博客上发布的文章 [5 year of Envoy OSS](https:\/\/mattklein123.dev\/2021\/09\/14\/5-years-envoy-oss\/)。他在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？看完本文，相信对于开源项目的维护者、创业者及投资人都会大有收获。\n\n------\n\n## 前言\n\n今天是 [Envoy Proxy 开源](https:\/\/www.envoyproxy.io\/)的 [5 周年](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。毫不夸张地说，在专业方面，过去的 5 年是一个史诗般的过山车，我的情绪介于兴奋、自豪、焦虑、尴尬、无聊、倦怠之间。我想分享一下这个项目的前传和历史，以及我在发展大型开源软件项目的过程中所学到的一些经验教训。\n\n## 前传和历史\n\n### 前传\n\n除了一些小的弯路，我在技术行业二十年的职业生涯一直专注于底层系统：嵌入式系统，操作系统，虚拟化，文件系统，以及最近的分布式系统网络。我的分布式系统网络之旅始于 2010 年初在亚马逊，我有幸帮助开发了第一批高性能计算（HPC）EC2 实例类型。我学到了大量的底层高性能计算机网络知识，尽管我对分布式系统的概念接触有限。\n\n2012 年，我加入了 Twitter，在经历了几次错误的开始后，我最终加入了边缘网络团队。这是我第一次真正接触到分布式系统应用网络概念。我领导了一个新的 HTTP 边缘代理的开发，称为 Twitter 流式聚合器（TSA），它在 2013 年首次推出，以扩大 Twitter 的“firehose”API（流式所有推文）的交付。在 2014 年世界杯前夕，我们决定将 TSA 作为一个通用的 HTTP\/HTTP2\/TLS 边缘代理，在靠近巴西赛事的存在点（POPs）推出。这样做的主要原因是不可能在 POP 的少量主机托管机架上部署现有的基于 JVM 的资源匮乏的边缘代理。项目周期特别紧张，我的团队成功地完成了一届没有事故的世界杯。（我还清楚地记得有一段时间，当软件崩溃时，不管是什么时候，我都会给自己打上一页，修复错误，然后重新进行金丝雀部署，继续测试）。在 Twitter 工作期间，我还接触到了该公司通过 Finagle 库进行服务间网络通信的方式，并取得了巨大成功。\n\n2015 年元旦前后，我在 Twitter 的日子里，因为我写的一个 bug，TSA 系统故障导致数百万 Twitter 的安卓用户被下线，这将是我在 Twitter 工作的尾声。\n\n![](008i3skNly1guh3vblu9xj60tu0eu76p02.jpg) \n\n### 加入 Lyft 和创建“Lyft 代理”\n\n我在 2015 年春天离开了 Twitter，部分原因是下线事件的影响，部分原因是对没有得到晋升的挫败感，部分原因是想尝试新的东西。我跟着我的老板从 Twitter 到了 Lyft，还有我在 Twitter 的其他同事。\n\n当我加入 Lyft 时，公司规模相对较小（少于 100 名工程师），并且正在努力从单体架构迁移到微服务架构。我已经[多次](https:\/\/mattklein123.dev\/appearances\/)谈到了 Envoy 的这部分历程，所以我不会再重述，在此简短的总结下，Lyft 遇到了所有典型的微服务迁移问题，主要是源于网络和可观测性。此外，Lyft 已经是“多面手”（使用多种语言和框架），所以使用基于库的解决方案来解决这些问题似乎不切实际。因此，根据我以前建立 TSA 的经验和观察服务间通信在 Twitter 的工作方式，由于得到在 Lyft 的前 Twitter 同事们的信任，我提议建立一个新的应用网络系统，称为“Lyft 代理”。\n\n经过一些激烈的讨论，包括新的代理是否应该用 Python 构建（是的，真的），我们就项目的大致轮廓达成一致，并决定使用 C\u002b\u002b 作为实现语言。在当时，C\u002b\u002b 似乎是唯一合理的选择。今天我还会选择 C\u002b\u002b 吗？然而，如今已经不是 2015 年初了。\n\n如果不说“Envoy\u0022 这个名字的由来，这部分的历史就不完整了。我们正在为这个项目建立最初的开发脚手架的时候，一个有远见的同事（Ryan Lane）说，我们不能把这个新项目叫做“Lyft 代理”，我们必须选择一个更好的名字。我总是很实际，就去找辞典，查了一下“代理”，然后决定用 Envoy 作为新名字。\n\n### 在 Lyft 上线\n\n直到 2015 年夏天，我才开始认真地研究 Envoy 的源代码。那几个月是我职业生涯中最有趣的几个月。我们应该珍惜这段初创时期，因为它不会持续很久。我花了很长时间，争取在合理的时间内（根据我的定义，这种类型的项目需要 3-4 个月的时间）做出能给 Lyft 带来价值的东西。俗话说，Lyft 给了我大量的绳子来吊死自己，而我致力于确保这种吊死不会发生。\n\n当然，我的效率主要归功于刚从压缩的开发时间表和许多错误（主要是我自己的）中走出来，在 Twitter 的 TSA。我知道哪些错误是不能犯的，哪些抽象是需要的，哪些测试有效，哪些无效，等等。\n\n2015 年秋天准备投入生产的 Envoy 的最初版本只包含了该项目今天所包含的功能和复杂性的一小部分。它不支持 TLS，只支持 HTTP\/1，并且有极其简单的路由和弹性功能。它所拥有的是你今天所看到的东西的骨架。在这个项目的历史上，很少有重大的重构，主要是因为，正如我之前所说的，我知道将要发生什么，以及为了支持这些功能，需要有哪些抽象。Envoy 从一开始就拥有一流的可观测性输出，以指标和日志的形式。在 2021 年，这种类型的网络可观测性是桌面上的赌注（这在很大程度上要归功于 Envoy 的成功），但在当时却不是这样。\n\nEnvoy 最初是作为边缘代理在 Lyft 上线的，位于提供 TLS 终止的 AWS ELB 后面。到 2015 年秋末，Envoy 为 Lyft 的 100% 流量提供服务，该系统产生的边缘仪表盘立即得到了回报（例如，提供 API 调用百分点延迟直方图，每个终端的成功率和请求率等）。\n\n在最初推出后不久，另一位 Twitter 同事（Bill Gallagher）加入了我的项目，我们迅速增加了一些功能，如 TLS 终止、HTTP\/2 支持、更多路由和负载平衡功能等。\n\n与此同时，Lyft 基于 Envoy 的“服务网格 \u0022 也开始成形了。首先，Envoy 被部署在 PHP 单片机旁边，以取代 HAProxy 及其一些固有的运维问题（例如，当时 HAProxy 仍然是单线程的），以帮助 MongoDB 的代理。可以毫不夸张地说，Envoy 的早期开发有很大一部分是针对 MongoDB 的稳定性（负载均衡、速率限制、可观测性等）。\n\n基于 Envoy 的边缘机群和单体之间的直接观察能力的好处是非常明显的。不久之后，我们在一些高 RPS 分解的微服务旁边部署了 Envoy，以帮助排除网络问题。这方面的价值也得到了证明。随着时间的推移，我们超越了对可观测性的关注，增加了帮助系统可靠性的功能，如直接连接和服务发现（跳过内部 ELB）、异常值检测、健康检查、重试、断路等。Lyft 的基于负载的重大事件的数量从每 1-2 周一次慢慢减少。当然，Envoy 不能将所有此类事件的减少归功于此，但它提供的网络抽象确实有很大的帮助。\n\n2016 年初，我们决定推动一个 100% 覆盖的服务网格。最初，我们认为这将是一个艰难的过程，需要自上而下的授权。在实践中，**团队报名参加了迁移，因为他们将得到的好处是显而易见的**。“胡萝卜 \u0022式的迁移几乎总是成功的。而“大棒\u0022 式的迁移则很少成功，或者即使成功了，也会在组织内留下眼泪和愤怒。\n\n到 2016 年中期，Envoy 被用于 Lyft 的所有网络通信，包括边缘服务、服务间通信、数据库、外部合作伙伴等。无论从哪个角度来看，该项目都取得了巨大的成功，帮助 Lyft 完成了微服务的迁移，提高了整体的可靠性，并对网络进行了抽象，使大多数工程师不需要了解真实的系统拓扑结构。此后，Bill 离开了这个项目，在 Lyft 从事其他工作，接替他的是 Roman Dzhabarov 和 Constance Caramanolis 加入我的团队。我们的小团队为整个 Lyft 开发和运维 Envoy。\n\n### 开放源码\n\n到 2016 年夏天，我们开始认真讨论开源 Envoy 的问题。早期的 Lyft 员工对开源和它为公司所做的事情很欣赏。很明显，Envoy 并不是 Lyft 的主要业务，那么为什么不把它放在那里并给予回报呢？我可以坦率地说，我们都带着不同的目标和期望来对待开放源代码的过程，以及对项目获得巨大成功后会发生什么感到非常天真。\n\n在加入 Envoy 之前，我已经使用了相当多的开源软件，但我几乎没有开源贡献的经验，也没有维护者的经验。（虽然我在 Linux 内核中有过[一次提交](https:\/\/github.com\/torvalds\/linux\/commit\/00370b8f8dd6e3171b8202f9c5187a5f73e99497)！）开源 Envoy 似乎是一个很好的机会，可以扩展我的技能组合，学习新的东西，可能会促进我的职业生涯，坦率地说，我不希望有一个 TSA v3 在第三家公司出现。对于 Lyft 来说，Envoy 是一个重要的工程项目，领导层认为，开放源代码将使 Lyft 作为一个工程组织具有可信度，并有助于招聘工作。正如我之前所说，我们所有人都对创建成功的开源，更重要的是在它获得成功的情况下培育它所需要的东西感到天真。\n\n但是，我们决定给它一个机会。我们在 2016 年夏天花了很大一部分时间来编写文档（Jose Nino 在这个时候加入了团队，他的第一个任务就是阅读并帮助改进所有的文档），清理存储库，使其 \u0022 不那么尴尬”，制作网站，发布博文等等。我真的很感谢这段时间里我在 Lyft 的同事，他们不仅支持我们，还帮助我们完成了无数的任务，包括网站设计、logo 等等。即使在这个早期阶段，我们也觉得第一印象很重要，如果我们要在开源领域有所作为，就必须通过高质量的文档、网站等给人留下良好的第一印象。\n\n在此期间，我们还利用我们的行业关系，与 Lyft 的一些“同行公司”（湾区的“独角兽 \u0022 互联网创业公司）会面，向他们展示我们在 Envoy 方面所做的工作，并获得他们的反馈，我们认为如果我们在正式开源前成功获得一个启动合作伙伴，这将是对项目的一个重大帮助。所有这些会议都非常友好，总的来说，所有与我们会面的公司都对我们所取得的成就印象深刻。但是，事后看来，他们都表示，以他们的小型基础设施团队，不可能马上采用 Envoy。他们祝愿我们在开放源代码方面取得最好的成绩，并说他们以后会回来看看。我们不禁对这些会议的结果感到沮丧，但我们还是向前推进了。\n\n2015 年 8 月，我与谷歌进行了第一次友好的会面。一个 Lyft 的同事（Chris Burnett）在一个 gRPC 聚会上发言，提到了 Envoy，因为它与 Envoy 的 [gRPC 桥接](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/other_protocols\/grpc#grpc-bridging)支持有关。我不知道的是，谷歌在发现 Envoy 的时候，正准备在 NGINX 的基础上推出 Istio。一次会议引出了另一次会议，然后是更多的会议，在 Envoy 开源之前，大量的谷歌员工已经看到了源代码和文档。(稍后会有更多关于这方面的内容）。\n\n到 9 月初，我们已经准备好了，并将开源日定为 9 月 14 日。总的来说，我是一个（过度？）自信的人，但在我的生活中，有几次我对自己成功的能力有很大的焦虑。我立即想到的是：开始上高中，开始上大学，以及大学毕业后在微软工作。而开源的 Envoy 就是其中之一。我记得我被公众的反应吓坏了。人们会怎么说？反馈会是积极的还是恶毒的？虽然我们在开源时是一个小团队，但我仍然写了 90% 或更多的代码，并且觉得把它放到公共领域是对我自己和我的能力的一种反映。\n\n如期而至，[Envoy](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191) 在 2016 年 9 月 14 日 [成为开源产品](https:\/\/eng.lyft.com\/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191)。我记得我和妻子一起庆祝，并说了一些话。“如果我们能让其他公司像 Lyft 一样使用 Envoy，我就会很高兴。”\n\n对开放源码发布的反应几乎是普遍的积极。令我们惊讶的是，几乎是立刻，我们开始听到大公司的声音，而不是小公司。在几周内，我们与苹果、微软进行了交谈，与谷歌的对话也不断加快。大公司在现有的解决方案中存在问题，并且有大量的团队准备投入到解决这些问题的工作中。具有讽刺意味的是（至少在 Twitter 的观点中），C\u002b\u002b 在这里是一种帮助，而不是一种阻碍。这些大公司都已经拥有充足的 C\/C\u002b\u002b 开发资源，以及他们想要整合的现有库，等等。对他们来说，C\u002b\u002b 是一个卖点。\n\n在这段时间里，毫不奇怪，我们与谷歌的人有最多的互动。最初主要是构建 Istio 的团队，但渐渐地，我们与 Anna Berenberg 花了更多时间，她现在是谷歌的杰出工程师，领导各种网络和负载均衡工作。这种关系将产生 \u0022 喷气燃料”，在 2017 年初真正启动该项目。\n\n### 开始起飞\n\n到了 2017 年初，很明显，Envoy 的开发正在加速。谷歌承诺用 Envoy 取代 NGINX，用于 Istio（最终在 2017 年春季推出），对项目的未来来说更重要的是，Anna 的大型团队致力于 GCP 云负载均衡功能，他们开始向使用 Envoy 的各种云负载均衡产品以及内部用例（这在这个时期都是非常秘密的，但现在已经众所周知）。\n\n我将永远记得与谷歌互动的那段时间是我职业生涯中最紧张的时期之一。说实话，那感觉就像一个收购（审讯）过程。我记得长长的会议和电子邮件线程，以证明我们的技术决定，“面试 \u0022中，谷歌试图确定我们是否会成为一个好的开源项目合作伙伴，等等。当时我们很痛苦地发现，这次\u0022 收购 \u0022 将使 Envoy 进入一个我们自己永远无法实现的轨道，所以我们尽一切努力使它获得成功，最终也获得了成功。而且，在过去 4 年多的时间里，我们与谷歌的合作确实是一种杰出的伙伴关系。早期的谷歌云工程师最终成为维护者，Harvey Tuch 和 Alyssa Wilk，为项目带来了大量的人才，包括技术上的，以及对开源和社区的支持。我对他们的感激之情溢于言表，没有他们，项目就不会有今天的成就。多年来为该项目做出贡献的其他谷歌工程师（现在有很多），除了普遍是优秀的社区管理者之外，还为该项目增加了大量的工程力量，否则该项目就不会有。我当然对最初的谷歌合作关系有顾虑（技术和理念上的分歧，等等），但我可以诚实地说，这些顾虑都没有成为现实。\n\n除了确保 Istio 和 GCP 团队与谷歌合作的成功之外，我们还花了大量时间与其他公司和维护者合作并加入他们，其中许多人对项目产生了巨大的影响，至今仍作为维护者、贡献者或用户大量参与。如果没有这些早期的社区成员，这个项目就不会有今天，我也非常感谢他们对项目的信任。\n\n同时，随着项目的不断深入，我开始收到大量投资者对 Envoy 的兴趣。有强烈的愿望让我离开 Lyft，围绕这个项目开一家公司。我[写过这部分的旅程](https:\/\/medium.com\/@mattklein123\/optimizing-impact-why-i-will-not-start-an-envoy-platform-company-8904286658cb)，所以我不会在这里重述，留在 Lyft 我会有大量的时间和精力来处理所有这些互动。正如链接的文章所描述的，我最终决定留在 Lyft，不开公司，以支持 Envoy 的持续成功。\n\n与此同时，我仍然在 Lyft 工作，正如我将在后面进一步讨论的那样，我越来越多地从事两份工作。我的第一份工作是在内部领导网络团队，并在运营上支持 Lyft 的 Envoy。我的第二份工作是作为 Envoy 的公众形象，包括 OSS 领导，代码审查，修复错误，编写可以促进项目的功能，在会议上发言，帮助其他公司采用和部署 Envoy，等等。我开始变得过于分散，并出现了倦怠的迹象。然而，到了 2017 年年中，不可否认的事实是，Envoy 的发展轨迹是大大的“向上和向右”。各大公司、“同行公司”、垂直产品和服务等的采用率继续攀升。\n\n### 捐赠给 CNCF 且感到倦怠\n\n到 2017 年秋天，有两件事是清楚的。\n\n1. Envoy 已经超出了 Lyft OSS 设备所能提供的范围。该项目需要法律、公共关系、营销、活动组织等方面的帮助。\n2. 我很快就完全倦怠了，需要找出一条可持续发展的道路。\n\n为了解决第一点，我们最终同意考虑将 Envoy 转交到 CNCF。数月来，CNCF 一直在追求该项目，但似乎从来没有任何令人信服的理由来加入。到 2017 年底，很明显，CNCF 的资源即使不是净收益，也至少对项目是中性的。我们开始了提交程序，并最终在我们最初开放项目资源的几乎整整一年后[加入了该基金会](https:\/\/eng.lyft.com\/envoy-joins-the-cncf-dc18baefbc22)。我很感谢 Alexis Richardson 和 Chris Aniszczyk 在这个过程中对项目的指导。\n\n第二点则要复杂得多。从根本上说，我的工作时间超过了我的工作能力，有效地跨越了两个不同的工作。此外，我正在期待我的第一个孩子，预产期在 2018 年初，随着到来的日期越来越近，这让我越来越焦虑。到这个时候，我已经很清楚，我在设定期望和界限方面做得不够好，不知道自己能够为 Lyft 提供什么，同时也没有从行业的角度关注 Envoy 的持续增长。在 Lyft，我越来越放任自流，陷入人际关系的争吵，在为更多的初级团队成员提供指导和领导方面，没有达到我这个级别的期望。\n\n简而言之，我当时正处于崩溃的边缘，最终我选择了 Envoy 而不是 Lyft，这对我的 Lyft 同事造成了伤害。我想，如果我在 2017 年初至年中对我的工作量与 Lyft 的领导层更加透明，我可能会避免一些最糟糕的结果，但不幸的现实是，**为开源软件行业的工作提供资源，而这些工作对雇主没有立即明显的作用，这是一个复杂的努力**。它可能会更顺利，也可能不会。在任何情况下，虽然我对一些我本可以处理得更好的人际关系问题感到遗憾，但无论好坏，**我都不后悔把精力放在 Envoy 上。我优先考虑的是 Envoy，而不是 Lyft，我做了我认为当时必须做的事情，以使它成功**。\n\n### 可持续发展道路\n\n我的第一个孩子在 2018 年 2 月出生，Lyft 极其慷慨的陪产假政策为我提供了休息和放空自己的时间。我从 Lyft 获得了一些空间，并开始更深入地思考我想要什么以及什么对我来说是可持续的。\n\n当我休完陪产假回来后，我与 Lyft 领导层明确表示，我不能再参与 Lyft 的 Envoy 的 \u0022日常\u0022 运维。相反，由于 2017 年底的一些后果，基础设施团队也希望与我分开一些。由于这个原因，**我大幅后退，实际上完全停止了在 Lyft 的基础设施工作**，在 2018 年年中至年末的 Lyft Bikes 和 Scooters 初始版本中编写固件网络代码。这是一个了不起的团队努力，在压缩的时间范围内得到了一些东西，我真的很喜欢在几个月内做一些完全不同的事情。\n\n2018 年也是我积极开始琢磨在 Envoy OSS 社区中 \u0022取代自己\u0022 的那一年。我花了大量的时间（并将继续花大量的时间）来培养维护者、新的贡献者，组织第一次专门的 EnvoyCon，等等。任何领导者都应该有一个目标，那就是确保该组织在有一天该领导者退位时能够继续良好地运作。\n\n到 2018 年底，我的主要职业倦怠风险已经得到解决，我又开始了合理的工作时间，并花了很多时间与我的妻子和儿子在一起，我的时间大致在 Envoy OSS 工作和 Lyft 的一般基础设施领导之间各占一半。明确地说，Envoy 的成功带来的特权使我能够在 Lyft 的工作生活中取得这种平衡。随着时间的推移，随着我的行业地位的提高，我的影响力也在同步增加，这使得我更容易按照自己的意愿设定就业条款。没有多少人有这样的运气，我明白我是多么幸运，能够“突破“倦怠墙的另一边而不必离开我的工作。\n\n### Envoy 长大了\n\n自 2019 年以来，因为新冠疫情，我在 Lyft 的基础设施领导和 OSS 领导之间继续保持着我上面描述的五五开的比例。当然也有单调和渴望不同的时候（从历史上看，我是一个习惯性换工作的人，6.5 年是迄今为止我在一件事情上工作的最长时间），但总的来说，我很高兴看到 Envoy 从一个“新秀 \u0022 变成更多的“少年”。我不再专注于做我所能想到的一切，使 Envoy 获得巨大的成功，因为坦率地说，Envoy 是一个巨大的成功，已经席卷了市场，并改变了用户对应用负载均衡工具的期望。相反，我更关注项目的可持续性。我们是在做长期的工作，这些天我觉得自己更像一个 CEO，看减员人数、优先级、预算编制、安全问题等等。这并不是说这不是有用的工作；它显然是有用的，它只是与早期的工作不同，早期的工作技术性更强，节奏更快。\n\n截止到 2021 年末，我对 Envoy 最引以为豪的事情是，在我看来，这个社区已经可以自我维持了。我们有一群令人难以置信的维护者、贡献者和用户，他们对项目的成功充满热情，并在使 Envoy 成为今天的样子中发挥了作用。这确实是一个团队的努力。\n\n## 经验教训\n\n过去的 5 年是一个史诗般的旅程。虽然我觉得我在技术上学到的东西相对较少，但我在领导力、社区建设和所有其他非技术性的东西方面都得到了成长和学习，这些都是建立一个成功的企业，无论是企业还是一个主要的开源成功故事。以下是我对一些主要学习内容的简短总结。\n\n### 成功的开源软件就像创办一个企业\n\n也许有争议的是，**我认为如果一个人有目标要创建一个非常成功的开源软件项目，他们需要把它想成一个企业**。除了核心技术之外，创业还涉及很多因素：\n\n- 招聘（在开源软件中，这意味着招聘贡献者和维护者）\n- 获取客户（在开源软件中，这被转化为用户）\n- 文档和技术写作\n- 公共关系\n- 市场营销\n- 法律（商标、许可等）\n- 人力资源（在开源软件中，这将转化为解决社区纠纷和制定文化）\n- 资金（在开源软件中，这转化为辅助费用，如 CI、为维护者找到允许他们在项目中部分或全部时间工作的工作，等等）\n- 总的说来，就是领导和方向的确定。资源有限，有很多事情可以做。企业 \/ 项目需要专注于最重要的事情，以实现产品的市场适应性。\n\n直观地说，我知道这一点，在最初为 Envoy 进行开源努力时，我积极地追求上述所有的领域，努力使项目从开始发展到今天的规模。上述列表中的每一项都很关键，如果没有所有这些，一个项目是不可能成功的，尤其是在技术领域有很多资金雄厚的公司竞争对手的情况下。\n\n我强烈鼓励那些考虑进行大规模开源工作的人提前在上述领域进行投资，以便在第一天就给人留下最佳印象。此外，新的开源项目应该准备在项目成长并开始看到采用时，在上述领域进行更多的投资。\n\n毫不奇怪，这些天我在 Envoy 上做的编码工作相对较少。我在项目上的时间主要是管理项目的所有非技术方面（上述列表中的所有内容，甚至更多！），并确保事情按计划进行。我所做的大多数编码项目都是“清洁 \u0022 的幕后项目，对项目有好处，但没有什么乐趣，也不可能激励其他贡献者（当然，我对他们每天的工作没有发言权，我有动力让他们尽可能的开心，这样他们就不会离开）。\n\n### 终端用户驱动的开源软件是一种结构性优势\n\n这些天来，很多“大的开源软件”，特别是在基础设施领域，是由大公司和风险投资支持的初创公司资助的。我不会绕到关于开源软件的困难经济的讨论，因为我[已经写过了](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)。我想说的是，**我坚信终端用户的开源软件比企业和风险投资支持的开源软件有很大的优势**：最初的客户几乎肯定会从软件中获得价值，否则软件就不会得到资助。这种与客户一起建立东西的良性循环是非常强大的。它几乎普遍导致了更好的结果：软件更可靠、更专注、功能更少。有很多由最终用户驱动的开源软件的例子，然后取得了巨大的商业成功。鉴于坚实的基础和内在的产品市场适应性，这对我来说并不奇怪。我希望看到比今天更多的最终用户驱动的开源软件，尽管我认识到经济上是困难的。对于那些有机会的人来说，请向这种类型的软件所具有的结构性优势靠拢！\n\n### 不要跟风，要跟随客户\n\n这也许是 \u0022成功的开源软件就像创业\u0022 和 \u0022最终用户驱动的开源软件是一种结构性优势\u0022 的必然结果，但我无法强调坚持不懈地关注客户的实际需求而不是炒作周期所认为的客户需求是多么关键。例如，**多年来，人们一直在嘲笑 Envoy 是用 C\u002b\u002b 编写的，这引起了无数的笑话**。我喜欢 C\u002b\u002b 吗？不，不是很喜欢。它是否在 2015 年完成了工作，并吸引了最初的一批主要用户？肯定是的。这是一个关注客户和市场的例子，而不是屈服于没有实际“商业 \u0022 影响的炒作。如果一个人把开源软件当做一个企业，就会立刻明白，**以客户和市场为中心是取得巨大成功的唯一途径**。在 Envoy，我花了大量的时间为终端用户争论，以确保我们建立的东西能让所有人受益，而不仅仅是一小部分小众用户。\n\n### 可扩展性是至关重要的\n\n跟着客户走往往会导致客户的要求不能很好地融入项目的架构中。从开源软件的角度来看，失去对项目主要目标的关注会导致功能蔓延、软件无法维护和维护人员负担过重。同时，说“不 \u0022 也是失去潜在用户的一个保证。\n\n对于 Envoy，我想确保我们至少可以说“是的，但是……\u0022，即提供一个强大的可扩展性模型，让用户可以满足他们的需求，而不需要将每一个改动和功能都推到上游。这种策略已经多次得到回报，它减轻了维护者的负担，让用户能够解决他们自己的问题，更重要的是，将 Envoy 推向了我在最初设计该软件时从未想象过的用例。\n\n可扩展性，特别是对于开源软件的构建模块，是至关重要的。\n\n### 质量问题\n\n跟随客户的另一个推论是，质量确实很重要。用户希望软件易于操作，相对来说没有错误，关心安全，等等。曾几何时很多人会觉得因为开源软件是 \u0022 免费的”，所以质量就得不到保证。这在理论上也许是正确的，但实际上，在一个项目对软件质量认真对待之前，用户不会大量地聚集在一个软件上。因为获得用户是一个飞轮，可以获得更多的用户（特别是当从早期采用者转向晚期采用者时），所以确保为整个软件质量编列时间预算就更加关键了。\n\n关于 Envoy，我一直有一个 \u0022零碰撞\u0022 的理念。任何崩溃都会被调查和修复，无论多么不频繁的错误。这种对稳定性和质量的关注不会被忽视。\n\n### 社区是扩大规模的唯一途径\n\n这很明显，但我还是要说：社区是扩展开源软件的唯一途径。这是一个由维护者、贡献者和用户组成的社区。此外，社区的**基调**在项目开始时就已经确定，而且极难改变。人类倾向于遵循规范。一旦规范被确定下来，无论规范是什么，与这些规范不一致的人都会被避开。因此，**项目最初的公共基调对于设定其长期的社区轨迹极为关键**。\n\n当我们把 Envoy 做成开源软件时，我在 GitHub 上投入了大量的精力与人们一起工作，使用建设性和欢迎性的语言。总的来说，我尽我所能让 Envoy 成为一个受欢迎的地方，让人们愿意来贡献自己的力量，无论是维护、偶尔的贡献，还是用户帮助其他用户。\n\n在 Envoy 所取得的所有不同类型的成功中，到目前为止，给我带来最多个人满足感的部分是，有相当多的人告诉我，他们已经发誓不再使用开源软件，尤其是基础设施开源软件，因为他们觉得大多数项目中的人对彼此感觉都很糟糕。相反的，他们喜欢为 Envoy 做贡献，因为这个社区是如此的尊重和欢迎彼此。这需要大量的努力和纪律，尤其是在项目的早期，才能达到这样的结果，而这已经得到了众多的回报。\n\n不要低估从一开始就确定项目的文化和基调的复合效应。\n\n### 混合商业和开源软件的利益是非常困难的\n\n已经有很多关于开源软件的困难经济学的文章（[包括我自己的文章](https:\/\/medium.com\/@mattklein123\/the-broken-economics-of-oss-5a1b31fc0182)，我在上面提到的）。我只想说，**试图将商业上的成功和开放源码的成功结合起来是非常困难的，主要是因为这些成功往往是相互矛盾的**。\n\n我相信，Envoy 通过其强大的 API 和可扩展性系统穿透了这个矛盾。从本质上讲，Envoy 已经成为一个工具，现在被大量的垂直产品和服务所使用。这就产生了一个社区，该社区充满了选择在一个共同的基底上合作的公司，即使是通过在扩展 \/ API \/ 控制平面 \/ UI\/UX 层上的创新，推出相互竞争的上层产品。\n\n任何成功的开源项目都会看到大量的商业 \/ 投资人的兴趣。如果一个项目的目标是保持一个充满活力的社区，同时又能取得商业上的成功（我认为这对整个项目的成功是必要的，因为钱必须来自某处），**那么预先考虑如何将核心层和商业层分开是极其重要的**。这样做的实用性和策略会因项目和技术的不同而不同，但我相信专注于强大的 API \/ 扩展性的分割是一个富有成效的策略。\n\n### 基金会是很棘手的\n\n在现代的开源讨论中，有很多关于基金会的作用的讨论。我不打算对这一话题做大量的评论，**但我的主要建议是不要被基金会和它们可能提供的理论利益所干扰**。相反，要积极地关注产品的市场适应性，生产高质量的软件，并为用户提供价值。如果这些事情得以实现，其余的事情就会自然而然地发生。\n\n对于非常成功的项目来说，基金会，更确切地说，中立的商标持有地，是非常有用的，所以我肯定会在那个时候考虑加入一个。随着项目的成熟，Envoy 从成为 CNCF 的一部分所获得的价值也在不断增加。CNCF 雇佣了开源软件律师、营销人员、公共关系人员、一流的活动人员等等。这些额外的资源在“经营业务 \u0022 方面是非常宝贵的。\n\n### 提前考虑治理问题\n\n![](008i3skNly1guh3vqvywcj60tw0h8go702.jpg)开源治理是**非常**困难的。就其本质而言，开放源代码是无政府的，没有明确的领导结构。没有一个适合所有项目的治理方法，每个项目都必须找到自己的前进方向，可以通过“BDFL”\/CEO 类型的模式、指导委员会、类似 Apache PMC 的程序等。所有的治理模式都有优点和缺点，并且有不同的失败模式。\n\n最重要的是，在项目变得庞大和成功之前，先认真思考治理问题。写下一套规则和规范，特别是花时间记录项目的冲突解决过程。\n\n同时也要意识到，根据我在上面关于社区规范如何在早期设定的评论，早期的项目维护者将对整个对话和冲突解决的风格产生巨大的影响，就像公司的早期员工对公司的文化产生巨大的影响一样。\n\n在我的印象中，我们在 Envoy 内部非常幸运，没有发生过任何重大分歧，出现的问题也可以迅速友好地解决。在项目的历史上，我们从来没有需要援引[维护者投票程序来解决冲突](https:\/\/github.com\/envoyproxy\/envoy\/blob\/main\/GOVERNANCE.md#conflict-resolution-and-voting)。在我看来，这是一个巨大的成就，也是对所有维护者的素质和专业性的证明，尤其是考虑到该项目已经变得如此受欢迎，以及围绕它的所有商业利益。\n\n### 对开源贡献的期望是至关重要的\n\n我在上面提到过这个问题，但我自己的职业倦怠很大程度上是由于我没有很好地与我的雇主就我需要花多少时间来管理 Envoy 的开源增长设定合理的期望。我不会撒谎说，进行这样的对话就能神奇地使雇主为某人腾出大量时间来从事开源工作，特别是那些可能不直接适用于其日常工作的项目。话虽如此，我确信对所有参与的人来说，对开源过程有公开和诚实的期望是非常重要的。以下是在开源项目之前或开始以开源身份工作之前要问的合理问题：\n\n- 雇员应该问他们的雇主，为什么他们要开放源代码？\n- 雇主应该问他们的员工，为什么他们要开放源代码？(这个问题的答案和前一个问题的答案不同是完全合理的，但应该在公开场合讨论)。\n- 雇员应该问他们的雇主，如果项目成功了，会发生什么？该项目将有哪些资源可用？员工将有多少时间可以在通用的开源软件问题上工作，目的是直接推动项目的发展？\n\n**雇主和雇员之间不匹配的期望是未来怨恨和倦怠的根本原因。**\n\n### 代理容易，API 难\n\n对一些人来说，Envoy 提供的底层网络代理机制似乎是这个项目的复杂部分。事实证明，与为 Envoy 发展一个稳定的 API 生态系统所做的工作相比，代理部分（在我看来）相对简单。平衡人类和计算机消费的 API 人体工程学，保持不同版本的稳定性，发展 API 以支持其他客户端，如 gRPC，指定协议语义以使 Envoy 能够与数百（可能是数千）个不同的管理服务器对话，等等，都是非常复杂的。我为团队在这一领域取得的成就感到骄傲（特别要感谢推动这一工作的 Harvey），即使在这一过程中出现了一些错误（比如从 API 的 V2 版本强制迁移到 V3 版本）。\n\n如果一个软件提供了一个 API，而且更重要的是希望这个 API 成为其他系统的关键组件，那么不要低估提供一个稳定和符合人体工程学的 API 的成本和复杂性。反过来说，**强大的 API 是一个生态系统飞轮的重要组成部分**，会以此产生更多的产品和用户，所以在我看来，这些努力是非常值得的。\n\n### 不要忽视职业倦怠\n\n**如果一个人想成就大事业，我不相信他可以 100% 实现良好的工作生活平衡**。现实情况是，任何成功都是由现有的特权 \/ 机会、一个好的想法、良好的执行力和大量的运气（包括在正确的时间出现在正确的地点）组成的。所有这些东西都在 Envoy 中发挥作用，我不会假装我没有把自己搞得很累，特别是在 2017 年。我也会重新做一遍 2017 年的工作，因为从我的角度来看，我做了我必须做的事情，使项目获得成功。(有时我想，如果我已经有了孩子，Envoy 是否还会诞生。我不确定它是否会发生，但这是一个更长的谈话主题！)\n\n综上所述，我在 2017 年描述的那种史诗般的推动力只能持续这么久，直到一个人崩溃。我鼓励大家不断反思自己的工作生活平衡，并为自己找出一条可持续发展的道路。每个人的情况都不同，我不能提供任何一个避免职业倦怠的建议，但我认为反思是一个好的开始，也是我自己不得不努力的事情。\n\n## 感谢\n\n在过去 6 年半的时间里，在 Envoy 上工作，其中 5 年是作为开源软件，这是我职业生涯中的亮点。这个项目的成功确实是一个团队的努力，我一个人是不可能完成的，我为我们所有人（维护者、贡献者和用户）共同完成的事情感到非常自豪。在这个项目上工作的维护者和贡献者是我所共事过的最好的工程师群体，他们才华横溢，他们就职在不同公司，位于不同的地理位置，这真是开源的理论潜力在实践中的体现。作为一个团队，我们已经产生了世界性的影响，改变了用户对软件负载均衡系统的期望，同时也建立了一个充满活力和热情的社区。在我最疯狂的梦想中，我从未想过这个项目会成为今天的样子。\n\n对我来说，未来会发生什么就不那么清楚了。正如我上面所说的，我的重点已经转移到了可持续性上。我想确保，如果有一天我离开了，这个项目将保持健康。尽管如此，这一天还没有到来，我期待着在可预见的未来帮助领导项目前进，希望能取得更大的成功和采用。向前迈进！\n', '\/trans\/envoy-oss-5-year\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">开源网络代理 Envoy 的创始人 Matt Klein，在 Twitter 因为自己的程序 bug 造成重大事故而离职，后加入 Lyft，在开源 Envoy 之前几乎没有贡献和管理开源项目的经验，这篇文章分享了他个人及 Envoy 开源的心路历程，在投身开源 Envoy 还是为雇主 Lyft 效命，该如何抉择？</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/trans/introducing-getenvoy-extension-toolkit-for-webassembly-based-envoy-extensions/">[译] 使用基于 WebAssembly 的 GetEnvoy 工具包扩展 Envoy</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2021/04/21</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用基于 WebAssembly 的 GetEnvoy 工具包扩展 Envoy', '本文为大家介绍了如何使用开源项目 GetEnvoy 来扩展 Envoy。', '\n说一说来龙去脉，Envoy 是一个非常注重规模化业务的底层网络组件，令人激动且功能强大。然而它在用户体验方面一直很欠缺。\n\n当用户开始使用一个新工具时，必然会从“如何在自己的环境中安装”这一问题开始。而 Envoy 之前并没有给出答案。\n\n为了填补这一空白，Tetrate [启动了](https:\/\/www.getenvoy.io\/blog\/announcing-the-getenvoy-project\/) GetEnvoy 项目并且 [推出了](https:\/\/www.getenvoy.io\/blog\/introducing-the-getenvoy-cli\/) getenvoy CLI，作为提供给用户的组件。\n\n### 新挑战\n\n下一个关于 Envoy 的常见需求是“如何扩展”。\n\n截止目前，如果想扩展或定制 Envoy，你将不得不“越界”成为实质上的 Envoy 开发者。 \n\n幸运的是，这种情况即将改变。一种名为 [WebAssembly（Wasm）](https:\/\/webassembly.org\/) 的新技术即将纳入 Envoy。Wasm 让使用不同编程语言开发 Envoy 扩展成为可能。更重要的是，能以完全动态的方式部署这些扩展。\n\n### GetEnvoy 扩展工具包\n\n[GetEnvoy 扩展工具包](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 的目的在于帮助有扩展 Envoy 需求的开发者，在短时间内完成扩展开发并启动运行。\n\n作为开发者，你很可能想：\n\n- 从工作中的典型示例入手\n- 从开始就建立有效的开发工作流\n- 利用最佳实践，自动避免常见陷阱\n\nGetEnvoy 扩展工具包将帮助您解决以上所有问题！\n\n### 使用 Rust 创建 Envoy HTTP Filter\n\n让我们使用 Rust 开发一个 Envoy HTTP Filter 来试试 GetEnvoy 扩展工具包吧！\n\n#### 1. 前置要求\n\n[安装](https:\/\/www.getenvoy.io\/install\/) getenvoy CLI，例如：\n\n\u0060\u0060\u0060shell\n$ curl -L https:\/\/getenvoy.io\/cli | bash -s -- -b \/usr\/local\/bin\n\u0060\u0060\u0060\n\n[安装](https:\/\/docs.docker.com\/engine\/install\/) Docker。 \n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy --version\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ngetenvoy version 0.2.0\n\u0060\u0060\u0060\n运行\n\u0060\u0060\u0060shell\n$ docker --version\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nDocker version 19.03.8, build afacb8b\n\u0060\u0060\u0060\n\n#### 2. 安装新的 HTTP Filter 扩展包的脚手架\n\n如果想在交互模式下构建一个新扩展，运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension init\n\u0060\u0060\u0060\n此外，如果想跳过向导，需要在命令行提供参数，比如：\n\u0060\u0060\u0060shell\n$ getenvoy extension init \\\n    --category envoy.filters.http \\\n    --language rust \\\n    --name me.filters.http.my_http_filter \\\n    my_http_filter \n\u0060\u0060\u0060\n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ tree -a my_http_filter\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nmy_http_filter\n├── .cargo\n│   └── config\n├── .getenvoy\n│   └── extension\n│       └── extension.yaml\n├── .gitignore\n├── Cargo.toml\n├── README.md\n├── src\n│   ├── config.rs\n│   ├── factory.rs\n│   ├── filter.rs\n│   ├── lib.rs\n│   └── stats.rs\n└── wasm\n    └── module\n        ├── Cargo.toml\n        └── src\n            └── lib.rs\n\u0060\u0060\u0060\n\n#### 3. 构建扩展\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension build\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nUpdating crates.io index\nDownloaded envoy-sdk v0.1.0\n...\nCompiling envoy-sdk v0.1.0\n...\nFinished dev [unoptimized \u002b debuginfo] target (s) in 23.57s\nCopying *.wasm file to \u0027target\/getenvoy\/extension.wasm\u0027\n\u0060\u0060\u0060\n\n检查\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ tree target\/getenvoy\/\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ntarget\/getenvoy\n└── extension.wasm\n\u0060\u0060\u0060\n\n#### 4. 运行单元测试\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension test\n\u0060\u0060\u0060\n\n检查\n\n应该看到类似于以下的输出：\n\n\u0060\u0060\u0060shell\nrunning 1 test\ntest tests::should_initialize ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\u0060\u0060\u0060\n\n#### 5. 在 Envoy 中运行扩展\n\n让我们用较困难的方式完成这部分工作。与其使用一条简单的自动化命令，不如手动完成每一步。\n\n##### 1. 下载 Envoy 二进制文件\n\n需要去下载和扩展开发版本相同的 Envoy\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ cat .getenvoy\/extension\/extension.yaml\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\n…\n\n# Runtime the extension is being developed against.\n\nruntime:\n  envoy:\n    version: wasm:1.15\n\u0060\u0060\u0060\n为了下载该版本的 Envoy，运行命令：\n\u0060\u0060\u0060shell\n$ getenvoy fetch wasm:1.15\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nfetching wasm:1.15\/darwin\n[Fetching Envoy] 100%\n\u0060\u0060\u0060\n\n##### 2. 创建一个示例 Envoy 配置\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension examples add\n\u0060\u0060\u0060\n检查一下，运行命令：\n\u0060\u0060\u0060shell\n$ tree .getenvoy\/extension\/examples\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\n.getenvoy\/extension\/examples\n└── default\n  ├── README.md\n  ├── envoy.tmpl.yaml\n  ├── example.yaml\n  └── extension.json\n\u0060\u0060\u0060\n\n##### 3. 通过查看 README.md 文件了解更多关于示例配置的信息\n\n##### 4. 快速浏览示例 Envoy 配置\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$  cat .getenvoy\/extension\/examples\/default\/envoy.tmpl.yaml\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060yaml\n...\nhttp_filters:\n- name: envoy.filters.http.wasm\n  typed_config:\n    \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n    config:\n      configuration: {{.GetEnvoy.Extension.Config}}\n      name: {{.GetEnvoy.Extension.Name}}\n      root_id: {{.GetEnvoy.Extension.Name}}\n      vm_config:\n        vm_id: {{.GetEnvoy.Extension.Name}}\n        runtime: envoy.wasm.runtime.v8\n        code: {{.GetEnvoy.Extension.Code}}\n- name: envoy.filters.http.router\n...\n\u0060\u0060\u0060\n\n注意，示例 Envoy 配置中包含了占位符 {{…}}，这些占位符会由 getenvoy CLI 解决。\n\n##### 5. 使用该示例配置启动 Envoy\n\n运行命令：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\ninfo Envoy command: [$HOME\/.getenvoy\/builds\/wasm\/1.15\/darwin\/bin\/envoy -c \/tmp\/getenvoy_extension_run732371719\/envoy.tmpl.yaml]\n...\n[info][main] [external\/envoy\/source\/server\/server.cc:339] admin address: 127.0.0.1:9901\n...\n[info][config] [external\/envoy\/source\/server\/listener_manager_impl.cc:700] all dependencies initialized. starting workers\n[info][main] [external\/envoy\/source\/server\/server.cc:575] starting main dispatch loop\n\u0060\u0060\u0060\n\n此时 Envoy 已启动，扩展也可以使用了。\n\n检查\n\n为了测试 HTTP Filter 扩展，运行命令：\n\n\u0060\u0060\u0060shell\n$ curl -i http:\/\/0.0.0.0:10000\n\u0060\u0060\u0060\n在 Envoy 的输出中，应该看到类似于以下的输出：\n\u0060\u0060\u0060shell\nmy_http_filter: #2 new http exchange starts at 2020-07-01T18:22:51.623813\u002b00:00 with config:\nmy_http_filter: #2 observing request headers\nmy_http_filter: #2 -\u003e :authority: 0.0.0.0:10000\nmy_http_filter: #2 -\u003e :path: \/\nmy_http_filter: #2 -\u003e :method: GET\nmy_http_filter: #2 -\u003e user-agent: curl\/7.64.1\nmy_http_filter: #2 -\u003e accept: *\/*\nmy_http_filter: #2 -\u003e x-forwarded-proto: http\nmy_http_filter: #2 -\u003e x-request-id: 8902ca62-75a7-40e7-9b2e-cd7dc983b091\nmy_http_filter: #2 http exchange complete\n\u0060\u0060\u0060\n由于现在你知道了运行扩展的背后都发生了什么，下次就可以用以下命令简单启动扩展：\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n\n#### 增加一个新特性\n\n让我们为扩展添加一个新特性：在代理的 HTTP 响应中注入一个额外的标头。\n\n首先，更新扩展配置以保存注入的标头的名称（添加的行后添加了注释）：\n\n在 src\/config.rs 文件中\n\n\u0060\u0060\u0060rust\n\/\/\/ Configuration for a Sample HTTP Filter.\n#[derive (Debug, Default, Deserialize)]\npub struct SampleHttpFilterConfig {#[serde (default)]{\n#[serde(default)]\npub response_header_name: String, \/\/ 添加的代码\n}\n\u0060\u0060\u0060\n\n接着，添加 on_response_headers 方法到 SampleHttpFilter 中：\n\n在 src\/filter.rs 文件中\n\n\u0060\u0060\u0060rust\n\/\/\/ Called when HTTP response headers have been received. 当 HTTP 响应头被接收时调用\n\/\/\/\n\/\/\/ Use \u0060filter_ops\u0060 to access and mutate response headers. 使用 filter_ops 访问和变异响应头\nfn on_response_headers (\n    \u0026mut self,\n    _num_headers: usize,\n    _end_of_stream: bool,\n    filter_ops: \u0026dyn http::ResponseHeadersOps,\n) -\u003e Result\u003chttp::FilterHeadersStatus\u003e {if !self.config.response_header_name.is_empty () {\n        filter_ops.set_response_header (\n            \u0026self.config.response_header_name,\n            \u0022injected by WebAssembly extension\u0022\n        )?;\n    }\n    Ok (http::FilterHeadersStatus::Continue)\n}\n\u0060\u0060\u0060\n\n最后，在默认的示例设置中更新扩展配置。\n\n在 \u0060.getenvoy\/extension\/examples\/default\/extension.json\u0060 文件中\n\n\u0060\u0060\u0060{\u0022response_header_name\u0022:\u0022my-header\u0022}\u0060\u0060\u0060\n\n检查\n\n为了确认变更，重启示例设置：\n\n\u0060\u0060\u0060shell\n$ getenvoy extension run\n\u0060\u0060\u0060\n发出以下示例请求：\n\u0060\u0060\u0060sh\n$ curl -i localhost:10000\n\u0060\u0060\u0060\n应该看到类似于下面的输出：\n\u0060\u0060\u0060sh\nHTTP\/1.1 200 OK\ncontent-length: 22\ncontent-type: text\/plain\ndate: Tue, 07 Jul 2020 18:36:23 GMT\nserver: envoy\nx-envoy-upstream-service-time: 0\nmy-header: injected by WebAssembly extension\n \nHi from mock service!\n\u0060\u0060\u0060\n\n注意到一条额外的标头被注入到响应中。\n\n#### 增加一个新指标\n\nEnvoy 大力支持对新行为的可观测性。\n\n让我们更新扩展以暴露关于其新行为的度量。具体来说，提供一个计数器，显示被额外的标头注入了的 HTTP 响应的数量。 \n\n编辑源码如下（添加的行后加入了注释）：\n\n在 src\/stats.rs 文件中\n\n\u0060\u0060\u0060rust\nuse envoy::host::stats::Counter;\n\n\/\/\/ Sample stats.\npub struct SampleHttpFilterStats {requests_total: Box\u003cdyn Counter\u003e,\n   responses_injected_total: Box\u003cdyn Counter\u003e,              \/\/added code 新增行\n} \n\nimpl SampleHttpFilterStats {\n   pub fn new (requests_total: Box\u003cdyn Counter\u003e,\n       responses_injected_total: Box\u003cdyn Counter\u003e,          \/\/added code 新增行\n   ) -\u003e Self {\n       SampleHttpFilterStats {\n           requests_total,\n           responses_injected_total,                        \/\/added code 新增行\n       }\n   }\n\n   pub fn requests_total (\u0026self) -\u003e \u0026dyn Counter {\u0026*self.requests_total}\n\n   pub fn responses_injected_total (\u0026self) -\u003e \u0026dyn Counter { \/\/added code 新增行\n       \u0026*self.responses_injected_total\n   }\n}\n\u0060\u0060\u0060\n在 src\/factory.rs 中\n\u0060\u0060\u0060rust\n\/\/\/ Creates a new factory.\npub fn new (clock: \u0026\u0027a dyn Clock, stats: \u0026dyn Stats) -\u003e Result\u003cSelf\u003e {\n    let stats = SampleHttpFilterStats::new (stats.counter (\u0022examples.http_filter.requests_total\u0022)?,\n        stats.counter (\u0022examples.http_filter.responses_injected_total\u0022)?, \/\/added code 新增行\n    );\n    \/\/ Inject dependencies on Envoy host APIs\n    Ok (SampleHttpFilterFactory {config: Rc::new (SampleHttpFilterConfig::default ()),\n        stats: Rc::new (stats),\n        clock,\n    })\n}\n\u0060\u0060\u0060\n在 src\/filter.rs 中\n\u0060\u0060\u0060rust\n\/\/\/ Called when HTTP response headers have been received.\n\/\/\/\n\/\/\/ Use \u0060filter_ops\u0060 to access and mutate response headers.\nfn on_response_headers (\n    \u0026mut self,\n    _num_headers: usize,\n    _end_of_stream: bool,\n    filter_ops: \u0026dyn http::ResponseHeadersOps,\n) -\u003e Result\u003chttp::FilterHeadersStatus\u003e {if !self.config.response_header_name.is_empty () {\n        filter_ops.set_response_header (\n            \u0026self.config.response_header_name,\n           \u0022injected by WebAssembly extension\u0022,\n        )?;\n        self.stats.responses_injected_total ().inc ()?; \/\/added code\n    }\n    Ok (http::FilterHeadersStatus::Continue)\n}\n\u0060\u0060\u0060\n\n检查\n\n重启示例设置，发出示例请求并检查 Envoy 的指标：\n\n\u0060\u0060\u0060$ getenvoy extension run\u0060\u0060\u0060\n\n\u0060\u0060\u0060sh\n$ curl -i localhost:10000\n$ curl -i localhost:10000\n\n$ curl -s localhost:9901\/stats | grep responses_injected_total\n\u0060\u0060\u0060\n应该看到类似于以下的输出：\n\u0060\u0060\u0060\nexamples.http_filter.responses_injected_total: 2\n\u0060\u0060\u0060\n\n我们对使用 [GetEnvoy 扩展工具包](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/) 的开发流程的简单介绍到此结束。\n\n### 结束语\n\n目前为止，我们展示了使用 GetEnvoy 开发 Envoy 扩展是多么容易。\n\n结合 [getenvoy CLI](https:\/\/www.getenvoy.io\/) 的便利和 [Envoy Rust SDK](https:\/\/docs.rs\/envoy-sdk\/) 的指引，你可以轻松胜任这些工作。\n\n除了上面演示的 [HTTP Filter](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/filter\/http\/index.html) 扩展外，你还可以使用该工具包开发其他类型的 Envoy 扩展，比如 [Network Filter](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/filter\/network\/index.html) 和 [Access Logger](https:\/\/docs.rs\/envoy-sdk\/0.1.0\/envoy_sdk\/extension\/access_logger\/index.html)。\n\n### 未来计划\n\n在未来的几个月里，我们将为 GetEnvoy 添加一些新特性。\n\n一方面，我们将把重点转移到扩展用户体验上，为用户提供能够轻松发现和使用扩展的方法。 \n\n另一方面，我们将继续改善开发者流程的用户体验。对更多编程语言和更多扩展类型的支持将会到来。 \n\n敬请关注 GetEnvoy 的进一步更新！请与我们分享你在 Rust 中的 Envoy 扩展！\n\n', '\/trans\/introducing-getenvoy-extension-toolkit-for-webassembly-based-envoy-extensions\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文为大家介绍了如何使用开源项目 GetEnvoy 来扩展 Envoy。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-proxy-config-deep-dive/">Istio 的数据平面 Envoy Proxy 配置详解</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2019/01/07</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 的数据平面 Envoy Proxy 配置详解', '本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。', '\nEnvoy 是 Istio Service Mesh 中默认的 Sidecar，Istio 在 Envoy 的基础上按照 Envoy 的 xDS 协议扩展了其控制平面，在讲到 Envoy xDS 协议之前还需要我们先熟悉下 Envoy 的基本术语。下面列举了 Envoy 里的基本术语及其数据结构解析，关于 Envoy 的详细介绍请参考 [Envoy 官方文档](https:\/\/cloudnative.to\/envoy\/)，至于 Envoy 在 Service Mesh（不仅限于 Istio）中是如何作为转发代理工作的请参考网易云刘超的这篇[深入解读 Service Mesh 背后的技术细节 ](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)以及[理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持](\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)，本文引用其中的一些观点，详细内容不再赘述。\n\n![Envoy proxy 架构图](xds.svg)\n\n## 基本术语\n\n下面是您应该了解的 Envoy 里的基本术语：\n\n- **Downstream（下游）**：下游主机连接到 Envoy，发送请求并接收响应，即发送请求的主机。\n- **Upstream（上游）**：上游主机接收来自 Envoy 的连接和请求，并返回响应，即接受请求的主机。\n- **Listener（监听器）**：监听器是命名网地址（例如，端口、unix domain socket 等)，下游客户端可以连接这些监听器。Envoy 暴露一个或者多个监听器给下游主机连接。\n- **Cluster（集群）**：集群是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到集群的哪个成员。\n\n我将在本文的后半部分解释以上术语与 Kubernetes、Istio 中概念之间的联系。\n\n## 关于 xDS 的版本\n\n有一点需要大家注意，就是 Envoy 的 API 有 v1 和 v2 两个版本，从 Envoy 1.5.0 起 v2 API 就已经生产就绪了，为了能够让用户顺利的向 v2 版本的额 API 过度，Envoy 启动的时候设置了一个 \u0060--v2-config-only\u0060 的标志，Envoy 不同版本对 v1\/v2 API 的支持详情请参考 [Envoy v1 配置废弃时间表](https:\/\/groups.google.com\/forum\/#!topic\/envoy-announce\/Lb1QZcSclGQ)。\n\nEnvoy 的作者 Matt Klein 在 [Service Mesh 中的通用数据平面 API 设计](https:\/\/cloudnative.to\/blog\/the-universal-data-plane-api\/)这篇文章中说明了 Envoy API v1 的历史及其缺点，还有 v2 的引入。v2 API 是 v1 的演进，而不是革命，它是 v1 功能的超集。\n\n在 Istio 1.0 及以上版本中使用的是 **Envoy 1.8.0-dev** 版本，其支持 v2 的 API，同时在 Envoy 作为 Sidecar proxy 启动的使用使用了例如下面的命令：\n\n\u0060\u0060\u0060bash\n$ \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster ratings --service-node sidecar~172.33.14.2~ratings-v1-8558d4458d-ld8x9.default~default.svc.cluster.local --max-obj-name-len 189 --allow-unknown-fields -l warn --v2-config-only\n\u0060\u0060\u0060\n\n上面是都 Bookinfo 示例中的 rating pod 中的 sidecar 启动的分析，可以看到其中指定了 \u0060--v2-config-only\u0060，表明 Istio 1.0\u002b 只支持 xDS v2 的 API。\n\n## Istio sidecar proxy 配置\n\n假如您使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 部署了 Kubernetes 集群并开启了 [Istio Service Mesh](https:\/\/istio.io\/zh)，再部署 [bookinfo 示例](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)，那么在 \u0060default\u0060 命名空间下有一个名字类似于 \u0060ratings-v1-7c9949d479-dwkr4\u0060 的 Pod，使用下面的命令查看该 Pod 的 Envoy sidecar 的全量配置：\n\n\u0060\u0060\u0060bash\nkubectl -n default exec ratings-v1-7c9949d479-dwkr4 -c istio-proxy curl http:\/\/localhost:15000\/config_dump \u003e dump-rating.json\n\u0060\u0060\u0060\n\n将 Envoy 的运行时配置 dump 出来之后你将看到一个长 6000 余行的配置文件。\n\nIstio 会在为 Service Mesh 中的每个 Pod 注入 Sidecar 的时候同时为 Envoy 注入 Bootstrap 配置，其余的配置是通过 Pilot 下发的，注意整个数据平面即 Service Mesh 中的 Envoy 的动态配置应该是相同的。您也可以使用上面的命令检查其他 sidecar 的 Envoy 配置是否跟最上面的那个相同。\n\n使用下面的命令检查 Service Mesh 中的所有有 Sidecar 注入的 Pod 中的 proxy 配置是否同步。\n\n\u0060\u0060\u0060bash\n$ istioctl proxy-status\nPROXY                                                 CDS        LDS        EDS               RDS          PILOT                            VERSION\ndetails-v1-876bf485f-sx7df.default                    SYNCED     SYNCED     SYNCED (100%)     SYNCED       istio-pilot-5bf6d97f79-6lz4x     1.0.0\n...\n\u0060\u0060\u0060\n\n[istioctl](https:\/\/istio.io\/zh\/docs\/reference\/commands\/istioctl\/) 这个命令行工具就像 [kubectl](https:\/\/jimmysong.io\/kubernetes-handbook\/guide\/kubectl-cheatsheet.html) 一样有很多神器的魔法，通过它可以高效的管理 Istio 和 debug。\n\n## Envoy proxy 配置解析\n\nIstio envoy sidecar proxy 配置中包含以下四个部分。\n\n- **bootstrap**：Envoy proxy 启动时候加载的静态配置。\n- **listeners**：监听器配置，使用 LDS 下发。\n- **clusters**：集群配置，静态配置中包括 xds-grpc 和 zipkin 地址，动态配置使用  CDS 下发。\n- **routes**：路由配置，静态配置中包括了本地监听的服务的集群信息，其中引用了 cluster，动态配置使用 RDS 下发。\n\n每个部分中都包含静态配置与动态配置，其中 bootstrap 配置又是在集群启动的时候通过 sidecar 启动参数注入的，配置文件在 \u0060\/etc\/istio\/proxy\/envoy-rev0.json\u0060。\n\n由于 bootstrap 中的配置是来自 Envoy 启动时加载的静态文件，主要配置了节点信息、tracing、admin 和统计信息收集等信息，这不是本文的重点，大家可以自行研究。\n\nBootstrap 是 Envoy 中配置的根本来源，Bootstrap 消息中有一个关键的概念，就是静态和动态资源的之间的区别。例如 Listener 或 Cluster 这些资源既可以从 static_resources 静态的获得也可以从 dynamic_resources 中配置的 LDS 或 CDS 之类的 xDS 服务获取。\n\n### Listener\n\nListener 顾名思义，就是监听器，监听 IP 地址和端口，然后根据策略转发。\n\n**Listener 的特点**\n\n- 每个 Envoy 进程中可以有多个 Listener，Envoy 与 Listener 之间是一对多的关系。\n- 每个 Listener 中可以配置一条 filter 链表（filter_chains），Envoy 会根据 filter 顺序执行过滤。\n- Listener 可以监听下游的端口，也可以接收来自其他 listener 的数据，形成链式处理。\n- filter 是可扩展的。\n- 可以静态配置，也可以使用 LDS 动态配置。\n- 目前只能监听 TCP，UDP 还未支持。\n\n**Listener 的数据结构**\n\nListener 的数据结构如下，除了 \u0060name\u0060、\u0060address\u0060 和 \u0060filter_chains\u0060 为必须配置之外，其他都为可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022address\u0022: \u0022{...}\u0022,\n  \u0022filter_chains\u0022: [],\n  \u0022use_original_dst\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022drain_type\u0022: \u0022...\u0022,\n  \u0022listener_filters\u0022: [],\n  \u0022transparent\u0022: \u0022{...}\u0022,\n  \u0022freebind\u0022: \u0022{...}\u0022,\n  \u0022socket_options\u0022: [],\n  \u0022tcp_fast_open_queue_length\u0022: \u0022{...}\u0022,\n  \u0022bugfix_reverse_write_filter_order\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 listener 的 UUID，唯一限定名，默认 60 个字符，例如 \u006010.254.74.159_15011\u0060，可以使用命令参数指定长度限制。\n\n- **address**：监听的逻辑\/物理地址和端口号，例如\n\n  \u0060\u0060\u0060json\n  \u0022address\u0022: {\n         \u0022socket_address\u0022: {\n          \u0022address\u0022: \u002210.254.74.159\u0022,\n          \u0022port_value\u0022: 15011\n         }\n  }\n  \u0060\u0060\u0060\n\n- **filter_chains**：这是一个列表，Envoy 中内置了一些通用的 filter，每种 filter 都有特定的数据结构，Envoy 会根据该配置顺序执行 filter。Envoy 中内置的 filter 有：[envoy.client_ssl_auth](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/client_ssl_auth_filter#config-network-filters-client-ssl-auth)、[envoy.echo](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/echo_filter#config-network-filters-echo)、[Envoy.http_connection_manager](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/http_conn_man\/http_conn_man#config-http-conn-man)、[envoy.mongo_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/mongo_proxy_filter#config-network-filters-mongo-proxy)、[envoy.rate_limit](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/rate_limit_filter#config-network-filters-rate-limit)、[Envoy.redis_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/redis_proxy_filter#config-network-filters-redis-proxy)、[envoy.tcp_proxy](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/network_filters\/tcp_proxy_filter#config-network-filters-tcp-proxy)、[http_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/intro\/arch_overview\/http_filters)、[thrift_filters](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.8.0\/configuration\/thrift_filters\/thrift_filters)等。这些 filter 可以单独使用也可以组合使用，还可以自定义扩展，例如使用 Istio 中的 EnvoyFilter 配置。\n\n- **use_original_dst**：这是一个布尔值，如果使用 iptables 重定向连接，则代理接收的端口可能与原始目的地址的端口不一样。当此标志设置为 true 时，Listener 将重定向的连接切换到与原始目的地址关联的 Listener。如果没有与原始目的地址关联的 Listener，则连接由接收它的 Listener 处理。默认为 false。注意：该参数将被废弃，请使用原始目的地址的 Listener filter 替代。该参数的主要用途是：Envoy 通过监听 15001 端口将应用的流量截取后再由其他 Listener 处理而不是直接转发出去，详情见 [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener)。\n\n关于 Listener 的详细介绍请参考 Envoy v2 API reference - listener。\n\n### Route\n\n我们在这里所说的路由指的是 HTTP 路由，这也使得 Envoy 可以用来处理网格边缘的流量。HTTP 路由转发是通过路由过滤器实现的。该过滤器的主要职能就是执行路由表中的指令。除了可以做重定向和转发，路由过滤器还需要处理重试、统计之类的任务。\n\n**HTTP 路由的特点**\n\n- 前缀和精确路径匹配规则。\n- 可跨越多个上游集群进行基于权重\/百分比的路由。\n- 基于优先级的路由。\n- 基于哈希策略的路由。\n\n**Route 的数据结构**\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022virtual_hosts\u0022: [],\n  \u0022internal_only_headers\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022validate_clusters\u0022: \u0022{...}\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该名字跟 \u0060envoy.http_connection_manager\u0060 filter 中的 \u0060http_filters.rds.route_config_name\u0060 一致，在 Istio Service Mesh 中为 Envoy 下发的配置中的 Route 是以监听的端口号作为名字，而同一个名字下面的 \u0060virtual_hosts\u0060 可以有多个值（数组形式）。\n- **virtual_hosts**：因为 **VirtualHosts** 是 Envoy 中引入的一个重要概念，我们在下文将详细说明 \u0060virtual_hosts\u0060 的数据结构。\n- **validate_clusters**：这是一个布尔值，用来设置开启使用 cluster manager 来检测路由表引用的 cluster 是否有效。如果是路由表是通过 route_config 静态配置的则该值默认设置为 true，如果是使用 rds 动态配置的话，则该值默认设置为 false。\n\n#### route.VirtualHost\n\nVirtualHost 即上文中 Route 配置中的 \u0060virtual_hosts\u0060，VirtualHost 是路由配置中的顶级元素。每个虚拟主机都有一个逻辑名称以及一组根据传入请求的 host header 路由到它的域。这允许单个 Listener 为多个顶级域路径树提供服务。基于域选择了虚拟主机后 Envoy  就会处理路由以查看要路由到哪个上游集群或是否执行重定向。\n\n**VirtualHost 的数据结构**\n\n下面是 VirtualHost 的数据结构，除了 \u0060name\u0060 和 \u0060domains\u0060 是必须配置项外，其他皆为可选项。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022domains\u0022: [],\n  \u0022routes\u0022: [],\n  \u0022require_tls\u0022: \u0022...\u0022,\n  \u0022virtual_clusters\u0022: [],\n  \u0022rate_limits\u0022: [],\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: [],\n  \u0022cors\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022include_request_attempt_count\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：该 VirtualHost 的名字，一般是 FQDN 加端口，如 \u0060details.default.svc.cluster.local:9080\u0060。\n- **domains**：这是个用来匹配 VirtualHost 的域名（host\/authority header）列表，也可以使用通配符，但是通配符不能匹配空字符，除了仅使用 \u0060*\u0060 作为 domains，注意列表中的值不能重复和存在交集，只要有一条 domain 被匹配上了，就会执行路由。Istio 会为该值配置所有地址解析形式，包括 IP 地址、FQDN 和短域名等。\n- **routes**：针对入口流量的有序路由列表，第一个匹配上的路由将被执行。我们在下文将详细说明 route 的数据结构。\n\n下面是一个实际的 VirtualHost 的例子，该配置来自 [Bookinfo 应用](https:\/\/istio.io\/latest\/zh\/docs\/examples\/bookinfo\/)的 details 应用的 Sidecar 服务。\n\n\u0060\u0060\u0060json\n{\n            \u0022name\u0022: \u0022details.default.svc.cluster.local:9080\u0022,\n            \u0022domains\u0022: [\n                \u0022details.default.svc.cluster.local\u0022,\n                \u0022details.default.svc.cluster.local:9080\u0022,\n                \u0022details\u0022,\n                \u0022details:9080\u0022,\n                \u0022details.default.svc.cluster\u0022,\n                \u0022details.default.svc.cluster:9080\u0022,\n                \u0022details.default.svc\u0022,\n                \u0022details.default.svc:9080\u0022,\n                \u0022details.default\u0022,\n                \u0022details.default:9080\u0022,\n                \u002210.254.4.113\u0022,\n                \u002210.254.4.113:9080\u0022\n            ],\n            \u0022routes\u0022: [\n                {\n                    \u0022match\u0022: {\n                        \u0022prefix\u0022: \u0022\/\u0022\n                    },\n                    \u0022route\u0022: {\n                        \u0022cluster\u0022: \u0022outbound|9080||details.default.svc.cluster.local\u0022,\n                        \u0022timeout\u0022: \u00220s\u0022,\n                        \u0022max_grpc_timeout\u0022: \u00220s\u0022\n                    },\n                    \u0022decorator\u0022: {\n                        \u0022operation\u0022: \u0022details.default.svc.cluster.local:9080\/*\u0022\n                    },\n                    \u0022per_filter_config\u0022: {\n                        \u0022mixer\u0022: {\n                            \u0022forward_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022mixer_attributes\u0022: {\n                                \u0022attributes\u0022: {\n                                    \u0022destination.service.host\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    },\n                                    \u0022destination.service.uid\u0022: {\n                                        \u0022string_value\u0022: \u0022istio:\/\/default\/services\/details\u0022\n                                    },\n                                    \u0022destination.service.name\u0022: {\n                                        \u0022string_value\u0022: \u0022details\u0022\n                                    },\n                                    \u0022destination.service.namespace\u0022: {\n                                        \u0022string_value\u0022: \u0022default\u0022\n                                    },\n                                    \u0022destination.service\u0022: {\n                                        \u0022string_value\u0022: \u0022details.default.svc.cluster.local\u0022\n                                    }\n                                }\n                            },\n                            \u0022disable_check_calls\u0022: true\n                        }\n                    }\n                }\n            ]\n        }\n\u0060\u0060\u0060\n\n#### route.Route\n\n路由既是如何匹配请求的规范，也是对下一步做什么的指示（例如，redirect、forward、rewrite 等）。\n\n**route.Route 的数据结构**\n\n下面是是 route.Route 的数据结构，除了 \u0060match\u0060 之外其余都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022match\u0022: \u0022{...}\u0022,\n  \u0022route\u0022: \u0022{...}\u0022,\n  \u0022redirect\u0022: \u0022{...}\u0022,\n  \u0022direct_response\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022decorator\u0022: \u0022{...}\u0022,\n  \u0022per_filter_config\u0022: \u0022{...}\u0022,\n  \u0022request_headers_to_add\u0022: [],\n  \u0022request_headers_to_remove\u0022: [],\n  \u0022response_headers_to_add\u0022: [],\n  \u0022response_headers_to_remove\u0022: []\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **match**：路由匹配参数。例如 URL prefix（前缀）、path（URL 的完整路径）、regex（规则表达式）等。\n- **route**：这里面配置路由的行为，可以是 route、redirect 和 direct_response，不过这里面没有专门的一个配置项用来配置以上三种行为，而是根据实际填充的配置项来确定的。例如在此处添加 \u0060cluster\u0060 配置则暗示路由动作为”route“，表示将流量路由到该 cluster。详情请参考 route.RouteAction。\n- **decorator**：被匹配的路由的修饰符，表示被匹配的虚拟主机和 URL。该配置里有且只有一个必须配置的项 \u0060operation\u0060，例如 \u0060details.default.svc.cluster.local:9080\/*\u0060。\n- **per_filter_config**：这是一个 map 类型，\u0060per_filter_config\u0060 字段可用于为 filter 提供特定路由的配置。Map 的 key 应与 filleter 名称匹配，例如用于 HTTP buffer filter 的 \u0060envoy.buffer\u0060。该字段是特定于 filter 的，详情请参考 HTTP filter。\n\n### Cluster\n\nCluster 是指 Envoy 连接的一组逻辑相同的上游主机。Envoy 通过服务发现来发现 cluster 的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到 cluster 的哪个成员。\n\n**Cluster 的特点**\n\n- 一组逻辑上相同的主机构成一个 cluster。\n- 可以在 cluster 中定义各种负载均衡策略。\n- 新加入的 cluster 需要一个热身的过程才可以给路由引用，该过程是原子的，即在 cluster 热身之前对于 Envoy 及 Service Mesh 的其余部分来说是不可见的。\n- 可以通过多种方式来配置 cluster，例如静态类型、严格限定 DNS、逻辑 DNS、EDS 等。\n\n**Cluster 的数据结构**\n\nCluster 的数据结构如下，除了 \u0060name\u0060 字段，其他都是可选的。\n\n\u0060\u0060\u0060json\n{\n  \u0022name\u0022: \u0022...\u0022,\n  \u0022alt_stat_name\u0022: \u0022...\u0022,\n  \u0022type\u0022: \u0022...\u0022,\n  \u0022eds_cluster_config\u0022: \u0022{...}\u0022,\n  \u0022connect_timeout\u0022: \u0022{...}\u0022,\n  \u0022per_connection_buffer_limit_bytes\u0022: \u0022{...}\u0022,\n  \u0022lb_policy\u0022: \u0022...\u0022,\n  \u0022hosts\u0022: [],\n  \u0022load_assignment\u0022: \u0022{...}\u0022,\n  \u0022health_checks\u0022: [],\n  \u0022max_requests_per_connection\u0022: \u0022{...}\u0022,\n  \u0022circuit_breakers\u0022: \u0022{...}\u0022,\n  \u0022tls_context\u0022: \u0022{...}\u0022,\n  \u0022common_http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022http2_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022extension_protocol_options\u0022: \u0022{...}\u0022,\n  \u0022dns_refresh_rate\u0022: \u0022{...}\u0022,\n  \u0022dns_lookup_family\u0022: \u0022...\u0022,\n  \u0022dns_resolvers\u0022: [],\n  \u0022outlier_detection\u0022: \u0022{...}\u0022,\n  \u0022cleanup_interval\u0022: \u0022{...}\u0022,\n  \u0022upstream_bind_config\u0022: \u0022{...}\u0022,\n  \u0022lb_subset_config\u0022: \u0022{...}\u0022,\n  \u0022ring_hash_lb_config\u0022: \u0022{...}\u0022,\n  \u0022original_dst_lb_config\u0022: \u0022{...}\u0022,\n  \u0022least_request_lb_config\u0022: \u0022{...}\u0022,\n  \u0022common_lb_config\u0022: \u0022{...}\u0022,\n  \u0022transport_socket\u0022: \u0022{...}\u0022,\n  \u0022metadata\u0022: \u0022{...}\u0022,\n  \u0022protocol_selection\u0022: \u0022...\u0022,\n  \u0022upstream_connection_options\u0022: \u0022{...}\u0022,\n  \u0022close_connections_on_host_health_failure\u0022: \u0022...\u0022,\n  \u0022drain_connections_on_host_removal\u0022: \u0022...\u0022\n}\n\u0060\u0060\u0060\n\n下面是关于上述数据结构中的常用配置解析。\n\n- **name**：如果你留意到作为 Sidecar 启动的 Envoy 的参数的会注意到 \u0060--max-obj-name-len 189\u0060，该选项用来用来指定 cluster 的名字，例如 \u0060inbound|9080||ratings.default.svc.cluster.local\u0060。该名字字符串由 \u0060|\u0060 分隔成四个部分，分别是 \u0060inbound\u0060 或 \u0060outbound\u0060 代表入向流量或出向流量、端口号、subcluster 名称、FQDN，其中 subcluster 名称将对应于 Istio \u0060DestinationRule\u0060 中配置的 \u0060subnet\u0060，如果是按照多版本按比例路由的话，该值可以是版本号。\n- **type**：即服务发现类型，支持的参数有 \u0060STATIC\u0060（缺省值）、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060、\u0060EDS\u0060、\u0060ORIGINAL_DST\u0060。\n- **hosts**：这是个列表，配置负载均衡的 IP 地址和端口，只有使用了  \u0060STATIC\u0060、\u0060STRICT_DNS\u0060、\u0060LOGICAL_DNS\u0060 服务发现类型时才需要配置。\n- **eds_cluster_config**：如果使用 \u0060EDS\u0060 做服务发现，则需要配置该项目，其中包括的配置有 \u0060service_name\u0060 和 \u0060ads\u0060。\n\n## 参考\n\n- [深入解读 Service Mesh 背后的技术细节 - cnblogs.com](https:\/\/www.cnblogs.com\/163yun\/p\/8962278.html)\n- [理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持 - jimmysong.io](https:\/\/jimmysong.io\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n', '\/blog\/envoy-proxy-config-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 的概念，对应的 xDS 的版本以及配置的详细解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-mesh-in-kubernetes-tutorial/">在 Kubernetes 中使用 Envoy mesh 教程</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/28</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('在 Kubernetes 中使用 Envoy mesh 教程', '本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。', '\n本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。\n\n**注**：本教程中的示例来自 [envoy-steps](https:\/\/github.com\/datawire\/envoy-steps)，本文中使用的所有的代码和 YAML 配置见 [envoy-tutorial](https:\/\/github.com\/rootsongjc\/envoy-tutorial)。\n\n![Envoy Mesh 架构图](envoy-mesh-in-kubernetes.webp)\n\n## 前提条件\n\n使用 [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) 部署 kubernetes 集群，只要启动集群并安装了 CoreDNS 即可，无须安装其他插件。\n\n## 部署应用\n\n我们首先将应用部署到 Kubernetes 中。\n\n部署 postgres 数据库。\n\n\u0060\u0060\u0060bash\nkubectl apply -f postgres\n\u0060\u0060\u0060\n\n创建 usersvc 镜像。\n\n\u0060\u0060\u0060bash\ndocker build -t jimmysong\/usersvc:step1 .\n\u0060\u0060\u0060\n\n部署 usersvc。\n\n\u0060\u0060\u0060bash\nkubectl apply -f usersvc\n\u0060\u0060\u0060\n\n查看 uservc 的 ClusterIP 地址。\n\n\u0060\u0060\u0060bash\n$ kubectl get svc usersvc\nkubectl get svc usersvc\nNAME      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE\nusersvc   ClusterIP   10.254.176.248   \u003cnone\u003e        5000\/TCP   11m\n\u0060\u0060\u0060\n\n进到 node1 中访问该服务，因为我们要访问的是 ClusterIP，在我们自己的电脑上是无法直接访问的，所以进到虚拟机中操作。\n\n\u0060\u0060\u0060bash\n$ vagrant ssh node1\n$ curl 10.254.176.248:5000\n{\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022msg\u0022: \u0022user health check OK\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022\n}\n\u0060\u0060\u0060\n\n尝试添加一个名为 \u0060Alice\u0060 的用户。\n\n\u0060\u0060\u0060bash\n$ curl -X PUT -H \u0022Content-Type: application\/json\u0022 \\\n    -d \u0027{ \u0022fullname\u0022: \u0022Alice\u0022, \u0022password\u0022: \u0022alicerules\u0022 }\u0027 \\\n    10.254.176.248\/user\/alice\n\u0060\u0060\u0060\n\n将会看到类似如下的输出。\n\n\u0060\u0060\u0060json\n{\n  \u0022fullname\u0022: \u0022Alice\u0022,\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022,\n  \u0022uuid\u0022: \u0022EF43B475F65848C6BE708F436305864B\u0022\n}\n\u0060\u0060\u0060\n\n尝试再添加一个名为 \u0060Bob\u0060 的用户。\n\n\u0060\u0060\u0060bash\n$ curl -X PUT -H \u0022Content-Type: application\/json\u0022 \\\n    -d \u0027{ \u0022fullname\u0022: \u0022Bob\u0022, \u0022password\u0022: \u0022bobrules\u0022 }\u0027 \\\n    10.254.176.248\/user\/bob\n\u0060\u0060\u0060\n\n将会看到类似如下的输出。\n\n\u0060\u0060\u0060json\n{\n  \u0022fullname\u0022: \u0022Bob\u0022,\n  \u0022hostname\u0022: \u0022usersvc-7cf5bb9d85-9gx7w\u0022,\n  \u0022ok\u0022: true,\n  \u0022resolvedname\u0022: \u0022172.33.10.7\u0022,\n  \u0022uuid\u0022: \u00226AC944E7D4254D9A811A82C0FDAC3046\u0022\n}\n\u0060\u0060\u0060\n\n当应用部署完毕后，我们该部署 edge envoy 了。\n\n## 部署 edge envoy\n\n部署 edge envoy 的方式很简单，执行下面的命令。\n\n\u0060\u0060\u0060bash\nkubectl apply -f edge-envoy\n\u0060\u0060\u0060\n\n现在访问 edge envoy 是就可以路由到 \u0060usersvc\u0060 上的，当然直接访问 \u0060usersvc\u0060 也是可以的。\n\n我们看下 edge-envoy 的 envoy 配置文件定义。\n\n\u0060\u0060\u0060json\n{\n  \u0022listeners\u0022: [\n    {\n      \u0022address\u0022: \u0022tcp:\/\/0.0.0.0:80\u0022,\n      \u0022filters\u0022: [\n        {\n          \u0022type\u0022: \u0022read\u0022,\n          \u0022name\u0022: \u0022http_connection_manager\u0022,\n          \u0022config\u0022: {\n            \u0022codec_type\u0022: \u0022auto\u0022,\n            \u0022stat_prefix\u0022: \u0022ingress_http\u0022,\n            \u0022route_config\u0022: {\n              \u0022virtual_hosts\u0022: [\n                {\n                  \u0022name\u0022: \u0022backend\u0022,\n                  \u0022domains\u0022: [\u0022*\u0022],\n                  \u0022routes\u0022: [\n                    {\n                      \u0022timeout_ms\u0022: 0,\n                      \u0022prefix\u0022: \u0022\/user\u0022,\n                      \u0022cluster\u0022: \u0022usersvc\u0022\n                    }\n                  ]\n                }\n              ]\n            },\n            \u0022filters\u0022: [\n              {\n                \u0022type\u0022: \u0022decoder\u0022,\n                \u0022name\u0022: \u0022router\u0022,\n                \u0022config\u0022: {}\n              }\n            ]\n          }\n        }\n      ]\n    }\n  ],\n  \u0022admin\u0022: {\n    \u0022access_log_path\u0022: \u0022\/dev\/null\u0022,\n    \u0022address\u0022: \u0022tcp:\/\/127.0.0.1:8001\u0022\n  },\n  \u0022cluster_manager\u0022: {\n    \u0022clusters\u0022: [\n      {\n        \u0022name\u0022: \u0022usersvc\u0022,\n        \u0022connect_timeout_ms\u0022: 250,\n        \u0022type\u0022: \u0022strict_dns\u0022,\n        \u0022service_name\u0022: \u0022usersvc\u0022,\n        \u0022lb_type\u0022: \u0022round_robin\u0022,\n        \u0022features\u0022: \u0022http2\u0022,\n        \u0022hosts\u0022: [\n          {\n            \u0022url\u0022: \u0022tcp:\/\/usersvc:80\u0022\n          }\n        ]\n      }\n    ]\n  }\n}\n\u0060\u0060\u0060\n\n客户端访问 \u0060edge-envoy\u0060 的 \u0060ClusterIP:8000\/user\/health\u0060 就可以检查节点的健康状况。\n\n## 部署 usersvc2\n\n删除原来的 \u0060usersvc\u0060，部署第二版 \u0060usersvc2\u0060，它与原来的 \u0060usersvc\u0060 唯一不同的地方是在 \u0060entrypoint\u0060 中集成了 envoy，查看 \u0060Dockerfile\u0060 中指定的 \u0060entrypoint.sh\u0060 的内容便可知。\n\n\u0060\u0060\u0060bash\n#!\/bin\/sh\n\npython \/application\/service.py \u0026\n\/usr\/local\/bin\/envoy -c \/application\/envoy.json\n\u0060\u0060\u0060\n\n首先删除老的 \u0060usersvc\u0060。\n\n\u0060\u0060\u0060bash\nkubectl delete -f usersvc\n\u0060\u0060\u0060\n\n使用下面的命令部署 \u0060usersvc2\u0060，它仍然使用 \u0060usersvc\u0060 这个 service 名称。\n\n\u0060\u0060\u0060bash\nkubectl apply -f usersvc2\n\u0060\u0060\u0060\n\nEnvoy 以 out-of-process 的方式运行，对应用进程没有侵入性，也可以使用 sidecar 的方式运行，让 envoy 与 应用容器运行在同一个 pod 中。\n\n增加 \u0060usersvc2\u0060 的实例个数。\n\n\u0060\u0060\u0060bash\nkubectl scale --replicas=3 deployment\/usersvc\n\u0060\u0060\u0060\n\n此时我们有 3 个 usersvc 实例，现在通过 \u0060edge-envoy\u0060 的 \u0060ClusterIP:8000\/user\/health\u0060 检查节点的健康状况时，是不是会轮询的访问到后端的的 \u0060usersvc2\u0060 的实例呢？\n\n我们当初在 \u0060edge-node\u0060 的 \u0060envoy.json\u0060 中配置过 cluster 的，其中指定了 \u0060lb_type\u0060 为 \u0060round_robin\u0060 。\n\n\u0060\u0060\u0060json\n  \u0022cluster_manager\u0022: {\n    \u0022clusters\u0022: [\n      {\n        \u0022name\u0022: \u0022usersvc\u0022,\n        \u0022connect_timeout_ms\u0022: 250,\n        \u0022type\u0022: \u0022strict_dns\u0022,\n        \u0022service_name\u0022: \u0022usersvc\u0022,\n        \u0022lb_type\u0022: \u0022round_robin\u0022,\n        \u0022features\u0022: \u0022http2\u0022,\n        \u0022hosts\u0022: [\n          {\n            \u0022url\u0022: \u0022tcp:\/\/usersvc:80\u0022\n          }\n        ]\n      }\n    ]\n  }\n\u0060\u0060\u0060\n\n而且该 \u0060Service_name\u0060 也可以被 DNS 正确解析。\n\n\u0060\u0060\u0060bash\nroot@usersvc-55b6857d44-gcg5c:\/application# nslookup usersvc\nServer:         10.254.0.2\nAddress:        10.254.0.2#53\n\nName:   usersvc.envoy-tutorial.svc.cluster.local\nAddress: 10.254.123.166\n\u0060\u0060\u0060\n\n**答案是否定的。**\n\n虽然通过 DNS 可以正确的解析出 Service 的 ClusterIP，但是负载均衡不再通过 kube-proxy 实现，所以不论我们访问多少次 \u0060edge-envoy\u0060 永远只能访问到一个固定的后端 \u0060usersvc\u0060。\n\n## 服务发现服务 - SDS\n\nKubernetes 中的 DNS 可以发现所有 Service 的 ClusterIP，但是 DNS 中不包括所有 endpoint 地址，我们需要一个 SDS（服务发现服务）来发现服务的所有的 endpoint，我们将修改 \u0060lb_type\u0060，使用 \u0060sds\u0060 替代 \u0060strict_dns\u0060。\n\n执行下面的命令部署 SDS。\n\n\u0060\u0060\u0060bassh\nkubectl apply -f usersvc-sds\n\u0060\u0060\u0060\n\n因为在添加了 SDS 之后需要修改 \u0060edge-envoy\u0060 中的 \u0060envoy.josn\u0060 配置，在 \u0060clusters\u0060 字段中增加 \u0060sds\u0060 信息，我们将所有的配置都写好了，重新打包成了镜像，我们需要先删除之前部署的 \u0060edge-envoy\u0060。\n\n\u0060\u0060\u0060bash\nkubectl delete -f edge-envoy\n\u0060\u0060\u0060\n\n部署新的 \u0060edge-envoy2\u0060。\n\n\u0060\u0060\u0060bash\nkubectl apply -f edge-envoy2\n\u0060\u0060\u0060\n\n连续访问 \u0060usersvc\u0060 12 次看看输出结果如何。\n\n\u0060\u0060\u0060bash\nURL=http:\/\/172.17.8.101:30800\/user\/alice\nfor i in \u0060seq 1 12\u0060;do curl -s $URL|grep \u0022resolvedname\u0022|tr -d \u0022 \u0022|tr -d \u0022,\u0022|tr -d \u0027\u0022\u0027;done\n\u0060\u0060\u0060\n\n我们可以看到类似如下的输出：\n\n\u0060\u0060\u0060ini\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\nresolvedname:172.33.71.2\nresolvedname:172.33.88.2\nresolvedname:172.33.10.2\n\u0060\u0060\u0060\n\n再查看下 \u0060usersvc\u0060 服务的所有 pod 的 IP 地址。\n\n\u0060\u0060\u0060bash\n$ kubectl get pod -l service=usersvc -o wide\nNAME                       READY     STATUS    RESTARTS   AGE       IP            NODE\nusersvc-55b6857d44-mkfpv   1\/1       Running   0          9m        172.33.88.2   node1\nusersvc-55b6857d44-q98jg   1\/1       Running   0          9m        172.33.71.2   node2\nusersvc-55b6857d44-s2znk   1\/1       Running   0          9m        172.33.10.2   node3\n\u0060\u0060\u0060\n\n我们看到 round-robin 负载均衡生效了。\n\n## 参考\n\n- [Part 2: Deploying Envoy with a Python Flask webapp and Kubernetes](https:\/\/www.datawire.io\/envoyproxy\/envoy-flask-kubernetes\/)\n- [envoy-steps](https:\/\/github.com\/datawire\/envoy-steps)\n- [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) \n- [envoy-tutorial](https:\/\/github.com\/rootsongjc\/envoy-tutorial)\n', '\/blog\/envoy-mesh-in-kubernetes-tutorial\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是在 Kubernetes 集群中，使用 Envoy 来做 mesh，来为一个简单的使用 Python 编写的 Flask 应用程序做反向代理和负载均衡。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-archiecture-and-terminology/">Envoy 的架构与基本配置解析</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/27</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy 的架构与基本配置解析', '本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。', '\n在了解一门技术之前一开始就要了解其中的基本概念和术语，只有融入了该语境才能理解这门技术。本文将为大家介绍 Envoy 中的基本术语和重点概念。\n\n## 架构\n\n下图是 Envoy proxy 的架构图，显示了 host B 经过 Envoy 访问 host A 的过程。每个 host 上都可能运行多个 service，Envoy 中也可能有多个 Listener，每个 Listener 中可能会有多个 filter 组成了 chain。\n\n![Envoy proxy 架构图](envoy-arch.jpg)\n\n其中的基本术语将在下面解释。\n\n## 基本术语\n\n**Host**：能够进行网络通信的实体（在手机或服务器等上的应用程序）。在 Envoy 中主机是指逻辑网络应用程序。只要每台主机都可以独立寻址，一块物理硬件上就运行多个主机。\n\n**Downstream**：下游（downstream）主机连接到 Envoy，发送请求并或获得响应。\n\n**Upstream**：上游（upstream）主机获取来自 Envoy 的链接请求和响应。\n\n**Cluster**: 集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。\n\n**Mesh**：一组互相协调以提供一致网络拓扑的主机。Envoy mesh 是指一组 Envoy 代理，它们构成了由多种不同服务和应用程序平台组成的分布式系统的消息传递基础。\n\n**运行时配置**：与 Envoy 一起部署的带外实时配置系统。可以在无需重启 Envoy 或 更改 Envoy 主配置的情况下，通过更改设置来影响操作。\n\n**Listener**: 侦听器（listener）是可以由下游客户端连接的命名网络位置（例如，端口、unix 域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3\/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（**LDS**）动态获取。\n\n**Listener filter**：Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。\n\n**Http Route Table**：HTTP 的路由规则，例如请求的域名，Path 符合什么规则，转发给哪个 Cluster。\n\n**Health checking**：健康检查会与 SDS 服务发现配合使用。但是，即使使用其他服务发现方式，也有相应需要进行主动健康检查的情况。详见 health checking。\n\n## xDS\n\nxDS 是一个关键概念，它是一类发现服务的统称，其包括如下几类：\n\n- CDS: Cluster Discovery Service\n- EDS: Endpoint Discovery Service\n- SDS: Secret Discovery Service\n- RDS: Route Discovery Service\n- LDS: Listener Discovery Service\n\n正是通过对 xDS 的请求来动态更新 Envoy 配置，另外还有个 ADS（Aggregated Discovery Service）通过聚合的方式解决以上 xDS 的更新顺序问题。\n\n## Envoy Mesh\n\nEnvoy Mesh 指的是由 envoy 做负载均衡和代理的 mesh。该 Mesh 中会包含两类 envoy：\n\n- Edge envoy：即流量进出 mesh 时候的 envoy，相当于 kubernetes 中的 ingress。\n- Service envoy：服务 envoy 是跟每个 Service 实例一起运行的，应用程序无感知的进程外工具，在 kubernetes 中会与应用容器以 sidecar 形式运行在同一个 pod 中。\n\nEnvoy 即可以单独作为 edge envoy，也可以仅做 service envoy 使用，也可以两者同时使用。Mesh 中的所有 envoy 会共享路由信息。\n\n## Envoy 配置\n\nEnvoy 中的配置包括两大类：listenner 配置和 cluster 配置。\n\n### Listener 配置\n\n我们知道 Envoy 中可以配置一组 listener 以实现复杂的处理逻辑。Listener 中设置监听的 TCP 端口，还有一组 filter 对这些端口上的数据流进行处理。\n\n\u0060\u0060\u0060yaml\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n\u0060\u0060\u0060\n\n这是一个 \u0060http_connection_manager\u0060 例子，其中必须包含 \u0060virtual_hosts\u0060 配置，而 \u0060virtual_hosts\u0060 配置中必须包含以下几项配置：\n\n- \u0060name\u0060：服务名称\n- \u0060domains\u0060：DNS 域名，必须能跟 \u0060virtual_host\u0060 的 URL 匹配 \n- \u0060routes\u0060：路由列表\n\n每个路由中还可以包含以下配置：\n\n- \u0060prefix\u0060：URL 路径前缀\n- \u0060cluster\u0060：处理该请求的 envoy cluster\n- \u0060timeout_ms\u0060：当出错时的超时时间\n\n如上面的例子中，我们还需要定义 \u0060service1\u0060 cluster 和 \u0060service2\u0060 cluster。\n\n### Cluster 配置\n\nCluster 是一组逻辑相似的主机配置，定义哪些主机属于一个服务，cluster 的配置中包含了服务发现和负载均衡方式配置。依然是参考使用 Envoy 作为前端代理中的配置：\n\n\u0060\u0060\u0060yaml\n clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\n\u0060\u0060\u0060\n\nCluster 的配置中至少包含以下信息：\n\n- \u0060name\u0060：cluster 名称，就是服务名称\n- \u0060type\u0060：该 cluster 怎么知道主机是否启动？即服务发现类型，有以下方式：\n  - \u0060static\u0060：监听 cluster 中的所有主机\n  - \u0060strict_dns\u0060：envoy 会监听 DNS，每个匹配的 A 记录都会认定为有效\n  - \u0060logical_dns\u0060：envoy 将使用 DNS 来增加主机，如果 DNS 不再返回该主机也不会删除这些主机信息\n  - \u0060sds\u0060：即 Service Discovery Service，envoy 访问外部的 REST 获取 cluster 成员信息\n- \u0060lb_type\u0060：cluster 的负载均衡类型，有以下方式：\n  - \u0060round_robin\u0060：轮询主机\n  - \u0060weighted_least_request\u0060：最近获得最少请求的主机\n  - \u0060random\u0060：随机\n- \u0060hosts\u0060：能够定义 cluster 中主机的 URL 地址，通常是\u0060tcp:\/\/\u0060 URL\n\n## 参考\n\n- [Part 1: Getting started with Envoy Proxy for microservices resilience - getambassador.io](https:\/\/www.getambassador.io\/resources\/getting-started-envoyproxy-microservices-resilience\/\/)\n', '\/blog\/envoy-archiecture-and-terminology\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文介绍了 Envoy proxy 中的基本概念、配置与架构解析。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/blog/envoy-as-front-proxy/">使用 Envoy 作为前端代理</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               2018/04/22</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('使用 Envoy 作为前端代理', '本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。', '\n[Envoy](https:\/\/github.com\/envoyproxy\/envoy) 是一款由 Lyft 开源的，使用 C\u002b\u002b 编写的 L7 代理和通信总线，目前是 [CNCF](https:\/\/cncf.io) 旗下的开源项目，代码托管在 GitHub 上，它也是 [Istio](https:\/\/istio.io) service mesh 中默认的 data plane。本文将给出使用 Envoy 作为 service mesh 的数据平面的示例，应用使用 docker-compose 编排。\n\n## 特性\n\nEnvoy 包括如下特性：\n\n- 进程外架构，不侵入应用进程\n- 使用现代版 C\u002b\u002b11 代码\n- L3\/L4 filter 架构\n- HTTP L7 filter 架构\n- 支持 HTTP\/2\n- HTTP L7 routing\n- 支持 gRPC\n- 支持 MongoDB L7\n- 动态配置\n- 最佳可观测性\n- 支持 front\/edge proxy\n- 高级负载均衡\n- 健康检查\n- 服务发现\n- 支持 DynamoDB L7\n\nEnvoy 本身无法构成一个完整的 Service Mesh，但是它可以作为 service mesh 中的应用间流量的代理，负责 service mesh 中的数据层。\n\n更多信息请参考 [Envoy 官网](https:\/\/www.envoyproxy.io\/)。\n\n## Envoy 作为前端代理\n\n本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。\n\n## 快速开始\n\nEnvoy 中的所有规则配置跟 Kubernetes 一样都是通过 YAML 文件来完成的。在继续下面的步骤之前，首先克隆 Envoy 的 GitHub repo。\n\n\u0060\u0060\u0060bash\ngit clone https:\/\/github.com\/envoyproxy\/envoy.git\n\u0060\u0060\u0060\n\n## 运行 sandbox 测试\n\nEnvoy 官方提供了以下打包用例：\n\n- Front Proxy\n- [Zipkin Tracing](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/zipkin_tracing)\n- Jaeger Tracing\n- gRPC Bridge\n\n全部可以使用 \u0060docker-compose\u0060 运行，代码可以在 https:\/\/github.com\/envoyproxy\/envoy\/tree\/master\/examples 找到。\n\n## Front proxy\n\nEnvoy 在 envoymesh 的边缘做反向代理，详细使用方式见 \u003chttps:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/start\/sandboxes\/front_proxy\u003e，在此我将解说下以下问题：\n\n- Envoy 是如何作为进程外架构运行的？\n- 为何说 Envoy 是无侵入式架构？\n- Envoy 作为边缘反向代理能做什么？\n\n本示例的架构图如下所示，此时 Envoy 将作为一个反向代理，类似于 Nginx，但与 Nginx 不同的是它还会作为一个进程，伴随每个服务一起运行在同一个容器中（在 Kubernetes 中可以作为 Sidecar 与应用容器一起运行在同一个 Pod 中）。\n\n![Front proxy 部署结构图](envoyproxy-docker-compose.png)\n\n在此示例中一共有 3 个服务，我们需要为其创建容器编排的 \u0060docker-compose.yml\u0060 文件。\n\n\u0060\u0060\u0060yaml\nversion: \u00272\u0027\nservices:\n\n  front-envoy:\n    build:\n      context: .\n      dockerfile: Dockerfile-frontenvoy\n    volumes:\n      - .\/front-envoy.yaml:\/etc\/front-envoy.yaml\n    networks:\n      - envoymesh\n    expose:\n      - \u002280\u0022\n      - \u00228001\u0022\n    ports:\n      - \u00228000:80\u0022\n      - \u00228001:8001\u0022\n\n  service1:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service1\n    environment:\n      - SERVICE_NAME=1\n    expose:\n      - \u002280\u0022\n\n  service2:\n    build:\n      context: .\n      dockerfile: Dockerfile-service\n    volumes:\n      - .\/service-envoy.yaml:\/etc\/service-envoy.yaml\n    networks:\n      envoymesh:\n        aliases:\n          - service2\n    environment:\n      - SERVICE_NAME=2\n    expose:\n      - \u002280\u0022\n\nnetworks:\n  envoymesh: {}\n\u0060\u0060\u0060\n\n使用 docker-compose 启动可以保证三个服务都在同一个网络内，即 \u0060frontproxy_envoymesh\u0060 网络中。\n\n其中 \u0060front-envoy\u0060 是前端（边缘）Envoy 服务，用来做反向代理，它使用的是 \u0060Dockerfile-frontenvoy\u0060 文件来构建镜像的，我们来看下该 \u0060Dockerfile\u0060 的内容。\n\n\u0060\u0060\u0060dockerfile\nFROM envoyproxy\/envoy:latest\n\nRUN apt-get update \u0026\u0026 apt-get -q install -y \\\n    curl\nCMD \/usr\/local\/bin\/envoy -c \/etc\/front-envoy.yaml --service-cluster front-proxy\n\u0060\u0060\u0060\n\n其中 \u0060\/etc\/front-envoy.yaml\u0060 是本地的 \u0060front-envoy.yaml\u0060 挂载进去的。我们看下该文件的内容。\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 80\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        config:\n          codec_type: auto\n          stat_prefix: ingress_http\n          route_config:\n            name: local_route\n            virtual_hosts:\n            - name: backend\n              domains:\n              - \u0022*\u0022\n              routes:\n              - match:\n                  prefix: \u0022\/service\/1\u0022\n                route:\n                  cluster: service1\n              - match:\n                  prefix: \u0022\/service\/2\u0022\n                route:\n                  cluster: service2\n          http_filters:\n          - name: envoy.router\n            config: {}\n  clusters:\n  - name: service1\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service1\n        port_value: 80\n  - name: service2\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    hosts:\n    - socket_address:\n        address: service2\n        port_value: 80\nadmin:\n  access_log_path: \u0022\/dev\/null\u0022\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 8001\n\u0060\u0060\u0060\n\n我们看到其中包括了三大配置项：\n\n- **static_resources**：路由配置信息\n- **cluster**：envoymesh 的服务注册信息\n- **admin**：管理接口，可以通过访问 8001 端口的，访问 \u0060\/stats\u0060  获取当前 envoymesh 的一些统计信息，访问 \u0060\/server_info\u0060 获取 Envoy 的版本信息\n\n使用 \u0060docker-compose\u0060 启动三个容器。\n\n\u0060\u0060\u0060bash\n$ pwd\nenvoy\/examples\/front-proxy\n$ docker-compose up --build -d\n$ docker-compose ps\n        Name                       Command               State      Ports\n-------------------------------------------------------------------------------------------------------------\nexample_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ... Up       80\/tcp\nexample_front-envoy_1   \/bin\/sh -c \/usr\/local\/bin\/ ... Up       0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\n\u0060\u0060\u0060\n\n我们下面将过一遍 Envoy 作为前端代理的所有功能，这些功能是通用功能。\n\n### 路由\n\n访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n$ curl -v localhost:8000\/service\/1\n* \nTrying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/1 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:26:33 GMT\n\u003c x-envoy-upstream-service-time: 14\n\u003c\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n访问 service2 \u003chttp:\/\/localhost:8000\/service\/2\u003e 将看到如下输出。\n\n\u0060\u0060\u0060bash\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8000 (#0)\n\u003e GET \/service\/2 HTTP\/1.1\n\u003e Host: localhost:8000\n\u003e User-Agent: curl\/7.54.0\n\u003e Accept: *\/*\n\u003e\n\u003c HTTP\/1.1 200 OK\n\u003c content-type: text\/html; charset=utf-8\n\u003c content-length: 89\n\u003c server: envoy\n\u003c date: Fri, 20 Apr 2018 08:27:27 GMT\n\u003c x-envoy-upstream-service-time: 10\n\u003c\nHello from behind Envoy (service 2)! hostname: f6650e1911a0 resolvedhostname: 172.18.0.3\n* Connection #0 to host localhost left intact\n\u0060\u0060\u0060\n\n我们看到访问请求被路由到了正确的服务后端。\n\n### 负载均衡\n\n增加 service1 的示例数。\n\n\u0060\u0060\u0060bash\n$ docker-compose scale service1=3\nWARNING: The scale command is deprecated. Use the up command with the --scale flag instead.\nStarting frontproxy_service1_1 ... done\nCreating frontproxy_service1_2 ... done\nCreating frontproxy_service1_3 ... done\n\n$ docker-compose ps\n          Name                        Command               State                            Ports\n---------------------------------------------------------------------------------------------------------------------------\nfrontproxy_front-envoy_1   \/usr\/bin\/dumb-init -- \/bin ...   Up      10000\/tcp, 0.0.0.0:8000-\u003e80\/tcp, 0.0.0.0:8001-\u003e8001\/tcp\nfrontproxy_service1_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_2      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service1_3      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\nfrontproxy_service2_1      \/bin\/sh -c \/usr\/local\/bin\/ ...   Up      10000\/tcp, 80\/tcp\n\u0060\u0060\u0060\n\n我们看到现在 service1 已经有了 3 个实例，现在再访问 service1 \u003chttp:\/\/localhost:8000\/service\/1\u003e。\n\n\u0060\u0060\u0060bash\n$ while true;do curl localhost:8000\/service\/1;sleep 1;done\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\nHello from behind Envoy (service 1)! hostname: a3e4185a9a49 resolvedhostname: 172.18.0.4\nHello from behind Envoy (service 1)! hostname: fe44dba64122 resolvedhostname: 172.18.0.5\nHello from behind Envoy (service 1)! hostname: c5b9f1289e0f resolvedhostname: 172.18.0.6\n\u0060\u0060\u0060\n\n我们看到对 service1 的已经有负载均衡了，使用的策略是 \u0060round_robin\u0060，这些都是在 \u0060front-envoy.yaml\u0060 文件中的 \u0060cluster\u0060 项下配置的。\n\n### admin 端点\n\n访问 \u003chttp:\/\/localhost:8001\u003e 可以看到 Envoy admin 提供以下管理 API 端点。\n\n| 命令                 | 描述                                     |\n| -------------------- | ---------------------------------------- |\n| \/                    | Admin 主页                               |\n| \/certs               | 打印机器上的 certs                       |\n| \/clusters            | upstream cluster 状态                    |\n| \/config_dump         | 输出当前的 Envoy 配置                    |\n| \/cpuprofiler         | 开启\/关闭 CPU profiler                   |\n| \/healthcheck\/fail    | 导致服务失败健康检查                     |\n| \/healthcheck\/ok      | 导致服务通过健康检查                     |\n| \/help                | 打印管理命令的帮助信息                   |\n| \/hot_restart_version | 打印热重启兼容版本                       |\n| \/listeners           | 打印 listener 地址                       |\n| \/logging             | 查询\/更改日志级别                        |\n| \/quitquitquit        | 退出服务                                 |\n| \/reset_counters      | 将计数器重置为 1                         |\n| \/runtime             | 打印运行时值                             |\n| \/runtime_modify      | 修改运行时值                             |\n| \/server_info         | 打印服务器版本\/状态信息                  |\n| \/stats               | 打印服务器状态统计信息                   |\n| \/stats\/prometheus    | 打印 prometheus 格式的服务器状态统计信息 |\n\nEnvoy 提供了 API 管理端点，可以对 Envoy 进行动态配置，参考 v2 API reference。\n\n## 参考\n\n- Front proxy\n', '\/blog\/envoy-as-front-proxy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">本文是使用 Envoy 作为前端代理的介绍，仅使用 docker 容器和 docker-compose 做编排在单机中运行，帮助我们从更底层了解 Envoy，当我们将 Envoy 作为 Istio Service Mesh 的 data panel 的时候将更加游刃有余。</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/categories/envoy/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/categories/envoy/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/categories/envoy/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/categories/envoy/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
     
     
     
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      专栏
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(81)</span>
        </a>
      
        <a href="/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(42)</span>
        </a>
      
        <a href="/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(25)</span>
        </a>
      
        <a href="/categories/%e9%9a%8f%e7%ac%94" class="sidebar-item">
            <span>随笔</span>
            <span>(22)</span>
        </a>
      
        <a href="/categories/%e5%85%b6%e4%bb%96" class="sidebar-item">
            <span>其他</span>
            <span>(19)</span>
        </a>
      
        <a href="/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%b8%9a%e6%80%81" class="sidebar-item">
            <span>业态</span>
            <span>(17)</span>
        </a>
      
        <a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="sidebar-item">
            <span>云原生</span>
            <span>(14)</span>
        </a>
      
        <a href="/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%ae%89%e5%85%a8" class="sidebar-item">
            <span>安全</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e5%bc%80%e6%ba%90" class="sidebar-item">
            <span>开源</span>
            <span>(9)</span>
        </a>
      
        <a href="/categories/%e6%97%85%e8%a1%8c" class="sidebar-item">
            <span>旅行</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e5%b7%a5%e5%85%b7" class="sidebar-item">
            <span>工具</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7" class="sidebar-item">
            <span>可观测性</span>
            <span>(5)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      资料
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/categories/%e5%87%ba%e7%89%88%e7%89%a9" class="sidebar-item">
            <span>出版物</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e7%94%b5%e5%ad%90%e4%b9%a6" class="sidebar-item">
            <span>翻译电子书</span>
            <span>(8)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3" class="sidebar-item">
            <span>翻译文档</span>
            <span>(7)</span>
        </a>
      
        <a href="/categories/%e7%bf%bb%e8%af%91%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>翻译图书</span>
            <span>(6)</span>
        </a>
      
        <a href="/categories/%e5%8e%9f%e5%88%9b%e5%9b%be%e4%b9%a6" class="sidebar-item">
            <span>原创图书</span>
            <span>(2)</span>
        </a>
      
        <a href="/categories/%e6%95%99%e7%a8%8b%e6%89%8b%e5%86%8c" class="sidebar-item">
            <span>教程手册</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">联系</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">微信公众号</li>
            
            
            <li class="mb-4"><img src="/images/servicemesher-wechat.webp" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">博客</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/blog/istio-ambient-l7-flow-analysis/">深入 Istio Ambient 模式：从 ztunnel 到 Waypoint 代理的 L7 流量路径解析</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/building-private-ai-knowledge-base-anythingllm/">探索 AnythingLLM：借助开源 AI 打造私有化智能知识库</a></li>
            
            <li class="mb-3"><a class="text-color" href="/blog/migrate-to-istio-telemetry-api/">从 MeshConfig 迁移到 Istio Telemetry API：提升网格观测性和灵活性</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">链接</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io/latest/zh/" target="_blank" rel="noopener noreferrer">
                  Istio 服务网格
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate 公司
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://space.bilibili.com/515485124" target="_blank" rel="noopener noreferrer">
                  云原生学院|Bilibili
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener noreferrer">
                  云原生开源项目大全
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener noreferrer">
                  云原生社区（中国）
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">教程</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Envoy 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener noreferrer">
                  Istio 基础教程
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/kubernetes-handbook/" >
                  Kubernetes 基础教程
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="/book/envoy-made-simple/" >
                  简明 Envoy 教程
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">通知</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/notice/nist-sp-800-233-service-mesh-proxy-models/">资料分享：云原生应用服务网格代理模型的威胁分析指南</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/kubecon-china-2024-panel/">KubeCon China 2024（香港）</a></li>
            
            <li class="mb-3"><a class="text-color" href="/notice/website-revamp-notice/">网站改版通知</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song 保留所有权利</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>










<script src="/js/wowchemy-search.min.7a37268e7bbe4a9160c2e4c33b749816.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
