<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Blog - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog Posts">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/blog/" />
  <meta property="og:title" content="Blog | Jimmy Song" />
  <meta property="twitter:title" content="Blog | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog Posts" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog Posts" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/trans/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Blog
                </p>
                <p class="page-description">
                    Jimmy Song&rsquo;s Blog Posts
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/kubecon-china-2024-recap/">KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/cloud-native"> 
             Cloud Native
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology', 'A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio\u0027s Ambient mode and API gateways and their profound impact on the industry.', '\nThis year\u0027s [KubeCon China](https:\/\/events.linuxfoundation.org\/kubecon-cloudnativecon-open-source-summit-ai-dev-china\/) marked its first-ever occurrence in Hong Kong, spanning three days. As a participant and a panel moderator, I will share in this article the highlights of the conference and the in-depth discussions on service meshes and gateway technologies.\n\n![KubeCon China Scene](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-hall.webp)\n\n## Key Themes\n\nThis edition of KubeCon introduced a theme on AI and developers, here are some of the focal points:\n\n1. **Practical Applications of Cloud Native Technologies in Industries**: Especially in the electric vehicle and cybersecurity sectors, such as the joint discussion by Huawei and NIO on how cloud native technologies can accelerate innovation in electric vehicles.\n\n2. **The Power of the Kubernetes Community**: Detailed discussions on the influence of China\u0027s Kubernetes community and its role in advancing regional cloud native activities.\n\n3. **The Integration of Open Source Technology and Artificial Intelligence**: Discussions on the advanced position of China and Hong Kong in the fields of open source and AI technologies and how these are driving regional technological innovation and development.\n\n4. **Latest Developments in Service Meshes and API Gateways**: Including updates on service mesh technologies and how they work in conjunction with Kubernetes schedulers to enhance system throughput.\n\n5. **New Strategies for Supply Chain Security**: Focusing on the latest developments in securing supply chains, particularly practical guidelines on SLSA compliance.\n\n6. **Multicluster Management and Edge Computing**: Discussions on strategies for effective management and innovation across different architectures and systems.\n\n7. **Optimization of AI Large Model Inference Performance**: Discussion on performance acceleration in serverless architectures for AI large model inference and related technological advancements.\n\n## Istio and Modern API Gateways: Exploring the Future of Service Meshes\n\nIn a [roundtable discussion](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYY6\/istio-and-modern-api-gateways-navigating-the-future-of-service-meshes-istiorejiong-apijie-daepqiu-jie-zha-jimmy-song-jianpeng-he-tetrate-jiaqi-zhang-alibaba-cloud-jintao-zhang-kong-inc-xunzhuo-liu-tencent) that I participated in with industry leaders from Tetrate, Alibaba Cloud, and Kong Inc., we delved deeply into the latest developments and integrations of Istio and API gateways.\n\n![KubeCon China 2024 Istio and Modern API Gateways Panel](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-panel.webp)\n\n1. **Innovations in Istio**: We discussed the latest version update of Istio (Istio 1.123) and key features such as optimizations in the Ambient mode, a new architectural choice that reduces resource consumption while enhancing performance.\n\n2. **Practical Comparison Between Ambient and Sidecar Modes**:\n   - **When to Choose Sidecar**: When high isolation and detailed traffic management are required.\n   - **When to Choose Ambient**: When pursuing ultimate performance and resource efficiency.\n\n3. **Challenges in the Development of Ambient Mode**: Despite its advantages, Ambient mode still faces challenges in complex traffic management and multi-tenant environments.\n\n4. **Service Mesh Optimization Strategies**: Discussing methods to enhance the performance and efficiency of cloud applications through service mesh improvements.\n\n5. **Integration of Service Meshes and API Gateways**: Demonstrating how these two technologies work together to support more complex deployment and operational modes.\n\n## Future Perspectives on Istio\n\nIn the [presentation by Zhonghu Xu and Jianpeng He](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcG\/what-is-the-future-of-service-mesh-sidecar-or-sidecarless-jie-zha-dyagsyi-wu-pi-yi-wu-zhonghu-xu-huawei), we gained insights into the possible future directions of Istio:\n\n- **Dual Mode Drive**: Istio is likely to support both the Ambient mode and the traditional Sidecar mode simultaneously. Ambient mode suits users seeking performance and cost optimization, while the Sidecar mode will continue to support users requiring comprehensive functionalities.\n\n- **Support for Gateway API**: Istio\u0027s support for the Gateway API provides users with more flexible routing and policy configuration options.\n\n- **Application of Waypoints Strategies**: Waypoints need not be limited to Istio or Envoy. Using the Gateway API and GAMMA, any standard-compliant implementation can serve as a Waypoint, offering greater flexibility and scalability for service meshes.\n\n### Sandwich Waypoint\n\nThey emphasized the Sandwich Waypoint, which supports:\n\n- **Traffic Redirection**: By setting the \u0060istio.io\/use-waypoint: {namespace}\/{gateway-name}\u0060 annotation, traffic to a target service, pod, or within a namespace can be redirected to the same Waypoint.\n- **Waypoint Deployment**: Users can deploy a Waypoint by creating a Gateway object. Unlike the original implementation of Waypoint, the new deployment method will include associated services and service accounts, not just the Waypoint instance.\n- **Routing and Policy Configuration**: Using the Gateway API for routing and policy configuration provides more customization options for users and providers.\n\nThis represents a mode in Istio\u0027s Ambient mode for capturing layer 7 traffic, as illustrated below.\n\n![Sandwich Waypoint Traffic Capture](istio-ambient-traffic-capture.svg)\n\nThe steps for capturing layer 7 traffic with Istio Sandwich Waypoint are as follows:\n\n1. Terminate the HBONE connection via zTunnel, arriving at the Waypoint, with zTunnel responsible for decoding the HBONE protocol.\n2. Waypoint extracts destination addresses, source addresses, etc., to handle traffic and determine forwarding locations.\n3. Waypoint expands or parses the transport layer encapsulation (TLV) data, with proxies supporting TLV processing to provide additional context.\n4. Waypoint communicates with the peer zTunnel, coordinating with the server-side zTunnel to ensure correct traffic transfer.\n5. Encapsulate HBONE, sent by the server-side zTunnel to the final server destination, achieving fine-grained traffic management and routing in an Istio environment while maintaining compatibility with existing network protocols.\n\n## Cutting-Edge Extensions in Envoy Gateway\n\nIn a [presentation](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcX\/gateway-api-and-beyond-introducing-envoy-gateways-gateway-api-extensions-jie-api-daeptao-envoyjie-zha-jie-api-huabing-zhao-tetrate) at KubeCon, Huabing Zhao discussed how Envoy Gateway enhances its capabilities and flexibility by extending the Kubernetes Gateway API, covering a wide range of matching and routing capabilities, new resource and policy models, and details of security policies.\n\n- **Gateway API Compatibility**: Envoy Gateway is fully compatible with the Gateway API and offers a wide range of matching and routing options. These include HTTP host and path matching, HTTP header-based operations, weighted load balancing, and support for gRPC, UDP, and TCP routing.\n- **Policies for Advanced Traffic Management:** The introduction of ClientTrafficPolicy and BackendTrafficPolicy provides users with more granular control over traffic management for both upstream and downstream connections, including features such as rate limiting, retries, load balancing, circuit breakers, and more.\n- **Enhancement of Security and Authentication**: The introduced SecurityPolicy supports CORS, HTTP basic authentication, OIDC, JWT authentication, and can integrate with various identity providers. It also provides detailed access control, allowing authorization based on the requester\u0027s original IP, JWT claims, etc.\n- **Expanding Functionality with Custom Extensions:** Envoy Gateway offers support for custom extensions through WASM (WebAssembly) and external process extensions. This allows users to enhance the gateway’s functionality by integrating their own customized extensions, tailored to specific use cases and operational needs.\n- **Future Exploration**: Future versions are expected to support non-Kubernetes environments deployment, optimize memory usage in the control plane, and expand authorization capabilities.\n\n## Conclusion\n\nThrough this conference, we gained insights into Istio\u0027s Ambient mode and the developments in Envoy Gateway. The discussions on these technologies not only forecast future trends but also provided practical insights to facilitate the implementation and innovation of technologies.', '\/en\/blog\/kubecon-china-2024-recap\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio&#39;s Ambient mode and API gateways and their profound impact on the industry.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-integration-istio-mesh/">Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh', 'This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.', '\n[Istio](https:\/\/istio.io) provides robust and flexible support for ingress gateways, utilizing the Envoy proxy in its sidecar mode. While Istio focuses on managing communication between services within a cluster, [Envoy Gateway](https:\/\/gateway.envoyproxy.io) is designed to expose applications to the external world, handle user requests, and support advanced features such as OIDC single sign-on. By combining the capabilities of the Istio service mesh with the advanced gateway features of Envoy Gateway, overall application accessibility and security can be enhanced.\n\nThe following diagram illustrates the traffic path of the ingress gateway in the Istio mesh.\n\n![Istio Ingress Gateway Traffic Path](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-ingress-sidecar.svg)\n\nThe next diagram shows how traffic flows from the edge of the Istio mesh into the internal network after introducing the Envoy Gateway.\n\n![Traffic Path After Introducing Envoy Gateway](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-teg-integration.svg)\n\n### Preparing for Interoperability between Envoy Gateway and Istio\n\nTo use Envoy Gateway as an ingress gateway for Istio, consider the following key points:\n\n- Avoid enabling the Ingress Gateway during Istio installation. We\u0027ll manually install and configure Envoy Gateway as the ingress gateway.\n- Since both Istio and Envoy Gateway use Envoy as a proxy, ensure Istio injects the Envoy sidecar into the Envoy Gateway\u0027s gateway pods to allow secure communication with Istio\u0027s data plane.\n- Configure the routing type of the Envoy proxy created by Envoy Gateway as \u0060Service\u0060 instead of \u0060Endpoint\u0060 to ensure proper routing.\n\nFollow the [quick start documentation](https:\/\/gateway.envoyproxy.io\/docs\/tasks\/quickstart\/) to install Envoy Gateway. Label the namespace of the Envoy Gateway to ensure the data plane gets the Istio sidecar injection:\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\nConfigure the Envoy Gateway\u0027s sidecar to not intercept incoming gateway traffic. The injected sidecar ensures that the components of Envoy Gateway and its created proxies are included in the Istio mesh and mount the correct certificates for secure communication.\n\n{{\u003cinclude_code file=\u0022control-plane-tls.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\nConfigure Envoy Gateway to not intercept inbound traffic:\n\n{{\u003cinclude_code file=\u0022teg-sidecars-no-inbound.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\nModify the GatewayClass configuration to apply the sidecar configuration to all \u0060EnvoyProxy\u0060 in the Envoy Gateway data plane:\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### Installing Istio\n\nDeploy Istio using the minimal profile to avoid deploying the Ingress Gateway:\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### Restarting the Envoy Gateway Control Plane\n\nWith Istio\u0027s sidecar injection ready, restart all Envoy Gateway control plane pods:\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis;\n\tdo kubectl rollout restart deployment -n envoy-gateway-system $d; done\n\u0060\u0060\u0060\n\n### Deploying a Test Application\n\nDeploy test applications after installing Istio to ensure they also receive sidecar injections:\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### Configuring Envoy Gateway\n\nNow configure the Envoy Gateway to handle edge traffic:\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\nDeploy the application gateway, which includes the following containers:\n\n- \u0060istio-init\u0060: Injected by Istio to modify pod iptables.\n- \u0060envoy\u0060: Controlled by Envoy Gateway, acting as the ingress gateway.\n- \u0060istio-proxy\u0060: Injected by Istio, responsible for communication with internal cluster pods.\n- \u0060shutdown-manager\u0060: Controlled by Envoy Gateway, responsible for pod lifecycle management.\n\nCreate an HTTP route:\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\nApply the route configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### Sending a Test Request\n\nGet the load balancer IP address of the gateway and send a test request:\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\nYou should see a correct response from the \u0060httpbin\u0060 service:\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### Enabling Strict mTLS\n\nEnable strict mTLS by applying the following configuration:\n\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n\n### Enabling TLS for the Gateway\n\nCreate the root certificate and private key for service signing:\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\nCreate the certificate and private key for \u0060www.example.com\u0060:\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nCreate a secret for the ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential --key=example_certs\/www.example.com.key --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nConfigure the ingress gateway:\n\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\nSend a test request:\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\nYou should be able to access the \u0060httpbin\u0060 service within the mesh via HTTPS.\n\n### Conclusion\n\nBy integrating Envoy Gateway as an ingress gateway in your Istio service mesh, you can leverage the best of both worlds: Istio\u0027s robust service mesh capabilities and Envoy Gateway\u0027s advanced gateway features. This setup enhances the security, scalability, and flexibility of your applications, providing a seamless and secure user experience. With careful configuration and the right tools, managing traffic in and out of your service mesh becomes more efficient and effective, ensuring your applications are always accessible and secure. \n', '\/en\/blog\/envoy-gateway-integration-istio-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 10, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Securing Istio: Addressing Critical Security Gaps and Best Practices', 'Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.', '\n## Introduction\n\nRecently, the Wiz research team released a [blog post](https:\/\/www.wiz.io\/blog\/sapwned-sap-ai-vulnerabilities-ai-security) that uncovered tenant isolation vulnerabilities in AI services, generating widespread attention. This study detailed security flaws across several AI service providers, particularly the SAP AI Core platform. Researchers were able to execute arbitrary code through legitimate AI training processes, subsequently moving laterally to take over services and gain access to customers’ private files and cloud credentials. These findings highlight the challenges that cloud services and management platforms face in ensuring isolation and sandbox environments.\n\nIn this context, Istio, as a crucial service mesh solution, faces similar security issues, especially in key functionalities like sidecar injection and traffic management. This blog aims to discuss how to protect the security of the Istio service mesh and provide a comprehensive set of mitigation measures. We will also discuss how multi-layer security strategies can effectively enhance Istio\u0027s security to address challenges mentioned in the Wiz report.\n\n## Overview\n\nIstio primarily manages east-west traffic within Kubernetes, offering detailed traffic management features such as request routing, load balancing, and fault recovery policies. While Istio offers essential security features such as traffic encryption, authentication, and authorization, it should not be viewed as a standalone firewall solution. To maintain robust security for services within the Istio mesh, it is crucial to complement Istio\u0027s security capabilities with additional measures from the underlying network and infrastructure, such as Container Network Interface (CNI) plugins and secure container implementations.\n\nWhether in Sidecar or Ambient mode, traffic is hijacked from application pods to data plane proxies for processing and forwarding. If application traffic is not successfully intercepted or is impersonated by a rogue application masquerading as Istio, security vulnerabilities can arise.\n\nThe diagram below illustrates where security vulnerabilities due to bypassing or impersonating Istio system users might occur.\n\n![\u0022Security vulnerabilities\u0022 in bypassing Istio\u0027s traffic hijacking](bypass-sidecar-traffic-hijack.svg)\n\nNext, we will explore specific situations where \u0022security vulnerabilities\u0022 arise and the strategies to address them.\n\n## Bypassing Istio Sidecar Injection\n\n### At the Namespace Level\n\n- **Scenario**: Application teams misuse namespace labels to disable Istio Sidecar injection at the namespace level.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes namespace resources.\n- **Monitoring**: Use policy engines (like OPA Gatekeeper) to ensure compliance with namespace labels, and regularly review namespace configurations.\n\n### At the Pod Level\n\n- **Scenario**: Application teams misuse Pod labels to disable Istio Sidecar injection at the Pod level.\n- **Mitigation Strategy**:\n  - Force all Pods to specify a UID that is not 1337.\n  - Inspect all container images to check for UID 1337 and reject those images. This inspection can be performed using an admission webhook or by a central team managing the image registry.\n- **Monitoring**: Employ Admission Webhooks to enforce Sidecar injection, prohibit exclusion labels, and regularly scan and audit all pods to ensure every required pod has a Sidecar injected.\n\n## Bypassing Traffic Redirection to Istio Sidecar\n\n### Misuse of Traffic Redirection Annotations\n\n- **Scenario**: Application teams misuse Pod annotations to exclude certain inbound or outbound ports or IPs, thereby bypassing traffic redirection.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Use policy engines to detect and alert on non-compliant annotation use, regularly review Pod annotations.\n\n### Misuse of Pod UID\n\n- **Scenario**: Application teams misuse UID 1337 (the ID of the sidecar proxy) to bypass Istio\u0027s Iptables redirection rules.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Prohibit or restrict the use of UID 1337, regularly audit Pod UID configurations to ensure no bypassing occurs.\n\n### Misuse of Pod Capabilities (NET_ADMIN, NET_RAW)\n\n- **Scenario**: Application teams misuse NET_ADMIN and NET_RAW capabilities to remove Istio Iptables rules.\n- **Mitigation Strategy**: Platform teams enable Istio CNI (to avoid granting elevated privileges to application teams) and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Regularly review and monitor Pod permission configurations to ensure no over-privileged actions are taken.\n\n## Bypassing Inbound Traffic Constraints\n\n### Misuse of PeerAuthentication\n\n- **Scenario**: Application teams create a PeerAuthentication resource for each namespace\/workload, enabling the PERMISSIVE authentication mode.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio PeerAuthentication resources.\n- **Monitoring**: Regularly review PeerAuthentication configurations to ensure all inbound traffic is encrypted as required.\n\n## Bypassing Outbound Traffic Constraints\n\n### Misuse of ServiceEntry\n\n- **Scenario**: Application teams create a ServiceEntry to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio ServiceEntry resources.\n- **Monitoring**: Regularly review ServiceEntry configurations to ensure no bypassing occurs.\n\n### Misuse of ExternalName Services\n\n- **Scenario**: Application teams create a Kubernetes Service of type ExternalName to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Kubernetes Service resources.\n- **Monitoring**: Regularly review the types of Kubernetes Service configurations to ensure no bypassing occurs.\n\n## Uncontrollably Changing Istio Sidecar Configuration\n\n### Misuse of Sidecar Resources\n\n- **Scenario**: Application teams create an Istio Sidecar resource for each workload and set the \u0060outboundTrafficPolicy\u0060 field to \u0060ALLOW_ANY\u0060 (overriding the possible global value \u0060REGISTRY_ONLY\u0060).\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio Sidecar resources.\n- **Monitoring**: Regularly review Sidecar resource configurations to ensure no global settings are overridden.\n\n### Misuse of EnvoyFilter\n\n- **Scenario**: Application teams create an EnvoyFilter that conflicts with existing Istio objects, potentially causing DoS attacks or violating security policies.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio EnvoyFilter resources.\n- **Monitoring**: Regularly review EnvoyFilter configurations to ensure no improper use occurs.\n\n## Service Mesh as Part of a Layered Defense\n\nThe service mesh is described as a supplemental layer to existing security models, enhancing microservice security by adding finer-grained security policies on top of traditional security controls. However, the article emphasizes that service meshes cannot independently ensure comprehensive security for microservices but should be part of an overall security strategy.\n\n![Microservices security layered architecture](security-layers.svg)\n\nService meshes primarily manage and control network traffic by deploying a lightweight proxy (sidecar) next to each service instance. This allows for precise traffic control and policy enforcement at the network level, such as traffic encryption, authentication, and authorization. Although service meshes offer features like traffic control, service discovery, and circuit breakers, these are essentially management of network traffic and are not sufficient to address all security issues. For instance, they cannot replace traditional security measures like application layer firewalls, intrusion detection systems, and data security.\n\nFurthermore, service meshes rely on correct configuration and management, and improper configuration can lead to security vulnerabilities. Therefore, while service meshes are an indispensable part of modern microservices architectures, they should be combined with traditional security measures to form a comprehensive, multi-layered security strategy framework. Refer to [How Service Mesh Layers Microservices Security with Traditional Security to Move Fast Safely](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) for further insights on strengthening service mesh security.\n\n## Long-term Solutions and Community Collaboration\n\nThe Istio community conducts a security audit almost every year, see the results from [2021](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/) and [2022](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/). From these results, we can see that Istio\u0027s security posture has greatly improved. Ensure that your Istio service mesh adheres to [security best practices](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/). Additionally, keep an eye on the [Istio CVE Bulletins](https:\/\/istio.io\/latest\/news\/security\/) or use tools like [Tetrate Istio Subscription](https:\/\/tetrate.io\/tetrate-istio-subscription\/) that can scan for various CVEs in the Istio service mesh, deploying Istio versions that are FIPS compliant and FIPS certified.\n\n## Conclusion\n\nService meshes provide an additional layer of security for microservices architectures by managing control flows outside of the applications. This allows for enhanced communication security between services without impacting application performance. When deploying service meshes, it is recommended to use Istio’s Egress Gateway to manage outbound traffic, in conjunction with Kubernetes\u0027 NetworkPolicy, to ensure all outbound traffic must pass through the gateway, thus preventing potential data leaks and other security threats.\n\n## References\n\n- [How to enforce egress traffic using Istio’s authorization policies - tetrate.io](https:\/\/tetrate.io\/blog\/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies\/)\n- [Istio Security Best Practice - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n- [Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io](https:\/\/tetrate.io\/blog\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/)\n- [Istio publishes results of 2022 security audit - istio.io](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/)\n- [Announcing the results of Istio’s first security assessment - istio.io](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)\n', '\/en\/blog\/securing-istio-addressing-critical-security-gaps-and-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Migrate from Kubernetes Ingress to the Gateway API', 'This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.', '\nWith the release of Istio 1.22, the Istio API has officially been upgraded to version v1, coinciding with the update of the Kubernetes Gateway API to v1.1. This article aims to explore the connections and differences between the Ingress API, Istio API, and Kubernetes Gateway API, detailing their selection and migration strategies in practical applications.\n\n## Introduction\n\nPreviously, I wrote an article discussing [Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh](\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/). The article pointed out that as Kubernetes\u0027 original ingress gateway, Ingress\u0027s resource model is too simple to meet the demands of today\u0027s programmable networks. As its successor, the Gateway API has rapidly developed in recent years and has gained broad support, including many emerging open-source gateway projects like [Envoy Gateway](https:\/\/gateway.envoyproxy.io) choosing to develop based on the Gateway API. Additionally, some legacy gateway projects have started adapting to the Gateway API or using tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) to migrate.\n\nThe Gateway API, as the latest achievement in Kubernetes ingress gateways, separates concerns through role division and supports cross-namespace capabilities, making it more suitable for multi-cloud environments. It integrates the overlapping functions of ingress gateways (north-south) and service meshes (east-west, intra-cluster routing) to provide a new reference model for unified traffic management in the cloud-native era.\n\nIngress API, Gateway API, and Istio API can all implement gateway functions, but what are the connections and differences between them? This article will unveil this mystery and provide strategies for selecting and migrating gateways in Kubernetes environments.\n\n## Kubernetes Traffic Management\n\nWith the widespread adoption and increasing complexity of microservice architectures, Kubernetes\u0027 traffic management tools have also evolved to meet various technical needs. The Ingress API, Istio API, and Kubernetes Gateway API each represent different stages of this evolution.\n\n**Ingress API** offers basic traffic management capabilities in Kubernetes, allowing users to manage external access to services within the cluster through simple routing rules (e.g., HTTP and HTTPS). Although its design is straightforward, its functionality is limited and mainly suitable for smaller-scale, less complex applications.\n\nIn contrast, **Istio API**, as part of a service mesh, offers a range of advanced traffic management features, such as traffic mirroring, canary releases, and circuit breakers, suitable for large-scale microservice architectures requiring complex traffic management.\n\nTo overcome the limitations of the Ingress API and integrate advanced features similar to those of Istio, the **Kubernetes Gateway API** was developed. It not only provides greater flexibility and extensibility in its design but also, through broad community support, serves as a bridge connecting traditional Ingress implementations and modern service mesh technologies like Istio, with most mainstream open-source gateways being based on or adapted to the Gateway API.\n\nThe following table summarizes the core features and recommended use cases for each API:\n\n| API Name      | Object Type                | Status                  | Recommended Use Cases                                       |\n| ------------- | -------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API   | \u0060Ingress\u0060                  | Stable (Kubernetes v1.19)| Suitable for small-scale and simple scenarios, mainly for basic routing configurations |\n| Istio API     | \u0060VirtualService\u0060, \u0060Gateway\u0060| Stable (Istio 1.22)     | Suitable for highly complex microservice architectures, requiring fine-grained control and advanced traffic management features |\n| Gateway API   | \u0060HTTPRoute\u0060, \u0060Gateway\u0060     | Stable (Gateway API v1.1)| Suitable for new or existing deployments that require increased flexibility and scalability, especially when combined with Istio |\n\nThe launch of [Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/), especially its improvements in compatibility with existing Ingress configurations, provides a smooth migration path for users, making the transition from traditional Ingress solutions to more modern, feature-rich Gateway API easier.\n\n## Migrating from Ingress to Kubernetes Gateway API\n\nTo migrate from Ingress to Gateway API, follow these steps:\n\n1. **Understand Key Differences**: Compared to Ingress, the Gateway API introduces several new concepts and resource types, such as \u0060Gateway\u0060, \u0060HTTPRoute\u0060, and \u0060TLSRoute\u0060. These resources offer more configuration options and flexibility; refer to the [Gateway API documentation](https:\/\/gateway-api.sigs.k8s.io\/guides\/) for their configurations.\n2. **Configure Entry Points**: Create \u0060Gateway\u0060 resource configurations, clearly defining how to receive external traffic, including protocols, ports, and TLS terminations.\n3. **Map Old Resources**: Map existing Ingress resources to corresponding Gateway API resources. For example, host and path rules in Ingress need to be converted into route rules in HTTPRoute.\n4. **Test and Deploy**: Before officially migrating, test the new Gateway API configurations in a test environment to ensure all traffic routing is normal and there are no security vulnerabilities.\n\nTo simplify the migration process, you can use tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway), which can automatically convert Ingress configurations into Gateway API formats.\n\n## Practical Migration Example\n\nHere is a simple example of an HTTP gateway configuration demonstrating how to migrate from Ingress to the Gateway API.\n\nAssume you have an existing Ingress configuration as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\nTo migrate it to the Gateway API, first create a Gateway object:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds:\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\nEnsure that the \u0060gatewayClassName\u0060 refers to a valid GatewayClass configured in your cluster. The GatewayClass is usually set by the cluster administrator and provides a resource to configure the Gateway.\n\nNext, create an HTTPRoute resource to define routing rules that route traffic to the backend service:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\nIn this example, we see:\n\n- The rules from the \u0060Ingress\u0060 object are directly mapped to the \u0060HTTPRoute\u0060 object.\n- The hostname matching, path matching, and backend service configurations remain unchanged, but the object and field names differ.\n\n## Considerations and Challenges\n\nAlthough it is possible to migrate from Ingress to Gateway API and potentially run them simultaneously, there are several challenges and considerations for the necessity of migration:\n\n- **Feature Differences**: Certain features specific to some Ingress controllers may not have direct equivalents in the Gateway API, requiring additional configurations or custom resources to achieve similar functionalities.\n- **Multi-Resource Management**: Using the Gateway API may involve managing more resource types and complex configurations than Ingress, potentially increasing the complexity of administration.\n\nFor existing users of Ingress and Istio API, whether to migrate to the Gateway API depends on specific circumstances. Here are some migration recommendations:\n\n- **For New Deployments**: It is advisable to use the Gateway API directly to take advantage of its advanced features and anticipate future developments.\n- **For Existing Deployments**: If the existing system operates stably and does not require advanced features, you can continue using the current APIs. If you seek to leverage new features of the Gateway API or plan for long-term development, a gradual migration is a prudent choice.\n\nFor the support status of different gateways for the Gateway API, refer to the [Gateway API Implementation Conformance Report](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/) for more details.\n\n## Conclusion\n\nThe Ingress API, Istio API, and Kubernetes Gateway API each have distinct features suitable for different application scenarios and needs. Selecting the appropriate API and planning and managing effectively can significantly enhance system flexibility and stability. As the Gateway API continues to develop and mature, it is increasingly becoming the mainstream choice for future traffic management.\n\nChoosing the right gateway technology, combined with your specific needs and existing architecture, can better manage and optimize traffic to ensure efficient and stable application operation. As technology progresses and the community evolves, the Gateway API provides a powerful and flexible framework, making the transition from traditional Ingress to more modern solutions simpler and more effective.\n\n## References\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/kubernetes-ingress-to-gateway-api-migration\/).*', '\/en\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/seamless-cross-cluster-access-istio/">A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 25, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh', 'Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.', '\n## Introduction\n\nAs enterprise information systems increasingly adopt microservices architecture, how to achieve efficient and secure cross-cluster access to services in a multicluster environment has become a crucial challenge. Istio, as a popular service mesh solution, offers a wealth of features to support seamless inter-cluster service connections.\n\nThere are several challenges when deploying and using a multicluster service mesh:\n\n- Cross-cluster service registration, discovery, and routing\n- Identity recognition and authentication between clusters\n\nThis article will delve into how to achieve seamless cross-cluster access in a multicluster Istio deployment by implementing SPIRE federation and exposing services via east-west gateways. Through a series of configuration and deployment examples, this article aims to provide readers with a clear guide to understanding and addressing common issues and challenges in multicluster service mesh deployments.\n\n## Istio Deployment Models\n\nThe [Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/) divides various deployment models based on clusters, networks, control planes, meshes, trust domains, and tenants.\n\nThis article focuses on the hybrid deployment model of multi-cloud \u002b multi-mesh \u002b multi-control plane \u002b multi-trust domain. This is a relatively complex scenario. If you can successfully deploy this model, then other scenarios should also be manageable.\n\n## FQDN in Multicluster Istio Service Mesh\n\nFor services across different meshes to access each other, they must be aware of each other\u0027s Fully Qualified Domain Name (FQDN). FQDNs typically consist of the service name, namespace, and top-level domain (e.g., \u0060svc.cluster.local\u0060). In Istio\u0027s multi-cloud or multi-mesh setup, different mechanisms such as \u0060ServiceEntry\u0060, \u0060VirtualService\u0060, and \u0060Gateway\u0060 configurations are used to control and manage service routing and access, instead of altering the FQDN.\n\nThe FQDN in a multi-cloud service mesh remains the same as in a single cluster, usually following the format:\n\n\u0060\u0060\u0060\n\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local\n\u0060\u0060\u0060\n\nYou might think about using \u0060meshID\u0060 to distinguish meshes? The \u0060meshID\u0060 is mainly used to differentiate and manage multiple Istio meshes within the same environment or across environments, and it is not used to directly construct the service FQDN.\n\n{{\u003ccallout note  \u0022Main roles of \u0060meshID\u0060\u0022\u003e}}\n- **Mesh-level telemetry data aggregation**: Differentiates data from different meshes, allowing for monitoring and analysis on a unified platform.\n- **Mesh federation**: Establishes federation among meshes, allowing for sharing some configurations and services.\n- **Cross-mesh policy implementation**: Identifies and applies mesh-specific policies, such as security policies and access control.\n{{\u003c\/callout\u003e}}\n\n## Cross-Cluster Service Registration, Discovery, and Routing\n\nIn the Istio multi-mesh environment, the East-West Gateway plays a key role. It not only handles ingress and egress traffic between meshes but also supports service discovery and connectivity. When one cluster needs to access a service in another cluster, it routes to the target service through this gateway.\n\nThe diagram below shows the process of service registration, discovery, and routing across clusters.\n\nIn the configuration of Istio multi-mesh, the processes of service registration, discovery, and routing are crucial as they ensure that services in different clusters can discover and communicate with each other. Here are the basic steps in service registration, discovery, and routing in the Istio multi-mesh environment:\n\n### 1. Service Registration\n\nIn each Kubernetes cluster, when a service is deployed, its details are registered with the Kubernetes API Server. This includes the service name, labels, selectors, ports, etc.\n\n### 2. Sync to Istiod\n\nIstiod, serving as the control plane, is responsible for monitoring changes in the status of the Kubernetes API Server. Whenever a new service is registered or an existing service is updated, Istiod automatically detects these changes. Istiod then extracts the necessary service information and builds internal configurations of services and endpoints.\n\n### 3. Cross-Cluster Service Discovery\n\nTo enable a service in one cluster to discover and communicate with a service in another cluster, Istiod needs to synchronize service endpoint information across all relevant clusters. This is usually achieved in one of two ways:\n   - **DNS Resolution**: Istio can be configured to use CoreDNS or a similar service to return cross-cluster service endpoints in DNS queries. When a service tries to resolve another cluster\u0027s service, the DNS query returns the IP addresses of the accessible remote service. In this article, we enable Istio\u0027s [DNS proxy](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/) to achieve cross-cluster service discovery. If a service exists both locally and remotely, a local DNS query returns only the local service\u0027s ClusterIP. If the service exists only in a remote cluster, the DNS query returns the IP address of the East-West Gateway\u0027s load balancer in the remote cluster, which can also be used for cross-cluster failover.\n   - **Service Entry Synchronization**: By setting specific ServiceEntry configurations, an Envoy proxy in one cluster knows how to find and route to a service in another cluster through the East-West Gateway.\n\n### 4. Routing and Load Balancing\n\nWhen Service A needs to communicate with Service B, its Envoy proxy first resolves the name of Service B to get an IP address, which is the load balancer address of the East-West Gateway in Service B\u0027s cluster. Then, the East-West Gateway routes the request to the target service. Envoy proxies can select the best service instance to send requests based on configured load balancing strategies (e.g., round-robin, least connections, etc.).\n\n### 5. Traffic Management\n\nIstio offers a rich set of traffic management features, such as request routing, fault injection, and traffic mirroring. These rules are defined in the Istio control plane and pushed to the various Envoy proxies for execution. This allows for flexible control and optimization of communication between services in a cross-cluster environment.\n\n## Identity Recognition and Authentication Between Clusters\n\nWhen services running in different clusters need to communicate with each other, correct identity authentication and authorization are key to ensuring service security. Using SPIFFE helps to identify and verify the identities of services, but in a multi-cloud environment, these identities need to be unique and verifiable.\n\nTo this end, we will set up SPIRE federation to assign identities to services across multiple clusters and achieve cross-cluster identity authentication:\n\n- **Using SPIFFE to Identify Service Identities**: Under the SPIFFE framework, each service is assigned a unique identifier in the format \u0060spiffe:\/\/\u003ctrust-domain\u003e\/\u003cnamespace\u003e\/\u003cservice\u003e\u0060. In a multi-cloud environment, including the cluster name in the \u0022trust domain\u0022 ensures the uniqueness of identities. For example, \u0060spiffe:\/\/foo.com\/ns\/default\/svc\/service1\u0060 and \u0060spiffe:\/\/bar.com\/ns\/default\/svc\/service1\u0060 can be set to differentiate services with the same name in different clusters.\n- **Using SPIRE Federation to Manage Inter-Cluster Certificates**: This enhances the security of the multi-cloud service mesh. SPIRE (SPIFFE Runtime Environment) offers a highly configurable platform for service identity verification and certificate issuance. When using SPIRE federation, cross-cluster service authentication can be achieved by creating a Trust Bundle for each SPIRE cluster.\n\nHere are the steps for implementing SPIRE federation.\n\n### 1. Configuring Trust Domain\n\nEach cluster is configured as a separate trust domain. Thus, each service within a cluster will have a unique SPIFFE ID based on its trust domain. For instance, a service in cluster 1 might have the ID \u0060spiffe:\/\/cluster1\/ns\/default\/svc\/service1\u0060, while the same service in cluster 2 would be \u0060spiffe:\/\/cluster2\/ns\/default\/svc\/service1\u0060.\n\n### 2. Establishing Trust Bundle\n\nConfigure trust relationships in SPIRE to allow nodes and workloads from different trust domains to mutually verify each other. This involves exchanging and accepting each other\u0027s CA certificates or JWT keys between trust domains, ensuring the security of cross-cluster communication.\n\n### 3. Configuring SPIRE Server and Agent\n\nDeploy a SPIRE Server and SPIRE Agent in each cluster. The SPIRE Server is responsible for managing the issuance and renewal of certificates, while the SPIRE Agent handles the secure distribution of certificates and keys to services within the cluster.\n\n{{\u003ccallout warning \u0022Compatibility Issues with Workload Registration when Using SPIRE Federation in Istio\u0022\u003e}}\nIn this article, we use the traditional Kubernetes Workload Registrar in the SPRIE Server to handle workload registration within the cluster. The Kubernetes Workload Registrar has been deprecated from SPIRE v1.5.4 onwards, replaced by the SPIRE Controller Manager, which, in my testing, does not run well with Istio.\n{{\u003c\/callout\u003e}}\n\n### 4. Using the Workload API\n\nServices can request and update their identity certificates through SPIRE\u0027s Workload API. This way, services can continuously verify their identities and securely communicate with other services, even when operating in different clusters. We will configure the proxies in the Istio mesh to share the Unix Domain Socket in the SPIRE Agent, thus accessing the Workload API to manage certificates.\n\n### 5. Automating Certificate Rotation\n\nWe will use cert-manager as SPIRE\u0027s [UpstreamAuthority](https:\/\/github.com\/spiffe\/spire\/blob\/v1.9.5\/doc\/plugin_server_upstreamauthority_cert_manager.md) to configure automatic rotation of service certificates and keys, enhancing the system\u0027s security. With automated rotation, even if certificates are leaked, attackers can only use these certificates for a short period.\n\nThese steps allow you to establish a cross-cluster, secure service identity verification framework, enabling services in different clusters to securely recognize and communicate with each other, effectively reducing security risks and simplifying certificate management. This configuration not only enhances security but also improves the system\u0027s scalability and flexibility through distributed trust domains.\n\n## Multicluster Deployment\n\nThe diagram below shows the deployment model for Istio multi-cloud and SPIRE federation.\n\n![Multicloud Mesh Deployment Model](multi-cluster-deployment.svg)\n\nBelow, I will demonstrate how to achieve seamless cross-cluster access in a multi-cloud Istio mesh.\n\n1. Create two Kubernetes clusters in GKE, named \u0060cluster-1\u0060 and \u0060cluster-2\u0060.\n2. Deploy SPIRE and set up federation in both clusters.\n3. Install Istio in both clusters, paying attention to configure the trust domain, east-west gateways, ingress gateways, \u0060sidecarInjectorWebhook\u0060 mounting SPIFFE UDS\u0027s \u0060workload-socket\u0060, and enabling DNS proxy.\n4. Deploy test applications and verify seamless cross-cluster access.\n\nThe versions of the components we deployed are as follows:\n\n- Kubernetes: v1.29.4\n- Istio: v1.22.1\n- SPIRE: v1.5.1\n- cert-manager: v1.15.1\n\nI have saved all commands and step-by-step\n\n instructions on Github: [rootsongjc\/istio-multi-cluster](https:\/\/github.com\/rootsongjc\/istio-multi-cluster). You can follow the instructions in this project. Here are explanations for the main steps.\n\n### 1. Preparing Kubernetes Clusters\n\nOpen Google Cloud Shell or your local terminal, and make sure you have installed the \u0060gcloud\u0060 CLI. Use the following commands to create two clusters:\n\n\u0060\u0060\u0060bash\ngcloud container clusters create cluster-1 --zone us-central1-a --num-nodes 3\ngcloud container clusters create cluster-2 --zone us-central1-b --num-nodes 3\n\u0060\u0060\u0060\n\n### 2. Deploying cert-manager\n\nUse cert-manager as the root CA to issue certificates for istiod and SPIRE.\n\n\u0060\u0060\u0060bash\n.\/cert-manager\/install-cert-manager.sh\n\u0060\u0060\u0060\n\n### 3. Deploying SPIRE Federation\n\nBasic information for SPIRE federation is as follows:\n\n| Cluster Alias | Trust Domain |\n| ------------- | ------------ |\n| cluster-1     | foo.com      |\n| cluster-2     | bar.com      |\n\nNote: The trust domain does not need to match the DNS name but must be the same as the trust domain in the Istio Operator configuration.\n\nExecute the following command to deploy SPIRE federation:\n\n\u0060\u0060\u0060bash\n.\/spire\/install-spire.sh\n\u0060\u0060\u0060\n\nFor details on managing identities in Istio using SPIRE, refer to [Managing Certificates in Istio with cert-manager and SPIRE](\/en\/blog\/cert-manager-spire-istio\/).\n\n### 4. Installing Istio\n\nWe will use IstioOperator to install Istio, configuring each cluster with:\n\n- Automatic Sidecar Injection\n- Ingress Gateway\n- East-West Gateway\n- DNS Proxy\n- SPIRE Integration\n- Access to remote Kubernetes cluster secrets\n\nExecute the following command to install Istio:\n\n\u0060\u0060\u0060bash\nistio\/install-istio.sh\n\u0060\u0060\u0060\n\n## Verifying Traffic Federation\n\nTo verify the correctness of the multi-cloud installation, we will deploy different versions of the \u0060helloworld\u0060 application in both clusters and then access the \u0060helloworld\u0060 service from \u0060cluster-1\u0060 to test the following cross-cluster access scenarios:\n\n1. East-West Traffic Federation: Cross-cluster service redundancy\n2. East-West Traffic Federation: Handling non-local target services\n3. North-South Traffic Federation: Accessing services via a remote ingress gateway\n\nExecute the following command to deploy the \u0060helloworld\u0060 application in both clusters:\n\n\u0060\u0060\u0060bash\n.\/example\/deploy-helloword.sh\n\u0060\u0060\u0060\n\n### East-West Traffic Federation: Cross-Cluster Service Redundancy\n\nAfter deploying the \u0060helloworld\u0060 application, access the \u0060hellowrold\u0060 service from the \u0060sleep\u0060 pod in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nThe diagram below shows the deployment architecture and traffic routing path for this scenario.\n\n![East-West Traffic Federation: Cross-Cluster Service Redundancy](east-west-traffic-federation-between-clusters-without-dns-proxying.svg)\n\nThe response results including both \u0060helloworld-v1\u0060 and \u0060helloworld-v2\u0060 indicate that cross-cluster service redundancy is effective.\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the ClusterIP of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060.\n\n**Verifying Traffic Routing**\n\nNext, we will verify the cross-cluster traffic routing path by examining the Envoy proxy configuration.\n\nView the endpoints of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deployment\/sleep.sleep --context=cluster-1 --cluster \u0022outbound|5000||helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT               STATUS      OUTLIER CHECK     CLUSTER\n10.76.3.22:5000        HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n34.136.67.85:15443     HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThese two endpoints, one is the endpoint of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060, and the other is the load balancer address of the \u0060istio-eastwestgateway\u0060 service in \u0060cluster-2\u0060. Istio sets up SNI for cross-cluster TLS connections, and in \u0060cluster-2\u0060, the target service is distinguished by SNI.\n\nExecute the following command to query the endpoint in \u0060cluster-2\u0060 based on the previous SNI:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deploy\/istio-eastwestgateway.istio-system --context=cluster-2 --cluster \u0022outbound_.5000_._.helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will get output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT           STATUS      OUTLIER CHECK     CLUSTER\n10.88.2.4:5000     HEALTHY     OK                outbound_.5000_._.helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThis endpoint is the endpoint of the \u0060helloworld\u0060 service in the \u0060cluster-2\u0060 cluster.\n\nThrough the steps above, you should understand the traffic path for cross-cluster redundant services. Next, we will delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060. No configuration changes are needed in Istio to automatically achieve failover.\n\n### East-West Traffic Federation: Failover\n\nExecute the following command to scale down the replicas of \u0060helloworld-v1\u0060 in \u0060cluster-1\u0060 to 0:\n\n\u0060\u0060\u0060bash\nkubectl -n helloworld scale deploy helloworld-v1 --context=cluster-1 --replicas 0\n\u0060\u0060\u0060\n\nAccess the \u0060helloworld\u0060 service again from \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060.\n\nNow, directly delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl delete service helloworld -n helloworld --context=cluster-1\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060, indicating that cross-cluster failover is effective.\n\nThe diagram below shows the traffic path for this scenario.\n\n![East-West Traffic Federation: Failover](east-west-traffic-federation-between-clusters-failover.svg)\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the address and port 15443 of the East-West Gateway in \u0060cluster-2\u0060.\n\n### North-South Traffic Federation: Accessing Services via Remote Ingress Gateway\n\nAccessing services in a remote cluster through the ingress gateway is the most traditional way of cross-cluster access. The diagram below shows the traffic path for this scenario.\n\n![North-South Traffic Federation: Accessing Services via Remote Ingress Gateway](north-south-traffic-federation-between-clusters.svg)\n\nExecute the following command to create a Gateway and VirtualService in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nkubectl apply --context=cluster-2 \\\n\t-f .\/examples\/helloworld-gateway.yaml -n helloworld\n\u0060\u0060\u0060\n\nGet the address of the ingress gateway in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nGATEWAY_URL=$(kubectl -n istio-ingress --context=cluster-2 get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\nExecute the following validation to access the service via the remote ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=\u0022${CTX_CLUSTER1}\u0022 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -s http:\/\/$GATEWAY_URL\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will receive responses from \u0060helloworld-v2\u0060.\n\n## Verifying Identity\n\nExecute the following command to obtain the certificate from the \u0060sleep\u0060 pod in the \u0060cluster-1\u0060 cluster:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config secret deployment\/sleep -o json --context=cluster-1| jq -r \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in cert-aa\n\u0060\u0060\u0060\n\nIf you see the following fields in the output message, it indicates that the identity assignment is correct:\n\n\u0060\u0060\u0060\nSubject: C=US, O=SPIFFE\n\nURI:spiffe:\/\/foo.com\/ns\/sample\/sa\/sleep\n\u0060\u0060\u0060\n\nView the identity information in SPIRE:\n\n\u0060\u0060\u0060bash\nkubectl --context=cluster-1 exec -i -t -n spire spire-server-0 -c spire-server \\\n\t-- .\/bin\/spire-server entry show -socketPath \/run\/spire\/sockets\n\n\/server.sock --spiffeID spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 9b09080d-3b67-44c2-a5b8-63c42ee03a3a\nSPIFFE ID        : spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\nParent ID        : spiffe:\/\/foo.com\/k8s-workload-registrar\/cluster-1\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:sleep\nSelector         : k8s:pod-uid:6800aca8-7627-4a30-ba30-5f9bdb5acdb2\nFederatesWith    : bar.com\nDNS name         : sleep-86bfc4d596-rgdkf\nDNS name         : sleep.sleep.svc\n\u0060\u0060\u0060\n\n## Recommendations for Production Environments\n\nFor production environments, it is recommended to use a [Unified Gateway](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway), employing a Tier-2 architecture. In the Tier-1 edge gateway, configure global traffic routing. This edge gateway will send the transcribed Istio configuration to the various ingress gateways in the Tier-2 clusters.\n\nThe diagram below shows the deployment of an Istio service mesh using SPIRE federation and a Tier2 architecture with TSB.\n\n![Deployment of a Multicluster Istio Service Mesh with SPIRE and Tier2 Architecture Using TSB](tsb-multi-cluster-architeture.svg)\n\nWe have divided these four Kubernetes clusters into Tier1 cluster (\u0060tier1\u0060) and Tier2 clusters (\u0060cp-cluster-1\u0060, \u0060cp-cluster-2\u0060, and \u0060cp-cluster-3\u0060). An Edge Gateway is installed in T1, while bookinfo and httpbin applications are installed in T2. Each cluster will have an independent trust domain, and all these clusters will form a SPIRE federation.\n\nThe diagram below shows the traffic routing for users accessing bookinfo and httpbin services through the ingress gateway.\n\n![Unified Gateway Architecture Diagram](tsb-unified-gateway.svg)\n\nYou need to create a logical abstraction layer suitable for multi-cloud above Istio. For detailed information about the unified gateway in TSB, refer to [TSB Documentation](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway#scenario-1-cluster-based-routing-with-http-path-and-header-match).\n\n## Summary\n\nThis article has detailed the key technologies and methods for implementing service identity verification, DNS resolution, and cross-cluster traffic management in an Istio multi-cloud mesh environment. By precisely configuring Istio and SPIRE federation, we have not only enhanced the system\u0027s security but also improved the efficiency and reliability of inter-service communication. Following these steps, you will be able to build a robust, scalable multi-cloud service mesh to meet the complex needs of modern applications.\n\n## References\n\n- [Deploying a Federated SPIRE Architecture - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/architecture\/federation\/readme\/)\n- [Install Multi-Primary on different networks -istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Istio SPIRE Integration - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)\n- [DNS Proxying - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)\n- [Attesting Istio workload identities with SPIFFE and SPIRE - developer.ibm.com](https:\/\/developer.ibm.com\/articles\/istio-identity-spiffe-spire\/)\n- [Expanding into New Frontiers - Smart DNS Proxying in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Managing Certificates in Istio with cert-manager and SPIRE - jimmysong.io](\/en\/blog\/cert-manager-spire-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multicluster-istio\/).*', '\/en\/blog\/seamless-cross-cluster-access-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-integrate-third-party-registry-with-istio/">How to Integrating Third-Party Service Registries with Istio?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 28, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Integrating Third-Party Service Registries with Istio?', 'This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.', '\nIstio relies on Kubernetes for service discovery, which generally means that microservices must be deployed within a Kubernetes cluster and use Kubernetes service discovery. However, many existing microservice projects still utilize third-party service registries like Consul and Eureka. This article will explore how to integrate these existing service registries with Istio.\n\n## Support for Non-Kubernetes Services in Istio\n\nOriginally, Istio supported only Kubernetes services, but over time, to accommodate a broader range of application scenarios, it began supporting third-party service registries like Consul. By introducing the Mesh Configuration Protocol (MCP), Istio was able to communicate with various service discovery backends, such as Consul, thereby managing services in non-Kubernetes environments. With the introduction of the ServiceEntry resource in version 1.1, users were able to manually add external services to Istio\u0027s service registry. By version 1.8, direct support for Consul was removed in favor of a more flexible approach through [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/), allowing the integration and management of all services, whether hosted on Kubernetes or not.\n\n## High-Level Architecture of Istio Proxy Configuration\n\nThe following diagram illustrates the high-level architecture of Istio proxy configuration, showing how configurations are ingested, transformed, and ultimately served to the Envoy proxies.\n\n\u0060\u0060\u0060mermaid \u0022Istio Proxy Configuration High-Level Architecture\u0022\ngraph TD\n    subgraph Configuration Ingestion\n        subgraph Configuration Storage\n            xcs(XDS Client) --\u003e acs(Aggregate)\n            ccs(CRD Client) --\u003e acs(Aggregate)\n            fcs(Filesystem Client) --\u003e acs(Aggregate)\n        end\n        subgraph Service Discovery\n            kc(Kube Controller) --\u003e sd(Aggregate)\n            sec(ServiceEntry Controller) --\u003e sd(Aggregate)\n        end\n    end\n    subgraph Configuration Translation\n        acs \u0026 sd --\u003e ct(Configuration Translator)\n    end\n    subgraph \u0022Configuration Service (XDS)\u0022\n        ct --\u003e xds(XDS Server)\n    end\n    xds --\u003e ep(Envoy Proxies)\n\u0060\u0060\u0060\n\n![Istio Proxy Configuration High-Level Architecture](f02f7fa551ceb4c4b9fd0419b69ca6f4.svg)\n\n### Detailed Process of Configuration Ingestion\n\n- **Configuration Storage**: Responsible for reading various types of resources and aggregating them. Includes:\n    - **XDS Client**: Reads resources via the xDS protocol.\n    - **CRD Client**: Reads resources from Kubernetes Custom Resource Definitions (CRDs).\n    - **Filesystem Client**: Reads resources from the filesystem.\n- **Service Discovery**: Aggregates service-oriented internal resources. Components used include:\n    - **Kube Controller**: Operates based on core Kubernetes types.\n    - **ServiceEntry Controller**: Operates based on Istio types.\n\n### Configuration Translation and Service\n\nAfter aggregating configurations from Configuration Storage and Service Discovery, the **Configuration Translator** translates them into a format suitable for the proxies, which are then served by the **XDS Server**. This is the final step in applying dynamic configurations to the proxies.\n\n## Synchronization of Third-Party Registries\n\nTo integrate third-party service registries, we can implement an Operator that monitors third-party service registries and pushes services in the form of ServiceEntry and WorkloadEntry resources to the Kubernetes API server. The following flowchart illustrates this synchronization process.\n\n\u0060\u0060\u0060mermaid \u0022Synchronization of Third-Party Registries Flowchart\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as Third-Party Service Registry\n    participant K8s as Kubernetes API Server\n    participant I as Istiod\n    participant EP as Envoy Proxies\n\n    O-\u003e\u003e\u002bCM: Query Service Registry\n    CM--\u003e\u003e-O: Return Service Data\n    O-\u003e\u003eO: Transform Services to ServiceEntry\n    O-\u003e\u003e\u002bK8s: Push ServiceEntry\n    K8s--\u003e\u003e-I: Update Istio Configuration\n    I-\u003e\u003eEP: Update Proxy Configuration\n    Note over EP: Envoy Proxies Receive New Configuration\n\n    loop Monitor Changes\n        O-\u003e\u003e\u002bCM: Check for Updates\n        CM--\u003e\u003e-O: Notify on Change\n        O-\u003e\u003eO: Transform Updated Services\n        O-\u003e\u003e\u002bK8s: Update ServiceEntry\n        K8s--\u003e\u003e-I: Refresh Istio Configuration\n        I-\u003e\u003eEP: Refresh Proxy Configuration\n    end\n\u0060\u0060\u0060\n\n![Synchronization of Third-Party Registries Flowchart](094c8461ff42db96a7c04d7a1b92b0d2.svg)\n\n### Steps for Synchronization of Third-Party Service Registries\n\n1. The Operator initiates a service query to the Third-Party Service Registry.\n2. The Third-Party Service Registry returns the current registered service data.\n3. The Operator transforms the service data into Istio\u0027s ServiceEntry objects.\n4. The Operator pushes the transformed ServiceEntry to the Kubernetes API Server.\n5. The Kubernetes API Server notifies Istiod of the changes.\n6. Istiod updates the configurations of the Envoy Proxies.\n7. The Operator regularly checks the Third-Party Service Registry to monitor service changes, updating the ServiceEntry and re-pushing it to the Kubernetes API Server upon detection of changes, thus completing the service synchronization.\n\n## Istio Registry Sync\n\nDeveloped by Tetrate, [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) is an extension operator that can run as an add-on for [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/). It supports the integration of non-Kubernetes service registries (such as AWS Cloud Map and Consul) with Istio. This tool provides several use cases:\n\n- **Hybrid Application Integration**: In hybrid environments, traditional applications using Consul and microservices in AWS using Cloud Map can achieve seamless service discovery through Istio Registry Sync.\n- **Dynamic Endpoint Management**: In environments where services frequently scale, Istio Registry Sync quickly reflects changes from the configured registry, ensuring accurate traffic management strategies within Istio\u0027s service mesh.\n- **Unified Monitoring and Security Posture**: By integrating services from all environments into Istio, it leverages service health metrics and a unified security protocol, such as mTLS, to ensure encrypted and authenticated communication across all services.\n\n## Conclusion\n\nThrough the methods described above, you can effectively integrate Istio with third-party service registries, whether by developing a custom Operator or using the ready-made Istio Registry Sync tool. This not only maintains the modernization of services but also ensures efficient collaboration across different environments.\n\n## References\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n\n---\n\n*This blog was initially published at [tetrate.io](LINK).*', '\/en\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-oidc/">How to Implement Single Sign-On (SSO) with OIDC in API Gateway using Envoy Gateway?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 27, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Implement Single Sign-On (SSO) with OIDC in API Gateway using Envoy Gateway?', 'This article provides a detailed guide on configuring Envoy Gateway to use OIDC for Single Sign-On. By using Auth0 as the identity provider, it demonstrates how to achieve secure and efficient SSO at the API Gateway level, enhancing user experience and system security.', '\nIn the blog post [Detailed Explanation of Common Authentication Methods in Microservices](\/en\/blog\/microservice-auth-methods\/), we discussed OAuth 2.0 authentication, which has several implementations, with OpenID Connect (OIDC) being the most popular one. OIDC provides both authentication and authorization for users. This article will explain how to implement OIDC authentication at the API Gateway level using Envoy Gateway.\n\n## Authentication Methods Supported by Envoy Gateway\n\nEnvoy Gateway is a high-performance API gateway implemented with Envoy, supporting various authentication methods to protect APIs and microservices:\n\n1. **JWT Authentication**: Uses JSON Web Tokens (JWT) for authentication.\n2. **mTLS (Mutual TLS)**: Ensures secure communication between client and server using mutual TLS.\n3. **HTTP Basic Authentication**: Uses username and password for basic authentication.\n4. **OIDC Authentication**: Uses OpenID Connect protocol for identity verification and authorization.\n5. **External Authentication**: Calls external HTTP or gRPC services to check if incoming HTTP requests are authenticated.\n\nThis article focuses on configuring and using OIDC authentication in Envoy Gateway to achieve Single Sign-On at the gateway level.\n\n## What is OIDC?\n\nOpenID Connect (OIDC) is an identity verification protocol built on [OAuth 2.0](\/blog\/microservice-auth-methods\/#oauth-20). It allows clients to verify a user\u0027s identity via an authentication server and obtain information about the user.\n\nThe OIDC authentication process is illustrated below:\n\n\u0060\u0060\u0060mermaid \u0022OIDC Authentication Flow Diagram\u0022\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant ResourceServer\n\n    User -\u003e\u003e Client: Request access to protected resource\n    Client -\u003e\u003e AuthServer: Request authentication (with client ID)\n    AuthServer -\u003e\u003e User: Request user login\n    User -\u003e\u003e AuthServer: User logs in and authorizes\n    AuthServer -\u003e\u003e Client: Returns authorization code\n    Client -\u003e\u003e AuthServer: Exchange authorization code for access token and ID token\n    AuthServer -\u003e\u003e Client: Returns access token and ID token\n    Client -\u003e\u003e ResourceServer: Request protected resource (with access token)\n    ResourceServer -\u003e\u003e AuthServer: Validate access token\n    AuthServer -\u003e\u003e ResourceServer: Validation successful\n    ResourceServer -\u003e\u003e Client: Return protected resource\n    Client -\u003e\u003e User: Return protected resource\n\u0060\u0060\u0060\n\n![OIDC Authentication Flow Diagram](4e66a849ccc150b9ead3ba1bfb59dc08.svg)\n\nOIDC adds an identity layer on top of OAuth 2.0, introducing ID tokens and a standardized UserInfo endpoint, enabling OAuth 2.0 to be used not only for authorization but also for securely verifying user identities, thus achieving Single Sign-On (SSO) and obtaining user identity information.\n\n## Why Implement Single Sign-On?\n\nSingle Sign-On (SSO) is an identity verification method that allows users to log in to multiple independent applications with one account. Through a single authentication, users can seamlessly access all related applications, reducing the hassle of repeatedly entering usernames and passwords, thereby enhancing the user experience. SSO centralizes user identity and authentication management, enhancing system security and simplifying IT management processes.\n\nFor microservices architecture, SSO is particularly important because it achieves unified authentication and authorization across various microservices, avoiding the need for each service to implement its own identity verification logic, reducing user login redundancy, and enhancing the user experience. Centralized management also unifies application security policies, effectively monitors and responds to security events, and improves overall system security. Additionally, by using standardized tokens (like JWT), SSO simplifies the identity verification process between microservices, enhancing development efficiency and allowing developers to focus on business logic implementation.\n\n## Example: Implementing Single Sign-On with Envoy Gateway and Auth0\n\nNext, we will use Auth0 as the identity provider to demonstrate how to achieve Single Sign-On at the API Gateway level using Envoy Gateway.\n\n### Implementing Single Sign-On with Auth0\n\nFirst, let\u0027s illustrate the detailed process of implementing Single Sign-On with Auth0 in Envoy Gateway, as shown below.\n\n\u0060\u0060\u0060mermaid \u0022Single Sign-On Flow Diagram with Auth0 and Envoy Gateway\u0022\nsequenceDiagram\n    participant User\n    participant Browser\n    participant Envoy Gateway\n    participant Auth0\n    participant Application\n\n    User -\u003e\u003e Browser: Open https:\/\/www.example.com\n    Browser -\u003e\u003e Envoy Gateway: Request https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e Browser: No ID token found in cookies\n    Envoy Gateway -\u003e\u003e Browser: Redirect to Auth0\n    Browser -\u003e\u003e Auth0: Request \/authorize?response_type=code\u0026client_id=${CLIENT_ID}\u0026redirect_uri=https:\/\/www.example.com\/myapp\/oauth2\/callback\n    Auth0 -\u003e\u003e Browser: Redirect to user login page\n    Browser -\u003e\u003e User: Input username \u0026 password\n    User -\u003e\u003e Browser: User login\n    Browser -\u003e\u003e Auth0: Submit credentials\n    Auth0 -\u003e\u003e Browser: Redirect to https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\u0026state=xxx\n    Browser -\u003e\u003e Envoy Gateway: Request https:\/\/www.example.com\/myapp\/oauth2\/callback?code=xxxx\n    Envoy Gateway -\u003e\u003e Auth0: Exchange ID token with the code\n    Envoy Gateway -\u003e\u003e Browser: Set cookie: ID token\n    Envoy Gateway -\u003e\u003e Browser: Redirect to https:\/\/www.example.com\n    Browser -\u003e\u003e Envoy Gateway: Request https:\/\/www.example.com\n    Envoy Gateway -\u003e\u003e Envoy Gateway: Verify ID token\n    Envoy Gateway -\u003e\u003e Application: Route to Backend service\n\u0060\u0060\u0060\n\n![Single Sign-On Flow Diagram with Auth0 and Envoy Gateway](0089f6fbc18bf3df6617cb57ed0ba6c2.svg)\n\nSteps explanation:\n\n1. **User visits the website**: The user accesses \u0060https:\/\/www.example.com\u0060 via a browser.\n2. **Request forwarding**: The browser sends a GET request to Envoy Gateway.\n3. **Check ID token**: Envoy Gateway checks if the user\u0027s request contains a valid ID token in the cookie.\n4. **Redirect to the identity provider**: If no ID token is found, Envoy Gateway redirects the user to the identity provider\u0027s (IdP) authorization endpoint, in this case, Auth0. For more information on how Auth0 implements Login, refer to the [Auth0 documentation](https:\/\/auth0.com\/docs\/api\/authentication#login).\n5. **User login**: The user enters their username and password on the identity provider\u0027s login page and submits the credentials for login.\n6. **Obtain authorization code**: After a successful login, the identity provider redirects the user back to Envoy Gateway, including an authorization code in the URL.\n7. **Exchange ID token**: Envoy Gateway uses the authorization code to request an ID token from the identity provider.\n8. **Set Cookie**: The identity provider returns the ID token, which Envoy Gateway sets as a cookie for the user.\n9. **Redirect**:  The URL redirected to https:\/\/www.example.com again.\n10. **Verify ID token**: Envoy Gateway verifies the ID token in the user\u0027s request.\n11. **Route the request**: Upon successful verification, Envoy Gateway routes the request to the backend application (App).\n\nThrough this process, Envoy Gateway achieves Single Sign-On functionality. HTTP requests from users that are not authenticated will be redirected to the SSO page. Besides Auth0, Envoy Gateway also supports multiple identity providers such as Azure AD, Keycloak, Okta, OneLogin, Salesforce, UAA, and more.\n\nNext, we will configure Auth0 and Envoy Gateway according to the sequence diagram.\n\n### Creating an Application on Auth0\n\nFollow these steps to set up a Regular Web Application on Auth0:\n\n1. Visit [Auth0](https:\/\/auth0.com\/) and sign up for a free account.\n2. Create a new application and choose Regular Web Applications.\n3. In the application settings, record or set the following fields:\n   - **Domain**: \u0060{DOMAIN}\u0060\n   - **Client ID**: \u0060{CLIENT_ID}\u0060\n   - **Client Secret**: \u0060{CLIENT_SECRET}\u0060\n   - **Allowed Callback URLs**: \u003chttps:\/\/www.example.com\/oauth2\/myapp\/callback\u003e\n   - **Allowed Logout URLs**: \u003chttps:\/\/www.example.com\/myapp\/logout\u003e\n\nRemember these Auth0 fields as we will use them to configure the Envoy Gateway\u0027s security policy.\n\n{{\u003ccallout note Note\u003e}}\nThe Logout URL here is not functional because the backend service in our example does not implement the Auth0 logout interface. We are adding this field as a placeholder for future implementation.\n{{\u003c\/callout\u003e}}\n\nBelow are screenshots of the Auth0 configuration page. After setting up the user and creating a Regular Web Application, you only need to configure these two places.\n\n![Auth0 Configuration Page 1](auth0-1.webp)\n\n![Auth0 Configuration Page 2](auth0-2.webp)\n\nThis completes the configuration on Auth0. Next, we will install and configure Envoy Gateway.\n\n### Installing Envoy Gateway\n\nRefer to the [Envoy Gateway Quick Start Guide](\/blog\/envoy-gateway-introduction\/#envoy-gateway-quick-start) to install Envoy Gateway on minikube:\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\nRefer to the Secure Gateway guide to configure TLS for Envoy Gateway:\n\n\u0060\u0060\u0060bash\n# Create root certificate and private key to sign certificates\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example.com.key -out example.com.crt\n\n# Create certificate and private key for www.example.com\nopenssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj \u0022\/CN=www.example.com\/O=example organization\u0022\nopenssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in www.example.com.csr -out www.example.com.crt\n\n# Store certificates\/keys in a Secret\nkubectl create secret tls example-cert --key=www.example.com.key --cert=www.example.com.crt\n\u0060\u0060\u0060\n\nUpdate the gateway created in the quickstart to include port \u0060443\u0060 and reference the \u0060example-cert\u0060 Secret in the HTTPS Listener:\n\n\u0060\u0060\u0060bash\necho \u0027[\n  {\n    \u0022op\u0022: \u0022add\u0022,\n    \u0022path\u0022: \u0022\/spec\/listeners\/-\u0022,\n    \u0022value\u0022: {\n      \u0022name\u0022: \u0022https\u0022,\n      \u0022protocol\u0022: \u0022HTTPS\u0022,\n      \u0022port\u0022: 443,\n      \u0022tls\u0022: {\n        \u0022mode\u0022: \u0022Terminate\u0022,\n        \u0022certificateRefs\u0022: [\n          {\n            \u0022kind\u0022: \u0022Secret\u0022,\n            \u0022group\u0022: \u0022\u0022,\n            \u0022name\u0022: \u0022example-cert\u0022\n          }\n        ]\n      }\n    }\n  }\n]\u0027 | kubectl patch gateway eg --type=json --patch-file \/dev\/stdin\n\u0060\u0060\u0060\n\nCreate an HTTPRoute to add a route to the \u0060backend\u0060 service for the \u0060\/myapp\u0060 endpoint:\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: myapp\nspec:\n  parentRefs:\n  - name: eg\n  hostnames: [\u0022www.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/myapp\n    backendRefs:\n    - name: backend\n      port: 3000\nEOF\n\u0060\u0060\u0060\n\n### Configuring OIDC Authentication in Envoy Gateway\n\nCreate a Kubernetes Secret to store the OAuth Client\u0027s Client Secret:\n\n\u0060\u0060\u0060bash\nkubectl create secret generic auth0-client-secret --from-literal=client-secret=${CLIENT_SECRET}\n\u0060\u0060\u0060\n\n{{\u003ccallout note Note\u003e}}\nReplace \u0060${CLIENT_SECRET}\u0060 with your Auth0 Client Secret.\n{{\u003c\/callout\u003e}}\n\nCreate a Security Policy:\n\n\u0060\u0060\u0060bash\ncat \u003c\u003cEOF | kubectl apply -f -\napiVersion: gateway.envoyproxy.io\/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: oidc-example\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: eg\n  oidc:\n    provider:\n      issuer: \u0022https:\/\/${DOMAIN}\u0022\n    clientID: \u0022${CLIENT_ID}\u0022\n    clientSecret:\n      name: \u0022auth0-client-secret\u0022\n    redirectURL: \u0022https:\/\/www.example.com\/myapp\/oauth2\/callback\u0022\n    logoutPath: \u0022\/myapp\/logout\u0022\nEOF\n\u0060\u0060\u0060\n\n**Notes**\n\n- The \u0060issuer\u0060 here should be filled with the Auth0 Domain.\n- The value of \u0060redirectURL\u0060 needs to appear in the Allowed Callback URLs in the Auth0 configuration.\n- \u0060logoutPath\u0060 is mandatory, even if its URL endpoint does not implement the logout logic.\n\nIn this example, we set up OIDC for the Envoy Gateway. By modifying the \u0060targetRef\u0060 to the HTTPRoute, OIDC can also be configured for individual routes. For detailed OIDC configuration, refer to the Envoy Gateway API Documentation.\n\n### Verifying Single Sign-On: Login\n\nAdd \u0060www.example.com\u0060 to the local \u0060\/etc\/hosts\u0060 file:\n\n\u0060\u0060\u0060bash\necho \u0022127.0.0.1 www.example.com\u0022 | sudo tee -a \/etc\/hosts\n\u0060\u0060\u0060\n\nConfigure port forwarding for the application to access the example application locally via the domain:\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\n\nsudo kubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 443:443\n\u0060\u0060\u0060\n\nNow, visit \u003chttps:\/\/www.example.com\u003e in your browser, skip the certificate risk warning, and the page will redirect to the Auth0 login page, as shown below. Choose to log in with a Google account.\n\n![Login Page](login.webp)\n\nAfter logging in, the browser will redirect back to \u003chttps:\/\/www.example.com\u003e and display the HTTP request results, as shown in the JSON code below.\n\n\u0060\u0060\u0060json\n{\n  \u0022path\u0022: \u0022\/\u0022,\n  \u0022host\u0022: \u0022www.example.com\u0022,\n  \u0022method\u0022: \u0022GET\u0022,\n  \u0022proto\u0022: \u0022HTTP\/1.1\u0022,\n  \u0022headers\u0022: {\n    \/*Omit*\/\n    \u0022Authorization\u0022: [\n      \u0022Bearer eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ\u0022\n    ],\n    \u0022Cookie\u0022: [\n      \u0022OauthHMAC-167a6c5=RPdscXEBap0NeSIppJXoxkHt0qvMz4fNHXo2uvgDgIY=; OauthExpires-167a6c5=1716540771; BearerToken-167a6c5=eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIiwiaXNzIjoiaHR0cHM6Ly9kZXYtYXdoam15MzhnZzVxeng3dS51cy5hdXRoMC5jb20vIn0..IiH9LnxmnrGAVy-q.eQV_0Ssetw9mmrEaJNLlBowGJNX51awhh67WSejPrksuGU9e9-DcPJQqmR67ONFzTXWR6CFy4Rfgs4btsmEtvCtiNTCgrBHP90ddbOTg_pK31WnsQ7NThyRfGwoogSaAtK6hFrC2pxFaLj0XL7XvSPk-OaTzK1Zh1da1IM1cmWAWiBRc3nQiVWRDrExPo8-i5SawFe0jIcwytVSaRiX5Polyd3cZ7A7nlei-vDLCfj0HVzOO605nF7ED2dBSnZyev1sg14q598f3X2Vfhi2oJlnbiulGZIlpXgGbcPhzAJJxyEe6qpRpNg7Hbk8Ya-i8gUTwwNysrgm3.Zu5kD_6DzSfZPvwemttXYQ; IdToken-167a6c5=eyJhbG\n\nciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFKWkxWbnNrai0tYmhsNlJzVm51OCJ9.eyJpc3MiOiJodHRwczovL2Rldi1hd2hqbXkzOGdnNXF6eDd1LnVzLmF1dGgwLmNvbS8iLCJhdWQiOiJUZzhlNWVoa0xKM2hka3cxTzREMTBQd21QeTcxZHZtdiIsImlhdCI6MTcxNjQ1NDM3MSwiZXhwIjoxNzE2NDkwMzcxLCJzdWIiOiJnb29nbGUtb2F1dGgyfDExMjc0NDc3OTAyMjMzMTA0ODY0MCIsInNpZCI6IjRlSjhDZnZuZjd5Mm1kaE94QXBTY0JiUEhjOS1rZUVLIn0.r9dwIy_HeiO5_I3UlohLkeRES5FGoxqQnwmcA00cA_kdc5mUxgeVopXIhBUjJnTKv7bOUVJvFw21ew4gqVRJfllDyG-s_XfhSW1-lEXmCc2bGYDtOzva6k2S_VRgyMKfG04_DWFuTgO_pLtix28aYq8cGzKJ_VglT_KgRhoktzJu4Js5iCv9JPnydRJmpvRJwX3tDv_Q3mmUSazaLkhOTdiBJFrGlS07qEzJ_iWANZgR8uDNhpXdmlcqpb3MZkkMulr5-jXIgEhBQKpw28tUiSlzh6EpAVuBH9T1w8bUmFRzCc6JPPamJRfflYW5onNgYHDfcU0RpvpsCHRHRAZbdA\u0022\n    ],\n    \/*Omit*\/\n    \u0022User-Agent\u0022: [\n      \u0022Mozilla\/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/125.0.0.0 Safari\/537.36\u0022\n    ],\n    \u0022X-Envoy-Internal\u0022: [\n      \u0022true\u0022\n    ],\n    \u0022X-Forwarded-For\u0022: [\n      \u002210.244.0.51\u0022\n    ],\n    \u0022X-Forwarded-Proto\u0022: [\n      \u0022https\u0022\n    ],\n    \u0022X-Request-Id\u0022: [\n      \u0022c1e64057-c5c8-4fb2-a304-25c291eeed32\u0022\n    ]\n  },\n  \u0022namespace\u0022: \u0022default\u0022,\n  \u0022ingress\u0022: \u0022\u0022,\n  \u0022service\u0022: \u0022\u0022,\n  \u0022pod\u0022: \u0022backend-55d64d8794-4qvgd\u0022\n}\n\u0060\u0060\u0060\n\nAt this point, you can see the ID Token in the Chrome browser\u0027s *Inspector - Application - Cookies*, as shown below:\n\n![View ID Token in Chrome Inspector](inspector.webp)\n\nWrite a Python script \u0060validate_id_token.py\u0060 to parse and validate the ID Token:\n\n\u0060\u0060\u0060python\nimport jwt\nimport requests\nfrom jwt.algorithms import RSAAlgorithm\nimport argparse\nimport json\nimport base64\n\ndef base64url_decode(input):\n    rem = len(input) % 4\n    if rem \u003e 0:\n        input \u002b= \u0027=\u0027 * (4 - rem)\n    return base64.urlsafe_b64decode(input)\n\ndef get_signing_key(jwk_url, kid):\n    jwks = requests.get(jwk_url).json()\n    for jwk in jwks[\u0027keys\u0027]:\n        if jwk[\u0027kid\u0027] == kid:\n            return RSAAlgorithm.from_jwk(jwk)\n    raise Exception(\u0027Public key not found.\u0027)\n\ndef validate_token(token, audience, issuer, jwk_url):\n    headers = jwt.get_unverified_header(token)\n    kid = headers[\u0027kid\u0027]\n    signing_key = get_signing_key(jwk_url, kid)\n\n    decoded_token = jwt.decode(\n        token,\n        signing_key,\n        algorithms=[\u0022RS256\u0022],\n        audience=audience,\n        issuer=issuer\n    )\n    return decoded_token\n\nif __name__ == \u0022__main__\u0022:\n    parser = argparse.ArgumentParser(description=\u0027Validate a JWT token.\u0027)\n    parser.add_argument(\u0027token\u0027, type=str, help=\u0027The JWT token to validate\u0027)\n    args = parser.parse_args()\n\n    token = args.token\n\n    # Parse the token\u0027s payload to extract audience and issuer\n    header, payload, signature = token.split(\u0027.\u0027)\n    decoded_payload = base64url_decode(payload)\n    payload_json = json.loads(decoded_payload)\n\n    audience = payload_json[\u0027aud\u0027]\n    issuer = payload_json[\u0027iss\u0027]\n    jwk_url = f\u0022{issuer}.well-known\/jwks.json\u0022\n\n    try:\n        decoded = validate_token(token, audience, issuer, jwk_url)\n        print(\u0022Token is valid. Decoded payload:\u0022)\n        for key, value in decoded.items():\n            print(f\u0022{key}: {value}\u0022)\n    except Exception as e:\n        print(f\u0022Token validation failed: {e}\u0022)\n\u0060\u0060\u0060\n\nInstall the required packages:\n\n\u0060\u0060\u0060bash\npip install pyjwt requests\n\u0060\u0060\u0060\n\nRun the script:\n\n\u0060\u0060\u0060bash\npython validate_id_token.py ${ID_TOKEN}\n\u0060\u0060\u0060\n\nYou will see an output similar to the following:\n\n\u0060\u0060\u0060ini\nToken is valid. Decoded payload:\niss: https:\/\/dev-awhjmy38gg5qzx7u.us.auth0.com\/\naud: Tg8e5ehkLJ3hdkw1O4D10PwmPy71dvmv\niat: 1716470905\nexp: 1716506905\nsub: google-oauth2|112744779022331048640\nsid: 4W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\n\u0060\u0060\u0060\n\nFrom the values in the ID Token, you can conclude:\n\n- The token is issued by Auth0 (\u0060iss\u0060 field).\n- The audience of the token is a specific application or API (\u0060aud\u0060 field), which is the Client ID for Auth0.\n- The token was issued at 2024-05-23 04:08:25 UTC (\u0060iat\u0060 field) and will expire at 2024-05-23 14:08:25 UTC (\u0060exp\u0060 field).\n- The subject (user) of the token has a unique identifier \u0060google-oauth2|112744779022331048640\u0060 (\u0060sub\u0060 field). This indicates that the user logged in using Google OAuth2.\n- The session ID is \u00604W_hQNJJ8ftDL8S3Cozp8GEu2Au4_e9N\u0060 (\u0060sid\u0060 field), used for session management.\n\n### Verifying Single Sign-On: Logout\n\nSince our example application does not implement the Auth0 logout logic, we need to explicitly tell Auth0 to logout via an HTTP request. Visit the following URL in your browser:\n\n\u0060\u0060\u0060bash\nhttps:\/\/${DOMAIN}\/v2\/logout?client_id=${CLIENT_ID}\n\u0060\u0060\u0060\n\nReplace \u0060${DOMAIN}\u0060 and \u0060${CLIENT_ID}\u0060 with the configuration items from your [Auth0 setup](#auth0). For detailed instructions on how to log users out using the OIDC endpoint in Auth0, refer to the [Auth0 documentation](https:\/\/auth0.com\/docs\/api\/authentication#logout).\n\nAfter logging out, the page will redirect to the login page again. Upon logging in, the page will redirect to \u003chttps:\/\/www.example.com\u003e.\n\n## Summary\n\nThrough these steps, you can implement OIDC authentication in Envoy Gateway, ensuring API security. This method not only provides a flexible authentication mechanism but also simplifies application identity management. By integrating with identity providers like Auth0, Envoy Gateway can easily achieve Single Sign-On, enhancing user experience and system security. In the future, you can further configure and optimize Envoy Gateway based on your needs, leveraging its powerful authentication and authorization capabilities to meet more complex security requirements and business needs.\n\n## References\n\n- Envoy Gateway OIDC Authentication - gateway.envoyproxy.io\n- [Log Users Out of Auth0 with OIDC Endpoint - auth0.com](https:\/\/auth0.com\/docs\/authenticate\/login\/logout\/log-users-out-of-auth0)', '\/en\/blog\/envoy-gateway-oidc\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed guide on configuring Envoy Gateway to use OIDC for Single Sign-On. By using Auth0 as the identity provider, it demonstrates how to achieve secure and efficient SSO at the API Gateway level, enhancing user experience and system security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-delta-xds-for-envoy/">Introduction to Envoy xDS and Configuration Distribution in Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 24, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introduction to Envoy xDS and Configuration Distribution in Istio', 'This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.', '\nIn the early stages of the Istio project, configurations were pushed to Envoy proxies using the global State of the World (SotW) method. Whenever a service changed, the global configuration had to be pushed to all sidecars, causing significant network load and performance loss on the control plane. The Istio community began developing Incremental xDS a few years ago to address this issue and has supported Incremental xDS in recent Istio versions. In the recent [Istio 1.22 release](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/), Incremental xDS has become the default feature. This article will introduce you to xDS, Incremental xDS, and the method of configuration distribution in Istio.\n\n## What is xDS?\n\nxDS (Extensible Discovery Service) is a communication protocol used for managing service discovery and dynamic configuration in a microservices architecture. This mechanism is widely used in Envoy proxies and Istio service meshes to manage various types of resource configurations, such as routing, service discovery, load balancing settings, etc.\n\n### What discovery services are included in xDS?\n\nxDS includes the following main discovery services, each responsible for different types of network resource configurations:\n\n1. **LDS (Listener Discovery Service)**: Manages the configuration of Envoy listeners, which define how to receive and handle inbound connections.\n2. **RDS (Route Discovery Service)**: Provides routing information, defining how to route requests to different services based on specified rules.\n3. **CDS (Cluster Discovery Service)**: Manages cluster information, where a cluster represents a group of logically similar backend service instances.\n4. **EDS (Endpoint Discovery Service)**: Provides the network addresses of specific service instances that make up the clusters defined in CDS.\n5. **SDS (Secret Discovery Service)**: Manages security-related configurations, such as TLS certificates and private keys.\n6. **VHDS (Virtual Host Discovery Service)**: Provides virtual host configurations for RDS, allowing dynamic updates of virtual hosts without restarting connections.\n7. **SRDS (Scoped Route Discovery Service)**: Manages routing scopes, providing dynamic route selection based on different conditions (such as request headers).\n8. **RTDS (Runtime Discovery Service)**: Provides runtime configurations, which can be used for experimental features or fine-tuning system behavior.\n9. **ECDS (Extension Config Discovery Service)**: Supports dynamic configuration updates for a specific filter. Currently, ECDS is supported for network filters, HTTP filters and Listener filters. \n\nThese services collectively support the distribution and update of dynamic configurations, enabling Envoy-based application architectures to adapt in real-time to changes, enhancing scalability and flexibility. Each service can be implemented independently or managed collectively through an aggregated approach (such as ADS). CNCF has also established an [xDS API working group](https:\/\/github.com\/cncf\/xds) to promote the xDS API as the de facto standard for L4\/L7 data plane configuration, similar to the role OpenFlow plays in L2\/L3\/L4 in SDN.\n\n{{\u003ccallout note Tip\u003e}}\nFor a detailed introduction to the xDS protocol, such as xDS RPC services and variant methods, as well as the xDS request process, please refer to the [Envoy proxy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol).\n{{\u003c\/callout\u003e}}\n\n### Variants of the xDS Protocol\n\nThe xDS protocol primarily includes the following variants:\n1. **State of the World (SotW)**: A separate gRPC stream provides complete data for each type of resource, typically used during the initial startup of an Envoy proxy, and was the first type of xDS protocol used by Istio.\n2. **Incremental xDS (Delta xDS)**: Provides only the changed parts of the data for each type of resource, developed starting in 2021 and enabled by default in the Istio 1.22 version.\n3. **Aggregated Discovery Service (ADS)**: A single gRPC stream aggregates all types of resource data.\n4. **Incremental ADS (Delta ADS)**: A single gRPC stream aggregates all types of incremental data.\n\nThe table below summarizes the four variants of the xDS protocol, including explanations, usage scenarios, and a comparison of their advantages and disadvantages. These variants provide multiple options for different network environments and service needs, allowing you to choose the most suitable protocol variant to optimize service performance and resource use.\n\n{{\u003ctable \u0022Introduction to the four variants of the xDS protocol\u0022\u003e}}\n| Variant Type  | Explanation                                                 | Usage Scenario                                               | Advantages                                                | Disadvantages                                              |\n| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW          | Sends all configuration data each time, regardless of changes. | Suitable for stable environments with little configuration change. | Simple to implement, easy to understand and maintain.     | Large data transmission, not suitable for environments with frequent configuration updates. |\n| Delta xDS     | Transmits only changed configuration data, not all data.     | Suitable for environments with frequent changes needing quick response to updates. | Reduces unnecessary data transmission, increasing efficiency. | Complex implementation, requires client and server to manage configuration states. |\n| ADS           | Manages all configuration data through a single gRPC stream, eliminating the need for separate connections for each resource type. | Suitable for complex service architectures that need to manage multiple types of resources simultaneously. | Reduces the number of network connections, simplifying resource management. | In cases of poor network or service quality, a single point of failure could cause all configuration updates to fail. |\n| Delta ADS     | Combines the advantages of ADS and Incremental xDS, aggregating and transmitting only changes in resources through a single gRPC stream. | Suitable for highly dynamic environments that need to manage multiple types of resources and require frequent updates. | Provides maximum flexibility and efficiency, suitable for large-scale and highly dynamic service architectures. | Most complex implementation, high requirements for managing configuration logic and precise control over resource changes and transmission. |\n\n{{\u003c\/table\u003e}}\n\nService meshes using the xDS protocol can more flexibly manage communication and configurations between microservices, reducing the latency of configuration changes and improving system response speed and reliability.\n\nIn Istio, the DiscoveryServer acts as the implementation of Envoy\u0027s xDS API, responsible for listening to the gRPC interface and dynamically pushing configurations according to Envoy\u0027s needs. It can handle requests for various resource types and update Envoy configurations in real-time based on service changes. Additionally, it supports security features, such as verifying client certificates, ensuring only legitimate service instances can receive configuration data.\n\n### Configuration Examples for xDS Variants\n\nConfiguring xDS variants typically involves specifying the xDS server details in the configuration of the Envoy proxy or a similar service mesh. While the configuration details of different service meshes and proxy servers may vary, here are some common YAML configuration examples that illustrate how to specify xDS servers and how to use these protocol variants.\n\n#### State of the World (SotW)\n\nIn Envoy\u0027s configuration, you can use SotW either through static resources or by dynamically obtaining resources via API. Here\u0027s a simple Envoy configuration example showing how to statically define clusters and listeners:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n#### Incremental xDS\n\nIncremental xDS configuration requires the xDS server to support the incremental protocol, and the client configuration must specify the use of Incremental xDS. The Envoy startup configuration needs to add an API version to enable Incremental xDS:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Aggregated Discovery Service (ADS) \n\nWhen using ADS, the configuration of all resource types is aggregated through a single API endpoint. This is specified in the Envoy configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Incremental ADS\n\nIncremental ADS achieves more fine-grained updates by specifying the incremental API type in the ADS configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\nThese configuration examples need to be adjusted according to your specific environment and requirements. For more details and advanced configurations, you can refer to the [Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype).\n\n## How Does Istio Send Configurations to Envoy Sidecars?\n\nThanks to the xDS protocol, tools like Istio and Envoy Gateway can dynamically distribute configurations to Envoy proxies via API. The diagram below shows the configuration distribution process in Istio (Sidecar mode).\n\n\u0060\u0060\u0060mermaid \u0022Istio Configuration Distribution Process Diagram\u0022\nflowchart TB\n    Declarative_Configuration[Declarative Configuration] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio Configuration Distribution Process Diagram](f78ce8f5c5eb02d32a733e923a83fa5d.svg)\n\nThe main steps of the configuration distribution process in Istio are:\n\n1. **Declarative Configuration**: Users define the service mesh\u0027s configuration using YAML files or other configuration management tools. These configurations can include routing rules, security policies, telemetry settings, etc.\n2. **Kubernetes**: Istio configuration files are submitted to the Kubernetes cluster, usually through the \u0060kubectl apply\u0060 command or other CI\/CD tools. Kubernetes receives the configuration files and stores them in the etcd database.\n3. **Istiod**: Istiod is the control plane component of Istio, responsible for managing and distributing configurations. It listens for events coming from the Kubernetes API server, obtains relevant configuration changes, and processes them. Istiod parses the configuration files, generates corresponding routing rules and policies, and distributes these configurations to the data plane (Envoy proxies) via the xDS API.\n4. **xDS API**: Istiod uses the xDS API to send configurations to each Envoy proxy.\n5. **Envoy Proxy**: Envoy is the data plane component of Istio, running in a sidecar container alongside each service, intercepting and managing all inbound and outbound traffic. Envoy proxies receive configurations from Istiod via the xDS API and manage traffic, enforce policies, and collect telemetry data based on these configurations.\n6. **Pod**: Each service instance runs in a Pod, which contains an application container and an Envoy proxy container. The Envoy proxy intercepts all network traffic to and from the application container and processes it according to the configurations.\n\nThis configuration distribution process ensures that Istio can dynamically manage and configure all service instances in the service mesh, providing consistent traffic management and policy enforcement.\n\n## The Evolution of xDS and the Implementation of Delta xDS in Istio\n\nInitially, xDS adopted a \u0022global state\u0022 (State of the World, abbreviated as SotW) design, which meant that any configuration change required sending the complete state of all configurations to Envoy. This approach created a huge burden on the network and control plane, especially in large-scale service deployments.\n\nAt EnvoyCon 2021, Aditya Prerepa and John Howard shared How Istio Implements Delta xDS, an incremental implementation of xDS. Compared to the traditional SotW xDS, Delta xDS sends only the changed configurations, significantly reducing the amount of configuration data that needs to be sent over the network, thus improving efficiency and performance. This method is particularly suitable for environments where configurations change frequently, as it updates only the changed parts rather than the entire configuration.\n\nDuring the implementation of Delta xDS, the Istio\n\n team faced several challenges, including ensuring the correctness of configuration updates and avoiding potential resource leaks. They addressed these challenges by adopting a Dry-run mode to run the SotW and Delta generators in parallel, gradually identifying and fixing flaws in the implementation. Additionally, they introduced new Envoy types, such as the Virtual Host Discovery Service, to support more fine-grained configuration distribution.\n\n### Delta xDS Incremental Configuration\n\nThe diagram below illustrates the process of Delta xDS incremental configuration.\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS Incremental Configuration Process Diagram\u0022\nsequenceDiagram\n    participant CP as Control Plane\n    participant P as Proxy\n    CP-\u003e\u003eP: Initial Complete Configuration\n    P-\u003e\u003eCP: Subscribe to Configuration Changes\n    Note over CP,P: Any Configuration Change Occurs\n    CP-\u003e\u003eP: Check Configuration Changes\n    CP-\u003e\u003eP: Calculate Differences\n    CP-\u003e\u003eP: Send Only Differences\n    Note over P: Proxy Uses Differences for Updates\n\u0060\u0060\u0060\n\n![Delta xDS Incremental Configuration Process Diagram](9a1fc2d6009beb68cf596e0f077881ec.svg)\n\nThe Delta xDS configuration process is as follows:\n\n1. **Initial Complete Configuration**: The control plane sends the initial complete configuration to the proxy, using the StoW mode at this time.\n2. **Subscribe to Configuration Changes**: The proxy subscribes to configuration changes from the control plane.\n4. **Check Configuration Changes**: The control plane checks for configuration changes relative to the proxy\u0027s known state.\n5. **Calculate Differences**: The control plane calculates the differences (increments) between the current configuration and the previous configuration held by the proxy.\n6. **Send Only Differences**: The control plane sends only the changed configuration (differences) to the proxy, which applies these incremental updates to its configuration.\n\nThis process ensures that only necessary changes are transmitted and applied, improving efficiency and reducing the load on network and proxy resources.\n\n### SotW vs Delta xDS\n\nWhile Delta xDS solves the performance issues of configuration distribution in large-scale networks, the SotW mode still has its place, such as in the initial configuration delivery. The table below compares the two configuration distribution methods in Istio: SotW (State of the World) and Delta xDS.\n\n{{\u003ctable \u0022Comparison of Global State and Incremental xDS Configuration Distribution Methods in Istio\u0022\u003e}}\n| Comparison Item   | SotW                                                        | Delta XDS                                   |\n| ----------------- | ----------------------------------------------------------- | ------------------------------------------- |\n| **Data Volume**   | Transmits complete configuration data each time, regardless of whether there are changes. | Transmits only the changed configuration data, reducing data volume. |\n| **Efficiency**    | Acceptable efficiency in small or less changing environments. | Higher efficiency in large or frequently changing environments. |\n| **Complexity**    | Simple implementation, easy to understand and maintain.     | More complex implementation, requires fine tracking and management of changes. |\n| **Resource Usage** | May increase server and network load due to repeatedly sending large amounts of unchanged data. | Lower resource usage, as only changed parts are handled. |\n| **Timeliness**    | High immediacy as full configuration is sent immediately after updates. | Faster response by sending only changed parts, reducing processing time. |\n| **Applicability** | Suitable for small to medium deployments with infrequent configuration changes. | Suitable for environments with frequent configuration changes or large-scale deployments. |\n{{\u003c\/table\u003e}}\n\nThis table compares SotW and Delta XDS from multiple perspectives, including data volume, efficiency, complexity, resource usage, timeliness, and applicability, helping you make the appropriate choice in different usage environments.\n\n## Conclusion\n\nIn this article, I shared the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS. With Delta xDS becoming the default configuration in Istio version 1.22, this will help users easily use Istio in large-scale network environments.\n\n## References\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-delta-xds\/).', '\/en\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-22/">Deep Dive into Istio 1.22: New Features and Practical Application Advice</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 21, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Deep Dive into Istio 1.22: New Features and Practical Application Advice', 'Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.', '\nThe recent [release of Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) includes a plethora of significant updates. This article shares the new features and application recommendations brought by this release.\n\n## Ambient Mode Enters Beta Phase\n\nAlthough Ambient mode has now entered the Beta phase, this does not mean we can completely do away with Sidecars. While the Istio official claims that Ambient mode simplifies operations and significantly reduces memory and CPU usage, it still has limitations and potential complexity issues. For example, while Sidecars are eliminated, the introduction of new ztunnel and waypoint components may pose new challenges. For more detailed information about Ambient mode entering Beta, refer to the [Istio official blog](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/).\n\n**Challenges Introduced by Ambient Mode**\n\n- Management of L7 traffic in Ambient mode is not yet mature\n- mTLS is forced to be enabled at the namespace level, meaning you cannot disable mTLS in Ambient mode\n- Zero-downtime upgrades in Ambient mode have not been resolved\n- Lack of best practices for coexistence and migration from Sidecar mode\n\nFor a comparison of Sidecar mode and Ambient mode, see [Analysis of Limitations in Istio Ambient Mode](\/blog\/istio-ambient-mode-limitations\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nIf you are just starting with Istio, especially if you only need to automatically enable mTLS for services, you can consider using Ambient mode at this stage. However, for L7 functionalities, it is recommended to wait until Ambient mode is fully mature before considering it for production use.\n{{\u003c\/callout\u003e}}\n\n## Istio API Upgrades\n\nIn the Istio 1.22 release, key APIs related to traffic management, security, and telemetry have officially been upgraded to the \u0060v1\u0060 version. You only need to change the API version of your existing configuration to \u0060v1\u0060, with no other changes needed. These APIs are already mature, and you can safely use the \u0060v1\u0060 version. For environments requiring high stability, Istio has added [validating admission policies](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/) to ensure that only \u0060v1\u0060 APIs and fields can be used in the Istio API.\n\nFor example, the following AuthorizationPolicy example.\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\nOther extension-type APIs such as \u0060EnvoyFilter\u0060, \u0060WasmPlugin\u0060, \u0060ProxyConfig\u0060 are still in alpha or beta stages. For more information on API upgrades, please refer to the [v1 API blog](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor commonly used functionalities, you can confidently use the \u0060v1\u0060 API. For extension-type APIs that are not yet stable, enabling validating admission policies is recommended to ensure system stability.\n{{\u003c\/callout\u003e}}\n\n## Gateway API Upgrade\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) has been updated to version 1.1.0 and is now widely available. This update extends Istio\u0027s traffic management capabilities, but it is important to be cautious of compatibility issues between Istio\u0027s native APIs and the Gateway API when migrating to the new API to avoid relying on features that are not fully mature yet. For more details, check out the [Gateway API v1.1 blog](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor existing deployments that are already stable using Istio API, continue using them, especially in scenarios requiring advanced features. For new deployments, consider using the stable version of the Gateway API to take advantage of its modern traffic management capabilities. Due to existing compatibility issues, do not rashly migrate to the Gateway API, as it may not be worth the risk.\n{{\u003c\/ callout\u003e}}\n\n## Delta xDS Enabled by Default\n\nIstio 1.22 version now has delta xDS enabled by default, which is a mechanism to optimize configuration distribution. Compared to the traditional State of the World (SotW) mode, delta xDS only sends changed configurations to the Envoy proxies, thereby significantly reducing the amount of data transmitted over the network and the resource consumption of the control plane. This change is particularly suitable for large-scale deployment environments with frequent configuration updates, improving the efficiency and performance of configuration updates. Additionally, delta xDS also helps manage configuration updates more efficiently in complex network environments or dynamically changing configurations.\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nThe delta xDS has been developed several versions ago but was not enabled by default. Now that this feature is stable, you can use it with confidence.\n{{\u003c\/callout\u003e}}\n\nFor more on xDS, refer to the [Introduction to Envoy xDS and Configuration Distribution Process in Istio](\/blog\/istio-delta-xds-for-envoy\/).\n\n### Path Template Support with Wildcards for AuthorizationPolicy\n\nIn Istio 1.22, \u0060AuthorizationPolicy\u0060 has added support for [path templates](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation), greatly enhancing the flexibility and precision of path matching. Prior to this, \u0060AuthorizationPolicy\u0060 did not support wildcards in path configurations. This feature allows for defining paths in HTTP requests using URI templates based on Envoy, including simple wildcards (\u0060*\u0060 and \u0060**\u0060) or named variables, enabling precise matching of single or multiple path components. For example, the path template \u0060\/foo\/{*}\u0060 can match \u0060\/foo\/bar\u0060 but not \u0060\/foo\/bar\/baz\u0060, while \u0060\/foo\/{**}\/\u0060 can match any path starting with \u0060\/foo\/\u0060. This flexible path template design is particularly suitable for dynamic and complex routing rules, further strengthening Istio\u0027s security policy toolbox.\n\nThe diagram below illustrates the wildcard rules for path matching in AuthorizationPolicy.\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy Path Matching Wildcard Rules\u0022\ngraph LR\n    A[AuthorizationPolicy Path Matching] --\u003e B(Define Path Templates)\n    B --\u003e C{Path Template Operators}\n    C --\u003e D[\u0022* (Match single segment)\u0022]\n    C --\u003e E[\u0022** (Match multiple segments)\u0022]\n    C --\u003e F[\u0022{name} (Named variable matching one segment)\u0022]\n    C --\u003e G[\u0022{name=**} (Named variable matching multiple segments)\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} matches \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ matches \/foo\/bar\/, \/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} matches \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd matches \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy Path Matching Wildcard Rules](dfe9a5d5e2bc91e91e7e24017f56a3db.svg)\n\nFor more on the specific applications and rules of path templates, you can refer to [Envoy\u0027s official documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto).\n\n{{\u003c callout note \u0022Tip\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 finally supports templates in path matching, so you no longer need to manually add paths one by one in your configurations.\n{{\u003c\/callout\u003e}}\n\n## Summary\n\nThe Istio 1.22 release introduces several important updates and improvements. Although some features are widely publicized, they require detailed assessment and appropriate testing in practical use. Hopefully, this blog post helps you understand and apply these new features more deeply to achieve the best results in practice.\n\n## References\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-new-features-v1_22\/).', '\/en\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/paris-trip/">A Journey in Paris — Capturing the Spring of France</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/essays"> 
             Essays
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('A Journey in Paris — Capturing the Spring of France', 'In March 2024, I visited Paris during KubeCon EU, experiencing the local culture, cuisine, and daily life nuances.', '\nIn March 2024, I had the special opportunity to visit Paris, France, for [KubeCon EU 2024](\/en\/blog\/kubecon-eu-paris-recap\/), a gathering of cloud computing and open-source enthusiasts from around the globe. Utilizing this chance, I not only gained insights into the latest technological trends but also embraced the history, culture, and everyday life of this city. My Parisian adventure spanned from March 16th to the 24th, during which I explored as much of this enchanting city as possible.\n\n## Visa Chapter\n\nFor us Chinese, obtaining a visa is always the first step to traveling abroad. The French Schengen visa, requiring a multitude of documents including a company sponsorship letter and itinerary, was made relatively easier by my company\u0027s profile. Fortunately, unlike the Japanese visa, the French visa did not require freezing substantial funds or showing a hefty bank deposit. I received a six-month visa, offering more flexibility and possibilities for my future travels in Europe.\n\n## Arriving in Paris\n\nThe journey from Beijing to Paris was filled with anticipation. I flew with Air France, departing in the early hours from Beijing and, after a 13-hour flight, arrived in Paris early in the morning. On my way back, I chose to transit through Istanbul, adding an exotic touch to my travel memories.\n\n## First Impressions\n\nThe Charles de Gaulle Airport was adorned with elegant Chinese signs everywhere, reflecting the French attention to detail. Although the customs process took nearly an hour, the diverse crowd reinforced the international vibe of Paris. Navigating the metro, I attempted three times before successfully boarding due to the crowd. Using Bolt taxi service, a kind Frenchman helped me communicate with the driver in French, showcasing the warmth and friendliness of the locals.\n\nHere are the translations for the image captions:\n\n![Charles de Gaulle Airport](custom.webp)\n\n## Parisian Daily Details\n\nIn every corner of Paris, you can see uniquely designed trash bins that are not only practical but also consider safety. Some are explosion-proof for glass bottles and cans, while others are simply covered with clear plastic bags for the same reason. These details reflect the meticulous and thoughtful city management.\n\n![Parisian Street Trash Bins](dustbin.webp)\n\n## Dining in Paris\n\nDespite the allure of Western steaks and pastries, I found myself craving the flavors of home. In Paris, I discovered a Sichuan restaurant named Yang\u0027s Kitchen; their beef noodle soup, while different from those back home, was delicious and reasonably priced. Additionally, the street fruits in Paris were not only more affordable but also tastier than those I usually purchase online, especially the pears I love.\n\n![Chinese and Western Cuisine in Paris, including Macarons](food.webp)\n\n![Street Stalls and Bakeries in Paris](store.webp)\n\n## Living in Paris\n\nParis, the capital of France, is renowned for its romance and history and has a unique administrative structure. The city is typically divided into \u0022Greater Paris\u0022 and \u0022Lesser Paris,\u0022 with Lesser Paris referring to the inner city from the 1st to the 20th arrondissement, covering most of the famous historical landmarks and cultural areas. Greater Paris includes the suburbs around Lesser Paris, forming a broader metropolitan area.\n\n![Map of Lesser Paris](paris-map.webp)\n\n![Comparison of the Area of Lesser Paris and Beijing\u0027s Third Ring Road](paris-vs-beijing.webp)\n\n## Navigating Paris\n\nParis\u0027s street planning is unique; the roads crisscross in non-strict north-south directions, and with traffic lights set on street corners, it can be disorienting for newcomers. The city\u0027s bike lanes are well-developed; I rented a power-assisted bicycle, experiencing an unprecedented sense of freedom cruising through the streets of Paris. The metro system is complex yet comprehensive, with a convenient payment system that mostly accepts credit cards.\n\n![Bike Lanes on Paris Streets](bike.webp)\n\n![Paris Metro](metro.webp)\n\n## Healthcare Experience\n\nThe second day in Paris, I suffered from diarrhea due to improper eating, which lasted two days. During this time, I visited a local pharmacy to buy medication. The pharmacy opened punctually at 8 AM, and there was always a line outside, impressing me with their timeliness and order.\n\n![Anti-diarrheal Medicine Purchased in Paris](drug.webp)\n\n## Sightseeing in Paris\n\nDuring the KubeCon EU, I used my spare time to visit several of Paris\u0027s famous attractions. The Eiffel Tower was a must-see; I ascended to the second-floor platform, which offered a spectacular view of the entire city. The Louvre, a haven for art lovers, drew countless visitors to Mona Lisa\u0027s enigmatic smile. Although the Notre-Dame was under repair, its charm at night remained irresistible.\n\n![The Louvre Museum](louvre.webp)\n\n![Foucault\u0027s Pendulum inside the Pantheon](pantheon.webp)\n\n![The Seine River](seine.webp)\n\n![Madeleine Church](madeleine.webp)\n\n![Sacré-Cœur Basilica](basilique.webp)\n\n## About the Olympics\n\nThe modern Olympics were initiated by the French in Paris. It may be that the French are accustomed to the Olympics, or it could be an effort to minimize disruption to local life. During my visit to Paris, I did not feel any ambiance indicative of the upcoming Olympic Games. Only a few iconic buildings had stages under construction, possibly for Olympic use, and some shops were selling Olympic memorabilia.\n\n## Comments\n\nRecently, there have been several videos on Chinese internet platforms depicting the poor security and environmental conditions in Paris, such as prevalent street theft, public urination, and a lack of public restrooms. Fortunately, I did not encounter any thieves nor did my companions. However, I did notice a urine smell, especially around tourist areas, and encountered a few homeless people asking for cigarettes. Additionally, it was challenging to find restrooms in the Louvre; the only men\u0027s restroom I found was under maintenance.\n\n![Street near the Louvre filled with trash and urine smell](street.webp)\n\n## Conclusion\n\nParis, with its unique charm and rich cultural heritage, left a profound impression on me. The locals were warm and friendly, and the scenery was breathtaking. Although some tourist-heavy areas were a bit chaotic, that\u0027s an unavoidable aspect of any tourist city. My trip to Paris was filled with wonderful memories, making me look forward to visiting this romantic land again. I hope this travelogue will help those planning their first journey to this enchanting city.', '\/en\/blog\/paris-trip\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In March 2024, I visited Paris during KubeCon EU, experiencing the local culture, cuisine, and daily life nuances.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/en/blog/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/blog/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/blog/page/3/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(50)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/migrate-to-istio-telemetry-api/">Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
