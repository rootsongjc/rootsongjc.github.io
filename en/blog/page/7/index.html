<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Blog · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog Posts">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/blog/" />
  <meta property="og:title" content="Blog | Jimmy Song" />
  <meta property="twitter:title" content="Blog | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog Posts" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog Posts" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/book">Book</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/blog/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Blog
                </p>
                <p class="page-description">
                    Jimmy Song&rsquo;s Blog Posts
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-do-you-need-istio-when-you-already-have-kubernetes/">Why Do You Need Istio When You Already Have Kubernetes?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Apr 7, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why Do You Need Istio When You Already Have Kubernetes?', 'This article will take you through the inner workings of Kubernetes and Istio. In addition, I will introduce the load balancing approach in Kubernetes, and explain why you need Istio when you have Kubernetes.', '\nIf you’ve heard of service mesh and tried [Istio](https:\/\/istio.io\/), you may have the following questions:\n\n1. Why is Istio running on Kubernetes?\n2. What is the role of Kubernetes and a service mesh in the cloud native application architecture, respectively?\n3. What aspects of Kubernetes does Istio extend? What problems does it solve?\n4. What is the relationship between Kubernetes, Envoy, and Istio?\n\nThis article will take you through the inner workings of Kubernetes and Istio. In addition, I will introduce the load balancing approach in Kubernetes, and explain why you need Istio when you have Kubernetes.\n\nKubernetes is essentially about application lifecycle management through declarative configuration, while a service mesh is essentially about providing inter-application traffic, security management and observability. If you have already built a stable application platform using Kubernetes, how do you set up load balancing and traffic control for calls between services? This is where a service mesh comes into the picture.\n\nEnvoy introduces the xDS protocol, which is supported by various open source software, such as [Istio](https:\/\/istio.io\/), [MOSN](https:\/\/github.com\/mosn\/mosn), etc. Envoy contributes xDS to a service mesh or cloud native infrastructure. Envoy is essentially a modern version of a proxy that can be configured through APIs, based on which many different usage scenarios are derived — such as API Gateway, sidecar proxy in service mesh, and edge proxy.\n\nThis article contains the following:\n\n- A description of the role of kube-proxy.\n- The limitations of Kubernetes for microservice management.\n- An introduction to the capabilities of Istio service mesh.\n- A comparison of some of the concepts in Kubernetes, Envoy, and the Istio service mesh.\n\n## Kubernetes vs Service Mesh\n\nThe following diagram shows the service access relationship in Kubernetes and service mesh (one sidecar per pod model).\n\n![Kubernetes vs Service Mesh](008eGmZEly1gpb7knfo4dj31hk0redrz.jpg)\n\n### Traffic Forwarding\n\nEach node in a Kubernetes cluster deploys a kube-proxy component that communicates with the Kubernetes API Server, gets information about the services in the cluster, and then sets iptables rules to send requests for service directly to the corresponding Endpoint (a pod belonging to the same group of services).\n\n### Service Discovery\n\n![Service Discovery](008eGmZEly1gpb7knwb79j30kq0fcjs9.jpg)\n\nIstio can follow the service registration in Kubernetes and can also interface with other service discovery systems via platform adapters in the control plane; and then generate data plane configurations (using CRD, which are stored in etcd) with transparent proxies for the data plane. The transparent proxy of the data plane is deployed as a sidecar container in the pod of each application service, and all these proxies need to request the control plane to synchronize the proxy configuration. The proxy is “transparent” because the application container is completely unaware of the presence of the proxy. The kube-proxy component in the process needs to intercept traffic as well, except that the kube-proxy intercepts traffic to and from the Kubernetes node — while the sidecar proxy intercepts traffic to and from the pod.\n\n### Disadvantages of a Service Mesh\n\nSince Kubernetes has many pods running on each node, putting the original kube-proxy route forwarding function in each pod will increase the response latency — due to more hops when the sidecar intercepts the traffic — and consume more resources. In order to manage traffic in a fine-grained manner, a series of new abstractions will be added. This will further increase the learning cost for users, but as the technology becomes more popular this situation will be slowly alleviated.\n\n### Advantages of a Service Mesh\n\nThe kube-proxy settings are global and cannot be controlled at a granular level for each service, while service mesh takes the traffic control out of the service layer in Kubernetes by means of sidecar proxy — allowing for more elasticity.\n\n### Shortcomings of Kube-Proxy\n\nFirst, it does not automatically try another pod if the forwarded pod is not serving properly. Each pod has a health check mechanism and when a pod has health problems, kubelet will restart the pod and kube-proxy will remove the corresponding forwarding rules. Also, nodePort-type services cannot add TLS or more complex message routing mechanisms.\n\nKube-proxy implements load balancing of traffic across multiple pod instances of a Kubernetes service, but how do you do fine-grained control of traffic between these services — such as dividing traffic by percentage to different application versions (which are all part of the same service but on different deployments), or doing canary releases (grayscale releases) and blue-green releases?\n\nThe Kubernetes community gives a way to [do canary releases using Deployment](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments), which is essentially a way to assign different pods to a deployment’s service by modifying the pod’s label.\n\n## Kubernetes Ingress vs. Istio Gateway\n\nAs mentioned above, kube-proxy can only route traffic within a Kubernetes cluster. The pods of a Kubernetes cluster are located in a network created by CNI. An ingress — a resource object created in Kubernetes — is created for communication outside the cluster. It’s driven by an ingress controller located on Kubernetes edge nodes responsible for managing north-south traffic. Ingress must be docked to various Ingress Controllers, such as the [nginx ingress controller](https:\/\/github.com\/kubernetes\/ingress-nginx) and [traefik](https:\/\/traefik.io\/). Ingress is only applicable to HTTP traffic and is simple to use. It can only route traffic by matching a limited number of fields — such as service, port, HTTP path, etc. This makes it impossible to route TCP traffic such as MySQL, Redis, and various RPCs. This is why you see people writing nginx config language in ingress resource annotations.The only way to directly route north-south traffic is to use the service’s LoadBalancer or NodePort, the former requiring cloud vendor support and the latter requiring additional port management.\n\nIstio Gateway functions similarly to Kubernetes Ingress, in that it is responsible for north-south traffic to and from the cluster. Istio Gateway describes a load balancer for carrying connections to and from the edge of the mesh. The specification describes a set of open ports and the protocols used by those ports, the SNI configuration for load balancing, etc. Gateway is a CRD extension that also reuses the capabilities of the sidecar proxy; see the [Istio website](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/gateway\/) for detailed configuration.\n\n## Envoy\n\nEnvoy is the default sidecar proxy in Istio. Istio extends its control plane based on Envoy’s xDS protocol. We need to familiarize ourselves with Envoy’s basic terminology before talking about Envoy’s xDS protocol. The following is a list of basic terms and their data structures in Envoy; please refer to the [Envoy documentation](https:\/\/envoyproxy.io\/) for more details.\n\n![Envoy](008eGmZEly1gpb7koah95j31450tetta.jpg)\n\n### Basic Terminology\n\nThe following are the basic terms in Envoy that you should know.\n\n- **Downstream**: The downstream host connects to Envoy, sends the request, and receives the response; i.e., the host that sent the request.\n- **Upstream**: The upstream host receives connections and requests from Envoy and returns responses; i.e., the host that receives the requests.\n- **Listener**: Listener is a named network address (for example, port, UNIX domain socket, etc.); downstream clients can connect to these listeners. Envoy exposes one or more listeners to the downstream hosts to connect.\n- **Cluster**: A cluster is a group of logically identical upstream hosts to which Envoy connects. Envoy discovers the members of a cluster through service discovery. Optionally, the health status of cluster members can be determined through proactive health checks. Envoy decides which member of the cluster to route requests through a load balancing policy.\n\nMultiple listeners can be set in Envoy, each listener can set a filter chain (filter chain table), and the filter is scalable so that we can more easily manipulate the behavior of traffic — such as setting encryption, private RPC, etc.\n\nThe xDS protocol was proposed by Envoy and is the default sidecar proxy in Istio, but as long as the xDS protocol is implemented, it can theoretically be used as a sidecar proxy in Istio — such as the [MOSN](https:\/\/github.com\/mosn\/mosn) open source by Ant Group.\n\n[008eGmZEly1gpb7kk7wk4j31060lqgqx.jpg)](https:\/\/cdn.thenewstack.io\/media\/2021\/03\/b800bf17-image3.png)\n\nIstio is a very feature-rich service mesh that includes the following capabilities.\n\n- Traffic Management: This is the most basic feature of Istio.\n- Policy Control: Enables access control systems, telemetry capture, quota management, billing, etc.\n- Observability: Implemented in the sidecar proxy.\n- Security Authentication: The Citadel component does key and certificate management.\n\n## Traffic Management in Istio\n\nThe following CRDs are defined in Istio to help users with traffic management.\n\n- Gateway: Gateway describes a load balancer that runs at the edge of the network and is used to receive incoming or outgoing HTTP\/TCP connections.\n- VirtualService: VirtualService actually connects the Kubernetes service to the Istio Gateway. It can also perform additional operations, such as defining a set of traffic routing rules to be applied when a host is addressed.\n- DestinationRule: The policy defined by the DestinationRule determines the access policy for the traffic after it has been routed. Simply put, it defines how traffic is routed. Among others, these policies can be defined as load balancing configurations, connection pool sizes, and external detection (for identifying and expelling unhealthy hosts in the load balancing pool) configurations.\n- EnvoyFilter: The EnvoyFilter object describes filters for proxy services that can customize the proxy configuration generated by Istio Pilot. This configuration is generally rarely used by primary users.\n- ServiceEntry: By default, services in the Istio service mesh are unable to discover services outside of the Mesh. ServiceEntry enables additional entries to be added to the service registry inside Istio, thus allowing automatically discovered services in the mesh to access and route to these manually added services.\n\n## Kubernetes vs. xDS vs. Istio\n\nHaving reviewed the abstraction of traffic management in Kubernetes’ kube-proxy component, xDS, and Istio, let’s look now at a comparison of the three components\/protocols in terms of traffic management only (note that the three are not exactly equivalent).\n\n| **Kubernetes** | **xDS**  | **Istio service mesh** |\n| -------------- | -------- | ---------------------- |\n| Endpoint       | Endpoint | WorkloadEntry          |\n| Service        | Route    | VirtualService         |\n| kube-proxy     | Route    | DestinationRule        |\n| kube-proxy     | Listener | EnvoyFilter            |\n| Ingress        | Listener | Gateway                |\n| Service        | Cluster  | ServiceEntry           |\n\n## Takeaways\n\n- The essence of Kubernetes is application lifecycle management, specifically deployment and management (scaling up and down, auto-recovery, release).\n- Kubernetes provides a scalable and highly resilient deployment and management platform for microservices.\n- A service mesh is based on transparent proxies that intercept traffic between services through sidecar proxies, and then manage the behavior of them through control plane configuration.\n- A service mesh decouples traffic management from Kubernetes, eliminating the need for a kube-proxy component to support traffic within service mesh; and managing inter-service traffic, security and observability by providing an abstraction closer to the microservice application layer.\n- xDS is one of the protocol standards for service mesh configuration.\n- A service mesh is a higher-level abstraction of service in Kubernetes.\n\n## Summary\n\nIf the object managed by Kubernetes is a pod, then the object managed in service mesh is a service, so it’s just a matter of using Kubernetes to manage microservices and then applying service mesh. If you don’t even want to manage a service, then use a serverless platform like [Knative](https:\/\/knative.dev\/) — but that’s an afterthought.\n', '\/en\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will take you through the inner workings of Kubernetes and Istio. In addition, I will introduce the load balancing approach in Kubernetes, and explain why you need Istio when you have Kubernetes.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-you-should-choose-ngac-as-your-access-control-model/">Why You Should Choose NGAC as Your Access Control Model</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Feb 20, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why You Should Choose NGAC as Your Access Control Model', 'This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.', '\nDifferent companies or software providers have devised countless ways to control user access to functions or resources, such as Discretionary Access Control (DAC), Mandatory Access Control (MAC), Role-Based Access Control (RBAC), and Attribute-Based Access Control (ABAC). In essence, whatever the type of access control model, three basic elements can be abstracted: user, system\/application, and policy.\n\nIn this article, we will introduce ABAC, RBAC, and a new access control model — Next Generation Access Control (NGAC) — and compare the similarities and differences between the three, as well as why you should consider NGAC.\n\n## What Is RBAC?\n\nRBAC, or Role-Based Access Control, takes an approach whereby users are granted (or denied) access to resources based on their role in the organization. Every role is assigned a collection of permissions and restrictions, which is great because you don’t need to keep track of every system user and their attributes. You just need to update appropriate roles, assign roles to users, or remove assignments. But this can be difficult to manage and scale. Enterprises that use the RBAC static role-based model have experienced role explosion: large companies may have tens of thousands of similar but distinct roles or users whose roles change over time, making it difficult to track roles or audit unneeded permissions. RBAC has fixed access rights, with no provision for ephemeral permissions or for considering attributes like location, time, or device. Enterprises using RBAC have had difficulty meeting the complex access control requirements to meet regulatory requirements of other organizational needs.\n\n### RBAC Example\n\nHere’s an example Role in the “default” namespace in Kubernetes that can be used to grant read access to pods:\n\n\u0060\u0060\u0060yaml\napiVersion: rbac.authorization.k8s.io\/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n- apiGroups: [\u0022v1\u0022]\n  resources: [\u0022pods\u0022]\n  verbs: [\u0022get\u0022, \u0022watch\u0022, \u0022list\u0022]\n\u0060\u0060\u0060\n\n## What Is ABAC?\n\nABAC stands for Attribute-Based Access Control. At a high level, [NIST defines](https:\/\/www.nist.gov\/publications\/guide-attribute-based-access-control-abac-definition-and-considerations-1) ABAC as an access control method “where subject requests to perform operations on objects are granted or denied based on assigned attributes of the subject, environment conditions, and a set of policies that are specified in terms of those attributes and conditions.” ABAC is a fine-grained model since you can assign any attributes to the user, but at the same time it becomes a burden and hard to manage:\n\n1. When defining permissions, the relationship between users and objects cannot be visualized.\n2. If the rules are a little complex or confusingly designed, it will be troublesome for the administrator to maintain and trace.\n\nThis can cause performance problems when there is a large number of permissions to process.\n\n### ABAC Example\n\nKubernetes initially uses ABAC as access control and is configured via JSON Lines, for example:\n\nAlice can just read pods in namespace “foo”:\n\n\u0060\u0060\u0060json\n {\u0022apiVersion\u0022: \u0022abac.authorization.kubernetes.io\/v1beta1\u0022, \u0022kind\u0022: \u0022Policy\u0022, \u0022spec\u0022: {\u0022user\u0022: \u0022alice\u0022, \u0022namespace\u0022: \u0022foo\u0022, \u0022resource\u0022: \u0022pods\u0022, \u0022readonly\u0022: true}}\n\u0060\u0060\u0060\n\n## What Is NGAC?\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying users administrative capabilities with a high level of granularity. NGAC was developed by [NIST](https:\/\/www.nist.gov\/) (National Institute of Standards and Technology) and is currently used in [Tetrate Q](https:\/\/www.tetrate.io\/blog\/introducing-tetrate-q\/) and [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/).\n\nThere are several types of entities; they represent the resources you want to protect, the relationships between them, and the actors that interact with the system. The entities are:\n\n1. Users\n2. Objects\n3. User attributes, such as organization unit\n4. Object attributes, such as folders\n5. Policy classes, such as file system access, location, and time\n\nNIST’s David Ferraiolo and [Tetrate](https:\/\/www.tetrate.io\/?utm_content=inline-mention)‘s Ignasi Barrera shared how NGAC works at their [presentation](https:\/\/www.tetrate.io\/blog\/unpacking-next-generation-access-control-ngac-and-tetrate-q\/) on Next Generation Access Control at Service Mesh Day 2019 in San Francisco.\n\nNGAC is based on the assumption that you can represent the system you want to protect in a graph that represents the resources you want to protect and your organizational structure, in a way that has meaning to you and that adheres to your organization semantics. On top of this model that is very particular to your organization, you can overlay policies. Between the resource model and the user model, the permissions are defined. This way NGAC provides an elegant way of representing the resources you want to protect, the different actors in the system, and how both worlds are tied together with permissions.\n\n![NGAC DAG](008eGmZEly1gpb7y6dffaj30ke0ay0ue.jpg)\n\nImage via [Linear Time Algorithms to Restrict Insider Access using Multi-Policy Access Control Systems](https:\/\/tsapps.nist.gov\/publication\/get_pdf.cfm?pub_id=922390)\n\n### NGAC Example\n\nThe following example shows a simple NGAC graph with a User DAG representing an organization structure, an Object DAG representing files and folders in a filesystem, a categorization of the files, and two different policies — file system and scope — that can be combined to make access decisions. The association edges between the two DAGs define the permissions the actors have on the target resources.\n\n![NGAC](008eGmZEly1gpb7y4v7x3j30lx0f7my9.jpg)\n\nIn this graph we can see a representation of two files, “resume” and “contract” in the “\/hr-docs” folder, each linked to a category (“public\/confidential”). There are also two policy classes, “File System” and “Scope,” where the objects in the graph are attached — these need to be satisfied in order to get access to each file.\n\nUser Allice has read and write access to both files in the example, because a path links Allice to each of the files and the paths grant permissions on both policy classes. However, user Bob only has access to the “resume” file, because although there exists a path from Bob to the “contract” file that satisfies the “File System” policy class with “read” permissions, there is no path granting permissions on the “Scope” policy class. So, access to the “contract” file is denied to Bob.\n\n## Why Choose NGAC?\n\nThe need to keep track of attributes of all objects creates a manageability burden in the case of ABAC. RBAC reduces the burden since we extract all access information to roles, but this paradigm suffers from role explosion problems and can also become unmanageable. With NGAC we have everything we need in graphs — in a compact, centralized fashion.\n\nWhen access decisions are complex, processing times of ABAC can rise exponentially. RBAC becomes especially hard to manage at scale, while NGAC scales linearly.\n\nWhere NGAC really shines is in flexibility. It can be configured to allow or disallow access based not only on object attributes, but also on other conditions — time, location, phase of the moon, and so on.\n\nOther key advantages of NGAC include the ability to set policies consistently (to meet compliance requirements) and the ability to set ephemeral policies. For example, NGAC could grant a developer one-time access to resources during an outage, without leaving unnecessary permissions in place that could later lead to a security breach. NGAC can evaluate and combine multiple policies in a single access decision, while keeping its linear time complexity.\n\n## Summary\n\nThe following table compares ABAC, RBAC, and NGAC in several aspects.\n\n![NGAC vs RBAC vs ABAC](008eGmZEly1gpb7y5ehmej30zs0fw76d.jpg)\n\nIn conclusion:\n\n- RBAC is simpler and has good performance, but can suffer at scale.\n- ABAC is flexible, but performance and auditability are a problem.\n- NGAC fixes those gaps by using a novel, elegant revolutionary approach: overlay access policies on top of an existing representation of the world, provided by the user. You can model RBAC and ABAC policies as well.\n\n## References\n\n- [Guide to Attribute-Based Access Control (ABAC) Definition and Considerations](https:\/\/nvlpubs.nist.gov\/nistpubs\/specialpublications\/NIST.SP.800-162.pdf)\n- Deploying ABAC policies using RBAC Systems\n- [RBAC vs. ABAC: What’s the Difference?](https:\/\/www.comparitech.com\/net-admin\/rbac-vs-abac\/)\n- [Role Explosion: The Unintended Consequence of RBAC](https:\/\/www.linkedin.com\/pulse\/role-explosion-unintended-consequence-rbac-oren-ohayon-harel\/)\n- [Exploring the Next Generation of Access Control Methodologies](https:\/\/www.nist.gov\/publications\/exploring-next-generation-access-control-methodologies)', '\/en\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-vm-odysssey/">Istio 1.8: A Virtual Machine Integration Odyssey</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 23, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8: A Virtual Machine Integration Odyssey', 'In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.', '\nIn this article, I’ll give you an overview of [Istio](https:\/\/istio.io\/)‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.\n\nI will show you a tumultuous odyssey of Istio’s virtual machine integration. Tetrate, the enterprise service mesh company that made pushing Istio to run everywhere part of its founding mission, has used VM features extensively in customer deployments and has been instrumental in pushing VMs to Istio upstream.\n\n## Preface\n\nIn my [previous article](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/), I talked about how Istio 1.7 supported virtual machines. But at that time, late October, virtual machines were still not seamlessly integrated into Istio — there was still a lot of manual work required. Now, Istio 1.8 has added WorkloadGroup and smart DNS proxy, which allows non-Kubernetes workloads like VMs to become first-class citizens in Istio — just like pods.\n\nWith or without a sidecar installed for virtual machines, until 1.7 you could not resolve the DNS name of a Kubernetes service unless a kube-external DNS was configured — which is the last piece of virtual machine integration in Istio. This shortcoming has finally been fixed in Istio 1.8.\n\n## Why Is Virtual Machine Support Important?\n\nIn the process of migrating our applications to cloud native architectures and continuously containerizing them, we will go through three phases as shown in the figure below.\n\n![Cloud Native Stages](0081Kckwly1gm0d6t775lj31s80k8go8.jpg)\n\n- Stage 1: All applications are deployed on virtual machines\n- Stage 2: Applications are deployed on both virtual machines and containers, are migrating from virtual machines to containers, and are using Kubernetes to manage containers.\n- Stage 3: All applications are deployed in containers first, using Kubernetes to manage containers and Istio to manage service-to-service communication.\n\nThe above diagram is artificially simplified: in reality, there might be multiple hybrid clouds, multiple regions, multiple clusters, etc. Plus, at stage 3 containers and virtual machines may remain in long-term coexistence, but the trend of containerization remains unchanged.\n\n## Istio’s History of Virtual Machine Support\n\nIstio’s support for virtual machines is a long process, an odyssey of sorts.\n\n### 0.2: Istio Mesh Expansion\n\nAs of version 0.2, Istio added virtual machines to the Mesh via [Istio Mesh Expansion](https:\/\/istio.io\/v0.2\/docs\/setup\/kubernetes\/mesh-expansion.html), provided that the following prerequisites were met.\n\n- Virtual machines must have direct access to the application’s pods via IP address, which requires a flat network between the container and the VM via VPC or VPN; and virtual machines do not need access to the Cluster IP, but rather direct access to the service’s endpoints.\n- Virtual machines must have access to Istio’s control plane services (Pilot, Mixer, CA, now being integrated as Istiod), which can expose the control plane endpoints to virtual machines by deploying load balancers in the Istio Mesh.\n- (optional) the virtual machine has access to the DNS server inside the Mesh (deployed in Kubernetes).\n\nThe steps to integrate a virtual machine are as follows.\n\n1. Create an internal load balancer for the Istio control plane service and the DNS service for the Kubernetes cluster.\n2. Generate a configuration file for the Istio Service CIDR, Service Account token, security certificate, and IP of the Istio Control Plane Service (the IP exposed through the Internal Load Balancer) and send it to the virtual machine.\n3. Setup the Istio component, dnsmaq (for DNS discovery), in the virtual machine; so that the virtual machine can access the services in the mesh using FQDN, to ensure that the virtual machine can correctly resolve the Cluster IP of the services in the mesh.\n4. To run the service in a virtual machine, you need to configure the sidecar, add inbound ports to be intercepted, then restart Istio and also run istioctl to register the service.\n\nThe following figure shows the detailed flow from integrating a virtual machine to accessing services in the virtual machine in a mesh.\n\n![Figure 1](0081Kckwly1gm0d6rogojj30u00yhdil.jpg)\n\nFigure 1\n\n1. The DNS is hijacked by dnsmasq deployed in the virtual machine, which allows it to correctly obtain the Cluster IP of the Istio service (Kubernetes’ built-in DNS).\n2. Access to Kubernetes’ built-in DNS service (which is exposed outside the cluster via the Internal Load Balancer and can be accessed directly).\n3. Return the Cluster IP resolved by \u0060productpage.bookinfo.svc.cluster.local\u0060, noting that the IP address is not directly accessible, but failure to be DNS resolved will result in a failed VM request for the service.\n4. The virtual machine’s call to services in a mesh is hijacked by the sidecar proxy.\n5. Since the proxy is connected to the Istio control plane, the endpoints of the service can be queried via xDS, so traffic will be forwarded to one of the endpoints.\n6. To access VM services in mesh, you need to manually add VM services to mesh using the istioctl register command, which essentially registers the VM services to the service and endpoint in Kubernetes.\n7. Services in the mesh can be accessed using the VM-registered service name (FQDN, e.g. \u0060mysql.vm.svc.cluster.local\u0060).\n\nThe above Istio support for virtual machines continued with Istio 1.0, which introduced a new API [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) with Istio 1.1, that allows additional entries to be added to Istio’s internal service registry so that services in the mesh can access\/route to these manually specified services. The istioctl register command is no longer needed and will be deprecated in Istio 1.9.\n\nThe istioctl experimental add-to-mesh command has been added to Istio 1.5 to add services from a virtual machine to a mesh, and it works just like the istioctl register.\n\n### 1.6 to 1.7: New Resource Abstractions\n\nIstio introduced a new resource type, [WorkloadEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-entry\/), in traffic management from [version 1.6](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/), to abstract virtual machines so that they can be added to the mesh as equivalent loads to the pods in Kubernetes; with traffic management, security management, observability, etc. The mesh configuration process for virtual machines is simplified with WorkloadEntry, which selects multiple workload entries and Kubernetes pods based on the label selector specified in the service entry.\n\nIstio 1.8 adds a resource object for [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) that provides a specification that can include both virtual machines and Kubernetes workloads, designed to mimic the existing sidecar injection and deployment specification model for Kubernetes workloads to bootstrap Istio agents on the VMs.\n\nBelow is a comparison of resource abstraction levels for virtual machines versus workloads in Kubernetes.\n\n| **Item**                           | **Kubernetes** | **Virtual Machine** |\n| ---------------------------------- | -------------- | ------------------- |\n| **Basic schedule unit**            | Pod            | WorkloadEntry       |\n| **Component**                      | Deployment     | WorkloadGroup       |\n| **Service register and discovery** | Service        | ServiceEntry        |\n\nFrom the above diagram, we can see that for virtual machine workloads there is a one-to-one correspondence with the workloads in Kubernetes.\n\nEverything seems perfect at this point. However, exposing the DNS server in the Kubernetes cluster directly is a big [security risk](https:\/\/blog.aquasec.com\/dns-spoofing-kubernetes-clusters), so we usually manually write the domain name and Cluster IP pair of the service the virtual machine needs to access to the local \/etc\/hosts — but this is not practical for a distributed cluster with a large number of nodes.\n\nThe process of accessing the services inside mesh by configuring the local \/etc\/hosts of the virtual machine is shown in the following figure.\n\n![Figure 2](0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg)\n\nFigure 2\n\n1. Registration of services in the virtual machine into the mesh.\n2. Manually write the domain name and Cluster IP pairs of the service to be accessed to the local \/etc\/hosts file in the virtual machine.\n3. Cluster IP where the virtual machine gets access to the service.\n4. The traffic is intercepted by the sidecar proxy and the endpoint address of the service to be accessed is resolved by Envoy.\n5. Access to designated endpoints of the service.\n\nIn Kubernetes, we generally use the Service object for service registration and discovery; each service has a separate DNS name that allows applications to call each other by using the service name. We can use ServiceEntry to register a service in a virtual machine into Istio’s service registry, but a virtual machine cannot access a DNS server in a Kubernetes cluster to get the Cluster IP if the DNS server is not exposed externally to the mesh, which causes the virtual machine to fail to access the services in the mesh. Wouldn’t the problem be solved if we could add a sidecar to the virtual machine that would transparently intercept DNS requests and get the Cluster IP of all services in the mesh, similar to the role of dnsmasq in Figure 1?\n\n### As of Istio 1.8 — Smart DNS Proxy\n\nWith the introduction of smart [DNS proxy](https:\/\/cloudnative.to\/blog\/istio-dns-proxy\/) in Istio 1.8, virtual machines can access services within the mesh without the need to configure \/etc\/hosts, as shown in the following figure.\n\n![Figure 3](0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg)\n\nFigure 3\n\nThe Istio agent on the sidecar will come with a cached DNS proxy dynamically programmed by Istiod. DNS queries from the application are transparently intercepted and served by the Istio proxy in the pod or VM, with the response to DNS query requests, enabling seamless access from the virtual machine to the service mesh.\n\nThe WorkloadGroup and smart DNS proxy introduced in Istio 1.8 provide powerful support for virtual machine workloads, making legacy applications deployed in virtual machines fully equivalent to pods in Kubernetes.\n\n## Summary\n\nIn this odyssey of Istio’s virtual machine support, we can see the gradual realization of unified management of virtual machines and pods — starting with exposing the DNS server in the mesh and setting up dnsmasq in the virtual machine, and ending with using smart DNS proxies and abstracting resources such as \u0060WorkloadEntry\u0060, \u0060WorkloadGroup\u0060 and \u0060ServiceEntry\u0060. This article only focuses on the single cluster situation, which is not enough to be used in real production. We also need to deal with security, multicluster, multitenancy, etc.\n\n## Referenced resources\n\n- [Tetrate Service Bridge — Across all compute bridging Kubernetes clusters, VMs, and bare metal](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Expanding into New Frontiers — Smart DNS Proxying in Istio](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Virtual Machine Installation — Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- [How to Integrate Virtual Machines into Istio Service Mesh](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)\n', '\/en\/blog\/istio-vm-odysssey\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-a-service-mesh/">What Is a Service Mesh?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 22, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What Is a Service Mesh?', 'This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.', '\nA service mesh is a relatively simple concept, consisting of a bunch of network proxies paired with each service in an application, plus a set of task management processes. The proxies are called the data plane and the management processes are called the control plane in the Service Mesh. The data plane intercepts calls between different services and “processes” them; the control plane is the brain of the mesh that coordinates the behavior of proxies and provides APIs for operations and maintenance personnel to manipulate and observe the entire network.\n\nThe diagram below shows the architecture of a service mesh.\n\n![Service Mesh Architecture](service-mesh-architecture.png)\n\nFurther, the service mesh is a dedicated infrastructure layer designed to enable reliable, fast, and secure inter-service invocation in microservices architectures. It is not a mesh of “services” but rather a mesh of “proxies” that services can plug into, thus abstracting the network from the application code. In a typical service mesh, these proxies are injected into each service deployment as a sidecar (and also may be deployed at the edge of the mesh). Instead of invoking services directly over the network, services invoke their local sidecar proxy, which in turn manages requests on behalf of the service, pushing the complexities of inter-service communications into a networking layer that can resolve them at scale. The set of interconnected sidecar proxies implements a so-called data plane, while on the other hand the service mesh control plane is used to configure proxies. The infrastructure introduced by a service mesh provides an opportunity, too, to collect metrics about the traffic that is flowing through the application.\n\n## The architecture of a service mesh\n\nThe infrastructure layer of a service mesh is divided into two main parts: the control plane and the data plane.\n\n**Characteristics of the control plane**\n\n- Do not parse packets directly.\n- Communicates with proxies in the control plane to issue policies and configurations.\n- Visualizes network behavior.\n- Typically provides APIs or command-line tools for configuration versioning and management for continuous integration and deployment.\n\n**Characteristics of the data plane**\n\n- Is usually designed with the goal of statelessness (though in practice some data needs to be cached to improve traffic forwarding performance).\n- Directly handles inbound and outbound packets, forwarding, routing, health checking, load balancing, authentication, authentication, generating monitoring data, etc.\n- Is transparent to the application, i.e., can be deployed senselessly.\n\n## Changes brought by the service mesh\n\n**Decoupling of microservice governance from business logic**\n\nA service mesh takes most of the capabilities in the SDK out of the application, disassembles them into separate processes, and deploys them in a sidecar model. By separating service communication and related control functions from the business process and synching them to the infrastructure layer, a service mesh **mostly** decouples them from the business logic, allowing application developers to focus more on the business itself.\n\nNote that the word “mostly” is mentioned here and that the SDK often needs to retain protocol coding and decoding logic, or even a lightweight SDK to implement fine-grained governance and monitoring policies in some scenarios. For example, to implement method-level call distributed tracing, the service mesh requires the business application to implement trace ID passing, and this part of the implementation logic can also be implemented through a lightweight SDK. Therefore, the service mesh is not zero-intrusive from a code level.\n\n**Unified governance of heterogeneous environments**\n\nWith the development of new technologies and staff turnover, there are often applications and services in different languages and frameworks in the same company, and in order to control these services uniformly, the previous practice was to develop a complete set of SDKs for each language and framework, which is very costly to maintain. With a service mesh, multilingual support is much easier by synching the main service governance capabilities to the infrastructure. By providing a very lightweight SDK, and in many cases, not even a separate SDK, it is easy to achieve unified traffic control and monitoring requirements for multiple languages and protocols.\n\n## Features of service mesh\n\nService mesh also has three major technical advantages over traditional microservice frameworks.\n\n**Observability**\n\nBecause the service mesh is a dedicated infrastructure layer through which all inter-service communication passes, it is uniquely positioned in the technology stack to provide uniform telemetry at the service invocation level. This means that all services are monitored as “black boxes.” The service mesh captures route data such as source, destination, protocol, URL, status codes, latency, duration, etc. This is essentially the same data that web server logs can provide, but the service mesh captures this data for all services, not just the web layer of individual services. It is important to note that collecting data is only part of the solution to the observability problem in microservice applications. Storing and analyzing this data needs to be complemented by mechanisms for additional capabilities, which then act as alerts or automatic instance scaling, for example.\n\n**Traffic control**\n\nWith a service mesh, services can be provided with various control capabilities such as intelligent routing (blue-green deployment, canary release, A\/B test), timeout retries, circuit breaking, fault injection, traffic mirroring, etc. These are often features that are not available in traditional microservices frameworks but are critical to the system. For example, the service mesh carries the communication traffic between microservices, so it is possible to test the robustness of the whole application by simulating the failure of some microservices through rules for fault injection in the grid. Since the service mesh is designed to efficiently connect source request calls to their optimal destination service instances, these traffic control features are “destination-oriented.” This is a key feature of the service mesh’s traffic control capabilities.\n\n**Security**\n\nTo some extent, monolithic applications are protected by their single address space. However, once a monolithic application is broken down into multiple microservices, the network becomes a significant attack surface. More services mean more network traffic, which means more opportunities for hackers to attack the information flow. And service mesh provides the capabilities and infrastructure to protect network calls. The security-related benefits of service mesh are in three core areas: authentication of services, encryption of inter-service communications, and enforcement of security-related policies.\n\nService mesh has brought about tremendous change and has strong technical advantages, and has been called the second generation of “microservice architecture.” However, there is no silver bullet in software development. Traditional microservices architecture has many pain points, and service mesh is no exception. It has its limitations.\n\n**Increased complexity**\n\nService mesh introduces sidecar proxies and other components into an already complex, distributed environment, which can greatly increase the overall chain and operational O\u0026M complexity. Ops needs to be more specialized. Adding a service mesh such as Istio to a container orchestrator such as Kubernetes often requires Ops to become an expert in both technologies in order to fully utilize the capabilities of both and to troubleshoot the problems encountered in the environment.\n\n**Latency**\n\nAt the link level, a service mesh is an invasive, complex technology that can add significant latency to system calls. This latency is on the millisecond level, but it can also be intolerable in special business scenarios.\n\n**Platform adaptation**\n\nThe intrusive nature of service mesh forces developers and operators to adapt to highly autonomous platforms and adhere to the platform’s rules.\n\n## The relationship between service mesh and Kubernetes\n\nKubernetes is essentially application lifecycle management, specifically the deployment and management (scaling, auto-recovery, publishing) of containerized applications. Service mesh decouples traffic management from Kubernetes, eliminating the need for a kube-proxy component for internal traffic, and manages inter-service and ingress traffic, security, and observability through an abstraction closer to the microservice application layer. The xDS used by Istio and Envoy is one of the protocol standards for service mesh configuration. \n\nOrganizations that use Kubernetes often turn to a service mesh to address the networking issues that arise with containerization — but notably, a service mesh can work with a legacy or a modern workload, and can be put in place prior to containerization for a faster, safer path to modernization.\n\n## Summary\n\nReaders should look dialectically at the advantages and disadvantages of a service mesh compared with traditional microservices architecture. A service mesh can be a critical part of the evolutionary path of application architecture, from the earliest monolith to distributed, to microservices, containerization, container orchestration, to hybrid workloads and multi-cloud. \n\nLooking ahead, Kubernetes is exploding, and it has become the container orchestration of choice for enterprise greenfield applications. If Kubernetes has completely won the market and the size and complexity of Kubernetes-based applications continue to grow, there will be a tipping point, and service mesh will be necessary to effectively manage these applications. As service mesh technology continues to evolve and the architecture and functionality of its implementation products, such as Istio, continue to be optimized, service mesh will completely replace traditional microservice architectures as the architecture of choice for microservices and transformation to the cloud for enterprises.\n\nThis article was co-authored by Guangming Luo, a member of the ServiceMesher community and the CNC steering community.\n', '\/en\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-1-8-a-smart-dns-proxy-takes-support-for-virtual-machines-a-step-further/">Istio 1.8: A Smart DNS Proxy Takes Support For Virtual Machines A Step Further</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Nov 19, 2020</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8: A Smart DNS Proxy Takes Support For Virtual Machines A Step Further', 'WorkloadGroup is a new API object. It is intended to be used with non-Kubernetes workloads like Virtual Machines and is meant to mimic the existing sidecar injection and deployment specification model used for Kubernetes workloads to bootstrap Istio proxies.', '\n1.8 is the last version of Istio to be released in 2020 and it has the following major updates:\n\n- Supports installation and upgrades using Helm 3.\n- Mixer was officially removed.\n- Added Istio DNS proxy to transparently intercept DNS queries from applications.\n- WorkloadGroup has been added to simplify the integration of virtual machines.\n\nWorkloadGroup is a new API object. It is intended to be used with non-Kubernetes workloads like Virtual Machines and is meant to mimic the existing sidecar injection and deployment specification model used for Kubernetes workloads to bootstrap Istio proxies.\n\n## Installation and Upgrades\n\nIstio starts to officially support the use of [Helm](https:\/\/istio.io\/latest\/docs\/setup\/install\/helm\/) v3 for installations and upgrades. In previous versions, the installation was done with the istioctl command-line tool or Operator. With version 1.8, Istio supports in-place and canary upgrades with Helm.\n\n## Enhancing Istio’s Usability\n\nThe istioctl command-line tool has a new bug reporting feature ([istioctl bug-report](https:\/\/istio.io\/latest\/docs\/reference\/commands\/istioctl\/#istioctl-bug-report)), which can be used to collect debugging information and get cluster status.\n\nThe way to install the [add-on](https:\/\/istio.io\/latest\/blog\/2020\/addon-rework\/) has changed: 1.7 istioctl is no longer recommended and has been removed in 1.8, to help solve the problem of add-on lagging upstream and to make it easier to maintain.\n\nTetrate is an enterprise service mesh company. Our flagship product, TSB, enables customers to bridge their workloads across bare metal, VMs, K8s, \u0026 cloud at the application layer and provide a resilient, feature-rich service mesh fabric powered by Istio, Envoy, and Apache SkyWalking.\n\nMixer, the Istio component that had been responsible for policy controls and telemetry collection, has been removed. Its functionalities are now being served by the Envoy proxies. For extensibility, service mesh experts recommend using [WebAssembly](https:\/\/istio.io\/latest\/blog\/2020\/wasm-announce\/) (Wasm) to extend Envoy; and you can also try the [GetEnvoy Toolkit](https:\/\/www.getenvoy.io\/reference\/getenvoy_extension_toolkit_reference\/), which makes it easier for developers to create Wasm extensions for Envoy. If you still want to use Mixer, you must use version 1.7 or older. Mixer continued receiving bug fixes and security fixes until Istio 1.7. Many features supported by Mixer have alternatives as specified in the [Mixer Deprecation](https:\/\/tinyurl.com\/mixer-deprecation) document, including the [in-proxy extensions](https:\/\/github.com\/istio\/proxy\/tree\/master\/extensions) based on the Wasm sandbox API.\n\n## Support for Virtual Machines\n\nIstio’s recent upgrades have steadily focused on making virtual machines first-class citizens in the mesh. [Istio 1.7 made progress to support virtual machines](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/) and Istio 1.8 adds a [smart DNS proxy](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/), which is an Istio sidecar agent written in Go. The Istio agent on the sidecar will come with a cache that is dynamically programmed by Istiod DNS Proxy. DNS queries from applications are transparently intercepted and served by an Istio proxy in a pod or VM that intelligently responds to DNS query requests, enabling seamless multicluster access from virtual machines to the service mesh.\n\nIstio 1.8 adds a [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/), which describes a collection of workload instances. It provides a specification that the workload instances can use to bootstrap their proxies, including the metadata and identity. It is only intended to be used with non-k8s workloads like Virtual Machines, and is meant to mimic the existing sidecar injection and deployment specification model used for Kubernetes workloads to bootstrap Istio proxies. Using WorkloadGroups, Istio has started to help automate VM registration with [istioctl experimental workload group](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/#create-files-to-transfer-to-the-virtual-machine).\n\n[Tetrate](https:\/\/www.tetrate.io\/), the enterprise service mesh company, uses these [VM features](https:\/\/www.tetrate.io\/blog\/whats-new-in-istio-1-8-dns-proxy-helps-expand-mesh-to-vms-and-multicluster\/) extensively in customers’ multicluster deployments, to enable sidecars to resolve DNS for hosts exposed at ingress gateways of all the clusters in a mesh; and to access them over mutual TLS.\n\n## Conclusion\n\nAll in all, the Istio team has kept the promise made at the beginning of the year to maintain a regular release cadence of one release every three months since the 1.1 release in 2018, with continuous optimizations in performance and user experience for a seamless experience of brownfield and greenfield apps on Istio. We look forward to more progress from Istio in 2021.', '\/en\/blog\/istio-1-8-a-smart-dns-proxy-takes-support-for-virtual-machines-a-step-further\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">WorkloadGroup is a new API object. It is intended to be used with non-Kubernetes workloads like Virtual Machines and is meant to mimic the existing sidecar injection and deployment specification model used for Kubernetes workloads to bootstrap Istio proxies.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/">How to Integrate Virtual Machines Into Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Nov 2, 2020</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Integrate Virtual Machines Into Istio Service Mesh', 'Better integration of virtual machine-based workloads into the service mesh is a major focus for the Istio team this year, and Tetrate also provides seamless multi-cloud connectivity, security and observability, including for virtual machines, through its product Tetrate Service Bridge. This article will show you why Istio needs to integrate with virtual machines and how.', '\n[Istio](https:\/\/istio.io\/) is a popular service mesh to connect, secure, control, and observe services. When it was first introduced as open source in 2017, Kubernetes was winning the container orchestration battle and Istio answered the needs of organizations moving to microservices. Although Istio claims to support heterogeneous environments such as Nomad, Consul, Eureka, Cloud Foundry, Mesos, etc., in reality, it has always worked best with Kubernetes — on which its service discovery is based.\n\nIstio was criticized for a number of issues early in its development, for the large number of components, the complexity of installation and maintenance, the difficulty of debugging, a steep learning curve due to the introduction of too many new concepts and objects (up to 50 CRDs), and the impact of Mixer components on performance. But these issues are gradually being overcome by the Istio team. As you can see from the [roadmap](https:\/\/istio.io\/latest\/zh\/blog\/2020\/tradewinds-2020\/) released in early 2020, Istio has come a long way.\n\nBetter integration of VM-based workloads into the mesh is a major focus for the Istio team this year. Tetrate also offers seamless multicloud connectivity, security, and observability, including for VMs, via its product [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/). This article will take you through why Istio needs to integrate with virtual machines and how you can do so.\n\n## Why Should Istio Support Virtual Machines?\n\nAlthough containers and Kubernetes are now widely used, there are still many services deployed on virtual machines and APIs outside of the Kubernetes cluster that needs to be managed by Istio mesh. It’s a huge challenge to unify the management of the brownfield environment with the greenfield.\n\n## What Is Needed to Add VMs to the Mesh?\n\nBefore the “how,” I’ll describe *what* is needed to add virtual machines to the mesh. There are a couple of things that Istio must know when supporting virtual machine traffic: which VMs have services that should be part of the mesh, and how to reach the VMs. Each VM also needs an identity, in order to communicate securely with the rest of the mesh. These requirements could work with Kubernetes CRDs, as well as a full-blown Service Registry like Consul. And the service account based identity bootstrapping could work as a mechanism for assigning workload identities to VMs that do not have a platform identity. For VMs that do have a platform identity (like EC2, GCP, Azure, etc.), work is underway in Istio to exchange the platform identity with a Kubernetes identity for ease of setting up mTLS communication.\n\n## How Does Istio Support Virtual Machines?\n\nIstio’s support for virtual machines starts with its service registry mechanism. The information about services and instances in the Istio mesh comes from Istio’s service registries, which up to this point have only looked at or tracked pods. In newer versions, Istio now has resource types to track and watch VMs. The sidecars inside the mesh cannot observe and control traffic to services outside the mesh, because they do not have any information about them.\n\nThe Istio community and [Tetrate](https:\/\/www.tetrate.io\/) have done a lot of [work](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/) on Istio’s support for virtual machines. The 1.6 release included the addition of WorkloadEntry, which allows you to describe a VM exactly as you would a host running in Kubernetes. In 1.7, the release started to add the foundations for bootstrapping VMs into the mesh automatically through tokens, with Istio doing the heavy lifting. Istio 1.8 will debut another abstraction called WorkloadGroup, which is similar to a Kubernetes Deployment object — but for VMs.\n\nThe following diagram shows how Istio models services in the mesh. The predominant source of information comes from a platform service registry like Kubernetes, or a system like Consul. In addition, the ServiceEntry serves as a user-defined service registry, modeling services on VMs or external services outside the organization.\n\n![](0081Kckwgy1gkp0fvr3orj30p30ehabc.jpg)\n\n**Why install Istio in a virtual machine when you can just use ServiceEntry to bring in the services in the VMs?**\n\nUsing ServiceEntry, you can enable services inside the mesh to discover and access external services; and in addition, manage the traffic to those external services. In conjunction with VirtualService, you can also configure access rules for the corresponding external service — such as request timeouts, fault injection, etc. — to enable controlled access to the specified external service.\n\nEven so, it only controls the traffic on the client-side, not access to the introduced external service to other services. That is, it cannot control the behavior of the service as the call initiator. Deploying sidecars in a virtual machine and introducing the virtual machine workload via workload selector allows the virtual machine to be managed indiscriminately, like a pod in Kubernetes.\n\n## Future\n\nAs you can see from the bookinfo demo, there is too much manual work involved in the process and it’s easy to go wrong. In the future, Istio will improve VM testing to be realistic, automate bootstrapping based on platform identity, improve DNS support and istioctl debugging, and more. You can follow the [Istio Environment Working Group](https:\/\/github.com\/istio\/community\/blob\/master\/WORKING-GROUPS.md) for more details about virtual machine support.\n\n## References\n\n- [Virtual Machine Installation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- Virtual Machines in Single-Network Meshes\n- [Istio: Bringing VMs into the Mesh (with Cynthia Coan)](https:\/\/www.tetrate.io\/blog\/istio-bringing-vms-into-the-mesh-with-cynthia-coan\/)\n- [Bridging Traditional and Modern Workloads](https:\/\/www.tetrate.io\/blog\/bridging-traditional-and-modern-workloads\/)\n\n', '\/en\/blog\/how-to-integrate-virtual-machines-into-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Better integration of virtual machine-based workloads into the service mesh is a major focus for the Istio team this year, and Tetrate also provides seamless multi-cloud connectivity, security and observability, including for virtual machines, through its product Tetrate Service Bridge. This article will show you why Istio needs to integrate with virtual machines and how.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/moving-on-from-ant-group/">New Beginning - Goodbye Ant, Hello Tetrate</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 31, 2020</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/essays"> 
             Essays
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('New Beginning - Goodbye Ant, Hello Tetrate', 'Today is my last day at Ant and tomorrow I\u0027m starting a new career at Tetrate.', '\nToday is my 914th day and also the last day with [Ant Group](https:\/\/www.antgroup.com\/), tomorrow is September 1st, which is usually the day school starts, and everyone at Alibaba is known as \u0022classmate\u0022, tomorrow I will join [Tetrate]( https:\/\/tetrate.io), and that\u0027s kind of starting my new semester!\n\n## Ant\/Alibaba and the Cloud Native Community\n\nTo date, Ant\/Alibaba Group has had a profound impact on my career, especially its corporate culture and values, and the Alibaba recruiting philosophy of \u0022finding like-minded people\u0022, and isn\u0027t the process of creating the Cloud Native Community also a process of finding like-minded people? [Cloud Native Community](https:\/\/cloudnative.to) is like a small society, I don\u0027t want it to have much social value, but only want it to make a small but beautiful change to individuals, to enterprises and to society. I constantly think about myself as an individual and as an employee, especially as an initiator of the community. What is my mission as an individual, an employee, and especially as an initiator of a community? What role should I play in the company? Where is this community going? I\u0027m fumbling along, but because of your support, it makes me stronger and more committed to the adoption and application of cloud native technology in China, outside of me I may have gone faster, but now with the community together we will go further!\n\n![24 June 2019, Shanghai, KubeCon China 2019](20190624.jpg)\n*June 24, 2019, Shanghai, KubeCon China 2019*\n\n## Joining Tetrate\n\nOver the past two years, I\u0027ve been working hard to promote Istio and Service Mesh technology, and with funding from Ant Group, I started the ServiceMesher Community to bring Service Mesh technology to China. Next I want to bring Chinese practice to the world.\n\nAs a Developer Advocate, the most important thing is not to stop learning, but to listen and take stock. Over the past two years, I\u0027ve seen a lot of people show interest in Service Mesh, but not enough to understand the risks and lack of knowledge about the new technology. I\u0027m excited to join this Service Mesh-focused startup [Tetrate](https:\/\/tetrate.io), a global telecommuting startup with products built around open source [Istio](https:\/\/istio.io), [Envoy](https:\/ \/envoyproxy.io) and [Apache SkyWalking](https:\/\/skywalking.apache.org\/), it aims to make it to be the cloud native network infrastructure. Here are several maintainers of these open source projects, such as [Sheng Wu](https:\/\/twitter.com\/wusheng1108), [Zack Butcher](https:\/\/twitter.com\/ZackButcher), [Lizan Zhou](https:\/\/twitter.com\/zlizan), etc., and I believe that working with them can help you understand and apply Service Mesh quickly and effectively across cloud native.\n\n## More\n\nEarlier this year as I was preparing for the Cloud Native community, I set the course for the next three years - cloud native, open source and community. The road to pursue my dream is full of thorns, not only need courage and perseverance, but also need you to be my strong backing, I will overcome the thorns and move forward. Open source belongs to the world, to let the world understand us better, we must be more active into the world. I hope that China\u0027s open source tomorrow will be better, I hope that Service Mesh technology will be better applied by the enterprises in China, I hope that cloud native can benefit the public, and I hope that we can all find our own mission. \n\nWe are hiring now, if you are interested with [Tetrate](\/en\/job\/tetrate), please send your resume to [careers@tetrate.io](mailto:careers@tetrate.io).\n', '\/en\/blog\/moving-on-from-ant-group\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Today is my last day at Ant and tomorrow I&#39;m starting a new career at Tetrate.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-the-microservices-in-post-kubernetes-era/">Service Mesh - The Microservices in Post Kubernetes Era</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Apr 1, 2020</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh - The Microservices in Post Kubernetes Era', 'This article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.', '\nThis article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.\n\nPeople who have just heard of Service Mesh and tried [Istio](https:\/\/istio.io\/) may have the following questions:\n\n1. Why does Istio bind Kubernetes?\n1. What roles do Kubernetes and Service Mesh play in cloud native?\n1. What aspects of Kubernetes has Istio extended? What problems have been solved?\n1. What is the relationship between Kubernetes, xDS protocols ([Envoy](https:\/\/github.com\/envoyproxy\/envoy) , [MOSN,](https:\/\/github.com\/mosn\/mosn) etc) and Istio?\n1. Should I use Service Mesh?\n\nIn this section, we will try to guide you through the internal connections between Kubernetes, the xDS protocol, and Istio Service Mesh. In addition, this section will also introduce the load balancing methods in Kubernetes, the significance of the xDS protocol for Service Mesh, and why Istio is needed in time for Kubernetes.\n\nUsing Service Mesh is not to say that it will break with Kubernetes, but that it will happen naturally. The essence of Kubernetes is to perform application lifecycle management through declarative configuration, while the essence of Service Mesh is to provide traffic and security management and observability between applications. If you have built a stable microservice platform using Kubernetes, how do you set up load balancing and flow control for calls between services?\n\nThe xDS protocol created by Envoy is supported by many open source software, such as [Istio](https:\/\/github.com\/istio\/istio) , [Linkerd](https:\/\/linkerd.io\/) , [MOSN,](https:\/\/github.com\/mosn\/mosn) etc. Envoy\u0027s biggest contribution to Service Mesh or cloud native is the definition of xDS. Envoy is essentially a proxy. It is a modern version of proxy that can be configured through APIs. Based on it, many different usage scenarios are derived, such as API Gateway, Service Mesh. Sidecar proxy and Edge proxy in.\n\n**This section contains the following**\n\n- Explain the role of kube-proxy.\n- Kubernetes\u0027 limitations in microservice management.\n- Describe the features of Istio Service Mesh.\n- Describe what xDS includes.\n- Compare some concepts in Kubernetes, Envoy and Istio Service Mesh.\n\n## Key takeaways\n\nIf you want to know everything in advance, here are some of the key points from this article:\n\n- The essence of Kubernetes is application lifecycle management, specifically deployment and management (scaling, scaling, automatic recovery, release).\n- Kubernetes provides a scalable and highly resilient deployment and management platform for microservices.\n- The foundation of Service Mesh is a transparent proxy. After the traffic between microservices is intercepted through sidecar proxy, the behavior of microservices is managed through the control plane configuration.\n- Service Mesh decoupled from Kubernetes traffic management, the internal flow without the need of Service Mesh \u0060kube-proxy \u0060supporting components, micro-services closer to abstract the application layer by, for traffic between management services, security and observability.\n- xDS defines the protocol standards for Service Mesh configuration.\n- Service Mesh is a higher-level abstraction of services in Kubernetes. Its next step is serverless.\n\n## Kubernetes vs Service Mesh\n\nThe following figure shows the service access relationship between Kubernetes and Service Mesh (one sidecar per pod mode).\n\n![kubernetes vs service mesh](kubernetes-vs-service-mesh.png)\n\n**Traffic forwarding**\n\nEach node of the cluster Kubernetes a deployed \u0060kube-proxy\u0060 assembly Kubernetes API Server may communicate with the cluster acquired service information, and then set iptables rules, sends a request for a service directly to the corresponding Endpoint (belonging to the same group service pod).\n\n**Service discovery**\n\n![Service registration in Service Mesh](istio-service-registry.png)\n\nIstio Service Mesh can use the service in Kubernetes for service registration. It can also connect to other service discovery systems through the platform adapter of the control plane, and then generate the configuration of the data plane (using CRD statements, stored in etcd), a **transparent proxy** for the data plane. (Transparent proxy) is deployed in the sidecar container in each application service pod. These proxy need to request the control plane to synchronize the proxy configuration. The reason why is a transparent proxy, because there is no application container fully aware agent, the process kube-proxy components like the need to block traffic, but \u0060kube-proxy\u0060that blocks traffic to Kubernetes node and sidecar proxy that blocks out of the Pod For more information, see [Understanding Route Forwarding by the Envoy Sidecar Proxy in Istio Service Mesh](\/en\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/) .\n\n**Disadvantages of Service Mesh**\n\nBecause each node on Kubernetes many runs Pod, the original \u0060kube-proxy\u0060routing forwarding placed in each pod, the distribution will lead to a lot of configuration, synchronization, and eventual consistency problems. In order to perform fine-grained traffic management, a series of new abstractions will be added, which will further increase the user\u0027s learning costs. However, with the popularization of technology, this situation will gradually ease.\n\n**Advantages of Service Mesh**\n\n\u0060kube-proxy\u0060 The settings are globally effective, and fine-grained control of each service cannot be performed. Service Mesh uses sidecar proxy to extract the control of traffic in Kubernetes from the service layer, which can be further expanded.\n\n## kube-proxy component\n\nIn Kubernetes cluster, each Node to run a \u0060kube-proxy \u0060 process. \u0060kube-proxy\u0060 Responsible for the \u0060Service\u0060 realization of a VIP (virtual IP) form. In Kubernetes v1.0, the proxy is implemented entirely in userspace. Kubernetes v1.1 adds the iptables proxy mode, but it is not the default operating mode. As of Kubernetes v1.2, the iptables proxy is used by default. In Kubernetes v1.8.0-beta.0, the ipvs proxy mode was added. More about kube-proxy component description please refer to kubernetes Description: service and kube-proxy principle and use IPVS achieve Kubernetes inlet flow load balancing.\n\n### kube-proxy flaws\n\nThe disadvantages of kube-proxy :\n\n\u003e First, if forwarded pod can not provide normal service, it does not automatically try another pod, of course, this can \u0060liveness probes\u0060 be solved. Each pod has a health check mechanism. When there is a problem with the health of the pod, kube-proxy will delete the corresponding forwarding rule. In addition, \u0060nodePort\u0060types of services cannot add TLS or more sophisticated message routing mechanisms.\n\nKube-proxy implements load balancing of traffic among multiple pod instances of the Kubernetes service, but how to fine-grained control the traffic between these services, such as dividing the traffic into different application versions by percentage (these applications belong to the same service , But on a different deployment), do canary release and blue-green release? Kubernetes community gives the [method using the Deployment do canary release](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments) , essentially by modifying the pod of the method label different pod to be classified into the Deployment of Service.\n\n## Kubernetes Ingress vs. Istio Gateway\n\nSpeaking above \u0060kube-proxy\u0060the flow inside the only route Kubernetes clusters, and we know that Pod Kubernetes cluster located CNI outside the network created, external cluster is unable to communicate directly with, so Kubernetes created in the ingress of this resource object, which is located by the Kubernetes edge nodes (such nodes can be many or a group) are driven by the Ingress controller, which is responsible for managing **north-south traffic** . Ingress must be [connected to](https:\/\/traefik.io\/) various ingress controllers, such as [nginx ingress controller](https:\/\/github.com\/kubernetes\/ingress-nginx) and [traefik](https:\/\/traefik.io\/) . Ingress is only applicable to HTTP traffic, and its usage is also very simple. It can only route traffic by matching limited fields such as service, port, and HTTP path, which makes it unable to route TCP traffic such as MySQL, Redis, and various private RPCs. To directly route north-south traffic, you can only use Service\u0027s LoadBalancer or NodePort. The former requires cloud vendor support, while the latter requires additional port management. Some Ingress controllers support exposing TCP and UDP services, but they can only be exposed using Services. Ingress itself does not support it, such as the nginx ingress controller . The exposed port of the service is configured by creating a ConfigMap.\n\nIstio Gateway is similar to Kubernetes Ingress in that it is responsible for north-south traffic to the cluster. \u0060Gateway\u0060The load balancer described by Istio is used to carry connections in and out of the edge of the mesh. The specification describes a series of open ports and the protocols used by these ports, SNI configuration for load balancing, and so on. Gateway is a CRD extension. It also [reuses](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) the capability of sidecar proxy. For detailed configuration, please refer to [Istio official website](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) .\n\n## xDS protocol\n\nYou may have seen the following picture when you understand Service Mesh. Each block represents an instance of a service, such as a Pod in Kubernetes (which contains a sidecar proxy). The xDS protocol controls all traffic in Istio Service Mesh. The specific behavior is to link the squares in the figure below.\n\n![Service Mesh diagram](service-mesh-schematic-diagram.png)\n\nThe xDS protocol was proposed by [Envoy](https:\/\/envoyproxy.io\/) . The original xDS protocols in the Envoy v2 API refer to CDS (Cluster Discovery Service), EDS (Endpoint Discovery Service), LDS (Listener Discovery Service), and RDS (Route Discovery Service). Later, in the v3 version, Scoped Route Discovery Service (SRDS), Virtual Host Discovery Service (VHDS), Secret Discovery Service (SDS), and Runtime Discovery Service (RTDS) were developed. See the [xDS REST and gRPC protocol for](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol) details .\n\nLet\u0027s take a look at the xDS protocol with a service with two instances each.\n\n![xDS protocol](00831rSTly1gde7ydng3ij30s80j4aba.jpg)\n\nThe arrow in the figure above is not the path or route after the traffic enters the proxy, nor is it the actual sequence. It is an imagined xDS interface processing sequence. In fact, there are cross references between xDS.\n\nAgents that support the xDS protocol dynamically discover resources by querying files or managing servers. In summary, the corresponding discovery service and its corresponding API are called  xDS. Envoy by **subscription (subscription)** to get the resources the way, there are three ways to subscribe:\n\n- **File subscription** : Monitor files in the specified path, the easiest way to find dynamic resource is to save it in a file and path configuration in ConfigSource the \u0060path\u0060parameter.\n- **gRPC streaming subscription** : Each xDS API can be individually configured \u0060ApiConfigSource\u0060to point to the cluster address of the corresponding upstream management server.\n- **Polling REST-JSON polling subscription** : A single xDS API can perform synchronous (long) polling of REST endpoints.\n\nFor details of the above xDS subscription methods, please refer to the xDS protocol analysis . Istio uses gRPC streaming subscriptions to configure sidecar proxy for all data planes.\n\nThe article introduces the overall architecture of the Istio pilot, the generation of proxy configuration, the function of the pilot-discovery module, and the CDS, EDS, and ADS in the xDS protocol. For details on ADS, please refer to the official Envoy documentation .\n\n### xDS protocol highlights\n\nFinally, summarize the main points about the xDS protocol:\n\n- CDS, EDS, LDS, and RDS are the most basic xDS protocols, and they can be updated independently.\n- All Discovery Services can connect to different Management Servers, which means that there can be multiple servers managing xDS.\n- Envoy has made a series of extensions based on the original xDS protocol, adding SDS (Key Discovery Service), ADS (Aggregated Discovery Service), HDS (Health Discovery Service), MS (Metric Service), RLS (Rate Limiting Service) Wait for the API.\n- To ensure data consistency, if used directly xDS original API, it needs to ensure that such sequential update: CDS -\u003e EDS -\u003e LDS -\u003e RDS, which is to follow the electronic engineering **before-break** (Make-Before-Break) The principle is to establish a new connection before disconnecting the original connection. The application in routing is to prevent the situation where the upstream cluster cannot be found and the traffic is dropped when a new routing rule is set, similar to the circuit Open circuit.\n- CDS sets which services are in the service mesh.\n- EDS sets which instances (Endpoints) belong to these services (Cluster).\n- LDS sets the listening port on the instance to configure routing.\n- The routing relationship between RDS final services should ensure that RDS is updated last.\n\n## Envoy\n\nEnvoy is the default sidecar in Istio Service Mesh. Based on Envoy, Istio has extended its control plane in accordance with Envoy\u0027s xDS protocol. Before talking about the Envoy xDS protocol, we need to be familiar with the basic terms of Envoy. The following lists the basic terms and data structure analysis in Envoy. For a detailed introduction to Envoy , please refer to the official Envoy document . As for how Envoy works as a forwarding proxy in Service Mesh (not limited to Istio), please refer to [understanding Istio Service Mesh Envoy agent in Sidecar injection and traffic hijacking](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/) , in which the article refers to some of the points, the details will not be repeated.\n\n![Envoy proxy architecture diagram](envoy-arch.png)\n\n### Basic terminology\n\nHere are the basic terms in Envoy you should know:\n\n- **Downstream** : The downstream host connects to Envoy, sends a request and receives a response, that is, the host sending the request.\n- **Upstream** : The upstream host receives the connection and request from Envoy and returns a response, that is, the host that accepted the request.\n- **Listener** : The listener is a named network address (for example, port, unix domain socket, etc.), and downstream clients can connect to these listeners. Envoy exposes one or more listeners to connect to downstream hosts.\n- **Cluster** : A cluster is a group of logically identical upstream hosts connected to Envoy. Envoy discovers members of the cluster through service discovery. You can choose to determine the health status of cluster members through active health checks. Envoy uses load balancing policies to decide which member of the cluster to route requests to.\n\nEnvoy can set multiple Listeners, and each Listener can also set a filter chain, and the filters are extensible, which can make it easier for us to manipulate traffic behavior, such as setting encryption, private RPC, and so on.\n\nThe xDS protocol was proposed by Envoy and is now the default sidecar proxy in Istio. However, as long as the xDS protocol is implemented, it can theoretically be used as a sidecar proxy in Istio, such as the open source proxy [MOSN](https:\/\/github.com\/mosn\/mosn) by [Ant Group](https:\/\/www.antfin.com) .\n\n## Istio Service Mesh\n\n![Istio service mesh architecture diagram](istio-mesh-arch.png)\n\nIstio is a very feature-rich Service Mesh, which includes the following functions:\n\n- Traffic Management: This is the most basic feature of Istio.\n- Policy control: Implemented through Mixer components and various adapters to implement access control systems, telemetry capture, quota management, and billing.\n- Observability: Achieved through Mixer.\n- Security certification: Citadel components do key and certificate management.\n\n### Traffic Management in Istio\n\nIstio defined as the CRD to help users perform traffic management:\n\n- **Gateway** : [Gateway](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) describes a load balancer running at the edge of the network for receiving incoming or outgoing HTTP \/ TCP connections.\n- **VirtualService** : [VirtualService](https:\/\/istio.io\/docs\/reference\/config\/networking\/virtual-service\/) actually connects Kubernetes services to Istio Gateway. It can also do more, such as defining a set of traffic routing rules to apply when a host is addressed.\n- **DestinationRule** : [\u0060DestinationRule\u0060](https:\/\/istio.io\/zh\/docs\/reference\/config\/networking\/destination-rule\/)The defined policy determines the access policy of the traffic after routing processing. Simply put, it defines how the traffic is routed. These policies can define load balancing configurations, connection pool sizes, and external detection (used to identify and evict unhealthy hosts in a load balancing pool) configuration.\n- **EnvoyFilter** : The [\u0060EnvoyFilter\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/envoy-filter\/)object describes filters for proxy services that can customize the proxy configuration generated by Istio Pilot. This configuration is rarely used by beginning users.\n- **ServiceEntry** : By default, services in Istio Service Mesh cannot discover services outside Mesh. It [\u0060ServiceEntry\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/service-entry\/)can add additional entries to the service registry inside Istio, so that services automatically discovered in the mesh can access and route to these manual Joined services.\n\n## Kubernetes vs xDS vs Istio\n\nAfter the reading of the above Kubernetes \u0060kube-proxy\u0060after abstraction component, and XDS Istio in traffic management, we will take you far as the traffic management aspect of comparison components corresponding to the three \/ protocol (note, not completely three equivalents).\n\n| Governors  | xDS      | Istio Service Mesh |\n| ---------- | -------- | ------------------ |\n| Endpoint   | Endpoint | -                  |\n| Service    | Route    | VirtualService     |\n| kube-proxy | Route    | DestinationRule    |\n| kube-proxy | Listener | EnvoyFilter        |\n| Ingress    | Listener | Gateway            |\n| Service    | Cluster  | ServiceEntry       |\n\n## Conclusion\n\nIf you say that the objects managed by Kubernetes are Pods, then the objects managed by Service Mesh are Service. Therefore, it is a natural thing to apply Service Mesh after using Kubernetes to manage microservices. If you do n’t want to manage even the Service, use [serverless](https:\/\/github.com\/knative\/) platforms like knative, but that\u0027s what comes next.\n\nThe function of Envoy\/MOSN is not just for traffic forwarding. The above concepts are just the tip of the iceberg in Istio\u0027s new layer of abstraction over Kubernetes. This will be the beginning of the book.\n', '\/en\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/cloud-native-sandbox/">Cloud Native Sandbox</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 18, 2019</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/open-source"> 
             Open Source
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Cloud Native Sandbox', 'A standalone Kubernetes and Istio environment with Docker on you own laptop', '\nGithub: https:\/\/github.com\/rootsongjc\/cloud-native-sandbox\n\nCloud Native Sandbox can help you setup a standalone Kubernetes and istio environment with Docker on you own laptop.\n\nThe sandbox integrated with the following components:\n\n- Kubernetes v1.10.3\n- Istio v1.0.4\n- Kubernetes dashboard v1.8.3\n\n## Differences with kubernetes-vagrant-centos-cluster\n\nAs I have created the [kubernetes-vagrant-centos-cluster](https:\/\/github.com\/rootsongjc\/kubernetes-vagrant-centos-cluster) to set up a Kubernetes cluster and istio service mesh with \u0060vagrantfile\u0060 which consists of 1 master(also as node) and 3 nodes, but there is a big problem that it is so high weight and consume resources. So I made this light weight sandbox.\n\n**Features**\n\n- No VirtualBox or Vagrantfile  required\n- Light weight\n- High speed, low drag\n- Easy to operate\n\n## Prerequisite\n\nYou only need a laptop with Docker Desktop installed and [Kubernetes enabled](https:\/\/docs.docker.com\/docker-for-mac\/#kubernetes).\n\nNote: Leave enough resources for Docker Desktop. At least 2 CPU, 4G memory.\n\n## Install\n\nTo start the sandbox, you have to run the following steps. \n\n### Kubernetes dashboard(Optional)\n\nInstall Kubernetes dashboard.\n\n\u0060\u0060\u0060bash\nkubectl apply -f install\/dashbaord\/\n\u0060\u0060\u0060\n\nGet the dashboard token.\n\n\u0060\u0060\u0060bash\nkubectl -n kube-system describe secret default| awk \u0027$1==\u0022token:\u0022{print $2}\u0027\n\u0060\u0060\u0060\n\nExpose \u0060kubernetes-dashboard\u0060 service.\n\n\u0060\u0060\u0060bash\nkubectl -n kube-system get pod -l k8s-app=kubernetes-dashboard -o jsonpath=\u0027{.items[0].metadata.name}\u0027\n\u0060\u0060\u0060\n\nLogin to Kubernetes dashboard on \u003chttp:\/\/localhost:8001\/api\/v1\/namespaces\/kube-system\/services\/https:kubernetes-dashboard:\/proxy\/#!\/login\u003e with the above token.\n\n### Istio(Required)\n\nInstall istio service mesh with the default add-ons.\n\n\u0060\u0060\u0060bash\n# Install istio\nkubectl apply -f install\/istio\/\n\u0060\u0060\u0060\n\nTo expose service \u0060grafana\u0060 on \u003chttp:\/\/localhost:3000\u003e.\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath=\u0027{.items[0].metadata.name}\u0027) 3000:3000 \u0026\n\u0060\u0060\u0060\n\nTo expose service \u0060prometheus\u0060 on \u003chttp:\/\/localhost:9090\u003e.\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath=\u0027{.items[0].metadata.name}\u0027) 9090:9090 \u0026\n\u0060\u0060\u0060\n\nTo expose service \u0060jaeger\u0060 on \u003chttp:\/\/localhost:16686\u003e.\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=jaeger -o jsonpath=\u0027{.items[0].metadata.name}\u0027) 16686:16686 \u0026\n\u0060\u0060\u0060\n\nTo expose service \u0060servicegraph\u0060 on \u003chttp:\/\/localhost:8088\/dotviz\u003e, \u003chttp:\/\/localhost:8088\/force\/forcegraph.html\u003e.\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=servicegraph -o jsonpath=\u0027{.items[0].metadata.name}\u0027) 8088:8088 \u0026\n\u0060\u0060\u0060\n\n### Kiali\n\nInstall [kiali](https:\/\/www.kiali.io\/).\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system apply -f install\/kiali\n\u0060\u0060\u0060\n\nTo expose service \u0060kiali\u0060 on \u003chttp:\/\/localhost:20001\u003e.\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=kiali -o jsonpath=\u0027{.items[0].metadata.name}\u0027) 20001:20001 \u0026\n\u0060\u0060\u0060\n\n## Bookinfo sample\n\nDeploy [bookinfo sample](https:\/\/istio.io\/docs\/examples\/bookinfo\/).\n\n\u0060\u0060\u0060bash\n# Enable sidecar auto injection\nkubectl label namespace default istio-injection=enabled\n# Deploy bookinfo sample\nkubectl -n default apply -f sample\/bookinfo\n\u0060\u0060\u0060\n\nVisit \u0060productpage\u0060 on \u003chttp:\/\/localhost\/productpage\u003e.\n\nLet\u0027s generate some loads.\n\n\u0060\u0060\u0060bash\nfor ((i=0;i\u003c1000;i=i\u002b1));do echo \u0022Step-\u003e$i\u0022;curl http:\/\/localhost\/productpage;done\n\u0060\u0060\u0060\n\nYou can watch the service status through \u003chttp:\/\/localhost:3000\u003e.\n\n## Client tools\n\nTo operate the applications on Kubernetes, you should install the following tools.\n\n**Required**\n\n- [kubectl](https:\/\/kubernetes.io\/docs\/tasks\/tools\/install-kubectl\/) - Deploy and manage applications on Kubernetes.\n- [istioctl](https:\/\/istio.io\/docs\/reference\/commands\/istioctl\/) - Istio configuration command line utility.\n\n**Optional**\n\n- [kubectx](https:\/\/github.com\/ahmetb\/kubectx)  - Switch faster between clusters and namespaces in kubectl\n- [kube-ps1](https:\/\/github.com\/jonmosco\/kube-ps1) - Kubernetes prompt info for bash and zsh\n', '\/en\/blog\/cloud-native-sandbox\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A standalone Kubernetes and Istio environment with Docker on you own laptop</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh/">Understanding How Envoy Sidecar Intercept and Route Traffic in Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 27, 2018</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding How Envoy Sidecar Intercept and Route Traffic in Istio Service Mesh', 'Details about Envoy sidecar with iptables rules.', '\nThis article uses Istio\u0027s official [bookinfo sample](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) to explain how Envoy performs routing forwarding after the traffic entering the Pod and forwarded to Envoy sidecar by iptables, detailing the inbound and outbound processing. For a detailed analysis of traffic interception, see [Understanding Envoy Sidecar Proxy Injection and Traffic Interception in Istio Service Mesh](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/).\n\n## Overview of Sidecar Injection and Traffic Interception Steps\n\nBelow is an overview of the steps from Sidecar injection, Pod startup to Sidecar proxy interception traffic and Envoy processing routing.\n\n1. Kubernetes automatically injected through Admission Controller, or the user run \u0060istioctl\u0060 command to manually inject sidecar container.\n2. Apply the YAML configuration deployment application. At this time, the service creation configuration file received by the Kubernetes API server already includes the Init container and the sidecar proxy.\n3. Before the sidecar proxy container and application container are started, the Init container started firstly. The Init container is used to set iptables (the default traffic interception method in Istio, and can also use BPF, IPVS, etc.) to Intercept traffic entering the pod to Envoy sidecar Proxy. All TCP traffic (Envoy currently only supports TCP traffic) will be Intercepted by sidecar, and traffic from other protocols will be requested as originally.\n4. Launch the Envoy sidecar proxy and application container in the Pod.\n\n{{\u003ccallout note\u003e}}\n**Sidecar proxy and application container startup order issues**\n\nStart the sidecar proxy and the application container. Which container is started first? Normally, Envoy Sidecar and the application container are all started up before receiving traffic requests. But we can\u0027t predict which container will start first, so does the container startup order have an impact on Envoy intercepting traffic? The answer is yes, but it is divided into the following two situations.\n\n**Case 1: The application container starts first, and the sidecar proxy is still not ready**\n\nIn this case, the traffic is transferred to the 15001 port by iptables, and the port is not monitored in the Pod. The TCP link cannot be established and the request fails.\n\n**Case 2: Sidecar starts first, the request arrives and the application is still not ready**\n\nIn this case, the request will certainly fail. As for the step at which the failure begins, the reader is left to think.\n\n**Question** : If adding a readiness and living probe for the sidecar proxy and application container can solve the problem?\n{{\u003c\/callout\u003e}}\n\n5. TCP requests that are sent or received from the Pod will be intercepted by iptables. After the inbound traffic is intercepted, it is processed by the Inbound Handler and then forwarded to the application container for processing. The outbound traffic is intercepted by iptables and then forwarded to the Outbound Handler for processing. Upstream and Endpoint.\n6. Sidecar proxy requests Pilot to use the xDS protocol to synchronize Envoy configurations, including LDS, EDS, CDS, etc., but to ensure the order of updates, Envoy will use ADS to request configuration updates from Pilot directly.\n\n## How Envoy handles route forwarding\n\nThe following figure shows a \u0060productpage\u0060service access request \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060, when traffic enters \u0060reviews\u0060 the internal services, \u0060reviews\u0060 internal services Envoy Sidecar is how to do traffic blocked the route forward.\n\n![Istio transparent traffic intercepting and traffic routing schematic](istio-iptables.svg)\n\nBefore the first step, \u0060productpage\u0060 Envoy Sidecar Pod has been selected by EDS of a request to \u0060reviews\u0060 a Pod service of its IP address, it sends a TCP connection request.\n\nThe Envoy configuration in the official website of Istio is to describe the process of Envoy doing traffic forwarding. The party considering the traffic of the downstream is to receive the request sent by the downstream. You need to request additional services, such as \u0060reviews\u0060 service requests need Pod \u0060ratings\u0060 service.\n\n\u0060reviews\u0060, there are three versions of the service, there is one instance of each version, three versions sidecar similar working steps, only to later \u0060reviews-v1-cb8655c75-b97zc\u0060 Sidecar flow Pod forwarding this step will be described.\n\n## Understanding the Inbound Handler\n\nThe role of the inbound handler is to transfer the traffic from the downstream intercepted by iptables to localhost to establish a connection with the application container inside the Pod.\n\nLook \u0060reviews-v1-cb8655c75-b97zc\u0060 at the Listener in the pod.\n\nRun \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc\u0060 to see what the Pod has a Listener.\n\n\u0060\u0060\u0060ini\nADDRESS            PORT      TYPE \n172.33.3.3         9080      HTTP \u003c---  Receives all inbound traffic on 9080 from listener 0.0.0.0_15006\n10.254.0.1         443       TCP  \u003c--\u002b\n10.254.4.253       80        TCP     |\n10.254.4.253       8080      TCP     |\n10.254.109.182     443       TCP     |\n10.254.22.50       15011     TCP     |\n10.254.22.50       853       TCP     |\n10.254.79.114      443       TCP     | \n10.254.143.179     15011     TCP     |\n10.254.0.2         53        TCP     | Receives outbound non-HTTP traffic for relevant IP:PORT pair from listener 0.0.0.0_15001\n10.254.22.50       443       TCP     |\n10.254.16.64       42422     TCP     |\n10.254.127.202     16686     TCP     |\n10.254.22.50       31400     TCP     |\n10.254.22.50       8060      TCP     |\n10.254.169.13      14267     TCP     |\n10.254.169.13      14268     TCP     |\n10.254.32.134      8443      TCP     |\n10.254.118.196     443       TCP  \u003c--\u002b\n0.0.0.0            15004     HTTP \u003c--\u002b\n0.0.0.0            8080      HTTP    |\n0.0.0.0            15010     HTTP    | \n0.0.0.0            8088      HTTP    |\n0.0.0.0            15031     HTTP    |\n0.0.0.0            9090      HTTP    | \n0.0.0.0            9411      HTTP    |  Receives outbound HTTP traffic for relevant port from listener 0.0.0.0_15001\n0.0.0.0            80        HTTP    |\n0.0.0.0            15030     HTTP    |\n0.0.0.0            9080      HTTP    |\n0.0.0.0            9093      HTTP    |\n0.0.0.0            3000      HTTP    |\n0.0.0.0            8060      HTTP    |\n0.0.0.0            9091      HTTP \u003c--\u002b    \n0.0.0.0            15006     TCP  \u003c--- Receives all inbound and outbound traffic to the pod from IP tables and hands over to virtual listener\n\u0060\u0060\u0060\n\nAs from \u0060productpage\u0060 traffic arriving \u0060reviews\u0060 Pods, downstream must clearly know the IP address of the Pod which is \u0060172.33.3.3\u0060, so the request is \u0060172.33.3.3:9080\u0060.\n\n**Virtual Listener**\n\nAs you can see from the Pod\u0027s Listener list, the 0.0.0.0:15001\/TCP Listener (the actual name is \u0060virtual\u0060) listens for all inbound traffic, and the following is the detailed configuration of the Listener.\n\n\u0060\u0060\u0060json\n{\n    \u0022name\u0022: \u0022virtual\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u00220.0.0.0\u0022,\n            \u0022portValue\u0022: 15006\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.tcp_proxy\u0022,\n                    \u0022config\u0022: {\n                        \u0022cluster\u0022: \u0022BlackHoleCluster\u0022,\n                        \u0022stat_prefix\u0022: \u0022BlackHoleCluster\u0022\n                    }\n                }\n            ]\n        }\n    ],\n    \u0022useOriginalDst\u0022: true\n}\n\u0060\u0060\u0060\n\n**UseOriginalDst** : As can be seen from the configuration in \u0060useOriginalDst\u0060the configuration as specified \u0060true\u0060, which is a Boolean value, the default is false, using iptables redirect connections, the proxy may receive port original destination address is not the same port, thus received at the proxy port It is 15001 and the original destination port is 9080. When this flag is set to true, the Listener redirects the connection to the Listener associated with the original destination address, here \u0060172.33.3.3:9080\u0060. Listener If no relationship to the original destination address, the connection processing by the Listener to receive it, i.e. the \u0060virtual\u0060Listener, after \u0060envoy.tcp_proxy\u0060forwarded to a filter process \u0060BlackHoleCluster\u0060, as the name implies, when no matching Envoy virtual listener when the effect of Cluster , will send the request to it and return 404. This will be referred to below Listener provided \u0060bindToPort\u0060 echoes.\n\n**Note** : This parameter will be discarded, please use the Listener filter of the original destination address instead. The main purpose of this parameter is: Envoy listens to the 15201 port to intercept the traffic intercepted by iptables via other Listeners instead of directly forwarding it. See the [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener) for details .\n\n**Listener 172.33.3.3_9080**\n\nAs mentioned above, the traffic entering the inbound handler is \u0060virtual\u0060 transferred to the \u0060172.33.3.3_9080\u0060 Listener by the Listener. We are looking at the Listener configuration.\n\nRun \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json\u0060 view.\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022172.33.3.3_9080\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u0022172.33.3.3\u0022,\n            \u0022portValue\u0022: 9080\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022raw_buffer\u0022\n            },\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.http_connection_manager\u0022,\n                    \u0022config\u0022: {\n                        ... \n                        \u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        },\n                        \u0022use_remote_address\u0022: false,\n                        ...\n                    }\n                }\n            ]，\n            \u0022deprecatedV1\u0022: {\n                \u0022bindToPort\u0022: false\n            }\n        ...\n        },\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022tls\u0022\n            },\n            \u0022tlsContext\u0022: {...\n            },\n            \u0022filters\u0022: [...\n            ]\n        }\n    ],\n...\n}]\n\u0060\u0060\u0060\n\n**bindToPort** : Note that there are a [\u0060bindToPort\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.6.0\/api-v1\/listeners\/listeners) configuration that is \u0060false\u0060, the default value of the configuration \u0060true\u0060, showing Listener bind to the port, set here to \u0060false\u0060 the process flow can Listener Listener transferred from the other, i.e., above said \u0060virtual\u0060 Listener, where we see filterChains.filters in the \u0060envoy.http_connection_manager\u0060 configuration section:\n\n\u0060\u0060\u0060json\n\u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n\u0060\u0060\u0060\n\nThis configuration indicates that traffic will be handed off to the Cluster for \u0060inbound|9080||reviews.default.svc.cluster.local\u0060 processing.\n\n**Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060**\n\nRun \u0060istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json\u0060 to see the Cluster configuration is as follows.\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n        \u0022connectTimeout\u0022: \u00221.000s\u0022,\n        \u0022hosts\u0022: [\n            {\n                \u0022socketAddress\u0022: {\n                    \u0022address\u0022: \u0022127.0.0.1\u0022,\n                    \u0022portValue\u0022: 9080\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {}\n            ]\n        }\n    }\n]\n\u0060\u0060\u0060\n\nYou can see that the Endpoint of the Cluster directly corresponds to localhost, and then the traffic is forwarded by the application container after iptables.\n\n## Understanding the Outbound Handler\n\nBecause the \u0060reviews\u0060 will to \u0060ratings\u0060 send an HTTP request service, request address are: \u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060 the role of Outbound handler is to intercept traffic to iptables to native applications sent via Envoy to determine how to route to the upstream.\n\nThe request sent by the application container is outbound traffic. After being intercepted by iptables, it is transferred to the Envoy Outbound handler for processing, then passed through \u0060virtual\u0060 Listener and \u00600.0.0.0_9080\u0060 Listener, and then finds the cluster of upstream through Route 9080, and then finds Endpoint through EDS to perform routing action. \n\n**Route 9080**\n\n\u0060reviews\u0060 requests \u0060ratings\u0060 service, run \u0060istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json\u0060 view route configuration because Envoy VirtualHost will be matched according to HTTP header of domains, so the following list only \u0060ratings.default.svc.cluster.local:9080\u0060 this one VirtualHost.\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n    \u0022domains\u0022: [\n        \u0022ratings.default.svc.cluster.local\u0022,\n        \u0022ratings.default.svc.cluster.local:9080\u0022,\n        \u0022ratings\u0022,\n        \u0022ratings:9080\u0022,\n        \u0022ratings.default.svc.cluster\u0022,\n        \u0022ratings.default.svc.cluster:9080\u0022,\n        \u0022ratings.default.svc\u0022,\n        \u0022ratings.default.svc:9080\u0022,\n        \u0022ratings.default\u0022,\n        \u0022ratings.default:9080\u0022,\n        \u002210.254.234.130\u0022,\n        \u002210.254.234.130:9080\u0022\n    ],\n    \u0022routes\u0022: [\n        {\n            \u0022match\u0022: {\n                \u0022prefix\u0022: \u0022\/\u0022\n            },\n            \u0022route\u0022: {\n                \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                \u0022timeout\u0022: \u00220.000s\u0022,\n                \u0022maxGrpcTimeout\u0022: \u00220.000s\u0022\n            },\n            \u0022decorator\u0022: {\n                \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n            },\n            \u0022perFilterConfig\u0022: {...\n            }\n        }\n    ]\n},\n..]\n\u0060\u0060\u0060\n\nYou can see the routing of traffic to the Cluster from this Virtual Host configuration \u0060outbound|9080||ratings.default.svc.cluster.local\u0060.\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nIstio 1.1 previous versions do not support the use of \u0060istioctl\u0060 commands to directly query Endpoint Cluster, you can use the debug queries Pilot endpoint way compromise.\n\n\u0060\u0060\u0060bash\nkubectl exec reviews-v1-cb8655c75-b97zc -c istio-proxy curl http:\/\/istio-pilot.istio-system.svc.cluster.local:9093\/debug\/edsz \u003e endpoints.json\n\u0060\u0060\u0060\n\n\u0060endpoints.json\u0060 file contains all the Endpoint information of the Cluster, and we only select \u0060outbound|9080||ratings.default.svc.cluster.local\u0060 the results of the Cluster as follows.\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nThe Endpoint can be one or more, and Envoy will route it according to certain rules by selecting the appropriate Endpoint.\n\n**Note** : Istio 1.1 will support the \u0060istioctl pc endpoint\u0060 command to query Endpoint.\n\n## Reference\n\n- [Debugging Envoy and Pilot - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/proxy-cmd\/)\n- [Understanding Envoy Agent Sidecar Injection and Traffic Interception in Istio Service Mesh - jimmysong.io](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [Istio traffic management implementation mechanism deep analysis - zhaohuabing.com](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/)\n\n', '\/en\/blog\/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Details about Envoy sidecar with iptables rules.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/en/blog/page/6/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/6/" class="page-link">
             6
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/blog/page/7/" class="page-link">
             7
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/8/" class="page-link">
             8
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/blog/page/8/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/page/8/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(43)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(10)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(4)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(4)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/seamless-cross-cluster-access-istio/">A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
