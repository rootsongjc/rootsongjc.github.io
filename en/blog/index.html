<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Blog - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog Posts">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/blog/" />
  <meta property="og:title" content="Blog | Jimmy Song" />
  <meta property="twitter:title" content="Blog | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog Posts" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog Posts" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/trans/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Blog
                </p>
                <p class="page-description">
                    Jimmy Song&rsquo;s Blog Posts
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 30, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from AWS App Mesh to Istio: A Comprehensive Guide', 'Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.', '\nWith[ AWS announcing the deprecation of AWS App Mesh effective September 30, 2026](https:\/\/aws.amazon.com\/cn\/blogs\/containers\/migrating-from-aws-app-mesh-to-amazon-ecs-service-connect\/), many organizations are evaluating alternatives to continue their service mesh journey. If you are one of those organizations, Istio presents itself as a robust and feature-rich option, especially for Kubernetes-native environments. In this post, I will provide an overview of the migration process from AWS App Mesh to Istio, compare the two service meshes, and introduce the Tetrate Istio Migration Tool—a convenient utility we developed to streamline this transition.\n\n## App Mesh vs Istio: Preparing for Migration\n\nWith AWS App Mesh being deprecated, it’s important to understand the similarities and differences between App Mesh and Istio to prepare for a successful migration. Below are some key points of comparison to help align your current infrastructure with what Istio offers:\n\n1. Comprehensive Features: Both App Mesh and Istio offer traffic management, observability, and security, but Istio provides more customizable options, including advanced traffic routing and enhanced telemetry.\n2. Cloud Agnostic: Unlike AWS App Mesh, which is tightly integrated with AWS, Istio is cloud-agnostic, allowing for greater flexibility across multi-cloud or hybrid environments.\n3. Advanced Security: Istio supports mTLS by default, offering more extensive security features and policies compared to App Mesh.\n\nAWS recommends ECS customers migrate to[ Service Connect](https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/developerguide\/service-connect.html) and EKS customers to[ VPC Lattice](https:\/\/aws.amazon.com\/vpc\/lattice\/). For a feature-rich, open source solution, Istio is a compelling choice. Let’s dive into the migration journey from AWS App Mesh to Istio, supported by Tetrate’s migration tool.\n\n## Comparing App Mesh, Service Connect, VPC Lattice and Istio\n\nBefore starting the migration, it’s essential to understand the key differences between AWS App Mesh, Service Connect, VPC Lattice, and Istio:\n\n| **Feature**                  | **App Mesh**                                                 | **Service Connect**                                          | **VPC Lattice**                                              | **Istio**                                                    |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Network Reliability**      | Uses[ Envoy](https:\/\/envoyproxy.io\/) as sidecar proxies for outlier detection, health checks, and retries with granular adjustments. | Uses Envoy as sidecar proxies with default configurations, only timeouts adjustable. | Built-in health checks and retries with AWS-managed reliability. No sidecar proxies are needed. | Supports both sidecar and ambient modes, using Envoy with full support for fine-tuning. |\n| **Advanced Traffic Routing** | Supports advanced traffic routing like A\/B testing and canary releases. | Does not support advanced traffic routing.                   | Supports basic traffic routing and load balancing.           | Supports advanced traffic control, including A\/B testing and canary releases. |\n| **Observability**            | Manual collection and monitoring of metrics.                 | Sends metrics to Amazon CloudWatch automatically.            | Integrated monitoring with AWS CloudWatch and X-Ray.         | Out-of-the-box observability with Prometheus, Grafana, and Jaeger. |\n| **Service Discovery**        | Integrates with AWS Cloud Map.                               | Uses AWS Cloud Map.                                          | Uses AWS service discovery mechanisms.                       | Uses Kubernetes-native service discovery.                    |\n| **Security**                 | Supports TLS with AWS PCA and mutual TLS (mTLS).             | Supports TLS, no mTLS.                                       | Supports mTLS.                                               | Supports mTLS, fine-grained security policies.               |\n| **Resource Sharing**         | Can share Mesh across multiple AWS accounts.                 | Cannot share namespaces across accounts.                     | Can share resources across multiple AWS accounts.            | Can be deployed across multiple clusters and clouds.         |\n\n## Introducing Tetrate’s Istio Migration Tool\n\nTo make the migration process smoother, Tetrate has developed an Istio Migration Toolkit, which is currently in a private state but can be used internally or by approved customers who request it through the[ form](https:\/\/resources.tetrate.dev\/app-mesh-istio?__hstc=218802950.edcf2542a8010c44aa57b98adaef028a.1721092227167.1729818643207.1730268606576.91\u0026__hssc=218802950.2.1730268606576\u0026__hsfp=872206273). The toolkit assists in automating the conversion of AWS App Mesh configurations to Istio equivalents, including Virtual Nodes, Virtual Routers, and other networking constructs.\n\n**Key Considerations**\n\n- **Service discovery**: App Mesh and Istio handle service discovery differently. Istio leverages Kubernetes-native service discovery, while App Mesh integrates with AWS Cloud Map. During the migration, it is critical to adjust your service definitions accordingly.\n- **Security**: Istio natively supports mTLS between services. While AWS App Mesh also offers mTLS, transitioning to Istio will require configuring the Certificate Authority (CA) and updating certificates to align with Istio’s security model.\n- **Traffic management**: Istio’s Virtual Services and Destination Rules offer more advanced traffic routing capabilities compared to App Mesh’s Virtual Routers and Nodes. As you migrate, plan for additional configuration steps to set up similar routing behavior in Istio.\n\n## Step-by-Step Migration Using Tetrate’s Migration Tool\n\nBelow, I’ll guide you through the steps to use this tool effectively.\n\n### Prerequisites\n\nTo start the migration, ensure you have the following installed:\n\n- [Go](https:\/\/golang.org\/doc\/install)\n- [kubectl](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)\n- [istioctl](https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/#download)\n\nMake sure your AWS App Mesh is properly installed and configured on an EKS cluster. You’ll also need a Kubernetes secret called tetrate-tis-creds for Istio installation, as detailed in the tool’s documentation.\n\nThe tool also helps verify compatibility, offering a precheck command to identify any potential blockers before starting the migration.\n\n### Running a Precheck\n\nTo verify that your setup is ready for migration, run:\n\n\u0060\u0060\u0060bash\ntim precheck\n\u0060\u0060\u0060\n\nThis command will scan your App Mesh environment and highlight any adjustments required to ensure a successful migration.\n\n### Migration Process\n\n1. Install Istio\n\n   Use the Istio Migration Toolkit to generate IstioOperator configurations, and install Istio:\n\n   \u0060\u0060\u0060bash\n   tim generate iop | istioctl install –skip-confirmation -f –\n   \u0060\u0060\u0060\n\n1. Apply Istio Networking Rules\n   Next, generate and apply Istio networking rules:\n\n   \u0060\u0060\u0060bash\n   tim generate networking | kubectl apply -f –\n   \u0060\u0060\u0060\n\n1. Remove AWS App Mesh Labels\n   Remove the existing App Mesh labels from your namespaces. For example, for the default namespace:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default \u0022appmesh.k8s.aws\/sidecarInjectorWebhook-\u0022\n   \u0060\u0060\u0060\n\n1. Enable Istio Sidecar Injection\n   Add a label to enable Istio’s automatic sidecar injection:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio-injection=enabled\n   \u0060\u0060\u0060\n\n1. Restart Deployments\n   To apply changes and initiate the new Envoy sidecar injection, restart your deployments:\n\n   \u0060\u0060\u0060bash\n   kubectl rollout restart deployment \u003cdeployment-name\u003e -n \u003cdeployment-namespace\u003e\n   \u0060\u0060\u0060\n\n### Migration Strategies\n\nWhen migrating apps from AWS App Mesh to Istio, there are strategies like in-place, canary, and blue\/green deployments, similar to those for migrating to VPC Lattice. The right strategy depends on app requirements like zero downtime or scheduling maintenance windows.\n\n1. **In-Place Migration**: Replace existing Kubernetes Pods instrumented with App Mesh with new Pods configured for Istio. This approach is suitable for applications that can tolerate downtime during the migration process, as each pod is recycled to remove the Envoy sidecar container and add Istio.\n2. **Blue\/Green Deployment**: Deploy a second copy of the application in a new namespace configured for Istio, while the original deployment remains operational with App Mesh. Gradually migrate traffic from App Mesh to Istio without downtime while both environments run simultaneously.\n3. **Canary Deployment**: Deploy Istio side-by-side with App Mesh and incrementally move a small percentage of traffic to Istio. Monitor performance and stability, and increase traffic as confidence grows.\n4. **Phased Migration**: Migrate components or services incrementally instead of all at once. This reduces risk and helps identify potential issues in smaller, manageable segments.\n5. **Testing and Validation**: Before cutting over entirely, conduct thorough testing to validate that service functionality, security, and performance metrics meet or exceed expectations.\n\n## Conclusion\n\nMigrating from AWS App Mesh to Istio can unlock new capabilities in traffic management, observability, and security. Tetrate’s Istio Migration Toolkit simplifies the process, providing a step-by-step approach to reduce manual configurations and ensure a seamless transition.\n\nIf you’re interested in trying out Tetrate’s Istio Migration Toolkit, feel free to reach out—the tool is currently available for private use, and we’d be happy to discuss access.\n\nThis migration is not just about adopting a new service mesh—it’s an opportunity to take advantage of Istio’s comprehensive features, support multi-cloud deployments, and enhance the resilience of your infrastructure.\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/).*\n', '\/en\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multi-Cluster PKI \u002b Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh', 'This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.', '\nAuthors: Cristofer TenEyck Senior Solution Engineer a Keyfactor and Jimmy Song Developer Advocate at Tetrate\n\n## Introduction\n\nIn the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge. \n\nIn this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes. \n\nWhy multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters. \n\n## Understanding PKI and its Role in Service Meshes \n\nPKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments. \n\nThe EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications. \n\n## Istio, EJBCA and cert-manager \n\nSetting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included: \n\n1. **Environment Preparation**: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA). \n2. **cert-manager Integration**: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates. \n3. **Automatic Certificate Renewal**: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters. \n\n![Architecture](arch.webp)\n\n## Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary \n\nThis section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found [here](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi).\n\nThe key steps include: \n\n1. **Install and Configure Helm Repositories**: Add necessary Helm repositories for Istio, cert-manager, and EJBCA. \n2. **Deploy cert-manager and EJBCA**: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets. \n3. **Configure Istio with EJBCA**: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration. \n4. **Install Istio Components**: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway. \n5. **Customization and Overrides**: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services. \n6. **Automatic Certificate Renewal:** The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications. \n\n![Certificate renew flow](cert-renew-flow.webp)\n\nAbove is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA. \n\n## PKI Best Practices and Compliance \n\nBuilding a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider: \n\n1. **Compliance with Regulations**: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices. \n2. **Crypto Agility and Quantum Readiness**: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important. \n3. **Collaboration with InfoSec**: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals. \n\n## Conclusion \n\nImplementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant. \n\nBy following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh. \n\nFor further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below. \n\n## Resources \n\n- [Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi)\n- [Istio documentation](https:\/\/istio.io\/latest\/docs\/)\n- [EJBCA Community edition](https:\/\/www.ejbca.org\/)\n- [cert-manager documentation](https:\/\/cert-manager.io\/docs\/)\n- [EU Cyber Resilience Act](https:\/\/digital-strategy.ec.europa.eu\/en\/policies\/cyber-resilience-act)\n- [US Executive Order on Cybersecurity](https:\/\/www.whitehouse.gov\/briefing-room\/statements-releases\/2021\/05\/12\/executive-order-on-improving-the-nations-cybersecurity\/)\n- [A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh](\/en\/blog\/seamless-cross-cluster-access-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh\/).*\n', '\/en\/blog\/multi-cluster-pki-istio-recipe\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-tracing/">How the Envoy Proxy Handles User Requests for Tracing</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 26, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How the Envoy Proxy Handles User Requests for Tracing', 'An in-depth exploration of how the Envoy proxy processes user requests in a cloud-native environment to enable distributed tracing and enhance application observability.', '\nIn a cloud-native environment, improving application observability to better understand user experience is crucial. However, relying solely on metrics and logs does not provide specific details for individual cases. This is where tracing technology becomes essential.\n\n## Basic Principles of Tracing\n\nTracing provides developers with a complete context of the user experience by attaching an associated ID to each user request. This associated ID acts like a thread that connects traces across multiple services, enabling comprehensive observability.\n\nThe diagram below illustrates the flow of user requests processed by Envoy.\n\n\u0060\u0060\u0060mermaid \u0022User Request and Envoy Proxy Processing Flow Diagram\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant App\n    participant Backend\n    \n    %% User sends the initial request with various headers\n    User-\u003e\u003eEnvoy: User Request with Headers (Host, X-User-Identity, X-B3-TraceId)\n\n    %% Envoy forwards the request to the application\n    Envoy-\u003e\u003eApp: Forward Request (with headers)\n    \n    %% App processes the request and makes outgoing requests\n    App-\u003e\u003eEnvoy: Outgoing Request (to Backend with headers)\n    Envoy-\u003e\u003eBackend: Forward Request (X-B3-TraceId: 1234, X-User-Identity)\n\n    %% Backend responds to the outgoing request\n    Backend-\u003e\u003eEnvoy: Response to App Request\n    Envoy-\u003e\u003eApp: Forward Response\n\n    %% App processes response and sends response back to user\n    App-\u003e\u003eEnvoy: Response to User Request\n    Envoy-\u003e\u003eUser: Forward Response (to original User Request)\n\n    %% Handling multiple requests concurrently\n    User-\u003e\u003eEnvoy: Multiple Concurrent Requests\n    Envoy-\u003e\u003eApp: Forward Multiple Requests\n    App-\u003e\u003eEnvoy: Forward Responses\n    Envoy-\u003e\u003eUser: Multiple Concurrent Responses\n\u0060\u0060\u0060\n\n![User Request and Envoy Proxy Processing Flow Diagram](3e14426a8706f1e658721863febb0d58.svg)\n\n**Tracing** enables developers to have complete context of the user experience by appending an associated ID to each user request. This associated ID connects traces across multiple services.\n\nAlthough all requests pass through the Envoy proxy, it cannot independently provide complete tracing information. Envoy only sees the application as part of the network and lacks insights into internal processes. This limits Envoy\u0027s ability to distinguish whether incoming and outgoing requests originate from the same user, thus it cannot automatically forward tracing context.\n\n## Request Context in the Service Mesh\n\nEnvoy can act as a Sidecar or Waypoint proxy in the Istio service mesh. The following diagram illustrates how Envoy handles request context within the service mesh.\n\n### 1. The Start of the User Request\n\nTracing involves following the path across multiple services to understand the complete context of the user experience. Tracing begins with a user request assigned an associated ID.\n\n\u0060\u0060\u0060mermaid \u0022Start of the User Request\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: Request (with Headers)\n    Note right of User: Headers:\u003cbr\/\u003e- Host: example.com\u003cbr\/\u003e- X-User-Identity: Base64 Token\u003cbr\/\u003e- X-B3-TraceId: 1234\n\u0060\u0060\u0060\n\n![Start of the User Request](a7b787a1899db47cfb74a3f63fdd60cb.svg)\n\n### 2. Request Passing Through Envoy Proxy\n\nEnvoy sits beside the application, and all incoming requests go through Envoy.\n\n\u0060\u0060\u0060mermaid \u0022Request Passing Through Envoy Proxy\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: Initiates Request\n    Envoy-\u003e\u003eApplication: Forwards Request\n\u0060\u0060\u0060\n\n![Request Passing Through Envoy Proxy](294e6a2bd4ea694cb9e8039da41b388c.svg)\n\n### 3. Envoy Adds Extra Headers\n\nEnvoy can add extra headers to the request to gather information about what happens internally within the application.\n\n\u0060\u0060\u0060mermaid \u0022Envoy Adds Extra Headers\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: Forward Request (with Extra Headers)\n    Note right of Envoy: Added Headers:\u003cbr\/\u003e- X-Forwarded-For\u003cbr\/\u003e- X-Forwarded-Client-Cert\n\u0060\u0060\u0060\n\n![Envoy Adds Extra Headers](0626b8bc5b9a1f71f87a2ed3ac4a26fd.svg)\n\n### 4. Application Processes Request and Calls Backend Services\n\nDuring request processing, the application may need to contact other systems, such as external authentication and authorization services.\n\n\u0060\u0060\u0060mermaid \u0022Application Processes Request and Calls Backend Services\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy (Outbound)\n    participant Backend\n    Application-\u003e\u003eEnvoy2: Call Backend Request\n    Envoy2-\u003e\u003eBackend: Forward Request\n\u0060\u0060\u0060\n\n![Application Processes Request and Calls Backend Services](6d851064ab515a85731111767057ed1a.svg)\n\n### 5. Application Needs to Copy the Associated ID\n\nThe application knows which outbound request corresponds to which inbound request (e.g., the request with Trace ID 1234). However, Envoy does not know this. Thus, the application must copy the associated ID and context from the inbound request to the outbound request.\n\n\u0060\u0060\u0060mermaid \u0022Application Needs to Copy the Associated ID\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy (Outbound)\n    participant Backend\n    Application-\u003e\u003eEnvoy2: Call Backend Request (Copy Headers)\n    Note right of Application: Copy Headers:\u003cbr\/\u003e- X-B3-TraceId: 1234\u003cbr\/\u003e- X-User-Identity: Base64 Token\n    Envoy2-\u003e\u003eBackend: Forward Request\n\u0060\u0060\u0060\n\n![Application Needs to Copy the Associated ID](f665f07be64f3e3d5d547d0513a49947.svg)\n\n### 6. Concurrent Handling of Multiple Requests\n\nIn real scenarios, applications handle multiple user requests simultaneously, leading to concurrency. Since Envoy only sees network-level requests and responses, it cannot distinguish the causal relationships between these requests.\n\n\u0060\u0060\u0060mermaid \u0022Concurrent Handling of Multiple Requests\u0022\nsequenceDiagram\n    participant User1\n    participant User2\n    participant Envoy\n    participant Application\n    User1-\u003e\u003eEnvoy: Request 1\n    User2-\u003e\u003eEnvoy: Request 2\n    Envoy-\u003e\u003eApplication: Forward Request 1\n    Envoy-\u003e\u003eApplication: Forward Request 2\n    Application-\u003e\u003eEnvoy: Response to Outbound Request 1\n    Application-\u003e\u003eEnvoy: Response to Outbound Request 2\n\u0060\u0060\u0060\n\n![Concurrent Handling of Multiple Requests](8851146efa64bf28b23427eaa3c88753.svg)\n\n### 7. Limitations of Envoy\n\nSince Envoy cannot see the internal processing logic of the application, it only observes a series of network requests and responses without knowing which outbound requests were triggered by which inbound requests.\n\n\u0060\u0060\u0060mermaid \u0022Limitations of Envoy\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: Multiple Requests\n    Application-\u003e\u003eEnvoy: Multiple Responses\n    Note over Envoy: Cannot distinguish causal relationships of requests\n\u0060\u0060\u0060\n\n![Limitations of Envoy](a3e1d4b42a3342b8089f30cfba68c457.svg)\n\n## The Role of the Application\n\nSince Envoy cannot automatically forward tracing context, the application itself needs to be responsible for copying the headers from inbound requests to outbound requests to maintain the integrity of the tracing information.\n\n### Application Copies Headers\n\nWhile processing inbound requests, the application needs to copy necessary headers (like associated ID and user identity) to any outbound requests.\n\n\u0060\u0060\u0060mermaid \u0022Application Copies Headers\u0022\nsequenceDiagram\n    participant Application\n    participant Backend\n    Application-\u003e\u003eBackend: Outbound Request (with Copied Headers)\n\u0060\u0060\u0060\n\n![Application Copies Headers](e5e99c435025f175807e7dd2912993fc.svg)\n\n### Response Returns to User\n\nOnce the application completes processing the user request, it returns the response to the user.\n\n\u0060\u0060\u0060mermaid \u0022Response Returns to User\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy\n    participant User\n    Application-\u003e\u003eEnvoy: Response\n    Envoy-\u003e\u003eUser: Forward Response\n\u0060\u0060\u0060\n\n![Response Returns to User](d06d46d97409d875f695a10005550f6b.svg)\n\n## Solutions and Recommendations\n\nTo ensure the integrity of tracing information, applications need to actively copy and transmit tracing-related headers. This can be achieved by integrating tools like [Apache SkyWalking](https:\/\/skywalking.apache.org\/), which not only supports distributed tracing but also includes performance monitoring and log analysis features. By utilizing SkyWalking’s libraries and agents, the process of copying headers and transmitting tracing information can be simplified.\n\nFor details on using SkyWalking for distributed tracing in Istio, refer to [this blog post](\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/).\n\n## Conclusion\n\n- **Importance of Tracing**: Tracing provides developers with complete context of user requests, aiding in better understanding and improving user experience.\n\n- **Role of Envoy**: Envoy serves as a proxy for network requests but cannot provide complete tracing information without assistance from the application.\n- **Application Responsibility**: Applications must actively copy and transmit tracing-related headers to maintain context.\n- **Utilizing Tools**: Leveraging distributed tracing tools like Apache SkyWalking can enhance observability and streamline the header copying process.\n\n## References\n\n- [How the Envoy proxy handles a user request - tetrate.io](https:\/\/tetrate.io\/blog\/how-the-envoy-proxy-handles-a-user-request\/)\n- [How to Use SkyWalking for Distributed Tracing in Istio? - jimmysong.io](https:\/\/jimmysong.io\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/)\n', '\/en\/blog\/envoy-tracing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth exploration of how the Envoy proxy processes user requests in a cloud-native environment to enable distributed tracing and enhance application observability.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/introducing-kmesh-kernel-native-service-mesh/">Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology', 'Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.', '\nIn the world of microservices and cloud-native applications, service meshes have become essential for managing service-to-service communication. However, traditional sidecar-based architectures introduce significant latency and resource overhead, posing challenges for latency-sensitive and large-scale applications. **Kmesh** emerges as a groundbreaking solution—a high-performance, kernel-native service mesh data plane that leverages eBPF and kernel enhancements to deliver unparalleled efficiency and performance.\n\n## Background\n\nService meshes like Istio have become integral in managing complex microservices architectures, providing features like traffic management, security, and observability. The sidecar model, where a proxy runs alongside each service instance, has been the predominant approach. While effective in functionality, this architecture introduces significant latency and resource overhead.\n\n{{\u003ccallout note \u0022Note\u0022\u003e}}\n\nAll data presented in this article is quoted from [A New Choice for Istio Data Plane: Architectural Innovation for a Brand-New Performance Experience](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no). I have not verified the accuracy of these data. You are requested to judge and verify the reliability of these data on your own.\n\n{{\u003c\/callout\u003e}}\n\n## Limitations of Traditional Sidecar Architectures\n\n1. **Latency Overhead**: The addition of sidecar proxies results in increased network hops and context switches, introducing an extra **2 to 3 milliseconds** of latency per service call. For latency-sensitive applications, this delay is unacceptable.\n\n2. **Resource Consumption**: Each sidecar consumes CPU and memory resources. In large-scale deployments with thousands of services, the accumulated resource overhead is huge. Although it can be optimized through certain technical means, it still reduces deployment density and increases operating costs.\n\nPerformance measurements of Istio reveal that even without traffic distribution, there\u0027s an inherent latency overhead of approximately 3 milliseconds. As the number of connections grows, latency increases correspondingly, highlighting the inefficiency of the sidecar model for high-performance applications.\n\n## Industry Attempts to Address the Challenges\n\nSeveral solutions have been proposed to mitigate the drawbacks of sidecar architectures:\n\n### Cilium Service Mesh\n\n- **Approach**: Combines eBPF with Envoy to create a sidecar-less service mesh.\n- **Mechanism**:\n  - **L4 Traffic**: Uses eBPF for efficient kernel-level data routing.\n  - **L7 Traffic**: Relies on Envoy for application-layer parsing.\n- **Limitations**:\n  - **Extra Hops for L7**: L7 governance through Envoy introduces additional network hops.\n  - **Fault Isolation**: Challenges in ensuring governance fault isolation.\n\n### Istio Ambient Mesh\n\n- **Approach**: Introduces sidecar-less architecture using **ztunnel** and **waypoint** proxies.\n- **Mechanism**:\n  - **User-Space Processing**: All traffic interception and management occur in user space.\n- **Limitations**:\n  - **Complex Traffic Interception**: User-space interception increases complexity.\n  - **Increased Hops**: L7 connections involve multiple network hops, adding latency.\n\nThese solutions, while innovative, do not fully resolve the latency and resource overhead issues inherent in sidecar architectures.\n\n## Introducing Kmesh: A Kernel-Native Approach\n\nKmesh defines a new service mesh data plane by directly integrating traffic governance into the operating system kernel. Utilizing eBPF (Extended Berkeley Packet Filter) and kernel enhancements, Kmesh provides high-performance, low-latency, and resource-efficient service mesh capabilities.\n\n### Technical Architecture\n\n![Kmesh Architecture](kmesh-arch.svg)\n\n**Core Components**:\n\n- **Kmesh-Daemon**: A per-node management component responsible for:\n  - Managing eBPF programs.\n  - Subscribing to xDS configurations from the control plane (e.g., Istiod).\n  - Handling observability and metrics collection.\n\n- **eBPF Orchestration**: Implements traffic interception and management at the kernel level, supporting:\n  - L4 load balancing.\n  - Traffic encryption and decryption.\n  - Monitoring and simple L7 dynamic routing.\n\n- **Waypoint Proxy (Optional in Dual Engine Mode)**: Handles advanced L7 traffic governance, deployed per namespace or per service as needed.\n\n### Key Advantages\n\n![Kmesh vs Sidecar vs Ambient ([Source](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no))](performance.webp)\n\n1. **High Performance**:\n   - **Latency Reduction**: Kernel-native L7 management reduces forwarding latency by over **60%** compared to traditional sidecar architectures.\n   - **Improved Application Startup**: Application bootstrap times improve by **40%** due to the elimination of sidecar initialization.\n\n2. **Low Resource Overhead**:\n   - **Resource Efficiency**: Eliminates the need for sidecar proxies, reducing resource consumption by over **70%**.\n\n3. **High Availability**:\n   - **Seamless Upgrades**: Kernel-level traffic management ensures that upgrading or restarting Kmesh components does not disrupt existing service connections.\n\n4. **Security Isolation**:\n   - **Enhanced Security**: Utilizes BPF-based virtual machine security and cgroup-level governance isolation to ensure secure multi-tenancy.\n\n5. **Flexible Governance Model**:\n   - **Deployment Modes**: Offers both Kernel-Native Mode for maximum performance and Dual Engine Mode for deployment flexibility.\n\n6. **Seamless Compatibility**:\n   - **Control Plane Integration**: Fully compatible with the xDS protocol, allowing integration with Istio\u0027s control plane and supporting Istio APIs and Gateway APIs.\n\n## Two Operational Modes of Kmesh\n\nKmesh provides two operational modes to cater to different deployment needs:\n\n### Kernel-Native Mode\n\n**Overview**:\n\n- **Ultimate Performance**: Achieves the lowest possible latency with no additional network hops for both L4 and L7 traffic.\n- **Mechanism**:\n  - **Kernel Enhancements**: Enhances the kernel using eBPF and kernel modules (ko).\n  - **Fake TCP Connections**: Utilizes forged connections to manage complex application-layer traffic within the kernel.\n  - **Traffic Management**: Directly manages traffic as soon as the client initiates communication, eliminating unnecessary context switches and data copies.\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces forwarding latency by over 60%.\n- **No Dependency on User-Space Proxies**: Entire traffic management is handled within the kernel.\n\n**Considerations**:\n\n- **Kernel Version Requirements**: May require specific kernel versions or enhancements, which could impact deployment flexibility.\n\n### Dual Engine Mode\n\n**Overview**:\n\n- **Flexible Governance**: Balances performance with broader compatibility and flexibility.\n- **Mechanism**:\n  - **Kernel-Level Interception**: Uses eBPF to intercept traffic in the kernel space.\n  - **Waypoint Proxy**: Deploys a remote waypoint proxy to handle complex L7 traffic management.\n  - **Layer Separation**: Splits L4 and L7 governance between kernel space (eBPF) and user space (waypoint).\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces latency by **30%** compared to Istio\u0027s Ambient Mesh.\n- **Simplified Traffic Interception**: Kernel-space interception is more secure and simpler than user-space interception.\n- **Lower Adoption Threshold**: Reduced dependency on specific kernel versions, making it easier for users to adopt.\n\n**Comparison with Ambient Mesh**:\n\n- **Fewer Network Hops**: Kmesh adds only one extra hop for L7 connections, whereas Ambient Mesh may add up to three.\n- **Simpler Architecture**: Kernel-level interception avoids the complexity of user-space interception mechanisms.\n\n## Deep Dive into Kmesh\u0027s Technology\n\n### eBPF and Kernel Enhancements\n\n**eBPF (Extended Berkeley Packet Filter)** is a powerful technology that allows the injection of custom code into the Linux kernel safely and efficiently. Kmesh leverages eBPF to:\n\n- **Intercept Network Traffic**: Attach eBPF programs to network events, enabling real-time interception and manipulation of packets.\n- **Implement Load Balancing**: Direct traffic to appropriate service instances based on policies.\n- **Perform Traffic Encryption**: Handle mTLS encryption and decryption within the kernel, reducing overhead.\n- **Collect Observability Data**: Gather metrics and telemetry data without impacting application performance.\n\n### Traffic Interception and Management\n\nIn the Kernel-Native Mode:\n\n- **Forged Connections**: Kmesh creates fake TCP connections within the kernel to manage traffic without involving user-space proxies.\n- **Direct Packet Manipulation**: Packets are intercepted and redirected at the kernel level, eliminating context switches and data copies that occur when moving packets between user space and kernel space.\n\nIn the Dual Engine Mode:\n\n- **eBPF Interception**: eBPF programs handle initial traffic interception and basic L4 management.\n- **Waypoint Proxy**: For advanced L7 features like routing, retries, and header manipulation, traffic is forwarded to a waypoint proxy deployed per service or namespace.\n\n### Security and Isolation\n\n- **BPF Virtual Machine Security**: eBPF runs in a restricted virtual machine within the kernel, ensuring that injected code cannot compromise kernel stability.\n- **Cgroup-Level Isolation**: Governance policies are applied at the cgroup level, providing isolation between different services and workloads.\n- **mTLS Support**: Mutual TLS is implemented within the kernel (Under development. Planned to be supported by the end of 2024), providing zero-trust security without the overhead of user-space encryption.\n\n## Performance Analysis\n\n**Test Setup**:\n\n- **Benchmark Tool**: Used [Fortio](https:\/\/github.com\/fortio\/fortio) to generate load and measure latency.\n- **Comparisons**: Measured performance across four configurations:\n  1. **Baseline**: Direct communication without any service mesh.\n  2. **Istio Sidecar**: Traditional sidecar-based deployment.\n  3. **Istio Ambient Mesh**: Sidecar-less deployment with ztunnel and waypoint.\n  4. **Kmesh**: Both Kernel-Native and Dual Engine modes.\n\n**Results**:\n\n- **Latency**:\n  - **Kmesh Kernel-Native Mode**: Achieved over **60%** reduction in forwarding latency compared to Istio Sidecar.\n  - **Kmesh Dual Engine Mode**: Reduced latency by **30%** compared to Istio Ambient Mesh.\n- **Resource Consumption**:\n  - **CPU and Memory**: Kmesh reduced resource overhead by over **70%**, as it eliminates the need for sidecar proxies.\n- **Application Startup Time**:\n  - Improved by **40%**, as applications no longer wait for sidecar initialization.\n\n**Interpretation**:\n\n- Kmesh approaches baseline performance, making the overhead of the service mesh negligible.\n- The elimination of context switches and data copies contributes significantly to performance gains.\n- The kernel-native approach ensures consistent performance even as the number of services scales.\n\n## Cloud-Native Integration and Compatibility\n\n- **Kubernetes Native**: Kmesh runs seamlessly on Kubernetes, managing traffic to and from pods without requiring changes to application code.\n- **Control Plane Integration**:\n  - **xDS Protocol Support**: Subscribes to xDS configurations from Istiod, ensuring compatibility with Istio\u0027s control plane.\n  - **Istio API Compatibility**: Supports existing Istio APIs, allowing users to leverage familiar configurations and policies.\n- **Gateway API Support**: Compatible with Gateway APIs, enabling more flexible and expressive traffic management.\n- **Observability**:\n  - Integrates with Prometheus for metrics collection.\n  - Utilizes eBPF for efficient data gathering without impacting performance.\n- **Security Policies**:\n  - Supports existing Istio security policies, including authentication and authorization.\n\n## Future Roadmap\n\n**Short-Term Goals (2024)**:\n\n- **September 2024**:\n  - Implement circuit breaking and rate limiting.\n  - Enhance support for mTLS and upstream extensions.\n  - Ensure seamless restarts without affecting traffic.\n- **December 2024 (Release 1.0)**:\n  - Introduce locality-aware load balancing.\n  - Add multi-cluster support for federated deployments.\n  - Enhance DNS and headless service handling.\n  - Integrate with gateway components for edge traffic management.\n\n**Long-Term Vision (2025 and Beyond)**:\n\n- **AI Integration**:\n  - Incorporate AI capabilities to improve traffic governance decisions.\n  - Enhance problem diagnostics and anomaly detection.\n- **Multi-VPC Support**:\n  - Extend support to multi-Virtual Private Cloud environments.\n- **Advanced Observability**:\n  - Leverage eBPF and Application Performance Management tools for deeper insights.\n  - Provide end-to-end tracing and metrics.\n\n## Conclusion\n\nKmesh represents a paradigm shift in service mesh technology by moving traffic management into the kernel. By leveraging eBPF and kernel enhancements, it addresses the critical challenges of latency and resource overhead inherent in traditional sidecar architectures. Kmesh offers a flexible, high-performance solution suitable for modern cloud-native applications, particularly those requiring low latency and high throughput.\n\n**Key Takeaways**:\n\n- **Performance**: Achieves near-baseline performance by eliminating unnecessary overhead.\n- **Resource Efficiency**: Reduces CPU and memory consumption, enabling higher deployment densities.\n- **Flexibility**: Provides multiple operational modes to suit different deployment scenarios.\n- **Security**: Enhances security through kernel-level enforcement and isolation mechanisms.\n- **Compatibility**: Integrates seamlessly with existing cloud-native ecosystems, including Kubernetes and Istio.\n\nAs microservices architectures continue to evolve, solutions like Kmesh will play a crucial role in enabling efficient, scalable, and secure service communication. By addressing the limitations of traditional service mesh designs, Kmesh sets a new standard for performance and resource efficiency in the service mesh landscape.\n', '\/en\/blog\/introducing-kmesh-kernel-native-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-configuration-safety-common-misconfigurations/">Istio Configuration Security: How to Avoid Misconfigurations</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Configuration Security: How to Avoid Misconfigurations', 'Explore common Istio configuration errors and their solutions to enhance the security and stability of your service mesh.', '\nIstio is a powerful service mesh solution that provides zero-trust security, observability, and advanced traffic management without requiring code modifications. However, misconfigurations often lead to unexpected behavior. This article discusses several common Istio configuration errors, explains the principles behind them, and shows how to identify and resolve these issues through diagrams. We will also introduce the TIS Config Analyzer tool from Tetrate, designed to optimize Istio operation efficiency and security.\n\n## Incident Cases Caused by Configuration Errors\n\nHere are two typical incidents caused by configuration errors:\n\n1. **[Amazon Web Services 2017 Outage](https:\/\/www.theverge.com\/2017\/3\/2\/14792442\/amazon-s3-outage-cause-typo-internet-server)**: A simple typo led to widespread service disruptions, affecting thousands of online services and applications, highlighting that even a minor configuration error in mature cloud infrastructure can have severe consequences.\n\n2. **[GitLab 2017 Data Loss Incident](https:\/\/about.gitlab.com\/blog\/2017\/02\/01\/gitlab-dot-com-database-incident\/)**: Due to configuration errors, GitLab accidentally deleted a large amount of production data during database maintenance. Although backup mechanisms were configured, an incorrect configuration prevented timely data recovery.\n\nThese cases show the importance of proper configuration management in preventing service disruptions and data loss.\n\n## Common Types of Istio Configuration Errors\n\nIstio configuration errors can be broadly categorized as follows:\n\n1. **AuthorizationPolicy**: Non-existent namespaces, HTTP methods and fully qualified gRPC names only, host without matching service registry entries, fields requiring mTLS enabled, missing service accounts, etc.\n2. **DestinationRule**: Multiple destination rules for the same host subset combination, host without matching entries in the service registry, subset labels not found in any matching hosts, etc.\n3. **Gateway**: Multiple gateways for the same host-port combination, gateway selectors not finding matching workloads in the namespace, etc.\n4. **Port**: Port names must follow a specific format, application protocols for ports must follow a specific format, etc.\n5. **Service**: No deployments exposing the same ports as the service found, etc.\n6. **VirtualService**: Routes with target weights do not have a valid service, virtual services pointing to non-existent gateways, etc.\n\n## Common Istio Configuration Errors Examples\n\nIn daily use of Istio, here are some of the most common configuration errors:\n\n1. **Virtual services pointing to non-existent gateways**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n      gateways:\n        - non-existent-gateway\n    \u0060\u0060\u0060\n    In this case, the \u0060details\u0060 virtual service tries to route through a non-existent \u0060non-existent-gateway\u0060, leading to traffic management failure.\n\n2. **Virtual services referencing non-existent service subsets**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n    \u0060\u0060\u0060\n    If the \u0060details\u0060 service does not define the corresponding subsets, requests will be rejected due to not finding the correct service instances.\n\n3. **Gateways not finding specified server credentials**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: Gateway\n    metadata:\n      name: cert-not-found-gateway\n      namespace: bookinfo\n    spec:\n      selector:\n        istio: ingressgateway\n      servers:\n        - port:\n            number: 443\n            name: https\n            protocol: HTTPS\n          tls:\n            mode: SIMPLE\n            credentialName: \u0022not-exist\u0022\n    \u0060\u0060\u0060\n    This will lead to a TLS handshake failure because the specified credential \u0060not-exist\u0060 does not exist.\n\n## Configuration Verification\n\nTo reduce the risk of service disruptions due to configuration errors, configuration verification has become indispensable. Configuration verification can be divided into the following two types:\n\n- **Static Configuration Verification**: Verify configurations before they are applied to the system. This includes checking for syntax errors, completeness, and validity of configuration items.\n- **On-demand Configuration Verification**: Verify configurations that have already been applied but may need adjustments based on real-time data. This type of verification helps adapt to changes in dynamic environments, ensuring the ongoing correctness of configurations.\n\n### Recommended Configuration Verification Tools\n\n#### \u0060istioctl validate\u0060\n\n\u0060istioctl validate\u0060 is used to verify the syntax and basic structure of Istio configuration files (such as YAML files), ensuring that the configuration files comply with the Istio API specifications. It can detect syntax and format errors before configurations are applied to the cluster. This is a static analysis tool, often integrated into the CI process, to prevent invalid configuration files from being applied to the cluster.\n\n#### \u0060istioctl analyze\u0060\n\n[\u0060istioctl analyze\u0060](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/istioctl-analyze\/) is a powerful diagnostic tool used to analyze the operational state and consistency of configurations in an Istio cluster. It not only checks the syntax of configuration files but also examines the configurations applied in the cluster to identify potential problems and conflicts. \u0060istioctl analyze\u0060 provides dynamic analysis capabilities, capable of identifying configuration errors and potential issues during cluster operation.\n\nThe configuration process for \u0060istioctl analyze\u0060 is as follows:\n\n1. **Collect Configuration Data**: First, \u0060istioctl analyze\u0060 collects Istio configuration data from specified sources. These sources can be an active Kubernetes cluster or local configuration files.\n2. **Parse and Build Model**: The tool parses the collected configuration data and builds an internal model representing Istio configurations.\n3. **Apply Analysis Rules**: Subsequently, it applies a set of predefined rules to analyze this model, detecting potential configuration issues. These rules cover a range of potential issues from security vulnerabilities to performance problems.\n4. **Generate Report**: After the analysis is complete, \u0060istioctl analyze\u0060 outputs a detailed report containing all identified issues. If no issues are found, it informs the user that the configurations appear to be correct.\n\nThe following is a workflow diagram of \u0060istioctl analyze\u0060:\n\n\u0060\u0060\u0060mermaid istioctl analyze Workflow Diagram\nflowchart TD\n    A[Start] --\u003e B[Select Configuration Source]\n    B --Local Files--\u003e C[Load Local Configuration Files]\n    B --Live Cluster--\u003e D[Connect to Kubernetes Cluster]\n    B --Both--\u003e E[Combine Local Files and Cluster Configurations]\n    C --\u003e F[Parse Configuration Data]\n    D --\u003e F\n    E --\u003e F\n    F --\u003e G[Build Internal Configuration Model]\n    G --\u003e H[Apply Analysis Rules]\n    H --\u003e I{Find Issues?}\n    I --Yes--\u003e J[Generate Issue Report]\n    I --No--\u003e K[Output Configuration Okay]\n    J --\u003e L[End]\n    K --\u003e L\n\u0060\u0060\u0060\n\n![istioctl analyze Workflow Diagram](4eb4d5bbb7c8856d609944835aa03993.svg)\n\n#### Kiali\n\n[Kiali](https:\/\/kiali.io) is a crucial tool for managing and visualizing Istio service meshes, providing real-time insights into the mesh\u0027s health, performance, and configuration status. By integrating Kiali into your Istio environment, you can enhance configuration security through:\n\n- **Visualization**: Kiali offers a graphical representation of the service mesh, making it easier to spot configuration errors, such as incorrect routing or missing policies.\n- **Validation**: It helps validate Istio configurations, highlighting issues such as misconfigured gateways or destination rules before they cause problems.\n- **Security Insights**: Kiali provides visibility into security policies, ensuring that mTLS and authorization settings are correctly implemented.\n\nUsing Kiali alongside tools like \u0060istioctl validate\u0060 and \u0060istioctl analyze\u0060 ensures a more robust approach to preventing and resolving Istio configuration errors, contributing to a secure and efficient service mesh.\n\n## Introduction to TIS\u0027s Config Analyzer Tool\n\nTo help developers and operations staff avoid common configuration mistakes, Tetrate developed the [Config Analyzer](https:\/\/docs.tetrate.io\/istio-subscription\/dashboard\/analyzers\/config) tool in the TIS Dashboard. This tool automatically verifies Istio configurations, analyzes service mesh configuration issues based on best practices, and provides optimization suggestions. Config Analyzer can automatically detect configuration issues in the Istio service mesh, offering explanations and solutions, and supports on-demand error detection in configurations.\n\n![TIS Config Analyzer can detect configuration issues on-demand](config-validate.png)\n\n## Conclusion\n\nProperly configuring Istio is key to ensuring the healthy operation of the service mesh. By understanding and avoiding common configuration errors, and using advanced tools like Tetrate\u0027s TIS Config Analyzer, you can ensure the stability and security of your Istio environment. Remember, a small configuration error can lead to a failure of the entire service mesh, making continuous monitoring and auditing of configurations very necessary.\n\n## References\n\n- [Validation - kiali.io](https:\/\/kiali.io\/docs\/features\/validations\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-configuration-security-how-to-avoid-misconfigurations\/).*\n', '\/en\/blog\/istio-configuration-safety-common-misconfigurations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore common Istio configuration errors and their solutions to enhance the security and stability of your service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/kubecon-china-2024-recap/">KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/cloud-native"> 
             Cloud Native
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology', 'A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio\u0027s Ambient mode and API gateways and their profound impact on the industry.', '\nThis year\u0027s [KubeCon China](https:\/\/events.linuxfoundation.org\/kubecon-cloudnativecon-open-source-summit-ai-dev-china\/) marked its first-ever occurrence in Hong Kong, spanning three days. As a participant and a panel moderator, I will share in this article the highlights of the conference and the in-depth discussions on service meshes and gateway technologies.\n\n![KubeCon China Scene](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-hall.webp)\n\n## Key Themes\n\nThis edition of KubeCon introduced a theme on AI and developers, here are some of the focal points:\n\n1. **Practical Applications of Cloud Native Technologies in Industries**: Especially in the electric vehicle and cybersecurity sectors, such as the joint discussion by Huawei and NIO on how cloud native technologies can accelerate innovation in electric vehicles.\n\n2. **The Power of the Kubernetes Community**: Detailed discussions on the influence of China\u0027s Kubernetes community and its role in advancing regional cloud native activities.\n\n3. **The Integration of Open Source Technology and Artificial Intelligence**: Discussions on the advanced position of China and Hong Kong in the fields of open source and AI technologies and how these are driving regional technological innovation and development.\n\n4. **Latest Developments in Service Meshes and API Gateways**: Including updates on service mesh technologies and how they work in conjunction with Kubernetes schedulers to enhance system throughput.\n\n5. **New Strategies for Supply Chain Security**: Focusing on the latest developments in securing supply chains, particularly practical guidelines on SLSA compliance.\n\n6. **Multicluster Management and Edge Computing**: Discussions on strategies for effective management and innovation across different architectures and systems.\n\n7. **Optimization of AI Large Model Inference Performance**: Discussion on performance acceleration in serverless architectures for AI large model inference and related technological advancements.\n\n## Istio and Modern API Gateways: Exploring the Future of Service Meshes\n\nIn a [roundtable discussion](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYY6\/istio-and-modern-api-gateways-navigating-the-future-of-service-meshes-istiorejiong-apijie-daepqiu-jie-zha-jimmy-song-jianpeng-he-tetrate-jiaqi-zhang-alibaba-cloud-jintao-zhang-kong-inc-xunzhuo-liu-tencent) that I participated in with industry leaders from Tetrate, Alibaba Cloud, and Kong Inc., we delved deeply into the latest developments and integrations of Istio and API gateways.\n\n![KubeCon China 2024 Istio and Modern API Gateways Panel](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-panel.webp)\n\n1. **Innovations in Istio**: We discussed the latest version update of Istio (Istio 1.123) and key features such as optimizations in the Ambient mode, a new architectural choice that reduces resource consumption while enhancing performance.\n\n2. **Practical Comparison Between Ambient and Sidecar Modes**:\n   - **When to Choose Sidecar**: When high isolation and detailed traffic management are required.\n   - **When to Choose Ambient**: When pursuing ultimate performance and resource efficiency.\n\n3. **Challenges in the Development of Ambient Mode**: Despite its advantages, Ambient mode still faces challenges in complex traffic management and multi-tenant environments.\n\n4. **Service Mesh Optimization Strategies**: Discussing methods to enhance the performance and efficiency of cloud applications through service mesh improvements.\n\n5. **Integration of Service Meshes and API Gateways**: Demonstrating how these two technologies work together to support more complex deployment and operational modes.\n\n## Future Perspectives on Istio\n\nIn the [presentation by Zhonghu Xu and Jianpeng He](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcG\/what-is-the-future-of-service-mesh-sidecar-or-sidecarless-jie-zha-dyagsyi-wu-pi-yi-wu-zhonghu-xu-huawei), we gained insights into the possible future directions of Istio:\n\n- **Dual Mode Drive**: Istio is likely to support both the Ambient mode and the traditional Sidecar mode simultaneously. Ambient mode suits users seeking performance and cost optimization, while the Sidecar mode will continue to support users requiring comprehensive functionalities.\n\n- **Support for Gateway API**: Istio\u0027s support for the Gateway API provides users with more flexible routing and policy configuration options.\n\n- **Application of Waypoints Strategies**: Waypoints need not be limited to Istio or Envoy. Using the Gateway API and GAMMA, any standard-compliant implementation can serve as a Waypoint, offering greater flexibility and scalability for service meshes.\n\n### Sandwich Waypoint\n\nThey emphasized the Sandwich Waypoint, which supports:\n\n- **Traffic Redirection**: By setting the \u0060istio.io\/use-waypoint: {namespace}\/{gateway-name}\u0060 annotation, traffic to a target service, pod, or within a namespace can be redirected to the same Waypoint.\n- **Waypoint Deployment**: Users can deploy a Waypoint by creating a Gateway object. Unlike the original implementation of Waypoint, the new deployment method will include associated services and service accounts, not just the Waypoint instance.\n- **Routing and Policy Configuration**: Using the Gateway API for routing and policy configuration provides more customization options for users and providers.\n\nThis represents a mode in Istio\u0027s Ambient mode for capturing layer 7 traffic, as illustrated below.\n\n![Sandwich Waypoint Traffic Capture](istio-ambient-traffic-capture.svg)\n\nThe steps for capturing layer 7 traffic with Istio Sandwich Waypoint are as follows:\n\n1. Terminate the HBONE connection via zTunnel, arriving at the Waypoint, with zTunnel responsible for decoding the HBONE protocol.\n2. Waypoint extracts destination addresses, source addresses, etc., to handle traffic and determine forwarding locations.\n3. Waypoint expands or parses the transport layer encapsulation (TLV) data, with proxies supporting TLV processing to provide additional context.\n4. Waypoint communicates with the peer zTunnel, coordinating with the server-side zTunnel to ensure correct traffic transfer.\n5. Encapsulate HBONE, sent by the server-side zTunnel to the final server destination, achieving fine-grained traffic management and routing in an Istio environment while maintaining compatibility with existing network protocols.\n\n## Cutting-Edge Extensions in Envoy Gateway\n\nIn a [presentation](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcX\/gateway-api-and-beyond-introducing-envoy-gateways-gateway-api-extensions-jie-api-daeptao-envoyjie-zha-jie-api-huabing-zhao-tetrate) at KubeCon, Huabing Zhao discussed how Envoy Gateway enhances its capabilities and flexibility by extending the Kubernetes Gateway API, covering a wide range of matching and routing capabilities, new resource and policy models, and details of security policies.\n\n- **Gateway API Compatibility**: Envoy Gateway is fully compatible with the Gateway API and offers a wide range of matching and routing options. These include HTTP host and path matching, HTTP header-based operations, weighted load balancing, and support for gRPC, UDP, and TCP routing.\n- **Policies for Advanced Traffic Management:** The introduction of ClientTrafficPolicy and BackendTrafficPolicy provides users with more granular control over traffic management for both upstream and downstream connections, including features such as rate limiting, retries, load balancing, circuit breakers, and more.\n- **Enhancement of Security and Authentication**: The introduced SecurityPolicy supports CORS, HTTP basic authentication, OIDC, JWT authentication, and can integrate with various identity providers. It also provides detailed access control, allowing authorization based on the requester\u0027s original IP, JWT claims, etc.\n- **Expanding Functionality with Custom Extensions:** Envoy Gateway offers support for custom extensions through WASM (WebAssembly) and external process extensions. This allows users to enhance the gateway’s functionality by integrating their own customized extensions, tailored to specific use cases and operational needs.\n- **Future Exploration**: Future versions are expected to support non-Kubernetes environments deployment, optimize memory usage in the control plane, and expand authorization capabilities.\n\n## Conclusion\n\nThrough this conference, we gained insights into Istio\u0027s Ambient mode and the developments in Envoy Gateway. The discussions on these technologies not only forecast future trends but also provided practical insights to facilitate the implementation and innovation of technologies.', '\/en\/blog\/kubecon-china-2024-recap\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio&#39;s Ambient mode and API gateways and their profound impact on the industry.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-integration-istio-mesh/">Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh', 'This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.', '\n[Istio](https:\/\/istio.io) provides robust and flexible support for ingress gateways, utilizing the Envoy proxy in its sidecar mode. While Istio focuses on managing communication between services within a cluster, [Envoy Gateway](https:\/\/gateway.envoyproxy.io) is designed to expose applications to the external world, handle user requests, and support advanced features such as OIDC single sign-on. By combining the capabilities of the Istio service mesh with the advanced gateway features of Envoy Gateway, overall application accessibility and security can be enhanced.\n\nThe following diagram illustrates the traffic path of the ingress gateway in the Istio mesh.\n\n![Istio Ingress Gateway Traffic Path](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-ingress-sidecar.svg)\n\nThe next diagram shows how traffic flows from the edge of the Istio mesh into the internal network after introducing the Envoy Gateway.\n\n![Traffic Path After Introducing Envoy Gateway](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-teg-integration.svg)\n\n### Preparing for Interoperability between Envoy Gateway and Istio\n\nTo use Envoy Gateway as an ingress gateway for Istio, consider the following key points:\n\n- Avoid enabling the Ingress Gateway during Istio installation. We\u0027ll manually install and configure Envoy Gateway as the ingress gateway.\n- Since both Istio and Envoy Gateway use Envoy as a proxy, ensure Istio injects the Envoy sidecar into the Envoy Gateway\u0027s gateway pods to allow secure communication with Istio\u0027s data plane.\n- Configure the routing type of the Envoy proxy created by Envoy Gateway as \u0060Service\u0060 instead of \u0060Endpoint\u0060 to ensure proper routing.\n\nFollow the [quick start documentation](https:\/\/gateway.envoyproxy.io\/docs\/tasks\/quickstart\/) to install Envoy Gateway. Label the namespace of the Envoy Gateway to ensure the data plane gets the Istio sidecar injection:\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\nConfigure the Envoy Gateway\u0027s sidecar to not intercept incoming gateway traffic. The injected sidecar ensures that the components of Envoy Gateway and its created proxies are included in the Istio mesh and mount the correct certificates for secure communication.\n\n{{\u003cinclude_code file=\u0022control-plane-tls.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\nConfigure Envoy Gateway to not intercept inbound traffic:\n\n{{\u003cinclude_code file=\u0022teg-sidecars-no-inbound.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\nModify the GatewayClass configuration to apply the sidecar configuration to all \u0060EnvoyProxy\u0060 in the Envoy Gateway data plane:\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### Installing Istio\n\nDeploy Istio using the minimal profile to avoid deploying the Ingress Gateway:\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### Restarting the Envoy Gateway Control Plane\n\nWith Istio\u0027s sidecar injection ready, restart all Envoy Gateway control plane pods:\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis;\n\tdo kubectl rollout restart deployment -n envoy-gateway-system $d; done\n\u0060\u0060\u0060\n\n### Deploying a Test Application\n\nDeploy test applications after installing Istio to ensure they also receive sidecar injections:\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### Configuring Envoy Gateway\n\nNow configure the Envoy Gateway to handle edge traffic:\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\nDeploy the application gateway, which includes the following containers:\n\n- \u0060istio-init\u0060: Injected by Istio to modify pod iptables.\n- \u0060envoy\u0060: Controlled by Envoy Gateway, acting as the ingress gateway.\n- \u0060istio-proxy\u0060: Injected by Istio, responsible for communication with internal cluster pods.\n- \u0060shutdown-manager\u0060: Controlled by Envoy Gateway, responsible for pod lifecycle management.\n\nCreate an HTTP route:\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\nApply the route configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### Sending a Test Request\n\nGet the load balancer IP address of the gateway and send a test request:\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\nYou should see a correct response from the \u0060httpbin\u0060 service:\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### Enabling Strict mTLS\n\nEnable strict mTLS by applying the following configuration:\n\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n\n### Enabling TLS for the Gateway\n\nCreate the root certificate and private key for service signing:\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\nCreate the certificate and private key for \u0060www.example.com\u0060:\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nCreate a secret for the ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential --key=example_certs\/www.example.com.key --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nConfigure the ingress gateway:\n\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\nSend a test request:\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\nYou should be able to access the \u0060httpbin\u0060 service within the mesh via HTTPS.\n\n### Conclusion\n\nBy integrating Envoy Gateway as an ingress gateway in your Istio service mesh, you can leverage the best of both worlds: Istio\u0027s robust service mesh capabilities and Envoy Gateway\u0027s advanced gateway features. This setup enhances the security, scalability, and flexibility of your applications, providing a seamless and secure user experience. With careful configuration and the right tools, managing traffic in and out of your service mesh becomes more efficient and effective, ensuring your applications are always accessible and secure. \n', '\/en\/blog\/envoy-gateway-integration-istio-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 10, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Securing Istio: Addressing Critical Security Gaps and Best Practices', 'Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.', '\n## Introduction\n\nRecently, the Wiz research team released a [blog post](https:\/\/www.wiz.io\/blog\/sapwned-sap-ai-vulnerabilities-ai-security) that uncovered tenant isolation vulnerabilities in AI services, generating widespread attention. This study detailed security flaws across several AI service providers, particularly the SAP AI Core platform. Researchers were able to execute arbitrary code through legitimate AI training processes, subsequently moving laterally to take over services and gain access to customers’ private files and cloud credentials. These findings highlight the challenges that cloud services and management platforms face in ensuring isolation and sandbox environments.\n\nIn this context, Istio, as a crucial service mesh solution, faces similar security issues, especially in key functionalities like sidecar injection and traffic management. This blog aims to discuss how to protect the security of the Istio service mesh and provide a comprehensive set of mitigation measures. We will also discuss how multi-layer security strategies can effectively enhance Istio\u0027s security to address challenges mentioned in the Wiz report.\n\n## Overview\n\nIstio primarily manages east-west traffic within Kubernetes, offering detailed traffic management features such as request routing, load balancing, and fault recovery policies. While Istio offers essential security features such as traffic encryption, authentication, and authorization, it should not be viewed as a standalone firewall solution. To maintain robust security for services within the Istio mesh, it is crucial to complement Istio\u0027s security capabilities with additional measures from the underlying network and infrastructure, such as Container Network Interface (CNI) plugins and secure container implementations.\n\nWhether in Sidecar or Ambient mode, traffic is hijacked from application pods to data plane proxies for processing and forwarding. If application traffic is not successfully intercepted or is impersonated by a rogue application masquerading as Istio, security vulnerabilities can arise.\n\nThe diagram below illustrates where security vulnerabilities due to bypassing or impersonating Istio system users might occur.\n\n![\u0022Security vulnerabilities\u0022 in bypassing Istio\u0027s traffic hijacking](bypass-sidecar-traffic-hijack.svg)\n\nNext, we will explore specific situations where \u0022security vulnerabilities\u0022 arise and the strategies to address them.\n\n## Bypassing Istio Sidecar Injection\n\n### At the Namespace Level\n\n- **Scenario**: Application teams misuse namespace labels to disable Istio Sidecar injection at the namespace level.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes namespace resources.\n- **Monitoring**: Use policy engines (like OPA Gatekeeper) to ensure compliance with namespace labels, and regularly review namespace configurations.\n\n### At the Pod Level\n\n- **Scenario**: Application teams misuse Pod labels to disable Istio Sidecar injection at the Pod level.\n- **Mitigation Strategy**:\n  - Force all Pods to specify a UID that is not 1337.\n  - Inspect all container images to check for UID 1337 and reject those images. This inspection can be performed using an admission webhook or by a central team managing the image registry.\n- **Monitoring**: Employ Admission Webhooks to enforce Sidecar injection, prohibit exclusion labels, and regularly scan and audit all pods to ensure every required pod has a Sidecar injected.\n\n## Bypassing Traffic Redirection to Istio Sidecar\n\n### Misuse of Traffic Redirection Annotations\n\n- **Scenario**: Application teams misuse Pod annotations to exclude certain inbound or outbound ports or IPs, thereby bypassing traffic redirection.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Use policy engines to detect and alert on non-compliant annotation use, regularly review Pod annotations.\n\n### Misuse of Pod UID\n\n- **Scenario**: Application teams misuse UID 1337 (the ID of the sidecar proxy) to bypass Istio\u0027s Iptables redirection rules.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Prohibit or restrict the use of UID 1337, regularly audit Pod UID configurations to ensure no bypassing occurs.\n\n### Misuse of Pod Capabilities (NET_ADMIN, NET_RAW)\n\n- **Scenario**: Application teams misuse NET_ADMIN and NET_RAW capabilities to remove Istio Iptables rules.\n- **Mitigation Strategy**: Platform teams enable Istio CNI (to avoid granting elevated privileges to application teams) and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Regularly review and monitor Pod permission configurations to ensure no over-privileged actions are taken.\n\n## Bypassing Inbound Traffic Constraints\n\n### Misuse of PeerAuthentication\n\n- **Scenario**: Application teams create a PeerAuthentication resource for each namespace\/workload, enabling the PERMISSIVE authentication mode.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio PeerAuthentication resources.\n- **Monitoring**: Regularly review PeerAuthentication configurations to ensure all inbound traffic is encrypted as required.\n\n## Bypassing Outbound Traffic Constraints\n\n### Misuse of ServiceEntry\n\n- **Scenario**: Application teams create a ServiceEntry to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio ServiceEntry resources.\n- **Monitoring**: Regularly review ServiceEntry configurations to ensure no bypassing occurs.\n\n### Misuse of ExternalName Services\n\n- **Scenario**: Application teams create a Kubernetes Service of type ExternalName to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Kubernetes Service resources.\n- **Monitoring**: Regularly review the types of Kubernetes Service configurations to ensure no bypassing occurs.\n\n## Uncontrollably Changing Istio Sidecar Configuration\n\n### Misuse of Sidecar Resources\n\n- **Scenario**: Application teams create an Istio Sidecar resource for each workload and set the \u0060outboundTrafficPolicy\u0060 field to \u0060ALLOW_ANY\u0060 (overriding the possible global value \u0060REGISTRY_ONLY\u0060).\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio Sidecar resources.\n- **Monitoring**: Regularly review Sidecar resource configurations to ensure no global settings are overridden.\n\n### Misuse of EnvoyFilter\n\n- **Scenario**: Application teams create an EnvoyFilter that conflicts with existing Istio objects, potentially causing DoS attacks or violating security policies.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio EnvoyFilter resources.\n- **Monitoring**: Regularly review EnvoyFilter configurations to ensure no improper use occurs.\n\n## Service Mesh as Part of a Layered Defense\n\nThe service mesh is described as a supplemental layer to existing security models, enhancing microservice security by adding finer-grained security policies on top of traditional security controls. However, the article emphasizes that service meshes cannot independently ensure comprehensive security for microservices but should be part of an overall security strategy.\n\n![Microservices security layered architecture](security-layers.svg)\n\nService meshes primarily manage and control network traffic by deploying a lightweight proxy (sidecar) next to each service instance. This allows for precise traffic control and policy enforcement at the network level, such as traffic encryption, authentication, and authorization. Although service meshes offer features like traffic control, service discovery, and circuit breakers, these are essentially management of network traffic and are not sufficient to address all security issues. For instance, they cannot replace traditional security measures like application layer firewalls, intrusion detection systems, and data security.\n\nFurthermore, service meshes rely on correct configuration and management, and improper configuration can lead to security vulnerabilities. Therefore, while service meshes are an indispensable part of modern microservices architectures, they should be combined with traditional security measures to form a comprehensive, multi-layered security strategy framework. Refer to [How Service Mesh Layers Microservices Security with Traditional Security to Move Fast Safely](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) for further insights on strengthening service mesh security.\n\n## Long-term Solutions and Community Collaboration\n\nThe Istio community conducts a security audit almost every year, see the results from [2021](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/) and [2022](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/). From these results, we can see that Istio\u0027s security posture has greatly improved. Ensure that your Istio service mesh adheres to [security best practices](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/). Additionally, keep an eye on the [Istio CVE Bulletins](https:\/\/istio.io\/latest\/news\/security\/) or use tools like [Tetrate Istio Subscription](https:\/\/tetrate.io\/tetrate-istio-subscription\/) that can scan for various CVEs in the Istio service mesh, deploying Istio versions that are FIPS compliant and FIPS certified.\n\n## Conclusion\n\nService meshes provide an additional layer of security for microservices architectures by managing control flows outside of the applications. This allows for enhanced communication security between services without impacting application performance. When deploying service meshes, it is recommended to use Istio’s Egress Gateway to manage outbound traffic, in conjunction with Kubernetes\u0027 NetworkPolicy, to ensure all outbound traffic must pass through the gateway, thus preventing potential data leaks and other security threats.\n\n## References\n\n- [How to enforce egress traffic using Istio’s authorization policies - tetrate.io](https:\/\/tetrate.io\/blog\/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies\/)\n- [Istio Security Best Practice - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n- [Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io](https:\/\/tetrate.io\/blog\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/)\n- [Istio publishes results of 2022 security audit - istio.io](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/)\n- [Announcing the results of Istio’s first security assessment - istio.io](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)\n', '\/en\/blog\/securing-istio-addressing-critical-security-gaps-and-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Migrate from Kubernetes Ingress to the Gateway API', 'This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.', '\nWith the release of Istio 1.22, the Istio API has officially been upgraded to version v1, coinciding with the update of the Kubernetes Gateway API to v1.1. This article aims to explore the connections and differences between the Ingress API, Istio API, and Kubernetes Gateway API, detailing their selection and migration strategies in practical applications.\n\n## Introduction\n\nPreviously, I wrote an article discussing [Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh](\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/). The article pointed out that as Kubernetes\u0027 original ingress gateway, Ingress\u0027s resource model is too simple to meet the demands of today\u0027s programmable networks. As its successor, the Gateway API has rapidly developed in recent years and has gained broad support, including many emerging open-source gateway projects like [Envoy Gateway](https:\/\/gateway.envoyproxy.io) choosing to develop based on the Gateway API. Additionally, some legacy gateway projects have started adapting to the Gateway API or using tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) to migrate.\n\nThe Gateway API, as the latest achievement in Kubernetes ingress gateways, separates concerns through role division and supports cross-namespace capabilities, making it more suitable for multi-cloud environments. It integrates the overlapping functions of ingress gateways (north-south) and service meshes (east-west, intra-cluster routing) to provide a new reference model for unified traffic management in the cloud-native era.\n\nIngress API, Gateway API, and Istio API can all implement gateway functions, but what are the connections and differences between them? This article will unveil this mystery and provide strategies for selecting and migrating gateways in Kubernetes environments.\n\n## Kubernetes Traffic Management\n\nWith the widespread adoption and increasing complexity of microservice architectures, Kubernetes\u0027 traffic management tools have also evolved to meet various technical needs. The Ingress API, Istio API, and Kubernetes Gateway API each represent different stages of this evolution.\n\n**Ingress API** offers basic traffic management capabilities in Kubernetes, allowing users to manage external access to services within the cluster through simple routing rules (e.g., HTTP and HTTPS). Although its design is straightforward, its functionality is limited and mainly suitable for smaller-scale, less complex applications.\n\nIn contrast, **Istio API**, as part of a service mesh, offers a range of advanced traffic management features, such as traffic mirroring, canary releases, and circuit breakers, suitable for large-scale microservice architectures requiring complex traffic management.\n\nTo overcome the limitations of the Ingress API and integrate advanced features similar to those of Istio, the **Kubernetes Gateway API** was developed. It not only provides greater flexibility and extensibility in its design but also, through broad community support, serves as a bridge connecting traditional Ingress implementations and modern service mesh technologies like Istio, with most mainstream open-source gateways being based on or adapted to the Gateway API.\n\nThe following table summarizes the core features and recommended use cases for each API:\n\n| API Name      | Object Type                | Status                  | Recommended Use Cases                                       |\n| ------------- | -------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API   | \u0060Ingress\u0060                  | Stable (Kubernetes v1.19)| Suitable for small-scale and simple scenarios, mainly for basic routing configurations |\n| Istio API     | \u0060VirtualService\u0060, \u0060Gateway\u0060| Stable (Istio 1.22)     | Suitable for highly complex microservice architectures, requiring fine-grained control and advanced traffic management features |\n| Gateway API   | \u0060HTTPRoute\u0060, \u0060Gateway\u0060     | Stable (Gateway API v1.1)| Suitable for new or existing deployments that require increased flexibility and scalability, especially when combined with Istio |\n\nThe launch of [Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/), especially its improvements in compatibility with existing Ingress configurations, provides a smooth migration path for users, making the transition from traditional Ingress solutions to more modern, feature-rich Gateway API easier.\n\n## Migrating from Ingress to Kubernetes Gateway API\n\nTo migrate from Ingress to Gateway API, follow these steps:\n\n1. **Understand Key Differences**: Compared to Ingress, the Gateway API introduces several new concepts and resource types, such as \u0060Gateway\u0060, \u0060HTTPRoute\u0060, and \u0060TLSRoute\u0060. These resources offer more configuration options and flexibility; refer to the [Gateway API documentation](https:\/\/gateway-api.sigs.k8s.io\/guides\/) for their configurations.\n2. **Configure Entry Points**: Create \u0060Gateway\u0060 resource configurations, clearly defining how to receive external traffic, including protocols, ports, and TLS terminations.\n3. **Map Old Resources**: Map existing Ingress resources to corresponding Gateway API resources. For example, host and path rules in Ingress need to be converted into route rules in HTTPRoute.\n4. **Test and Deploy**: Before officially migrating, test the new Gateway API configurations in a test environment to ensure all traffic routing is normal and there are no security vulnerabilities.\n\nTo simplify the migration process, you can use tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway), which can automatically convert Ingress configurations into Gateway API formats.\n\n## Practical Migration Example\n\nHere is a simple example of an HTTP gateway configuration demonstrating how to migrate from Ingress to the Gateway API.\n\nAssume you have an existing Ingress configuration as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\nTo migrate it to the Gateway API, first create a Gateway object:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds:\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\nEnsure that the \u0060gatewayClassName\u0060 refers to a valid GatewayClass configured in your cluster. The GatewayClass is usually set by the cluster administrator and provides a resource to configure the Gateway.\n\nNext, create an HTTPRoute resource to define routing rules that route traffic to the backend service:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\nIn this example, we see:\n\n- The rules from the \u0060Ingress\u0060 object are directly mapped to the \u0060HTTPRoute\u0060 object.\n- The hostname matching, path matching, and backend service configurations remain unchanged, but the object and field names differ.\n\n## Considerations and Challenges\n\nAlthough it is possible to migrate from Ingress to Gateway API and potentially run them simultaneously, there are several challenges and considerations for the necessity of migration:\n\n- **Feature Differences**: Certain features specific to some Ingress controllers may not have direct equivalents in the Gateway API, requiring additional configurations or custom resources to achieve similar functionalities.\n- **Multi-Resource Management**: Using the Gateway API may involve managing more resource types and complex configurations than Ingress, potentially increasing the complexity of administration.\n\nFor existing users of Ingress and Istio API, whether to migrate to the Gateway API depends on specific circumstances. Here are some migration recommendations:\n\n- **For New Deployments**: It is advisable to use the Gateway API directly to take advantage of its advanced features and anticipate future developments.\n- **For Existing Deployments**: If the existing system operates stably and does not require advanced features, you can continue using the current APIs. If you seek to leverage new features of the Gateway API or plan for long-term development, a gradual migration is a prudent choice.\n\nFor the support status of different gateways for the Gateway API, refer to the [Gateway API Implementation Conformance Report](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/) for more details.\n\n## Conclusion\n\nThe Ingress API, Istio API, and Kubernetes Gateway API each have distinct features suitable for different application scenarios and needs. Selecting the appropriate API and planning and managing effectively can significantly enhance system flexibility and stability. As the Gateway API continues to develop and mature, it is increasingly becoming the mainstream choice for future traffic management.\n\nChoosing the right gateway technology, combined with your specific needs and existing architecture, can better manage and optimize traffic to ensure efficient and stable application operation. As technology progresses and the community evolves, the Gateway API provides a powerful and flexible framework, making the transition from traditional Ingress to more modern solutions simpler and more effective.\n\n## References\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/kubernetes-ingress-to-gateway-api-migration\/).*', '\/en\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/blog/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/blog/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/page/8/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(46)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-tracing/">How the Envoy Proxy Handles User Requests for Tracing</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
