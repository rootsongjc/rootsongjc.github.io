<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Blog - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog Posts">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/blog/" />
  <meta property="og:title" content="Blog | Jimmy Song" />
  <meta property="twitter:title" content="Blog | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog Posts" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog Posts" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/trans/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Blog
                </p>
                <p class="page-description">
                    Jimmy Song&rsquo;s Blog Posts
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-packet-lifecycle-optimization/">Packet Lifecycle and Traffic Optimization in Istio Ambient Mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 29, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Packet Lifecycle and Traffic Optimization in Istio Ambient Mode', 'An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.', '\nThis article provides an in-depth analysis of the packet lifecycle in Istio Ambient Mode. It covers everything from the interception and target resolution of initial packets to the fast forwarding and optimization strategies for subsequent packets, helping readers better understand the technical logic and performance practices behind Ambient Mode.\n\n## Overview of Packet Lifecycle: From Kernel Space to User Space\n\nIn Ambient Mode, packet processing starts in the kernel space network stack of a Pod, where packets are intercepted by iptables rules and then processed by zTunnel in user space. zTunnel handles tasks such as transparent proxying, policy enforcement, and encrypted tunnel creation. Packets are then sent back to the kernel space network for forwarding to the target service or another zTunnel. The core idea is to analyze and tag the first packet in detail to pave the way for subsequent packets, thereby reducing redundant overhead.\n\nThe diagram below illustrates the packet lifecycle from a Pod to zTunnel in Istio Ambient Mode.\n\n\u0060\u0060\u0060mermaid \u0022Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel\u0022\nsequenceDiagram\n    participant App as Application\n    participant PodKernel as Pod Kernel-Space Network Stack\n    participant ipt as iptables\n    participant ztunnel as ztunnel User-Space Processing\n    participant HostKernel as Host Kernel-Space\n    participant Service as Destination Service or Next ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: Initial Packet Path\n    App-\u003e\u003ePodKernel: Sends the first packet\n    PodKernel-\u003e\u003eipt: Checks iptables redirection rules\n    ipt-\u003e\u003eztunnel: Redirects packet to zTunnel transparent proxy port\n    ztunnel-\u003e\u003eztunnel: Extracts destination address \u0026 policy validation \u0026 establishes tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the processed packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: Subsequent Packet Path\n    App-\u003e\u003ePodKernel: Sends subsequent packets\n    PodKernel-\u003e\u003ePodKernel: Matches existing connection using conntrack\n    PodKernel-\u003e\u003eztunnel: Packet directly enters ztunnel inbound socket (no iptables redirection needed)\n    ztunnel-\u003e\u003eztunnel: No need for re-parsing \u0026 reuses existing tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\u0060\u0060\u0060\n\n![Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel](0af66a9ca6d1db3f9e14e2e19e3210fb.svg)\n\nThe following sections will detail the processing paths for both the first packet and subsequent packets, analyzing the technical highlights and optimization strategies.\n\n## First Packet Path: From Interception to Destination Resolution\n\n### Initial Packet Emission\n\nWhen an application in a Pod emits a packet (e.g., an HTTP request), the packet is first processed by the Pod’s network namespace and kernel space network stack.\n\n### Transparent Interception via Iptables\n\n*iptables* rules filter outbound traffic. If the destination address is non-local and the packet lacks specific tags, it is redirected to zTunnel’s transparent proxy port (e.g., 15006 or 15008). Using *IP_TRANSPARENT* and *SO_ORIGINAL_DST* options, zTunnel can extract the packet’s original destination address in user space. This ensures transparent proxying for services located on the same node, across nodes, or outside the mesh.\n\n### Policy Validation and Processing in zTunnel User Space\n\nOnce in zTunnel, the first packet undergoes policy and security checks such as RBAC validation and mTLS encryption determination. For in-mesh traffic, an HTTP\/2 CONNECT tunnel (HBONE) is established for encrypted cross-node communication. For out-of-mesh traffic, direct TCP transmission is used.\n\n### Packet Egress and Connection Establishment\n\nAfter processing, zTunnel establishes an outbound socket (e.g., HTTP\/2 tunnel or plaintext TCP connection) based on the packet’s parsed details, sends it back to the kernel space, and routes it to the target service or zTunnel.\n\nAt this point, the first packet has completed a full journey from kernel space to user space and back. Connection states, policies, and tunnel information are recorded to optimize subsequent packets.\n\n## Subsequent Packet Path: Fast Forwarding with Conntrack and Tunnel Reuse\n\nOnce the first packet completes destination resolution and policy validation, the Linux kernel’s connection tracking (conntrack) records the connection state and tags it. Subsequent packets belonging to the same connection bypass complex iptables redirection and destination resolution, directly reaching zTunnel’s inbound socket.\n\n### Role of Conntrack\n\n*conntrack* tracks existing connections, providing a fast path for subsequent packets. This allows packets to be forwarded directly to zTunnel without repeatedly triggering *iptables* rules or undergoing policy checks.\n\n### Inbound Socket and User Space Processing\n\nSubsequent packets entering zTunnel’s inbound socket are directly identified by connection tags, skipping complex RBAC validation or encryption decisions. If an encrypted tunnel (HBONE) was established for the first packet, subsequent packets reuse this tunnel. For plaintext traffic, the existing TCP connection is used for direct transmission.\n\n### Optimization for Tunnel and Plaintext Paths\n\n- **HBONE Tunnel:** For in-mesh encrypted traffic, HTTP\/2 tunnels enable multiplexing, reducing repeated connection overhead.\n- **Plaintext Socket:** For local or external unencrypted traffic, subsequent packets use the existing plaintext connection, avoiding extra encapsulation.\n\nThese mechanisms greatly simplify the processing path for subsequent packets, improving performance and throughput.\n\n## Key Technical Points and Optimization Strategies\n\n1. **Transparent Proxying:** Using IP_TRANSPARENT and SO_ORIGINAL_DST, zTunnel seamlessly captures and parses non-local traffic, achieving true transparent proxying.\n2. **Efficient Kernel-User Space Switching:** By completing detailed parsing and policy validation for the first packet in user space, and leveraging conntrack and inbound socket mechanisms for subsequent packets, unnecessary context switching is minimized.\n3. **Multiplexed Tunnels:** HTTP\/2 CONNECT tunnels (HBONE) support encryption, load balancing, and multiplexing, enhancing efficiency for subsequent packet forwarding.\n\n## Practical Recommendations and Considerations\n\n- **Multi-Platform Adaptation:** Transparent proxying relies on Linux features. For non-Linux platforms (e.g., Windows, macOS), local proxies or alternative solutions may be required.\n- **Tuning and Observability:** Use zTunnel logs, connection tracking, and mesh observability tools to monitor traffic paths and performance. Fine-tune iptables rules, RBAC policies, and tunnel parameters based on data and results.\n\n## Conclusion\n\nIstio Ambient Mode introduces innovative designs for packet lifecycle and traffic optimization. By performing comprehensive policy parsing and encryption negotiation for the first packet, and leveraging conntrack for fast forwarding of subsequent packets, Ambient Mode strikes a balance between transparent proxying, scalability, and performance.\n\nAs the core component of Ambient Mode, zTunnel combines transparent application experience with underlying network optimization, meeting service mesh security and policy requirements while significantly reducing redundant overhead. This makes traffic processing more efficient and seamless.', '\/en\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 20, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('In-Pod IPtables Rule Injection in Istio Ambient Mode Explained', 'A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.', '\nIn my [previous blog post](\/en\/blog\/istio-ambient-traffic-interception\/), I provided an overview of the iptables rules injected within pod network namespaces in Istio ambient mode. This article takes a closer look at these rules, explaining how they achieve transparent traffic interception and redirection within pods.\n\n## iptables Rules Inside the Pod\n\nIn a pod\u0027s network namespace, the Istio CNI Node Agent sets up a series of iptables rules to enable transparent traffic interception and redirection. The following rules, injected into the \u0060mangle\u0060 and \u0060nat\u0060 tables, demonstrate how Istio processes inbound and outbound traffic.\n\n\u0060\u0060\u0060python\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*mangle\n:PREROUTING ACCEPT [99138:22880045]  # Default ACCEPT policy for the PREROUTING chain in the mangle table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the mangle table.\n:FORWARD ACCEPT [0:0]                # Default ACCEPT policy for the FORWARD chain in the mangle table.\n:OUTPUT ACCEPT [100900:34940164]     # Default ACCEPT policy for the OUTPUT chain in the mangle table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the mangle table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -m connmark --mark 0x111\/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\n# Restore connection mark 0x111\/0xfff for consistent connection tracking.\n\n-A ISTIO_PRERT -m mark --mark 0x539\/0xfff -j CONNMARK --set-xmark 0x111\/0xfff\n# Set connection mark to 0x111\/0xfff for packets marked 0x539\/0xfff in PREROUTING.\n\nCOMMIT  # Apply mangle table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*nat\n:PREROUTING ACCEPT [2:120]           # Default ACCEPT policy for the PREROUTING chain in the nat table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the nat table.\n:OUTPUT ACCEPT [119:9344]            # Default ACCEPT policy for the OUTPUT chain in the nat table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the nat table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound NAT traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting NAT traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -d 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic destined for 169.254.7.127 (likely an internal Istio address).\n\n-A ISTIO_OUTPUT -p tcp -m mark --mark 0x111\/0xfff -j ACCEPT\n# Allow TCP traffic marked as 0x111\/0xfff.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -o lo -j ACCEPT\n# Allow traffic to the loopback interface excluding 127.0.0.1.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -p tcp -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15001\n# Redirect outbound TCP traffic (not marked 0x539\/0xfff) destined outside 127.0.0.1 to port 15001 (outbound socket).\n\n-A ISTIO_PRERT -s 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic originating from 169.254.7.127 in the PREROUTING chain.\n\n-A ISTIO_PRERT ! -d 127.0.0.1\/32 -p tcp -m tcp ! --dport 15008 -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15006\n# Redirect inbound TCP traffic (not marked 0x539\/0xfff) to port 15006 (inbound socket) if its destination port is not 15008.\n\nCOMMIT  # Apply nat table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\u0060\u0060\u0060\n\n### Role of Specific Ports\n\nThese iptables rules differentiate and handle various types of traffic using specific ports:\n\n- **15008 (HBONE socket)**: Handles HTTP-based traffic transparently using the HBONE protocol.\n- **15006 (plaintext socket)**: Manages unencrypted traffic within the mesh for inter-pod communication.\n- **15001 (outbound socket)**: Controls outbound traffic and enforces policies for accessing external services.\n\nBy leveraging these ports, Istio enables transparent management and control of inbound, outbound, and internal traffic, enforcing fine-grained security policies and traffic controls. For more information, refer to [Istio Application Requirements](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/application-requirements\/).\n\n### Significance of \u00600x539\u0060 Mark\n\nThe \u00600x539\u0060 mark identifies traffic originating from Istio proxies (e.g., ztunnel). This mark is applied to distinguish packets processed by proxies, ensuring they are not reprocessed or misrouted.\n\n### Significance of \u00600x111\u0060 Mark\n\nThe \u00600x111\u0060 mark is used for connection-level marking within the Istio mesh, indicating that a connection has been processed by a proxy. The \u0060CONNMARK\u0060 module in iptables extends this mark to the entire connection, speeding up subsequent packet matching.\n\n## Visualizing iptables Rules\n\nThe following diagram illustrates the execution path of traffic through iptables rules, helping to understand how traffic is matched and redirected:\n\n\u0060\u0060\u0060mermaid \u0022iptables Rules Visualization\u0022\ngraph TD\nA[Traffic enters pod namespace] --\u003e B{Traffic direction}\nB -- Inbound --\u003e C[PREROUTING chain]\nC --\u003e D[ISTIO_PRERT chain]\nD --\u003e E{Source is 169.254.7.127?}\nE -- Yes --\u003e F[ACCEPT]\nE -- No --\u003e G{Destination is 127.0.0.1?}\nG -- Yes --\u003e F[ACCEPT]\nG -- No --\u003e H{Destination port is 15008?}\nH -- Yes --\u003e F[ACCEPT]\nH -- No --\u003e I{Packet marked 0x539?}\nI -- Yes --\u003e F[ACCEPT]\nI -- No --\u003e J[REDIRECT to port 15006]\nB -- Outbound --\u003e K[OUTPUT chain]\nK --\u003e L[ISTIO_OUTPUT chain]\nL --\u003e M{Destination is 169.254.7.127?}\nM -- Yes --\u003e N[ACCEPT]\nM -- No --\u003e O{Packet marked 0x111?}\nO -- Yes --\u003e N[ACCEPT]\nO -- No --\u003e P{Destination is 127.0.0.1 and output interface is lo?}\nP -- Yes --\u003e N[ACCEPT]\nP -- No --\u003e Q{Packet marked 0x539?}\nQ -- Yes --\u003e N[ACCEPT]\nQ -- No --\u003e R[REDIRECT to port 15001]\n\u0060\u0060\u0060\n\n![iptables Rules Visualization](05fa21587176b2333b3857e039764cd4.svg)\n\nFor further details on how Istio CNI handles iptables, refer to the source code: [istio\/cni\/pkg\/iptables\/iptables.go at master · istio\/istio · GitHub](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/iptables\/iptables.go).\n\n## Routing Visualization for Different Traffic Types\n\nHere are visualized traffic paths for encrypted and plaintext communication across and within nodes:\n\n**Cross-Node Encrypted Traffic**\n\n![Cross-Node Encrypted Traffic Path](cross-node-hbone.svg)\n\n**Cross-Node Plaintext Traffic**\n\n![Cross-Node Plaintext Traffic Path](cross-node-plaintext.svg)\n\n**Same-Node Encrypted Traffic**\n\n![Same-Node Encrypted Traffic Path](same-node-hbone.svg)\n\n**Same-Node Plaintext Traffic**\n\n\n\n![Same-Node Plaintext Traffic Path](same-node-plaintext.svg)\n\n1. **Application Sends Request**: Traffic originates from the application process and enters the pod’s network namespace.\n2. **iptables Rule Matching**:\n   - **Outbound Traffic** matches \u0060OUTPUT\u0060 chain rules, redirecting eligible traffic to the \u0060ISTIO_OUTPUT\u0060 chain.\n   - Matched traffic is marked and accepted.\n3. **REDIRECT Handling**: Traffic is captured and redirected by iptables to ztunnel (port 15006 for plaintext, 15008 for encrypted).\n4. **ztunnel Processing**: ztunnel performs policy enforcement and encryption.\n5. **Traffic Forwarded to Target Service**: Processed traffic is sent to the target service via a built tunnel.\n6. **Response Path**: Responses flow back to ztunnel for decryption and policy checks before reaching the application.\n\n## Conclusion\n\nBy analyzing the iptables rules in Istio ambient mode, we see how Istio’s CNI plugin establishes a transparent traffic interception mechanism within pods. These rules ensure that traffic entering and leaving pods is correctly handled by ztunnel, enabling finer-grained traffic management and security policy enforcement. Stay tuned for more deep dives into Istio ambient mode networking!\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-iptables-rule-injection\/).*', '\/en\/blog\/istio-ambient-inpod-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Detailed Explanation of Transparent Traffic Interception in Istio ambient mode', 'This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.', '\nThis is the first article in my series on Istio ambient mode. In the upcoming posts, I will delve deeper into the key components and their working principles, including how ztunnel forwards traffic to the waypoint proxy, how the waypoint proxy handles the traffic, and a comprehensive analysis of the traffic path using the Bookinfo example. Since traffic interception is the foundation of service mesh functionality, I chose to start with it to provide a solid understanding.\n\nIstio ambient mode is a service mesh implementation that eliminates the need for sidecar injection into each pod. By configuring transparent traffic interception and redirection within the pod\u0027s network namespace, applications can leverage service mesh capabilities without any modifications. The following content provides a detailed explanation of the transparent traffic interception process, covering components such as **Istio CNI Node Agent**, **ztunnel**, **network namespaces**, and **iptables rules**, illustrated with flowcharts and diagrams.\n\n## Background Knowledge\n\n### Linux Network Namespaces\n\n**Network namespaces** are a Linux kernel feature used to isolate the network environment of different processes. Each network namespace has its own network devices, IP addresses, routing tables, and iptables rules. Container technologies (e.g., Docker, Kubernetes) use network namespaces to provide each container (or pod) with an isolated network stack.\n\n### Istio CNI Node Agent\n\n**Istio CNI Node Agent** is a core component of ambient mode that operates on Kubernetes nodes, detecting pods joining the Ambient mesh and configuring traffic redirection rules for these pods. Note that this involves the Istio CNI Node Agent, not the traditional Istio CNI plugin. The Node Agent acts as a daemon working alongside ztunnel but does not directly perform network plugin tasks.\n\n### ztunnel\n\n**ztunnel** is a critical component in ambient mode, running as a DaemonSet on each node. Its responsibilities include:\n\n- Receiving and processing redirected traffic.\n- Enforcing L4 policies such as mTLS encryption and access control.\n- Communicating with the control plane to obtain configurations and certificates.\n\n### HBONE (HTTP-Based Overlay Network Encapsulation)\n\n**HBONE (HTTP-Based Overlay Network Encapsulation)** is a protocol introduced by Istio for transmitting arbitrary TCP traffic between ztunnel and waypoint proxy. HBONE leverages HTTP\/2 and HTTP\/3 multiplexing and encryption features for enhanced communication efficiency and security.\n\n## Detailed Traffic Interception Process\n\nIn ambient mode, application pods require no code changes or sidecar injection. Traffic interception and redirection occur entirely within the **pod\u0027s network namespace**, avoiding conflicts with the underlying CNI. Here’s an overview of the steps involved:\n\n\u0060\u0060\u0060mermaid \u0022Traffic Interception Process in Istio Ambient Mode\u0022\nsequenceDiagram\n    participant Kubelet\n    participant NodeAgent as Istio CNI Node Agent\n    participant podNetns as pod Network Namespace\n    participant ztunnel\n    participant pod as Application pod\n\n    Kubelet-\u003e\u003eNodeAgent: Notify new pod joins the Ambient mesh\n    NodeAgent-\u003e\u003epodNetns: Configure iptables rules\n    NodeAgent-\u003e\u003eztunnel: Pass pod network namespace FD\n    ztunnel-\u003e\u003ePodNetns: Start listening sockets in the pod network namespace\n    Pod-\u003e\u003ePodNetns: Application sends traffic\n    PodNetns-\u003e\u003eztunnel: Traffic redirected to ztunnel\n    ztunnel-\u003e\u003eTarget Service: Forward traffic via tunnel\n    Target Service--\u003e\u003eztunnel: Return response\n    ztunnel--\u003e\u003ePod: Send response back to application\n\u0060\u0060\u0060\n\n![Traffic Interception Process in Istio Ambient Mode](47a0230e39849d8e80ed6ab75bc34ebe.svg)\n\n### Detailed Steps of Traffic Interception\n\n1. **Pod Initialization and Network Configuration**:\n   - When Kubernetes creates a pod, it invokes the underlying CNI plugin (e.g., Calico, Cilium) via the Container Runtime Interface (CRI) to configure the pod’s network.\n   - At this stage, the pod’s network namespace (netns) is established.\n2. **Istio CNI Node Agent Configures Traffic Redirection**:\n   - The Istio CNI Node Agent detects that the new pod is marked for ambient mode (via the label \u0060istio.io\/dataplane-mode=ambient\u0060).\n   - It enters the pod’s network namespace and sets up iptables rules for traffic interception.\n   - The network namespace’s file descriptor (FD) is passed to ztunnel.\n3. **Ztunnel Starts Listening Sockets in Pod Network Namespace**:\n   - ztunnel receives the namespace FD and starts listening sockets within it to handle redirected traffic.\n4. **Transparent Traffic Interception and Processing**:\n   - Traffic originating from the application is intercepted by the iptables rules in the pod and transparently redirected to ztunnel.\n   - ztunnel performs policy checks, encryption, and other processing before forwarding traffic to the target service.\n   - Responses are decrypted by ztunnel and returned to the application.\n\nFor more details about how Istio CNI configures iptables, see my other blog post: [Analyzing iptables Rules in Istio ambient mode](\/blog\/istio-ambient-pod-iptables-injection\/).\n\n## ztunnel Log Analysis\n\nYou can inspect all logs related to traffic interception in ztunnel using the following command, which helps you understand how ztunnel operates:\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system logs -l app=ztunnel | grep -E \u0022inbound|outbound\u0022\n\u0060\u0060\u0060\n\nThe logs will look like the examples below, where \u0060inbound\u0060 and \u0060outbound\u0060 are relative to ztunnel.\n\n**Inbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:33:01.410751Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.19:58000 src.workload=\u0022bookinfo-gateway-istio-64fc6d75d6-s442s\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-gateway-istio\u0022 dst.addr=10.28.2.18:15008 dst.hbone_addr=10.28.2.18:9080 dst.service=\u0022productpage.default.svc.cluster.local\u0022 dst.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 direction=\u0022inbound\u0022 bytes_sent=9603 bytes_recv=2052 duration=\u00222110ms\u0022\n\u0060\u0060\u0060\n\nThis log describes inbound traffic from \u0060bookinfo-gateway-istio\u0060 to the \u0060productpage\u0060 service, passing through ztunnel’s port 15008, encrypted via HBONE, with identities verified through SPIFFE.\n\n**Outbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:32:59.360677Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.18:51960 src.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 dst.addr=10.28.2.14:15008 dst.hbone_addr=34.118.226.6:9080 dst.service=\u0022details.default.svc.cluster.local\u0022 dst.workload=\u0022waypoint-7594b5b786-vgjwz\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/waypoint\u0022 direction=\u0022outbound\u0022 bytes_sent=794 bytes_recv=414 duration=\u002240ms\u0022\n\u0060\u0060\u0060\n\nThis log shows outbound traffic from the \u0060productpage\u0060 pod to the \u0060details\u0060 service, routed through ztunnel using an HBONE tunnel to the waypoint pod (port \u006015008\u0060).\n\n## Conclusion\n\nIstio ambient mode achieves sidecar-free transparent traffic interception through the collaboration of Istio CNI Node Agent and ztunnel. Key features include:\n\n- **High compatibility**: Avoids conflicts with underlying CNI.\n- **Simplified operations**: No need for application code changes, reducing resource overhead.\n- **Enhanced security**: Enables end-to-end encrypted transmission with HBONE.\n\nIn future articles, I will explore advanced features of Istio ambient mode, including L7 traffic path analysis and network topology construction. Stay tuned!\n\n## References\n\n- [Maturing Istio Ambient: Compatibility Across Various Kubernetes Providers and CNIs](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/)\n- [Introducing Istio Ambient Mesh](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)\n- [Kubernetes Official Documentation: Network Plugins](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/compute-storage-net\/network-plugins\/)\n- [HBONE](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)\n- [ztunnel Traffic Redirection](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/traffic-redirection\/)\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/transparent-traffic-interception-in-istio-ambient-mode-a-comprehensive-explanation\/).', '\/en\/blog\/istio-ambient-traffic-interception\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrate-to-istio-telemetry-api/">Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 18, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh', 'Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.', '\nThe Istio Telemetry API is a modern approach to replace traditional MeshConfig telemetry configuration. It provides more flexible tools to define **Tracing**, **Metrics**, and **Access Logging** within the service mesh. Compared to conventional \u0060EnvoyFilter\u0060 and \u0060MeshConfig\u0060, the Telemetry API offers better modularity, dynamic updates, and multi-layered configuration capabilities.\n\nIn this article, we will detail how to use the Telemetry API to configure Istio telemetry features, covering the implementation of Tracing, Metrics, and Logging, as well as how to migrate from legacy MeshConfig configurations.\n\n## Evolution of Telemetry API\n\nIstio\u0027s telemetry capabilities initially relied on traditional methods such as **Mixer** and the \u0060configOverride\u0060 in **MeshConfig**. While these methods met basic needs, they struggled with complex use cases. To address these issues, Istio introduced the CRD-based **Telemetry API**.\n\n### Key Version Updates\n\nTo help readers understand the evolution of the Telemetry API, here are some important version milestones:\n\n1. **Istio 1.11**: Introduced the Telemetry API (Alpha), offering basic metrics and logging customization.\n2. **Istio 1.13**: Added support for OpenTelemetry logging, custom tracing service names, and enhanced log filtering.\n3. **Istio 1.18**: Deprecated the installation of Prometheus \u0060EnvoyFilter\u0060, relying entirely on Telemetry API for telemetry behavior.\n4. **Istio 1.22**: Graduated the Telemetry API to stable (v1), making it ready for production environments.\n\n## Why Migrate to Telemetry API?\n\nAlthough traditional MeshConfig and EnvoyFilter provided foundational telemetry capabilities, their configuration methods posed significant limitations in terms of flexibility, dynamism, and scalability. To better understand these limitations, let\u0027s explore several key aspects.\n\n### Complexity of MeshConfig and EnvoyFilter\n\nBefore diving into the issues, let’s clarify the roles of MeshConfig and EnvoyFilter: MeshConfig is used for global configurations, while EnvoyFilter allows for fine-grained customization. However, this separation of duties leads to management challenges.\n\n#### 1. Dispersed Configuration Methods\n\n- **MeshConfig** is used to define global mesh behaviors, such as access log paths, trace sampling rates, and metric dimensions. While suitable for simple scenarios, it cannot meet namespace- or workload-specific needs.\n- **EnvoyFilter** can override or extend Envoy configurations, enabling finer control. However, this method involves directly manipulating Envoy’s internal structures (xDS fields), which is complex and error-prone.\n\n  **Example: Configuring access logging via MeshConfig**\n  \u0060\u0060\u0060yaml\n  apiVersion: install.istio.io\/v1alpha1\n  kind: IstioOperator\n  spec:\n    meshConfig:\n      accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  **Issues**:\n  - Cannot set different log paths for specific services or namespaces.\n  - Requires reapplying the entire configuration, lacking dynamism.\n\n  **Example: Customizing metrics via EnvoyFilter**\n  \u0060\u0060\u0060yaml\n  apiVersion: networking.istio.io\/v1alpha3\n  kind: EnvoyFilter\n  metadata:\n    name: custom-metric-filter\n    namespace: mynamespace\n  spec:\n    workloadSelector:\n      labels:\n        app: myapp\n    configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n        listener:\n          filterChain:\n            filter:\n              name: envoy.filters.network.http_connection_manager\n              subFilter:\n                name: envoy.filters.http.router\n        proxy:\n          proxyVersion: \u0027^1\\\\.13.*\u0027\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: istio.stats\n          typed_config:\n            \u0027@type\u0027: type.googleapis.com\/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n            value:\n              config:\n                configuration:\n                  \u0027@type\u0027: type.googleapis.com\/google.protobuf.StringValue\n                  value: |\n                    {\n                      \u0022debug\u0022: \u0022false\u0022,\n                      \u0022stat_prefix\u0022: \u0022istio\u0022,\n                      \u0022disable_host_header_fallback\u0022: true\n                    }\n                root_id: stats_inbound\n                vm_config:\n                  code:\n                    local:\n                      inline_string: envoy.wasm.stats\n                  runtime: envoy.wasm.runtime.null\n                  vm_id: stats_inbound\n  \u0060\u0060\u0060\n  **Issues**:\n  - Syntax is complex and verbose, requiring deep understanding of Envoy’s structure.\n  - High potential for errors, leading to costly debugging and maintenance.\n\n#### 2. Lack of Dynamism\n\nWhile modern microservice environments emphasize dynamic configuration, MeshConfig and EnvoyFilter offer limited support for dynamism:\n\n- **MeshConfig**: Modifying configurations often requires restarting proxies or reapplying the entire setup, causing service disruptions.\n- **EnvoyFilter**: Updating even a single parameter necessitates redeployment of related proxy instances.\n\n#### 3. Challenges in Multi-Tenant Support\n\nIn multi-tenant environments, customizing telemetry configurations for different namespaces or workloads is crucial. However:\n\n- **MeshConfig**: Cannot provide differentiated settings for namespaces or workloads.\n- **EnvoyFilter**: Requires multiple filter configurations, increasing management complexity.\n\n#### 4. Limited Extensibility and Debugging\n\n- MeshConfig and EnvoyFilter are slow to support new requirements (e.g., OpenTelemetry).\n- Debugging EnvoyFilter configurations is challenging, requiring in-depth analysis of Envoy logs and behaviors.\n\n### Deprecating Legacy MeshConfig Telemetry Configuration\n\nGiven the limitations mentioned above, the Istio community has deprecated traditional MeshConfig telemetry configurations. The following examples illustrate their usage and shortcomings:\n\n- **Access Logging Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n- **Trace Sampling Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    enableTracing: true\n    extensionProviders:\n    - name: zipkin\n      zipkin:\n        service: zipkin.istio-system.svc.cluster.local\n        port: 9411\n  \u0060\u0060\u0060\n- **Custom Metrics Labels**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    telemetry:\n      v2:\n        prometheus:\n          configOverride:\n            inboundSidecar:\n              metrics:\n                - name: requests_total\n                  dimensions:\n                    user-agent: request.headers[\u0027User-Agent\u0027]\n  \u0060\u0060\u0060\n\nThese configurations demonstrate clear limitations in flexibility and scalability, making them unsuitable for complex production environments.\n\n## Advantages of Telemetry API\n\nBuilding upon traditional methods, the Telemetry API introduces several improvements, making it well-suited for modern service mesh management:\n\n1. **Modular Design**: Separate configurations for Tracing, Metrics, and Access Logging.\n2. **Dynamic Updates**: Supports real-time configuration updates without proxy restarts.\n3. **Layered Support**: Allows configurations at global, namespace, and workload levels.\n4. **Simplified Syntax**: Uses declarative syntax, eliminating the need for in-depth Envoy knowledge.\n\n## Example Configurations with Istio Telemetry API\n\n### Global Configuration Example\n\nTo illustrate the usage of the Telemetry API, here is an example of a global configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  accessLogging:\n    - providers:\n        - name: file-log\n  tracing:\n    - providers:\n        - name: \u0022skywalking\u0022\n      randomSamplingPercentage: 100.00\n  metrics:\n    - overrides:\n        - match:\n            metric: REQUEST_COUNT\n            mode: CLIENT\n          tagOverrides:\n            x_user_email:\n              value: |\n                \u0027x-user-email\u0027 in request.headers ? request.headers[\u0027x-user-email\u0027] : \u0027empty\u0027\n      providers:\n        - name: prometheus\n\u0060\u0060\u0060\n\nThe remaining sections demonstrate step-by-step how to configure and validate SkyWalking, as well as perform migration, ensuring readers can implement these practices seamlessly in their environments.\n\n### Configuring SkyWalking with Telemetry API\n\nHere, we will demonstrate how to use the Telemetry API to configure the sampling rate and span tags for SkyWalking.\n\n#### Verify Istio Version and CRD\n\n- If using Istio 1.22 or later, use \u0060telemetry.istio.io\/v1\u0060.\n- For Istio 1.18 to 1.21 users, use \u0060telemetry.istio.io\/v1alpha1\u0060.\n\nCheck whether the Telemetry API CRD is installed using the following command:\n\n\u0060\u0060\u0060bash\nkubectl get crds | grep telemetry\n\u0060\u0060\u0060\n\n#### Deploy SkyWalking\n\nDeploy the SkyWalking OAP service in your cluster:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\nCheck the service status:\n\n\u0060\u0060\u0060bash\nkubectl get pods -n istio-system -l app=skywalking-oap\n\u0060\u0060\u0060\n\n#### Add SkyWalking Provider to MeshConfig\n\nDefine the SkyWalking provider in Istio\u0027s \u0060MeshConfig\u0060.\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: istio\n  namespace: istio-system\ndata:\n  mesh: |-\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: \u0022tracing.istio-system.svc.cluster.local\u0022\n        port: 11800\n\u0060\u0060\u0060\n\n#### Configure Sampling Rate with Telemetry API\n\nUsing the Telemetry API, set SkyWalking as the default tracing provider and define the sampling rate.\n\nTelemetry API allows configuration at multiple levels. For brevity, we demonstrate namespace-level configuration here. For other levels, refer to the [Telemetry API documentation](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/).\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1\nkind: Telemetry\nmetadata:\n  name: namespace-override\n  namespace: default\nspec:\n  tracing:\n  - providers:\n      - name: skywalking\n    randomSamplingPercentage: 50\n    customTags:\n      env:\n        literal:\n          value: production\n\u0060\u0060\u0060\n\nExplanation:\n\n- \u0060providers.name\u0060: Specifies SkyWalking as the default tracing provider.\n- \u0060randomSamplingPercentage\u0060: Overrides namespace-level settings to set a 50% sampling rate.\n- \u0060customTags\u0060: Adds the \u0060env=production\u0060 tag to all trace data.\n\n### Validate Configuration\n\nGenerate traffic for the mesh services, such as using the [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) example application:\n\n\u0060\u0060\u0060bash\ncurl http:\/\/$GATEWAY_URL\/productpage\n\u0060\u0060\u0060\n\nView the trace data:\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nOpen your browser and navigate to \u0060http:\/\/localhost:8080\u0060 to access the tracing dashboard and inspect the generated traces.\n\n![Skywalking Tracing](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-tracing.webp)\n\nClick on a span to see the additional \u0060env: production\u0060 tag.\n\n![Skywalking Span](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-span.webp)\n\n## Summary\n\nThe Telemetry API significantly reduces the complexity of configuring telemetry in the service mesh through its modular design, dynamic updates, and multi-level support. Compared to MeshConfig and EnvoyFilter, the Telemetry API is a more flexible, efficient, and modern solution. We highly recommend migrating to the Telemetry API to take full advantage of its capabilities.\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-telemetry\/).\n', '\/en\/blog\/migrate-to-istio-telemetry-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-sidecar-vs-ambient-network-cost-performance/">Network Cost Comparison Between Istio Sidecar and Ambient Modes</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Network Cost Comparison Between Istio Sidecar and Ambient Modes', 'In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.', '\nIn the evolving landscape of service mesh architectures, understanding the network costs associated with different deployment modes is crucial for optimizing performance and resource efficiency. This blog post will compare the network costs of Istio’s sidecar mode and ambient mode, drawing insights from my recent article, [Which Data Plane Should I Use—Sidecar, Ambient, Cilium, or gRPC?](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/)\n\n## Sidecar Mode\n\nIstio’s sidecar mode intercepts traffic between services by deploying a sidecar proxy alongside each pod. This model introduces additional network hops, which may increase latency and resource usage. However, the mode includes important optimizations like [locality-aware load balancing](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/locality-load-balancing\/).\n\nFigure 1 illustrates the traffic path when Application 1 accesses Application 2 located in a different availability zone (AZ) under the sidecar model.\n\n![Figure 1: The traffic path for Application 1 in Istio Sidecar mode to access Application 2 located in a different availability zone (AZ).](sidecar-mode.svg)\n\n### Locality Awareness in Sidecar Mode\n\nTo better understand locality management, you can use the command \u0060istioctl proxy-config endpoint \u003cpod-name[.namespace]\u003e -o yaml\u0060 to view an endpoint table containing locality information. This helps visualize how locality is managed in sidecar mode.Below is a sample output snippet showing endpoint information for the cluster \u0060outbound|9080||reviews.default.svc.cluster.local\u0060:\n\n\u0060\u0060\u0060yaml\n- addedViaApi: true\n  circuitBreakers:\n    thresholds:\n    - maxConnections: 4294967295\n      maxPendingRequests: 4294967295\n      maxRequests: 4294967295\n      maxRetries: 4294967295\n    - maxConnections: 1024\n      maxPendingRequests: 1024\n      maxRequests: 1024\n      maxRetries: 3\n      priority: HIGH\n  edsServiceName: outbound|9080||reviews.default.svc.cluster.local\n  hostStatuses:\n  - address:\n      socketAddress:\n        address: 10.244.0.98\n        portValue: 9080\n    healthStatus:\n      edsHealthStatus: HEALTHY\n    locality:\n      region: us-central1\n      zone: us-central1-c\n    stats:\n    - name: cx_connect_fail\n    - name: cx_total\n    - name: rq_error\n    - name: rq_success\n    - name: rq_timeout\n    - name: rq_total\n    - name: cx_active\n      type: GAUGE\n    - name: rq_active\n      type: GAUGE\n    weight: 1\n  - address:\n    # Additional addresses omitted\n  - address:\n    # Additional addresses omitted\n  name: outbound|9080||reviews.default.svc.cluster.local\n  observabilityName: outbound|9080||reviews.default.svc.cluster.local;\n\u0060\u0060\u0060\n\nThis shows how the sidecar proxy in each pod manages fine-grained traffic control, including circuit breaker configurations like maxConnections, maxRequests, and maxRetries, along with traffic metrics and health status indicators. This level of detail aids in maintaining healthy, stable, and latency-efficient traffic at the pod level.\n\nIn sidecar mode, each proxy prioritizes routing traffic to services within the same AZ or region, minimizing cross-AZ traffic and reducing latency and associated costs. This approach optimizes network paths, preventing cross-regional bottlenecks.\n\nAlthough sidecar mode can be compute-intensive, its locality-aware functionality is instrumental in maintaining efficient traffic routing, particularly in multi-region cloud deployments, where it helps minimize cross-region traffic costs.\n\n## Ambient Mode\n\nThe following diagram shows the architecture of Istio’s ambient mode.\n\n![Figure 2: Istio ambient mode architecture](istio-ambient-layers.svg)\n\nIstio ambient mode has two layers:\n\n1. **Ztunnel Layer (L3\/L4 Traffic Management)**: In ambient mode, zTunnel manages traffic mainly at the network and transport layers, reducing overhead while ensuring basic connectivity and security requirements are met.\n2. **Waypoint Proxy Layer (L7 Traffic Management)**: This layer, which adds application-layer functionality like advanced routing, observability, and policy enforcement, requires optimal placement to avoid cross-AZ traffic. Waypoint proxies should be deployed within each AZ to ensure maximum performance.\n\n## Locality Awareness in Ambient Mode\n\nIn contrast to sidecar mode, ambient mode uses zTunnel and waypoint proxies for a different architectural approach. Like sidecar mode, zTunnel prioritizes routing traffic within the same AZ, limiting cross-AZ traffic and associated network costs.\n\nFigure 3 illustrates the traffic path for Application 1 accessing Application 2 in a different AZ in ambient mode.\n\n![Figure 3: The traffic path for Application 1 in Istio ambient mode to access Application 2 located in a different availability zone (AZ).](ambient-mode.svg)\n\nNote: In the figure, the waypoint proxy is shown separately for demonstration purposes; in practice, it is not bound to a specific node and can be colocated with zTunnel.\n\nTo gain further insights into locality in ambient mode, you can use \u0060istioctl ztunnel-config workload -o yaml\u0060, which provides detailed views of zTunnel configurations and traffic distribution.\n\nHere’s an example snippet:\n\n\u0060\u0060\u0060yaml\n- applicationTunnel:\n    protocol: \u0022\u0022\n  canonicalName: productpage\n  canonicalRevision: v1\n  clusterId: Kubernetes\n  hostname: \u0022\u0022\n  locality:\n    region: us-central1\n    zone: us-central1-c\n  name: productpage-v1-d5789fdfb-gmw5r\n  namespace: default\n  node: gke-cilium-default-pool-63a77182-f699\n  protocol: HBONE\n  serviceAccount: bookinfo-productpage\n  status: Healthy\n  trustDomain: cluster.local\n  uid: Kubernetes\/\/Pod\/default\/productpage-v1-d5789fdfb-gmw5r\n  workloadIps:\n    - 10.28.2.14\n  workloadName: productpage-v1\n  workloadType: deployment\n\u0060\u0060\u0060\n\nThis output demonstrates ztunnel’s locality-aware information, which centralizes traffic management for all pods on a node, including load balancing, health checks, and locality awareness.\n\n### Waypoint Proxies\n\nThe waypoint proxy, however, does not automatically have AZ awareness. To optimize for cost and performance, waypoint proxies must be deployed across AZs to enable local traffic handling. Otherwise, there is a risk of additional cross-AZ traffic and costs. Additionally, once traffic reaches a waypoint proxy, original locality information may be obscured, complicating route optimization.\n\nFor optimal cost and performance, waypoint proxies should be distributed within each AZ to process traffic locally. The proximity-aware communication design between ztunnel and waypoint proxies helps ensure traffic is routed to the nearest waypoint, further reducing cross-AZ costs and latency.\n\n## Visualizing with Kiali Dashboard\n\nWhen comparing sidecar and ambient modes, visualizing locality and routing behavior with Kiali dashboard can help illustrate ambient mode’s complexity. Kiali provides a graphical view of traffic paths in different modes, aiding in understanding ambient mode’s operational intricacies.\n\n![Kiali UI](kiali.webp)\n\n## Conclusion\n\nIn comparing the network costs of Istio’s sidecar and ambient modes, both architectures support locality-aware routing to minimize cross-AZ traffic. Sidecar mode offers more comprehensive locality management at each proxy, while ambient mode requires careful waypoint proxy deployment to avoid extra costs. Additionally, ambient mode’s sub-modes (with or without waypoint proxies) impact network cost and performance in distinct ways. For a deeper dive into the four primary service mesh data plane deployment modes, I encourage you to read the full article [here](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-cost-comparison\/).*\n', '\/en\/blog\/istio-sidecar-vs-ambient-network-cost-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 30, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from AWS App Mesh to Istio: A Comprehensive Guide', 'Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.', '\nWith[ AWS announcing the deprecation of AWS App Mesh effective September 30, 2026](https:\/\/aws.amazon.com\/cn\/blogs\/containers\/migrating-from-aws-app-mesh-to-amazon-ecs-service-connect\/), many organizations are evaluating alternatives to continue their service mesh journey. If you are one of those organizations, Istio presents itself as a robust and feature-rich option, especially for Kubernetes-native environments. In this post, I will provide an overview of the migration process from AWS App Mesh to Istio, compare the two service meshes, and introduce the Tetrate Istio Migration Tool—a convenient utility we developed to streamline this transition.\n\n## App Mesh vs Istio: Preparing for Migration\n\nWith AWS App Mesh being deprecated, it’s important to understand the similarities and differences between App Mesh and Istio to prepare for a successful migration. Below are some key points of comparison to help align your current infrastructure with what Istio offers:\n\n1. Comprehensive Features: Both App Mesh and Istio offer traffic management, observability, and security, but Istio provides more customizable options, including advanced traffic routing and enhanced telemetry.\n2. Cloud Agnostic: Unlike AWS App Mesh, which is tightly integrated with AWS, Istio is cloud-agnostic, allowing for greater flexibility across multi-cloud or hybrid environments.\n3. Advanced Security: Istio supports mTLS by default, offering more extensive security features and policies compared to App Mesh.\n\nAWS recommends ECS customers migrate to[ Service Connect](https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/developerguide\/service-connect.html) and EKS customers to[ VPC Lattice](https:\/\/aws.amazon.com\/vpc\/lattice\/). For a feature-rich, open source solution, Istio is a compelling choice. Let’s dive into the migration journey from AWS App Mesh to Istio, supported by Tetrate’s migration tool.\n\n## Comparing App Mesh, Service Connect, VPC Lattice and Istio\n\nBefore starting the migration, it’s essential to understand the key differences between AWS App Mesh, Service Connect, VPC Lattice, and Istio:\n\n| **Feature**                  | **App Mesh**                                                 | **Service Connect**                                          | **VPC Lattice**                                              | **Istio**                                                    |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Network Reliability**      | Uses[ Envoy](https:\/\/envoyproxy.io\/) as sidecar proxies for outlier detection, health checks, and retries with granular adjustments. | Uses Envoy as sidecar proxies with default configurations, only timeouts adjustable. | Built-in health checks and retries with AWS-managed reliability. No sidecar proxies are needed. | Supports both sidecar and ambient modes, using Envoy with full support for fine-tuning. |\n| **Advanced Traffic Routing** | Supports advanced traffic routing like A\/B testing and canary releases. | Does not support advanced traffic routing.                   | Supports basic traffic routing and load balancing.           | Supports advanced traffic control, including A\/B testing and canary releases. |\n| **Observability**            | Manual collection and monitoring of metrics.                 | Sends metrics to Amazon CloudWatch automatically.            | Integrated monitoring with AWS CloudWatch and X-Ray.         | Out-of-the-box observability with Prometheus, Grafana, and Jaeger. |\n| **Service Discovery**        | Integrates with AWS Cloud Map.                               | Uses AWS Cloud Map.                                          | Uses AWS service discovery mechanisms.                       | Uses Kubernetes-native service discovery.                    |\n| **Security**                 | Supports TLS with AWS PCA and mutual TLS (mTLS).             | Supports TLS, no mTLS.                                       | Supports mTLS.                                               | Supports mTLS, fine-grained security policies.               |\n| **Resource Sharing**         | Can share Mesh across multiple AWS accounts.                 | Cannot share namespaces across accounts.                     | Can share resources across multiple AWS accounts.            | Can be deployed across multiple clusters and clouds.         |\n\n## Introducing Tetrate’s Istio Migration Tool\n\nTo make the migration process smoother, Tetrate has developed an Istio Migration Toolkit, which is currently in a private state but can be used internally or by approved customers who request it through the[ form](https:\/\/resources.tetrate.dev\/app-mesh-istio?__hstc=218802950.edcf2542a8010c44aa57b98adaef028a.1721092227167.1729818643207.1730268606576.91\u0026__hssc=218802950.2.1730268606576\u0026__hsfp=872206273). The toolkit assists in automating the conversion of AWS App Mesh configurations to Istio equivalents, including Virtual Nodes, Virtual Routers, and other networking constructs.\n\n**Key Considerations**\n\n- **Service discovery**: App Mesh and Istio handle service discovery differently. Istio leverages Kubernetes-native service discovery, while App Mesh integrates with AWS Cloud Map. During the migration, it is critical to adjust your service definitions accordingly.\n- **Security**: Istio natively supports mTLS between services. While AWS App Mesh also offers mTLS, transitioning to Istio will require configuring the Certificate Authority (CA) and updating certificates to align with Istio’s security model.\n- **Traffic management**: Istio’s Virtual Services and Destination Rules offer more advanced traffic routing capabilities compared to App Mesh’s Virtual Routers and Nodes. As you migrate, plan for additional configuration steps to set up similar routing behavior in Istio.\n\n## Step-by-Step Migration Using Tetrate’s Migration Tool\n\nBelow, I’ll guide you through the steps to use this tool effectively.\n\n### Prerequisites\n\nTo start the migration, ensure you have the following installed:\n\n- [Go](https:\/\/golang.org\/doc\/install)\n- [kubectl](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)\n- [istioctl](https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/#download)\n\nMake sure your AWS App Mesh is properly installed and configured on an EKS cluster. You’ll also need a Kubernetes secret called tetrate-tis-creds for Istio installation, as detailed in the tool’s documentation.\n\nThe tool also helps verify compatibility, offering a precheck command to identify any potential blockers before starting the migration.\n\n### Running a Precheck\n\nTo verify that your setup is ready for migration, run:\n\n\u0060\u0060\u0060bash\ntim precheck\n\u0060\u0060\u0060\n\nThis command will scan your App Mesh environment and highlight any adjustments required to ensure a successful migration.\n\n### Migration Process\n\n1. Install Istio\n\n   Use the Istio Migration Toolkit to generate IstioOperator configurations, and install Istio:\n\n   \u0060\u0060\u0060bash\n   tim generate iop | istioctl install –skip-confirmation -f –\n   \u0060\u0060\u0060\n\n1. Apply Istio Networking Rules\n   Next, generate and apply Istio networking rules:\n\n   \u0060\u0060\u0060bash\n   tim generate networking | kubectl apply -f –\n   \u0060\u0060\u0060\n\n1. Remove AWS App Mesh Labels\n   Remove the existing App Mesh labels from your namespaces. For example, for the default namespace:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default \u0022appmesh.k8s.aws\/sidecarInjectorWebhook-\u0022\n   \u0060\u0060\u0060\n\n1. Enable Istio Sidecar Injection\n   Add a label to enable Istio’s automatic sidecar injection:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio-injection=enabled\n   \u0060\u0060\u0060\n\n1. Restart Deployments\n   To apply changes and initiate the new Envoy sidecar injection, restart your deployments:\n\n   \u0060\u0060\u0060bash\n   kubectl rollout restart deployment \u003cdeployment-name\u003e -n \u003cdeployment-namespace\u003e\n   \u0060\u0060\u0060\n\n### Migration Strategies\n\nWhen migrating apps from AWS App Mesh to Istio, there are strategies like in-place, canary, and blue\/green deployments, similar to those for migrating to VPC Lattice. The right strategy depends on app requirements like zero downtime or scheduling maintenance windows.\n\n1. **In-Place Migration**: Replace existing Kubernetes Pods instrumented with App Mesh with new Pods configured for Istio. This approach is suitable for applications that can tolerate downtime during the migration process, as each pod is recycled to remove the Envoy sidecar container and add Istio.\n2. **Blue\/Green Deployment**: Deploy a second copy of the application in a new namespace configured for Istio, while the original deployment remains operational with App Mesh. Gradually migrate traffic from App Mesh to Istio without downtime while both environments run simultaneously.\n3. **Canary Deployment**: Deploy Istio side-by-side with App Mesh and incrementally move a small percentage of traffic to Istio. Monitor performance and stability, and increase traffic as confidence grows.\n4. **Phased Migration**: Migrate components or services incrementally instead of all at once. This reduces risk and helps identify potential issues in smaller, manageable segments.\n5. **Testing and Validation**: Before cutting over entirely, conduct thorough testing to validate that service functionality, security, and performance metrics meet or exceed expectations.\n\n## Conclusion\n\nMigrating from AWS App Mesh to Istio can unlock new capabilities in traffic management, observability, and security. Tetrate’s Istio Migration Toolkit simplifies the process, providing a step-by-step approach to reduce manual configurations and ensure a seamless transition.\n\nIf you’re interested in trying out Tetrate’s Istio Migration Toolkit, feel free to reach out—the tool is currently available for private use, and we’d be happy to discuss access.\n\nThis migration is not just about adopting a new service mesh—it’s an opportunity to take advantage of Istio’s comprehensive features, support multi-cloud deployments, and enhance the resilience of your infrastructure.\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/).*\n', '\/en\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multi-Cluster PKI \u002b Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh', 'This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.', '\nAuthors: Cristofer TenEyck Senior Solution Engineer a Keyfactor and Jimmy Song Developer Advocate at Tetrate\n\n## Introduction\n\nIn the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge. \n\nIn this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes. \n\nWhy multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters. \n\n## Understanding PKI and its Role in Service Meshes \n\nPKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments. \n\nThe EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications. \n\n## Istio, EJBCA and cert-manager \n\nSetting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included: \n\n1. **Environment Preparation**: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA). \n2. **cert-manager Integration**: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates. \n3. **Automatic Certificate Renewal**: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters. \n\n![Architecture](arch.webp)\n\n## Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary \n\nThis section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found [here](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi).\n\nThe key steps include: \n\n1. **Install and Configure Helm Repositories**: Add necessary Helm repositories for Istio, cert-manager, and EJBCA. \n2. **Deploy cert-manager and EJBCA**: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets. \n3. **Configure Istio with EJBCA**: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration. \n4. **Install Istio Components**: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway. \n5. **Customization and Overrides**: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services. \n6. **Automatic Certificate Renewal:** The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications. \n\n![Certificate renew flow](cert-renew-flow.webp)\n\nAbove is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA. \n\n## PKI Best Practices and Compliance \n\nBuilding a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider: \n\n1. **Compliance with Regulations**: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices. \n2. **Crypto Agility and Quantum Readiness**: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important. \n3. **Collaboration with InfoSec**: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals. \n\n## Conclusion \n\nImplementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant. \n\nBy following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh. \n\nFor further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below. \n\n## Resources \n\n- [Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi)\n- [Istio documentation](https:\/\/istio.io\/latest\/docs\/)\n- [EJBCA Community edition](https:\/\/www.ejbca.org\/)\n- [cert-manager documentation](https:\/\/cert-manager.io\/docs\/)\n- [EU Cyber Resilience Act](https:\/\/digital-strategy.ec.europa.eu\/en\/policies\/cyber-resilience-act)\n- [US Executive Order on Cybersecurity](https:\/\/www.whitehouse.gov\/briefing-room\/statements-releases\/2021\/05\/12\/executive-order-on-improving-the-nations-cybersecurity\/)\n- [A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh](\/en\/blog\/seamless-cross-cluster-access-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh\/).*\n', '\/en\/blog\/multi-cluster-pki-istio-recipe\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-tracing/">How the Envoy Proxy Handles User Requests for Tracing</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 26, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How the Envoy Proxy Handles User Requests for Tracing', 'An in-depth exploration of how the Envoy proxy processes user requests in a cloud-native environment to enable distributed tracing and enhance application observability.', '\nIn a cloud-native environment, improving application observability to better understand user experience is crucial. However, relying solely on metrics and logs does not provide specific details for individual cases. This is where tracing technology becomes essential.\n\n## Basic Principles of Tracing\n\nTracing provides developers with a complete context of the user experience by attaching an associated ID to each user request. This associated ID acts like a thread that connects traces across multiple services, enabling comprehensive observability.\n\nThe diagram below illustrates the flow of user requests processed by Envoy.\n\n\u0060\u0060\u0060mermaid \u0022User Request and Envoy Proxy Processing Flow Diagram\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant App\n    participant Backend\n    \n    %% User sends the initial request with various headers\n    User-\u003e\u003eEnvoy: User Request with Headers (Host, X-User-Identity, X-B3-TraceId)\n\n    %% Envoy forwards the request to the application\n    Envoy-\u003e\u003eApp: Forward Request (with headers)\n    \n    %% App processes the request and makes outgoing requests\n    App-\u003e\u003eEnvoy: Outgoing Request (to Backend with headers)\n    Envoy-\u003e\u003eBackend: Forward Request (X-B3-TraceId: 1234, X-User-Identity)\n\n    %% Backend responds to the outgoing request\n    Backend-\u003e\u003eEnvoy: Response to App Request\n    Envoy-\u003e\u003eApp: Forward Response\n\n    %% App processes response and sends response back to user\n    App-\u003e\u003eEnvoy: Response to User Request\n    Envoy-\u003e\u003eUser: Forward Response (to original User Request)\n\n    %% Handling multiple requests concurrently\n    User-\u003e\u003eEnvoy: Multiple Concurrent Requests\n    Envoy-\u003e\u003eApp: Forward Multiple Requests\n    App-\u003e\u003eEnvoy: Forward Responses\n    Envoy-\u003e\u003eUser: Multiple Concurrent Responses\n\u0060\u0060\u0060\n\n![User Request and Envoy Proxy Processing Flow Diagram](3e14426a8706f1e658721863febb0d58.svg)\n\n**Tracing** enables developers to have complete context of the user experience by appending an associated ID to each user request. This associated ID connects traces across multiple services.\n\nAlthough all requests pass through the Envoy proxy, it cannot independently provide complete tracing information. Envoy only sees the application as part of the network and lacks insights into internal processes. This limits Envoy\u0027s ability to distinguish whether incoming and outgoing requests originate from the same user, thus it cannot automatically forward tracing context.\n\n## Request Context in the Service Mesh\n\nEnvoy can act as a Sidecar or Waypoint proxy in the Istio service mesh. The following diagram illustrates how Envoy handles request context within the service mesh.\n\n### 1. The Start of the User Request\n\nTracing involves following the path across multiple services to understand the complete context of the user experience. Tracing begins with a user request assigned an associated ID.\n\n\u0060\u0060\u0060mermaid \u0022Start of the User Request\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: Request (with Headers)\n    Note right of User: Headers:\u003cbr\/\u003e- Host: example.com\u003cbr\/\u003e- X-User-Identity: Base64 Token\u003cbr\/\u003e- X-B3-TraceId: 1234\n\u0060\u0060\u0060\n\n![Start of the User Request](a7b787a1899db47cfb74a3f63fdd60cb.svg)\n\n### 2. Request Passing Through Envoy Proxy\n\nEnvoy sits beside the application, and all incoming requests go through Envoy.\n\n\u0060\u0060\u0060mermaid \u0022Request Passing Through Envoy Proxy\u0022\nsequenceDiagram\n    participant User\n    participant Envoy\n    participant Application\n    User-\u003e\u003eEnvoy: Initiates Request\n    Envoy-\u003e\u003eApplication: Forwards Request\n\u0060\u0060\u0060\n\n![Request Passing Through Envoy Proxy](294e6a2bd4ea694cb9e8039da41b388c.svg)\n\n### 3. Envoy Adds Extra Headers\n\nEnvoy can add extra headers to the request to gather information about what happens internally within the application.\n\n\u0060\u0060\u0060mermaid \u0022Envoy Adds Extra Headers\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: Forward Request (with Extra Headers)\n    Note right of Envoy: Added Headers:\u003cbr\/\u003e- X-Forwarded-For\u003cbr\/\u003e- X-Forwarded-Client-Cert\n\u0060\u0060\u0060\n\n![Envoy Adds Extra Headers](0626b8bc5b9a1f71f87a2ed3ac4a26fd.svg)\n\n### 4. Application Processes Request and Calls Backend Services\n\nDuring request processing, the application may need to contact other systems, such as external authentication and authorization services.\n\n\u0060\u0060\u0060mermaid \u0022Application Processes Request and Calls Backend Services\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy (Outbound)\n    participant Backend\n    Application-\u003e\u003eEnvoy2: Call Backend Request\n    Envoy2-\u003e\u003eBackend: Forward Request\n\u0060\u0060\u0060\n\n![Application Processes Request and Calls Backend Services](6d851064ab515a85731111767057ed1a.svg)\n\n### 5. Application Needs to Copy the Associated ID\n\nThe application knows which outbound request corresponds to which inbound request (e.g., the request with Trace ID 1234). However, Envoy does not know this. Thus, the application must copy the associated ID and context from the inbound request to the outbound request.\n\n\u0060\u0060\u0060mermaid \u0022Application Needs to Copy the Associated ID\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy2 as Envoy (Outbound)\n    participant Backend\n    Application-\u003e\u003eEnvoy2: Call Backend Request (Copy Headers)\n    Note right of Application: Copy Headers:\u003cbr\/\u003e- X-B3-TraceId: 1234\u003cbr\/\u003e- X-User-Identity: Base64 Token\n    Envoy2-\u003e\u003eBackend: Forward Request\n\u0060\u0060\u0060\n\n![Application Needs to Copy the Associated ID](f665f07be64f3e3d5d547d0513a49947.svg)\n\n### 6. Concurrent Handling of Multiple Requests\n\nIn real scenarios, applications handle multiple user requests simultaneously, leading to concurrency. Since Envoy only sees network-level requests and responses, it cannot distinguish the causal relationships between these requests.\n\n\u0060\u0060\u0060mermaid \u0022Concurrent Handling of Multiple Requests\u0022\nsequenceDiagram\n    participant User1\n    participant User2\n    participant Envoy\n    participant Application\n    User1-\u003e\u003eEnvoy: Request 1\n    User2-\u003e\u003eEnvoy: Request 2\n    Envoy-\u003e\u003eApplication: Forward Request 1\n    Envoy-\u003e\u003eApplication: Forward Request 2\n    Application-\u003e\u003eEnvoy: Response to Outbound Request 1\n    Application-\u003e\u003eEnvoy: Response to Outbound Request 2\n\u0060\u0060\u0060\n\n![Concurrent Handling of Multiple Requests](8851146efa64bf28b23427eaa3c88753.svg)\n\n### 7. Limitations of Envoy\n\nSince Envoy cannot see the internal processing logic of the application, it only observes a series of network requests and responses without knowing which outbound requests were triggered by which inbound requests.\n\n\u0060\u0060\u0060mermaid \u0022Limitations of Envoy\u0022\nsequenceDiagram\n    participant Envoy\n    participant Application\n    Envoy-\u003e\u003eApplication: Multiple Requests\n    Application-\u003e\u003eEnvoy: Multiple Responses\n    Note over Envoy: Cannot distinguish causal relationships of requests\n\u0060\u0060\u0060\n\n![Limitations of Envoy](a3e1d4b42a3342b8089f30cfba68c457.svg)\n\n## The Role of the Application\n\nSince Envoy cannot automatically forward tracing context, the application itself needs to be responsible for copying the headers from inbound requests to outbound requests to maintain the integrity of the tracing information.\n\n### Application Copies Headers\n\nWhile processing inbound requests, the application needs to copy necessary headers (like associated ID and user identity) to any outbound requests.\n\n\u0060\u0060\u0060mermaid \u0022Application Copies Headers\u0022\nsequenceDiagram\n    participant Application\n    participant Backend\n    Application-\u003e\u003eBackend: Outbound Request (with Copied Headers)\n\u0060\u0060\u0060\n\n![Application Copies Headers](e5e99c435025f175807e7dd2912993fc.svg)\n\n### Response Returns to User\n\nOnce the application completes processing the user request, it returns the response to the user.\n\n\u0060\u0060\u0060mermaid \u0022Response Returns to User\u0022\nsequenceDiagram\n    participant Application\n    participant Envoy\n    participant User\n    Application-\u003e\u003eEnvoy: Response\n    Envoy-\u003e\u003eUser: Forward Response\n\u0060\u0060\u0060\n\n![Response Returns to User](d06d46d97409d875f695a10005550f6b.svg)\n\n## Solutions and Recommendations\n\nTo ensure the integrity of tracing information, applications need to actively copy and transmit tracing-related headers. This can be achieved by integrating tools like [Apache SkyWalking](https:\/\/skywalking.apache.org\/), which not only supports distributed tracing but also includes performance monitoring and log analysis features. By utilizing SkyWalking’s libraries and agents, the process of copying headers and transmitting tracing information can be simplified.\n\nFor details on using SkyWalking for distributed tracing in Istio, refer to [this blog post](\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/).\n\n## Conclusion\n\n- **Importance of Tracing**: Tracing provides developers with complete context of user requests, aiding in better understanding and improving user experience.\n\n- **Role of Envoy**: Envoy serves as a proxy for network requests but cannot provide complete tracing information without assistance from the application.\n- **Application Responsibility**: Applications must actively copy and transmit tracing-related headers to maintain context.\n- **Utilizing Tools**: Leveraging distributed tracing tools like Apache SkyWalking can enhance observability and streamline the header copying process.\n\n## References\n\n- [How the Envoy proxy handles a user request - tetrate.io](https:\/\/tetrate.io\/blog\/how-the-envoy-proxy-handles-a-user-request\/)\n- [How to Use SkyWalking for Distributed Tracing in Istio? - jimmysong.io](https:\/\/jimmysong.io\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/)\n', '\/en\/blog\/envoy-tracing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth exploration of how the Envoy proxy processes user requests in a cloud-native environment to enable distributed tracing and enhance application observability.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/introducing-kmesh-kernel-native-service-mesh/">Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology', 'Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.', '\nIn the world of microservices and cloud-native applications, service meshes have become essential for managing service-to-service communication. However, traditional sidecar-based architectures introduce significant latency and resource overhead, posing challenges for latency-sensitive and large-scale applications. **Kmesh** emerges as a groundbreaking solution—a high-performance, kernel-native service mesh data plane that leverages eBPF and kernel enhancements to deliver unparalleled efficiency and performance.\n\n## Background\n\nService meshes like Istio have become integral in managing complex microservices architectures, providing features like traffic management, security, and observability. The sidecar model, where a proxy runs alongside each service instance, has been the predominant approach. While effective in functionality, this architecture introduces significant latency and resource overhead.\n\n{{\u003ccallout note \u0022Note\u0022\u003e}}\n\nAll data presented in this article is quoted from [A New Choice for Istio Data Plane: Architectural Innovation for a Brand-New Performance Experience](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no). I have not verified the accuracy of these data. You are requested to judge and verify the reliability of these data on your own.\n\n{{\u003c\/callout\u003e}}\n\n## Limitations of Traditional Sidecar Architectures\n\n1. **Latency Overhead**: The addition of sidecar proxies results in increased network hops and context switches, introducing an extra **2 to 3 milliseconds** of latency per service call. For latency-sensitive applications, this delay is unacceptable.\n\n2. **Resource Consumption**: Each sidecar consumes CPU and memory resources. In large-scale deployments with thousands of services, the accumulated resource overhead is huge. Although it can be optimized through certain technical means, it still reduces deployment density and increases operating costs.\n\nPerformance measurements of Istio reveal that even without traffic distribution, there\u0027s an inherent latency overhead of approximately 3 milliseconds. As the number of connections grows, latency increases correspondingly, highlighting the inefficiency of the sidecar model for high-performance applications.\n\n## Industry Attempts to Address the Challenges\n\nSeveral solutions have been proposed to mitigate the drawbacks of sidecar architectures:\n\n### Cilium Service Mesh\n\n- **Approach**: Combines eBPF with Envoy to create a sidecar-less service mesh.\n- **Mechanism**:\n  - **L4 Traffic**: Uses eBPF for efficient kernel-level data routing.\n  - **L7 Traffic**: Relies on Envoy for application-layer parsing.\n- **Limitations**:\n  - **Extra Hops for L7**: L7 governance through Envoy introduces additional network hops.\n  - **Fault Isolation**: Challenges in ensuring governance fault isolation.\n\n### Istio Ambient Mesh\n\n- **Approach**: Introduces sidecar-less architecture using **ztunnel** and **waypoint** proxies.\n- **Mechanism**:\n  - **User-Space Processing**: All traffic interception and management occur in user space.\n- **Limitations**:\n  - **Complex Traffic Interception**: User-space interception increases complexity.\n  - **Increased Hops**: L7 connections involve multiple network hops, adding latency.\n\nThese solutions, while innovative, do not fully resolve the latency and resource overhead issues inherent in sidecar architectures.\n\n## Introducing Kmesh: A Kernel-Native Approach\n\nKmesh defines a new service mesh data plane by directly integrating traffic governance into the operating system kernel. Utilizing eBPF (Extended Berkeley Packet Filter) and kernel enhancements, Kmesh provides high-performance, low-latency, and resource-efficient service mesh capabilities.\n\n### Technical Architecture\n\n![Kmesh Architecture](kmesh-arch.svg)\n\n**Core Components**:\n\n- **Kmesh-Daemon**: A per-node management component responsible for:\n  - Managing eBPF programs.\n  - Subscribing to xDS configurations from the control plane (e.g., Istiod).\n  - Handling observability and metrics collection.\n\n- **eBPF Orchestration**: Implements traffic interception and management at the kernel level, supporting:\n  - L4 load balancing.\n  - Traffic encryption and decryption.\n  - Monitoring and simple L7 dynamic routing.\n\n- **Waypoint Proxy (Optional in Dual Engine Mode)**: Handles advanced L7 traffic governance, deployed per namespace or per service as needed.\n\n### Key Advantages\n\n![Kmesh vs Sidecar vs Ambient ([Source](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no))](performance.webp)\n\n1. **High Performance**:\n   - **Latency Reduction**: Kernel-native L7 management reduces forwarding latency by over **60%** compared to traditional sidecar architectures.\n   - **Improved Application Startup**: Application bootstrap times improve by **40%** due to the elimination of sidecar initialization.\n\n2. **Low Resource Overhead**:\n   - **Resource Efficiency**: Eliminates the need for sidecar proxies, reducing resource consumption by over **70%**.\n\n3. **High Availability**:\n   - **Seamless Upgrades**: Kernel-level traffic management ensures that upgrading or restarting Kmesh components does not disrupt existing service connections.\n\n4. **Security Isolation**:\n   - **Enhanced Security**: Utilizes BPF-based virtual machine security and cgroup-level governance isolation to ensure secure multi-tenancy.\n\n5. **Flexible Governance Model**:\n   - **Deployment Modes**: Offers both Kernel-Native Mode for maximum performance and Dual Engine Mode for deployment flexibility.\n\n6. **Seamless Compatibility**:\n   - **Control Plane Integration**: Fully compatible with the xDS protocol, allowing integration with Istio\u0027s control plane and supporting Istio APIs and Gateway APIs.\n\n## Two Operational Modes of Kmesh\n\nKmesh provides two operational modes to cater to different deployment needs:\n\n### Kernel-Native Mode\n\n**Overview**:\n\n- **Ultimate Performance**: Achieves the lowest possible latency with no additional network hops for both L4 and L7 traffic.\n- **Mechanism**:\n  - **Kernel Enhancements**: Enhances the kernel using eBPF and kernel modules (ko).\n  - **Fake TCP Connections**: Utilizes forged connections to manage complex application-layer traffic within the kernel.\n  - **Traffic Management**: Directly manages traffic as soon as the client initiates communication, eliminating unnecessary context switches and data copies.\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces forwarding latency by over 60%.\n- **No Dependency on User-Space Proxies**: Entire traffic management is handled within the kernel.\n\n**Considerations**:\n\n- **Kernel Version Requirements**: May require specific kernel versions or enhancements, which could impact deployment flexibility.\n\n### Dual Engine Mode\n\n**Overview**:\n\n- **Flexible Governance**: Balances performance with broader compatibility and flexibility.\n- **Mechanism**:\n  - **Kernel-Level Interception**: Uses eBPF to intercept traffic in the kernel space.\n  - **Waypoint Proxy**: Deploys a remote waypoint proxy to handle complex L7 traffic management.\n  - **Layer Separation**: Splits L4 and L7 governance between kernel space (eBPF) and user space (waypoint).\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces latency by **30%** compared to Istio\u0027s Ambient Mesh.\n- **Simplified Traffic Interception**: Kernel-space interception is more secure and simpler than user-space interception.\n- **Lower Adoption Threshold**: Reduced dependency on specific kernel versions, making it easier for users to adopt.\n\n**Comparison with Ambient Mesh**:\n\n- **Fewer Network Hops**: Kmesh adds only one extra hop for L7 connections, whereas Ambient Mesh may add up to three.\n- **Simpler Architecture**: Kernel-level interception avoids the complexity of user-space interception mechanisms.\n\n## Deep Dive into Kmesh\u0027s Technology\n\n### eBPF and Kernel Enhancements\n\n**eBPF (Extended Berkeley Packet Filter)** is a powerful technology that allows the injection of custom code into the Linux kernel safely and efficiently. Kmesh leverages eBPF to:\n\n- **Intercept Network Traffic**: Attach eBPF programs to network events, enabling real-time interception and manipulation of packets.\n- **Implement Load Balancing**: Direct traffic to appropriate service instances based on policies.\n- **Perform Traffic Encryption**: Handle mTLS encryption and decryption within the kernel, reducing overhead.\n- **Collect Observability Data**: Gather metrics and telemetry data without impacting application performance.\n\n### Traffic Interception and Management\n\nIn the Kernel-Native Mode:\n\n- **Forged Connections**: Kmesh creates fake TCP connections within the kernel to manage traffic without involving user-space proxies.\n- **Direct Packet Manipulation**: Packets are intercepted and redirected at the kernel level, eliminating context switches and data copies that occur when moving packets between user space and kernel space.\n\nIn the Dual Engine Mode:\n\n- **eBPF Interception**: eBPF programs handle initial traffic interception and basic L4 management.\n- **Waypoint Proxy**: For advanced L7 features like routing, retries, and header manipulation, traffic is forwarded to a waypoint proxy deployed per service or namespace.\n\n### Security and Isolation\n\n- **BPF Virtual Machine Security**: eBPF runs in a restricted virtual machine within the kernel, ensuring that injected code cannot compromise kernel stability.\n- **Cgroup-Level Isolation**: Governance policies are applied at the cgroup level, providing isolation between different services and workloads.\n- **mTLS Support**: Mutual TLS is implemented within the kernel (Under development. Planned to be supported by the end of 2024), providing zero-trust security without the overhead of user-space encryption.\n\n## Performance Analysis\n\n**Test Setup**:\n\n- **Benchmark Tool**: Used [Fortio](https:\/\/github.com\/fortio\/fortio) to generate load and measure latency.\n- **Comparisons**: Measured performance across four configurations:\n  1. **Baseline**: Direct communication without any service mesh.\n  2. **Istio Sidecar**: Traditional sidecar-based deployment.\n  3. **Istio Ambient Mesh**: Sidecar-less deployment with ztunnel and waypoint.\n  4. **Kmesh**: Both Kernel-Native and Dual Engine modes.\n\n**Results**:\n\n- **Latency**:\n  - **Kmesh Kernel-Native Mode**: Achieved over **60%** reduction in forwarding latency compared to Istio Sidecar.\n  - **Kmesh Dual Engine Mode**: Reduced latency by **30%** compared to Istio Ambient Mesh.\n- **Resource Consumption**:\n  - **CPU and Memory**: Kmesh reduced resource overhead by over **70%**, as it eliminates the need for sidecar proxies.\n- **Application Startup Time**:\n  - Improved by **40%**, as applications no longer wait for sidecar initialization.\n\n**Interpretation**:\n\n- Kmesh approaches baseline performance, making the overhead of the service mesh negligible.\n- The elimination of context switches and data copies contributes significantly to performance gains.\n- The kernel-native approach ensures consistent performance even as the number of services scales.\n\n## Cloud-Native Integration and Compatibility\n\n- **Kubernetes Native**: Kmesh runs seamlessly on Kubernetes, managing traffic to and from pods without requiring changes to application code.\n- **Control Plane Integration**:\n  - **xDS Protocol Support**: Subscribes to xDS configurations from Istiod, ensuring compatibility with Istio\u0027s control plane.\n  - **Istio API Compatibility**: Supports existing Istio APIs, allowing users to leverage familiar configurations and policies.\n- **Gateway API Support**: Compatible with Gateway APIs, enabling more flexible and expressive traffic management.\n- **Observability**:\n  - Integrates with Prometheus for metrics collection.\n  - Utilizes eBPF for efficient data gathering without impacting performance.\n- **Security Policies**:\n  - Supports existing Istio security policies, including authentication and authorization.\n\n## Future Roadmap\n\n**Short-Term Goals (2024)**:\n\n- **September 2024**:\n  - Implement circuit breaking and rate limiting.\n  - Enhance support for mTLS and upstream extensions.\n  - Ensure seamless restarts without affecting traffic.\n- **December 2024 (Release 1.0)**:\n  - Introduce locality-aware load balancing.\n  - Add multi-cluster support for federated deployments.\n  - Enhance DNS and headless service handling.\n  - Integrate with gateway components for edge traffic management.\n\n**Long-Term Vision (2025 and Beyond)**:\n\n- **AI Integration**:\n  - Incorporate AI capabilities to improve traffic governance decisions.\n  - Enhance problem diagnostics and anomaly detection.\n- **Multi-VPC Support**:\n  - Extend support to multi-Virtual Private Cloud environments.\n- **Advanced Observability**:\n  - Leverage eBPF and Application Performance Management tools for deeper insights.\n  - Provide end-to-end tracing and metrics.\n\n## Conclusion\n\nKmesh represents a paradigm shift in service mesh technology by moving traffic management into the kernel. By leveraging eBPF and kernel enhancements, it addresses the critical challenges of latency and resource overhead inherent in traditional sidecar architectures. Kmesh offers a flexible, high-performance solution suitable for modern cloud-native applications, particularly those requiring low latency and high throughput.\n\n**Key Takeaways**:\n\n- **Performance**: Achieves near-baseline performance by eliminating unnecessary overhead.\n- **Resource Efficiency**: Reduces CPU and memory consumption, enabling higher deployment densities.\n- **Flexibility**: Provides multiple operational modes to suit different deployment scenarios.\n- **Security**: Enhances security through kernel-level enforcement and isolation mechanisms.\n- **Compatibility**: Integrates seamlessly with existing cloud-native ecosystems, including Kubernetes and Istio.\n\nAs microservices architectures continue to evolve, solutions like Kmesh will play a crucial role in enabling efficient, scalable, and secure service communication. By addressing the limitations of traditional service mesh designs, Kmesh sets a new standard for performance and resource efficiency in the service mesh landscape.\n', '\/en\/blog\/introducing-kmesh-kernel-native-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/blog/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/blog/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/blog/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/blog/page/9/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(51)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-packet-lifecycle-optimization/">Packet Lifecycle and Traffic Optimization in Istio Ambient Mode</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />





<script>
    anchors.add();
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
