<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh Overview Â· Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Deeper understanding of Istio, Chapter 1.">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.101.0" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css">
  
  <link rel="stylesheet" href="/plugins/themify-icons/themify-icons.css">
  
  <link rel="stylesheet" href="/plugins/hightlight/syntax.css">
  
  <link rel="stylesheet" href="/plugins/fontawesome/font-awesome.min.css">
  
  <link rel="stylesheet" href="/plugins/tocbot/tocbot.css">
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.css" media="screen">

  <!--Favicon-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="57x57" href="images/favicon-57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="images/favicon-72.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="images/favicon-114.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="images/favicon-144.png" />

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  
  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/blog/dui-service-mesh-overview/" />
  <meta property="og:title" content="Service Mesh Overview" />
  <meta property="twitter:title" content="Service Mesh Overview" />
  
  <meta property="og:description" content="Deeper understanding of Istio, Chapter 1." />
  <meta property="twitter:description" content="Deeper understanding of Istio, Chapter 1." />
  
  
  <meta property="og:image" content="https://jimmysong.io/images/banner/service-mesh-banner.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/service-mesh-banner.jpg" />
  
  
  
</head>
<body>
    <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>

<header class="fixed-top header">
  
  
  
  <div class="navigation w-100 ">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en"><img class="img-fluid" width="200px"
            src="/images/logo.svg" alt="Jimmy Song&#39;s blog"></a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="https://lib.jimmysong.io" target="_blank" rel="noopener">Book</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            

          
          
          
          <!-- search -->
          <button id="searchOpen" class="search-btn js-search"><i class="fa fa-search text-dark"></i></button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


    <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>Search</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fa fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        <i class="fa fa-search" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Input the keyword">
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>

    
	
	
<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/page-title.webp'),url('/images/backgrounds/page-title.webp');">
    <div class="container">
        <div class="row">
            <div class="col-md-8">
                <ul class="list-inline custom-breadcrumb">
                    <li class="list-inline-item h2"><a class="text-white font-secondary" href="/en/blog">
            
            
              
              Blogs
              
            
          </a></li>
                    <li class="list-inline-item"><i class="ti-angle-right text-white"></i></li>
                    <li class="list-inline-item text-white h3 font-secondary">Service Mesh Overview</li>
                </ul>
                <p class="text-white">Deeper understanding of Istio, Chapter 1.</p>
            </div>
        </div>
    </div>
</section>

	


<section class="section-sm">
  <div class="container blog">
    <div class="row">
      <div class="col-lg-8 article-content">
        <div class="row">
          <div class="col-12">
            <ul class="list-inline">
              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">Date
                  :</span>January 22, 2021</li>

              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">Category
                  :</span><a
                  href="/en/categories/service-mesh"> 
                  Service Mesh</a> </li>
              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">Word Count
                  :</span>5004 words</li>
              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">Reading Time
                  :</span>23 Minute</li>
            </ul>
          </div>
          
          <div class="col-12 my-4">
            <div class="border-bottom"></div>
          </div>
          
          <div class="col-12 content">
            
            <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">Click to show the outline</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#11-service-mesh-basic-concept">1.1 Service Mesh Basic Concept</a></li>
    <li><a href="#12-microservices-in-the-post-kubernetes-era">1.2 Microservices in the Post-Kubernetes Era</a>
      <ul>
        <li><a href="#121-important-points">1.2.1 Important points</a></li>
        <li><a href="#122-kubernetes-and-service-mesh">1.2.2 Kubernetes and Service Mesh</a></li>
        <li><a href="#123-the-kube-proxy-component">1.2.3 The kube-proxy component</a></li>
        <li><a href="#124-kubernetes-ingress-and-istio-gateway">1.2.4 Kubernetes Ingress and Istio Gateway</a></li>
        <li><a href="#125-xds-protocol">1.2.5 xDS protocol</a></li>
        <li><a href="#126-envoy">1.2.6 Envoy</a></li>
        <li><a href="#127-istio-service-mesh">1.2.7 Istio Service Mesh</a></li>
      </ul>
    </li>
    <li><a href="#13-what-is-istio">1.3 What is Istio</a>
      <ul>
        <li><a href="#131-why-use-istio">1.3.1 Why use Istio</a></li>
        <li><a href="#132-istios-platform-support">1.3.2 Istio's platform support</a></li>
      </ul>
    </li>
    <li><a href="#14-summary-of-this-chapter">1.4 Summary of this chapter</a></li>
  </ul>
</nav>
</details>

            
            <p>Microservices architecture is the current technology hotspot in software
development, and has been featured on various blogs, social media, and
conference presentations, with a lot of interest from both infrastructure and business system engineers. This phenomenon and fever has been going on for nearly 6 years now.</p>
<p>Especially in recent years, microservices architecture has gradually
developed and matured, from the initial &ldquo;starburst&rdquo; to the current
large-scale implementation and practice, almost becoming the preferred
architecture in distributed environments. Microservice architecture has
become a hot technology nowadays, and a lot of Internet enterprises are
doing the implementation and promotion of microservice architecture. At
the same time, there are also many traditional enterprises doing
Internet technology transformation based on microservices and
containers.</p>
<p>In the Internet technology transformation, there is a trend in China to
Spring Cloud and Dubbo as the representative of the microservices
development framework is very popular and popular. However, there is no &ldquo;silver bullet&rdquo; for software development, and applications built on
these traditional microservices frameworks are enjoying their advantages
while the pain points are becoming more and more obvious, such as.</p>
<ul>
<li>
<p>Intrusive. To integrate the capabilities of the SDK, in addition to
adding relevant dependencies, you need to add a portion of code,
annotations or configurations to the business code to prevent
unclear boundaries between the business layer code and the
governance layer code.</p>
</li>
<li>
<p>High upgrade cost. Each upgrade requires the business application to
modify the SDK version, re-run functional regression tests, and
deploy live for each machine. This is in conflict with the rapid
iterative development of the business for the business side, and
most business sides are reluctant to stop and do these things that
are less relevant to their business goals.</p>
</li>
<li>
<p>Version fragmentation is serious. Due to the high upgrade cost and
the fact that the middleware is constantly moving forward, over
time, it leads to inconsistent versions and uneven capabilities of
the SDKs referenced by different services online, resulting in a
situation where it is difficult to unify governance.</p>
</li>
<li>
<p>Middleware evolution is difficult. Due to severe version fragmentation, middleware needs to be compatible with various old versions of logic in the code as it evolves forward, and it is impossible to achieve rapid iteration because of the &ldquo;shackles&rdquo;.</p>
</li>
<li>
<p>Spring Cloud is known as the &ldquo;family&rdquo; of microservices governance
frameworks, containing dozens of components, large and small, with
so much content that it often takes years for users to become
familiar with the key components. If you use Spring Cloud as a
complete governance framework, you need to understand the principles and implementation in depth, otherwise it will be very difficult to locate the problem.</p>
</li>
<li>
<p>Incomplete governance features. Unlike RPC frameworks, Spring Cloud,
as the quintessential governance framework, is not a panacea.
Advanced features such as protocol conversion support, multiple
authorization mechanisms, dynamic request routing, fault injection,
grayscale publishing, etc. are not covered. These features are often
indispensable for large-scale enterprise implementations, so
companies also need to invest in other human resources for
self-research of related features, or research other components as a
supplement.</p>
</li>
</ul>
<p>The above lists the limitations of traditional microservices frameworks, but it does not mean that they are useless. In small and medium-sized enterprises, the adoption of traditional microservices frameworks like Spring Cloud can not only meet most of the service governance needs, but can also be used to rapidly advance microservices transformation. The limitations of traditional microservices frameworks are the inevitable stage of technology development to a certain extent, and the driving force behind the continuous development and advancement of technology. Service Mesh technology is a better solution to solve these problems at this stage.</p>
<h2 id="11-service-mesh-basic-concept">1.1 Service Mesh Basic Concept</h2>
<p>In 2019, among the many hot technology trends, cloud-native continues to
receive a lot of attention, and many developers are very enthusiastic
about the emerging technologies, and many enterprises have started to
explore the transformation and implementation of cloud-native
architecture. This year, Chinese developers have experienced a shift
from focusing on the &ldquo;cloud native concept&rdquo; to focusing on &ldquo;cloud
native implementation practices&rdquo;. As a result, Service Mesh technology
is getting hotter and hotter, receiving more and more attention from
developers and gaining a large number of advocates. So, what is Service
Mesh? Why is it attracting developers' attention? How does it differ
from traditional microservice frameworks?</p>
<p>The term Service Mesh was first coined by Buoyant, the company that
developed Linkerd, and was first used publicly on September 29,
2016.William Morgan, Buoyant CEO, defines the concept of Service Mesh as follows.</p>
<p>Service Mesh is an infrastructure layer that specializes in handling
service communication. Its responsibility is to perform reliable request
delivery under the complex topology of services composed of cloud-native
applications. In practice, it is a set of lightweight network proxies
deployed with application services and transparent to the application
services.</p>
<p>There are 4 key points in the above passage.</p>
<ul>
<li>
<p>The essence: the infrastructure layer.</p>
</li>
<li>
<p>Function: Request distribution.</p>
</li>
<li>
<p>Deployment form: Web proxy.</p>
</li>
<li>
<p>Features: Transparent.</p>
</li>
</ul>
<p>In 2017, with the introduction of Linkerd, Service Mesh entered the
vision of the domestic community and was translated into &ldquo;Service
Mesh&rdquo; by the domestic &ldquo;technical evangelists&rdquo;.</p>
<p>The Service mesh is relatively simple in terms of overall architecture,
consisting of a bunch of user agents immediately adjacent to each
service, plus a set of task management processes. In a service mesh, the
agents are called the Data Layer or Data Plane, and the management
processes are called the Control Layer or Control Plane. The Data Plane
intercepts calls between different services and processes them; the
Control Plane not only coordinates the behavior of agents, but also
manipulates and measures the entire network by providing APIs for
operations and maintenance personnel.</p>
<p>Further, the Service mesh is a dedicated infrastructure layer designed
to &ldquo;enable reliable, fast and secure inter-service invocation in a
microservices architecture&rdquo;. It is not a mesh of &ldquo;services&rdquo;, but a
mesh of &ldquo;agents&rdquo; into which services can be plugged, thus abstracting
the network. In a typical service mesh, these proxies are injected into
each service deployment as a Sidecar. Instead of invoking services
directly over the network, services invoke their local Sidecar proxies,
which in turn represent service management requests, thus encapsulating
the complexity of inter-service communication. The interconnected
Sidecar agents implement a so-called data plane, which is contrasted
with the service mesh components (control plane) used to configure
agents and collect metrics.</p>
<p>In a nutshell, the infrastructure layer of Service Mesh is divided into
two main parts: the control plane and the data plane. The two currently popular open source service meshes, Istio and Linkerd, are actually of this construction.</p>
<p>Characteristics of the control plane.</p>
<ul>
<li>
<p>Does not parse packets directly.</p>
</li>
<li>
<p>Communicate with agents in the control plane, issue policies and
configurations.</p>
</li>
<li>
<p>Responsible for the visualization of web behavior.</p>
</li>
<li>
<p>APIs or command line tools are often provided that can be used for
configuration versioning management for continuous integration and
deployment.</p>
</li>
</ul>
<p>Characteristics of the data plane.</p>
<ul>
<li>
<p>It is usually designed with the stateless goal in mind, but in
practice some data needs to be cached in order to improve the
efficiency of traffic forwarding, so statelessness is also
controversial.</p>
</li>
<li>
<p>Directly handle inbound and outbound packets, such as forwarding,
routing, health checking, load balancing, authentication,
authentication, monitoring data, etc.</p>
</li>
<li>
<p>Transparent to the application and can be deployed without
perception.</p>
</li>
</ul>
<p>So what changes have been brought about by the emergence of the Service mesh?</p>
<p>First, the decoupling of microservice governance and business logic.
Service mesh strips most of the functions in the SDK from the
application, disassembles them into independent processes, and deploys
them in the Sidecar model. By separating the service communication and
related control functions from the business process and sinking them to
the infrastructure layer, Service mesh makes them completely decoupled
from the business system, allowing developers to focus more on the
business itself.</p>
<p>Note that the word &ldquo;most&rdquo; is mentioned here. In the SDK, it is often
necessary to retain the protocol coding and decoding logic, and even in
some scenarios, a lightweight SDK is required to implement fine-grained
governance and monitoring policies. For example, to implement
method-level call-link tracing, the service mesh needs the business
application to implement Trace ID passing, and this part of the
implementation logic can also be realized by a lightweight SDK.
Therefore, at the code level, the Service mesh is not zero-intrusive.</p>
<p>Second, unified governance of heterogeneous systems. With the
development of new technologies and staff turnover, applications and
services in different languages and frameworks can appear even in the
same company. In order to unify the control of these services, the
previous practice is to develop a complete set of SDKs for each language
and framework, which is not only very costly to maintain but also brings
great challenges to the middleware team of the company. With Service
mesh, the main service governance function can be sunk to the
infrastructure, and multi-language support will be much easier. By
simply providing a very lightweight SDK, and in many cases not even a
separate SDK, it is easy to achieve unified traffic control, monitoring,
and other requirements in multiple languages and protocols.</p>
<p>In addition, the Service mesh has three major technical advantages over
traditional microservice frameworks.</p>
<ul>
<li>
<p>Observability. Because the Service mesh is a dedicated
infrastructure layer through which all inter-service communication
needs to pass, it is uniquely positioned in the technology stack to
provide uniform telemetry at the service invocation level. This
means that all services are monitored as &ldquo;black boxes&rdquo;. The
service mesh captures line data such as source, destination,
protocol, URL, status codes, latency, duration, etc. This is
essentially the same data that web server logs can provide, but the
service mesh captures this data for all services, not just the web
layer of individual services. It is important to note that
collecting data is only part of the solution to the observability
problem in microservice applications. Storing and analyzing this
data needs to be supplemented by mechanisms for additional
functionality and acts as alerts or automatic instance scaling, for
example.</p>
</li>
<li>
<p>Traffic Control. Service mesh can provide various control functions
for services such as intelligent routing (blue-green deployment,
canary release, A/B testing), timeout retry, meltdown, fault
injection, traffic mirroring, etc. These are features that are not
available in traditional microservices frameworks, but are critical
features for the system. This is because the service mesh carries
the communication traffic between microservices, so it is possible
to test the robustness of the whole application by performing fault
injection in the service mesh through rules to simulate the
situation when some microservices fail. Since the Service mesh is
designed to efficiently connect source request invocations to their
optimal destination service instances, these traffic control
features are destination-oriented. This is one of the key features
of the Service mesh traffic control feature.</p>
</li>
<li>
<p>Security. To some extent, monolithic architecture applications are
protected by their single address space. However, once a monolithic
architecture application is broken down into multiple microservices,
the network becomes a significant attack surface. More services
means more network traffic, which means more opportunities for
hackers to attack the information flow. And service meshs provide
exactly the functionality and infrastructure to protect network
calls. The benefits associated with Service mesh security are in the
following 3 core areas: authentication of services, encryption of
inter-service communications, and enforcement of security-related
policies.</p>
</li>
</ul>
<p>Service mesh has extremely powerful technical advantages and has brought great changes, and is called the &ldquo;second generation of microservice architecture&rdquo;. However, just as there is no &ldquo;silver bullet&rdquo; for
software development and traditional microservice architecture has many
pain points, Service mesh also has its limitations, as follows.</p>
<ul>
<li>
<p>Increased complexity. Service meshs introduce Sidecar agents and
other components into an already complex distributed environment,
which can greatly increase the overall chain and operational O&amp;M
complexity.</p>
</li>
<li>
<p>Ops needs to be more specialized. Adding a service mesh such as
Istio to a container orchestration tool such as Kubernetes requires
Ops staff to become experts in both technologies in order to fully
use the capabilities of both, as well as locate problems encountered
in the environment.</p>
</li>
<li>
<p>Delay. At the link level, service meshes are an intrusive and
complex technique that can add significant latency to system calls.
While this latency is on the millisecond level, it can be
intolerable in particular business scenarios.</p>
</li>
<li>
<p>Platform Adaptation. The intrusive nature of the Service mesh forces
developers and Ops to adapt to the platform and comply with its
rules.</p>
</li>
</ul>
<h2 id="12-microservices-in-the-post-kubernetes-era">1.2 Microservices in the Post-Kubernetes Era</h2>
<p>Anyone who has heard of Service mesh and tried Istio probably has the
following 5 questions.</p>
<p>(1) Why should Istio bind Kubernetes?</p>
<p>(2) What is the role of Kubernetes and Service mesh respectively in
cloud-native?</p>
<p>(3) What aspects of Kubernetes does Istio extend? What problems have
been solved?</p>
<p>(4) What is the relationship between Kubernetes, xDS protocols (Envoy,
MOSN, etc.) and Istio?</p>
<p>(5) Should I use Service Mesh or not?</p>
<p>This section will take the reader through the inner workings of
Kubernetes, the xDS protocol, and the Istio service mesh. In addition,
this section will introduce the load balancing approach in Kubernetes,
the significance of the xDS protocol for service meshs, and why Istio is
still needed even with Kubernetes.</p>
<p>Using a service mesh is not a break with Kubernetes, but a natural fit;
the essence of Kubernetes is application lifecycle management through
declarative configuration, while the essence of a service mesh is to
provide inter-application traffic and security management, as well as
observability. If you have already built a stable microservices platform
using Kubernetes, how do you set up load balancing and traffic control
for calls between services?</p>
<p>The xDS protocol created by Envoy is supported by many open source
software such as Istio, Linkerd, MOSN, etc. Envoy's biggest contribution to Service mesh or Cloud Native is the definition of xDS.
envoy is essentially a web proxy, a modern version of proxy configured
through APIs, based on which many different usage scenarios have been
derived, such as API gateways, Sidecar agents and edge agents in service
meshs.</p>
<h3 id="121-important-points">1.2.1 Important points</h3>
<p>To get a preview of everything that follows, you can read some of the
main points listed below.</p>
<ul>
<li>
<p>The essence of Kubernetes is application lifecycle management,
specifically, the deployment and management of applications (scaling
up and down, automatic recovery, and release).</p>
</li>
<li>
<p>Kubernetes provides a scalable and highly resilient deployment and
management platform for microservices.</p>
</li>
<li>
<p>The Service mesh is based on transparent proxies that first
intercept traffic to and from microservices through Sidecar proxies,
and then manage the behavior of microservices through control plane
configuration.</p>
</li>
<li>
<p>The Service mesh decouples traffic management from Kubernetes.
Traffic within the Service mesh does not require the support of the
kube-proxy component, and manages traffic between services through
an abstraction close to the microservice application layer, enabling
security and observability features.</p>
</li>
<li>
<p>xDS defines the protocol standard for service mesh configuration.</p>
</li>
<li>
<p>The Service mesh is a higher-level abstraction of service in
Kubernetes, and its next step is serverless.</p>
</li>
</ul>
<h3 id="122-kubernetes-and-service-mesh">1.2.2 Kubernetes and Service Mesh</h3>
<p>Figure 1-1 shows the service access relationship between Kubernetes
natively and Service Mesh (one Sidecar per Pod deployed in the model).</p>
<h5 id="1-traffic-forwarding">1. Traffic forwarding</h5>
<p>Each node in a Kubernetes cluster deploys a kube-proxy component, which
first communicates with the Kubernetes API Server to obtain information
about the services in the cluster, then sets up iptables rules to send
requests for a service directly to the corresponding Endpoint (a Pod
belonging to the same group of service) to the corresponding Endpoint (a
Pod belonging to the same group of services).</p>
<p>Figure 1-1</p>
<h5 id="2-service-discovery">2. Service Discovery</h5>
<p>The Istio Service mesh can not only follow the service in Kubernetes for
service registration, but can also interface to other service discovery
systems via platform adapters in the control plane to generate data
plane configurations (using CRD declarations that are saved in etcd).
Transparent Proxy for the data plane is deployed in the form of Sidecar
containers in each Pod of application services, and these Proxies need
to request the control plane to synchronize the proxy configuration. The
reason for the transparent proxy is that the application container is
completely unaware of the presence of the proxy, and the kube-proxy
component needs to intercept traffic in the process, except that the
kube-proxy component intercepts traffic to and from the Kubernetes node,
while the Sidecar Proxy intercepts traffic to and from the Pod. Figure
1-2 shows the service discovery mechanism in Istio.</p>
<p>Figure 1-2</p>
<h5 id="3-disadvantages-of-service-mesh">3. Disadvantages of Service mesh</h5>
<p>Since each node in Kubernetes runs numerous Pods, placing the route
forwarding functionality of the original kube-proxy approach in each Pod
leads to significant configuration distribution, synchronization, and
eventual consistency issues. A new set of abstractions must be added for
fine-grained traffic management, leading to further learning costs for
users, but the situation will slowly be mitigated as the technology
becomes more widespread.</p>
<h5 id="4-advantages-of-service-mesh">4. Advantages of Service mesh</h5>
<p>The kube-proxy settings are all globally effective and cannot be
controlled at a granular level for each service, while the Service mesh
takes the control of traffic in Kubernetes out of the service layer by
way of Sidecar Proxy to do more scaling.</p>
<h3 id="123-the-kube-proxy-component">1.2.3 The kube-proxy component</h3>
<p>In a Kubernetes cluster, each Node runs a kube-proxy process. kube-proxy
is responsible for implementing a form of VIP (virtual IP address) for
the service. In Kubernetes v1.0, the proxy is implemented entirely in
the userspace proxy mode. In Kubernetes v1.1, the iptables proxy mode
was added, but is not the default mode of operation. From Kubernetes
v1.2 onwards, the iptables proxy mode is used by default. In Kubernetes
v1.8.0-beta.0, the IPVS proxy mode was added.</p>
<p>Defects of kube-proxy</p>
<p>First of all, if the forwarding Pod is not serving properly, then it
will not automatically try another Pod, but this problem can be solved
by liveness probes. Each Pod has a health check mechanism, and
kube-proxy will remove the corresponding forwarding rules when the Pod
has health problems. Also, nodePort-type services cannot add TLS, or
more complex message routing mechanisms.</p>
<p>kube-proxy implements load balancing of traffic across multiple Pod
instances in a Kubernetes service, but how do you control the traffic
between these services at a granular level, for example, by dividing the
traffic into different application versions (which are all part of the
same service, but on different deployments) by percentage, doing canary
releases (grayscale releases) and blue-green releases? The Kubernetes
community has given a method to do canary releases using Deployment,
which is essentially a way to assign different Pods to a Deployment
service by modifying the Pod's label.</p>
<h3 id="124-kubernetes-ingress-and-istio-gateway">1.2.4 Kubernetes Ingress and Istio Gateway</h3>
<p>The kube-proxy can only route traffic inside the Kubernetes cluster,
while the Pods of the Kubernetes cluster are located in the network
created by CNI and cannot be communicated with directly outside the
cluster, so Ingress, a resource object, is created in Kubernetes and
driven by an Ingress Controller located at a Kubernetes edge node (there
can be many such Ingress must be docked to various Ingress Controllers,
such as Nginx Ingress Controller and Traefik, in order to be used. HTTP
traffic and is simple to use, but it can only match routed traffic to a
limited number of fields such as service, port, HTTP path, etc. This
makes it impossible to route TCP traffic such as MySQL, Redis, and
various private RPCs. To directly route north-south traffic, one can
only use the service's LoadBalancer or NodePort, the former requiring
cloud vendor support and the latter requiring additional port
management. Some Ingress Controllers support exposing TCP and UDP
services, but only using services to do so; Ingress itself does not
support this, for example, Nginx Ingress Controller, where the ports
exposed by the service are configured by creating a ConfigMap.</p>
<p>Istio Gateway functions similarly to Kubernetes Ingress in that it is
responsible for managing north-south traffic to and from the
cluster.Istio Gateway can be thought of as a load balancer for the
network, used to carry connections to and from the edge of the mesh.The
Istio Gateway specification describes a set of open ports and the
protocols used by those ports, the The Istio Gateway specification
describes a set of open ports and the protocols used for these ports,
the SNI configuration for load balancing, etc. The Gateway resource in
Istio is a CRD extension that also reuses the Sidecar proxy
functionality, see the official Istio website for detailed
configuration.</p>
<h3 id="125-xds-protocol">1.2.5 xDS protocol</h3>
<p>Figure 1-3 shows the control plane of Service Mesh, which readers may
have seen when learning about Service Mesh. Each square represents an
instance of a service, for example, a Pod in Kubernetes (which contains
a Sidecar agent). xDS protocol controls the specific behavior of all
traffic in the Istio Service Mesh, i.e., the squares in Figure 1-3 are
linked together.</p>
<p>Figure 1-3</p>
<p>xDS protocol is proposed by Envoy, in Envoy v2 version of the API of the
most original xDS protocol refers to CDS (Cluster Discovery Service),
EDS (Endpoint Discovery Service), LDS (Listener Discovery Service ) and
RDS (Route Discovery Service), later in Envoy v3 version of the xDS
protocol developed Scoped Route Discovery Service (SRDS), Virtual Host
Discovery Service (VHDS), Secret Discovery Service (SDS), Runtime
Discovery Service (RTDS).</p>
<p>The following is an understanding of the xDS protocol through the
communication of the two services, as shown in Figure 1-4.</p>
<p>Figure 1-4</p>
<p>The arrows in Figure 1-4 are not the paths or routes that traffic takes
once it enters the Proxy, nor are they the actual order, but a virtual
kind of xDS interface processing order. In fact, there are
cross-references between the various xDS protocols.</p>
<p>Agents that support the xDS protocol can dynamically discover resources
by querying files or managing servers. Broadly speaking, these discovery
services and their corresponding APIs are called xDS. Envoy obtains
resources by way of subscription (Subscription), and there are three
types of subscription.</p>
<ul>
<li>
<p>File subscription: monitors the files under the specified path. The
easiest way to discover dynamic resources is to save them in a file
and configure the path in the path parameter in the configSource.</p>
</li>
<li>
<p>gRPC streaming subscription: Each xDS API can be individually
configured with an ApiConfigSource pointing to the cluster address
of the corresponding upstream management server.</p>
</li>
<li>
<p>Polling REST-JSON polling subscriptions: A single xDS API can
perform synchronous (long) polling of REST endpoints.</p>
</li>
</ul>
<p>Istio uses gRPC streaming subscription to configure Sidecar Proxy for
all data planes. the following summarizes the key points about the xDS
protocol.</p>
<ul>
<li>
<p>CDS, EDS, LDS, and RDS are the most basic xDS protocols and can all
be updated independently.</p>
</li>
<li>
<p>All Discovery Services can connect to different management services,
which means that there can be more than one server managing xDS.</p>
</li>
<li>
<p>Envoy has made a series of expansions to the original xDS protocol,
adding APIs such as SDS (Key Discovery Service), ADS (Aggregate
Discovery Service), HDS (Health Discovery Service), MS (Metric
Service), and RLS (Rate Limiting Service).</p>
</li>
<li>
<p>In order to ensure data consistency, if the original xDS API is used
directly, it needs to be updated in the order of CDS â EDS â LDS â
RDS. This follows the Make-Before-Break principle in electrical
engineering, i.e., a new connection is established before the
original one is disconnected, and is applied in routing to prevent
traffic from being dropped due to the inability to discover the
upstream cluster when a new routing rule is set, similar to a
circuit break.</p>
</li>
<li>
<p>CDS is used to set which services are available in the service mesh.</p>
</li>
<li>
<p>EDS is used to set which instances (Endpoint) belong to these
services (Cluster).</p>
</li>
<li>
<p>LDS is used to set the ports listening on the instance to configure
the routes.</p>
</li>
<li>
<p>The RDS is the final routing relationship between services and
should be guaranteed to update the RDS last.</p>
</li>
</ul>
<h3 id="126-envoy">1.2.6 Envoy</h3>
<p>Envoy is the default Sidecar in the Istio service mesh, and Istio has
extended its control plane in accordance with Envoy's xDS protocol on
top of Envoy. Before explaining the Envoy xDS protocol, you need to
familiarize yourself with the basic terms of Envoy. The following lists
the basic terms in Envoy and their data structure analysis.</p>
<ul>
<li>
<p>Downstream (downstream): downstream hosts connect to Envoy, send
requests and receive responses, i.e. the hosts that send the
requests.</p>
</li>
<li>
<p>Upstream: The upstream host receives connections and requests from
Envoy and returns a response, i.e., the host receiving the request.</p>
</li>
<li>
<p>Listener (listener): listeners are named network addresses (for
example, ports, UNIX Domain Socket, etc.), and downstream clients
can connect to these listeners. envoy exposes one or more listeners
for downstream hosts to connect to.</p>
</li>
<li>
<p>Cluster (Cluster): Cluster is a group of logically identical
upstream hosts to which Envoy is connected.Envoy discovers the
members of a cluster through service discovery and can determine the
health status of cluster members through proactive health
checks.Envoy decides which member of the cluster to route requests
to through a load balancing policy.</p>
</li>
</ul>
<p>Envoy can set multiple Listener, and each Listener can set filterchain
(filter chain), and the filter is scalable, so that it is easier to
manipulate the traffic, for example, set encryption, private RPC, etc.</p>
<p>The xDS protocol was proposed by Envoy and is currently the default
Sidecar proxy in Istio. However, as long as the xDS protocol is
implemented, it can theoretically be used as a Sidecar proxy in Istio,
for example, MOSN, which is open source by Ant Group.</p>
<h3 id="127-istio-service-mesh">1.2.7 Istio Service Mesh</h3>
<p>Istio is a very feature-rich Service Mesh implementation that includes
the following features.</p>
<ul>
<li>
<p>Traffic management: This is the most basic feature of Istio.</p>
</li>
<li>
<p>Policy control: The Mixer component and various adapters enable
policy control such as access control system, telemetry capture,
quota management and billing.</p>
</li>
<li>
<p>Observability: Achieved through Mixer.</p>
</li>
<li>
<p>Secure authentication: Key and certificate management through
Citadel components.</p>
</li>
</ul>
<p>The following CRDs are defined in Istio to help users with traffic
management.</p>
<ul>
<li>
<p>Gateway: Describes a load balancer that runs at the edge of the
network to receive incoming or outgoing HTTP / TCP connections.</p>
</li>
<li>
<p>VirtualService: can actually connect Kubernetes services to the
Istio Gateway and can perform additional operations, such as
defining a set of traffic routing rules to be applied when a host is
addressed.</p>
</li>
<li>
<p>DestinationRule: Determines the access policy for the traffic after
routing. Simply put, it defines how traffic is routed. Among these
policies you can define load balancing configurations, connection
pool sizes and external detection (for identifying and expelling
unhealthy hosts in the load balancing pool) configurations.</p>
</li>
<li>
<p>EnvoyFilter: Describes filters for proxy services that customize the
proxy configuration generated by Istio Pilot. Beginner users
generally rarely use this configuration.</p>
</li>
<li>
<p>ServiceEntry: By default, services in the Istio Service mesh are
unable to discover services outside of the mesh. serviceEntry
enables additional entries to be added to the service registry
within Istio, allowing services in the service mesh to access and
route to those services that have been manually added.</p>
</li>
</ul>
<h2 id="13-what-is-istio">1.3 What is Istio</h2>
<p>Istio, an open source Service Mesh implementation, has been in the
limelight since its launch and has become a highly sought-after product by vendors and developers. The official Istio documentation defines it as &ldquo;a fully open source service mesh built transparently into existing distributed applications. It is also a platform with API interfaces that can integrate with any logging, telemetry, and policy system. Istio&rsquo;s diverse features enable you to run distributed microservice architectures successfully and efficiently, and provide a unified approach to protecting, connecting, and monitoring microservices.&rdquo;</p>
<p>As you can see from the official definition, Istio provides a complete
solution to manage and monitor microservice applications using a unified
approach. At the same time, it has features for managing traffic,
enforcing access policies, collecting data, and more, all of which are
transparent to the application and can be implemented with little to no
modification to business code.</p>
<p>With Istio, users can virtually eliminate the need to use other
microservices frameworks and implement features such as service
governance on their own. Just delegate the network layer to Istio, and
it will do this set of functions for you. Simply put, Istio is a service
mesh that provides service governance functionality.</p>
<h3 id="131-why-use-istio">1.3.1 Why use Istio</h3>
<p>Service Mesh is a service governance technology whose core function is
to control traffic. From this point of view, Service Mesh and existing
service governance products overlap in terms of functionality. If an
enterprise is using microservice applications that already have very
good service governance capabilities, it is not necessary to introduce
Service Mesh; however, if the enterprise is using systems that do not
have good governance capabilities, or if there are pain points in the
system architecture that can be solved by Service Mesh, then Service
Mesh is the best choice.</p>
<p>Compared to public library-based service governance products, the most
important feature of Service Mesh is its transparency to applications.
Not only can users seamlessly connect their microservice applications to
the mesh, but they do not need to modify the business logic. Istio
currently provides the following four important features.</p>
<ul>
<li>
<p>Automatic load balancing for HTTP, gRPC, WebSocket and TCP traffic.</p>
</li>
<li>
<p>Fine-grained control of traffic behavior through rich routing rules,
retries, failover and failover injection</p>
</li>
<li>
<p>Provides sophisticated observability aspects, including automated
metrics, logging and tracking of all mesh-controlled traffic.</p>
</li>
<li>
<p>Provides authentication and authorization policies to enable secure
inter-service communication in a cluster.</p>
</li>
</ul>
<h3 id="132-istios-platform-support">1.3.2 Istio's platform support</h3>
<p>Istio is platform independent and is designed to run in a variety of
environments, including cross-cloud, on-premise, Kubernetes, and more.
The platforms currently supported by Istio are.</p>
<ol>
<li>Services deployed in a Kubernetes cluster.</li>
<li>Services registered in Consul.</li>
<li>Services running in a separate virtual machine.</li>
</ol>
<h2 id="14-summary-of-this-chapter">1.4 Summary of this chapter</h2>
<p>This chapter introduces the basic concepts of Service Mesh and gives the reader an initial understanding of Istio. As a typical distributed system, larger microservices are increasingly in need of service governance, network communication, etc. Service Mesh plays such a role, giving microservice applications the ability to control traffic and other aspects in a way that is transparent to business logic.</p>
<p>Containerization and Kubernetes-based container orchestration have become the mainstream application deployment and management method in the industry, which also gives Service Mesh a better underlying support. With the continuous development of Service Mesh technology, Service Mesh will likely become the preferred technology solution for enterprise microservices and cloud transformation.</p>

          </div>

          <div class="col-12 mb-4">
            <div class="border-bottom">
            


<p class="edit-page">
<a href="https://github.com/rootsongjc/website/edit/master/content/en/blog/dui-service-mesh-overview/index.md">
  <i class="fa fa-pencil-square-o" aria-hidden="true"></i> Edit this page
  </a>
</p>


            </div>
          </div>
          
          <div class="col-12">
              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light">
              
              <a href="/en/tags/cloud-native" class="badge"> 
                  Cloud Native</a> </li>
          </div>

          
          
<div class="col-12">
<ul class="pager blog-pager">

<li class="previous">
<a href="https://jimmysong.io/en/blog/what-is-a-service-mesh/" data-toggle="tooltip" data-placement="top" title="What is a service mesh?">&larr; Previous Post</a>
</li>
 
<li class="next">
<a href="https://jimmysong.io/en/blog/istio-18-a-virtual-machine-integration-odyssey/" data-toggle="tooltip" data-placement="top" title="Istio 1.8: A Virtual Machine Integration Odyssey">Next Post &rarr;</a>
</li>

</ul>
</div>


          
          
          <div class="col-12">
          
           <script src="https://giscus.app/client.js"
        data-repo="rootsongjc/rootsongjc.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ1MzczNA=="
        data-category="Announcements"
        data-category-id="DIC_kwDOAd_yJs4CPNtR"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        
        data-lang="en"
        
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

          
          </div>
        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 sidebar">
      <!-- recommend -->
      

<div class="bg-white md-4">
  <p class="sidebar-title">
  Related article
  </p>
  <!-- post-item -->
  
  <div class="media border-bottom border-color pb-3 mb-3">
    <a href="/en/blog/what-is-a-service-mesh/"><img class="mr-3 post-thumb-sm" src="/images/banner/service-mesh-banner.jpg" alt="blog banner"></a>
    <div class="media-body">
      <a href="/en/blog/what-is-a-service-mesh/">
        <p class="mt-0">What is a service mesh?</p>
      </a>
      January 22, 2021
    </div>
  </div>
  
  <div class="media border-bottom border-color pb-3 mb-3">
    <a href="/en/blog/istio-1-8-a-smart-dns-proxy-takes-support-for-virtual-machines-a-step-further/"><img class="mr-3 post-thumb-sm" src="/images/banner/istio18.jpg" alt="blog banner"></a>
    <div class="media-body">
      <a href="/en/blog/istio-1-8-a-smart-dns-proxy-takes-support-for-virtual-machines-a-step-further/">
        <p class="mt-0">Istio 1.8: A Smart DNS Proxy Takes Support for Virtual Machines a Step Further</p>
      </a>
      November 19, 2020
    </div>
  </div>
  
  <div class="media border-bottom border-color pb-3 mb-3">
    <a href="/en/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/"><img class="mr-3 post-thumb-sm" src="/images/banner/istio-logo.webp" alt="blog banner"></a>
    <div class="media-body">
      <a href="/en/blog/how-to-integrate-virtual-machines-into-istio-service-mesh/">
        <p class="mt-0">How to Integrate Virtual Machines into Istio Service Mesh</p>
      </a>
      November 2, 2020
    </div>
  </div>
  
</div>


      <!-- /recommend -->
      <!-- toc -->
      
<div class="bg-white py-4 box-shadow mb-4 sticky-top aside-toc d-none d-sm-block">
    <p class="sidebar-title">
    Table of content
    </p>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#11-service-mesh-basic-concept">1.1 Service Mesh Basic Concept</a></li>
    <li><a href="#12-microservices-in-the-post-kubernetes-era">1.2 Microservices in the Post-Kubernetes Era</a>
      <ul>
        <li><a href="#121-important-points">1.2.1 Important points</a></li>
        <li><a href="#122-kubernetes-and-service-mesh">1.2.2 Kubernetes and Service Mesh</a></li>
        <li><a href="#123-the-kube-proxy-component">1.2.3 The kube-proxy component</a></li>
        <li><a href="#124-kubernetes-ingress-and-istio-gateway">1.2.4 Kubernetes Ingress and Istio Gateway</a></li>
        <li><a href="#125-xds-protocol">1.2.5 xDS protocol</a></li>
        <li><a href="#126-envoy">1.2.6 Envoy</a></li>
        <li><a href="#127-istio-service-mesh">1.2.7 Istio Service Mesh</a></li>
      </ul>
    </li>
    <li><a href="#13-what-is-istio">1.3 What is Istio</a>
      <ul>
        <li><a href="#131-why-use-istio">1.3.1 Why use Istio</a></li>
        <li><a href="#132-istios-platform-support">1.3.2 Istio's platform support</a></li>
      </ul>
    </li>
    <li><a href="#14-summary-of-this-chapter">1.4 Summary of this chapter</a></li>
  </ul>
</nav>
</div>

      <!-- /toc -->
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>



      
    

<footer>
  
  <div class="footer bg-footer section-sm border-bottom">
    <div class="container">
      <div class="row">
        <div class="col-lg-4 col-sm-8 mb-5 mb-lg-0">
          
          <h4 class="text-white mb-5 text-uppercase">Follow Me</h4>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Fellow me on twitter</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-twitter-qr-code.webp" width="128px" alt="footer image"></li>
            
            
            
          
        </div>
        
        

        
        <div class="col-lg-2 col-md-3 col-sm-4 col-6 mb-5 mb-md-0">
          <h4 class="text-white mb-5 text-uppercase">Blog</h4>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/why-istio-need-spire/">Why would you need SPIRE for authentication with Istio?</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-service-mesh-book/">In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/how-to-build-istio/">How to build Istio?</a></li>
            
          </ul>
        </div>

        
        <div class="col-lg-2 col-md-3 col-sm-4 col-6 mb-5 mb-md-0">
          <h4 class="text-white mb-5 text-uppercase">links</h4>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/awesome-cloud-native/" target="_blank" rel="noopener">Awesome Cloud Native</a></li>
            
            <li class="mb-3"><a class="text-color" href="https://cloudnative.to" target="_blank" rel="noopener">Cloud Native Community(China)</a></li>
            
            <li class="mb-3"><a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener">Tetrate - Service Mesh Company</a></li>
            
            <li class="mb-3"><a class="text-color" href="https://istio.tetratelabs.io/" target="_blank" rel="noopener">Tetrate Istio Distro</a></li>
            
          </ul>
        </div>

        
        <div class="col-lg-2 col-md-3 col-sm-4 col-6 mb-5 mb-md-0">
          <h4 class="text-white mb-5 text-uppercase">Courses</h4>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals-zh" target="_blank" rel="noopener">Istio Fundamentals</a></li>
            
            <li class="mb-3"><a class="text-color" href="https://lib.jimmysong.io/kubernetes-handbook/" target="_blank" rel="noopener">Kubernetes Handbook</a></li>
            
          </ul>
        </div>

        
        <div class="col-lg-2 col-md-3 col-sm-4 col-6 mb-5 mb-md-0">
          <h4 class="text-white mb-5 text-uppercase">new notice</h4>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/cloud-native-public-library/">Cloud Native library launch</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/tetrate-recruit/">The Enterprise Service Mesh company Tetrate is hiring</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/tetrate-istio-fundamental-courses/">Tetrate Academy Releases Free Istio Fundamentals Course</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer">
    <div class="container">
      <div class="row">
        <div class="col-sm-9 text-sm-left text-center">
          <p class="mb-0 text-color">Â© 2017-2022 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-3 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" rel="noopener"><i class="fa fa-twitter "></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" rel="noopener"><i class="fa fa-github "></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" rel="noopener"><i class="fa fa-linkedin "></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="mailto:jimmysong@jimmysong.io" target="_blank" rel="noopener"><i class="fa fa-envelope "></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="/blog/index.xml" target="_blank" rel="noopener"><i class="fa fa-rss "></i></a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>




<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.js"></script>

<!-- google analitycs -->

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-93485976-1', 'auto');
  ga('send', 'pageview');
</script>



<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>









<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, 'Copied')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>




<script>
tocbot.init({
  
  tocSelector: '.aside-toc #TableOfContents',
  
  contentSelector: '.content',
  
  headingSelector: 'h1, h2, h3, h4',
  
  hasInnerContainers: false,
  collapseDepth: 3
});
</script>












<script src="/js/wowchemy-search.min.d6b05289afb45cfed22e376a0e89bf9f.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content">
      <div class="search-hit-name">
        <div class="article-metadata search-hit-type">{{relpermalink}}</div>
        <a href="{{relpermalink}}">{{title}}</a>
        <p class="search-hit-description">{{snippet}}</p>
      </div>
    </div>
  </div>
</script>


</body>

</html>
