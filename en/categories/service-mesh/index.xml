<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy Song - Cloud Native | Open Source | Community â€“ Service Mesh</title>
    <link>https://jimmysong.io/en/categories/service-mesh/</link>
    <description>Recent content in Service Mesh on Jimmy Song - Cloud Native | Open Source | Community</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; 2020 Jimmy Song All Right Reserved; Powerd by Hugo with [educenter](https://github.com/themefisher/educenter-hugo) theme</copyright>
    <lastBuildDate>Wed, 01 Apr 2020 11:56:04 +0800</lastBuildDate>
    
	  <atom:link href="https://jimmysong.io/en/categories/service-mesh/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Service Mesh - the Microservices in Post Kubernetes Era</title>
      <link>https://jimmysong.io/en/blog/service-mesh-the-microservices-in-post-kubernetes-era/</link>
      <pubDate>Wed, 01 Apr 2020 11:56:04 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/service-mesh-the-microservices-in-post-kubernetes-era/</guid>
      <description>
        
        
        &lt;p&gt;This article is a rework of previously written content and is included in the &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34;&gt;Istio Handbook&lt;/a&gt; of the ServiceMesher community . Other chapters are still being compiled.&lt;/p&gt;
&lt;p&gt;People who have just heard of Service Mesh and tried &lt;a href=&#34;https://istio.io/&#34;&gt;Istio&lt;/a&gt; may have the following questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why does Istio bind Kubernetes?&lt;/li&gt;
&lt;li&gt;What roles do Kubernetes and Service Mesh play in cloud native?&lt;/li&gt;
&lt;li&gt;What aspects of Kubernetes has Istio extended? What problems have been solved?&lt;/li&gt;
&lt;li&gt;What is the relationship between Kubernetes, xDS protocols (&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34;&gt;Envoy&lt;/a&gt; , &lt;a href=&#34;https://github.com/mosn/mosn&#34;&gt;MOSN,&lt;/a&gt; etc) and Istio?&lt;/li&gt;
&lt;li&gt;Should I use Service Mesh?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this section, we will try to guide you through the internal connections between Kubernetes, the xDS protocol, and Istio Service Mesh. In addition, this section will also introduce the load balancing methods in Kubernetes, the significance of the xDS protocol for Service Mesh, and why Istio is needed in time for Kubernetes.&lt;/p&gt;
&lt;p&gt;Using Service Mesh is not to say that it will break with Kubernetes, but that it will happen naturally. The essence of Kubernetes is to perform application lifecycle management through declarative configuration, while the essence of Service Mesh is to provide traffic and security management and observability between applications. If you have built a stable microservice platform using Kubernetes, how do you set up load balancing and flow control for calls between services?&lt;/p&gt;
&lt;p&gt;The xDS protocol created by Envoy is supported by many open source software, such as &lt;a href=&#34;https://github.com/istio/istio&#34;&gt;Istio&lt;/a&gt; , &lt;a href=&#34;https://linkerd.io/&#34;&gt;Linkerd&lt;/a&gt; , &lt;a href=&#34;https://github.com/mosn/mosn&#34;&gt;MOSN,&lt;/a&gt; etc. Envoy&#39;s biggest contribution to Service Mesh or cloud native is the definition of xDS. Envoy is essentially a proxy. It is a modern version of proxy that can be configured through APIs. Based on it, many different usage scenarios are derived, such as API Gateway, Service Mesh. Sidecar proxy and Edge proxy in.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This section contains the following&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explain the role of kube-proxy.&lt;/li&gt;
&lt;li&gt;Kubernetes&amp;rsquo; limitations in microservice management.&lt;/li&gt;
&lt;li&gt;Describe the features of Istio Service Mesh.&lt;/li&gt;
&lt;li&gt;Describe what xDS includes.&lt;/li&gt;
&lt;li&gt;Compare some concepts in Kubernetes, Envoy and Istio Service Mesh.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;key-takeaways&#34;&gt;Key takeaways&lt;/h2&gt;
&lt;p&gt;If you want to know everything in advance, here are some of the key points from this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The essence of Kubernetes is application lifecycle management, specifically deployment and management (scaling, scaling, automatic recovery, release).&lt;/li&gt;
&lt;li&gt;Kubernetes provides a scalable and highly resilient deployment and management platform for microservices.&lt;/li&gt;
&lt;li&gt;The foundation of Service Mesh is a transparent proxy. After the traffic between microservices is intercepted through sidecar proxy, the behavior of microservices is managed through the control plane configuration.&lt;/li&gt;
&lt;li&gt;Service Mesh decoupled from Kubernetes traffic management, the internal flow without the need of Service Mesh &lt;code&gt;kube-proxy &lt;/code&gt;supporting components, micro-services closer to abstract the application layer by, for traffic between management services, security and observability.&lt;/li&gt;
&lt;li&gt;xDS defines the protocol standards for Service Mesh configuration.&lt;/li&gt;
&lt;li&gt;Service Mesh is a higher-level abstraction of services in Kubernetes. Its next step is serverless.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-vs-service-mesh&#34;&gt;Kubernetes vs Service Mesh&lt;/h2&gt;
&lt;p&gt;The following figure shows the service access relationship between Kubernetes and Service Mesh (one sidecar per pod mode).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubernetes-vs-service-mesh.png&#34; alt=&#34;kubernetes vs service mesh&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Traffic forwarding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each node of the cluster Kubernetes a deployed &lt;code&gt;kube-proxy&lt;/code&gt; assembly Kubernetes API Server may communicate with the cluster acquired &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/service.html&#34;&gt;service&lt;/a&gt; information, and then set iptables rules, sends a request for a service directly to the corresponding Endpoint (belonging to the same group service pod).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service discovery&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;istio-service-registry.png&#34; alt=&#34;Service registration in Service Mesh&#34;&gt;&lt;/p&gt;
&lt;p&gt;Istio Service Mesh can use the service in Kubernetes for service registration. It can also connect to other service discovery systems through the platform adapter of the control plane, and then generate the configuration of the data plane (using CRD statements, stored in etcd), a &lt;strong&gt;transparent proxy&lt;/strong&gt; for the data plane. (Transparent proxy) is deployed in the sidecar container in each application service pod. These proxy need to request the control plane to synchronize the proxy configuration. The reason why is a transparent proxy, because there is no application container fully aware agent, the process kube-proxy components like the need to block traffic, but &lt;code&gt;kube-proxy&lt;/code&gt;that blocks traffic to Kubernetes node and sidecar proxy that blocks out of the Pod For more information, see &lt;a href=&#34;https://jimmysong.io/en/blog/envoy-sidecar-routing-of-istio-service-mesh-deep-dive/&#34;&gt;Understanding Route Forwarding by the Envoy Sidecar Proxy in Istio Service Mesh&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages of Service Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Because each node on Kubernetes many runs Pod, the original &lt;code&gt;kube-proxy&lt;/code&gt;routing forwarding placed in each pod, the distribution will lead to a lot of configuration, synchronization, and eventual consistency problems. In order to perform fine-grained traffic management, a series of new abstractions will be added, which will further increase the user&#39;s learning costs. However, with the popularization of technology, this situation will gradually ease.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantages of Service Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kube-proxy&lt;/code&gt; The settings are globally effective, and fine-grained control of each service cannot be performed. Service Mesh uses sidecar proxy to extract the control of traffic in Kubernetes from the service layer, which can be further expanded.&lt;/p&gt;
&lt;h2 id=&#34;kube-proxy-component&#34;&gt;kube-proxy component&lt;/h2&gt;
&lt;p&gt;In Kubernetes cluster, each Node to run a &lt;code&gt;kube-proxy &lt;/code&gt; process. &lt;code&gt;kube-proxy&lt;/code&gt; Responsible for the &lt;code&gt;Service&lt;/code&gt; realization of a VIP (virtual IP) form. In Kubernetes v1.0, the proxy is implemented entirely in userspace. Kubernetes v1.1 adds the &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/service.html#iptables-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F&#34;&gt;iptables proxy mode&lt;/a&gt; , but it is not the default operating mode. As of Kubernetes v1.2, the iptables proxy is used by default. In Kubernetes v1.8.0-beta.0, the &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/service.html#ipvs-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F&#34;&gt;ipvs proxy mode was added&lt;/a&gt; . More about kube-proxy component description please refer &lt;a href=&#34;https://cizixs.com/2017/03/30/kubernetes-introduction-service-and-kube-proxy/&#34;&gt;kubernetes Description: service and kube-proxy principle&lt;/a&gt; and &lt;a href=&#34;https://jishu.io/kubernetes/ipvs-loadbalancer-for-kubernetes/&#34;&gt;use IPVS achieve Kubernetes inlet flow load balancing&lt;/a&gt; .&lt;/p&gt;
&lt;h3 id=&#34;kube-proxy-flaws&#34;&gt;kube-proxy flaws&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://cizixs.com/2017/03/30/kubernetes-introduction-service-and-kube-proxy/&#34;&gt;The disadvantages of kube-proxy&lt;/a&gt; :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;First, if forwarded pod can not provide normal service, it does not automatically try another pod, of course, this can &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html&#34;&gt;&lt;code&gt;liveness probes&lt;/code&gt;&lt;/a&gt; be solved. Each pod has a health check mechanism. When there is a problem with the health of the pod, kube-proxy will delete the corresponding forwarding rule. In addition, &lt;code&gt;nodePort&lt;/code&gt;types of services cannot add TLS or more sophisticated message routing mechanisms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kube-proxy implements load balancing of traffic among multiple pod instances of the Kubernetes service, but how to fine-grained control the traffic between these services, such as dividing the traffic into different application versions by percentage (these applications belong to the same service , But on a different deployment), do canary release and blue-green release? Kubernetes community gives the &lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments&#34;&gt;method using the Deployment do canary release&lt;/a&gt; , essentially by modifying the pod of the method &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/label.html&#34;&gt;label&lt;/a&gt; different pod to be classified into the Deployment of Service.&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-ingress-vs-istio-gateway&#34;&gt;Kubernetes Ingress vs. Istio Gateway&lt;/h2&gt;
&lt;p&gt;Speaking above &lt;code&gt;kube-proxy&lt;/code&gt;the flow inside the only route Kubernetes clusters, and we know that Pod Kubernetes cluster located &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/cni.html&#34;&gt;CNI&lt;/a&gt; outside the network created, external cluster is unable to communicate directly with, so Kubernetes created in the &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/ingress.html&#34;&gt;ingress&lt;/a&gt; of this resource object, which is located by the Kubernetes &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/practice/edge-node-configuration.html&#34;&gt;edge nodes&lt;/a&gt; (such nodes can be many or a group) are driven by the Ingress controller, which is responsible for managing &lt;strong&gt;north-south traffic&lt;/strong&gt; . Ingress must be &lt;a href=&#34;https://traefik.io/&#34;&gt;connected to&lt;/a&gt; various ingress controllers, such as &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34;&gt;nginx ingress controller&lt;/a&gt; and &lt;a href=&#34;https://traefik.io/&#34;&gt;traefik&lt;/a&gt; . Ingress is only applicable to HTTP traffic, and its usage is also very simple. It can only route traffic by matching limited fields such as service, port, and HTTP path, which makes it unable to route TCP traffic such as MySQL, Redis, and various private RPCs. To directly route north-south traffic, you can only use Service&#39;s LoadBalancer or NodePort. The former requires cloud vendor support, while the latter requires additional port management. Some Ingress controllers support exposing TCP and UDP services, but they can only be exposed using Services. Ingress itself does not support it, such as the &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/&#34;&gt;nginx ingress controller&lt;/a&gt; . The exposed port of the service is configured by creating a ConfigMap.&lt;/p&gt;
&lt;p&gt;Istio Gateway is similar to Kubernetes Ingress in that it is responsible for north-south traffic to the cluster. &lt;code&gt;Gateway&lt;/code&gt;The load balancer described by Istio is used to carry connections in and out of the edge of the mesh. The specification describes a series of open ports and the protocols used by these ports, SNI configuration for load balancing, and so on. Gateway is a &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/crd.html&#34;&gt;CRD extension&lt;/a&gt; . It also &lt;a href=&#34;https://istio.io/docs/reference/config/networking/gateway/&#34;&gt;reuses&lt;/a&gt; the capability of sidecar proxy. For detailed configuration, please refer to &lt;a href=&#34;https://istio.io/docs/reference/config/networking/gateway/&#34;&gt;Istio official website&lt;/a&gt; .&lt;/p&gt;
&lt;h2 id=&#34;xds-protocol&#34;&gt;xDS protocol&lt;/h2&gt;
&lt;p&gt;You may have seen the following picture when you understand Service Mesh. Each block represents an instance of a service, such as a Pod in Kubernetes (which contains a sidecar proxy). The xDS protocol controls all traffic in Istio Service Mesh. The specific behavior is to link the squares in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;service-mesh-schematic-diagram.png&#34; alt=&#34;Service Mesh diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;The xDS protocol was proposed by &lt;a href=&#34;https://envoyproxy.io/&#34;&gt;Envoy&lt;/a&gt; . The original xDS protocols in the Envoy v2 API refer to CDS (Cluster Discovery Service), EDS (Endpoint Discovery Service), LDS (Listener Discovery Service), and RDS (Route Discovery Service). Later, in the v3 version, Scoped Route Discovery Service (SRDS), Virtual Host Discovery Service (VHDS), Secret Discovery Service (SDS), and Runtime Discovery Service (RTDS) were developed. See the &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34;&gt;xDS REST and gRPC protocol for&lt;/a&gt; details .&lt;/p&gt;
&lt;p&gt;Let&#39;s take a look at the xDS protocol with a service with two instances each.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gde7ydng3ij30s80j4aba.jpg&#34; alt=&#34;xDS protocol&#34;&gt;&lt;/p&gt;
&lt;p&gt;The arrow in the figure above is not the path or route after the traffic enters the proxy, nor is it the actual sequence. It is an imagined xDS interface processing sequence. In fact, there are cross references between xDS.&lt;/p&gt;
&lt;p&gt;Agents that support the xDS protocol dynamically discover resources by querying files or managing servers. In summary, the corresponding discovery service and its corresponding API are called  xDS. Envoy by &lt;strong&gt;subscription (subscription)&lt;/strong&gt; to get the resources the way, there are three ways to subscribe:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File subscription&lt;/strong&gt; : Monitor files in the specified path, the easiest way to find dynamic resource is to save it in a file and path configuration in &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/config_source.proto#core-configsource&#34;&gt;ConfigSource&lt;/a&gt; the &lt;code&gt;path&lt;/code&gt;parameter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gRPC streaming subscription&lt;/strong&gt; : Each xDS API can be individually configured &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/config_source.proto#core-apiconfigsource&#34;&gt;&lt;code&gt;ApiConfigSource&lt;/code&gt;&lt;/a&gt;to point to the cluster address of the corresponding upstream management server.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Polling REST-JSON polling subscription&lt;/strong&gt; : A single xDS API can perform synchronous (long) polling of REST endpoints.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For details of the above xDS subscription methods, please refer to the &lt;a href=&#34;https://jimmysong.io/istio-handbook/concepts/envoy-xds-protocol.html&#34;&gt;xDS protocol analysis&lt;/a&gt; . Istio uses gRPC streaming subscriptions to configure sidecar proxy for all data planes.&lt;/p&gt;
&lt;p&gt;The article introduces the overall architecture of the Istio pilot, the generation of proxy configuration, the function of the pilot-discovery module, and the CDS, EDS, and ADS in the xDS protocol. For details on ADS, please refer to the &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/service/discovery/v2/ads.proto&#34;&gt;official Envoy documentation&lt;/a&gt; .&lt;/p&gt;
&lt;h3 id=&#34;xds-protocol-highlights&#34;&gt;xDS protocol highlights&lt;/h3&gt;
&lt;p&gt;Finally, summarize the main points about the xDS protocol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDS, EDS, LDS, and RDS are the most basic xDS protocols, and they can be updated independently.&lt;/li&gt;
&lt;li&gt;All Discovery Services can connect to different Management Servers, which means that there can be multiple servers managing xDS.&lt;/li&gt;
&lt;li&gt;Envoy has made a series of extensions based on the original xDS protocol, adding SDS (Key Discovery Service), ADS (Aggregated Discovery Service), HDS (Health Discovery Service), MS (Metric Service), RLS (Rate Limiting Service) Wait for the API.&lt;/li&gt;
&lt;li&gt;To ensure data consistency, if used directly xDS original API, it needs to ensure that such sequential update: CDS -&amp;gt; EDS -&amp;gt; LDS -&amp;gt; RDS, which is to follow the electronic engineering &lt;strong&gt;before-break&lt;/strong&gt; (Make-Before-Break) The principle is to establish a new connection before disconnecting the original connection. The application in routing is to prevent the situation where the upstream cluster cannot be found and the traffic is dropped when a new routing rule is set, similar to the circuit Open circuit.&lt;/li&gt;
&lt;li&gt;CDS sets which services are in the service mesh.&lt;/li&gt;
&lt;li&gt;EDS sets which instances (Endpoints) belong to these services (Cluster).&lt;/li&gt;
&lt;li&gt;LDS sets the listening port on the instance to configure routing.&lt;/li&gt;
&lt;li&gt;The routing relationship between RDS final services should ensure that RDS is updated last.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;envoy&#34;&gt;Envoy&lt;/h2&gt;
&lt;p&gt;Envoy is the default sidecar in Istio Service Mesh. Based on Enovy, Istio has extended its control plane in accordance with Envoy&#39;s xDS protocol. Before talking about the Envoy xDS protocol, we need to be familiar with the basic terms of Envoy. The following lists the basic terms and data structure analysis in Envoy. For a detailed introduction to &lt;a href=&#34;http://www.servicemesher.com/envoy/&#34;&gt;Envoy&lt;/a&gt; , please refer to the &lt;a href=&#34;http://www.servicemesher.com/envoy/&#34;&gt;official Envoy document&lt;/a&gt; . As for how Envoy works as a forwarding proxy in Service Mesh (not limited to Istio), please refer to NetEase Cloud Liu Chao this &lt;a href=&#34;https://www.cnblogs.com/163yun/p/8962278.html&#34;&gt;in-depth interpretation of the technical details behind the Service Mesh&lt;/a&gt; and &lt;a href=&#34;https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&#34;&gt;understanding Istio Service Mesh Envoy agent in Sidecar injection and traffic hijacking&lt;/a&gt; , in which the article refers to some of the points, the details will not be repeated.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;envoy-arch.png&#34; alt=&#34;Envoy proxy architecture diagram&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;basic-terminology&#34;&gt;Basic terminology&lt;/h3&gt;
&lt;p&gt;Here are the basic terms in Enovy you should know:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Downstream&lt;/strong&gt; : The downstream host connects to Envoy, sends a request and receives a response, that is, the host sending the request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upstream&lt;/strong&gt; : The upstream host receives the connection and request from Envoy and returns a response, that is, the host that accepted the request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Listener&lt;/strong&gt; : The listener is a named network address (for example, port, unix domain socket, etc.), and downstream clients can connect to these listeners. Envoy exposes one or more listeners to connect to downstream hosts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt; : A cluster is a group of logically identical upstream hosts connected to Envoy. Envoy &lt;a href=&#34;http://www.servicemesher.com/envoy/intro/arch_overview/service_discovery.html#arch-overview-service-discovery&#34;&gt;discovers&lt;/a&gt; members of the cluster through &lt;a href=&#34;http://www.servicemesher.com/envoy/intro/arch_overview/service_discovery.html#arch-overview-service-discovery&#34;&gt;service discovery&lt;/a&gt; . You can choose to determine the health status of cluster members through &lt;a href=&#34;http://www.servicemesher.com/envoy/intro/arch_overview/health_checking.html#arch-overview-health-checking&#34;&gt;active health checks&lt;/a&gt; . Envoy uses &lt;a href=&#34;http://www.servicemesher.com/envoy/intro/arch_overview/load_balancing.html#arch-overview-load-balancing&#34;&gt;load balancing policies&lt;/a&gt; to decide which member of the cluster to route requests to.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Envoy can set multiple Listeners, and each Listener can also set a filter chain, and the filters are extensible, which can make it easier for us to manipulate traffic behavior, such as setting encryption, private RPC, and so on.&lt;/p&gt;
&lt;p&gt;The xDS protocol was proposed by Envoy and is now the default sidecar proxy in Istio. However, as long as the xDS protocol is implemented, it can theoretically be used as a sidecar proxy in Istio, such as the open source proxy &lt;a href=&#34;https://github.com/mosn/mosn&#34;&gt;MOSN&lt;/a&gt; by &lt;a href=&#34;https://www.antfin.com&#34;&gt;Ant Financial&lt;/a&gt; .&lt;/p&gt;
&lt;h2 id=&#34;istio-service-mesh&#34;&gt;Istio Service Mesh&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;istio-mesh-arch.png&#34; alt=&#34;Istio service mesh architecture diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;Istio is a very feature-rich Service Mesh, which includes the following functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Management: This is the most basic feature of Istio.&lt;/li&gt;
&lt;li&gt;Policy control: Implemented through Mixer components and various adapters to implement access control systems, telemetry capture, quota management, and billing.&lt;/li&gt;
&lt;li&gt;Observability: Achieved through Mixer.&lt;/li&gt;
&lt;li&gt;Security certification: Citadel components do key and certificate management.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;traffic-management-in-istio&#34;&gt;Traffic Management in Istio&lt;/h3&gt;
&lt;p&gt;Istio defined as the &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/concepts/custom-resource.html&#34;&gt;CRD&lt;/a&gt; to help users perform traffic management:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gateway&lt;/strong&gt; : &lt;a href=&#34;https://istio.io/docs/reference/config/networking/gateway/&#34;&gt;Gateway&lt;/a&gt; describes a load balancer running at the edge of the network for receiving incoming or outgoing HTTP / TCP connections.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VirtualService&lt;/strong&gt; : &lt;a href=&#34;https://istio.io/docs/reference/config/networking/virtual-service/&#34;&gt;VirtualService&lt;/a&gt; actually connects Kubernetes services to Istio Gateway. It can also do more, such as defining a set of traffic routing rules to apply when a host is addressed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DestinationRule&lt;/strong&gt; : &lt;a href=&#34;https://istio.io/zh/docs/reference/config/networking/destination-rule/&#34;&gt;&lt;code&gt;DestinationRule&lt;/code&gt;&lt;/a&gt;The defined policy determines the access policy of the traffic after routing processing. Simply put, it defines how the traffic is routed. These policies can define load balancing configurations, connection pool sizes, and external detection (used to identify and evict unhealthy hosts in a load balancing pool) configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EnvoyFilter&lt;/strong&gt; : The &lt;a href=&#34;https://istio.io/docs/reference/config/networking/envoy-filter/&#34;&gt;&lt;code&gt;EnvoyFilter&lt;/code&gt;&lt;/a&gt;object describes filters for proxy services that can customize the proxy configuration generated by Istio Pilot. This configuration is rarely used by beginning users.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ServiceEntry&lt;/strong&gt; : By default, services in Istio Service Mesh cannot discover services outside Mesh. It &lt;a href=&#34;https://istio.io/docs/reference/config/networking/service-entry/&#34;&gt;&lt;code&gt;ServiceEntry&lt;/code&gt;&lt;/a&gt;can add additional entries to the service registry inside Istio, so that services automatically discovered in the mesh can access and route to these manual Joined services.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-vs-xds-vs-istio&#34;&gt;Kubernetes vs xDS vs Istio&lt;/h2&gt;
&lt;p&gt;After the reading of the above Kubernetes &lt;code&gt;kube-proxy&lt;/code&gt;after abstraction component, and XDS Istio in traffic management, we will take you far as the traffic management aspect of comparison components corresponding to the three / protocol (note, not completely three equivalents).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Governors&lt;/th&gt;
&lt;th&gt;xDS&lt;/th&gt;
&lt;th&gt;Istio Service Mesh&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;VirtualService&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;DestinationRule&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;EnvoyFilter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ingress&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;Gateway&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Cluster&lt;/td&gt;
&lt;td&gt;ServiceEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you say that the objects managed by Kubernetes are Pods, then the objects managed by Service Mesh are Service. Therefore, it is a natural thing to apply Service Mesh after using Kubernetes to manage microservices. If you do nâ€™t want to manage even the Service, use &lt;a href=&#34;https://github.com/knative/&#34;&gt;serverless&lt;/a&gt; platforms like knative, but that&#39;s what comes next.&lt;/p&gt;
&lt;p&gt;The function of Envoy/MOSN is not just for traffic forwarding. The above concepts are just the tip of the iceberg in Istio&#39;s new layer of abstraction over Kubernetes. This will be the beginning of the book.&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/163yun/p/8962278.html&#34;&gt;In-depth interpretation of the technical details behind Service Mesh-cnblogs.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&#34;&gt;Understanding Envoy Proxy Sidecar Injection and Traffic Hijacking in Istio Service Mesh - jimmysong.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cizixs.com/2017/03/30/kubernetes-introduction-service-and-kube-proxy/&#34;&gt;Introduction to kubernetes: service and kube-proxy principles - cizixs.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jishu.io/kubernetes/ipvs-loadbalancer-for-kubernetes/&#34;&gt;Kubernetes Ingress Traffic Load Balancing Using IPVS - jishu.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34;&gt;xDS REST and gRPC protocol - envoyproxy.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Understanding How Envoy Sidecar Intercept and Route Traffic in Istio Service Mesh</title>
      <link>https://jimmysong.io/en/blog/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh/</link>
      <pubDate>Thu, 27 Dec 2018 10:01:22 +0800</pubDate>
      
      <guid>https://jimmysong.io/en/blog/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh/</guid>
      <description>
        
        
        &lt;p&gt;This article uses Istio&#39;s official &lt;a href=&#34;https://preliminary.istio.io/zh/docs/examples/bookinfo&#34;&gt;bookinfo example&lt;/a&gt; to explain how Envoy performs routing forwarding after the traffic entering the Pod and forwarded to Envoy sidecar by iptables, detailing the inbound and outbound processing. For a detailed analysis of traffic interception, see &lt;a href=&#34;https://jimmysong.io/posts/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&#34;&gt;Understanding Envoy Sidecar Proxy Injection and Traffic Interception in Istio Service Mesh&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;The following is a request flow diagram for bookinfo officially provided by Istio, assuming that the DestinationRule is not configured in all services of the bookinfo application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;006tNbRwly1fyitp0jsghj31o70u0x6p.jpg&#34; alt=&#34;bookinfo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;overview-of-sidecar-injection-and-traffic-interception-steps&#34;&gt;Overview of Sidecar Injection and Traffic Interception Steps&lt;/h2&gt;
&lt;p&gt;Below is an overview of the steps from Sidecar injection, Pod startup to Sidecar proxy interception traffic and Envoy processing routing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Kubernetes automatically injected through Admission Controller, or the user run &lt;code&gt;istioctl&lt;/code&gt; command to manually inject sidecar container.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Apply the YAML configuration deployment application. At this time, the service creation configuration file received by the Kubernetes API server already includes the Init container and the sidecar proxy.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Before the sidecar proxy container and application container are started, the Init container started firstly. The Init container is used to set iptables (the default traffic interception method in Istio, and can also use BPF, IPVS, etc.) to Intercept traffic entering the pod to Envoy sidecar Proxy. All TCP traffic (Envoy currently only supports TCP traffic) will be Intercepted by sidecar, and traffic from other protocols will be requested as originally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Launch the Envoy sidecar proxy and application container in the Pod. For the process of this step, please refer to &lt;a href=&#34;https://zhaohuabing.com/post/2018-09-25-istio-traffic-management-impl-intro/#%E9%80%9A%E8%BF%87%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE&#34;&gt;the complete configuration through the management interface&lt;/a&gt; .&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sidecar proxy and application container startup order issues&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Start the sidecar proxy and the application container. Which container is started first? Normally, Envoy Sidecar and the application container are all started up before receiving traffic requests. But we can&#39;t predict which container will start first, so does the container startup order have an impact on Envoy hijacking traffic? The answer is yes, but it is divided into the following two situations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case 1: The application container starts first, and the sidecar proxy is still not ready&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this case, the traffic is transferred to the 15001 port by iptables, and the port is not monitored in the Pod. The TCP link cannot be established and the request fails.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Case 2: Sidecar starts first, the request arrives and the application is still not ready&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this case, the request will certainly fail. As for the step at which the failure begins, the reader is left to think.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; : If adding a &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html&#34;&gt;readiness and living probe&lt;/a&gt; for the sidecar proxy and application container can solve the problem?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; TCP requests that are sent or received from the Pod will be hijacked by iptables. After the inbound traffic is hijacked, it is processed by the Inbound Handler and then forwarded to the application container for processing. The outbound traffic is hijacked by iptables and then forwarded to the Outbound Handler for processing. Upstream and Endpoint.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; Sidecar proxy requests Pilot to use the xDS protocol to synchronize Envoy configurations, including LDS, EDS, CDS, etc., but to ensure the order of updates, Envoy will use ADS to request configuration updates from Pilot directly.&lt;/p&gt;
&lt;h2 id=&#34;how-envoy-handles-route-forwarding&#34;&gt;How Envoy handles route forwarding&lt;/h2&gt;
&lt;p&gt;The following figure shows a &lt;code&gt;productpage&lt;/code&gt;service access request &lt;code&gt;http://reviews.default.svc.cluster.local:9080/&lt;/code&gt;, when traffic enters &lt;code&gt;reviews&lt;/code&gt; the internal services, &lt;code&gt;reviews&lt;/code&gt; internal services Envoy Sidecar is how to do traffic blocked the route forward. The original image can be downloaded on &lt;a href=&#34;https://drive.google.com/file/d/1n-h235tm8DnL_RqxTTA95rgGtrLkBsyr/view?usp=sharing&#34;&gt;Google Drive&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;istio-envoy-sidecar-traffic-injection.jpg&#34; alt=&#34;istio iptables&#34;&gt;&lt;/p&gt;
&lt;p&gt;Before the first step, &lt;code&gt;productpage&lt;/code&gt; Envoy Sidecar Pod has been selected by EDS of a request to &lt;code&gt;reviews&lt;/code&gt; a Pod service of its IP address, it sends a TCP connection request.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://preliminary.istio.io/zh/help/ops/traffic-management/proxy-cmd/#envoy-%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90&#34;&gt;Envoy configuration&lt;/a&gt; in the official website of Istio is to describe the process of Envoy doing traffic forwarding. The party considering the traffic of the downstream is to receive the request sent by the downstream. You need to request additional services, such as &lt;code&gt;reviews&lt;/code&gt; service requests need Pod &lt;code&gt;ratings&lt;/code&gt; service.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reviews&lt;/code&gt;, there are three versions of the service, there is one instance of each version, three versions sidecar similar working steps, only to later &lt;code&gt;reviews-v1-cb8655c75-b97zc&lt;/code&gt; Sidecar flow Pod forwarding this step will be described.&lt;/p&gt;
&lt;h2 id=&#34;understand-the-inbound-handler&#34;&gt;Understand the Inbound Handler&lt;/h2&gt;
&lt;p&gt;The role of the inbound handler is to transfer the traffic from the downstream intercepted by iptables to localhost to establish a connection with the application container inside the Pod.&lt;/p&gt;
&lt;p&gt;Look &lt;code&gt;reviews-v1-cb8655c75-b97zc&lt;/code&gt; at the Listener in the pod.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;istioctl pc listener reviews-v1-cb8655c75-b97zc&lt;/code&gt; to see what the Pod has a Listener.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;ADDRESS            PORT      TYPE &lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;172.33.3.3         9080      HTTP &amp;lt;---  Receives all inbound traffic on 9080 from listener 0.0.0.0_15001&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.0.1         443       TCP  &amp;lt;--+&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.4.253       80        TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.4.253       8080      TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.109.182     443       TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.22.50       15011     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.22.50       853       TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.79.114      443       TCP     | &lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.143.179     15011     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.0.2         53        TCP     | Receives outbound non-HTTP traffic for relevant IP:PORT pair from listener 0.0.0.0_15001&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.22.50       443       TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.16.64       42422     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.127.202     16686     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.22.50       31400     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.22.50       8060      TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.169.13      14267     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.169.13      14268     TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.32.134      8443      TCP     |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;10.254.118.196     443       TCP  &amp;lt;--+&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            15004     HTTP &amp;lt;--+&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            8080      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            15010     HTTP    | &lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            8088      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            15031     HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            9090      HTTP    | &lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            9411      HTTP    |  Receives outbound HTTP traffic for relevant port from listener 0.0.0.0_15001&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            80        HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            15030     HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            9080      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            9093      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            3000      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            8060      HTTP    |&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            9091      HTTP &amp;lt;--+    &lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;0.0.0.0            15001     TCP  &amp;lt;--- Receives all inbound and outbound traffic to the pod from IP tables and hands over to virtual listener&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As from &lt;code&gt;productpage&lt;/code&gt; traffic arriving &lt;code&gt;reviews&lt;/code&gt; Pods, downstream must clearly know the IP address of the Pod which is &lt;code&gt;172.33.3.3&lt;/code&gt;, so the request is &lt;code&gt;172.33.3.3:9080&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;virtual Listener&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you can see from the Pod&#39;s Listener list, the 0.0.0.0:15001/TCP Listener (the actual name is &lt;code&gt;virtual&lt;/code&gt;) listens for all inbound traffic, and the following is the detailed configuration of the Listener.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;virtual&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15001&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;filterChains&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;envoy.tcp_proxy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;BlackHoleCluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;stat_prefix&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;BlackHoleCluster&amp;#34;&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;useOriginalDst&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;UseOriginalDst&lt;/strong&gt; : As can be seen from the configuration in &lt;code&gt;useOriginalDst&lt;/code&gt;the configuration as specified &lt;code&gt;true&lt;/code&gt;, which is a Boolean value, the default is false, using iptables redirect connections, the proxy may receive port &lt;a href=&#34;http://www.servicemesher.com/envoy/configuration/listener_filters/original_dst_filter.html&#34;&gt;original destination address&lt;/a&gt; is not the same port, thus received at the proxy port It is 15001 and the original destination port is 9080. When this flag is set to true, the Listener redirects the connection to the Listener associated with the original destination address, here &lt;code&gt;172.33.3.3:9080&lt;/code&gt;. Listener If no relationship to the original destination address, the connection processing by the Listener to receive it, i.e. the &lt;code&gt;virtual&lt;/code&gt;Listener, after &lt;code&gt;envoy.tcp_proxy&lt;/code&gt;forwarded to a filter process &lt;code&gt;BlackHoleCluster&lt;/code&gt;, as the name implies, when no matching Envoy virtual listener when the effect of Cluster , will send the request to it and return 404. This will be referred to below Listener provided &lt;code&gt;bindToPort&lt;/code&gt;echoes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : This parameter will be discarded, please use the Listener filter of the &lt;a href=&#34;http://www.servicemesher.com/envoy/configuration/listener_filters/original_dst_filter.html&#34;&gt;original destination address&lt;/a&gt; instead. The main purpose of this parameter is: Envoy listens to the 15201 port to intercept the traffic intercepted by iptables via other Listeners instead of directly forwarding it. See the &lt;a href=&#34;https://zhaohuabing.com/post/2018-09-25-istio-traffic-management-impl-intro/#virtual-listener&#34;&gt;Virtual Listener&lt;/a&gt; for details .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Listener 172.33.3.3_9080&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As mentioned above, the traffic entering the inbound handler is &lt;code&gt;virtual&lt;/code&gt; transferred to the &lt;code&gt;172.33.3.3_9080&lt;/code&gt; Listener by the Listener. We are looking at the Listener configuration.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json&lt;/code&gt; view.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;172.33.3.3_9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;172.33.3.3&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9080&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;filterChains&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filterChainMatch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;transportProtocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;raw_buffer&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;envoy.http_connection_manager&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt; 
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;route_config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;validate_clusters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtual_hosts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;domains&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                        &lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
                                    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|http|9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;routes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                            &lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
                                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;route&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;max_grpc_timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;
                                            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                                        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                                    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
                                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
                        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;use_remote_address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;ï¼Œ&lt;/span&gt;
            &lt;span class=&#34;s2&#34;&gt;&amp;#34;deprecatedV1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;bindToPort&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filterChainMatch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;transportProtocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;tls&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;tlsContext&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;bindToPort&lt;/strong&gt; : Note that there are a &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.6.0/api-v1/listeners/listeners&#34;&gt;&lt;code&gt;bindToPort&lt;/code&gt;&lt;/a&gt;configuration that is &lt;code&gt;false&lt;/code&gt;, the default value of the configuration &lt;code&gt;true&lt;/code&gt;, showing Listener bind to the port, set here to &lt;code&gt;false&lt;/code&gt; the process flow can Listener Listener transferred from the other, i.e., above said &lt;code&gt;virtual&lt;/code&gt; Listener, where we see filterChains.filters in the &lt;code&gt;envoy.http_connection_manager&lt;/code&gt; configuration section:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;route_config&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;validate_clusters&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtual_hosts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;domains&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                        &lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
                                    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|http|9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;routes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                                        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                            &lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
                                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;route&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;max_grpc_timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                                                &lt;span class=&#34;nt&#34;&gt;&amp;#34;timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;
                                            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                                        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                                    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
                                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
                        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This configuration indicates that traffic will be handed off to the Cluster for &lt;code&gt;inbound|9080||reviews.default.svc.cluster.local&lt;/code&gt; processing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cluster inbound|9080||reviews.default.svc.cluster.local&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json&lt;/code&gt; to see the Cluster configuration is as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;connectTimeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.000s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;hosts&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9080&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;circuitBreakers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;thresholds&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can see that the Endpoint of the Cluster directly corresponds to localhost, and then the traffic is forwarded by the application container after iptables.&lt;/p&gt;
&lt;h2 id=&#34;understand-the-outbound-handler&#34;&gt;Understand the Outbound Handler&lt;/h2&gt;
&lt;p&gt;Because the &lt;code&gt;reviews&lt;/code&gt; will to &lt;code&gt;ratings&lt;/code&gt; send an HTTP request service, request address are: &lt;code&gt;http://ratings.default.svc.cluster.local:9080/&lt;/code&gt; the role of Outbound handler is to intercept traffic to iptables to native applications sent via Envoy to determine how to route to the upstream.&lt;/p&gt;
&lt;p&gt;The request sent by the application container is outbound traffic. After being hijacked by iptables, it is transferred to the Envoy Outbound handler for processing, then passed through &lt;code&gt;virtual&lt;/code&gt; Listener and &lt;code&gt;0.0.0.0_9080&lt;/code&gt; Listener, and then finds the cluster of upstream through Route 9080, and then finds Endpoint through EDS to perform routing action. This section can refer to the &lt;a href=&#34;https://preliminary.istio.io/zh/help/ops/traffic-management/proxy-cmd/#envoy-%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90&#34;&gt;Envoy depth configuration resolution&lt;/a&gt; in the official Istio website .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Route 9080&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reviews&lt;/code&gt; requests &lt;code&gt;ratings&lt;/code&gt; service, run &lt;code&gt;istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json&lt;/code&gt; view route configuration because Envoy VirtualHost will be matched according to HTTP header of domains, so the following list only &lt;code&gt;ratings.default.svc.cluster.local:9080&lt;/code&gt; this one VirtualHost.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster.local:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;domains&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster.local:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default:9080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.254.234.130&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.254.234.130:9080&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;routes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;match&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;prefix&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;route&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;outbound|9080||ratings.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;maxGrpcTimeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.000s&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;decorator&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;operation&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratings.default.svc.cluster.local:9080/*&amp;#34;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;perFilterConfig&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can see the routing of traffic to the Cluster from this Virtual Host configuration &lt;code&gt;outbound|9080||ratings.default.svc.cluster.local&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Endpoint outbound|9080||ratings.default.svc.cluster.local&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio 1.1 previous versions do not support the use of &lt;code&gt;istioctl&lt;/code&gt; commands to directly query Endpoint Cluster, you can use the debug queries Pilot endpoint way compromise.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; reviews-v1-cb8655c75-b97zc -c istio-proxy curl http://istio-pilot.istio-system.svc.cluster.local:9093/debug/edsz &amp;gt; endpoints.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;endpoints.json&lt;/code&gt; file contains all the Endpoint information of the Cluster, and we only select &lt;code&gt;outbound|9080||ratings.default.svc.cluster.local&lt;/code&gt; the results of the Cluster as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;clusterName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;outbound|9080||ratings.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;endpoints&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;locality&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;lbEndpoints&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;#34;endpoint&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
              &lt;span class=&#34;nt&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;172.33.100.2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9080&lt;/span&gt;
              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
          &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;filterMetadata&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
              &lt;span class=&#34;nt&#34;&gt;&amp;#34;istio&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                  &lt;span class=&#34;nt&#34;&gt;&amp;#34;uid&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;kubernetes://ratings-v1-8558d4458d-ns6lk.default&amp;#34;&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
          &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The Endpoint can be one or more, and Envoy will route it according to certain rules by selecting the appropriate Endpoint.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : Istio 1.1 will support the &lt;code&gt;istioctl pc endpoint&lt;/code&gt; command to query Endpoint.&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://preliminary.istio.io/zh/help/ops/traffic-management/proxy-cmd/&#34;&gt;Debug Envoy and Pilot - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/posts/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&#34;&gt;Understanding Envoy Agent Sidecar Injection and Traffic Interception in Istio Service Mesh - jimmysong.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2018-09-25-istio-traffic-management-impl-intro/&#34;&gt;Istio traffic management implementation mechanism deep analysis - zhaohuabing.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
