<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh Column · Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here.">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.10cc29dc94114b03907db3131a2a0b871735964d59cce9d69637f50ea22698ae.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.10cc29dc94114b03907db3131a2a0b871735964d59cce9d69637f50ea22698ae.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/categories/service-mesh/" />
  <meta property="og:title" content="Service Mesh Column | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh Column | Jimmy Song" />

  
  <meta property="og:description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here." />
  <meta property="twitter:description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here." />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/book">Library</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/categories/service-mesh/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh Column
                </p>
                <p class="page-description">
                    Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here.
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-in-2021/">Service Mesh in 2021: The Ecosystem Is Emerging</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh in 2021: The Ecosystem Is Emerging', 'A review of the development of Service Mesh in 2021.', '\nAs the service mesh architecture concept gains traction and the scenarios for its applications emerge, there is no shortage of discussions about it in the community. I have worked on service mesh with the community for 4 years now, and will summarize the development of service mesh in 2021 from this perspective. Since Istio is the most popular service mesh, this article will focus on the technical and ecological aspects of Istio.\n\n## Service mesh: a critical tech for Cloud Native Infrastructure \n\nAs one of the vital technologies [defined by CNCF](https:\/\/github.com\/cncf\/toc\/blob\/main\/DEFINITION.md) for cloud native, Istio has been around for five years now. Their development has gone through the following periods.\n\n- Exploration phase: 2017-2018\n- Early adopter phase: 2019-2020\n- Large-scale landing and ecological development phase: 2021-present\n\nService mesh has crossed the “chasm”(refer [Crossing the Chasm](https:\/\/thinkinsights.net\/strategy\/crossing-the-chasm\/) theory) and is in between the “early majority” and “late majority” phases of adoption. Based on feedback from the audience of [Istio Weekly,](https:\/\/github.com\/tetratelabs\/istio-weekly\/) users are no longer blindly following new technologies for experimentation and are starting to consider whether they need them in their organization dialectically.\n\n![Cross the chasm](008i3skNly1gysddnj9i2j30sg0fqaaz.jpg)\n\nWhile new technologies and products continue to emerge, the service mesh, as part of the cloud native technology stack, has continued to solidify its position as the “cloud native network infrastructure” over the past year. The diagram below illustrates the cloud native technology stack model, where each layer has several representative technologies that define the standard. As new-age middleware, the service mesh mirrors other cloud native technologies, such as [Dapr](https:\/\/dapr.io\/) (Distributed Application Runtime), which represents the capability model for cloud native middleware, [OAM](https:\/\/oam.dev\/), which defines the cloud native application model, and the service mesh, which defines the L7 network model.\n\n![Cloud Native Stack](008i3skNly1gysddogtenj30sg0qlwgs.jpg)\n\nA layered view of the cloud native application platform technology stack\n\n## Optimizing the mesh for large scale production applications with different deployment models\n\nOver the past year, the community focused on the following areas.\n\n- Performance optimization: performance issues of service mesh in large-scale application scenarios.\n- Protocol and extensions: enabling service mesh to support arbitrary L7 network protocols.\n- Deployment models: Proxyless vs. Node model vs. Sidecar model.\n- eBPF: putting some of the service mesh’s capabilities to the kernel layer.\n\n### Performance optimization\n\nIstio was designed to serve service to service traffic by “proto-protocol forwarding”. The goal is making the service mesh as “transparent” as possible to applications. Thus using IPtables to hijack the traffic, according to the community-provided test results Istio 1.2 adds only 3 ms to the baseline latency for a mesh with 1000 RPS on 16 connections. However, because of issues inherent in the IPtables conntrack module, Istio’s performance issues begin to emerge as the mesh size increases. To optimize the performance of the Istio sidecar for resource usage and network latency, the community gave the following solutions.\n\n- Sidecar configuration: By configuring service dependencies manually or by adding an Operator to the control plane, the number of service configurations sent to Sidecar can be reduced, thus reducing the resource footprint of the data plane; for more automatic and intelligent configuration of Sidecar, the open source projects [Slime](https:\/\/github.com\/slime-io\/slime) and [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) both offer their innovative configuration loading solutions.\n- The introduction of eBPF: eBPF can be a viable solution to optimize the performance of the service mesh. Some Cilium-based startups even radically propose to use eBPF to replace the Sidecar proxy completely. Still, the Envoy proxy\/xDS protocol has become the proxy for the service mesh implementation and supports the Layer 7 protocol very well. We can use eBPF to improve network performance, but complex protocol negotiation, parsing, and user scaling remain challenging to implement on the user side.\n\n### Protocol and extensions\n\nExtensibility of Istio has always been a significant problem, and there are two aspects to Istio’s extensibility.\n\n- Protocol level: allowing Istio to support all L7 protocols\n- Ecological: allowing Istio to run more extensions\n\nIstio uses Envoy as its data plane. Extending Istio is essentially an extension of Envoy’s functionality. Istio’s official solution is to use WebAssembly, and in Istio 1.12, the [Wasm plugin configuration API](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was introduced to extend the Istio ecosystem. Istio’s extension mechanism uses the [Proxy-Wasm Application Binary Interface (ABI)](https:\/\/github.com\/proxy-wasm\/spec) specification to provide a set of proxy-independent streaming APIs and utilities that can be implemented in any language with an appropriate SDK. Today, Proxy-Wasm’s SDKs are AssemblyScript (similar to TypeScript), C\u002b\u002b, Rust, Zig, and Go (using the TinyGo WebAssembly System Interface).\n\nThere are still relatively few WebAssembly extensions available, and many enterprises choose to customize their CRD and build a service mesh management plane based on Istio. In addition, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is also in strong demand for end-users. It allows them to migrate applications from traditional loads to service mesh easily. Finally, there is the hybrid cloud traffic management with multiple clusters and mesh, which is a more advanced requirement.\n\n### Deployment models\n\nWhen the service mesh concept first emerged, there was a debate between the Per-node and Sidecar models, represented by Linkerd and Istio. eBPF later proposed a kernel to sink the service mesh, which led to more service mesh deployment models, as shown in the figure below.\n\n![Service Mesh Deployment Models](008i3skNly1gysddpco2mj30qz0sgwhk.jpg)\n\nThese four deployment methods have their own advantages and disadvantages, the specific choice of which depends on the actual situation.\n\n### Development of the Istio ecosystem and the projects that support Istio\n\n2021 was also an exciting year for the Istio community, with a series of events and tutorials.\n\n- February, the first Istio distribution, [Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/).\n- February, the first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was held online, with over 2,000 participants.\n- March, the first free online [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals) is released.\n- May, the first [Certification Istio Administrator exam](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) be released.\n- May, ServiceMeshCon Europe was held online.\n- July, [Istio Meetup China](https:\/\/istio.io\/latest\/zh\/blog\/2021\/istiomeetups-china\/) was held in Beijing with more than 100 attendees.\n- October, ServiceMeshCon North America was held in Los Angeles.\n\nThere are also numerous open source projects related to Istio Service Mesh, as shown in the table below.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\nNote: Data is as of January 6, 2022\n\n## Summary\n\nLooking back, we can see that, unlike previous years where users were experimenting, users in 2021 looked for more practical uses for service mesh before implementing them. Their position as the infrastructure of cloud native networks is further strengthened, and more importantly, the service mesh ecosystem is emerging. Looking ahead, in 2022, two technologies to watch are eBPF and WebAssembly(Wasm). We believe that more good examples of service mesh practices will emerge, taking the ecology and standardization a step further.\n', '\/en\/blog\/service-mesh-in-2021\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A review of the development of Service Mesh in 2021.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/">The Debate in the Community About Istio and Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 17, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Debate in the Community About Istio and Service Mesh', 'There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.', '\nYou can use Istio to do [multi-cluster management](https:\/\/www.tetrate.io\/blog\/multicluster-management-with-kubernetes-and-istio\/), [API Gateway](https:\/\/www.tetrate.io\/blog\/istio-servicemesh-api-gateway\/), and manage applications on Kubernetes or [virtual machines](https:\/\/www.tetrate.io\/blog\/istio-18-a-virtual-machine-integration-odyssey\/). In my [last blog](https:\/\/www.tetrate.io\/blog\/why-is-service-mesh-a-necessary-part-of-cloud-native\/), I talked about how service mesh is an integral part of cloud native applications. However, building infrastructure can be a big deal. There is no shortage of debate in the community about the practicability of service mesh and Istio– here’s a list of common questions and concerns, and how to address them.\n\n- Is anyone using Istio in production?\n- What is the impact on application performance due to the many resources consumed by injecting sidecar into the pod?\n- Istio supports a limited number of protocols; is it scalable?\n- Will Istio be manageable? – Or is it too complex, old services too costly to migrate, and the learning curve too steep?\n\nI will answer each of these questions below.\n\n### Istio is architecturally stable, production-ready, and ecologically emerging\n\n[Istio 1.12](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was just released in November – and has evolved significantly since the explosion of service mesh in 2018 (the year Istio co-founders established Tetrate). Istio has a large community of providers and [users](https:\/\/istio.io\/latest\/about\/case-studies\/). The Istio SIG of Cloud Native Community has held eight Istio Big Talk (Istio 大咖说), with Baidu, Tencent, NetEase, Xiaohongshu(小红书), and Xiaodian Technology(小电科技) sharing their Istio practices. According to [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), about 50% of the companies surveyed are using a service mesh in production or planning to in the next year, and about half (47%) of organizations using a service mesh in production are using Istio.\n\nMany companies have developed extensions or plugins for Istio, such as Ant, NetEase, eBay, and Airbnb. Istio’s architecture has been stable since the 1.5 release, and the release cycle is fixed quarterly, with the current project’s main task being Day-2 Operations. \n\nThe Istio community has also hosted various events, with the first IstioCon in March 2021, the Istio Meetup China in Beijing in July, and the Service Mesh Summit 2022 in Shanghai in January 2022.\n\nSo we can say that the Istio architecture is stable and production-ready, and the ecosystem is budding.\n\n### The impact of service mesh on application performance\n\nA service mesh uses iptables to do traffic hijacking by default to be transparent to applications. When the number of services is large, there are a lot of iptables rules that affect network performance. You can use techniques like [eBPF](https:\/\/cloudnative.to\/blog\/how-ebpf-streamlines-the-service-mesh\/) to provide application performance, but the method requires a high version of the operating system kernel, which few enterprises can achieve.\n\n![Istio DNS](008i3skNly1gxgyfcfm5oj30sg0djmxt.jpg)\n\nIn the early days, Istio distributed the routing information of all services in the mesh to all proxy sidecars, which caused [sidecar](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)s to take up a lot of resources. [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) and [Slime](https:\/\/github.com\/slime-io\/slime) can achieve configuration lazy loading. We will introduce these two open-source projects in the Istio open-source ecosystem.\n\nFinally, there is a problem related to Sidecar proxy operation and maintenance: upgrading all Envoy proxies while ensuring constant traffic. A solution is using the [SidecarSet](https:\/\/xie.infoq.cn\/article\/23ae6d3f0d0260b4797a708a0) resource in the open-source project [OpenKruise](https:\/\/github.com\/openkruise\/kruise).\n\nThe resource consumption and network latency associated with the introduction of Sidecar are also within reasonable limits, as you can see from the [service mesh benchmark performance tests](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/).\n\n### Extending the Istio service mesh\n\nThe next question is about extending the Istio service mesh. The current solution given by the Istio community is to use [WebAssembly](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/), an extension that is still relatively little used in production by now and has performance concerns. Most of the answers I’ve observed are CRDs that build a service mesh management plane based on Istio.\n\nAlso, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is in strong demand for end-users. It allows them to migrate applications from traditional loads to cloud native easily. Finally, hybrid cloud traffic management for multiple clusters and meshes is a more advanced requirement.\n\n### Steep learning curve\n\nMany people complain that Istio has too little learning material. Istio has been open source for four years, and there are a lot of learning resources now:\n\n- [Istio Documentation](https:\/\/istio.io\/)\n- [IstioCon 2021](https:\/\/events.istio.io\/istiocon-2021\/)\n- [Istio Big Talk\/Istio Weekly](https:\/\/github.com\/tetratelabs\/istio-weekly)\n- [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals)\n- [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)\n\nYes, Istio is complex, but it’s been getting more and more manageable with every release. In my next blog, I will introduce you to two open source projects that extend Istio and give you some insight into what’s going on in the Istio community.\n', '\/en\/blog\/the-debate-in-the-community-about-istio-and-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/">Service Mesh - An Integral Part of Cloud-Native Applications</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh - An Integral Part of Cloud-Native Applications', 'This article will explore the relationship between service mesh and cloud native.', '\nIf you don’t know what Istio is, you can read my previous articles below:\n\n- [What Is Istio and Why Does Kubernetes Need it?](https:\/\/www.tetrate.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)\n- [Why do you need Istio when you already have Kubernetes?](https:\/\/www.tetrate.io\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/)\n\nThis article will explore the relationship between service mesh and cloud native.\n\n### Service mesh – the product of the container orchestration war\n\nIf you’ve been following the cloud-native space since its early days, you’ll remember the container orchestration wars of 2015 to 2017. Kubernetes won the container wars in 2017, the idea of microservices had taken hold, and the trend toward containerization was unstoppable. Kubernetes architecture matured and slowly became boring, and service mesh technologies, represented by Linkerd and Istio, entered the CNCF-defined cloud-native critical technologies on the horizon.\n\nKubernetes was designed with the concept of cloud-native in mind. A critical idea in cloud-native is the architectural design of microservices. When a single application is split into microservices, how can microservices be managed to ensure the SLA of the service as the number of services increases? The service mesh was born to solve this problem at the architectural level, free programmers’ creativity, and avoid tedious service discovery, monitoring, distributed tracing, and other matters.\n\nThe service mesh takes the standard functionality of microservices down to the infrastructure layer, allowing developers to focus more on business logic and thus speed up service delivery, which is consistent with the whole idea of cloud-native. You no longer need to integrate bulky SDKs in your application, develop and maintain SDKs for different languages, and just use the service mesh for Day 2 operations after the application is deployed.\n\nThe service mesh is regarded as the next generation of microservices. In the diagram, we can see that many of the concerns of microservices overlap with the functionality of Kubernetes. Kubernetes focuses on the application lifecycle, managing resources and deployments with little control over services. The service mesh fills this gap. The service mesh can connect, control, observe and protect microservices.\n\n### **Kubernetes vs. xDS vs. Istio**\n\nThis diagram shows the layered architecture of Kubernetes and Istio.\n\n![Kubernetes vs xDS vs Istio](008i3skNly1gxgxss9mamj30n90d73zs.jpg)\n\nThe diagram indicates that the kube-proxy settings are global and cannot be controlled at a granular level for each service. All Kubernetes can do is topology-aware routing, routing traffic closer to the Pod, and setting network policies in and out of the Pod.\n\nIn contrast, the service mesh takes traffic control out of the service layer in Kubernetes through sidecar proxies, injects proxies into each Pod, and manipulates these distributed proxies through a control plane. It allows for more excellent resiliency.\n\nKube-proxy implements traffic load balancing between multiple pod instances of a Kubernetes service. But how do you finely control the traffic between these services — such as dividing the traffic by percentage to different application versions (which are all part of the same service, but on other deployments), or doing canary releases and blue-green releases?\n\nThe Kubernetes community gives a way to do canary releases using Deployment, assigning different pods to deployed services by modifying the pod’s label.\n\n![Envoy Architecture](008i3skNly1gxgxsswmoij30sg0kl76r.jpg)\n\nCurrently, the most popular open-source implementation of service mesh in the world is Istio. From the [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), we know that Istio is the most used service mesh in production today. Many companies have built their service mesh based on Istio, such as Ant, Airbnb, eBay, NetEase, Tencent, etc.\n\n![CNCF Survey Report 2020](008i3skNly1gxgxstgg4qj30sg0gg0ts.jpg)\n\nFigure from [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf)\n\nIstio is developed based on Envoy, which has been used by default as its distributed proxy since the first day it was open-sourced. Envoy pioneered the creation of the xDS protocol for distributed gateway configuration, greatly simplifying the configuration of large-scale distributed networks. Ant Group open source MOSN also supported xDS In 2019. Envoy was also one of the first projects to graduate from CNCF, tested by large-scale production applications.\n\n### Service mesh – the cloud-native networking infrastructure\n\nWith the above comparison between Kubernetes and service mesh in mind, we can see the place of service mesh in the cloud-native application architecture. That is, building a cloud-native network infrastructure specifically provides:\n\n- Traffic management: controlling the flow of traffic and API calls between services, making calls more reliable, and enhancing network robustness in different environments.\n- Observability: understanding the dependencies between services and the nature and flow of traffic between them provides the ability to identify problems quickly.\n- Policy enforcement: controlling access policies between services by configuring the mesh rather than by changing the code.\n- Service Identification and Security: providing service identifiability and security protection in the mesh.\n', '\/en\/blog\/service-mesh-an-integral-part-of-cloud-native-apps\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will explore the relationship between service mesh and cloud native.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-4-year-birthday/">Happy Istio 4th Anniversary -- Retrospect and Outlook</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 24, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Happy Istio 4th Anniversary -- Retrospect and Outlook', 'Today is Istio\u0027s 4 year birthday, let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.', '\nIstio was named by [Tetrate](https:\/\/tetrate.io\/) founder Varun Talwar and Google lead engineer Louis Ryan in 2017 and was open sourced on May 24, 2017. Today is the fourth anniversary of Istio’s open source arrival. Let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.\n\n### Istio’s open source history\n\nIn 2017, the year Kubernetes ended the container orchestration battle, Google took the opportunity to consolidate its dominance in the cloud native space and compensate for Kubernetes’ disadvantage in service-to-service traffic management by open-sourcing Istio. Istio released its 1.10 last week — but here are some of the most important releases in Istio’s history to date. \n\n| **Date**          | **Version** | **Note**                                                     |\n| ----------------- | ----------- | ------------------------------------------------------------ |\n| May 24, 2017      | 0.1         | Officially open source; established the architectural foundation of Control Plane, Data Plane and sidecar proxy. |\n| October 10, 2017  | 0.2         | Started to support multiple runtime environments, such as virtual machines. |\n| June 1, 2018      | 0.8         | API refactoring                                              |\n| July 31, 2018     | 1.0         | Production-ready, after which the Istio team underwent a massive reorganization. |\n| March 19, 2019    | 1.1         | Enterprise-ready. Support for multiple Kubernetes clusters, with performance optimizations. |\n| March 3, 2020     | 1.5         | Back to monolith, with microservice components merged into istiod, making Istio’s architecture cleaner and easier to maintain. Support for WebAssembly extension, making Istio’s ecology much stronger. |\n| November 18, 2020 | 1.8         | Officially deprecated Mixer and focused on adding support for virtual machines. |\n\nA year after its inception– and two months before the 1.0 release, version 0.8 was released with a massive refactoring of the API. In late July 2018, when 1.0 was released, Istio reached a production-ready tipping point. Since then, Google has massively reorganized the Istio team and several Istio-based service mesh startups were born, making 2018 the booming year of the service mesh industry.\n\nIstio 1.1 was released in March 2019, almost 9 months after 1.0 was released, which is far beyond the average release cycle of an open-source project. We know that the speed of iteration and evolution is a core competency of basic software. Since then, Istio has started a regular [release cadence](https:\/\/istio.io\/v1.7\/about\/release-cadence\/) of one version per quarter and has become the [#4 fastest growing project in GitHub’s top 10 in 2019](https:\/\/octoverse.github.com\/#fastest-growing-oss-projects-by-contributors)!\n\n### The Istio community\n\nIn 2020, Istio’s project management began to mature and its governance reached a stage of evolution. We saw the first [election](https:\/\/istio.io\/latest\/blog\/2020\/steering-election-results\/) of a steering committee for the Istio community and the transfer of the trademark to [Open Usage Commons](https:\/\/istio.io\/latest\/blog\/2020\/open-usage\/). The first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was successfully held in February 2021, with thousands of people attending the online conference. There is also a [large Istio community in China](https:\/\/www.youtube.com\/watch?v=6m-rhyfy8sg\u0026list=PL7wB27eZmdffS-g_xh7X-b0echc_XZMKV\u0026index=8), and face-to-face Istio community meetups will be held there in 2021. Stay tuned for more.\n\n![](008i3skNly1gquicfqg14j31lw0smwl2.jpg)\n\nAccording to the CNCF 2020 Survey, 46% of organizations were either using a service mesh in production or planning to use it in the next 12 months. Istio was the top used mesh among those using a mesh in production.\n\n### The future\n\nAfter 4 years of development, there is not only a large user base around Istio, but also several Istio vendors, as you can see on the [homepage](https:\/\/istio.io\/) of the recently revamped Istio website. In the last few releases, Istio has shifted its development focus to improving the Day 2 Operation experience. We also expect to see more Istio adoption path recommendations, case studies, learning materials, training, and certifications (such as the industry’s first [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) from Tetrate) that will facilitate the adoption of Istio.\n', '\/en\/blog\/istio-4-year-birthday\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Today is Istio&#39;s 4 year birthday, let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-you-should-choose-ngac-as-your-access-control-model/">Why You Should Choose NGAC as Your Access Control Model</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Feb 20, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why You Should Choose NGAC as Your Access Control Model', 'This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.', '\nDifferent companies or software providers have devised countless ways to control user access to functions or resources, such as Discretionary Access Control (DAC), Mandatory Access Control (MAC), Role-Based Access Control (RBAC), and Attribute-Based Access Control (ABAC). In essence, whatever the type of access control model, three basic elements can be abstracted: user, system\/application, and policy.\n\nIn this article, we will introduce ABAC, RBAC, and a new access control model — Next Generation Access Control (NGAC) — and compare the similarities and differences between the three, as well as why you should consider NGAC.\n\n## What Is RBAC?\n\nRBAC, or Role-Based Access Control, takes an approach whereby users are granted (or denied) access to resources based on their role in the organization. Every role is assigned a collection of permissions and restrictions, which is great because you don’t need to keep track of every system user and their attributes. You just need to update appropriate roles, assign roles to users, or remove assignments. But this can be difficult to manage and scale. Enterprises that use the RBAC static role-based model have experienced role explosion: large companies may have tens of thousands of similar but distinct roles or users whose roles change over time, making it difficult to track roles or audit unneeded permissions. RBAC has fixed access rights, with no provision for ephemeral permissions or for considering attributes like location, time, or device. Enterprises using RBAC have had difficulty meeting the complex access control requirements to meet regulatory requirements of other organizational needs.\n\n### RBAC Example\n\nHere’s an example Role in the “default” namespace in Kubernetes that can be used to grant read access to pods:\n\n\u0060\u0060\u0060yaml\napiVersion: rbac.authorization.k8s.io\/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n- apiGroups: [\u0022v1\u0022]\n  resources: [\u0022pods\u0022]\n  verbs: [\u0022get\u0022, \u0022watch\u0022, \u0022list\u0022]\n\u0060\u0060\u0060\n\n## What Is ABAC?\n\nABAC stands for Attribute-Based Access Control. At a high level, [NIST defines](https:\/\/www.nist.gov\/publications\/guide-attribute-based-access-control-abac-definition-and-considerations-1) ABAC as an access control method “where subject requests to perform operations on objects are granted or denied based on assigned attributes of the subject, environment conditions, and a set of policies that are specified in terms of those attributes and conditions.” ABAC is a fine-grained model since you can assign any attributes to the user, but at the same time it becomes a burden and hard to manage:\n\n1. When defining permissions, the relationship between users and objects cannot be visualized.\n2. If the rules are a little complex or confusingly designed, it will be troublesome for the administrator to maintain and trace.\n\nThis can cause performance problems when there is a large number of permissions to process.\n\n### ABAC Example\n\nKubernetes initially uses ABAC as access control and is configured via JSON Lines, for example:\n\nAlice can just read pods in namespace “foo”:\n\n\u0060\u0060\u0060json\n {\u0022apiVersion\u0022: \u0022abac.authorization.kubernetes.io\/v1beta1\u0022, \u0022kind\u0022: \u0022Policy\u0022, \u0022spec\u0022: {\u0022user\u0022: \u0022alice\u0022, \u0022namespace\u0022: \u0022foo\u0022, \u0022resource\u0022: \u0022pods\u0022, \u0022readonly\u0022: true}}\n\u0060\u0060\u0060\n\n## What Is NGAC?\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying users administrative capabilities with a high level of granularity. NGAC was developed by [NIST](https:\/\/www.nist.gov\/) (National Institute of Standards and Technology) and is currently used in [Tetrate Q](https:\/\/www.tetrate.io\/blog\/introducing-tetrate-q\/) and [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/).\n\nThere are several types of entities; they represent the resources you want to protect, the relationships between them, and the actors that interact with the system. The entities are:\n\n1. Users\n2. Objects\n3. User attributes, such as organization unit\n4. Object attributes, such as folders\n5. Policy classes, such as file system access, location, and time\n\nNIST’s David Ferraiolo and [Tetrate](https:\/\/www.tetrate.io\/?utm_content=inline-mention)‘s Ignasi Barrera shared how NGAC works at their [presentation](https:\/\/www.tetrate.io\/blog\/unpacking-next-generation-access-control-ngac-and-tetrate-q\/) on Next Generation Access Control at Service Mesh Day 2019 in San Francisco.\n\nNGAC is based on the assumption that you can represent the system you want to protect in a graph that represents the resources you want to protect and your organizational structure, in a way that has meaning to you and that adheres to your organization semantics. On top of this model that is very particular to your organization, you can overlay policies. Between the resource model and the user model, the permissions are defined. This way NGAC provides an elegant way of representing the resources you want to protect, the different actors in the system, and how both worlds are tied together with permissions.\n\n![NGAC DAG](008eGmZEly1gpb7y6dffaj30ke0ay0ue.jpg)\n\nImage via [Linear Time Algorithms to Restrict Insider Access using Multi-Policy Access Control Systems](https:\/\/tsapps.nist.gov\/publication\/get_pdf.cfm?pub_id=922390)\n\n### NGAC Example\n\nThe following example shows a simple NGAC graph with a User DAG representing an organization structure, an Object DAG representing files and folders in a filesystem, a categorization of the files, and two different policies — file system and scope — that can be combined to make access decisions. The association edges between the two DAGs define the permissions the actors have on the target resources.\n\n![NGAC](008eGmZEly1gpb7y4v7x3j30lx0f7my9.jpg)\n\nIn this graph we can see a representation of two files, “resume” and “contract” in the “\/hr-docs” folder, each linked to a category (“public\/confidential”). There are also two policy classes, “File System” and “Scope,” where the objects in the graph are attached — these need to be satisfied in order to get access to each file.\n\nUser Allice has read and write access to both files in the example, because a path links Allice to each of the files and the paths grant permissions on both policy classes. However, user Bob only has access to the “resume” file, because although there exists a path from Bob to the “contract” file that satisfies the “File System” policy class with “read” permissions, there is no path granting permissions on the “Scope” policy class. So, access to the “contract” file is denied to Bob.\n\n## Why Choose NGAC?\n\nThe need to keep track of attributes of all objects creates a manageability burden in the case of ABAC. RBAC reduces the burden since we extract all access information to roles, but this paradigm suffers from role explosion problems and can also become unmanageable. With NGAC we have everything we need in graphs — in a compact, centralized fashion.\n\nWhen access decisions are complex, processing times of ABAC can rise exponentially. RBAC becomes especially hard to manage at scale, while NGAC scales linearly.\n\nWhere NGAC really shines is in flexibility. It can be configured to allow or disallow access based not only on object attributes, but also on other conditions — time, location, phase of the moon, and so on.\n\nOther key advantages of NGAC include the ability to set policies consistently (to meet compliance requirements) and the ability to set ephemeral policies. For example, NGAC could grant a developer one-time access to resources during an outage, without leaving unnecessary permissions in place that could later lead to a security breach. NGAC can evaluate and combine multiple policies in a single access decision, while keeping its linear time complexity.\n\n## Summary\n\nThe following table compares ABAC, RBAC, and NGAC in several aspects.\n\n![NGAC vs RBAC vs ABAC](008eGmZEly1gpb7y5ehmej30zs0fw76d.jpg)\n\nIn conclusion:\n\n- RBAC is simpler and has good performance, but can suffer at scale.\n- ABAC is flexible, but performance and auditability are a problem.\n- NGAC fixes those gaps by using a novel, elegant revolutionary approach: overlay access policies on top of an existing representation of the world, provided by the user. You can model RBAC and ABAC policies as well.\n\n## References\n\n- [Guide to Attribute-Based Access Control (ABAC) Definition and Considerations](https:\/\/nvlpubs.nist.gov\/nistpubs\/specialpublications\/NIST.SP.800-162.pdf)\n- Deploying ABAC policies using RBAC Systems\n- [RBAC vs. ABAC: What’s the Difference?](https:\/\/www.comparitech.com\/net-admin\/rbac-vs-abac\/)\n- [Role Explosion: The Unintended Consequence of RBAC](https:\/\/www.linkedin.com\/pulse\/role-explosion-unintended-consequence-rbac-oren-ohayon-harel\/)\n- [Exploring the Next Generation of Access Control Methodologies](https:\/\/www.nist.gov\/publications\/exploring-next-generation-access-control-methodologies)', '\/en\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-vm-odysssey/">Istio 1.8: A Virtual Machine Integration Odyssey</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 23, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8: A Virtual Machine Integration Odyssey', 'In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.', '\nIn this article, I’ll give you an overview of [Istio](https:\/\/istio.io\/)‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.\n\nI will show you a tumultuous odyssey of Istio’s virtual machine integration. Tetrate, the enterprise service mesh company that made pushing Istio to run everywhere part of its founding mission, has used VM features extensively in customer deployments and has been instrumental in pushing VMs to Istio upstream.\n\n## Preface\n\nIn my [previous article](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/), I talked about how Istio 1.7 supported virtual machines. But at that time, late October, virtual machines were still not seamlessly integrated into Istio — there was still a lot of manual work required. Now, Istio 1.8 has added WorkloadGroup and smart DNS proxy, which allows non-Kubernetes workloads like VMs to become first-class citizens in Istio — just like pods.\n\nWith or without a sidecar installed for virtual machines, until 1.7 you could not resolve the DNS name of a Kubernetes service unless a kube-external DNS was configured — which is the last piece of virtual machine integration in Istio. This shortcoming has finally been fixed in Istio 1.8.\n\n## Why Is Virtual Machine Support Important?\n\nIn the process of migrating our applications to cloud native architectures and continuously containerizing them, we will go through three phases as shown in the figure below.\n\n![Cloud Native Stages](0081Kckwly1gm0d6t775lj31s80k8go8.jpg)\n\n- Stage 1: All applications are deployed on virtual machines\n- Stage 2: Applications are deployed on both virtual machines and containers, are migrating from virtual machines to containers, and are using Kubernetes to manage containers.\n- Stage 3: All applications are deployed in containers first, using Kubernetes to manage containers and Istio to manage service-to-service communication.\n\nThe above diagram is artificially simplified: in reality, there might be multiple hybrid clouds, multiple regions, multiple clusters, etc. Plus, at stage 3 containers and virtual machines may remain in long-term coexistence, but the trend of containerization remains unchanged.\n\n## Istio’s History of Virtual Machine Support\n\nIstio’s support for virtual machines is a long process, an odyssey of sorts.\n\n### 0.2: Istio Mesh Expansion\n\nAs of version 0.2, Istio added virtual machines to the Mesh via [Istio Mesh Expansion](https:\/\/istio.io\/v0.2\/docs\/setup\/kubernetes\/mesh-expansion.html), provided that the following prerequisites were met.\n\n- Virtual machines must have direct access to the application’s pods via IP address, which requires a flat network between the container and the VM via VPC or VPN; and virtual machines do not need access to the Cluster IP, but rather direct access to the service’s endpoints.\n- Virtual machines must have access to Istio’s control plane services (Pilot, Mixer, CA, now being integrated as Istiod), which can expose the control plane endpoints to virtual machines by deploying load balancers in the Istio Mesh.\n- (optional) the virtual machine has access to the DNS server inside the Mesh (deployed in Kubernetes).\n\nThe steps to integrate a virtual machine are as follows.\n\n1. Create an internal load balancer for the Istio control plane service and the DNS service for the Kubernetes cluster.\n2. Generate a configuration file for the Istio Service CIDR, Service Account token, security certificate, and IP of the Istio Control Plane Service (the IP exposed through the Internal Load Balancer) and send it to the virtual machine.\n3. Setup the Istio component, dnsmaq (for DNS discovery), in the virtual machine; so that the virtual machine can access the services in the mesh using FQDN, to ensure that the virtual machine can correctly resolve the Cluster IP of the services in the mesh.\n4. To run the service in a virtual machine, you need to configure the sidecar, add inbound ports to be intercepted, then restart Istio and also run istioctl to register the service.\n\nThe following figure shows the detailed flow from integrating a virtual machine to accessing services in the virtual machine in a mesh.\n\n![Figure 1](0081Kckwly1gm0d6rogojj30u00yhdil.jpg)\n\nFigure 1\n\n1. The DNS is hijacked by dnsmasq deployed in the virtual machine, which allows it to correctly obtain the Cluster IP of the Istio service (Kubernetes’ built-in DNS).\n2. Access to Kubernetes’ built-in DNS service (which is exposed outside the cluster via the Internal Load Balancer and can be accessed directly).\n3. Return the Cluster IP resolved by \u0060productpage.bookinfo.svc.cluster.local\u0060, noting that the IP address is not directly accessible, but failure to be DNS resolved will result in a failed VM request for the service.\n4. The virtual machine’s call to services in a mesh is hijacked by the sidecar proxy.\n5. Since the proxy is connected to the Istio control plane, the endpoints of the service can be queried via xDS, so traffic will be forwarded to one of the endpoints.\n6. To access VM services in mesh, you need to manually add VM services to mesh using the istioctl register command, which essentially registers the VM services to the service and endpoint in Kubernetes.\n7. Services in the mesh can be accessed using the VM-registered service name (FQDN, e.g. \u0060mysql.vm.svc.cluster.local\u0060).\n\nThe above Istio support for virtual machines continued with Istio 1.0, which introduced a new API [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) with Istio 1.1, that allows additional entries to be added to Istio’s internal service registry so that services in the mesh can access\/route to these manually specified services. The istioctl register command is no longer needed and will be deprecated in Istio 1.9.\n\nThe istioctl experimental add-to-mesh command has been added to Istio 1.5 to add services from a virtual machine to a mesh, and it works just like the istioctl register.\n\n### 1.6 to 1.7: New Resource Abstractions\n\nIstio introduced a new resource type, [WorkloadEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-entry\/), in traffic management from [version 1.6](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/), to abstract virtual machines so that they can be added to the mesh as equivalent loads to the pods in Kubernetes; with traffic management, security management, observability, etc. The mesh configuration process for virtual machines is simplified with WorkloadEntry, which selects multiple workload entries and Kubernetes pods based on the label selector specified in the service entry.\n\nIstio 1.8 adds a resource object for [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) that provides a specification that can include both virtual machines and Kubernetes workloads, designed to mimic the existing sidecar injection and deployment specification model for Kubernetes workloads to bootstrap Istio agents on the VMs.\n\nBelow is a comparison of resource abstraction levels for virtual machines versus workloads in Kubernetes.\n\n| **Item**                           | **Kubernetes** | **Virtual Machine** |\n| ---------------------------------- | -------------- | ------------------- |\n| **Basic schedule unit**            | Pod            | WorkloadEntry       |\n| **Component**                      | Deployment     | WorkloadGroup       |\n| **Service register and discovery** | Service        | ServiceEntry        |\n\nFrom the above diagram, we can see that for virtual machine workloads there is a one-to-one correspondence with the workloads in Kubernetes.\n\nEverything seems perfect at this point. However, exposing the DNS server in the Kubernetes cluster directly is a big [security risk](https:\/\/blog.aquasec.com\/dns-spoofing-kubernetes-clusters), so we usually manually write the domain name and Cluster IP pair of the service the virtual machine needs to access to the local \/etc\/hosts — but this is not practical for a distributed cluster with a large number of nodes.\n\nThe process of accessing the services inside mesh by configuring the local \/etc\/hosts of the virtual machine is shown in the following figure.\n\n![Figure 2](0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg)\n\nFigure 2\n\n1. Registration of services in the virtual machine into the mesh.\n2. Manually write the domain name and Cluster IP pairs of the service to be accessed to the local \/etc\/hosts file in the virtual machine.\n3. Cluster IP where the virtual machine gets access to the service.\n4. The traffic is intercepted by the sidecar proxy and the endpoint address of the service to be accessed is resolved by Envoy.\n5. Access to designated endpoints of the service.\n\nIn Kubernetes, we generally use the Service object for service registration and discovery; each service has a separate DNS name that allows applications to call each other by using the service name. We can use ServiceEntry to register a service in a virtual machine into Istio’s service registry, but a virtual machine cannot access a DNS server in a Kubernetes cluster to get the Cluster IP if the DNS server is not exposed externally to the mesh, which causes the virtual machine to fail to access the services in the mesh. Wouldn’t the problem be solved if we could add a sidecar to the virtual machine that would transparently intercept DNS requests and get the Cluster IP of all services in the mesh, similar to the role of dnsmasq in Figure 1?\n\n### As of Istio 1.8 — Smart DNS Proxy\n\nWith the introduction of smart [DNS proxy](https:\/\/cloudnative.to\/blog\/istio-dns-proxy\/) in Istio 1.8, virtual machines can access services within the mesh without the need to configure \/etc\/hosts, as shown in the following figure.\n\n![Figure 3](0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg)\n\nFigure 3\n\nThe Istio agent on the sidecar will come with a cached DNS proxy dynamically programmed by Istiod. DNS queries from the application are transparently intercepted and served by the Istio proxy in the pod or VM, with the response to DNS query requests, enabling seamless access from the virtual machine to the service mesh.\n\nThe WorkloadGroup and smart DNS proxy introduced in Istio 1.8 provide powerful support for virtual machine workloads, making legacy applications deployed in virtual machines fully equivalent to pods in Kubernetes.\n\n## Summary\n\nIn this odyssey of Istio’s virtual machine support, we can see the gradual realization of unified management of virtual machines and pods — starting with exposing the DNS server in the mesh and setting up dnsmasq in the virtual machine, and ending with using smart DNS proxies and abstracting resources such as \u0060WorkloadEntry\u0060, \u0060WorkloadGroup\u0060 and \u0060ServiceEntry\u0060. This article only focuses on the single cluster situation, which is not enough to be used in real production. We also need to deal with security, multicluster, multitenancy, etc.\n\n## Referenced resources\n\n- [Tetrate Service Bridge — Across all compute bridging Kubernetes clusters, VMs, and bare metal](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Expanding into New Frontiers — Smart DNS Proxying in Istio](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Virtual Machine Installation — Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- [How to Integrate Virtual Machines into Istio Service Mesh](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)\n', '\/en\/blog\/istio-vm-odysssey\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-a-service-mesh/">What Is a Service Mesh?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 22, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What Is a Service Mesh?', 'This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.', '\nA service mesh is a relatively simple concept, consisting of a bunch of network proxies paired with each service in an application, plus a set of task management processes. The proxies are called the data plane and the management processes are called the control plane in the Service Mesh. The data plane intercepts calls between different services and “processes” them; the control plane is the brain of the mesh that coordinates the behavior of proxies and provides APIs for operations and maintenance personnel to manipulate and observe the entire network.\n\nThe diagram below shows the architecture of a service mesh.\n\n![Service Mesh Architecture](service-mesh-architecture.png)\n\nFurther, the service mesh is a dedicated infrastructure layer designed to enable reliable, fast, and secure inter-service invocation in microservices architectures. It is not a mesh of “services” but rather a mesh of “proxies” that services can plug into, thus abstracting the network from the application code. In a typical service mesh, these proxies are injected into each service deployment as a sidecar (and also may be deployed at the edge of the mesh). Instead of invoking services directly over the network, services invoke their local sidecar proxy, which in turn manages requests on behalf of the service, pushing the complexities of inter-service communications into a networking layer that can resolve them at scale. The set of interconnected sidecar proxies implements a so-called data plane, while on the other hand the service mesh control plane is used to configure proxies. The infrastructure introduced by a service mesh provides an opportunity, too, to collect metrics about the traffic that is flowing through the application.\n\n## The architecture of a service mesh\n\nThe infrastructure layer of a service mesh is divided into two main parts: the control plane and the data plane.\n\n**Characteristics of the control plane**\n\n- Do not parse packets directly.\n- Communicates with proxies in the control plane to issue policies and configurations.\n- Visualizes network behavior.\n- Typically provides APIs or command-line tools for configuration versioning and management for continuous integration and deployment.\n\n**Characteristics of the data plane**\n\n- Is usually designed with the goal of statelessness (though in practice some data needs to be cached to improve traffic forwarding performance).\n- Directly handles inbound and outbound packets, forwarding, routing, health checking, load balancing, authentication, authentication, generating monitoring data, etc.\n- Is transparent to the application, i.e., can be deployed senselessly.\n\n## Changes brought by the service mesh\n\n**Decoupling of microservice governance from business logic**\n\nA service mesh takes most of the capabilities in the SDK out of the application, disassembles them into separate processes, and deploys them in a sidecar model. By separating service communication and related control functions from the business process and synching them to the infrastructure layer, a service mesh **mostly** decouples them from the business logic, allowing application developers to focus more on the business itself.\n\nNote that the word “mostly” is mentioned here and that the SDK often needs to retain protocol coding and decoding logic, or even a lightweight SDK to implement fine-grained governance and monitoring policies in some scenarios. For example, to implement method-level call distributed tracing, the service mesh requires the business application to implement trace ID passing, and this part of the implementation logic can also be implemented through a lightweight SDK. Therefore, the service mesh is not zero-intrusive from a code level.\n\n**Unified governance of heterogeneous environments**\n\nWith the development of new technologies and staff turnover, there are often applications and services in different languages and frameworks in the same company, and in order to control these services uniformly, the previous practice was to develop a complete set of SDKs for each language and framework, which is very costly to maintain. With a service mesh, multilingual support is much easier by synching the main service governance capabilities to the infrastructure. By providing a very lightweight SDK, and in many cases, not even a separate SDK, it is easy to achieve unified traffic control and monitoring requirements for multiple languages and protocols.\n\n## Features of service mesh\n\nService mesh also has three major technical advantages over traditional microservice frameworks.\n\n**Observability**\n\nBecause the service mesh is a dedicated infrastructure layer through which all inter-service communication passes, it is uniquely positioned in the technology stack to provide uniform telemetry at the service invocation level. This means that all services are monitored as “black boxes.” The service mesh captures route data such as source, destination, protocol, URL, status codes, latency, duration, etc. This is essentially the same data that web server logs can provide, but the service mesh captures this data for all services, not just the web layer of individual services. It is important to note that collecting data is only part of the solution to the observability problem in microservice applications. Storing and analyzing this data needs to be complemented by mechanisms for additional capabilities, which then act as alerts or automatic instance scaling, for example.\n\n**Traffic control**\n\nWith a service mesh, services can be provided with various control capabilities such as intelligent routing (blue-green deployment, canary release, A\/B test), timeout retries, circuit breaking, fault injection, traffic mirroring, etc. These are often features that are not available in traditional microservices frameworks but are critical to the system. For example, the service mesh carries the communication traffic between microservices, so it is possible to test the robustness of the whole application by simulating the failure of some microservices through rules for fault injection in the grid. Since the service mesh is designed to efficiently connect source request calls to their optimal destination service instances, these traffic control features are “destination-oriented.” This is a key feature of the service mesh’s traffic control capabilities.\n\n**Security**\n\nTo some extent, monolithic applications are protected by their single address space. However, once a monolithic application is broken down into multiple microservices, the network becomes a significant attack surface. More services mean more network traffic, which means more opportunities for hackers to attack the information flow. And service mesh provides the capabilities and infrastructure to protect network calls. The security-related benefits of service mesh are in three core areas: authentication of services, encryption of inter-service communications, and enforcement of security-related policies.\n\nService mesh has brought about tremendous change and has strong technical advantages, and has been called the second generation of “microservice architecture.” However, there is no silver bullet in software development. Traditional microservices architecture has many pain points, and service mesh is no exception. It has its limitations.\n\n**Increased complexity**\n\nService mesh introduces sidecar proxies and other components into an already complex, distributed environment, which can greatly increase the overall chain and operational O\u0026M complexity. Ops needs to be more specialized. Adding a service mesh such as Istio to a container orchestrator such as Kubernetes often requires Ops to become an expert in both technologies in order to fully utilize the capabilities of both and to troubleshoot the problems encountered in the environment.\n\n**Latency**\n\nAt the link level, a service mesh is an invasive, complex technology that can add significant latency to system calls. This latency is on the millisecond level, but it can also be intolerable in special business scenarios.\n\n**Platform adaptation**\n\nThe intrusive nature of service mesh forces developers and operators to adapt to highly autonomous platforms and adhere to the platform’s rules.\n\n## The relationship between service mesh and Kubernetes\n\nKubernetes is essentially application lifecycle management, specifically the deployment and management (scaling, auto-recovery, publishing) of containerized applications. Service mesh decouples traffic management from Kubernetes, eliminating the need for a kube-proxy component for internal traffic, and manages inter-service and ingress traffic, security, and observability through an abstraction closer to the microservice application layer. The xDS used by Istio and Envoy is one of the protocol standards for service mesh configuration. \n\nOrganizations that use Kubernetes often turn to a service mesh to address the networking issues that arise with containerization — but notably, a service mesh can work with a legacy or a modern workload, and can be put in place prior to containerization for a faster, safer path to modernization.\n\n## Summary\n\nReaders should look dialectically at the advantages and disadvantages of a service mesh compared with traditional microservices architecture. A service mesh can be a critical part of the evolutionary path of application architecture, from the earliest monolith to distributed, to microservices, containerization, container orchestration, to hybrid workloads and multi-cloud. \n\nLooking ahead, Kubernetes is exploding, and it has become the container orchestration of choice for enterprise greenfield applications. If Kubernetes has completely won the market and the size and complexity of Kubernetes-based applications continue to grow, there will be a tipping point, and service mesh will be necessary to effectively manage these applications. As service mesh technology continues to evolve and the architecture and functionality of its implementation products, such as Istio, continue to be optimized, service mesh will completely replace traditional microservice architectures as the architecture of choice for microservices and transformation to the cloud for enterprises.\n\nThis article was co-authored by Guangming Luo, a member of the ServiceMesher community and the CNC steering community.\n', '\/en\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-the-microservices-in-post-kubernetes-era/">Service Mesh - The Microservices in Post Kubernetes Era</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Apr 1, 2020</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh - The Microservices in Post Kubernetes Era', 'This article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.', '\nThis article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.\n\nPeople who have just heard of Service Mesh and tried [Istio](https:\/\/istio.io\/) may have the following questions:\n\n1. Why does Istio bind Kubernetes?\n1. What roles do Kubernetes and Service Mesh play in cloud native?\n1. What aspects of Kubernetes has Istio extended? What problems have been solved?\n1. What is the relationship between Kubernetes, xDS protocols ([Envoy](https:\/\/github.com\/envoyproxy\/envoy) , [MOSN,](https:\/\/github.com\/mosn\/mosn) etc) and Istio?\n1. Should I use Service Mesh?\n\nIn this section, we will try to guide you through the internal connections between Kubernetes, the xDS protocol, and Istio Service Mesh. In addition, this section will also introduce the load balancing methods in Kubernetes, the significance of the xDS protocol for Service Mesh, and why Istio is needed in time for Kubernetes.\n\nUsing Service Mesh is not to say that it will break with Kubernetes, but that it will happen naturally. The essence of Kubernetes is to perform application lifecycle management through declarative configuration, while the essence of Service Mesh is to provide traffic and security management and observability between applications. If you have built a stable microservice platform using Kubernetes, how do you set up load balancing and flow control for calls between services?\n\nThe xDS protocol created by Envoy is supported by many open source software, such as [Istio](https:\/\/github.com\/istio\/istio) , [Linkerd](https:\/\/linkerd.io\/) , [MOSN,](https:\/\/github.com\/mosn\/mosn) etc. Envoy\u0027s biggest contribution to Service Mesh or cloud native is the definition of xDS. Envoy is essentially a proxy. It is a modern version of proxy that can be configured through APIs. Based on it, many different usage scenarios are derived, such as API Gateway, Service Mesh. Sidecar proxy and Edge proxy in.\n\n**This section contains the following**\n\n- Explain the role of kube-proxy.\n- Kubernetes\u0027 limitations in microservice management.\n- Describe the features of Istio Service Mesh.\n- Describe what xDS includes.\n- Compare some concepts in Kubernetes, Envoy and Istio Service Mesh.\n\n## Key takeaways\n\nIf you want to know everything in advance, here are some of the key points from this article:\n\n- The essence of Kubernetes is application lifecycle management, specifically deployment and management (scaling, scaling, automatic recovery, release).\n- Kubernetes provides a scalable and highly resilient deployment and management platform for microservices.\n- The foundation of Service Mesh is a transparent proxy. After the traffic between microservices is intercepted through sidecar proxy, the behavior of microservices is managed through the control plane configuration.\n- Service Mesh decoupled from Kubernetes traffic management, the internal flow without the need of Service Mesh \u0060kube-proxy \u0060supporting components, micro-services closer to abstract the application layer by, for traffic between management services, security and observability.\n- xDS defines the protocol standards for Service Mesh configuration.\n- Service Mesh is a higher-level abstraction of services in Kubernetes. Its next step is serverless.\n\n## Kubernetes vs Service Mesh\n\nThe following figure shows the service access relationship between Kubernetes and Service Mesh (one sidecar per pod mode).\n\n![kubernetes vs service mesh](kubernetes-vs-service-mesh.png)\n\n**Traffic forwarding**\n\nEach node of the cluster Kubernetes a deployed \u0060kube-proxy\u0060 assembly Kubernetes API Server may communicate with the cluster acquired service information, and then set iptables rules, sends a request for a service directly to the corresponding Endpoint (belonging to the same group service pod).\n\n**Service discovery**\n\n![Service registration in Service Mesh](istio-service-registry.png)\n\nIstio Service Mesh can use the service in Kubernetes for service registration. It can also connect to other service discovery systems through the platform adapter of the control plane, and then generate the configuration of the data plane (using CRD statements, stored in etcd), a **transparent proxy** for the data plane. (Transparent proxy) is deployed in the sidecar container in each application service pod. These proxy need to request the control plane to synchronize the proxy configuration. The reason why is a transparent proxy, because there is no application container fully aware agent, the process kube-proxy components like the need to block traffic, but \u0060kube-proxy\u0060that blocks traffic to Kubernetes node and sidecar proxy that blocks out of the Pod For more information, see [Understanding Route Forwarding by the Envoy Sidecar Proxy in Istio Service Mesh](\/en\/blog\/envoy-sidecar-routing-of-istio-service-mesh-deep-dive\/) .\n\n**Disadvantages of Service Mesh**\n\nBecause each node on Kubernetes many runs Pod, the original \u0060kube-proxy\u0060routing forwarding placed in each pod, the distribution will lead to a lot of configuration, synchronization, and eventual consistency problems. In order to perform fine-grained traffic management, a series of new abstractions will be added, which will further increase the user\u0027s learning costs. However, with the popularization of technology, this situation will gradually ease.\n\n**Advantages of Service Mesh**\n\n\u0060kube-proxy\u0060 The settings are globally effective, and fine-grained control of each service cannot be performed. Service Mesh uses sidecar proxy to extract the control of traffic in Kubernetes from the service layer, which can be further expanded.\n\n## kube-proxy component\n\nIn Kubernetes cluster, each Node to run a \u0060kube-proxy \u0060 process. \u0060kube-proxy\u0060 Responsible for the \u0060Service\u0060 realization of a VIP (virtual IP) form. In Kubernetes v1.0, the proxy is implemented entirely in userspace. Kubernetes v1.1 adds the iptables proxy mode, but it is not the default operating mode. As of Kubernetes v1.2, the iptables proxy is used by default. In Kubernetes v1.8.0-beta.0, the ipvs proxy mode was added. More about kube-proxy component description please refer to kubernetes Description: service and kube-proxy principle and use IPVS achieve Kubernetes inlet flow load balancing.\n\n### kube-proxy flaws\n\nThe disadvantages of kube-proxy :\n\n\u003e First, if forwarded pod can not provide normal service, it does not automatically try another pod, of course, this can \u0060liveness probes\u0060 be solved. Each pod has a health check mechanism. When there is a problem with the health of the pod, kube-proxy will delete the corresponding forwarding rule. In addition, \u0060nodePort\u0060types of services cannot add TLS or more sophisticated message routing mechanisms.\n\nKube-proxy implements load balancing of traffic among multiple pod instances of the Kubernetes service, but how to fine-grained control the traffic between these services, such as dividing the traffic into different application versions by percentage (these applications belong to the same service , But on a different deployment), do canary release and blue-green release? Kubernetes community gives the [method using the Deployment do canary release](https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#canary-deployments) , essentially by modifying the pod of the method label different pod to be classified into the Deployment of Service.\n\n## Kubernetes Ingress vs. Istio Gateway\n\nSpeaking above \u0060kube-proxy\u0060the flow inside the only route Kubernetes clusters, and we know that Pod Kubernetes cluster located CNI outside the network created, external cluster is unable to communicate directly with, so Kubernetes created in the ingress of this resource object, which is located by the Kubernetes edge nodes (such nodes can be many or a group) are driven by the Ingress controller, which is responsible for managing **north-south traffic** . Ingress must be [connected to](https:\/\/traefik.io\/) various ingress controllers, such as [nginx ingress controller](https:\/\/github.com\/kubernetes\/ingress-nginx) and [traefik](https:\/\/traefik.io\/) . Ingress is only applicable to HTTP traffic, and its usage is also very simple. It can only route traffic by matching limited fields such as service, port, and HTTP path, which makes it unable to route TCP traffic such as MySQL, Redis, and various private RPCs. To directly route north-south traffic, you can only use Service\u0027s LoadBalancer or NodePort. The former requires cloud vendor support, while the latter requires additional port management. Some Ingress controllers support exposing TCP and UDP services, but they can only be exposed using Services. Ingress itself does not support it, such as the nginx ingress controller . The exposed port of the service is configured by creating a ConfigMap.\n\nIstio Gateway is similar to Kubernetes Ingress in that it is responsible for north-south traffic to the cluster. \u0060Gateway\u0060The load balancer described by Istio is used to carry connections in and out of the edge of the mesh. The specification describes a series of open ports and the protocols used by these ports, SNI configuration for load balancing, and so on. Gateway is a CRD extension. It also [reuses](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) the capability of sidecar proxy. For detailed configuration, please refer to [Istio official website](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) .\n\n## xDS protocol\n\nYou may have seen the following picture when you understand Service Mesh. Each block represents an instance of a service, such as a Pod in Kubernetes (which contains a sidecar proxy). The xDS protocol controls all traffic in Istio Service Mesh. The specific behavior is to link the squares in the figure below.\n\n![Service Mesh diagram](service-mesh-schematic-diagram.png)\n\nThe xDS protocol was proposed by [Envoy](https:\/\/envoyproxy.io\/) . The original xDS protocols in the Envoy v2 API refer to CDS (Cluster Discovery Service), EDS (Endpoint Discovery Service), LDS (Listener Discovery Service), and RDS (Route Discovery Service). Later, in the v3 version, Scoped Route Discovery Service (SRDS), Virtual Host Discovery Service (VHDS), Secret Discovery Service (SDS), and Runtime Discovery Service (RTDS) were developed. See the [xDS REST and gRPC protocol for](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol) details .\n\nLet\u0027s take a look at the xDS protocol with a service with two instances each.\n\n![xDS protocol](00831rSTly1gde7ydng3ij30s80j4aba.jpg)\n\nThe arrow in the figure above is not the path or route after the traffic enters the proxy, nor is it the actual sequence. It is an imagined xDS interface processing sequence. In fact, there are cross references between xDS.\n\nAgents that support the xDS protocol dynamically discover resources by querying files or managing servers. In summary, the corresponding discovery service and its corresponding API are called  xDS. Envoy by **subscription (subscription)** to get the resources the way, there are three ways to subscribe:\n\n- **File subscription** : Monitor files in the specified path, the easiest way to find dynamic resource is to save it in a file and path configuration in ConfigSource the \u0060path\u0060parameter.\n- **gRPC streaming subscription** : Each xDS API can be individually configured \u0060ApiConfigSource\u0060to point to the cluster address of the corresponding upstream management server.\n- **Polling REST-JSON polling subscription** : A single xDS API can perform synchronous (long) polling of REST endpoints.\n\nFor details of the above xDS subscription methods, please refer to the xDS protocol analysis . Istio uses gRPC streaming subscriptions to configure sidecar proxy for all data planes.\n\nThe article introduces the overall architecture of the Istio pilot, the generation of proxy configuration, the function of the pilot-discovery module, and the CDS, EDS, and ADS in the xDS protocol. For details on ADS, please refer to the official Envoy documentation .\n\n### xDS protocol highlights\n\nFinally, summarize the main points about the xDS protocol:\n\n- CDS, EDS, LDS, and RDS are the most basic xDS protocols, and they can be updated independently.\n- All Discovery Services can connect to different Management Servers, which means that there can be multiple servers managing xDS.\n- Envoy has made a series of extensions based on the original xDS protocol, adding SDS (Key Discovery Service), ADS (Aggregated Discovery Service), HDS (Health Discovery Service), MS (Metric Service), RLS (Rate Limiting Service) Wait for the API.\n- To ensure data consistency, if used directly xDS original API, it needs to ensure that such sequential update: CDS -\u003e EDS -\u003e LDS -\u003e RDS, which is to follow the electronic engineering **before-break** (Make-Before-Break) The principle is to establish a new connection before disconnecting the original connection. The application in routing is to prevent the situation where the upstream cluster cannot be found and the traffic is dropped when a new routing rule is set, similar to the circuit Open circuit.\n- CDS sets which services are in the service mesh.\n- EDS sets which instances (Endpoints) belong to these services (Cluster).\n- LDS sets the listening port on the instance to configure routing.\n- The routing relationship between RDS final services should ensure that RDS is updated last.\n\n## Envoy\n\nEnvoy is the default sidecar in Istio Service Mesh. Based on Envoy, Istio has extended its control plane in accordance with Envoy\u0027s xDS protocol. Before talking about the Envoy xDS protocol, we need to be familiar with the basic terms of Envoy. The following lists the basic terms and data structure analysis in Envoy. For a detailed introduction to Envoy , please refer to the official Envoy document . As for how Envoy works as a forwarding proxy in Service Mesh (not limited to Istio), please refer to [understanding Istio Service Mesh Envoy agent in Sidecar injection and traffic hijacking](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/) , in which the article refers to some of the points, the details will not be repeated.\n\n![Envoy proxy architecture diagram](envoy-arch.png)\n\n### Basic terminology\n\nHere are the basic terms in Envoy you should know:\n\n- **Downstream** : The downstream host connects to Envoy, sends a request and receives a response, that is, the host sending the request.\n- **Upstream** : The upstream host receives the connection and request from Envoy and returns a response, that is, the host that accepted the request.\n- **Listener** : The listener is a named network address (for example, port, unix domain socket, etc.), and downstream clients can connect to these listeners. Envoy exposes one or more listeners to connect to downstream hosts.\n- **Cluster** : A cluster is a group of logically identical upstream hosts connected to Envoy. Envoy discovers members of the cluster through service discovery. You can choose to determine the health status of cluster members through active health checks. Envoy uses load balancing policies to decide which member of the cluster to route requests to.\n\nEnvoy can set multiple Listeners, and each Listener can also set a filter chain, and the filters are extensible, which can make it easier for us to manipulate traffic behavior, such as setting encryption, private RPC, and so on.\n\nThe xDS protocol was proposed by Envoy and is now the default sidecar proxy in Istio. However, as long as the xDS protocol is implemented, it can theoretically be used as a sidecar proxy in Istio, such as the open source proxy [MOSN](https:\/\/github.com\/mosn\/mosn) by [Ant Group](https:\/\/www.antfin.com) .\n\n## Istio Service Mesh\n\n![Istio service mesh architecture diagram](istio-mesh-arch.png)\n\nIstio is a very feature-rich Service Mesh, which includes the following functions:\n\n- Traffic Management: This is the most basic feature of Istio.\n- Policy control: Implemented through Mixer components and various adapters to implement access control systems, telemetry capture, quota management, and billing.\n- Observability: Achieved through Mixer.\n- Security certification: Citadel components do key and certificate management.\n\n### Traffic Management in Istio\n\nIstio defined as the CRD to help users perform traffic management:\n\n- **Gateway** : [Gateway](https:\/\/istio.io\/docs\/reference\/config\/networking\/gateway\/) describes a load balancer running at the edge of the network for receiving incoming or outgoing HTTP \/ TCP connections.\n- **VirtualService** : [VirtualService](https:\/\/istio.io\/docs\/reference\/config\/networking\/virtual-service\/) actually connects Kubernetes services to Istio Gateway. It can also do more, such as defining a set of traffic routing rules to apply when a host is addressed.\n- **DestinationRule** : [\u0060DestinationRule\u0060](https:\/\/istio.io\/zh\/docs\/reference\/config\/networking\/destination-rule\/)The defined policy determines the access policy of the traffic after routing processing. Simply put, it defines how the traffic is routed. These policies can define load balancing configurations, connection pool sizes, and external detection (used to identify and evict unhealthy hosts in a load balancing pool) configuration.\n- **EnvoyFilter** : The [\u0060EnvoyFilter\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/envoy-filter\/)object describes filters for proxy services that can customize the proxy configuration generated by Istio Pilot. This configuration is rarely used by beginning users.\n- **ServiceEntry** : By default, services in Istio Service Mesh cannot discover services outside Mesh. It [\u0060ServiceEntry\u0060](https:\/\/istio.io\/docs\/reference\/config\/networking\/service-entry\/)can add additional entries to the service registry inside Istio, so that services automatically discovered in the mesh can access and route to these manual Joined services.\n\n## Kubernetes vs xDS vs Istio\n\nAfter the reading of the above Kubernetes \u0060kube-proxy\u0060after abstraction component, and XDS Istio in traffic management, we will take you far as the traffic management aspect of comparison components corresponding to the three \/ protocol (note, not completely three equivalents).\n\n| Governors  | xDS      | Istio Service Mesh |\n| ---------- | -------- | ------------------ |\n| Endpoint   | Endpoint | -                  |\n| Service    | Route    | VirtualService     |\n| kube-proxy | Route    | DestinationRule    |\n| kube-proxy | Listener | EnvoyFilter        |\n| Ingress    | Listener | Gateway            |\n| Service    | Cluster  | ServiceEntry       |\n\n## Conclusion\n\nIf you say that the objects managed by Kubernetes are Pods, then the objects managed by Service Mesh are Service. Therefore, it is a natural thing to apply Service Mesh after using Kubernetes to manage microservices. If you do n’t want to manage even the Service, use [serverless](https:\/\/github.com\/knative\/) platforms like knative, but that\u0027s what comes next.\n\nThe function of Envoy\/MOSN is not just for traffic forwarding. The above concepts are just the tip of the iceberg in Istio\u0027s new layer of abstraction over Kubernetes. This will be the beginning of the book.\n', '\/en\/blog\/service-mesh-the-microservices-in-post-kubernetes-era\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article is a rework of previously written content and is included in the Istio Handbook of the ServiceMesher community . Other chapters are still being compiled.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh/">Understanding How Envoy Sidecar Intercept and Route Traffic in Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 27, 2018</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding How Envoy Sidecar Intercept and Route Traffic in Istio Service Mesh', 'Details about Envoy sidecar with iptables rules.', '\nThis article uses Istio\u0027s official [bookinfo sample](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) to explain how Envoy performs routing forwarding after the traffic entering the Pod and forwarded to Envoy sidecar by iptables, detailing the inbound and outbound processing. For a detailed analysis of traffic interception, see [Understanding Envoy Sidecar Proxy Injection and Traffic Interception in Istio Service Mesh](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/).\n\n## Overview of Sidecar Injection and Traffic Interception Steps\n\nBelow is an overview of the steps from Sidecar injection, Pod startup to Sidecar proxy interception traffic and Envoy processing routing.\n\n1. Kubernetes automatically injected through Admission Controller, or the user run \u0060istioctl\u0060 command to manually inject sidecar container.\n2. Apply the YAML configuration deployment application. At this time, the service creation configuration file received by the Kubernetes API server already includes the Init container and the sidecar proxy.\n3. Before the sidecar proxy container and application container are started, the Init container started firstly. The Init container is used to set iptables (the default traffic interception method in Istio, and can also use BPF, IPVS, etc.) to Intercept traffic entering the pod to Envoy sidecar Proxy. All TCP traffic (Envoy currently only supports TCP traffic) will be Intercepted by sidecar, and traffic from other protocols will be requested as originally.\n4. Launch the Envoy sidecar proxy and application container in the Pod.\n\n{{\u003ccallout note\u003e}}\n**Sidecar proxy and application container startup order issues**\n\nStart the sidecar proxy and the application container. Which container is started first? Normally, Envoy Sidecar and the application container are all started up before receiving traffic requests. But we can\u0027t predict which container will start first, so does the container startup order have an impact on Envoy intercepting traffic? The answer is yes, but it is divided into the following two situations.\n\n**Case 1: The application container starts first, and the sidecar proxy is still not ready**\n\nIn this case, the traffic is transferred to the 15001 port by iptables, and the port is not monitored in the Pod. The TCP link cannot be established and the request fails.\n\n**Case 2: Sidecar starts first, the request arrives and the application is still not ready**\n\nIn this case, the request will certainly fail. As for the step at which the failure begins, the reader is left to think.\n\n**Question** : If adding a readiness and living probe for the sidecar proxy and application container can solve the problem?\n{{\u003c\/callout\u003e}}\n\n5. TCP requests that are sent or received from the Pod will be intercepted by iptables. After the inbound traffic is intercepted, it is processed by the Inbound Handler and then forwarded to the application container for processing. The outbound traffic is intercepted by iptables and then forwarded to the Outbound Handler for processing. Upstream and Endpoint.\n6. Sidecar proxy requests Pilot to use the xDS protocol to synchronize Envoy configurations, including LDS, EDS, CDS, etc., but to ensure the order of updates, Envoy will use ADS to request configuration updates from Pilot directly.\n\n## How Envoy handles route forwarding\n\nThe following figure shows a \u0060productpage\u0060service access request \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060, when traffic enters \u0060reviews\u0060 the internal services, \u0060reviews\u0060 internal services Envoy Sidecar is how to do traffic blocked the route forward.\n\n![Istio transparent traffic intercepting and traffic routing schematic](istio-iptables.svg)\n\nBefore the first step, \u0060productpage\u0060 Envoy Sidecar Pod has been selected by EDS of a request to \u0060reviews\u0060 a Pod service of its IP address, it sends a TCP connection request.\n\nThe Envoy configuration in the official website of Istio is to describe the process of Envoy doing traffic forwarding. The party considering the traffic of the downstream is to receive the request sent by the downstream. You need to request additional services, such as \u0060reviews\u0060 service requests need Pod \u0060ratings\u0060 service.\n\n\u0060reviews\u0060, there are three versions of the service, there is one instance of each version, three versions sidecar similar working steps, only to later \u0060reviews-v1-cb8655c75-b97zc\u0060 Sidecar flow Pod forwarding this step will be described.\n\n## Understanding the Inbound Handler\n\nThe role of the inbound handler is to transfer the traffic from the downstream intercepted by iptables to localhost to establish a connection with the application container inside the Pod.\n\nLook \u0060reviews-v1-cb8655c75-b97zc\u0060 at the Listener in the pod.\n\nRun \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc\u0060 to see what the Pod has a Listener.\n\n\u0060\u0060\u0060ini\nADDRESS            PORT      TYPE \n172.33.3.3         9080      HTTP \u003c---  Receives all inbound traffic on 9080 from listener 0.0.0.0_15006\n10.254.0.1         443       TCP  \u003c--\u002b\n10.254.4.253       80        TCP     |\n10.254.4.253       8080      TCP     |\n10.254.109.182     443       TCP     |\n10.254.22.50       15011     TCP     |\n10.254.22.50       853       TCP     |\n10.254.79.114      443       TCP     | \n10.254.143.179     15011     TCP     |\n10.254.0.2         53        TCP     | Receives outbound non-HTTP traffic for relevant IP:PORT pair from listener 0.0.0.0_15001\n10.254.22.50       443       TCP     |\n10.254.16.64       42422     TCP     |\n10.254.127.202     16686     TCP     |\n10.254.22.50       31400     TCP     |\n10.254.22.50       8060      TCP     |\n10.254.169.13      14267     TCP     |\n10.254.169.13      14268     TCP     |\n10.254.32.134      8443      TCP     |\n10.254.118.196     443       TCP  \u003c--\u002b\n0.0.0.0            15004     HTTP \u003c--\u002b\n0.0.0.0            8080      HTTP    |\n0.0.0.0            15010     HTTP    | \n0.0.0.0            8088      HTTP    |\n0.0.0.0            15031     HTTP    |\n0.0.0.0            9090      HTTP    | \n0.0.0.0            9411      HTTP    |  Receives outbound HTTP traffic for relevant port from listener 0.0.0.0_15001\n0.0.0.0            80        HTTP    |\n0.0.0.0            15030     HTTP    |\n0.0.0.0            9080      HTTP    |\n0.0.0.0            9093      HTTP    |\n0.0.0.0            3000      HTTP    |\n0.0.0.0            8060      HTTP    |\n0.0.0.0            9091      HTTP \u003c--\u002b    \n0.0.0.0            15006     TCP  \u003c--- Receives all inbound and outbound traffic to the pod from IP tables and hands over to virtual listener\n\u0060\u0060\u0060\n\nAs from \u0060productpage\u0060 traffic arriving \u0060reviews\u0060 Pods, downstream must clearly know the IP address of the Pod which is \u0060172.33.3.3\u0060, so the request is \u0060172.33.3.3:9080\u0060.\n\n**Virtual Listener**\n\nAs you can see from the Pod\u0027s Listener list, the 0.0.0.0:15001\/TCP Listener (the actual name is \u0060virtual\u0060) listens for all inbound traffic, and the following is the detailed configuration of the Listener.\n\n\u0060\u0060\u0060json\n{\n    \u0022name\u0022: \u0022virtual\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u00220.0.0.0\u0022,\n            \u0022portValue\u0022: 15006\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.tcp_proxy\u0022,\n                    \u0022config\u0022: {\n                        \u0022cluster\u0022: \u0022BlackHoleCluster\u0022,\n                        \u0022stat_prefix\u0022: \u0022BlackHoleCluster\u0022\n                    }\n                }\n            ]\n        }\n    ],\n    \u0022useOriginalDst\u0022: true\n}\n\u0060\u0060\u0060\n\n**UseOriginalDst** : As can be seen from the configuration in \u0060useOriginalDst\u0060the configuration as specified \u0060true\u0060, which is a Boolean value, the default is false, using iptables redirect connections, the proxy may receive port original destination address is not the same port, thus received at the proxy port It is 15001 and the original destination port is 9080. When this flag is set to true, the Listener redirects the connection to the Listener associated with the original destination address, here \u0060172.33.3.3:9080\u0060. Listener If no relationship to the original destination address, the connection processing by the Listener to receive it, i.e. the \u0060virtual\u0060Listener, after \u0060envoy.tcp_proxy\u0060forwarded to a filter process \u0060BlackHoleCluster\u0060, as the name implies, when no matching Envoy virtual listener when the effect of Cluster , will send the request to it and return 404. This will be referred to below Listener provided \u0060bindToPort\u0060 echoes.\n\n**Note** : This parameter will be discarded, please use the Listener filter of the original destination address instead. The main purpose of this parameter is: Envoy listens to the 15201 port to intercept the traffic intercepted by iptables via other Listeners instead of directly forwarding it. See the [Virtual Listener](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/#virtual-listener) for details .\n\n**Listener 172.33.3.3_9080**\n\nAs mentioned above, the traffic entering the inbound handler is \u0060virtual\u0060 transferred to the \u0060172.33.3.3_9080\u0060 Listener by the Listener. We are looking at the Listener configuration.\n\nRun \u0060istioctl pc listener reviews-v1-cb8655c75-b97zc --address 172.33.3.3 --port 9080 -o json\u0060 view.\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022172.33.3.3_9080\u0022,\n    \u0022address\u0022: {\n        \u0022socketAddress\u0022: {\n            \u0022address\u0022: \u0022172.33.3.3\u0022,\n            \u0022portValue\u0022: 9080\n        }\n    },\n    \u0022filterChains\u0022: [\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022raw_buffer\u0022\n            },\n            \u0022filters\u0022: [\n                {\n                    \u0022name\u0022: \u0022envoy.http_connection_manager\u0022,\n                    \u0022config\u0022: {\n                        ... \n                        \u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        },\n                        \u0022use_remote_address\u0022: false,\n                        ...\n                    }\n                }\n            ]，\n            \u0022deprecatedV1\u0022: {\n                \u0022bindToPort\u0022: false\n            }\n        ...\n        },\n        {\n            \u0022filterChainMatch\u0022: {\n                \u0022transportProtocol\u0022: \u0022tls\u0022\n            },\n            \u0022tlsContext\u0022: {...\n            },\n            \u0022filters\u0022: [...\n            ]\n        }\n    ],\n...\n}]\n\u0060\u0060\u0060\n\n**bindToPort** : Note that there are a [\u0060bindToPort\u0060](https:\/\/www.envoyproxy.io\/docs\/envoy\/v1.6.0\/api-v1\/listeners\/listeners) configuration that is \u0060false\u0060, the default value of the configuration \u0060true\u0060, showing Listener bind to the port, set here to \u0060false\u0060 the process flow can Listener Listener transferred from the other, i.e., above said \u0060virtual\u0060 Listener, where we see filterChains.filters in the \u0060envoy.http_connection_manager\u0060 configuration section:\n\n\u0060\u0060\u0060json\n\u0022route_config\u0022: {\n                            \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                            \u0022validate_clusters\u0022: false,\n                            \u0022virtual_hosts\u0022: [\n                                {\n                                    \u0022domains\u0022: [\n                                        \u0022*\u0022\n                                    ],\n                                    \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                    \u0022routes\u0022: [\n                                        {\n                                            ...\n                                            \u0022route\u0022: {\n                                                \u0022cluster\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n                                                \u0022max_grpc_timeout\u0022: \u00220.000s\u0022,\n                                                \u0022timeout\u0022: \u00220.000s\u0022\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n\u0060\u0060\u0060\n\nThis configuration indicates that traffic will be handed off to the Cluster for \u0060inbound|9080||reviews.default.svc.cluster.local\u0060 processing.\n\n**Cluster \u0060inbound|9080||reviews.default.svc.cluster.local\u0060**\n\nRun \u0060istioctl pc cluster reviews-v1-cb8655c75-b97zc --fqdn reviews.default.svc.cluster.local --direction inbound -o json\u0060 to see the Cluster configuration is as follows.\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||reviews.default.svc.cluster.local\u0022,\n        \u0022connectTimeout\u0022: \u00221.000s\u0022,\n        \u0022hosts\u0022: [\n            {\n                \u0022socketAddress\u0022: {\n                    \u0022address\u0022: \u0022127.0.0.1\u0022,\n                    \u0022portValue\u0022: 9080\n                }\n            }\n        ],\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {}\n            ]\n        }\n    }\n]\n\u0060\u0060\u0060\n\nYou can see that the Endpoint of the Cluster directly corresponds to localhost, and then the traffic is forwarded by the application container after iptables.\n\n## Understanding the Outbound Handler\n\nBecause the \u0060reviews\u0060 will to \u0060ratings\u0060 send an HTTP request service, request address are: \u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060 the role of Outbound handler is to intercept traffic to iptables to native applications sent via Envoy to determine how to route to the upstream.\n\nThe request sent by the application container is outbound traffic. After being intercepted by iptables, it is transferred to the Envoy Outbound handler for processing, then passed through \u0060virtual\u0060 Listener and \u00600.0.0.0_9080\u0060 Listener, and then finds the cluster of upstream through Route 9080, and then finds Endpoint through EDS to perform routing action. \n\n**Route 9080**\n\n\u0060reviews\u0060 requests \u0060ratings\u0060 service, run \u0060istioctl proxy-config routes reviews-v1-cb8655c75-b97zc --name 9080 -o json\u0060 view route configuration because Envoy VirtualHost will be matched according to HTTP header of domains, so the following list only \u0060ratings.default.svc.cluster.local:9080\u0060 this one VirtualHost.\n\n\u0060\u0060\u0060json\n[{\n    \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n    \u0022domains\u0022: [\n        \u0022ratings.default.svc.cluster.local\u0022,\n        \u0022ratings.default.svc.cluster.local:9080\u0022,\n        \u0022ratings\u0022,\n        \u0022ratings:9080\u0022,\n        \u0022ratings.default.svc.cluster\u0022,\n        \u0022ratings.default.svc.cluster:9080\u0022,\n        \u0022ratings.default.svc\u0022,\n        \u0022ratings.default.svc:9080\u0022,\n        \u0022ratings.default\u0022,\n        \u0022ratings.default:9080\u0022,\n        \u002210.254.234.130\u0022,\n        \u002210.254.234.130:9080\u0022\n    ],\n    \u0022routes\u0022: [\n        {\n            \u0022match\u0022: {\n                \u0022prefix\u0022: \u0022\/\u0022\n            },\n            \u0022route\u0022: {\n                \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                \u0022timeout\u0022: \u00220.000s\u0022,\n                \u0022maxGrpcTimeout\u0022: \u00220.000s\u0022\n            },\n            \u0022decorator\u0022: {\n                \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n            },\n            \u0022perFilterConfig\u0022: {...\n            }\n        }\n    ]\n},\n..]\n\u0060\u0060\u0060\n\nYou can see the routing of traffic to the Cluster from this Virtual Host configuration \u0060outbound|9080||ratings.default.svc.cluster.local\u0060.\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nIstio 1.1 previous versions do not support the use of \u0060istioctl\u0060 commands to directly query Endpoint Cluster, you can use the debug queries Pilot endpoint way compromise.\n\n\u0060\u0060\u0060bash\nkubectl exec reviews-v1-cb8655c75-b97zc -c istio-proxy curl http:\/\/istio-pilot.istio-system.svc.cluster.local:9093\/debug\/edsz \u003e endpoints.json\n\u0060\u0060\u0060\n\n\u0060endpoints.json\u0060 file contains all the Endpoint information of the Cluster, and we only select \u0060outbound|9080||ratings.default.svc.cluster.local\u0060 the results of the Cluster as follows.\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nThe Endpoint can be one or more, and Envoy will route it according to certain rules by selecting the appropriate Endpoint.\n\n**Note** : Istio 1.1 will support the \u0060istioctl pc endpoint\u0060 command to query Endpoint.\n\n## Reference\n\n- [Debugging Envoy and Pilot - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/proxy-cmd\/)\n- [Understanding Envoy Agent Sidecar Injection and Traffic Interception in Istio Service Mesh - jimmysong.io](\/en\/blog\/envoy-sidecar-injection-in-istio-service-mesh-deep-dive\/)\n- [Istio traffic management implementation mechanism deep analysis - zhaohuabing.com](https:\/\/zhaohuabing.com\/post\/2018-09-25-istio-traffic-management-impl-intro\/)\n\n', '\/en\/blog\/understanding-how-envoy-sidecar-intercept-and-route-traffic-in-istio-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Details about Envoy sidecar with iptables rules.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(42)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(9)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(4)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(4)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/seamless-cross-cluster-access-istio/">A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/how-to-integrate-third-party-registry-with-istio/">How to Integrating Third-Party Service Registries with Istio?</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-gateway-oidc/">How to Implement Single Sign-On (SSO) with OIDC in API Gateway using Envoy Gateway?</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
