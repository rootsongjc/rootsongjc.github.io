<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh Column - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here.">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.f6911c0ac7d2b5b69c3f2d9f2a2b3b496b5da0608580347fdb4dc11ef74f3ec5.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/categories/service-mesh/" />
  <meta property="og:title" content="Service Mesh Column | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh Column | Jimmy Song" />

  
  <meta property="og:description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here." />
  <meta property="twitter:description" content="Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here." />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/categories/service-mesh/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh Column
                </p>
                <p class="page-description">
                    Welcome to the Service Mesh Column, your comprehensive resource for all things related to service mesh technology. I cover a wide range of topics from foundational concepts to advanced applications, including service discovery, load balancing, traffic management, security policies, and observability. Whether you are a beginner or an experienced developer, you will find valuable content here.
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/introducing-kmesh-kernel-native-service-mesh/">Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology', 'Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.', '\nIn the world of microservices and cloud-native applications, service meshes have become essential for managing service-to-service communication. However, traditional sidecar-based architectures introduce significant latency and resource overhead, posing challenges for latency-sensitive and large-scale applications. **Kmesh** emerges as a groundbreaking solution—a high-performance, kernel-native service mesh data plane that leverages eBPF and kernel enhancements to deliver unparalleled efficiency and performance.\n\n## Background\n\nService meshes like Istio have become integral in managing complex microservices architectures, providing features like traffic management, security, and observability. The sidecar model, where a proxy runs alongside each service instance, has been the predominant approach. While effective in functionality, this architecture introduces significant latency and resource overhead.\n\n{{\u003ccallout note \u0022Note\u0022\u003e}}\n\nAll data presented in this article is quoted from [A New Choice for Istio Data Plane: Architectural Innovation for a Brand-New Performance Experience](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no). I have not verified the accuracy of these data. You are requested to judge and verify the reliability of these data on your own.\n\n{{\u003c\/callout\u003e}}\n\n## Limitations of Traditional Sidecar Architectures\n\n1. **Latency Overhead**: The addition of sidecar proxies results in increased network hops and context switches, introducing an extra **2 to 3 milliseconds** of latency per service call. For latency-sensitive applications, this delay is unacceptable.\n\n2. **Resource Consumption**: Each sidecar consumes CPU and memory resources. In large-scale deployments with thousands of services, the accumulated resource overhead is huge. Although it can be optimized through certain technical means, it still reduces deployment density and increases operating costs.\n\nPerformance measurements of Istio reveal that even without traffic distribution, there\u0027s an inherent latency overhead of approximately 3 milliseconds. As the number of connections grows, latency increases correspondingly, highlighting the inefficiency of the sidecar model for high-performance applications.\n\n## Industry Attempts to Address the Challenges\n\nSeveral solutions have been proposed to mitigate the drawbacks of sidecar architectures:\n\n### Cilium Service Mesh\n\n- **Approach**: Combines eBPF with Envoy to create a sidecar-less service mesh.\n- **Mechanism**:\n  - **L4 Traffic**: Uses eBPF for efficient kernel-level data routing.\n  - **L7 Traffic**: Relies on Envoy for application-layer parsing.\n- **Limitations**:\n  - **Extra Hops for L7**: L7 governance through Envoy introduces additional network hops.\n  - **Fault Isolation**: Challenges in ensuring governance fault isolation.\n\n### Istio Ambient Mesh\n\n- **Approach**: Introduces sidecar-less architecture using **ztunnel** and **waypoint** proxies.\n- **Mechanism**:\n  - **User-Space Processing**: All traffic interception and management occur in user space.\n- **Limitations**:\n  - **Complex Traffic Interception**: User-space interception increases complexity.\n  - **Increased Hops**: L7 connections involve multiple network hops, adding latency.\n\nThese solutions, while innovative, do not fully resolve the latency and resource overhead issues inherent in sidecar architectures.\n\n## Introducing Kmesh: A Kernel-Native Approach\n\nKmesh defines a new service mesh data plane by directly integrating traffic governance into the operating system kernel. Utilizing eBPF (Extended Berkeley Packet Filter) and kernel enhancements, Kmesh provides high-performance, low-latency, and resource-efficient service mesh capabilities.\n\n### Technical Architecture\n\n![Kmesh Architecture](kmesh-arch.svg)\n\n**Core Components**:\n\n- **Kmesh-Daemon**: A per-node management component responsible for:\n  - Managing eBPF programs.\n  - Subscribing to xDS configurations from the control plane (e.g., Istiod).\n  - Handling observability and metrics collection.\n\n- **eBPF Orchestration**: Implements traffic interception and management at the kernel level, supporting:\n  - L4 load balancing.\n  - Traffic encryption and decryption.\n  - Monitoring and simple L7 dynamic routing.\n\n- **Waypoint Proxy (Optional in Dual Engine Mode)**: Handles advanced L7 traffic governance, deployed per namespace or per service as needed.\n\n### Key Advantages\n\n![Kmesh vs Sidecar vs Ambient ([Source](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no))](performance.webp)\n\n1. **High Performance**:\n   - **Latency Reduction**: Kernel-native L7 management reduces forwarding latency by over **60%** compared to traditional sidecar architectures.\n   - **Improved Application Startup**: Application bootstrap times improve by **40%** due to the elimination of sidecar initialization.\n\n2. **Low Resource Overhead**:\n   - **Resource Efficiency**: Eliminates the need for sidecar proxies, reducing resource consumption by over **70%**.\n\n3. **High Availability**:\n   - **Seamless Upgrades**: Kernel-level traffic management ensures that upgrading or restarting Kmesh components does not disrupt existing service connections.\n\n4. **Security Isolation**:\n   - **Enhanced Security**: Utilizes BPF-based virtual machine security and cgroup-level governance isolation to ensure secure multi-tenancy.\n\n5. **Flexible Governance Model**:\n   - **Deployment Modes**: Offers both Kernel-Native Mode for maximum performance and Dual Engine Mode for deployment flexibility.\n\n6. **Seamless Compatibility**:\n   - **Control Plane Integration**: Fully compatible with the xDS protocol, allowing integration with Istio\u0027s control plane and supporting Istio APIs and Gateway APIs.\n\n## Two Operational Modes of Kmesh\n\nKmesh provides two operational modes to cater to different deployment needs:\n\n### Kernel-Native Mode\n\n**Overview**:\n\n- **Ultimate Performance**: Achieves the lowest possible latency with no additional network hops for both L4 and L7 traffic.\n- **Mechanism**:\n  - **Kernel Enhancements**: Enhances the kernel using eBPF and kernel modules (ko).\n  - **Fake TCP Connections**: Utilizes forged connections to manage complex application-layer traffic within the kernel.\n  - **Traffic Management**: Directly manages traffic as soon as the client initiates communication, eliminating unnecessary context switches and data copies.\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces forwarding latency by over 60%.\n- **No Dependency on User-Space Proxies**: Entire traffic management is handled within the kernel.\n\n**Considerations**:\n\n- **Kernel Version Requirements**: May require specific kernel versions or enhancements, which could impact deployment flexibility.\n\n### Dual Engine Mode\n\n**Overview**:\n\n- **Flexible Governance**: Balances performance with broader compatibility and flexibility.\n- **Mechanism**:\n  - **Kernel-Level Interception**: Uses eBPF to intercept traffic in the kernel space.\n  - **Waypoint Proxy**: Deploys a remote waypoint proxy to handle complex L7 traffic management.\n  - **Layer Separation**: Splits L4 and L7 governance between kernel space (eBPF) and user space (waypoint).\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces latency by **30%** compared to Istio\u0027s Ambient Mesh.\n- **Simplified Traffic Interception**: Kernel-space interception is more secure and simpler than user-space interception.\n- **Lower Adoption Threshold**: Reduced dependency on specific kernel versions, making it easier for users to adopt.\n\n**Comparison with Ambient Mesh**:\n\n- **Fewer Network Hops**: Kmesh adds only one extra hop for L7 connections, whereas Ambient Mesh may add up to three.\n- **Simpler Architecture**: Kernel-level interception avoids the complexity of user-space interception mechanisms.\n\n## Deep Dive into Kmesh\u0027s Technology\n\n### eBPF and Kernel Enhancements\n\n**eBPF (Extended Berkeley Packet Filter)** is a powerful technology that allows the injection of custom code into the Linux kernel safely and efficiently. Kmesh leverages eBPF to:\n\n- **Intercept Network Traffic**: Attach eBPF programs to network events, enabling real-time interception and manipulation of packets.\n- **Implement Load Balancing**: Direct traffic to appropriate service instances based on policies.\n- **Perform Traffic Encryption**: Handle mTLS encryption and decryption within the kernel, reducing overhead.\n- **Collect Observability Data**: Gather metrics and telemetry data without impacting application performance.\n\n### Traffic Interception and Management\n\nIn the Kernel-Native Mode:\n\n- **Forged Connections**: Kmesh creates fake TCP connections within the kernel to manage traffic without involving user-space proxies.\n- **Direct Packet Manipulation**: Packets are intercepted and redirected at the kernel level, eliminating context switches and data copies that occur when moving packets between user space and kernel space.\n\nIn the Dual Engine Mode:\n\n- **eBPF Interception**: eBPF programs handle initial traffic interception and basic L4 management.\n- **Waypoint Proxy**: For advanced L7 features like routing, retries, and header manipulation, traffic is forwarded to a waypoint proxy deployed per service or namespace.\n\n### Security and Isolation\n\n- **BPF Virtual Machine Security**: eBPF runs in a restricted virtual machine within the kernel, ensuring that injected code cannot compromise kernel stability.\n- **Cgroup-Level Isolation**: Governance policies are applied at the cgroup level, providing isolation between different services and workloads.\n- **mTLS Support**: Mutual TLS is implemented within the kernel (Under development. Planned to be supported by the end of 2024), providing zero-trust security without the overhead of user-space encryption.\n\n## Performance Analysis\n\n**Test Setup**:\n\n- **Benchmark Tool**: Used [Fortio](https:\/\/github.com\/fortio\/fortio) to generate load and measure latency.\n- **Comparisons**: Measured performance across four configurations:\n  1. **Baseline**: Direct communication without any service mesh.\n  2. **Istio Sidecar**: Traditional sidecar-based deployment.\n  3. **Istio Ambient Mesh**: Sidecar-less deployment with ztunnel and waypoint.\n  4. **Kmesh**: Both Kernel-Native and Dual Engine modes.\n\n**Results**:\n\n- **Latency**:\n  - **Kmesh Kernel-Native Mode**: Achieved over **60%** reduction in forwarding latency compared to Istio Sidecar.\n  - **Kmesh Dual Engine Mode**: Reduced latency by **30%** compared to Istio Ambient Mesh.\n- **Resource Consumption**:\n  - **CPU and Memory**: Kmesh reduced resource overhead by over **70%**, as it eliminates the need for sidecar proxies.\n- **Application Startup Time**:\n  - Improved by **40%**, as applications no longer wait for sidecar initialization.\n\n**Interpretation**:\n\n- Kmesh approaches baseline performance, making the overhead of the service mesh negligible.\n- The elimination of context switches and data copies contributes significantly to performance gains.\n- The kernel-native approach ensures consistent performance even as the number of services scales.\n\n## Cloud-Native Integration and Compatibility\n\n- **Kubernetes Native**: Kmesh runs seamlessly on Kubernetes, managing traffic to and from pods without requiring changes to application code.\n- **Control Plane Integration**:\n  - **xDS Protocol Support**: Subscribes to xDS configurations from Istiod, ensuring compatibility with Istio\u0027s control plane.\n  - **Istio API Compatibility**: Supports existing Istio APIs, allowing users to leverage familiar configurations and policies.\n- **Gateway API Support**: Compatible with Gateway APIs, enabling more flexible and expressive traffic management.\n- **Observability**:\n  - Integrates with Prometheus for metrics collection.\n  - Utilizes eBPF for efficient data gathering without impacting performance.\n- **Security Policies**:\n  - Supports existing Istio security policies, including authentication and authorization.\n\n## Future Roadmap\n\n**Short-Term Goals (2024)**:\n\n- **September 2024**:\n  - Implement circuit breaking and rate limiting.\n  - Enhance support for mTLS and upstream extensions.\n  - Ensure seamless restarts without affecting traffic.\n- **December 2024 (Release 1.0)**:\n  - Introduce locality-aware load balancing.\n  - Add multi-cluster support for federated deployments.\n  - Enhance DNS and headless service handling.\n  - Integrate with gateway components for edge traffic management.\n\n**Long-Term Vision (2025 and Beyond)**:\n\n- **AI Integration**:\n  - Incorporate AI capabilities to improve traffic governance decisions.\n  - Enhance problem diagnostics and anomaly detection.\n- **Multi-VPC Support**:\n  - Extend support to multi-Virtual Private Cloud environments.\n- **Advanced Observability**:\n  - Leverage eBPF and Application Performance Management tools for deeper insights.\n  - Provide end-to-end tracing and metrics.\n\n## Conclusion\n\nKmesh represents a paradigm shift in service mesh technology by moving traffic management into the kernel. By leveraging eBPF and kernel enhancements, it addresses the critical challenges of latency and resource overhead inherent in traditional sidecar architectures. Kmesh offers a flexible, high-performance solution suitable for modern cloud-native applications, particularly those requiring low latency and high throughput.\n\n**Key Takeaways**:\n\n- **Performance**: Achieves near-baseline performance by eliminating unnecessary overhead.\n- **Resource Efficiency**: Reduces CPU and memory consumption, enabling higher deployment densities.\n- **Flexibility**: Provides multiple operational modes to suit different deployment scenarios.\n- **Security**: Enhances security through kernel-level enforcement and isolation mechanisms.\n- **Compatibility**: Integrates seamlessly with existing cloud-native ecosystems, including Kubernetes and Istio.\n\nAs microservices architectures continue to evolve, solutions like Kmesh will play a crucial role in enabling efficient, scalable, and secure service communication. By addressing the limitations of traditional service mesh designs, Kmesh sets a new standard for performance and resource efficiency in the service mesh landscape.\n', '\/en\/blog\/introducing-kmesh-kernel-native-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Migrate from Kubernetes Ingress to the Gateway API', 'This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.', '\nWith the release of Istio 1.22, the Istio API has officially been upgraded to version v1, coinciding with the update of the Kubernetes Gateway API to v1.1. This article aims to explore the connections and differences between the Ingress API, Istio API, and Kubernetes Gateway API, detailing their selection and migration strategies in practical applications.\n\n## Introduction\n\nPreviously, I wrote an article discussing [Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh](\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/). The article pointed out that as Kubernetes\u0027 original ingress gateway, Ingress\u0027s resource model is too simple to meet the demands of today\u0027s programmable networks. As its successor, the Gateway API has rapidly developed in recent years and has gained broad support, including many emerging open-source gateway projects like [Envoy Gateway](https:\/\/gateway.envoyproxy.io) choosing to develop based on the Gateway API. Additionally, some legacy gateway projects have started adapting to the Gateway API or using tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) to migrate.\n\nThe Gateway API, as the latest achievement in Kubernetes ingress gateways, separates concerns through role division and supports cross-namespace capabilities, making it more suitable for multi-cloud environments. It integrates the overlapping functions of ingress gateways (north-south) and service meshes (east-west, intra-cluster routing) to provide a new reference model for unified traffic management in the cloud-native era.\n\nIngress API, Gateway API, and Istio API can all implement gateway functions, but what are the connections and differences between them? This article will unveil this mystery and provide strategies for selecting and migrating gateways in Kubernetes environments.\n\n## Kubernetes Traffic Management\n\nWith the widespread adoption and increasing complexity of microservice architectures, Kubernetes\u0027 traffic management tools have also evolved to meet various technical needs. The Ingress API, Istio API, and Kubernetes Gateway API each represent different stages of this evolution.\n\n**Ingress API** offers basic traffic management capabilities in Kubernetes, allowing users to manage external access to services within the cluster through simple routing rules (e.g., HTTP and HTTPS). Although its design is straightforward, its functionality is limited and mainly suitable for smaller-scale, less complex applications.\n\nIn contrast, **Istio API**, as part of a service mesh, offers a range of advanced traffic management features, such as traffic mirroring, canary releases, and circuit breakers, suitable for large-scale microservice architectures requiring complex traffic management.\n\nTo overcome the limitations of the Ingress API and integrate advanced features similar to those of Istio, the **Kubernetes Gateway API** was developed. It not only provides greater flexibility and extensibility in its design but also, through broad community support, serves as a bridge connecting traditional Ingress implementations and modern service mesh technologies like Istio, with most mainstream open-source gateways being based on or adapted to the Gateway API.\n\nThe following table summarizes the core features and recommended use cases for each API:\n\n| API Name      | Object Type                | Status                  | Recommended Use Cases                                       |\n| ------------- | -------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API   | \u0060Ingress\u0060                  | Stable (Kubernetes v1.19)| Suitable for small-scale and simple scenarios, mainly for basic routing configurations |\n| Istio API     | \u0060VirtualService\u0060, \u0060Gateway\u0060| Stable (Istio 1.22)     | Suitable for highly complex microservice architectures, requiring fine-grained control and advanced traffic management features |\n| Gateway API   | \u0060HTTPRoute\u0060, \u0060Gateway\u0060     | Stable (Gateway API v1.1)| Suitable for new or existing deployments that require increased flexibility and scalability, especially when combined with Istio |\n\nThe launch of [Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/), especially its improvements in compatibility with existing Ingress configurations, provides a smooth migration path for users, making the transition from traditional Ingress solutions to more modern, feature-rich Gateway API easier.\n\n## Migrating from Ingress to Kubernetes Gateway API\n\nTo migrate from Ingress to Gateway API, follow these steps:\n\n1. **Understand Key Differences**: Compared to Ingress, the Gateway API introduces several new concepts and resource types, such as \u0060Gateway\u0060, \u0060HTTPRoute\u0060, and \u0060TLSRoute\u0060. These resources offer more configuration options and flexibility; refer to the [Gateway API documentation](https:\/\/gateway-api.sigs.k8s.io\/guides\/) for their configurations.\n2. **Configure Entry Points**: Create \u0060Gateway\u0060 resource configurations, clearly defining how to receive external traffic, including protocols, ports, and TLS terminations.\n3. **Map Old Resources**: Map existing Ingress resources to corresponding Gateway API resources. For example, host and path rules in Ingress need to be converted into route rules in HTTPRoute.\n4. **Test and Deploy**: Before officially migrating, test the new Gateway API configurations in a test environment to ensure all traffic routing is normal and there are no security vulnerabilities.\n\nTo simplify the migration process, you can use tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway), which can automatically convert Ingress configurations into Gateway API formats.\n\n## Practical Migration Example\n\nHere is a simple example of an HTTP gateway configuration demonstrating how to migrate from Ingress to the Gateway API.\n\nAssume you have an existing Ingress configuration as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\nTo migrate it to the Gateway API, first create a Gateway object:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds:\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\nEnsure that the \u0060gatewayClassName\u0060 refers to a valid GatewayClass configured in your cluster. The GatewayClass is usually set by the cluster administrator and provides a resource to configure the Gateway.\n\nNext, create an HTTPRoute resource to define routing rules that route traffic to the backend service:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\nIn this example, we see:\n\n- The rules from the \u0060Ingress\u0060 object are directly mapped to the \u0060HTTPRoute\u0060 object.\n- The hostname matching, path matching, and backend service configurations remain unchanged, but the object and field names differ.\n\n## Considerations and Challenges\n\nAlthough it is possible to migrate from Ingress to Gateway API and potentially run them simultaneously, there are several challenges and considerations for the necessity of migration:\n\n- **Feature Differences**: Certain features specific to some Ingress controllers may not have direct equivalents in the Gateway API, requiring additional configurations or custom resources to achieve similar functionalities.\n- **Multi-Resource Management**: Using the Gateway API may involve managing more resource types and complex configurations than Ingress, potentially increasing the complexity of administration.\n\nFor existing users of Ingress and Istio API, whether to migrate to the Gateway API depends on specific circumstances. Here are some migration recommendations:\n\n- **For New Deployments**: It is advisable to use the Gateway API directly to take advantage of its advanced features and anticipate future developments.\n- **For Existing Deployments**: If the existing system operates stably and does not require advanced features, you can continue using the current APIs. If you seek to leverage new features of the Gateway API or plan for long-term development, a gradual migration is a prudent choice.\n\nFor the support status of different gateways for the Gateway API, refer to the [Gateway API Implementation Conformance Report](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/) for more details.\n\n## Conclusion\n\nThe Ingress API, Istio API, and Kubernetes Gateway API each have distinct features suitable for different application scenarios and needs. Selecting the appropriate API and planning and managing effectively can significantly enhance system flexibility and stability. As the Gateway API continues to develop and mature, it is increasingly becoming the mainstream choice for future traffic management.\n\nChoosing the right gateway technology, combined with your specific needs and existing architecture, can better manage and optimize traffic to ensure efficient and stable application operation. As technology progresses and the community evolves, the Gateway API provides a powerful and flexible framework, making the transition from traditional Ingress to more modern solutions simpler and more effective.\n\n## References\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/kubernetes-ingress-to-gateway-api-migration\/).*', '\/en\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-in-2021/">Service Mesh in 2021: The Ecosystem Is Emerging</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh in 2021: The Ecosystem Is Emerging', 'A review of the development of Service Mesh in 2021.', '\nAs the service mesh architecture concept gains traction and the scenarios for its applications emerge, there is no shortage of discussions about it in the community. I have worked on service mesh with the community for 4 years now, and will summarize the development of service mesh in 2021 from this perspective. Since Istio is the most popular service mesh, this article will focus on the technical and ecological aspects of Istio.\n\n## Service mesh: a critical tech for Cloud Native Infrastructure \n\nAs one of the vital technologies [defined by CNCF](https:\/\/github.com\/cncf\/toc\/blob\/main\/DEFINITION.md) for cloud native, Istio has been around for five years now. Their development has gone through the following periods.\n\n- Exploration phase: 2017-2018\n- Early adopter phase: 2019-2020\n- Large-scale landing and ecological development phase: 2021-present\n\nService mesh has crossed the “chasm”(refer [Crossing the Chasm](https:\/\/thinkinsights.net\/strategy\/crossing-the-chasm\/) theory) and is in between the “early majority” and “late majority” phases of adoption. Based on feedback from the audience of [Istio Weekly,](https:\/\/github.com\/tetratelabs\/istio-weekly\/) users are no longer blindly following new technologies for experimentation and are starting to consider whether they need them in their organization dialectically.\n\n![Cross the chasm](008i3skNly1gysddnj9i2j30sg0fqaaz.jpg)\n\nWhile new technologies and products continue to emerge, the service mesh, as part of the cloud native technology stack, has continued to solidify its position as the “cloud native network infrastructure” over the past year. The diagram below illustrates the cloud native technology stack model, where each layer has several representative technologies that define the standard. As new-age middleware, the service mesh mirrors other cloud native technologies, such as [Dapr](https:\/\/dapr.io\/) (Distributed Application Runtime), which represents the capability model for cloud native middleware, [OAM](https:\/\/oam.dev\/), which defines the cloud native application model, and the service mesh, which defines the L7 network model.\n\n![Cloud Native Stack](008i3skNly1gysddogtenj30sg0qlwgs.jpg)\n\nA layered view of the cloud native application platform technology stack\n\n## Optimizing the mesh for large scale production applications with different deployment models\n\nOver the past year, the community focused on the following areas.\n\n- Performance optimization: performance issues of service mesh in large-scale application scenarios.\n- Protocol and extensions: enabling service mesh to support arbitrary L7 network protocols.\n- Deployment models: Proxyless vs. Node model vs. Sidecar model.\n- eBPF: putting some of the service mesh’s capabilities to the kernel layer.\n\n### Performance optimization\n\nIstio was designed to serve service to service traffic by “proto-protocol forwarding”. The goal is making the service mesh as “transparent” as possible to applications. Thus using IPtables to hijack the traffic, according to the community-provided test results Istio 1.2 adds only 3 ms to the baseline latency for a mesh with 1000 RPS on 16 connections. However, because of issues inherent in the IPtables conntrack module, Istio’s performance issues begin to emerge as the mesh size increases. To optimize the performance of the Istio sidecar for resource usage and network latency, the community gave the following solutions.\n\n- Sidecar configuration: By configuring service dependencies manually or by adding an Operator to the control plane, the number of service configurations sent to Sidecar can be reduced, thus reducing the resource footprint of the data plane; for more automatic and intelligent configuration of Sidecar, the open source projects [Slime](https:\/\/github.com\/slime-io\/slime) and [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) both offer their innovative configuration loading solutions.\n- The introduction of eBPF: eBPF can be a viable solution to optimize the performance of the service mesh. Some Cilium-based startups even radically propose to use eBPF to replace the Sidecar proxy completely. Still, the Envoy proxy\/xDS protocol has become the proxy for the service mesh implementation and supports the Layer 7 protocol very well. We can use eBPF to improve network performance, but complex protocol negotiation, parsing, and user scaling remain challenging to implement on the user side.\n\n### Protocol and extensions\n\nExtensibility of Istio has always been a significant problem, and there are two aspects to Istio’s extensibility.\n\n- Protocol level: allowing Istio to support all L7 protocols\n- Ecological: allowing Istio to run more extensions\n\nIstio uses Envoy as its data plane. Extending Istio is essentially an extension of Envoy’s functionality. Istio’s official solution is to use WebAssembly, and in Istio 1.12, the [Wasm plugin configuration API](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was introduced to extend the Istio ecosystem. Istio’s extension mechanism uses the [Proxy-Wasm Application Binary Interface (ABI)](https:\/\/github.com\/proxy-wasm\/spec) specification to provide a set of proxy-independent streaming APIs and utilities that can be implemented in any language with an appropriate SDK. Today, Proxy-Wasm’s SDKs are AssemblyScript (similar to TypeScript), C\u002b\u002b, Rust, Zig, and Go (using the TinyGo WebAssembly System Interface).\n\nThere are still relatively few WebAssembly extensions available, and many enterprises choose to customize their CRD and build a service mesh management plane based on Istio. In addition, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is also in strong demand for end-users. It allows them to migrate applications from traditional loads to service mesh easily. Finally, there is the hybrid cloud traffic management with multiple clusters and mesh, which is a more advanced requirement.\n\n### Deployment models\n\nWhen the service mesh concept first emerged, there was a debate between the Per-node and Sidecar models, represented by Linkerd and Istio. eBPF later proposed a kernel to sink the service mesh, which led to more service mesh deployment models, as shown in the figure below.\n\n![Service Mesh Deployment Models](008i3skNly1gysddpco2mj30qz0sgwhk.jpg)\n\nThese four deployment methods have their own advantages and disadvantages, the specific choice of which depends on the actual situation.\n\n### Development of the Istio ecosystem and the projects that support Istio\n\n2021 was also an exciting year for the Istio community, with a series of events and tutorials.\n\n- February, the first Istio distribution, [Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/).\n- February, the first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was held online, with over 2,000 participants.\n- March, the first free online [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals) is released.\n- May, the first [Certification Istio Administrator exam](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) be released.\n- May, ServiceMeshCon Europe was held online.\n- July, [Istio Meetup China](https:\/\/istio.io\/latest\/zh\/blog\/2021\/istiomeetups-china\/) was held in Beijing with more than 100 attendees.\n- October, ServiceMeshCon North America was held in Los Angeles.\n\nThere are also numerous open source projects related to Istio Service Mesh, as shown in the table below.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\nNote: Data is as of January 6, 2022\n\n## Summary\n\nLooking back, we can see that, unlike previous years where users were experimenting, users in 2021 looked for more practical uses for service mesh before implementing them. Their position as the infrastructure of cloud native networks is further strengthened, and more importantly, the service mesh ecosystem is emerging. Looking ahead, in 2022, two technologies to watch are eBPF and WebAssembly(Wasm). We believe that more good examples of service mesh practices will emerge, taking the ecology and standardization a step further.\n', '\/en\/blog\/service-mesh-in-2021\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A review of the development of Service Mesh in 2021.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/">The Debate in the Community About Istio and Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 17, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Debate in the Community About Istio and Service Mesh', 'There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.', '\nYou can use Istio to do [multi-cluster management](https:\/\/www.tetrate.io\/blog\/multicluster-management-with-kubernetes-and-istio\/), [API Gateway](https:\/\/www.tetrate.io\/blog\/istio-servicemesh-api-gateway\/), and manage applications on Kubernetes or [virtual machines](https:\/\/www.tetrate.io\/blog\/istio-18-a-virtual-machine-integration-odyssey\/). In my [last blog](https:\/\/www.tetrate.io\/blog\/why-is-service-mesh-a-necessary-part-of-cloud-native\/), I talked about how service mesh is an integral part of cloud native applications. However, building infrastructure can be a big deal. There is no shortage of debate in the community about the practicability of service mesh and Istio– here’s a list of common questions and concerns, and how to address them.\n\n- Is anyone using Istio in production?\n- What is the impact on application performance due to the many resources consumed by injecting sidecar into the pod?\n- Istio supports a limited number of protocols; is it scalable?\n- Will Istio be manageable? – Or is it too complex, old services too costly to migrate, and the learning curve too steep?\n\nI will answer each of these questions below.\n\n### Istio is architecturally stable, production-ready, and ecologically emerging\n\n[Istio 1.12](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was just released in November – and has evolved significantly since the explosion of service mesh in 2018 (the year Istio co-founders established Tetrate). Istio has a large community of providers and [users](https:\/\/istio.io\/latest\/about\/case-studies\/). The Istio SIG of Cloud Native Community has held eight Istio Big Talk (Istio 大咖说), with Baidu, Tencent, NetEase, Xiaohongshu(小红书), and Xiaodian Technology(小电科技) sharing their Istio practices. According to [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), about 50% of the companies surveyed are using a service mesh in production or planning to in the next year, and about half (47%) of organizations using a service mesh in production are using Istio.\n\nMany companies have developed extensions or plugins for Istio, such as Ant, NetEase, eBay, and Airbnb. Istio’s architecture has been stable since the 1.5 release, and the release cycle is fixed quarterly, with the current project’s main task being Day-2 Operations. \n\nThe Istio community has also hosted various events, with the first IstioCon in March 2021, the Istio Meetup China in Beijing in July, and the Service Mesh Summit 2022 in Shanghai in January 2022.\n\nSo we can say that the Istio architecture is stable and production-ready, and the ecosystem is budding.\n\n### The impact of service mesh on application performance\n\nA service mesh uses iptables to do traffic hijacking by default to be transparent to applications. When the number of services is large, there are a lot of iptables rules that affect network performance. You can use techniques like [eBPF](https:\/\/cloudnative.to\/blog\/how-ebpf-streamlines-the-service-mesh\/) to provide application performance, but the method requires a high version of the operating system kernel, which few enterprises can achieve.\n\n![Istio DNS](008i3skNly1gxgyfcfm5oj30sg0djmxt.jpg)\n\nIn the early days, Istio distributed the routing information of all services in the mesh to all proxy sidecars, which caused [sidecar](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)s to take up a lot of resources. [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) and [Slime](https:\/\/github.com\/slime-io\/slime) can achieve configuration lazy loading. We will introduce these two open-source projects in the Istio open-source ecosystem.\n\nFinally, there is a problem related to Sidecar proxy operation and maintenance: upgrading all Envoy proxies while ensuring constant traffic. A solution is using the [SidecarSet](https:\/\/xie.infoq.cn\/article\/23ae6d3f0d0260b4797a708a0) resource in the open-source project [OpenKruise](https:\/\/github.com\/openkruise\/kruise).\n\nThe resource consumption and network latency associated with the introduction of Sidecar are also within reasonable limits, as you can see from the [service mesh benchmark performance tests](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/).\n\n### Extending the Istio service mesh\n\nThe next question is about extending the Istio service mesh. The current solution given by the Istio community is to use [WebAssembly](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/), an extension that is still relatively little used in production by now and has performance concerns. Most of the answers I’ve observed are CRDs that build a service mesh management plane based on Istio.\n\nAlso, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is in strong demand for end-users. It allows them to migrate applications from traditional loads to cloud native easily. Finally, hybrid cloud traffic management for multiple clusters and meshes is a more advanced requirement.\n\n### Steep learning curve\n\nMany people complain that Istio has too little learning material. Istio has been open source for four years, and there are a lot of learning resources now:\n\n- [Istio Documentation](https:\/\/istio.io\/)\n- [IstioCon 2021](https:\/\/events.istio.io\/istiocon-2021\/)\n- [Istio Big Talk\/Istio Weekly](https:\/\/github.com\/tetratelabs\/istio-weekly)\n- [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals)\n- [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)\n\nYes, Istio is complex, but it’s been getting more and more manageable with every release. In my next blog, I will introduce you to two open source projects that extend Istio and give you some insight into what’s going on in the Istio community.\n', '\/en\/blog\/the-debate-in-the-community-about-istio-and-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/">Service Mesh - An Integral Part of Cloud-Native Applications</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh - An Integral Part of Cloud-Native Applications', 'This article will explore the relationship between service mesh and cloud native.', '\nIf you don’t know what Istio is, you can read my previous articles below:\n\n- [What Is Istio and Why Does Kubernetes Need it?](https:\/\/www.tetrate.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)\n- [Why do you need Istio when you already have Kubernetes?](https:\/\/www.tetrate.io\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/)\n\nThis article will explore the relationship between service mesh and cloud native.\n\n### Service mesh – the product of the container orchestration war\n\nIf you’ve been following the cloud-native space since its early days, you’ll remember the container orchestration wars of 2015 to 2017. Kubernetes won the container wars in 2017, the idea of microservices had taken hold, and the trend toward containerization was unstoppable. Kubernetes architecture matured and slowly became boring, and service mesh technologies, represented by Linkerd and Istio, entered the CNCF-defined cloud-native critical technologies on the horizon.\n\nKubernetes was designed with the concept of cloud-native in mind. A critical idea in cloud-native is the architectural design of microservices. When a single application is split into microservices, how can microservices be managed to ensure the SLA of the service as the number of services increases? The service mesh was born to solve this problem at the architectural level, free programmers’ creativity, and avoid tedious service discovery, monitoring, distributed tracing, and other matters.\n\nThe service mesh takes the standard functionality of microservices down to the infrastructure layer, allowing developers to focus more on business logic and thus speed up service delivery, which is consistent with the whole idea of cloud-native. You no longer need to integrate bulky SDKs in your application, develop and maintain SDKs for different languages, and just use the service mesh for Day 2 operations after the application is deployed.\n\nThe service mesh is regarded as the next generation of microservices. In the diagram, we can see that many of the concerns of microservices overlap with the functionality of Kubernetes. Kubernetes focuses on the application lifecycle, managing resources and deployments with little control over services. The service mesh fills this gap. The service mesh can connect, control, observe and protect microservices.\n\n### **Kubernetes vs. xDS vs. Istio**\n\nThis diagram shows the layered architecture of Kubernetes and Istio.\n\n![Kubernetes vs xDS vs Istio](008i3skNly1gxgxss9mamj30n90d73zs.jpg)\n\nThe diagram indicates that the kube-proxy settings are global and cannot be controlled at a granular level for each service. All Kubernetes can do is topology-aware routing, routing traffic closer to the Pod, and setting network policies in and out of the Pod.\n\nIn contrast, the service mesh takes traffic control out of the service layer in Kubernetes through sidecar proxies, injects proxies into each Pod, and manipulates these distributed proxies through a control plane. It allows for more excellent resiliency.\n\nKube-proxy implements traffic load balancing between multiple pod instances of a Kubernetes service. But how do you finely control the traffic between these services — such as dividing the traffic by percentage to different application versions (which are all part of the same service, but on other deployments), or doing canary releases and blue-green releases?\n\nThe Kubernetes community gives a way to do canary releases using Deployment, assigning different pods to deployed services by modifying the pod’s label.\n\n![Envoy Architecture](008i3skNly1gxgxsswmoij30sg0kl76r.jpg)\n\nCurrently, the most popular open-source implementation of service mesh in the world is Istio. From the [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), we know that Istio is the most used service mesh in production today. Many companies have built their service mesh based on Istio, such as Ant, Airbnb, eBay, NetEase, Tencent, etc.\n\n![CNCF Survey Report 2020](008i3skNly1gxgxstgg4qj30sg0gg0ts.jpg)\n\nFigure from [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf)\n\nIstio is developed based on Envoy, which has been used by default as its distributed proxy since the first day it was open-sourced. Envoy pioneered the creation of the xDS protocol for distributed gateway configuration, greatly simplifying the configuration of large-scale distributed networks. Ant Group open source MOSN also supported xDS In 2019. Envoy was also one of the first projects to graduate from CNCF, tested by large-scale production applications.\n\n### Service mesh – the cloud-native networking infrastructure\n\nWith the above comparison between Kubernetes and service mesh in mind, we can see the place of service mesh in the cloud-native application architecture. That is, building a cloud-native network infrastructure specifically provides:\n\n- Traffic management: controlling the flow of traffic and API calls between services, making calls more reliable, and enhancing network robustness in different environments.\n- Observability: understanding the dependencies between services and the nature and flow of traffic between them provides the ability to identify problems quickly.\n- Policy enforcement: controlling access policies between services by configuring the mesh rather than by changing the code.\n- Service Identification and Security: providing service identifiability and security protection in the mesh.\n', '\/en\/blog\/service-mesh-an-integral-part-of-cloud-native-apps\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will explore the relationship between service mesh and cloud native.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-4-year-birthday/">Happy Istio 4th Anniversary -- Retrospect and Outlook</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 24, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Happy Istio 4th Anniversary -- Retrospect and Outlook', 'Today is Istio\u0027s 4 year birthday, let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.', '\nIstio was named by [Tetrate](https:\/\/tetrate.io\/) founder Varun Talwar and Google lead engineer Louis Ryan in 2017 and was open sourced on May 24, 2017. Today is the fourth anniversary of Istio’s open source arrival. Let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.\n\n### Istio’s open source history\n\nIn 2017, the year Kubernetes ended the container orchestration battle, Google took the opportunity to consolidate its dominance in the cloud native space and compensate for Kubernetes’ disadvantage in service-to-service traffic management by open-sourcing Istio. Istio released its 1.10 last week — but here are some of the most important releases in Istio’s history to date. \n\n| **Date**          | **Version** | **Note**                                                     |\n| ----------------- | ----------- | ------------------------------------------------------------ |\n| May 24, 2017      | 0.1         | Officially open source; established the architectural foundation of Control Plane, Data Plane and sidecar proxy. |\n| October 10, 2017  | 0.2         | Started to support multiple runtime environments, such as virtual machines. |\n| June 1, 2018      | 0.8         | API refactoring                                              |\n| July 31, 2018     | 1.0         | Production-ready, after which the Istio team underwent a massive reorganization. |\n| March 19, 2019    | 1.1         | Enterprise-ready. Support for multiple Kubernetes clusters, with performance optimizations. |\n| March 3, 2020     | 1.5         | Back to monolith, with microservice components merged into istiod, making Istio’s architecture cleaner and easier to maintain. Support for WebAssembly extension, making Istio’s ecology much stronger. |\n| November 18, 2020 | 1.8         | Officially deprecated Mixer and focused on adding support for virtual machines. |\n\nA year after its inception– and two months before the 1.0 release, version 0.8 was released with a massive refactoring of the API. In late July 2018, when 1.0 was released, Istio reached a production-ready tipping point. Since then, Google has massively reorganized the Istio team and several Istio-based service mesh startups were born, making 2018 the booming year of the service mesh industry.\n\nIstio 1.1 was released in March 2019, almost 9 months after 1.0 was released, which is far beyond the average release cycle of an open-source project. We know that the speed of iteration and evolution is a core competency of basic software. Since then, Istio has started a regular [release cadence](https:\/\/istio.io\/v1.7\/about\/release-cadence\/) of one version per quarter and has become the [#4 fastest growing project in GitHub’s top 10 in 2019](https:\/\/octoverse.github.com\/#fastest-growing-oss-projects-by-contributors)!\n\n### The Istio community\n\nIn 2020, Istio’s project management began to mature and its governance reached a stage of evolution. We saw the first [election](https:\/\/istio.io\/latest\/blog\/2020\/steering-election-results\/) of a steering committee for the Istio community and the transfer of the trademark to [Open Usage Commons](https:\/\/istio.io\/latest\/blog\/2020\/open-usage\/). The first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was successfully held in February 2021, with thousands of people attending the online conference. There is also a [large Istio community in China](https:\/\/www.youtube.com\/watch?v=6m-rhyfy8sg\u0026list=PL7wB27eZmdffS-g_xh7X-b0echc_XZMKV\u0026index=8), and face-to-face Istio community meetups will be held there in 2021. Stay tuned for more.\n\n![](008i3skNly1gquicfqg14j31lw0smwl2.jpg)\n\nAccording to the CNCF 2020 Survey, 46% of organizations were either using a service mesh in production or planning to use it in the next 12 months. Istio was the top used mesh among those using a mesh in production.\n\n### The future\n\nAfter 4 years of development, there is not only a large user base around Istio, but also several Istio vendors, as you can see on the [homepage](https:\/\/istio.io\/) of the recently revamped Istio website. In the last few releases, Istio has shifted its development focus to improving the Day 2 Operation experience. We also expect to see more Istio adoption path recommendations, case studies, learning materials, training, and certifications (such as the industry’s first [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) from Tetrate) that will facilitate the adoption of Istio.\n', '\/en\/blog\/istio-4-year-birthday\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Today is Istio&#39;s 4 year birthday, let’s take a look back at Istio’s four years of development — and look forward to Istio’s future.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-you-should-choose-ngac-as-your-access-control-model/">Why You Should Choose NGAC as Your Access Control Model</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Feb 20, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why You Should Choose NGAC as Your Access Control Model', 'This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.', '\nDifferent companies or software providers have devised countless ways to control user access to functions or resources, such as Discretionary Access Control (DAC), Mandatory Access Control (MAC), Role-Based Access Control (RBAC), and Attribute-Based Access Control (ABAC). In essence, whatever the type of access control model, three basic elements can be abstracted: user, system\/application, and policy.\n\nIn this article, we will introduce ABAC, RBAC, and a new access control model — Next Generation Access Control (NGAC) — and compare the similarities and differences between the three, as well as why you should consider NGAC.\n\n## What Is RBAC?\n\nRBAC, or Role-Based Access Control, takes an approach whereby users are granted (or denied) access to resources based on their role in the organization. Every role is assigned a collection of permissions and restrictions, which is great because you don’t need to keep track of every system user and their attributes. You just need to update appropriate roles, assign roles to users, or remove assignments. But this can be difficult to manage and scale. Enterprises that use the RBAC static role-based model have experienced role explosion: large companies may have tens of thousands of similar but distinct roles or users whose roles change over time, making it difficult to track roles or audit unneeded permissions. RBAC has fixed access rights, with no provision for ephemeral permissions or for considering attributes like location, time, or device. Enterprises using RBAC have had difficulty meeting the complex access control requirements to meet regulatory requirements of other organizational needs.\n\n### RBAC Example\n\nHere’s an example Role in the “default” namespace in Kubernetes that can be used to grant read access to pods:\n\n\u0060\u0060\u0060yaml\napiVersion: rbac.authorization.k8s.io\/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: pod-reader\nrules:\n- apiGroups: [\u0022v1\u0022]\n  resources: [\u0022pods\u0022]\n  verbs: [\u0022get\u0022, \u0022watch\u0022, \u0022list\u0022]\n\u0060\u0060\u0060\n\n## What Is ABAC?\n\nABAC stands for Attribute-Based Access Control. At a high level, [NIST defines](https:\/\/www.nist.gov\/publications\/guide-attribute-based-access-control-abac-definition-and-considerations-1) ABAC as an access control method “where subject requests to perform operations on objects are granted or denied based on assigned attributes of the subject, environment conditions, and a set of policies that are specified in terms of those attributes and conditions.” ABAC is a fine-grained model since you can assign any attributes to the user, but at the same time it becomes a burden and hard to manage:\n\n1. When defining permissions, the relationship between users and objects cannot be visualized.\n2. If the rules are a little complex or confusingly designed, it will be troublesome for the administrator to maintain and trace.\n\nThis can cause performance problems when there is a large number of permissions to process.\n\n### ABAC Example\n\nKubernetes initially uses ABAC as access control and is configured via JSON Lines, for example:\n\nAlice can just read pods in namespace “foo”:\n\n\u0060\u0060\u0060json\n {\u0022apiVersion\u0022: \u0022abac.authorization.kubernetes.io\/v1beta1\u0022, \u0022kind\u0022: \u0022Policy\u0022, \u0022spec\u0022: {\u0022user\u0022: \u0022alice\u0022, \u0022namespace\u0022: \u0022foo\u0022, \u0022resource\u0022: \u0022pods\u0022, \u0022readonly\u0022: true}}\n\u0060\u0060\u0060\n\n## What Is NGAC?\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying users administrative capabilities with a high level of granularity. NGAC was developed by [NIST](https:\/\/www.nist.gov\/) (National Institute of Standards and Technology) and is currently used in [Tetrate Q](https:\/\/www.tetrate.io\/blog\/introducing-tetrate-q\/) and [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/).\n\nThere are several types of entities; they represent the resources you want to protect, the relationships between them, and the actors that interact with the system. The entities are:\n\n1. Users\n2. Objects\n3. User attributes, such as organization unit\n4. Object attributes, such as folders\n5. Policy classes, such as file system access, location, and time\n\nNIST’s David Ferraiolo and [Tetrate](https:\/\/www.tetrate.io\/?utm_content=inline-mention)‘s Ignasi Barrera shared how NGAC works at their [presentation](https:\/\/www.tetrate.io\/blog\/unpacking-next-generation-access-control-ngac-and-tetrate-q\/) on Next Generation Access Control at Service Mesh Day 2019 in San Francisco.\n\nNGAC is based on the assumption that you can represent the system you want to protect in a graph that represents the resources you want to protect and your organizational structure, in a way that has meaning to you and that adheres to your organization semantics. On top of this model that is very particular to your organization, you can overlay policies. Between the resource model and the user model, the permissions are defined. This way NGAC provides an elegant way of representing the resources you want to protect, the different actors in the system, and how both worlds are tied together with permissions.\n\n![NGAC DAG](008eGmZEly1gpb7y6dffaj30ke0ay0ue.jpg)\n\nImage via [Linear Time Algorithms to Restrict Insider Access using Multi-Policy Access Control Systems](https:\/\/tsapps.nist.gov\/publication\/get_pdf.cfm?pub_id=922390)\n\n### NGAC Example\n\nThe following example shows a simple NGAC graph with a User DAG representing an organization structure, an Object DAG representing files and folders in a filesystem, a categorization of the files, and two different policies — file system and scope — that can be combined to make access decisions. The association edges between the two DAGs define the permissions the actors have on the target resources.\n\n![NGAC](008eGmZEly1gpb7y4v7x3j30lx0f7my9.jpg)\n\nIn this graph we can see a representation of two files, “resume” and “contract” in the “\/hr-docs” folder, each linked to a category (“public\/confidential”). There are also two policy classes, “File System” and “Scope,” where the objects in the graph are attached — these need to be satisfied in order to get access to each file.\n\nUser Allice has read and write access to both files in the example, because a path links Allice to each of the files and the paths grant permissions on both policy classes. However, user Bob only has access to the “resume” file, because although there exists a path from Bob to the “contract” file that satisfies the “File System” policy class with “read” permissions, there is no path granting permissions on the “Scope” policy class. So, access to the “contract” file is denied to Bob.\n\n## Why Choose NGAC?\n\nThe need to keep track of attributes of all objects creates a manageability burden in the case of ABAC. RBAC reduces the burden since we extract all access information to roles, but this paradigm suffers from role explosion problems and can also become unmanageable. With NGAC we have everything we need in graphs — in a compact, centralized fashion.\n\nWhen access decisions are complex, processing times of ABAC can rise exponentially. RBAC becomes especially hard to manage at scale, while NGAC scales linearly.\n\nWhere NGAC really shines is in flexibility. It can be configured to allow or disallow access based not only on object attributes, but also on other conditions — time, location, phase of the moon, and so on.\n\nOther key advantages of NGAC include the ability to set policies consistently (to meet compliance requirements) and the ability to set ephemeral policies. For example, NGAC could grant a developer one-time access to resources during an outage, without leaving unnecessary permissions in place that could later lead to a security breach. NGAC can evaluate and combine multiple policies in a single access decision, while keeping its linear time complexity.\n\n## Summary\n\nThe following table compares ABAC, RBAC, and NGAC in several aspects.\n\n![NGAC vs RBAC vs ABAC](008eGmZEly1gpb7y5ehmej30zs0fw76d.jpg)\n\nIn conclusion:\n\n- RBAC is simpler and has good performance, but can suffer at scale.\n- ABAC is flexible, but performance and auditability are a problem.\n- NGAC fixes those gaps by using a novel, elegant revolutionary approach: overlay access policies on top of an existing representation of the world, provided by the user. You can model RBAC and ABAC policies as well.\n\n## References\n\n- [Guide to Attribute-Based Access Control (ABAC) Definition and Considerations](https:\/\/nvlpubs.nist.gov\/nistpubs\/specialpublications\/NIST.SP.800-162.pdf)\n- Deploying ABAC policies using RBAC Systems\n- [RBAC vs. ABAC: What’s the Difference?](https:\/\/www.comparitech.com\/net-admin\/rbac-vs-abac\/)\n- [Role Explosion: The Unintended Consequence of RBAC](https:\/\/www.linkedin.com\/pulse\/role-explosion-unintended-consequence-rbac-oren-ohayon-harel\/)\n- [Exploring the Next Generation of Access Control Methodologies](https:\/\/www.nist.gov\/publications\/exploring-next-generation-access-control-methodologies)', '\/en\/blog\/why-you-should-choose-ngac-as-your-access-control-model\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will introduce you to the next generation permission control model, NGAC, and compare ABAC, RABC, and explain why you should choose NGAC.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-vm-odysssey/">Istio 1.8: A Virtual Machine Integration Odyssey</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 23, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio 1.8: A Virtual Machine Integration Odyssey', 'In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.', '\nIn this article, I’ll give you an overview of [Istio](https:\/\/istio.io\/)‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.\n\nI will show you a tumultuous odyssey of Istio’s virtual machine integration. Tetrate, the enterprise service mesh company that made pushing Istio to run everywhere part of its founding mission, has used VM features extensively in customer deployments and has been instrumental in pushing VMs to Istio upstream.\n\n## Preface\n\nIn my [previous article](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/), I talked about how Istio 1.7 supported virtual machines. But at that time, late October, virtual machines were still not seamlessly integrated into Istio — there was still a lot of manual work required. Now, Istio 1.8 has added WorkloadGroup and smart DNS proxy, which allows non-Kubernetes workloads like VMs to become first-class citizens in Istio — just like pods.\n\nWith or without a sidecar installed for virtual machines, until 1.7 you could not resolve the DNS name of a Kubernetes service unless a kube-external DNS was configured — which is the last piece of virtual machine integration in Istio. This shortcoming has finally been fixed in Istio 1.8.\n\n## Why Is Virtual Machine Support Important?\n\nIn the process of migrating our applications to cloud native architectures and continuously containerizing them, we will go through three phases as shown in the figure below.\n\n![Cloud Native Stages](0081Kckwly1gm0d6t775lj31s80k8go8.jpg)\n\n- Stage 1: All applications are deployed on virtual machines\n- Stage 2: Applications are deployed on both virtual machines and containers, are migrating from virtual machines to containers, and are using Kubernetes to manage containers.\n- Stage 3: All applications are deployed in containers first, using Kubernetes to manage containers and Istio to manage service-to-service communication.\n\nThe above diagram is artificially simplified: in reality, there might be multiple hybrid clouds, multiple regions, multiple clusters, etc. Plus, at stage 3 containers and virtual machines may remain in long-term coexistence, but the trend of containerization remains unchanged.\n\n## Istio’s History of Virtual Machine Support\n\nIstio’s support for virtual machines is a long process, an odyssey of sorts.\n\n### 0.2: Istio Mesh Expansion\n\nAs of version 0.2, Istio added virtual machines to the Mesh via [Istio Mesh Expansion](https:\/\/istio.io\/v0.2\/docs\/setup\/kubernetes\/mesh-expansion.html), provided that the following prerequisites were met.\n\n- Virtual machines must have direct access to the application’s pods via IP address, which requires a flat network between the container and the VM via VPC or VPN; and virtual machines do not need access to the Cluster IP, but rather direct access to the service’s endpoints.\n- Virtual machines must have access to Istio’s control plane services (Pilot, Mixer, CA, now being integrated as Istiod), which can expose the control plane endpoints to virtual machines by deploying load balancers in the Istio Mesh.\n- (optional) the virtual machine has access to the DNS server inside the Mesh (deployed in Kubernetes).\n\nThe steps to integrate a virtual machine are as follows.\n\n1. Create an internal load balancer for the Istio control plane service and the DNS service for the Kubernetes cluster.\n2. Generate a configuration file for the Istio Service CIDR, Service Account token, security certificate, and IP of the Istio Control Plane Service (the IP exposed through the Internal Load Balancer) and send it to the virtual machine.\n3. Setup the Istio component, dnsmaq (for DNS discovery), in the virtual machine; so that the virtual machine can access the services in the mesh using FQDN, to ensure that the virtual machine can correctly resolve the Cluster IP of the services in the mesh.\n4. To run the service in a virtual machine, you need to configure the sidecar, add inbound ports to be intercepted, then restart Istio and also run istioctl to register the service.\n\nThe following figure shows the detailed flow from integrating a virtual machine to accessing services in the virtual machine in a mesh.\n\n![Figure 1](0081Kckwly1gm0d6rogojj30u00yhdil.jpg)\n\nFigure 1\n\n1. The DNS is hijacked by dnsmasq deployed in the virtual machine, which allows it to correctly obtain the Cluster IP of the Istio service (Kubernetes’ built-in DNS).\n2. Access to Kubernetes’ built-in DNS service (which is exposed outside the cluster via the Internal Load Balancer and can be accessed directly).\n3. Return the Cluster IP resolved by \u0060productpage.bookinfo.svc.cluster.local\u0060, noting that the IP address is not directly accessible, but failure to be DNS resolved will result in a failed VM request for the service.\n4. The virtual machine’s call to services in a mesh is hijacked by the sidecar proxy.\n5. Since the proxy is connected to the Istio control plane, the endpoints of the service can be queried via xDS, so traffic will be forwarded to one of the endpoints.\n6. To access VM services in mesh, you need to manually add VM services to mesh using the istioctl register command, which essentially registers the VM services to the service and endpoint in Kubernetes.\n7. Services in the mesh can be accessed using the VM-registered service name (FQDN, e.g. \u0060mysql.vm.svc.cluster.local\u0060).\n\nThe above Istio support for virtual machines continued with Istio 1.0, which introduced a new API [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/) with Istio 1.1, that allows additional entries to be added to Istio’s internal service registry so that services in the mesh can access\/route to these manually specified services. The istioctl register command is no longer needed and will be deprecated in Istio 1.9.\n\nThe istioctl experimental add-to-mesh command has been added to Istio 1.5 to add services from a virtual machine to a mesh, and it works just like the istioctl register.\n\n### 1.6 to 1.7: New Resource Abstractions\n\nIstio introduced a new resource type, [WorkloadEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-entry\/), in traffic management from [version 1.6](https:\/\/istio.io\/latest\/news\/releases\/1.6.x\/announcing-1.6\/), to abstract virtual machines so that they can be added to the mesh as equivalent loads to the pods in Kubernetes; with traffic management, security management, observability, etc. The mesh configuration process for virtual machines is simplified with WorkloadEntry, which selects multiple workload entries and Kubernetes pods based on the label selector specified in the service entry.\n\nIstio 1.8 adds a resource object for [WorkloadGroup](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/workload-group\/) that provides a specification that can include both virtual machines and Kubernetes workloads, designed to mimic the existing sidecar injection and deployment specification model for Kubernetes workloads to bootstrap Istio agents on the VMs.\n\nBelow is a comparison of resource abstraction levels for virtual machines versus workloads in Kubernetes.\n\n| **Item**                           | **Kubernetes** | **Virtual Machine** |\n| ---------------------------------- | -------------- | ------------------- |\n| **Basic schedule unit**            | Pod            | WorkloadEntry       |\n| **Component**                      | Deployment     | WorkloadGroup       |\n| **Service register and discovery** | Service        | ServiceEntry        |\n\nFrom the above diagram, we can see that for virtual machine workloads there is a one-to-one correspondence with the workloads in Kubernetes.\n\nEverything seems perfect at this point. However, exposing the DNS server in the Kubernetes cluster directly is a big [security risk](https:\/\/blog.aquasec.com\/dns-spoofing-kubernetes-clusters), so we usually manually write the domain name and Cluster IP pair of the service the virtual machine needs to access to the local \/etc\/hosts — but this is not practical for a distributed cluster with a large number of nodes.\n\nThe process of accessing the services inside mesh by configuring the local \/etc\/hosts of the virtual machine is shown in the following figure.\n\n![Figure 2](0081Kckwly1gm0d6qx2o0j30sq0v440v.jpg)\n\nFigure 2\n\n1. Registration of services in the virtual machine into the mesh.\n2. Manually write the domain name and Cluster IP pairs of the service to be accessed to the local \/etc\/hosts file in the virtual machine.\n3. Cluster IP where the virtual machine gets access to the service.\n4. The traffic is intercepted by the sidecar proxy and the endpoint address of the service to be accessed is resolved by Envoy.\n5. Access to designated endpoints of the service.\n\nIn Kubernetes, we generally use the Service object for service registration and discovery; each service has a separate DNS name that allows applications to call each other by using the service name. We can use ServiceEntry to register a service in a virtual machine into Istio’s service registry, but a virtual machine cannot access a DNS server in a Kubernetes cluster to get the Cluster IP if the DNS server is not exposed externally to the mesh, which causes the virtual machine to fail to access the services in the mesh. Wouldn’t the problem be solved if we could add a sidecar to the virtual machine that would transparently intercept DNS requests and get the Cluster IP of all services in the mesh, similar to the role of dnsmasq in Figure 1?\n\n### As of Istio 1.8 — Smart DNS Proxy\n\nWith the introduction of smart [DNS proxy](https:\/\/cloudnative.to\/blog\/istio-dns-proxy\/) in Istio 1.8, virtual machines can access services within the mesh without the need to configure \/etc\/hosts, as shown in the following figure.\n\n![Figure 3](0081Kckwly1gm0d6sgfpxj30oi0rsjt5.jpg)\n\nFigure 3\n\nThe Istio agent on the sidecar will come with a cached DNS proxy dynamically programmed by Istiod. DNS queries from the application are transparently intercepted and served by the Istio proxy in the pod or VM, with the response to DNS query requests, enabling seamless access from the virtual machine to the service mesh.\n\nThe WorkloadGroup and smart DNS proxy introduced in Istio 1.8 provide powerful support for virtual machine workloads, making legacy applications deployed in virtual machines fully equivalent to pods in Kubernetes.\n\n## Summary\n\nIn this odyssey of Istio’s virtual machine support, we can see the gradual realization of unified management of virtual machines and pods — starting with exposing the DNS server in the mesh and setting up dnsmasq in the virtual machine, and ending with using smart DNS proxies and abstracting resources such as \u0060WorkloadEntry\u0060, \u0060WorkloadGroup\u0060 and \u0060ServiceEntry\u0060. This article only focuses on the single cluster situation, which is not enough to be used in real production. We also need to deal with security, multicluster, multitenancy, etc.\n\n## Referenced resources\n\n- [Tetrate Service Bridge — Across all compute bridging Kubernetes clusters, VMs, and bare metal](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)\n- [Expanding into New Frontiers — Smart DNS Proxying in Istio](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Virtual Machine Installation — Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/virtual-machine\/)\n- [How to Integrate Virtual Machines into Istio Service Mesh](https:\/\/thenewstack.io\/how-to-integrate-virtual-machines-into-istio-service-mesh\/)\n', '\/en\/blog\/istio-vm-odysssey\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll give you an overview of Istio‘s history of virtual machine integration support. In particular, the introduction of the smart DNS proxy and WorkloadGroup in Istio 1.8, which makes virtual machines and containers equivalent at the resource abstraction level.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-a-service-mesh/">What Is a Service Mesh?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 22, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What Is a Service Mesh?', 'This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.', '\nA service mesh is a relatively simple concept, consisting of a bunch of network proxies paired with each service in an application, plus a set of task management processes. The proxies are called the data plane and the management processes are called the control plane in the Service Mesh. The data plane intercepts calls between different services and “processes” them; the control plane is the brain of the mesh that coordinates the behavior of proxies and provides APIs for operations and maintenance personnel to manipulate and observe the entire network.\n\nThe diagram below shows the architecture of a service mesh.\n\n![Service Mesh Architecture](service-mesh-architecture.png)\n\nFurther, the service mesh is a dedicated infrastructure layer designed to enable reliable, fast, and secure inter-service invocation in microservices architectures. It is not a mesh of “services” but rather a mesh of “proxies” that services can plug into, thus abstracting the network from the application code. In a typical service mesh, these proxies are injected into each service deployment as a sidecar (and also may be deployed at the edge of the mesh). Instead of invoking services directly over the network, services invoke their local sidecar proxy, which in turn manages requests on behalf of the service, pushing the complexities of inter-service communications into a networking layer that can resolve them at scale. The set of interconnected sidecar proxies implements a so-called data plane, while on the other hand the service mesh control plane is used to configure proxies. The infrastructure introduced by a service mesh provides an opportunity, too, to collect metrics about the traffic that is flowing through the application.\n\n## The architecture of a service mesh\n\nThe infrastructure layer of a service mesh is divided into two main parts: the control plane and the data plane.\n\n**Characteristics of the control plane**\n\n- Do not parse packets directly.\n- Communicates with proxies in the control plane to issue policies and configurations.\n- Visualizes network behavior.\n- Typically provides APIs or command-line tools for configuration versioning and management for continuous integration and deployment.\n\n**Characteristics of the data plane**\n\n- Is usually designed with the goal of statelessness (though in practice some data needs to be cached to improve traffic forwarding performance).\n- Directly handles inbound and outbound packets, forwarding, routing, health checking, load balancing, authentication, authentication, generating monitoring data, etc.\n- Is transparent to the application, i.e., can be deployed senselessly.\n\n## Changes brought by the service mesh\n\n**Decoupling of microservice governance from business logic**\n\nA service mesh takes most of the capabilities in the SDK out of the application, disassembles them into separate processes, and deploys them in a sidecar model. By separating service communication and related control functions from the business process and synching them to the infrastructure layer, a service mesh **mostly** decouples them from the business logic, allowing application developers to focus more on the business itself.\n\nNote that the word “mostly” is mentioned here and that the SDK often needs to retain protocol coding and decoding logic, or even a lightweight SDK to implement fine-grained governance and monitoring policies in some scenarios. For example, to implement method-level call distributed tracing, the service mesh requires the business application to implement trace ID passing, and this part of the implementation logic can also be implemented through a lightweight SDK. Therefore, the service mesh is not zero-intrusive from a code level.\n\n**Unified governance of heterogeneous environments**\n\nWith the development of new technologies and staff turnover, there are often applications and services in different languages and frameworks in the same company, and in order to control these services uniformly, the previous practice was to develop a complete set of SDKs for each language and framework, which is very costly to maintain. With a service mesh, multilingual support is much easier by synching the main service governance capabilities to the infrastructure. By providing a very lightweight SDK, and in many cases, not even a separate SDK, it is easy to achieve unified traffic control and monitoring requirements for multiple languages and protocols.\n\n## Features of service mesh\n\nService mesh also has three major technical advantages over traditional microservice frameworks.\n\n**Observability**\n\nBecause the service mesh is a dedicated infrastructure layer through which all inter-service communication passes, it is uniquely positioned in the technology stack to provide uniform telemetry at the service invocation level. This means that all services are monitored as “black boxes.” The service mesh captures route data such as source, destination, protocol, URL, status codes, latency, duration, etc. This is essentially the same data that web server logs can provide, but the service mesh captures this data for all services, not just the web layer of individual services. It is important to note that collecting data is only part of the solution to the observability problem in microservice applications. Storing and analyzing this data needs to be complemented by mechanisms for additional capabilities, which then act as alerts or automatic instance scaling, for example.\n\n**Traffic control**\n\nWith a service mesh, services can be provided with various control capabilities such as intelligent routing (blue-green deployment, canary release, A\/B test), timeout retries, circuit breaking, fault injection, traffic mirroring, etc. These are often features that are not available in traditional microservices frameworks but are critical to the system. For example, the service mesh carries the communication traffic between microservices, so it is possible to test the robustness of the whole application by simulating the failure of some microservices through rules for fault injection in the grid. Since the service mesh is designed to efficiently connect source request calls to their optimal destination service instances, these traffic control features are “destination-oriented.” This is a key feature of the service mesh’s traffic control capabilities.\n\n**Security**\n\nTo some extent, monolithic applications are protected by their single address space. However, once a monolithic application is broken down into multiple microservices, the network becomes a significant attack surface. More services mean more network traffic, which means more opportunities for hackers to attack the information flow. And service mesh provides the capabilities and infrastructure to protect network calls. The security-related benefits of service mesh are in three core areas: authentication of services, encryption of inter-service communications, and enforcement of security-related policies.\n\nService mesh has brought about tremendous change and has strong technical advantages, and has been called the second generation of “microservice architecture.” However, there is no silver bullet in software development. Traditional microservices architecture has many pain points, and service mesh is no exception. It has its limitations.\n\n**Increased complexity**\n\nService mesh introduces sidecar proxies and other components into an already complex, distributed environment, which can greatly increase the overall chain and operational O\u0026M complexity. Ops needs to be more specialized. Adding a service mesh such as Istio to a container orchestrator such as Kubernetes often requires Ops to become an expert in both technologies in order to fully utilize the capabilities of both and to troubleshoot the problems encountered in the environment.\n\n**Latency**\n\nAt the link level, a service mesh is an invasive, complex technology that can add significant latency to system calls. This latency is on the millisecond level, but it can also be intolerable in special business scenarios.\n\n**Platform adaptation**\n\nThe intrusive nature of service mesh forces developers and operators to adapt to highly autonomous platforms and adhere to the platform’s rules.\n\n## The relationship between service mesh and Kubernetes\n\nKubernetes is essentially application lifecycle management, specifically the deployment and management (scaling, auto-recovery, publishing) of containerized applications. Service mesh decouples traffic management from Kubernetes, eliminating the need for a kube-proxy component for internal traffic, and manages inter-service and ingress traffic, security, and observability through an abstraction closer to the microservice application layer. The xDS used by Istio and Envoy is one of the protocol standards for service mesh configuration. \n\nOrganizations that use Kubernetes often turn to a service mesh to address the networking issues that arise with containerization — but notably, a service mesh can work with a legacy or a modern workload, and can be put in place prior to containerization for a faster, safer path to modernization.\n\n## Summary\n\nReaders should look dialectically at the advantages and disadvantages of a service mesh compared with traditional microservices architecture. A service mesh can be a critical part of the evolutionary path of application architecture, from the earliest monolith to distributed, to microservices, containerization, container orchestration, to hybrid workloads and multi-cloud. \n\nLooking ahead, Kubernetes is exploding, and it has become the container orchestration of choice for enterprise greenfield applications. If Kubernetes has completely won the market and the size and complexity of Kubernetes-based applications continue to grow, there will be a tipping point, and service mesh will be necessary to effectively manage these applications. As service mesh technology continues to evolve and the architecture and functionality of its implementation products, such as Istio, continue to be optimized, service mesh will completely replace traditional microservice architectures as the architecture of choice for microservices and transformation to the cloud for enterprises.\n\nThis article was co-authored by Guangming Luo, a member of the ServiceMesher community and the CNC steering community.\n', '\/en\/blog\/what-is-a-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will take you through what a service mesh is, as well as its architecture, features, and advantages and disadvantages.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/categories/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/categories/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/categories/service-mesh/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/categories/service-mesh/page/2/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(46)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-tracing/">How the Envoy Proxy Handles User Requests for Tracing</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
