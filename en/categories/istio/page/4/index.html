<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Istio Column - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Welcome to the Istio Column, your comprehensive resource for all things related to the Istio service mesh. I cover a wide range of topics from introductory to advanced usage, including service discovery, load balancing, traffic management, policy enforcement, and observability. Whether you are a beginner or an experienced user, you will find valuable content here. ">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/categories/istio/" />
  <meta property="og:title" content="Istio Column | Jimmy Song" />
  <meta property="twitter:title" content="Istio Column | Jimmy Song" />

  
  <meta property="og:description" content="Welcome to the Istio Column, your comprehensive resource for all things related to the Istio service mesh. I cover a wide range of topics from introductory to advanced usage, including service discovery, load balancing, traffic management, policy enforcement, and observability. Whether you are a beginner or an experienced user, you will find valuable content here. " />
  <meta property="twitter:description" content="Welcome to the Istio Column, your comprehensive resource for all things related to the Istio service mesh. I cover a wide range of topics from introductory to advanced usage, including service discovery, load balancing, traffic management, policy enforcement, and observability. Whether you are a beginner or an experienced user, you will find valuable content here. " />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/book">Book</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/categories/istio/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio Column
                </p>
                <p class="page-description">
                    Welcome to the Istio Column, your comprehensive resource for all things related to the Istio service mesh. I cover a wide range of topics from introductory to advanced usage, including service discovery, load balancing, traffic management, policy enforcement, and observability. Whether you are a beginner or an experienced user, you will find valuable content here.
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/sidecar-injection-iptables-and-traffic-routing/">Understanding the Sidecar Injection, Traffic Intercepting &amp; Routing Process in Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding the Sidecar Injection, Traffic Intercepting \u0026 Routing Process in Istio', 'Learn the sidecar pattern, transparent traffic intercepting and routing in Istio.', '\nBased on Istio version 1.13, this article will present the following.\n\n- What is the sidecar pattern and what advantages does it have?\n- How are the sidecar injections done in Istio?\n- How does the sidecar proxy do transparent traffic intercepting?\n- How is the traffic routed to upstream?\n\nThe figure below shows how the \u0060productpage\u0060 service requests access to \u0060http:\/\/reviews.default.svc.cluster.local:9080\/\u0060 and how the sidecar proxy inside the reviews service does traffic blocking and routing forwarding when traffic goes inside the \u0060reviews\u0060 service.\n\n![Istio transparent traffic intercepting and traffic routing diagram](istio-iptables.svg)\n\nAt the beginning of the first step, the sidecar in the \u0060productpage\u0060 pod has selected a pod of the reviews service to be requested via EDS, knows its IP address, and sends a TCP connection request.\n\nThere are three versions of the reviews service, each with an instance, and the sidecar work steps in the three versions are similar, as illustrated below only by the sidecar traffic forwarding step in one of the Pods.\n\n## Sidecar pattern\n\nDividing the functionality of an application into separate processes running in the same minimal scheduling unit (e.g. Pod in Kubernetes) can be considered sidecar mode. As shown in the figure below, the sidecar pattern allows you to add more features next to your application without additional third-party component configuration or modifications to the application code.\n\n![Sidecar pattern](sidecar-pattern.svg)\n\nThe Sidecar application is loosely coupled to the main application. It can shield the differences between different programming languages and unify the functions of microservices such as observability, monitoring, logging, configuration, circuit breaker, etc.\n\n### Advantages of using the Sidecar pattern\n\nWhen deploying a service mesh using the sidecar model, there is no need to run an agent on the node, but multiple copies of the same sidecar will run in the cluster. In the sidecar deployment model, a companion container (such as Envoy or MOSN) is deployed next to each application\u0027s container, which is called a sidecar container. The sidecar takes overall traffic in and out of the application container. In Kubernetes\u0027 Pod, a sidecar container is injected next to the original application container, and the two containers share storage, networking, and other resources.\n\nDue to its unique deployment architecture, the sidecar model offers the following advantages.\n\n- Abstracting functions unrelated to application business logic into a common infrastructure reduces the complexity of microservice code.\n- Reduce code duplication in microservices architectures because it is no longer necessary to write the same third-party component profiles and code.\n- The sidecar can be independently upgraded to reduce the coupling of application code to the underlying platform.\n\n## iptables manipulation analysis\n\nIn order to view the iptables configuration, we need to \u0060nsente\u0060r the sidecar container using the root user to view it, because \u0060kubectl\u0060 cannot use privileged mode to remotely manipulate the docker container, so we need to log on to the host where the \u0060productpage\u0060 pod is located.\n\nIf you use Kubernetes deployed by minikube, you can log directly into the minikube\u0027s virtual machine and switch to root. View the iptables configuration that lists all the rules for the NAT (Network Address Translation) table because the mode for redirecting inbound traffic to the sidecar is \u0060REDIRECT\u0060 in the parameters passed to the \u0060istio-iptables\u0060 when the Init container is selected for the startup, so there will only be NAT table specifications in the iptables and mangle table configurations if TPROXY is selected. See the iptables command for detailed usage.\n\nWe only look at the iptables rules related to \u0060productpage\u0060 below.\n\n\u0060\u0060\u0060bash\n# login to minikube, change user to root\n$ minikube ssh\n$ sudo -i\n\n# See the processes in the productpage pod\u0027s istio-proxy container\n$ docker top \u0060docker ps|grep \u0022istio-proxy_productpage\u0022|cut -d \u0022 \u0022 -f1\u0060\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\n1337                10576               10517               0                   08:09               ?                   00:00:07            \/usr\/local\/bin\/pilot-agent proxy sidecar --domain default.svc.cluster.local --configPath \/etc\/istio\/proxy --binaryPath \/usr\/local\/bin\/envoy --serviceCluster productpage.default --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istiod.istio-system.svc:15012 --zipkinAddress zipkin.istio-system:9411 --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --dnsRefreshRate 300s --statusPort 15020 --trust-domain=cluster.local --controlPlaneBootstrap=false\n1337                10660               10576               0                   08:09               ?                   00:00:33            \/usr\/local\/bin\/envoy -c \/etc\/istio\/proxy\/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --parent-shutdown-time-s 60 --service-cluster productpage.default --service-node sidecar~172.17.0.16~productpage-v1-7f44c4d57c-ksf9b.default~default.svc.cluster.local --max-obj-name-len 189 --local-address-ip-version v4 --log-format [Envoy (Epoch 0)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2\n\n# Enter the nsenter into the namespace of the sidecar container (any of the above is ok)\n$ nsenter -n --target 10660\n\u0060\u0060\u0060\n\nView the process\u0027s iptables rule chain under its namespace.\n\n\u0060\u0060\u0060bash\n# View the details of the rule configuration in the NAT table.\n$ iptables -t nat -L -v\n# PREROUTING chain: Used for Destination Address Translation (DNAT) to jump all incoming TCP traffic to the ISTIO_INBOUND chain.\nChain PREROUTING (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n 2701  162K ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere\n\n# INPUT chain: Processes incoming packets and non-TCP traffic will continue on the OUTPUT chain.\nChain INPUT (policy ACCEPT 2701 packets, 162K bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# OUTPUT chain: jumps all outbound packets to the ISTIO_OUTPUT chain.\nChain OUTPUT (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n   15   900 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere\n\n# POSTROUTING CHAIN: All packets must first enter the POSTROUTING chain when they leave the network card, and the kernel determines whether they need to be forwarded out according to the packet destination.\nChain POSTROUTING (policy ACCEPT 79 packets, 6761 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\n# ISTIO_INBOUND CHAIN: Redirects all inbound traffic to the ISTIO_IN_REDIRECT chain, except for traffic destined for ports 15090 (used by Prometheus) and 15020 (used by Ingress gateway for Pilot health checks), and traffic sent to these two ports will return to the call point of the iptables rule chain, the successor POSTROUTING to the INPUT chain.\nChain ISTIO_INBOUND (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh\n    2   120 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090\n 2699  162K RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020\n    0     0 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere\n\n# ISTIO_IN_REDIRECT chain: jumps all inbound traffic to the local 15006 port, thus successfully blocking traffic to the sidecar.\nChain ISTIO_IN_REDIRECT (3 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006\n\n# ISTIO_OUTPUT chain: see the details bellow\nChain ISTIO_OUTPUT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 RETURN     all  --  any    lo      127.0.0.6            anywhere\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337\n   15   900 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337\n    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337\n    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337\n    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337\n    0     0 RETURN     all  --  any    any     anywhere             localhost\n    0     0 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere\n\n# ISTIO_REDIRECT chain: redirects all traffic to Sidecar (i.e. local) port 15001.\nChain ISTIO_REDIRECT (1 references)\n pkts bytes target     prot opt in     out     source               destination\n    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001\n\u0060\u0060\u0060\n\nThe focus here is on the 9 rules in the \u0060ISTIO_OUTPUT\u0060 chain. For ease of reading, I will show some of the above rules in the form of a table as follows.\n\n| **Rule** | **target**        | **in** | **out** | **source** | **destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n\nThe following diagram shows the detailed flow of the \u0060ISTIO_ROUTE\u0060 rule.\n\n![ISTIO_ROUTE iptables rules](istio-route-iptables.svg)\n\nI will explain the purpose of each rule, corresponding to the steps and details in the illustration at the beginning of the article, in the order in which they appear. Where rules 5, 6, and 7 are extensions of the application of rules 2, 3, and 4 respectively (from UID to GID), which serve similar purposes and will be explained together. Note that the rules therein are executed in order, meaning that the rule with the next highest order will be used as the default. When the outbound NIC (out) is lo (local loopback address, loopback interface), it means that the destination of the traffic is the local Pod, and traffic sent from the Pod to the outside, will not go through this interface. Only rules 4, 7, 8, and 9 apply to all outbound traffic from the review Pod.\n\n**Rule 1**\n\n- Purpose: To pass through traffic sent by the Envoy proxy to the local application container, so that it bypasses the Envoy proxy and goes directly to the application container.\n- Corresponds to steps 6 through 7 in the illustration.\n- Details: This rule causes all requests from 127.0.0.6 (this IP address will be explained below) to jump out of the chain, return to the point of invocation of iptables (i.e. OUTPUT) and continue with the rest of the routing rules, i.e. the \u0060POSTROUTING\u0060 rule, which sends traffic to an arbitrary destination, such as the application container within the local Pod. Without this rule, traffic from the Envoy proxy within the Pod to the Pod container will execute the next rule, rule 2, and the traffic will enter the Inbound Handler again, creating a dead loop. Putting this rule in the first place can avoid the problem of traffic dead-ending in the Inbound Handler.\n\n**Rule 2, 5**\n\n- Purpose: Handle inbound traffic (traffic inside the Pod) from the Envoy proxy, but not requests to the localhost, and forward it to the Envoy proxy\u0027s Inbound Handler via a subsequent rule. This rule applies to scenarios where the Pod invokes its own IP address, i.e., traffic between services within the Pod.\n- Details: If the destination of the traffic is not localhost and the packet is sent by 1337 UID (i.e. istio-proxy user, Envoy proxy), the traffic will be forwarded to Envoy\u0027s Inbound Handler through \u0060ISTIO_IN_REDIRECT\u0060 eventually.\n\n**Rule 3, 6**\n\n- Purpose: To pass through the internal traffic of the application container within the Pod. This rule applies to traffic within the container. For example, access to Pod IP or localhost within a Pod.\n- Corresponds to steps 6 through 7 in the illustration.\n- Details: If the traffic is not sent by an Envoy user, then jump out of the chain and return to \u0060OUTPUT\u0060 to call \u0060POSTROUTING\u0060 and go straight to the destination.\n\n**Rule 4, 7**\n\n- Purpose: To pass through outbound requests sent by Envoy proxy.\n- Corresponds to steps 14 through 15 in the illustration.\n- Details: If the request was made by the Envoy proxy, return \u0060OUTPUT\u0060 to continue invoking the \u0060POSTROUTING\u0060 rule and eventually access the destination directly.\n\n**Rule 8**\n\n- Purpose: Passes requests from within the Pod to the localhost.\n- Details: If the destination of the request is localhost, return \u0060OUTPUT\u0060 and call \u0060POSTROUTING\u0060 to access localhost directly.\n\n**Rule 9**\n\n- Purpose: All other traffic will be forwarded to \u0060ISTIO_REDIRECT\u0060 after finally reaching the Outbound Handler of Envoy proxy.\n- Corresponds to steps 10 through 11 in the illustration.\n\nThe above rule avoids dead loops in the iptables rules for Envoy proxy to application routing, and guarantees that traffic can be routed correctly to the Envoy proxy, and that real outbound requests can be made.\n\n**About RETURN target**\n\nYou may notice that there are many \u0060RETURN\u0060 targets in the above rules, which means that when this rule is specified, it jumps out of the rule chain, returns to the call point of iptables (in our case \u0060OUTPUT\u0060) and continues to execute the rest of the routing rules, in our case the \u0060POSTROUTING\u0060 rule, which sends traffic to any destination address, you can think of This is intuitively understood as pass-through.\n\n**About the 127.0.0.6 IP address**\n\nThe IP 127.0.0.6 is the default \u0060InboundPassthroughClusterIpv4\u0060 in Istio and is specified in the code of Istio. This is the IP address to which traffic is bound after entering the Envoy proxy, and serves to allow Outbound traffic to be re-sent to the application container in the Pod, i.e. Passthought, bypassing the Outbound Handler. this traffic is access to the Pod itself, and not real outbound traffic. See Istio [Issue-29603](https:\/\/github.com\/istio\/istio\/issues\/29603) for more information on why this IP was chosen as the traffic passthrough.\n\n## The traffic routing process explained\n\nTraffic routing is divided into two processes, Inbound and Outbound, which will be analyzed in detail for the reader below based on the example above and the configuration of the sidecar.\n\n### Understand Inbound Handler\n\nThe role of the Inbound handler is to pass traffic from the downstream blocked by iptables to the localhost and establish a connection to the application container within the Pod. Assuming the name of one of the Pods is \u0060reviews-v1-545db77b95-jkgv2\u0060, run \u0060istioctl proxy-config listener reviews-v1-545db77b95-jkgv2 --port 15006\u0060 to see which Listener is in that Pod.\n\n\u0060\u0060\u0060ini\nADDRESS PORT  MATCH                                                                                           DESTINATION\n0.0.0.0 15006 Addr: *:15006                                                                                   Non-HTTP\/Non-TCP\n0.0.0.0 15006 Trans: tls; App: istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: 0.0.0.0\/0                        InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; App: http\/1.1,h2c; Addr: 0.0.0.0\/0                                           InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: TCP TLS; Addr: 0.0.0.0\/0                                                       InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: raw_buffer; Addr: 0.0.0.0\/0                                                              InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; Addr: 0.0.0.0\/0                                                                     InboundPassthroughClusterIpv4\n0.0.0.0 15006 Trans: tls; App: istio,istio-peer-exchange,istio-http\/1.0,istio-http\/1.1,istio-h2; Addr: *:9080 Cluster: inbound|9080||\n0.0.0.0 15006 Trans: raw_buffer; Addr: *:9080                                                                 Cluster: inbound|9080||\n\u0060\u0060\u0060\n\nThe following lists the meanings of the fields in the above output.\n\n- ADDRESS: downstream address\n- PORT: The port the Envoy listener is listening on\n- MATCH: The transport protocol used by the request or the matching downstream address\n- DESTINATION: Route destination\n\nThe Iptables in the reviews Pod intercept inbound traffic to port 15006, and from the above output we can see that Envoy\u0027s Inbound Handler is listening on port 15006, and requests to port 9080 destined for any IP will be routed to the \u0060inbound|9080||\u0060 Cluster.\n\nAs you can see in the last two rows of the Pod\u0027s Listener list, the Listener for \u00600.0.0.0:15006\/TCP\u0060 (whose actual name is \u0060virtualInbound\u0060) listens for all Inbound traffic, which contains matching rules, and traffic to port 9080 from any IP will be routed. If you want to see the detailed configuration of this Listener in Json format, you can execute the \u0060istioctl proxy-config listeners reviews-v1-545db77b95-jkgv2 --port 15006 -o json\u0060 command. You will get an output similar to the following.\n\n\u0060\u0060\u0060json\n[\n    \/*omit*\/\n    {\n        \u0022name\u0022: \u0022virtualInbound\u0022,\n        \u0022address\u0022: {\n            \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u00220.0.0.0\u0022,\n                \u0022portValue\u0022: 15006\n            }\n        },\n        \u0022filterChains\u0022: [\n            \/*omit*\/\n            {\n                \u0022filterChainMatch\u0022: {\n                    \u0022destinationPort\u0022: 9080,\n                    \u0022transportProtocol\u0022: \u0022tls\u0022,\n                    \u0022applicationProtocols\u0022: [\n                        \u0022istio\u0022,\n                        \u0022istio-peer-exchange\u0022,\n                        \u0022istio-http\/1.0\u0022,\n                        \u0022istio-http\/1.1\u0022,\n                        \u0022istio-h2\u0022\n                    ]\n                },\n                \u0022filters\u0022: [\n                    \/*omit*\/\n                    {\n                        \u0022name\u0022: \u0022envoy.filters.network.http_connection_manager\u0022,\n                        \u0022typedConfig\u0022: {\n                            \u0022@type\u0022: \u0022type.googleapis.com\/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\u0022,\n                            \u0022statPrefix\u0022: \u0022inbound_0.0.0.0_9080\u0022,\n                            \u0022routeConfig\u0022: {\n                                \u0022name\u0022: \u0022inbound|9080||\u0022,\n                                \u0022virtualHosts\u0022: [\n                                    {\n                                        \u0022name\u0022: \u0022inbound|http|9080\u0022,\n                                        \u0022domains\u0022: [\n                                            \u0022*\u0022\n                                        ],\n                                        \u0022routes\u0022: [\n                                            {\n                                                \u0022name\u0022: \u0022default\u0022,\n                                                \u0022match\u0022: {\n                                                    \u0022prefix\u0022: \u0022\/\u0022\n                                                },\n                                                \u0022route\u0022: {\n                                                    \u0022cluster\u0022: \u0022inbound|9080||\u0022,\n                                                    \u0022timeout\u0022: \u00220s\u0022,\n                                                    \u0022maxStreamDuration\u0022: {\n                                                        \u0022maxStreamDuration\u0022: \u00220s\u0022,\n                                                        \u0022grpcTimeoutHeaderMax\u0022: \u00220s\u0022\n                                                    }\n                                                },\n                                                \u0022decorator\u0022: {\n                                                    \u0022operation\u0022: \u0022reviews.default.svc.cluster.local:9080\/*\u0022\n                                                }\n                                            }\n                                        ]\n                                    }\n                                ],\n                                \u0022validateClusters\u0022: false\n                            },\n                            \/*omit*\/\n                        }\n                    }\n                ],\n            \/*omit*\/\n        ],\n        \u0022listenerFilters\u0022: [\n        \/*omit*\/\n        ],\n        \u0022listenerFiltersTimeout\u0022: \u00220s\u0022,\n        \u0022continueOnListenerFiltersTimeout\u0022: true,\n        \u0022trafficDirection\u0022: \u0022INBOUND\u0022\n    }\n]\n\u0060\u0060\u0060\n\nSince the Inbound Handler traffic routes traffic from any address to this Pod port 9080 to the \u0060inbound|9080||\u0060 Cluster, let\u0027s run \u0060istioctl pc cluster reviews-v1-545db77b95-jkgv2 --port 9080 --direction inbound -o json\u0060 to see the Cluster configuration and you will get something like the following output.\n\n\u0060\u0060\u0060json\n[\n    {\n        \u0022name\u0022: \u0022inbound|9080||\u0022,\n        \u0022type\u0022: \u0022ORIGINAL_DST\u0022,\n        \u0022connectTimeout\u0022: \u002210s\u0022,\n        \u0022lbPolicy\u0022: \u0022CLUSTER_PROVIDED\u0022,\n        \u0022circuitBreakers\u0022: {\n            \u0022thresholds\u0022: [\n                {\n                    \u0022maxConnections\u0022: 4294967295,\n                    \u0022maxPendingRequests\u0022: 4294967295,\n                    \u0022maxRequests\u0022: 4294967295,\n                    \u0022maxRetries\u0022: 4294967295,\n                    \u0022trackRemaining\u0022: true\n                }\n            ]\n        },\n        \u0022cleanupInterval\u0022: \u002260s\u0022,\n        \u0022upstreamBindConfig\u0022: {\n            \u0022sourceAddress\u0022: {\n                \u0022address\u0022: \u0022127.0.0.6\u0022,\n                \u0022portValue\u0022: 0\n            }\n        },\n        \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n                \u0022istio\u0022: {\n                    \u0022services\u0022: [\n                        {\n                            \u0022host\u0022: \u0022reviews.default.svc.cluster.local\u0022,\n                            \u0022name\u0022: \u0022reviews\u0022,\n                            \u0022namespace\u0022: \u0022default\u0022\n                        }\n                    ]\n                }\n            }\n        }\n    }\n]\n\u0060\u0060\u0060\n\nWe see that the \u0060TYPE\u0060 is \u0060ORIGINAL_DST\u0060, which sends the traffic to the original destination address (Pod IP), because the original destination address is the current Pod, you should also notice that the value of \u0060upstreamBindConfig.sourceAddress.address\u0060 is rewritten to 127.0.0.6, and for Pod This echoes the first rule in the iptables \u0060ISTIO_OUTPUT\u0060 the chain above, according to which traffic will be passed through to the application container inside the Pod.\n\n### Understand Outbound Handler\n\nBecause reviews send an HTTP request to the ratings service at \u0060http:\/\/ratings.default.svc.cluster.local:9080\/\u0060, the role of the Outbound handler is to intercept traffic from the local application to which iptables has intercepted, and determine how to route it to the upstream via the sidecar.\n\nRequests from application containers are Outbound traffic, intercepted by iptables and transferred to the Outbound handler for processing, which then passes through the virtualOutbound Listener, the \u00600.0.0.0_9080\u0060 Listener, and then finds the upstream cluster via Route 9080, which in turn finds the Endpoint via EDS to perform the routing action.\n\n**Route \u0060ratings.default.svc.cluster.local:9080\u0060**\n\n\u0060reviews\u0060 requests the \u0060ratings\u0060 service and runs \u0060istioctl proxy-config routes reviews-v1-545db77b95-jkgv2 --name 9080 -o json\u0060. View the route configuration because the  sidecar matches VirtualHost based on domains in the HTTP header, so only \u0060ratings.default.svc.cluster.local:9080\u0060 is listed below for this VirtualHost.\n\n\u0060\u0060\u0060json\n[{\n  {\n      \u0022name\u0022: \u0022ratings.default.svc.cluster.local:9080\u0022,\n      \u0022domains\u0022: [\n          \u0022ratings.default.svc.cluster.local\u0022,\n          \u0022ratings.default.svc.cluster.local:9080\u0022,\n          \u0022ratings\u0022,\n          \u0022ratings:9080\u0022,\n          \u0022ratings.default.svc.cluster\u0022,\n          \u0022ratings.default.svc.cluster:9080\u0022,\n          \u0022ratings.default.svc\u0022,\n          \u0022ratings.default.svc:9080\u0022,\n          \u0022ratings.default\u0022,\n          \u0022ratings.default:9080\u0022,\n          \u002210.98.49.62\u0022,\n          \u002210.98.49.62:9080\u0022\n      ],\n      \u0022routes\u0022: [\n          {\n              \u0022name\u0022: \u0022default\u0022,\n              \u0022match\u0022: {\n                  \u0022prefix\u0022: \u0022\/\u0022\n              },\n              \u0022route\u0022: {\n                  \u0022cluster\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n                  \u0022timeout\u0022: \u00220s\u0022,\n                  \u0022retryPolicy\u0022: {\n                      \u0022retryOn\u0022: \u0022connect-failure,refused-stream,unavailable,cancelled,resource-exhausted,retriable-status-codes\u0022,\n                      \u0022numRetries\u0022: 2,\n                      \u0022retryHostPredicate\u0022: [\n                          {\n                              \u0022name\u0022: \u0022envoy.retry_host_predicates.previous_hosts\u0022\n                          }\n                      ],\n                      \u0022hostSelectionRetryMaxAttempts\u0022: \u00225\u0022,\n                      \u0022retriableStatusCodes\u0022: [\n                          503\n                      ]\n                  },\n                  \u0022maxGrpcTimeout\u0022: \u00220s\u0022\n              },\n              \u0022decorator\u0022: {\n                  \u0022operation\u0022: \u0022ratings.default.svc.cluster.local:9080\/*\u0022\n              }\n          }\n      ]\n  },\n..]\n\u0060\u0060\u0060\n\nFrom this VirtualHost configuration, you can see routing traffic to the cluster \u0060outbound|9080||ratings.default.svc.cluster.local\u0060.\n\n**Endpoint \u0060outbound|9080||ratings.default.svc.cluster.local\u0060**\n\nRunning \u0060istioctl proxy-config endpoint reviews-v1-545db77b95-jkgv2 --port 9080 -o json --cluster \u0022outbound|9080||ratings.default.svc.cluster.local\u0022\u0060 to view the Endpoint configuration, the results are as follows.\n\n\u0060\u0060\u0060json\n{\n  \u0022clusterName\u0022: \u0022outbound|9080||ratings.default.svc.cluster.local\u0022,\n  \u0022endpoints\u0022: [\n    {\n      \u0022locality\u0022: {\n\n      },\n      \u0022lbEndpoints\u0022: [\n        {\n          \u0022endpoint\u0022: {\n            \u0022address\u0022: {\n              \u0022socketAddress\u0022: {\n                \u0022address\u0022: \u0022172.33.100.2\u0022,\n                \u0022portValue\u0022: 9080\n              }\n            }\n          },\n          \u0022metadata\u0022: {\n            \u0022filterMetadata\u0022: {\n              \u0022istio\u0022: {\n                  \u0022uid\u0022: \u0022kubernetes:\/\/ratings-v1-8558d4458d-ns6lk.default\u0022\n                }\n            }\n          }\n        }\n      ]\n    }\n  ]\n}\n\u0060\u0060\u0060\n\nWe see that the endpoint address is \u006010.4.1.12\u0060. In fact, the Endpoint can be one or more, and the sidecar will select the appropriate Endpoint to route based on certain rules. At this point the review Pod has found the Endpoint for its upstream service rating.\n\n## Summary\n\nThis article uses the bookinfo example provided by Istio to guide readers through the implementation details behind the sidecar injection, iptables transparent traffic intercepting, and traffic routing in the sidecar. The sidecar mode and traffic transparent intercepting are the features and basic functions of Istio service mesh, understanding the process behind this function and the implementation details will help you understand the principle of service mesh and the content in the later chapters of the Istio Handbook, so I hope readers can try it from scratch in their own environment to deepen their understanding.\n\nUsing iptables for traffic intercepting is just one of the ways to do traffic intercepting in the data plane of a service mesh, and there are many more traffic intercepting scenarios, quoted below from the description of the traffic intercepting section given in the MOSN official network of the cloud-native network proxy.\n\n### Problems with using iptables for traffic intercepting\n\nCurrently, Istio uses iptables for transparent intercepting and there are three main problems.\n\n1. The need to use the conntrack module for connection tracking, in the case of a large number of connections, will cause a large consumption and may cause the track table to be full, in order to avoid this problem, the industry has a practice of closing conntrack.\n2. iptables is a common module with global effect and cannot explicitly prohibit associated changes, which is less controllable.\n3. iptables redirect traffic is essentially exchanging data via a loopback. The outbound traffic will traverse the protocol stack twice and lose forwarding performance in a large concurrency scenario.\n\nSeveral of the above problems are not present in all scenarios, let\u0027s say some scenarios where the number of connections is not large and the NAT table is not used, iptables is a simple solution that meets the requirements. In order to adapt to a wider range of scenarios, transparent intercepting needs to address all three of these issues.\n\n### Transparent intercepting optimization\n\nIn order to optimize the performance of transparent traffic intercepting in Istio, the following solutions have been proposed by the industry.\n\n**Traffic intercepting with eBPF using the Merbridge Open Source Project**\n\n[Merbridge](https:\/\/github.com\/merbridge\/merbridge) is a plug-in that leverages eBPF to accelerate the Istio service mesh, which was open sourced by DaoCloud in early 2022. Using Merbridge can optimize network performance in the data plane to some extent.\n\nMerbridge leverages the sockops and \u0060redir\u0060 capabilities of eBPF to transfer packets directly from inbound sockets to outbound sockets. eBPF provides the \u0060bpf_msg_redirect_hash\u0060 function to forward application packets directly.\n\n**Handling inbound traffic with tproxy**\n\ntproxy can be used for redirection of inbound traffic without changing the destination IP\/port in the packet, without performing connection tracking, and without the problem of conntrack modules creating a large number of connections. Restricted to the kernel version, tproxy\u0027s application to outbound is flawed. Istio currently supports handling inbound traffic via tproxy.\n\n**Use hook connect to handle outbound traffic**\n\nIn order to adapt to more application scenarios, the outbound direction is implemented by hook connect, which is implemented as follows.\n\n![Hook Connect Diagram](hook-connect.svg)\n\nWhichever transparent intercepting scheme is used, the problem of obtaining the real destination IP\/port needs to be solved, using the iptables scheme through getsockopt, \u0060tproxy\u0060 can read the destination address directly, by modifying the call interface, hook connect scheme reads in a similar way to tproxy.\n\nAfter the transparent intercepting, the  \u0060sockmap\u0060 can shorten the packet traversal path and improve forwarding performance in the outbound direction, provided that the kernel version meets the requirements (4.16 and above).\n\n## References\n\n- [Debugging Envoy and Istiod - istio.io](https:\/\/istio.io\/docs\/ops\/diagnostic-tools\/proxy-cmd\/)\n- [Demystifying Istio\u0027s Sidecar Injection Model - istio.io](https:\/\/istio.io\/blog\/2019\/data-plane-setup\/)\n- The traffic intercepting solution when MOSN is used as a sidecar - mosn.io\n', '\/en\/blog\/sidecar-injection-iptables-and-traffic-routing\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Learn the sidecar pattern, transparent traffic intercepting and routing in Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-pod-process-lifecycle/">Istio Data Plane Pod Startup Process Explained</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Data Plane Pod Startup Process Explained', 'This article will explain Istio\u0027s Init container, Pod internal processes and the startup process.', '\nThis article will explain:\n\n- The sidecar auto-injection process in Istio\n- The init container startup process in Istio\n- The startup process of a Pod with Sidecar auto-injection enabled\n\nThe following figure shows the components of a Pod in the Istio data plane after it has been started.\n\n![Istio data plane pod](istio-pod-lifecycle.jpg)\n\n## Sidecar injection in Istio\n\nThe following two sidecar injection methods are available in Istio.\n\n- Manual injection using \u0060istioctl\u0060.\n- Kubernetes-based [mutating webhook admission controller](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/admission-controllers\/) automatic sidecar injection method.\n\nWhether injected manually or automatically, SIDECAR\u0027s injection process follows the following steps.\n\n1. Kubernetes needs to know the Istio cluster to which the sidecar to be injected is connected and its configuration.\n2. Kubernetes needs to know the configuration of the sidecar container itself to be injected, such as the image address, boot parameters, etc.\n3. Kubernetes injects the above configuration into the side of the application container by the sidecar injection template and the configuration parameters of the above configuration-filled sidecar.\n\nThe sidecar can be injected manually using the following command.\n\n\u0060\u0060\u0060bash\nistioctl kube-inject -f ${YAML_FILE} | kuebectl apply -f -\n\u0060\u0060\u0060\n\nThis command is injected using Istio\u0027s built-in sidecar configuration, see the [Istio official website](https:\/\/istio.io) for details on how to use Istio below.\n\nWhen the injection is complete you will see that Istio has injected initContainer and sidecar proxy-related configurations into the original pod template.\n\n### Init container\n\nThe Init container is a dedicated container that runs before the application container is launched and is used to contain some utilities or installation scripts that do not exist in the application image.\n\nMultiple Init containers can be specified in a Pod, and if more than one is specified, the Init containers will run sequentially. The next Init container can only be run if the previous Init container must run successfully. Kubernetes only initializes the Pod and runs the application container when all the Init containers have been run.\n\nThe Init container uses Linux Namespace, so it has a different view of the file system than the application container. As a result, they can have access to Secret in a way that application containers cannot.\n\nDuring Pod startup, the Init container starts sequentially after the network and data volumes are initialized. Each container must be successfully exited before the next container can be started. If exiting due to an error will result in a container startup failure, it will retry according to the policy specified in the Pod\u0027s restartPolicy. However, if the Pod\u0027s restartPolicy is set to Always, the restartPolicy is used when the Init container failed.\n\nThe Pod will not become Ready until all Init containers are successful. The ports of the Init containers will not be aggregated in the Service. The Pod that is being initialized is in the Pending state but should set the Initializing state to true. The Init container will automatically terminate once it is run.\n\n## Sidecar injection example analysis\n\nFor a detailed YAML configuration for the bookinfo applications, see \u0060bookinfo.yaml\u0060 for the official Istio YAML of productpage in the bookinfo sample.\n\nThe following will be explained in the following terms.\n\n- Injection of Sidecar containers\n- Creation of iptables rules\n- The detailed process of routing\n\n\u0060\u0060\u0060yaml\napiVersion: apps\/v1\nkind: Deployment\nmetadata:\n  name: productpage-v1\n  labels:\n    app: productpage\n    version: v1\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: productpage\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: productpage\n        version: v1\n    spec:\n      serviceAccountName: bookinfo-productpage\n      containers:\n      - name: productpage\n        image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 9080\n        volumeMounts:\n        - name: tmp\n          mountPath: \/tmp\n      volumes:\n      - name: tmp\n        emptyDir: {}\n\u0060\u0060\u0060\n\nLet\u0027s see the \u0060productpage\u0060 container’s [Dockerfile](https:\/\/github.com\/istio\/istio\/blob\/master\/samples\/bookinfo\/src\/productpage\/Dockerfile).\n\n\u0060\u0060\u0060docker\nFROM python:3.7.4-slim\n\nCOPY requirements.txt .\/\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY test-requirements.txt .\/\nRUN pip install --no-cache-dir -r test-requirements.txt\n\nCOPY productpage.py \/opt\/microservices\/\nCOPY tests\/unit\/* \/opt\/microservices\/\nCOPY templates \/opt\/microservices\/templates\nCOPY static \/opt\/microservices\/static\nCOPY requirements.txt \/opt\/microservices\/\n\nARG flood_factor\nENV FLOOD_FACTOR ${flood_factor:-0}\n\nEXPOSE 9080\nWORKDIR \/opt\/microservices\nRUN python -m unittest discover\n\nUSER 1\n\nCMD [\u0022python\u0022, \u0022productpage.py\u0022, \u00229080\u0022]\n\u0060\u0060\u0060\n\nWe see that \u0060ENTRYPOINT\u0060 is not configured in Dockerfile, so \u0060CMD\u0060’s configuration \u0060python productpage.py 9080\u0060 will be the default \u0060ENTRYPOINT\u0060, keep that in mind and look at the configuration after the sidecar injection.\n\n\u0060\u0060\u0060bash\n$ istioctl kube-inject -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\n\u0060\u0060\u0060\n\nWe intercept only a portion of the YAML configuration that is part of the Deployment configuration associated with productpage.\n\n\u0060\u0060\u0060yaml\n      containers:\n      - image: docker.io\/istio\/examples-bookinfo-productpage-v1:1.15.0 # application image\n        name: productpage\n        ports:\n        - containerPort: 9080\n      - args:\n        - proxy\n        - sidecar\n        - --domain\n        - $(POD_NAMESPACE).svc.cluster.local\n        - --configPath\n        - \/etc\/istio\/proxy\n        - --binaryPath\n        - \/usr\/local\/bin\/envoy\n        - --serviceCluster\n        - productpage.$(POD_NAMESPACE)\n        - --drainDuration\n        - 45s\n        - --parentShutdownDuration\n        - 1m0s\n        - --discoveryAddress\n        - istiod.istio-system.svc:15012\n        - --zipkinAddress\n        - zipkin.istio-system:9411\n        - --proxyLogLevel=warning\n        - --proxyComponentLogLevel=misc:error\n        - --connectTimeout\n        - 10s\n        - --proxyAdminPort\n        - \u002215000\u0022\n        - --concurrency\n        - \u00222\u0022\n        - --controlPlaneAuthPolicy\n        - NONE\n        - --dnsRefreshRate\n        - 300s\n        - --statusPort\n        - \u002215020\u0022\n        - --trust-domain=cluster.local\n        - --controlPlaneBootstrap=false\n        image: docker.io\/istio\/proxyv2:1.5.1 # sidecar proxy\n        name: istio-proxy\n        ports:\n        - containerPort: 15090\n          name: http-envoy-prom\n          protocol: TCP\n      initContainers:\n      - command:\n        - istio-iptables\n        - -p\n        - \u002215001\u0022\n        - -z\n        - \u002215006\u0022\n        - -u\n        - \u00221337\u0022\n        - -m\n        - REDIRECT\n        - -i\n        - \u0027*\u0027\n        - -x\n        - \u0022\u0022\n        - -b\n        - \u0027*\u0027\n        - -d\n        - 15090,15020\n        image: docker.io\/istio\/proxyv2:1.5.1 # init container\n        name: istio-init\n\u0060\u0060\u0060\n\nIstio\u0027s configuration for application Pod injection mainly includes:\n\n- Init container \u0060istio-init\u0060: for setting iptables port forwarding in the pod\n- Sidecar container \u0060istio-proxy\u0060: running a sidecar proxy, such as Envoy or MOSN\n\nThe two containers will be parsed separately.\n\n## Init container analysis\n\nThe Init container that Istio injects into the pod is named \u0060istio-init\u0060, and we see in the YAML file above after Istio\u0027s injection is complete that the init command for this container is.\n\n\u0060\u0060\u0060bash\nistio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0027*\u0027 -x \u0022\u0022 -b \u0027*\u0027 -d 15090,15020\n\u0060\u0060\u0060\n\nLet\u0027s check the container\u0027s Dockerfile again to see how \u0060ENTRYPOINT\u0060 determines what commands are executed at startup.\n\n\u0060\u0060\u0060docker\n# ommit\n# The pilot-agent will bootstrap Envoy.\nENTRYPOINT [\u0022\/usr\/local\/bin\/pilot-agent\u0022]\n\u0060\u0060\u0060\n\nWe see that the entrypoint of the \u0060istio-init\u0060 container is the \u0060\/usr\/local\/bin\/istio-iptables\u0060 command line, and the location of the code for this command-line tool is in the \u0060tools\/istio-iptables\u0060 directory of the Istio source code repository.\n\n### Init container initiation\n\nThe Init container\u0027s entrypoint is the \u0060istio-iptables\u0060 command line, which is used as follows.\n\n\u0060\u0060\u0060bash\nUsage:\n  istio-iptables [flags]\n\nFlags:\n  -n, --dry-run                                     Do not call any external dependencies like iptables\n  -p, --envoy-port string                           Specify the envoy port to which redirect all TCP traffic (default $ENVOY_PORT = 15001)\n  -h, --help                                        help for istio-iptables\n  -z, --inbound-capture-port string                 Port to which all inbound TCP traffic to the pod\/VM should be redirected to (default $INBOUND_CAPTURE_PORT = 15006)\n      --iptables-probe-port string                  set listen port for failure detection (default \u002215002\u0022)\n  -m, --istio-inbound-interception-mode string      The mode used to redirect inbound connections to Envoy, either \u0022REDIRECT\u0022 or \u0022TPROXY\u0022\n  -b, --istio-inbound-ports string                  Comma separated list of inbound ports for which traffic is to be redirected to Envoy (optional). The wildcard character \u0022*\u0022 can be used to configure redirection for all ports. An empty list will disable\n  -t, --istio-inbound-tproxy-mark string\n  -r, --istio-inbound-tproxy-route-table string\n  -d, --istio-local-exclude-ports string            Comma separated list of inbound ports to be excluded from redirection to Envoy (optional). Only applies  when all inbound traffic (i.e. \u0022*\u0022) is being redirected (default to $ISTIO_LOCAL_EXCLUDE_PORTS)\n  -o, --istio-local-outbound-ports-exclude string   Comma separated list of outbound ports to be excluded from redirection to Envoy\n  -i, --istio-service-cidr string                   Comma separated list of IP ranges in CIDR form to redirect to envoy (optional). The wildcard character \u0022*\u0022 can be used to redirect all outbound traffic. An empty list will disable all outbound\n  -x, --istio-service-exclude-cidr string           Comma separated list of IP ranges in CIDR form to be excluded from redirection. Only applies when all  outbound traffic (i.e. \u0022*\u0022) is being redirected (default to $ISTIO_SERVICE_EXCLUDE_CIDR)\n  -k, --kube-virt-interfaces string                 Comma separated list of virtual interfaces whose inbound traffic (from VM) will be treated as outbound\n      --probe-timeout duration                      failure detection timeout (default 5s)\n  -g, --proxy-gid string                            Specify the GID of the user for which the redirection is not applied. (same default value as -u param)\n  -u, --proxy-uid string                            Specify the UID of the user for which the redirection is not applied. Typically, this is the UID of the proxy container\n  -f, --restore-format                              Print iptables rules in iptables-restore interpretable format (default true)\n      --run-validation                              Validate iptables\n      --skip-rule-apply                             Skip iptables apply\n\u0060\u0060\u0060\n\nThe above incoming parameters are reassembled into iptables rules. For more information on how to use this command, visit \u0060tools\/istio-iptables\/pkg\/cmd\/root.go\u0060.\n\nThe significance of the container\u0027s existence is that it allows the sidecar agent to intercept all inbound and outbound traffic to the pod, redirect all inbound traffic to port 15006 (sidecar) except port 15090 (used by Prometheus) and port 15092 (Ingress Gateway), and then intercept outbound traffic from the application container which is processed by sidecar (listening through port 15001) and then outbound. See the [official Istio documentation](https:\/\/istio.io\/docs\/ops\/deployment\/requirements\/) for port usage in Istio.\n\n**Command analysis**\n\nHere is the purpose of this start-up command.\n\n- Forward all traffic from the application container to port 15006 of the sidecar.\n- Run with the \u0060istio-proxy\u0060 user identity, with a UID of 1337, the userspace where the sidecar is located, which is the default user used by the \u0060istio-proxy\u0060 container, see the runAsUser field of the YAML configuration.\n- Use the default REDIRECT mode to redirect traffic.\n- Redirect all outbound traffic to the sidecar proxy (via port 15001).\n\nBecause the Init container is automatically terminated after initialization, since we cannot log into the container to view the iptables information, the Init container initialization results are retained in the application container and sidecar container.\n\n## Pod Startup Sequence\n\nThe startup process of a Pod with Sidecar auto-injection enabled is as follows.\n\n1. The Init container starts first, injecting iptables rules into the Pod for transparent traffic interception. \n2. Subsequently, Kubernetes starts the containers in the order in which they are declared in the Pod Spec, but this is non-blocking and there is no guarantee that the first container will be started before the next one is started. \u0060istio-proxy\u0060 container starts, \u0060pilot-agent\u0060 will be the PID 1 process, which is the first process in the Linux user space and is responsible for pulling up other processes and handling zombie processes. The \u0060pilot-agent\u0060 generates the Envoy bootstrap configuration and fork the envoy process; the application container is started almost simultaneously with the \u0060istio-proxy\u0060 container, and the readiness probe comes in handy to prevent the container inside the Pod from receiving outside traffic before it is ready to start. Kubernetes will perform a readiness check on port 15021 of the \u0060istio-proxy\u0060 container, and the \u0060kubelet\u0060 will not route traffic to the Pod until the \u0060isito-proxy\u0060 has finished booting.\n3. After the Pod is started, the \u0060pilot-agent\u0060 becomes a daemon that monitors the rest of the system and provides Envoy with Bootstrap configuration, certificates, health checks, configuration hot reloading, identity support, and process lifecycle management, among other things.\n\n## Pod container startup order problem\n\nIn the process of Pod startup there is a container startup order problem. Suppose the following situation, the application container starts first and requests other services, when the \u0060istio-proxy\u0060 container has not finished starting, then the request will fail, and if your application is not robust enough, it may even cause the application container to crash and the Pod to restart. The solution for this situation is to\n\n- Modify the application to add timeout retries.\n- Increase the start delay of the process in the application container, for example by increasing the sleep time.\n- Add a [postStart](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/attach-handler-lifecycle-event\/) configuration to the application container to detect if the application process has finished starting, and Kubernetes will only mark the Pod\u0027s state as \u0060Running\u0060 if the detection is successful.\n\n## Summary\n\nThis article walks you through the process of starting Pods in the Istio data plane, and the issues that arise because of the order in which Pod contenters are started.\n', '\/en\/blog\/istio-pod-process-lifecycle\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will explain Istio&#39;s Init container, Pod internal processes and the startup process.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/understanding-iptables/">Understanding IPTables</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding IPTables', 'This article will give you a brief introduction to iptables, its tables and the order of execution.', '\niptables is an important feature in the Linux kernel and has a wide range of applications. iptables is used by default in Istio for transparent traffic hijacking. Understanding iptables is very important for us to understand how Istio works. This article will give you a brief introduction to iptbles.\n\n## iptables introduction\n\niptables is a management tool for netfilter, the firewall software in the Linux kernel. netfilter is located in the user space and is part of netfilter. netfilter is located in the kernel space and has not only network address conversion, but also packet content modification and packet filtering firewall functions.\n\nBefore learning about iptables for Init container initialization, let\u0027s go over iptables and rule configuration.\n\nThe following figure shows the iptables call chain.\n\n![iptables 调用链](iptables.jpg)\n\n### iptables\n\nThe iptables version used in the Init container is v1.6.0 and contains 5 tables.\n\n1. RAW is used to configure packets. Packets in RAW are not tracked by the system.\n2. The filter is the default table used to house all firewall-related operations.\n3. NAT is used for network address translation (e.g., port forwarding).\n4. Mangle is used for modifications to specific packets (refer to corrupted packets).\n5. Security is used to force access to control network rules.\n\nNote: In this example, only the NAT table is used.\n\nThe chain types in the different tables are as follows.\n\n| Rule name   | raw  | filter | nat  | mangle | security |\n| ----------- | ---- | ------ | ---- | ------ | -------- |\n| PREROUTING  | ✓    |        | ✓    | ✓      |          |\n| INPUT       |      | ✓      |      | ✓      | ✓        |\n| OUTPUT      | ✓    | ✓      | ✓    | ✓      | ✓        |\n| POSTROUTING |      |        | ✓    | ✓      |          |\n| FORWARD     |      | ✓      |      | ✓      | ✓        |\n\n### Understand iptables rules\n\nView the default iptables rules in the \u0060istio-proxy\u0060 container, the default view is the rules in the filter table.\n\n\u0060\u0060\u0060bash\n$ iptables -L -v\nChain INPUT (policy ACCEPT 350K packets, 63M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)\n pkts bytes target     prot opt in     out     source               destination\n\u0060\u0060\u0060\n\nWe see three default chains, INPUT, FORWARD, and OUTPUT, with the first line of output in each chain indicating the chain name (INPUT\/FORWARD\/OUTPUT in this case), followed by the default policy (ACCEPT).\n\nThe following is a proposed structure diagram of iptables, where traffic passes through the INPUT chain and then enters the upper protocol stack, such as:\n\n![iptables chains](iptables-chains.jpg)\n\nMultiple rules can be added to each chain and the rules are executed in order from front to back. Let\u0027s look at the table header definition of the rule.\n\n- **PKTS**: Number of matched messages processed\n- **bytes**: cumulative packet size processed (bytes)\n- **Target**: If the message matches the rule, the specified target is executed.\n- **PROT**: Protocols such as TDP, UDP, ICMP, and ALL.\n- **opt**: Rarely used, this column is used to display IP options.\n- **IN**: Inbound network interface.\n- **OUT**: Outbound network interface.\n- **source**: the source IP address or subnet of the traffic, the latter being anywhere.\n- **destination**: the destination IP address or subnet of the traffic, or anywhere.\n\nThere is also a column without a header, shown at the end, which represents the options of the rule, and is used as an extended match condition for the rule to complement the configuration in the previous columns. prot, opt, in, out, source and destination and the column without a header shown after destination together form the match rule. TARGET is executed when traffic matches these rules.\n\n**Types supported by TARGET**\n\nTarget types include ACCEPT, REJECT, DROP, LOG, SNAT, MASQUERADE, DNAT, REDIRECT, RETURN or jump to other rules, etc. You can determine where the telegram is going by executing only one rule in a chain that matches in order, except for the RETURN type, which is similar to the return statement in programming languages, which returns to its call point and continues to execute the next rule.\n\nFrom the output, you can see that the Init container does not create any rules in the default link of iptables, but instead creates a new link.\n\n## Summary\n\nWith the above brief introduction to iptables, you have understood how iptables works, the rule chain and its execution order.\n', '\/en\/blog\/understanding-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will give you a brief introduction to iptables, its tables and the order of execution.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-components-and-ports/">Istio Component Ports and Functions in Details</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 8, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Component Ports and Functions in Details', 'This article will introduce you to the various ports and functions of the Istio control plane and data plane.', '\nIn my last two blogs:\n\n- [Sidecar injection, transparent traffic hijacking , and routing process in Istio explained in detail](\/en\/blog\/sidecar-injection-iptables-and-traffic-routing\/)\n- [Traffic types and iptables rules in Istio sidecar explained](\/en\/blog\/istio-sidecar-traffic-types\/)\n\nI gave you a detailed overview of the traffic in the Istio data plane, but the data plane does not exist in isolation. This article will show you the ports and their usages for each component of both the control plane and data plane in Istio, which will help you understand the relationship between these flows and troubleshoot them.\n\n## Overview\n\nFirstly, I will show you a global schematic. The following figure shows the components of a sidecar in the Istio data plane, and the objects that interact with it.\n\n![Istio components](istio-ports-components.webp)\n\nWe can use the \u0060nsenter\u0060 command to enter the namespace of the \u0060productpage\u0060 Pod of the Bookinfo example and see the information about the ports it is listening on internally.\n\n![Istio sidecar ports](sidecar-ports.webp)\n\nFrom the figure, we can see that besides the port 9080 that the \u0060productpage\u0060 application listens to, the Sidecar container also listens to a large number of other ports, such as 15000, 15001, 15004, 15006, 15021, 15090, etc. You can learn about the ports used in Istio in the Istio documentation.\n\nLet\u0027s go back into the \u0060productpage\u0060 Pod and use the \u0060lsof -i\u0060 command to see the ports it has open, as shown in the following figure.\n\n![Productpage Pod ports](product-pod-ports.webp)\n\nWe can see that there is a TCP connection established between the \u0060pilot-agent\u0060 and \u0060istiod\u0060, the port in the listening described above, and the TCP connection established inside the Pod, which corresponds to the figure at the beginning of the article.\n\nThe root process of the Sidecar container (\u0060istio-proxy\u0060) is \u0060pilot-agent\u0060, and the startup command is shown below.\n\n![Internal procecces in Sidecar](sidecar-procecces.webp)\n\nAs we can see from the figure, the PID of its \u0060pilot-agent\u0060 process is 1, and it forked the Envoy process.\n\nCheck the ports it opens in Istiod, as shown in the figure below.\n\n![Istiod ports](sidecar-lsof.webp)\n\nWe can see the ports that are listened to, the inter-process and remote communication connections.\n\n## Ports usage overview\n\nThese ports can play a pivotal role when you are troubleshooting. They are described below according to the component and function in which the port is located.\n\n### Ports in Istiod\n\nThe ports in Istiod are relatively few and single-function.\n\n- 9876: ControlZ user interface, exposing information about Istiod\u0027s processes\n- 8080: Istiod debugging port, through which the configuration and status information of the grid can be queried\n- 15010: Exposes the xDS API and issues plain text certificates\n- 15012: Same functionality as port 15010, but uses TLS communication\n- 15014: Exposes control plane metrics to Prometheus\n- 15017: Sidecar injection and configuration validation port\n\n## Ports in sidecar\n\nFrom the above, we see that there are numerous ports in the sidecar.\n\n- 15000: Envoy admin interface, which you can use to query and modify the configuration of Envoy Proxy. Please refer to[ Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/operations\/admin) for details.\n- 15001: Used to handle outbound traffic.\n- 15004: Debug port (explained further below).\n- 15006: Used to handle inbound traffic.\n- 15020: Summarizes statistics, perform health checks on Envoy and DNS agents, and debugs \u0060pilot-agent\u0060 processes, as explained in detail below.\n- 15021: Used for sidecar health checks to determine if the injected Pod is ready to receive traffic. We set up the readiness probe on the \u0060\/healthz\/ready\u0060 path on this port, and Istio hands off the sidecar readiness checks to kubelet.\n- 15053: Local DNS proxy for scenarios where the cluster\u0027s internal domain names are not resolved by Kubernetes DNS.\n- 15090: Envoy Prometheus query port, through which the \u0060pilot-agent\u0060 will scratch metrics.\n\nThe above ports can be divided into the following categories.\n\n- Responsible for inter-process communication, such as 15001, 15006, 15053\n- Health check and information statistics, e.g. 150021, 15090\n- Debugging: 15000, 15004\n\nLet\u0027s look at the key ports in detail.\n\n## 15000\n\n15000 is Envoy\u0027s Admin interface, which allows us to modify Envoy and get a view and query metrics and configurations.\n\nThe Admin interface consists of a REST API with multiple endpoints and a simple user interface. You can enable the Envoy Admin interface view in the \u0060productpage\u0060 Pod using the following command:\n\n\u0060\u0060\u0060bash\nkubectl -n default port-forward deploy\/productpage-v1 15000\n\u0060\u0060\u0060\n\nVisit \u0060http:\/\/localhost:15000\u0060 in your browser and you will see the Envoy Admin interface as shown below.\n\n![Envoy Admin interface](envoy-admin.webp)\n\n## 15004\n\nWith the \u0060pilot-agent\u0060 proxy \u0060istiod\u0060 debug endpoint on port 8080, you can access localhost\u0027s port 15004 in the data plane Pod to query the grid information, which has the same effect as port 8080 below.\n\n## 8080\n\nYou can also forward \u0060istiod\u0060 port 8080 locally by running the following command:\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system port-forward deploy\/istiod 8080\n\u0060\u0060\u0060\n\nVisit \u0060http:\/\/localhost:8080\/debug\u0060 in your browser and you will see the debug endpoint as shown in the figure below.\n\n![Pilot Debug Console](pilot-debug-console.webp)\n\nOf course, this is only one way to get the mesh information and debug the mesh, you can also use \u0060istioctl\u0060 command or Kiali to debug it, which will be more efficient and intuitive.\n\n## 15020\n\nPort 15020 has three main usages.\n\n1. Aggregating metrics: You can query port 15090 for Envoy\u0027s metrics, or you can configure it to query the application\u0027s metrics, aggregating Envoy, application, and its own metrics for Prometheus to collect. The corresponding debug endpoint is \u0060\/stats\/prometheus\u0060. \n2. Performing health checks on Envoy and DNS agent: the corresponding debug endpoints are \u0060\/healthz\/ready\u0060 and \u0060\/app-health\u0060.\n3. Debugging \u0060pilot-agent\u0060 processes: the corresponding debug endpoints are \u0060\/quitquitquit\u0060, \u0060debug\/ndsz\u0060 and \u0060\/debug\/pprof\u0060.\n\nThe following figure shows the debugging information you see when you open \u0060http:\/\/localhost:15020\/debug\/pprof\u0060 in your browser.\n\n![pprof endpoint](pprof.webp)\n\nThe information in the figure shows the stack information of the \u0060pilot-agent\u0060.\n\n## Summary\n\nBy understanding the component ports in Istio, you should have a better understanding of the relationship between the components in Istio and their internal traffic. Being familiar with the functions of these ports will help in troubleshooting the mesh.\n', '\/en\/blog\/istio-components-and-ports\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will introduce you to the various ports and functions of the Istio control plane and data plane.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-sidecar-traffic-types/">Traffic Types and Iptables Rules in Istio Sidecar Explained</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 7, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Traffic Types and Iptables Rules in Istio Sidecar Explained', 'This article will show you the six traffic types and their iptables rules in Istio sidecar, and take you through the whole diagram in a schematic format.', '\nAs we know that Istio uses iptables for traffic hijacking, where the iptables rule chains has one called \u0060ISTIO_OUTPUT\u0060, which contains the following rules.\n\n| **Rule** | **target**        | **in** | **out** | **source** | **destination**                 |\n| -------- | ----------------- | ------ | ------- | ---------- | ------------------------------- |\n| 1        | RETURN            | any    | lo      | 127.0.0.6  | anywhere                        |\n| 2        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner UID match 1337 |\n| 3        | RETURN            | any    | lo      | anywhere   | anywhere !owner UID match 1337  |\n| 4        | RETURN            | any    | any     | anywhere   | anywhere owner UID match 1337   |\n| 5        | ISTIO_IN_REDIRECT | any    | lo      | anywhere   | !localhost owner GID match 1337 |\n| 6        | RETURN            | any    | lo      | anywhere   | anywhere !owner GID match 1337  |\n| 7        | RETURN            | any    | any     | anywhere   | anywhere owner GID match 1337   |\n| 8        | RETURN            | any    | any     | anywhere   | localhost                       |\n| 9        | ISTIO_REDIRECT    | any    | any     | anywhere   | anywhere                        |\n\nThe sidecar applies these rules to deal with different types of traffic. This article will show you the six types of traffic and their iptables rules in Istio sidecar.\n\n## iptables Traffic Routing in Sidecar\n\nThe following list summarizes the six types of traffic in Sidecar.\n\n 1. Remote service accessing local service: Remote Pod -\u003e Local Pod\n 2. Local service accessing remote service: Local Pod -\u003e Remote Pod\n 3. Prometheus crawling metrics of local service: Prometheus -\u003e Local Pod\n 4. Traffic between Local Pod service: Local Pod -\u003e Local Pod\n 5. Inter-process TCP traffic within Envoy\n 6. Sidecar to Istiod traffic\n\nThe following will explain the iptables routing rules within Sidecar for each scenario, which specifies which rule in ISTIO_OUTPUT is used for routing.\n\n## Type 1: Remote Pod -\u003e Local Pod\n\nThe following are the iptables rules for remote services, applications or clients accessing the local pod IP of the data plane.\n\nRemote Pod -\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060 -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006 (Inbound) -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060 POSTROUTING\u0060 -\u003e Local Pod\n\nWe see that the traffic only passes through the Envoy 15006 Inbound port once. The following diagram shows this scenario of the iptables rules.\n\n![Remote Pod to Local Pod](remote-pod-local-pod.svg)\n\n## Type 2: Local Pod -\u003e Remote Pod\n\nThe following are the iptables rules that the local pod IP goes through to access the remote service.\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e \u0060ISTIO_REDIRECT\u0060 -\u003e Envoy 15001 (Outbound) -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060 -\u003e Remote Pod\n\nWe see that the traffic only goes through the Envoy 15001 Outbound port. \n\n![Local Pod to Remote Pod](local-pod-remote-pod.svg)\n\nThe traffic in both scenarios above passes through Envoy only once because only one scenario occurs in that Pod, sending or receiving requests.\n\n## Type 3: Prometheus -\u003e Local Pod\n\nPrometheus traffic that grabs data plane metrics does not have to go through the Envoy proxy.\n\nThese traffic pass through the following iptables rules.\n\nPrometheus-\u003e \u0060RREROUTING\u0060 -\u003e \u0060ISTIO_INBOUND\u0060 (traffic destined for ports 15020, 15090 will go to \u0060INPUT\u0060) -\u003e \u0060INPUT\u0060  -\u003e Local Pod\n\n![Prometheus to Local Pod](prometheus-local-pod.svg)\n\n## Type 4: Local Pod -\u003e Local Pod\n\nA Pod may simultaneously have two or more services. If the Local Pod accesses a service on the current Pod, the traffic will go through Envoy 15001 and Envoy 15006 ports to reach the service port of the Local Pod.\n\nThe iptables rules for this traffic are as follows.\n\nLocal Pod-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 9** -\u003e \u0060ISTIO_REDIRECT\u0060 -\u003e Envoy 15001（Outbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 2** -\u003e \u0060ISTIO_IN_REDIRECT\u0060 -\u003e Envoy 15006（Inbound）-\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 1** -\u003e \u0060POSTROUTING\u0060 -\u003e Local Pod\n\n![Local Pod to Local Pod](local-pod-local-pod.svg)\n\n## Type 5: Inter-process TCP traffic within Envoy\n\nEnvoy internal processes with UID and GID 1337 will communicate with each other using lo NICs and localhost domains.\n\nThe iptables rules that these flows pass through are as follows.\n\nEnvoy process (Localhost) -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 8** -\u003e \u0060POSTROUTING\u0060 -\u003e Envoy process (Localhost)\n\n![Envoy inter-process TCP traffic](envoy-internal-tcp-traffic.svg)\n\n## Type 6: Sidecar to Istiod traffic\n\nSidecar needs access to Istiod to synchronize its configuration so that Envoy will have traffic sent to Istiod.\n\nThe iptables rules that this traffic passes through are as follows.\n\n\u0060pilot-agent\u0060 process -\u003e \u0060OUTPUT\u0060 -\u003e **\u0060Istio_OUTPUT\u0060 RULE 9** -\u003e Envoy 15001 (Outbound Handler) -\u003e OUTPUT -\u003e **\u0060ISTIO_OUTPUT\u0060 RULE 4** -\u003e \u0060POSTROUTING\u0060  -\u003e Istiod\n\n![Sidecar to Istiod](sidecar-istiod.svg)\n\n## Summary\n\nAll the sidecar proxies that Istio injects into the Pod or installed in the virtual machine form the data plane of the service mesh, which is also the main workload location of Istio. In my next blog, I will take you through the ports of each component in Envoy and their functions, so that we can have a more comprehensive understanding of the traffic in Istio.\n', '\/en\/blog\/istio-sidecar-traffic-types\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will show you the six traffic types and their iptables rules in Istio sidecar, and take you through the whole diagram in a schematic format.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-13/">What&#39;s New in Istio 1.13?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 28, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What\u0027s New in Istio 1.13?', 'In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.', '\nIstio 1.13 is the first release of 2022, and, not surprisingly, the Istio team will continue to release new versions every quarter. Overall, the new features in this release include:\n\n- Support for newer versions of Kubernetes\n- New API – ProxyConfig, for configuring sidecar proxies\n- Improved Telemetry API\n- Support for hostname-based load balancers with multiple network gateways\n\n### Support for Kubernetes Versions\n\nI often see people asking in the community which Istio supports Kubernetes versions. Istio’s website has a clear list of supported Kubernetes versions. You can see [here](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases) that Istio 1.13 supports Kubernetes versions 1.20, 1.21, 1.22, and 1.23, and has been tested but not officially supported in Kubernetes 1.16, 1.17, 1.18, 1.19.\n\nWhen configuring Istio, there are a lot of checklists. I noted them all in the [Istio cheatsheet](https:\/\/github.com\/tetratelabs\/istio-cheatsheet). There are a lot of cheat sheets about configuring Istio, using resources, dealing with everyday problems, etc., in this project, which will be online soon, so stay tuned.\n\nThe following screenshot is from the Istio cheatsheet website, it shows the basic cheat sheet for setting up Istio.\n\n![Istio cheatsheet](istio-cheatsheet.jpg)\n\n### Introducing the new ProxyConfig API\n\nBefore Istio version 1.13, if you wanted to customize the configuration of the sidecar proxy, there were two ways to do it.\n\n**MeshConfig**\n\nUse MeshConfig and use IstioOperator to modify it at the Mesh level. For example, use the following configuration to alter the default discovery port for istiod.\n\n\u0060\u0060\u0060yaml\napVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n\t  defaultConfig:\n      discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n**Annotation in the Pods**\n\nYou can also use annotation at the Pod level to customize the configuration. For example, you can add the following annotations to Pod to modify the default port for \u0060istiod\u0060 of the workload:\n\n\u0060\u0060\u0060yaml\nanannotations:\n  proxy.istio.io\/config: |\n    discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\nWhen you configure sidecar in either of these ways, the fields set in annotations will completely override the default fields in MeshConfig. Please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#ProxyConfig) for all configuration items of ProxyConfig.\n\n**The new API – ProxyConfig**\n\nBut in 1.13, a new top-level custom resource, ProxyConfig, has been added, allowing you to customize the configuration of your sidecar proxy in one place by specifying a namespace and using a selector to select the scope of the workload, just like any other CRD. Istio currently has limited support for this API, so please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/proxy-config\/) for more information on the ProxyConfig API.\n\nHowever, no matter which way you customize the configuration of the sidecar proxy, it does not take effect dynamically and requires a workload restart to take effect. For example, for the above configuration, because you changed the default port of istiod, all the workloads in the mesh need to be restarted before connecting to the control plane.\n\n### Telemetry API\n\n[MeshConfig](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-ExtensionProvider) customized extensions and configurations in the Istio mesh. The three pillars of observability– Metrics, Telemetry, and Logging– can each be docked to different providers. The [Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/) gives you a one-stop place for flexible configuration of them. Like the ProxyConfig API, the Telemetry API follows the configuration hierarchy of Workload Selector \u003e Local Namespace \u003e Root Configuration Namespace. The API was introduced in Istio 1.11 and has been further refined in that release to add support for OpenTelemetry logs, filtered access logs, and custom tracing service names. See [Telemetry Configuration](https:\/\/istio.io\/latest\/docs\/reference\/config\/telemetry\/) for details.\n\n### Automatic resolution of multi-network gateway hostnames\n\nIn September 2021, a member of the Istio community [reported an issue](https:\/\/szabo.jp\/2021\/09\/22\/multicluster-istio-on-eks\/) with the EKS load balancer failing to resolve when running multi-cluster Istio in AWS EKS. Workloads that cross cluster boundaries need to be communicated indirectly through a dedicated east-west gateway for a multi-cluster, multi-network mesh. You can follow the instructions on [Istio’s website](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/) to configure a multi-network, primary-remote cluster, and Istio will automatically resolve the IP address of the load balancer based on the hostname.\n\n### Istio 1.13.1 fixing the critical security vulnerabilities\n\nIstio 1.13.1 was released to fix a known [critical vulnerability](https:\/\/cve.mitre.org\/cgi-bin\/cvekey.cgi?keyword=CVE-2022-23635) that could lead to an unauthenticated control plane denial of service attack.\n\nThe figure below shows a multi-cluster primary-remote mesh where istiod exposes port 15012 to the public Internet via a gateway so that a pod on another network can connect to it.\n\n![Multi-network Mesh](multi-network-mesh.jpg)\n\nWhen installing a multi-network, primary-remote mode Istio mesh, for a remote Kubernetes cluster to access the control plane, an east-west Gateway needs to be installed in the Primary cluster, exposing port 15012 of the control plane istiod to the Internet. An attacker could send specially crafted messages to that port, causing the control plane to crash. If you set up a firewall to allow traffic from only some IPs to access this port, you will be able to reduce the impact of the problem. It is recommended that you upgrade to Istio 1.13.1 immediately to resolve the issue completely.\n\n### IstioCon 2022\n\n![IstioCon 2022](istiocon-2022.jpg)\n\nFinally, as a committee member for the last and current IstioCon, I call on everyone to register for [IstioCon 2022](https:\/\/events.istio.io\/istiocon-2022\/), which will be held online on April 25! It will be an industry-focused event, a platform to connect contributors and users to discuss the uses of Istio in different architectural setups, its limitations, and where to take the project next. The main focus on end-user companies, as we look forward to sharing a diversity of case studies showing how to use Istio in production.\n', '\/en\/blog\/what-is-new-in-istio-1-13\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-extensions-slime-and-aeraki/">Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 10, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem', 'In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.', '\nIt’s been more than [four years](https:\/\/www.tetrate.io\/blog\/happy-istio-4th-anniversary-retrospect-and-outlook\/) since Istio launched in May 2017, and while the project has had a strong following on GitHub and 10\u002b releases, its growing open-source ecosystem is still in its infancy. \n\nRecently added support for [WebAssembly extensions](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) has made the most popular open source service mesh more extensible than ever. This table lists the open-source projects in the Istio ecosystem as of November 11, 2021, sorted by open-source date. These projects enhance the Istio service mesh with gateways, extensions, utilities, and more. In this article, I’ll highlight the two new projects in the category of extensions.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\n### **Slime: an intelligent service mesh manager for Istio**\n\n[Slime](https:\/\/github.com\/slime-io\/slime) is an Istio-based, intelligent mesh manager open-sourced by NetEase’s microservices team. Based on the Kubernetes Operator implementation, Slime can be used as a CRD manager that seamlessly interfaces with Istio without needing any customization or definition of dynamic service governance policies. This achieves automatic and convenient use of Istio and Envoy’s advanced features.\n\nSlime addresses the following issues:\n\n- Implementing higher-level extensions in Istio. For example, extending the HTTP plugin; adaptive traffic limiting based on the resource usage of the service.\n- Poor performance arising from Istio sending all the configurations within the mesh to each sidecar proxy.\n\nSlime solves these problems by building an Istio management plane. Its main purpose are\n\n- to build a pluggable controller to facilitate the extension of new functions.\n- to obtain data by listening to the data plane to intelligently generate the configuration for Istio.\n- to build a higher-level CRD for the user to configure, which Slime converts into an Istio configuration.\n\nThe following diagram shows the flow chart of Istio as an Istio management plane.\n\n![Slime architecture](slime-arch.png)\n\nThe specific steps for Slime to manage Istio are as follows.\n\n1. Slime operator completes the initialization of Slime components in Kubernetes based on the administrator’s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to Kubernetes clusters.\n3. Slime queries the monitoring data of the relevant service stored in Prometheus and converts the Slime CRD into an Istio CRD, in conjunction with the configuration of the adaptive part of the Slime CRD while pushing it to the Global Proxy.\n4. Istio listens for the creation of Istio CRDs.\n5. Istio pushes the configuration information of the Sidecar Proxy to the corresponding Sidecar Proxy in the data plane.\n\nThe diagram below shows the internal architecture of Slime.\n\n![Slime Internal](slime-internal.png)\n\nWe can divide Slime internally into three main components.\n\n- **slime-boot**: operator for deploying Slime modules on Kubernetes.\n- **slime-controller**: the core component of Slime that listens to the Slime CRD and converts it to an Istio CRD.\n- **slime-metric**: the component used to obtain service metrics information. slime-controller dynamically adjusts service governance rules based on the information it receives.\n\nThe following diagram shows the architecture of Slime Adaptive Traffic Limiting.\n![Slime smart limiter](slime-smart-filter.png)\n\nSlime dynamically configures traffic limits by interfacing with the Prometheus metric server to obtain real-time monitoring.\n\nSlime’s adaptive traffic limitation process has two parts: one that converts SmartLimiter to[ EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/) and the other that monitors the data. Slime also provides an external monitoring data interface (Metric Discovery Server) that allows you to sync custom monitoring metrics to the traffic limiting component via MDS.\n\nThe CRD SmartLimiter created by Slime is used to configure adaptive traffic limiting. Its configuration is close to natural semantics, e.g., if you want to trigger an access limit for Service A with a limit of 30QPS when the CPU exceeds 80%, the corresponding SmartLimiter is defined as follows.\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  -  action:\n       fill_interval:\n         seconds: 1\n         quota: \u002230\/{pod}\u0022 # 30 is the quota for this service. If there are three pods, the limit is 10 per pod.\n       condition: \u0022{cpu}\u003e0.8\u0022 # Auto-fill the template based on the value of the monitor {cpu}\n\u0060\u0060\u0060\n\n### **Aeraki: A Non-Invasive Istio Extension Toolset**\n\n[Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) is a service mesh project open sourced by Tencent Cloud in March 2021. Aeraki provides an end-to-end cloud-native service mesh protocol extension solution that provides Istio with powerful third-party protocol extension capabilities in a non-intrusive way, supporting traffic management for Dubbo, Thrift, Redis, and private protocols in Istio. Aeraki’s architecture is shown in the following diagram.\n\n![Aeraki architecture](aeraki-architecture.png)\n\nAeraki architecture, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nAs seen in the Aeraki architecture diagram, the Aeraki protocol extension solution consists of two components.\n\n- **Aeraki**: Aeraki runs as an Istio enhancement component on the control plane, providing user-friendly traffic rule configurations to operations via CRDs. Aeraki translates these traffic rule configurations into Envoy configurations distributed via Istio to sidecar proxies on the data plane. Aeraki also acts as an RDS server providing dynamic routing to the MetaProtocol Proxy on the data plane. The RDS provided by Aeraki differs from Envoy’s RDS in that Envoy RDS primarily offers dynamic routing for the HTTP protocol, while Aeraki RDS is designed to provide dynamic routing capabilities for all L7 protocols developed on the MetaProtocol framework.\n- **MetaProtocol Proxy**: A generic L7 protocol proxy based on Envoy implementation. MetaProtocol Proxy is an extension of Envoy. It unifies the basic capabilities of service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for L7 protocols, which greatly reduces the difficulty of developing third-party protocols on Envoy and allows you to quickly create a third-party protocol plug-in based on MetaProtocol by only implementing the codec interface.\n\nBefore the introduction of MetaProtocol Proxy, if you wanted to use Envoy to implement an L7 protocol to implement routing, traffic limiting, telemetry, etc., you needed to write a complete TCP filter, which would have required a lot of work. For most L7 protocols, the required traffic management capabilities are similar, so there is no need to duplicate this work in each L7 filter implementation. The Aeraki project uses a MetaProtocol Proxy to implement these unified capabilities, as shown in the following figure.\n\n![MetaProtocol proxy](metaprotocol-proxy.png)\n\nMetaProtocol proxy, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nBased on MetaProtocol Proxy, we only need to implement the codec interface part of the code to write a new L7 protocol Envoy Filter. In addition, without adding a single line of code, Aeraki can provide configuration distribution and RDS dynamic routing configuration for this L7 protocol at the control plane.\n\n### **Make Istio work for all environments and workloads**\n\nWe have seen that NetEase and Tencent are scaling Istio mainly by building Operator. However, this scaling is not enough for multi-cluster management. We know that much of our current infrastructure is transitioning to cloud native or containerized, which means containers, virtual machines, and other environments co-exist. How do we unify traffic management of these different environments? It is possible to do so using Istio.\n\nYou have to again build a management plane on top of Istio and add an abstraction layer to add CRDs that apply to cluster management, such as cluster traffic configuration, policy configuration, etc. Additionally, you have to deploy a Gateway in each cluster that connects uniformly to an edge proxy that interconnects all the groups. \n\nTo learn more about Tetrate Service Bridge (TSB), which provides this layer of infrastructure, you can go [here](https:\/\/www.tetrate.io\/tetrate-service-bridge\/). TSB is built on the open source Istio with enhancements, it follows the concept of the above two open source projects, and also builds a management plane to support heterogeneous environments.\n\nAs we can see, the Istio-based projects and the open source environment are booming and companies like Tetrate are doing useful jobs of productizing and making Istio available to all workloads.\n\n', '\/en\/blog\/istio-extensions-slime-and-aeraki\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-servicemesh-api-gateway/">Using Istio Service Mesh as API Gateway</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Using Istio Service Mesh as API Gateway', 'What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.', '\nAPI gateways have been around for a long time as the entry point for clients to access the back-end, mainly to manage “north-south” traffic, In recent years, service mesh architectures have become popular, mainly for managing internal systems,(i.e. “east-west” traffic), while a service mesh like Istio also has built-in gateways that bring traffic inside and outside the system under unified control. This often creates confusion for first-time users of Istio. What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.\n\n## Key Insights\n\n- The service mesh was originally created to solve the problem of managing internal traffic for distributed systems, but API gateways existed long before it.\n- While the Gateway is built into Istio, you can still use a custom Ingress Controller to proxy external traffic.\n- API gateways and service mesh are converging.\n\n## How do I expose services in the Istio mesh?\n\nThe following diagram shows four approaches to expose services in the Istio mesh using Istio Gateway, Kubernetes Ingress, API Gateway, and NodePort\/LB.\n\n![Exposing services through Istio Ingress Gateway](access-cluster.svg)\n\nThe Istio mesh is shaded, and the traffic in the mesh is internal (east-west) traffic, while the traffic from clients accessing services within the Kubernetes cluster is external (north-south) traffic. \n\n| **Approach**          | **Controller**     | **Features**                                                 |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | Load balancing                                               |\n| Kubernetes Ingress    | Ingress controller | Load balancing, TLS, virtual host, traffic routing           |\n| Istio Gateway         | Istio              | Load balancing, TLS, virtual host, advanced traffic routing, other advanced Istio features |\n| API Gateway           | API Gateway        | Load balancing, TLS, virtual host, advanced traffic routing, API lifecycle management, billing, rate limiting, policy enforcement, data aggregation |\n\nSince NodePort\/LoadBalancer is a basic way to expose services built into Kubernetes, this article will not discuss that option. Each of the other three approaches will be described below.\n\n## Using Kubernetes Ingress to expose traffic\n\nWe all know that clients of a Kubernetes cluster cannot directly access the IP address of a pod because the pod is in a network plane built into Kubernetes. We can expose services inside Kubernetes outside the cluster using NodePort or Load Balancer Kubernetes service type. To support virtual hosting, hiding and saving IP addresses, you can use Ingress resources to expose services in Kubernetes.\n\n![Kubernetes Ingress to expose services](ingress.svg)\n\nIngress is a Kubernetes resource that controls the behavior of an ingress controller that does the traffic touring, which is the equivalent of a load-balanced directional proxy server such as Nginx, Apache, etc., which also includes rule definitions, i.e., routing information for URLs, which is provided by the [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers).\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\nThe *kubernetes.io\/ingress.class: istio* annotation in the example above indicates that the Ingress uses the Istio Ingress Controller which in fact uses Envoy proxy. \n\n## Using Istio Gateway to expose services\n\nIstio is a popular service mesh implementation that has evolved from Kubernetes that implements some features that Kubernetes doesn’t. (See [What is Istio and why does Kubernetes need Istio?](https:\/\/www.tetrate.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)) It makes traffic management transparent to the application, moving this functionality from the application to the platform layer and becoming a cloud-native infrastructure.\n\nIstio used Kubernetes Ingress as the traffic portal in versions prior to Istio 0.8, where Envoy was used as the Ingress Controller. From Istio 0.8 and later, Istio created the Gateway object. Gateway and VirtualService are used to represent the configuration model of Istio Ingress, and the default implementation of Istio Ingress uses the same Envoy proxy. In this way, the Istio control plane controls both the ingress gateway and the internal sidecar proxy with a consistent configuration model. These configurations include routing rules, policy enforcement, telemetry, and other service control functions.\n\nThe Istio Gateway resources function similarly to the Kubernetes Ingress in that it is responsible for north-south traffic to and from the cluster. The Istio Gateway acts as a load balancer to carry connections to and from the edge of the service mesh. The specification describes a set of open ports and the protocols used by those ports, as well as the SNI configuration for load balancing, etc.\n\nThe Istio Gateway resource itself can only be configured for L4 through L6, such as exposed ports, TLS settings, etc.; however, the Gateway can be bound to a VirtualService, where routing rules can be configured on L7, such as versioned traffic routing, fault injection, HTTP redirects, HTTP rewrites, and all other routing rules supported within the mesh.\n\nBelow is an example of a Gateway binding to a VirtualService. The pod with the “istio: ingressgateway” label will act as the Ingress controller and route HTTP traffic to port 80 of the httpbin.example.com virtual host. The biggest difference between this and using Kubernetes Ingress is that it requires us to manually bind the VirtualService to the Gateway and specify the pod where the Gateway is located. This configuration is equivalent to opening up an entry point to Kubernetes for external access.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\nThe VirtualService below is bound to the gateway above via *gateways* to accept traffic from that gateway.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## Using an API Gateway\n\nAPI gateways are API management tools that sit between the client and the back-end service and are widely used in microservices as a way to separate the client interface from the back-end implementation. When a client makes a request, the API gateway breaks it down into multiple requests, then routes them to the correct location, generates a response, and keeps track of everything. \n\nThe API Gateway is a special type of service in the microservices architecture that serves as the entry point for all microservices and is responsible for performing routing requests, protocol conversions, aggregating data, authentication, rate limiting, circuit breaking, and more. Most enterprise APIs are deployed through API Gateways, which typically handle common tasks across API service systems, such as TLS termination, authentication and authorization, rate limiting, and statistical information.\n\nThere can be one or more API Gateways in the mesh. The responsibilities of the API Gateway are\n\n- Request routing and version control\n- Facilitating the transition of monolithic applications to microservices\n- Permission authentication\n- Data aggregation: monitoring and billing\n- Protocol conversion\n- Messaging and caching\n- Security and alerting\n\nMany of the above basic functions such as routing and permission authentication can also be achieved through Istio Gateway, but some mature API gateways may be more advantageous in terms of feature richness and scalability.\n\n- The introduction of API Gateway requires consideration of the deployment, operation and maintenance, load balancing, and other scenarios of API Gateway itself, which increases the complexity of back-end services.\n- An API Gateway carries a large number of interface adaptations, which makes it difficult to maintain.\n- For some scenarios, the addition of a hop may lead to a reduction in performance.\n\nCurrently, some API Gateway imitations are building their own service mesh by deploying them in the sidecar.\n\n## Summary\n\nIn the Istio mesh, you can use a variety of Kubernetes Ingress Controllers to act as entry gateways, but of course, you can also use Istio’s built-in Istio Gateway directly, for policy control, traffic management, and usage monitoring. The advantage of this is that the gateway can be managed directly through Istio’s control plane, without the need for additional tools. But for functions such as API statement cycle management, complex billing, protocol conversion, and authentication, a traditional API gateway may be a better fit for you. So, you can choose according to your needs, or you can use a combination.\n\nSome traditional reverse proxies are also moving towards Service Mesh, such as Nginx with Nginx Service Mesh and Traefik with Traefik Mesh, and some API gateway products are also moving towards Service Mesh, such as Kong with Kuma, and in the future, we will see more convergence of API gateways, reverse proxies, and service meshes.\n', '\/en\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multicluster-management-with-kubernetes-and-istio/">Multicluster Management With Kubernetes and Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 12, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multicluster Management With Kubernetes and Istio', 'This article explains three patterns\/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.', '\nDo you have multiple Kubernetes clusters and a service mesh? Do your virtual machines and services in a Kubernetes cluster need to interact? This article will take you through the process and considerations of building a hybrid cloud using Kubernetes and an Istio Service Mesh. Together, Kubernetes and Istio can be used to bring hybrid workloads into a mesh and achieve interoperability for multicluster. But another layer of infrastructure — a management plane — is helpful for managing multicluster or multimesh deployments.\n\n## Kubernetes\n\nUsing Kubernetes enables rapid deployment of a distributed environment that enables cloud interoperability and unifies the control plane on the cloud. It also provides resource objects, such as Service, Ingress and [Gateway](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/), to handle application traffic. The Kubernetes API Server communicates with the kube-proxy component on each node in the cluster, creates iptables rules for the node, and forwards requests to other pods.\n\nAssuming that a client now wants to access a service in Kubernetes, the request is first sent to the Ingress\/Gateway, then forwarded to the backend service (Service A in the diagram below) based on the routing configuration in the Ingress\/Gateway. Then Service A polls an instance of Service B for the traffic requested by Service B. Lastly, the traffic requested by Service A for Service B is polled forward to Service B’s instance.\n\n![Kubernetes](008i3skNly1gsgg6a11l1j31lu0u042s.jpg)\n\n## Kubernetes Multicluster\n\nThe most common usage scenarios for multicluster management include:\n\n- service traffic load balancing\n- isolating development and production environments\n- decoupling data processing and data storage\n- cross-cloud backup and disaster recovery\n- flexible allocation of compute resources\n- low-latency access to services across regions\n- avoiding vendor lock-in\n\nThere are often multiple Kubernetes clusters within an enterprise; and the [KubeFed](https:\/\/github.com\/kubernetes-sigs\/kubefed) implementation of Kubernetes cluster federation developed by [Multicluster SIG](https:\/\/github.com\/kubernetes\/community\/blob\/master\/sig-multicluster\/README.md) enables multicluster management capabilities, which allows all Kubernetes clusters to be managed through the same interface.\n\nThere are several general issues that need to be addressed when using cluster federation:\n\n- Configuring which clusters need to be federated\n- API resources need to be propagated across the clusters\n- Configuring how API resources are distributed to different clusters\n- Registering DNS records in clusters to enable service discovery across clusters\n\nThe following is a multicluster architecture for [KubeSphere](https:\/\/kubesphere.io\/) — one of the most commonly used Kubernetes multicluster management architectures — where the Host Cluster serves as the control plane with two member clusters, West and East.\n\n![Multicluster](008i3skNly1gsgg7a2ojvj31aa0u0491.jpg)\n\nThe Host Cluster needs to be able to access the API Server of the Member Cluster, but the network connectivity between Member Clusters is not required. The Host Cluster is independent of the Member Cluster it manages and the Member Cluster is not aware of the existence of the Host Cluster. The advantage of this is that when the control plane fails, the Member Cluster will not be affected and the deployed load can still operate normally without being affected.\n\nThe Host Cluster also assumes the role of API portal, and the Host Cluster forwards the resource requests to the Member Cluster — which is convenient for aggregation and also facilitates unified authority authentication. We see that there is a Federation Control Plane in the Host Cluster, where the Push Reconciler propagates the identity, role, and role binding from the Federation Cluster to all Member Clusters.\n\n## Istio Service Mesh\n\nConsider using the Istio service mesh when we have multilingual, multiversion microservices running in Kubernetes and need finer-grained canary publishing and unified security policy management for inter-service observability. Istio enables intelligent application-aware load balancing from the application layer to other Service Mesh-enabled services in the cluster, by transparently intercepting all traffic to and from the application using IPTables, and bypassing the primary kube-proxy load balancing. The Istio control plane communicates with the Kubernetes API Server to obtain information about all registered services in the cluster.\n\nThe following diagram illustrates the basics of Istio, where all nodes belong to the same Kubernetes cluster.\n\n![Istio Service Mesh](008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg)\n\nYou may end up with at least a few Kubernetes clusters, each hosting microservices. Multiple [deployment models](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/) exist for Istio’s multicluster deployments — depending on network isolation, primary and backup — which can be specified by declaration when deploying using Istio Operator. Communication between these microservices in a cluster can be enhanced by a service mesh. Within the cluster, Istio provides common communication patterns to improve resiliency, security and observability.\n\nAll of the above is about application load management on Kubernetes, but for legacy applications on virtual machines: how can they be managed in the same plane? Istio supports applications on virtual machines, so why do we need a management plane?\n\n## Management Plane\n\nTo manage gateways, traffic and security groupings, and apply them to different clusters and namespaces, you’ll need to add another layer of abstraction on top of Istio: a management plane. The diagram below shows the multitenant model of Tetrate Service Bridge (TSB). TSB uses Next Generation Access Control (NGAC) — a fine-grained authorization framework — to manage user access and also facilitate the construction of a zero-trust network.\n\n![Management Plane](008i3skNly1gsgg8ndcajj31il0u00z9.jpg)\n\nIstio provides workload identification, protected by strong mTLS encryption. This zero-trust model is better than trusting workloads based on topology information, such as source IP. A common control plane for multicluster management is built on top of Istio. Then a management plane is added to manage multiple clusters — providing multitenancy, management configuration, observability, and more.\n\nThe diagram below shows the architecture of Tetrate Service Bridge.\n\n![Tetrate Service Bridge](008i3skNly1gsgg951mknj314g0u0dnf.jpg)\n\n## Summary\n\nInteroperability of heterogeneous clusters is achieved with Kubernetes. Istio brings containerized and virtual machine loads into a single control plane, to unify traffic, security and observability within the clusters. However, as the number of clusters, network environments and user permissions become more complex, there is a need to build another management plane above Istio’s control plane (for example, [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)) for hybrid cloud management.\n', '\/en\/blog\/multicluster-management-with-kubernetes-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains three patterns/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/">How to Debug Microservices in Kubernetes With Proxy, Sidecar or Service Mesh?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 5, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Debug Microservices in Kubernetes With Proxy, Sidecar or Service Mesh?', 'This article explains three patterns\/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.', '\nKubernetes is arguably the best environment for running microservices so far, but the experience of debugging microservices in a Kubernetes environment may not be as user-friendly. This article will show you how to debug microservices in Kubernetes, introduce common tools, and explain how the introduction of Istio impacts debugging microservices.\n\n## Debugging microservices is vastly different from traditional monolithic applications\n\nThe debugging of microservices has been a long-standing problem for software developers. This challenge does not exist in traditional monolithic applications because developers can leverage the debugger in IDEs to add breakpoints, modify environment variables, single-step execution, etc. for their applications, all of which provide great help in software debugging. With the popularity of Kubernetes, the debugging of microservices becomes a thorny issue, where the following issues are more complicated than the debugging of traditional monolithic applications.\n\n### Multiple dependencies\n\nA microservice often depends on multiple other microservices, some shared volumes across multiple microservices, and authorizations based on service accounts. When debugging a microservice, how do you deploy other dependent services to quickly build a latest set of staging environments?\n\n### Access from a local machine\n\nWhen microservices are running on a developer’s local computer, there is usually no direct access to the services in a Kubernetes cluster. How can you debug microservices deployed in a Kubernetes cluster as if they were local services?\n\n### Slow development loop\n\nUsually, it takes a long process to update the code and build it into an image before pushing it to the cluster. How do you speed up the development cycle? Let’s look at the tools that address those challenges.\n\n## Tools\n\nThe main solutions for debugging microservices in Kubernetes are:\n\n- Proxy: by building a VPN, deploying a proxy in the Kubernetes cluster, and adding local debug endpoints to make the services in Kubernetes directly accessible to local applications, your architecture will look like [ local service ] \u003c-\u003e [ proxy ] \u003c-\u003e [ app in Kubernetes ].\n- Sidecar: Inject a sidecar into the pod of the microservice to be debugged to intercept all traffic to and from the service, so that the service can be tracked and monitored, and the service can also be debugged in this sidecar.\n- Service Mesh: To get an overall picture of the application, inject sidecars into all microservices so that you can get a dashboard that monitors global status.\n\nHere are three typical open source projects that implement the above solutions, each of which can help you debug microservices from a different perspective. You can apply them at different stages of software development and they can be said to be complementary to each other.\n\n### Proxy – debugging microservices with Telepresence\n\n[Telepresence](https:\/\/www.telepresence.io\/) is essentially a local proxy that proxies data volumes, environment variables, and networks in a Kubernetes cluster locally. The following diagram shows the main usage scenarios for Telepresence.\n\n![Proxy mode: Telepresence](telepresence.jpg)\n\nUsers need to manually execute the telepresence command locally, which will automatically deploy the agent to Kubernetes. Once the agent has been deployed,\n\n- Local services will have complete access to other services in the Kubernetes cluster, environment variables, Secret, ConfigMap, etc.\n- Services in the cluster also have direct access to the locally exposed endpoints.\n\nHowever, this approach requires users to run multiple commands while debugging locally, and in some network environments it may not be possible to establish a VPN connection to the Kubernetes cluster.\n\n### Sidecar – debugging microservices with Nocalhost\n\n[Nocalhost](https:\/\/nocalhost.dev\/) is a Kubernetes-based cloud development environment. To use it, you just need to install a plugin in your IDE – VS Code to extend Kubernetes and shorten the development feedback cycle. The development environment can be isolated by creating different namespaces for different users and using ServiceAccount when binding to different user corners. Nocalhost also provides a web console and API for administrators to manage different development environments.\n\n![Sidecar mode: Nocalhost](sidecar-nocalhost.jpg)\n\nAs long as you have a Kubernetes cluster and have admin rights to the cluster, you can refer to the Nocalhost documentation to quickly start trying it out. To use the Nocalhost plugin in VS Code, you need to configure the Kubernetes cluster in the plugin first.\n\n1. Select the Kubeconfig file you just exported or copy and paste the contents of the file directly into the configuration.\n2. Then select the service you need to test and select the corresponding Dev Container. VS Code will automatically open a new code window.\n\nHere is an example of the [bookinfo sample](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) provided by Istio. You can open the cloned code in your local IDE and click the hammer next to the code file to enter development mode. Selecting the corresponding DevContainer and Nocalhost will automatically inject a development container sidecar into the pod and automatically enter the container in the terminal, as shown in the following figure.\n\n![Nocalhost VS code](nocalhost-vs-code.jpg)\n\nIn development mode, the code is modified locally without rebuilding the image, and the remote development environment takes effect in real time, which can greatly accelerate the development speed. At the same time, Nocalhost also provides a server for managing the development environment and user rights, as shown in the following figure.\n\n![Nocalhost Web](nocalhost-web-admin.jpg)\n\n### Service Mesh – debugging microservices with Istio\n\nThe above method of using proxy and sidecar can only debug one service at a time. You’ll need a mesh to get the global status of the application, such as the metrics of the service obtained, and debug the performance of the service by understanding the dependency and invocation process of the service through distributed tracing. These observability features need to be implemented by injecting sidecar uniformly for all services. And, when your services are in the process of migrating from VMs to Kubernetes, using Istio can bring VMs and Kubernetes into a single network plane (as shown below), making it easy for developers to debug and do incremental migrations.\n\n![Service Mesh mode: Istio](istio-service-mesh.jpg)\n\nOf course, these benefits do not come without a “cost.” With the introduction of Istio, your Kubernetes services will need to adhere to the Istio naming convention and you’ll need to know how to debug microservices using the Istioctl command line and logging.\n\n- Use the *istioctl analyze* command to debug the deployment of microservices in your cluster, and you can use YAML files to examine the deployment of resources in a namespace or across your cluster.\n- Use *istioctl proxy-config secret* to ensure that the secret of a pod in a service mesh is loaded correctly and is valid.\n\n## Summary\n\nIn the process of microservicing applications and migrating from virtual machines to Kubernetes, developers need to make a lot of changes in their mindset and habits. By building a VPN between local and Kubernetes via proxy, developers can easily debug services in Kubernetes as if they were local services. By injecting a sidecar into the pod, you can achieve real-time debugging and speed up the development process. Finally, the Istio service mesh truly enables global observability, and you can also use tools like [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) to manage heterogeneous platforms, helping you gradually move from monolithic applications to microservices.\n', '\/en\/blog\/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains three patterns/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/en/categories/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/en/categories/istio/page/3/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/categories/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/categories/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/categories/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/categories/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/categories/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/categories/istio/page/5/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/categories/istio/page/5/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(44)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-tracing/">How the Envoy Proxy Handles User Requests for Tracing</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/introducing-kmesh-kernel-native-service-mesh/">Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
