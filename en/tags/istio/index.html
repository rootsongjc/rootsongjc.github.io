<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/istio/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-l7-flow-analysis/">Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 9, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy', 'An in-depth exploration of Istio ambient mode’s L7 traffic path, covering transparent interception, policy application, and traffic forwarding from ztunnel to waypoint proxy.', '\nIn Istio\u0027s ambient mode, **ztunnel** acts as a node-level security proxy responsible for L4 traffic interception and encryption between services. However, ztunnel doesn’t handle L7 tasks such as HTTP-based routing or policy enforcement. For L7 traffic management, **waypoint proxy**, powered by Envoy, processes HTTP requests and applies L7 policies. When ztunnel detects traffic requiring L7 processing, it forwards the traffic using the **HBONE protocol** to the waypoint proxy. The proxy applies policies, logs telemetry data, and forwards requests to the target Pod through ztunnel.\n\nThis post details this traffic forwarding path, breaking down how L7 traffic flows from **ztunnel** to **waypoint proxy** and ultimately to the target Pod.\n\n## Roles and Responsibilities in Ambient Mode\n\n### ztunnel (L4 Traffic Manager)\n\n- Intercepts traffic at L4 (TCP) level.\n- Secures traffic using mTLS encryption and authenticates service identities.\n\n### Waypoint Proxy (L7 Traffic Manager)\n\n- Manages L7 traffic policies such as HTTP routing, authentication, authorization, and telemetry.\n- Acts as an application-aware proxy, applying business-specific policies and sending metrics to the observability stack.\n\nWhen a request requires L7 handling (e.g., \u0060productpage\u0060 service calling \u0060reviews-v1\u0060), **ztunnel** **forwards traffic to waypoint proxy using HBONE**, enabling transparent policy application and telemetry collection.\n\n## L7 Traffic Path in Ambient Mode\n\nThe following diagram illustrates the L7 traffic path in Istio ambient mode:\n\n\u0060\u0060\u0060mermaid \u0022L7 Traffic Path in Ambient Mode\u0022\nsequenceDiagram\n    participant SP as Source Pod (productpage)\n    participant ZT1 as ztunnel (Source Node)\n    participant WP as Waypoint Proxy\n    participant ZT2 as ztunnel (Target Node)\n    participant DP as Target Pod (reviews-v1)\n\n    SP-\u003e\u003eZT1: HTTP Request (HTTP\/1.1)\n    Note over SP,ZT1: Traffic intercepted by ztunnel\n    ZT1-\u003e\u003eWP: Forward as HBONE Request (mTLS)\n    Note over ZT1,WP: Transparent interception \u0026 encryption\n    WP-\u003e\u003eZT2: Forward after applying L7 policies (mTLS)\n    Note over WP,ZT2: L7 policy applied and forwarded\n    ZT2-\u003e\u003eDP: Deliver to application port (TCP)\n    Note over ZT2,DP: Traffic redirected at target node\n    DP--\u003e\u003eZT2: Send back the response (TCP)\n    Note over DP,ZT2: Response generated by application\n    ZT2-\u003e\u003eWP: Forward response as HBONE (mTLS)\n    WP-\u003e\u003eZT1: Return response after applying policies (mTLS)\n    Note over WP,ZT1: Policy-applied response data\n    ZT1-\u003e\u003eSP: Return response (HTTP\/1.1)\n    Note over ZT1,SP: Response delivered back to application\n\u0060\u0060\u0060\n\n![L7 Traffic Path in Ambient Mode](447f9e24cd3cc95eb700cbd7e0b62816.svg)\n\nThe following two pictures respectively show the L7 traffic processing paths of the source Pod and the destination Pod in the same node and cross-node scenarios.\n\n![L7 traffic path of source pod and destination pod on the same node](hbone-same-node.svg)\n\n![L7 traffic path of source pod and destination pod on different nodes](hbone-cross-node.svg)\n\n### Traffic Path Breakdown\n\n### **1. Application Request Sent**\n\nThe \u0060productpage\u0060 service initiates an HTTP request to the \u0060reviews-v1\u0060 service at \u0060reviews.default.svc.cluster.local:9080\u0060.\n\n### 2. ztunnel L4 Traffic Interception\n\nZtunnel on the source node intercepts the outbound request from \u0060productpage\u0060 using Kubernetes’ \u0060iptables\u0060 rules. It inspects Istio\u0027s control plane configuration and determines that L7 policies must be applied.\n\n### 3. Forwarding Traffic Using HBONE Protocol\n\nZtunnel uses **HBONE protocol** instead of native Envoy-to-Envoy XDS or TCP\u002bmTLS tunneling. HBONE (HTTP-Based Overlay Network Environment) encapsulates traffic in HTTP\/2, enabling transparent forwarding of traffic for L7 processing.\n\nztunnel wraps the intercepted traffic into an HBONE tunnel and forwards it to waypoint proxy.\n\n### 4. L7 Processing and Policy Enforcement by Waypoint Proxy\n\nWaypoint proxy, built on Envoy, verifies the downstream client\u0027s mTLS credentials using SPIFFE IDs and contextual metadata for authentication. It then applies the following policies:\n\n- **HTTP Routing \u0026 Load Balancing:** Routes requests based on Host\/Path headers.\n- **Authorization Policies:** Validates access through headers and tokens.\n- **Traffic Shaping:** Injects faults, rate-limits requests, and implements retries.\n- **Telemetry Collection:** Tracks metrics, logs, traces, and request durations.\n\nWaypoint proxy forwards the processed traffic through HBONE to the target node’s ztunnel.\n\n### 5. Delivering Traffic to Target Pod\n\nztunnel on the target node receives traffic from waypoint proxy through HBONE, decapsulates the request, and forwards it to the target Pod (\u0060reviews-v1\u0060) on its application port.\n\n### Insights and Key Takeaways\n\n### 1. Transparent Routing via Waypoint Proxy\n\n- **Waypoint proxy** only knows the target Pod’s IP address and rewritten port \u006015008\u0060.\n- **ztunnel** manages traffic redirection using Kubernetes \u0060iptables\u0060.\n\n### 2. End-to-End Security\n\n- Mutual TLS (mTLS) with SPIFFE ID validation ensures secure traffic transmission.\n- Traffic **cannot bypass ztunnel**, enforcing a **Zero Trust Architecture**.\n\n### 3. Transparent Policy Enforcement\n\n- Developers don’t need to change the application code.\n- Traffic control, security, and telemetry are fully automated at the data plane level.\n\n## **How to Debug Ambient Mode?**\n\n### 1. ztunnel Debugging\n\nUse \u0060istioctl ztunnel\u0060 to inspect ztunnel configurations and states.\n\n### **2. Waypoint Proxy Debugging**\n\n- Use Envoy-specific commands such as \u0060istioctl pc\u0060 and \u0060istioctl ps\u0060 to inspect Envoy proxy configurations.\n- Use \u0060istioctl waypoint\u0060 for streamlined configuration inspection.\n\n## Conclusion\n\nIstio ambient mode uses **ztunnel** for L4 traffic processing, including transparent interception, mTLS encryption, and forwarding. L7 tasks such as HTTP-based routing, policy enforcement, and telemetry collection are managed by **waypoint proxy**, with communication between ztunnel and waypoint proxy facilitated by **HBONE protocol**.\n\nThis innovative design eliminates sidecars, simplifying operations while maintaining high performance, security, and observability.\n', '\/en\/blog\/istio-ambient-l7-flow-analysis\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth exploration of Istio ambient mode’s L7 traffic path, covering transparent interception, policy application, and traffic forwarding from ztunnel to waypoint proxy.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/http2-envoy-tunnel-demo/">Implementing HTTP/2 CONNECT Tunnels with Envoy: Concepts and Practical Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Feb 4, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Implementing HTTP\/2 CONNECT Tunnels with Envoy: Concepts and Practical Guide', 'A deep dive into creating transparent tunnels using HTTP\/2 CONNECT, including technical principles, practical workflows, and example code.', '\nAs part of my recent exploration into Istio Ambient mode, I discovered that the HTTP\/2 CONNECT method is a core technology for creating tunnels that enable transparent traffic interception and forwarding. HTTP\/2 CONNECT tunnel is a powerful tool that can create an efficient tunnel in an existing HTTP\/2 connection for transmitting raw TCP data. This article shows how to implement the basic functions of the HTTP\/2 CONNECT tunnel using Envoy through a simple Demo.\n\n## What Is HTTP\/2 CONNECT and HBONE Tunnel?\n\nThe HTTP\/2 CONNECT method provides a standardized approach for creating tunnels to transparently transmit data. In Istio Ambient mode, it offers an efficient way for proxy data planes to communicate. HBONE (HTTP-Based Overlay Network Environment) tunnel, built on HTTP\/2 CONNECT, is Istio’s implementation for transparent traffic interception and forwarding. Using HBONE, data can securely traverse the tunnel via HTTP\/2, offering a sidecar-less alternative. This innovative design simplifies the management and deployment of service meshes.\n\nHBONE, specific to Istio, is a secure tunneling protocol for communication between Istio components. Its current implementation incorporates three open standards:\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT establishes the tunnel, mTLS encrypts the connection, and HTTP\/2 multiplexes streams within the secure tunnel while transmitting stream-level metadata. For more details, see the [HBONE documentation](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/).\n\n## Basic Principles of HTTP\/2 CONNECT Tunnel Creation\n\nThe HTTP\/2 CONNECT method creates a VPN-like tunnel for secure data transmission. The basic steps are as follows:\n\n1. The client sends a standard TCP or HTTP request to the proxy.\n2. The proxy sends an HTTP\/2 CONNECT request to the target server on behalf of the client.\n3. If the server allows tunnel creation, it responds with an HTTP\/2 200 OK.\n5. Data flows bidirectionally between the client, proxy, and server through the tunnel.\n\nThis method ensures secure and transparent data transmission, particularly suited for scenarios requiring efficient communication and end-to-end encryption.\n\nBelow is a diagram showing the basic process of creating a tunnel using the HTTP\/2 CONNECT method:\n\n\u0060\u0060\u0060mermaid \u0022The basic process of establishing a tunnel using the HTTP2 Connect method\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: Standard TCP Request\n    Proxy-\u003e\u003eServer: CONNECT Request (HTTP\/2 CONNECT)\n    Server--\u003e\u003eProxy: HTTP\/2 200 OK\n    Proxy--\u003e\u003eClient: Forward 200 OK\n    Client-\u003e\u003eProxy: Start Data Transmission\n    Proxy-\u003e\u003eServer: Forward Data\n    Server-\u003e\u003eProxy: Return Processed Data\n    Proxy-\u003e\u003eClient: Forward Processed Data\n\u0060\u0060\u0060\n\n![The basic process of establishing a tunnel using the HTTP2 Connect method](6c8637147d93c860174fe0df8b21a0b3.svg)\n\n\n\n## Demo: Establishing an HTTP\/2 CONNECT Tunnel with Envoy\n\nIn this demo:\n\n- The **client** sends a text message to the **Envoy proxy**, which forwards it to the **server** through an **HTTP\/2 CONNECT tunnel**.\n- The **server** processes and replies to the message, with **Envoy** facilitating secure communication.\n- The **client** remains unaware of the tunnel\u0027s existence, experiencing a seamless connection.\n\nBelow is the architecture for this demo. To simplify the setup, we will configure TLS only for the server:\n\n\u0060\u0060\u0060mermaid \u0022Architecture Diagram\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![Architecture Diagram](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n### Directory Structure\n\nThe complete directory structure of this example is as follows:\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### Key Steps in the Demo Setup\n\n1. **Generate Certificates:** Create self-signed certificates using OpenSSL.\n2. **Configure Envoy:** Define Envoy settings to accept client TCP connections and establish tunnels with the server.\n3. **Implement the Server:** Use Node.js to build an HTTP\/2 server that processes client messages.\n4. **Implement the Client:** Use Node.js to build a client that sends messages to the Envoy proxy.\n5. **Deploy Services:** Use Docker Compose to orchestrate Envoy and the server.\n6. **Test Communication:** Verify message flow from client to server and back through the HTTP\/2 CONNECT tunnel.\n\nBy following this guide, you can establish efficient, transparent, and secure traffic tunnels using HTTP\/2 CONNECT, a cornerstone of Istio\u0027s Ambient mode and HBONE technology.\n\n### Environment Preparation\n\n#### 1. Install Node.js\n\nEnsure that **Node.js** (version \u003e= **10.10.0**) is installed on your system, as the \u0060http2\u0060 module became stable starting with this version.\n\n- **Download Link:** [Node.js Official Website](https:\/\/nodejs.org\/)\n\n#### 2. Install Docker and Docker Compose\n\n- **Docker Download Link:** [Docker Official Website](https:\/\/www.docker.com\/get-started)\n- **Docker Compose Download Link:** [Docker Compose Official Documentation](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. Create a Project Directory\n\nCreate a new directory in your workspace and navigate to it:\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### Generating a Self-Signed Certificate\n\nTo enable encrypted communication between Envoy and the server, we need to generate a self-signed certificate with the correct configuration.\n\n#### 1. Create the Certificates Directory and OpenSSL Configuration File\n\nCreate the \u0060certs\u0060 directory:\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\nCreate an \u0060openssl.cnf\u0060 file with the following content:\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. Generate the Key and Certificate\n\nRun the following command to generate the key and certificate:\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\nThis will generate the \u0060server.key\u0060 and \u0060server.crt\u0060 files in the \u0060certs\u0060 directory.\n\n### Configuring the Envoy Proxy\n\nWe need to configure Envoy to accept plain TCP connections from the client and forward the data to the server through an HTTP\/2 CONNECT tunnel.\n\n#### 1. Create the Envoy Configuration File\n\nIn the project root directory, create a file named \u0060envoy.yaml\u0060 with the following content:\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. Key Highlights of the Configuration\n\n- **TCP Proxy Listener:** Listens for incoming TCP connections on port \u006010000\u0060 and forwards traffic to the upstream server.\n- **HTTP\/2 Tunnel:** Configures Envoy to use HTTP\/2 CONNECT for tunneling traffic to the server.\n- **TLS Encryption:** Enables secure communication between Envoy and the upstream server using the generated \u0060server.crt\u0060 and \u0060server.key\u0060.\n- **Access Logs:** Configures detailed logs for request and response metrics.\n\nNext, proceed to set up the server and client components to test the tunnel functionality.\n\n### Implementing the Server\n\n#### 1. Create the Server Directory and Files\n\nCreate the \u0060server\u0060 directory in the project root:\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\nInside the \u0060server\u0060 directory, create \u0060server.js\u0060 and \u0060Dockerfile\u0060.\n\n#### 2. Write \u0060server.js\u0060\n\nAdd the following code to \u0060server\/server.js\u0060:\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ Respond with 200 to establish the tunnel\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ Handle data within the tunnel\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ Respond to the client\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ Return 404 for non-CONNECT requests\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\n\/\/ Start the server and listen on port 8080\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**Notes:**\n\n- It listens for the \u0060secureConnection\u0060 event to process TLS-secured sockets.\n- The server reads incoming data from the socket, processes client messages, and sends responses.\n\n#### 3. Create the \u0060Dockerfile\u0060\n\nAdd the following content to \u0060server\/Dockerfile\u0060:\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### Implementing the Client\n\n#### 1. Create the Client Directory and Files\n\nCreate the \u0060client\u0060 directory in the project root:\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\nInside the \u0060client\u0060 directory, create \u0060client.js\u0060.\n\n#### 2. Write \u0060client.js\u0060\n\nAdd the following code to \u0060client\/client.js\u0060:\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ Create a TCP connection to Envoy\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ Send messages to the server\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ Close the connection\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**Explanation:**\n\n- The **client** establishes a standard TCP connection with **Envoy** and sends text messages.\n- This client\u0027s existence only triggers Envoy to establish a tunnel with the server.\n\n### Creating the Docker Compose File\n\nCreate \u0060docker-compose.yml\u0060 in the project root:\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # Mount the certificates directory\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # Mount the certificates directory\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\nThis configuration sets up both the Envoy proxy and the server to operate within the same Docker network, facilitating seamless communication.\n\n### Running the Example\n\n#### 1. Start Docker Compose\n\nIn the project root directory, run:\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**Expected Output:**\n\n- **Envoy Container:** Displays startup information and debug logs.\n- **Server Container:** Displays \u0060Secure HTTP\/2 server is listening on port 8080\u0060.\n\n#### 2. Run the Client\n\nOpen a new terminal, navigate to the \u0060client\u0060 directory:\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\nRun the client:\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**Expected Output:**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. Check Server Logs\n\nIn the Docker Compose output, you should see logs from the server:\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. Check Envoy Logs\n\nIn Envoy’s logs, you can see records of the connection established with the server using the **HTTP\/2 CONNECT tunnel**.\n\n### Testing the Communication\n\n- **The client** sends text messages to **Envoy** over a TCP connection.\n- **Envoy** forwards the client’s TCP traffic to the **server** via an **HTTP\/2 CONNECT tunnel**.\n- **The server** receives the messages, processes them, and replies to the client.\n- **Envoy** relays the server’s responses back to the **client** through the tunnel.\n- **The client** receives the responses from server.\n\n### Notes\n\n- **Certificate Management:** Ensure the certificates are properly configured and used in both Envoy and the server.\n- **Docker Networking:** Use Docker Compose-defined networks to allow containers to communicate using service names.\n- **Port Conflicts:** Ensure ports \u006010000\u0060 (Envoy) and \u00608080\u0060 (server) are not occupied.\n- **TLS Configuration:** In this example, communication between Envoy and the server is secured with TLS and HTTP\/2.\n\n## Tunnel Establishment Process\n\nThe following diagram illustrates the interaction between the client, Envoy proxy, and server, showing how data is transmitted and the tunnel connection is established:\n\n\u0060\u0060\u0060mermaid \u0022Tunnel Establishment Process\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% Client connects to Envoy via TCP\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy creates a new TCP proxy session\nNote over Envoy: Create new TCP proxy session (ConnectionId: 0)\n\n%% Envoy connects to the upstream server\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: Attempt to establish new connection (ConnectionId: 1)\n\n%% Envoy establishes HTTP\/2 connection with the server\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy establishes the HTTP\/2 CONNECT tunnel\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: Tunnel established successfully\n\n%% Client sends data\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% Client closes the connection\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: Tunnel closed\nNote over Envoy,Client: Connection closed\n\n%% Log connection closure\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![Tunnel Establishment Process](e2f47e2631af2b2e8f72dadc4f82fe94.svg)\n\n\n\nExplanation:\n\n1. **Client connects to Envoy via TCP:**\n   - The client sends a TCP connection request to Envoy.\n   - Envoy accepts the connection and creates a new TCP proxy session (ConnectionId: 0).\n\n2. **Envoy establishes a connection with the server:**\n   - Envoy connects to the upstream cluster \u0060tunnel_cluster\u0060, creating a new connection (ConnectionId: 1).\n\n3. **Establishing the HTTP\/2 CONNECT tunnel:**\n   - Envoy establishes an HTTP\/2 connection with the server.\n   - Envoy sends an HTTP\/2 CONNECT request with the target hostname \u0060server:8080\u0060.\n   - The server responds with \u0060200 OK\u0060, successfully establishing the tunnel.\n\n4. **Data transmission:**\n   - **Message exchange loop:**\n     - The client sends data (\u0060Message N\u0060) to Envoy.\n     - Envoy forwards the data through the tunnel to the server.\n     - The server processes the data and responds (\u0060Echo Message N\u0060).\n     - Envoy forwards the response back to the client.\n   - **Logging:**\n     - The server logs each received message, e.g., \u0060Received from client: Message N from client!\u0060.\n\n5. **Closing the connection:**\n   - The client sends a FIN request to close the connection.\n   - Envoy forwards the FIN request to the server, closing the tunnel.\n   - The server acknowledges the FIN with an ACK.\n   - Envoy sends the ACK to the client, completing the connection closure.\n\n6. **Logging:**\n   - Envoy logs the closure of connections, including ConnectionId and stats.\n   - The server logs the closure, e.g., \u0060Stream ended by client.\u0060.\n\n## Conclusion\n\nAlthough this is an introductory example, it provides a solid foundation for understanding and further exploring the HTTP\/2 CONNECT tunnel function. In the next blog, I will explain the tunnel implemented by two Envoy proxies and take you to further understand the HBONE transparent tunnel in the Istio ambient mode.\n\n## References\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n', '\/en\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into creating transparent tunnels using HTTP/2 CONNECT, including technical principles, practical workflows, and example code.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-packet-lifecycle-optimization/">Packet Lifecycle and Traffic Optimization in Istio Ambient Mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 29, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Packet Lifecycle and Traffic Optimization in Istio Ambient Mode', 'An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.', '\nThis article provides an in-depth analysis of the packet lifecycle in Istio Ambient Mode. It covers everything from the interception and target resolution of initial packets to the fast forwarding and optimization strategies for subsequent packets, helping readers better understand the technical logic and performance practices behind Ambient Mode.\n\n## Overview of Packet Lifecycle: From Kernel Space to User Space\n\nIn Ambient Mode, packet processing starts in the kernel space network stack of a Pod, where packets are intercepted by iptables rules and then processed by zTunnel in user space. zTunnel handles tasks such as transparent proxying, policy enforcement, and encrypted tunnel creation. Packets are then sent back to the kernel space network for forwarding to the target service or another zTunnel. The core idea is to analyze and tag the first packet in detail to pave the way for subsequent packets, thereby reducing redundant overhead.\n\nThe diagram below illustrates the packet lifecycle from a Pod to zTunnel in Istio Ambient Mode.\n\n\u0060\u0060\u0060mermaid \u0022Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel\u0022\nsequenceDiagram\n    participant App as Application\n    participant PodKernel as Pod Kernel-Space Network Stack\n    participant ipt as iptables\n    participant ztunnel as ztunnel User-Space Processing\n    participant HostKernel as Host Kernel-Space\n    participant Service as Destination Service or Next ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: Initial Packet Path\n    App-\u003e\u003ePodKernel: Sends the first packet\n    PodKernel-\u003e\u003eipt: Checks iptables redirection rules\n    ipt-\u003e\u003eztunnel: Redirects packet to zTunnel transparent proxy port\n    ztunnel-\u003e\u003eztunnel: Extracts destination address \u0026 policy validation \u0026 establishes tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the processed packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: Subsequent Packet Path\n    App-\u003e\u003ePodKernel: Sends subsequent packets\n    PodKernel-\u003e\u003ePodKernel: Matches existing connection using conntrack\n    PodKernel-\u003e\u003eztunnel: Packet directly enters ztunnel inbound socket (no iptables redirection needed)\n    ztunnel-\u003e\u003eztunnel: No need for re-parsing \u0026 reuses existing tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\u0060\u0060\u0060\n\n![Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel](0af66a9ca6d1db3f9e14e2e19e3210fb.svg)\n\nThe following sections will detail the processing paths for both the first packet and subsequent packets, analyzing the technical highlights and optimization strategies.\n\n## First Packet Path: From Interception to Destination Resolution\n\n### Initial Packet Emission\n\nWhen an application in a Pod emits a packet (e.g., an HTTP request), the packet is first processed by the Pod’s network namespace and kernel space network stack.\n\n### Transparent Interception via Iptables\n\n*iptables* rules filter outbound traffic. If the destination address is non-local and the packet lacks specific tags, it is redirected to zTunnel’s transparent proxy port (e.g., 15006 or 15008). Using *IP_TRANSPARENT* and *SO_ORIGINAL_DST* options, zTunnel can extract the packet’s original destination address in user space. This ensures transparent proxying for services located on the same node, across nodes, or outside the mesh.\n\n### Policy Validation and Processing in zTunnel User Space\n\nOnce in zTunnel, the first packet undergoes policy and security checks such as RBAC validation and mTLS encryption determination. For in-mesh traffic, an HTTP\/2 CONNECT tunnel (HBONE) is established for encrypted cross-node communication. For out-of-mesh traffic, direct TCP transmission is used.\n\n### Packet Egress and Connection Establishment\n\nAfter processing, zTunnel establishes an outbound socket (e.g., HTTP\/2 tunnel or plaintext TCP connection) based on the packet’s parsed details, sends it back to the kernel space, and routes it to the target service or zTunnel.\n\nAt this point, the first packet has completed a full journey from kernel space to user space and back. Connection states, policies, and tunnel information are recorded to optimize subsequent packets.\n\n## Subsequent Packet Path: Fast Forwarding with Conntrack and Tunnel Reuse\n\nOnce the first packet completes destination resolution and policy validation, the Linux kernel’s connection tracking (conntrack) records the connection state and tags it. Subsequent packets belonging to the same connection bypass complex iptables redirection and destination resolution, directly reaching zTunnel’s inbound socket.\n\n### Role of Conntrack\n\n*conntrack* tracks existing connections, providing a fast path for subsequent packets. This allows packets to be forwarded directly to zTunnel without repeatedly triggering *iptables* rules or undergoing policy checks.\n\n### Inbound Socket and User Space Processing\n\nSubsequent packets entering zTunnel’s inbound socket are directly identified by connection tags, skipping complex RBAC validation or encryption decisions. If an encrypted tunnel (HBONE) was established for the first packet, subsequent packets reuse this tunnel. For plaintext traffic, the existing TCP connection is used for direct transmission.\n\n### Optimization for Tunnel and Plaintext Paths\n\n- **HBONE Tunnel:** For in-mesh encrypted traffic, HTTP\/2 tunnels enable multiplexing, reducing repeated connection overhead.\n- **Plaintext Socket:** For local or external unencrypted traffic, subsequent packets use the existing plaintext connection, avoiding extra encapsulation.\n\nThese mechanisms greatly simplify the processing path for subsequent packets, improving performance and throughput.\n\n## Key Technical Points and Optimization Strategies\n\n1. **Transparent Proxying:** Using IP_TRANSPARENT and SO_ORIGINAL_DST, zTunnel seamlessly captures and parses non-local traffic, achieving true transparent proxying.\n2. **Efficient Kernel-User Space Switching:** By completing detailed parsing and policy validation for the first packet in user space, and leveraging conntrack and inbound socket mechanisms for subsequent packets, unnecessary context switching is minimized.\n3. **Multiplexed Tunnels:** HTTP\/2 CONNECT tunnels (HBONE) support encryption, load balancing, and multiplexing, enhancing efficiency for subsequent packet forwarding.\n\n## Practical Recommendations and Considerations\n\n- **Multi-Platform Adaptation:** Transparent proxying relies on Linux features. For non-Linux platforms (e.g., Windows, macOS), local proxies or alternative solutions may be required.\n- **Tuning and Observability:** Use zTunnel logs, connection tracking, and mesh observability tools to monitor traffic paths and performance. Fine-tune iptables rules, RBAC policies, and tunnel parameters based on data and results.\n\n## Conclusion\n\nIstio Ambient Mode introduces innovative designs for packet lifecycle and traffic optimization. By performing comprehensive policy parsing and encryption negotiation for the first packet, and leveraging conntrack for fast forwarding of subsequent packets, Ambient Mode strikes a balance between transparent proxying, scalability, and performance.\n\nAs the core component of Ambient Mode, zTunnel combines transparent application experience with underlying network optimization, meeting service mesh security and policy requirements while significantly reducing redundant overhead. This makes traffic processing more efficient and seamless.', '\/en\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 20, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('In-Pod IPtables Rule Injection in Istio Ambient Mode Explained', 'A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.', '\nIn my [previous blog post](\/en\/blog\/istio-ambient-traffic-interception\/), I provided an overview of the iptables rules injected within pod network namespaces in Istio ambient mode. This article takes a closer look at these rules, explaining how they achieve transparent traffic interception and redirection within pods.\n\n## iptables Rules Inside the Pod\n\nIn a pod\u0027s network namespace, the Istio CNI Node Agent sets up a series of iptables rules to enable transparent traffic interception and redirection. The following rules, injected into the \u0060mangle\u0060 and \u0060nat\u0060 tables, demonstrate how Istio processes inbound and outbound traffic.\n\n\u0060\u0060\u0060python\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*mangle\n:PREROUTING ACCEPT [99138:22880045]  # Default ACCEPT policy for the PREROUTING chain in the mangle table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the mangle table.\n:FORWARD ACCEPT [0:0]                # Default ACCEPT policy for the FORWARD chain in the mangle table.\n:OUTPUT ACCEPT [100900:34940164]     # Default ACCEPT policy for the OUTPUT chain in the mangle table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the mangle table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -m connmark --mark 0x111\/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\n# Restore connection mark 0x111\/0xfff for consistent connection tracking.\n\n-A ISTIO_PRERT -m mark --mark 0x539\/0xfff -j CONNMARK --set-xmark 0x111\/0xfff\n# Set connection mark to 0x111\/0xfff for packets marked 0x539\/0xfff in PREROUTING.\n\nCOMMIT  # Apply mangle table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*nat\n:PREROUTING ACCEPT [2:120]           # Default ACCEPT policy for the PREROUTING chain in the nat table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the nat table.\n:OUTPUT ACCEPT [119:9344]            # Default ACCEPT policy for the OUTPUT chain in the nat table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the nat table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound NAT traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting NAT traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -d 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic destined for 169.254.7.127 (likely an internal Istio address).\n\n-A ISTIO_OUTPUT -p tcp -m mark --mark 0x111\/0xfff -j ACCEPT\n# Allow TCP traffic marked as 0x111\/0xfff.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -o lo -j ACCEPT\n# Allow traffic to the loopback interface excluding 127.0.0.1.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -p tcp -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15001\n# Redirect outbound TCP traffic (not marked 0x539\/0xfff) destined outside 127.0.0.1 to port 15001 (outbound socket).\n\n-A ISTIO_PRERT -s 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic originating from 169.254.7.127 in the PREROUTING chain.\n\n-A ISTIO_PRERT ! -d 127.0.0.1\/32 -p tcp -m tcp ! --dport 15008 -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15006\n# Redirect inbound TCP traffic (not marked 0x539\/0xfff) to port 15006 (inbound socket) if its destination port is not 15008.\n\nCOMMIT  # Apply nat table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\u0060\u0060\u0060\n\n### Role of Specific Ports\n\nThese iptables rules differentiate and handle various types of traffic using specific ports:\n\n- **15008 (HBONE socket)**: Handles HTTP-based traffic transparently using the HBONE protocol.\n- **15006 (plaintext socket)**: Manages unencrypted traffic within the mesh for inter-pod communication.\n- **15001 (outbound socket)**: Controls outbound traffic and enforces policies for accessing external services.\n\nBy leveraging these ports, Istio enables transparent management and control of inbound, outbound, and internal traffic, enforcing fine-grained security policies and traffic controls. For more information, refer to [Istio Application Requirements](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/application-requirements\/).\n\n### Significance of \u00600x539\u0060 Mark\n\nThe \u00600x539\u0060 mark identifies traffic originating from Istio proxies (e.g., ztunnel). This mark is applied to distinguish packets processed by proxies, ensuring they are not reprocessed or misrouted.\n\n### Significance of \u00600x111\u0060 Mark\n\nThe \u00600x111\u0060 mark is used for connection-level marking within the Istio mesh, indicating that a connection has been processed by a proxy. The \u0060CONNMARK\u0060 module in iptables extends this mark to the entire connection, speeding up subsequent packet matching.\n\n## Visualizing iptables Rules\n\nThe following diagram illustrates the execution path of traffic through iptables rules, helping to understand how traffic is matched and redirected:\n\n\u0060\u0060\u0060mermaid \u0022iptables Rules Visualization\u0022\ngraph TD\nA[Traffic enters pod namespace] --\u003e B{Traffic direction}\nB -- Inbound --\u003e C[PREROUTING chain]\nC --\u003e D[ISTIO_PRERT chain]\nD --\u003e E{Source is 169.254.7.127?}\nE -- Yes --\u003e F[ACCEPT]\nE -- No --\u003e G{Destination is 127.0.0.1?}\nG -- Yes --\u003e F[ACCEPT]\nG -- No --\u003e H{Destination port is 15008?}\nH -- Yes --\u003e F[ACCEPT]\nH -- No --\u003e I{Packet marked 0x539?}\nI -- Yes --\u003e F[ACCEPT]\nI -- No --\u003e J[REDIRECT to port 15006]\nB -- Outbound --\u003e K[OUTPUT chain]\nK --\u003e L[ISTIO_OUTPUT chain]\nL --\u003e M{Destination is 169.254.7.127?}\nM -- Yes --\u003e N[ACCEPT]\nM -- No --\u003e O{Packet marked 0x111?}\nO -- Yes --\u003e N[ACCEPT]\nO -- No --\u003e P{Destination is 127.0.0.1 and output interface is lo?}\nP -- Yes --\u003e N[ACCEPT]\nP -- No --\u003e Q{Packet marked 0x539?}\nQ -- Yes --\u003e N[ACCEPT]\nQ -- No --\u003e R[REDIRECT to port 15001]\n\u0060\u0060\u0060\n\n![iptables Rules Visualization](05fa21587176b2333b3857e039764cd4.svg)\n\nFor further details on how Istio CNI handles iptables, refer to the source code: [istio\/cni\/pkg\/iptables\/iptables.go at master · istio\/istio · GitHub](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/iptables\/iptables.go).\n\n## Routing Visualization for Different Traffic Types\n\nHere are visualized traffic paths for encrypted and plaintext communication across and within nodes:\n\n**Cross-Node Encrypted Traffic**\n\n![Cross-Node Encrypted Traffic Path](cross-node-hbone.svg)\n\n**Cross-Node Plaintext Traffic**\n\n![Cross-Node Plaintext Traffic Path](cross-node-plaintext.svg)\n\n**Same-Node Encrypted Traffic**\n\n![Same-Node Encrypted Traffic Path](same-node-hbone.svg)\n\n**Same-Node Plaintext Traffic**\n\n\n\n![Same-Node Plaintext Traffic Path](same-node-plaintext.svg)\n\n1. **Application Sends Request**: Traffic originates from the application process and enters the pod’s network namespace.\n2. **iptables Rule Matching**:\n   - **Outbound Traffic** matches \u0060OUTPUT\u0060 chain rules, redirecting eligible traffic to the \u0060ISTIO_OUTPUT\u0060 chain.\n   - Matched traffic is marked and accepted.\n3. **REDIRECT Handling**: Traffic is captured and redirected by iptables to ztunnel (port 15006 for plaintext, 15008 for encrypted).\n4. **ztunnel Processing**: ztunnel performs policy enforcement and encryption.\n5. **Traffic Forwarded to Target Service**: Processed traffic is sent to the target service via a built tunnel.\n6. **Response Path**: Responses flow back to ztunnel for decryption and policy checks before reaching the application.\n\n## Conclusion\n\nBy analyzing the iptables rules in Istio ambient mode, we see how Istio’s CNI plugin establishes a transparent traffic interception mechanism within pods. These rules ensure that traffic entering and leaving pods is correctly handled by ztunnel, enabling finer-grained traffic management and security policy enforcement. Stay tuned for more deep dives into Istio ambient mode networking!\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-iptables-rule-injection\/).*', '\/en\/blog\/istio-ambient-inpod-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Detailed Explanation of Transparent Traffic Interception in Istio ambient mode', 'This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.', '\nThis is the first article in my series on Istio ambient mode. In the upcoming posts, I will delve deeper into the key components and their working principles, including how ztunnel forwards traffic to the waypoint proxy, how the waypoint proxy handles the traffic, and a comprehensive analysis of the traffic path using the Bookinfo example. Since traffic interception is the foundation of service mesh functionality, I chose to start with it to provide a solid understanding.\n\nIstio ambient mode is a service mesh implementation that eliminates the need for sidecar injection into each pod. By configuring transparent traffic interception and redirection within the pod\u0027s network namespace, applications can leverage service mesh capabilities without any modifications. The following content provides a detailed explanation of the transparent traffic interception process, covering components such as **Istio CNI Node Agent**, **ztunnel**, **network namespaces**, and **iptables rules**, illustrated with flowcharts and diagrams.\n\n## Background Knowledge\n\n### Linux Network Namespaces\n\n**Network namespaces** are a Linux kernel feature used to isolate the network environment of different processes. Each network namespace has its own network devices, IP addresses, routing tables, and iptables rules. Container technologies (e.g., Docker, Kubernetes) use network namespaces to provide each container (or pod) with an isolated network stack.\n\n### Istio CNI Node Agent\n\n**Istio CNI Node Agent** is a core component of ambient mode that operates on Kubernetes nodes, detecting pods joining the Ambient mesh and configuring traffic redirection rules for these pods. Note that this involves the Istio CNI Node Agent, not the traditional Istio CNI plugin. The Node Agent acts as a daemon working alongside ztunnel but does not directly perform network plugin tasks.\n\n### ztunnel\n\n**ztunnel** is a critical component in ambient mode, running as a DaemonSet on each node. Its responsibilities include:\n\n- Receiving and processing redirected traffic.\n- Enforcing L4 policies such as mTLS encryption and access control.\n- Communicating with the control plane to obtain configurations and certificates.\n\n### HBONE (HTTP-Based Overlay Network Encapsulation)\n\n**HBONE (HTTP-Based Overlay Network Encapsulation)** is a protocol introduced by Istio for transmitting arbitrary TCP traffic between ztunnel and waypoint proxy. HBONE leverages HTTP\/2 and HTTP\/3 multiplexing and encryption features for enhanced communication efficiency and security.\n\n## Detailed Traffic Interception Process\n\nIn ambient mode, application pods require no code changes or sidecar injection. Traffic interception and redirection occur entirely within the **pod\u0027s network namespace**, avoiding conflicts with the underlying CNI. Here’s an overview of the steps involved:\n\n\u0060\u0060\u0060mermaid \u0022Traffic Interception Process in Istio Ambient Mode\u0022\nsequenceDiagram\n    participant Kubelet\n    participant NodeAgent as Istio CNI Node Agent\n    participant podNetns as pod Network Namespace\n    participant ztunnel\n    participant pod as Application pod\n\n    Kubelet-\u003e\u003eNodeAgent: Notify new pod joins the Ambient mesh\n    NodeAgent-\u003e\u003epodNetns: Configure iptables rules\n    NodeAgent-\u003e\u003eztunnel: Pass pod network namespace FD\n    ztunnel-\u003e\u003ePodNetns: Start listening sockets in the pod network namespace\n    Pod-\u003e\u003ePodNetns: Application sends traffic\n    PodNetns-\u003e\u003eztunnel: Traffic redirected to ztunnel\n    ztunnel-\u003e\u003eTarget Service: Forward traffic via tunnel\n    Target Service--\u003e\u003eztunnel: Return response\n    ztunnel--\u003e\u003ePod: Send response back to application\n\u0060\u0060\u0060\n\n![Traffic Interception Process in Istio Ambient Mode](47a0230e39849d8e80ed6ab75bc34ebe.svg)\n\n### Detailed Steps of Traffic Interception\n\n1. **Pod Initialization and Network Configuration**:\n   - When Kubernetes creates a pod, it invokes the underlying CNI plugin (e.g., Calico, Cilium) via the Container Runtime Interface (CRI) to configure the pod’s network.\n   - At this stage, the pod’s network namespace (netns) is established.\n2. **Istio CNI Node Agent Configures Traffic Redirection**:\n   - The Istio CNI Node Agent detects that the new pod is marked for ambient mode (via the label \u0060istio.io\/dataplane-mode=ambient\u0060).\n   - It enters the pod’s network namespace and sets up iptables rules for traffic interception.\n   - The network namespace’s file descriptor (FD) is passed to ztunnel.\n3. **Ztunnel Starts Listening Sockets in Pod Network Namespace**:\n   - ztunnel receives the namespace FD and starts listening sockets within it to handle redirected traffic.\n4. **Transparent Traffic Interception and Processing**:\n   - Traffic originating from the application is intercepted by the iptables rules in the pod and transparently redirected to ztunnel.\n   - ztunnel performs policy checks, encryption, and other processing before forwarding traffic to the target service.\n   - Responses are decrypted by ztunnel and returned to the application.\n\nFor more details about how Istio CNI configures iptables, see my other blog post: [Analyzing iptables Rules in Istio ambient mode](\/blog\/istio-ambient-pod-iptables-injection\/).\n\n## ztunnel Log Analysis\n\nYou can inspect all logs related to traffic interception in ztunnel using the following command, which helps you understand how ztunnel operates:\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system logs -l app=ztunnel | grep -E \u0022inbound|outbound\u0022\n\u0060\u0060\u0060\n\nThe logs will look like the examples below, where \u0060inbound\u0060 and \u0060outbound\u0060 are relative to ztunnel.\n\n**Inbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:33:01.410751Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.19:58000 src.workload=\u0022bookinfo-gateway-istio-64fc6d75d6-s442s\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-gateway-istio\u0022 dst.addr=10.28.2.18:15008 dst.hbone_addr=10.28.2.18:9080 dst.service=\u0022productpage.default.svc.cluster.local\u0022 dst.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 direction=\u0022inbound\u0022 bytes_sent=9603 bytes_recv=2052 duration=\u00222110ms\u0022\n\u0060\u0060\u0060\n\nThis log describes inbound traffic from \u0060bookinfo-gateway-istio\u0060 to the \u0060productpage\u0060 service, passing through ztunnel’s port 15008, encrypted via HBONE, with identities verified through SPIFFE.\n\n**Outbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:32:59.360677Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.18:51960 src.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 dst.addr=10.28.2.14:15008 dst.hbone_addr=34.118.226.6:9080 dst.service=\u0022details.default.svc.cluster.local\u0022 dst.workload=\u0022waypoint-7594b5b786-vgjwz\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/waypoint\u0022 direction=\u0022outbound\u0022 bytes_sent=794 bytes_recv=414 duration=\u002240ms\u0022\n\u0060\u0060\u0060\n\nThis log shows outbound traffic from the \u0060productpage\u0060 pod to the \u0060details\u0060 service, routed through ztunnel using an HBONE tunnel to the waypoint pod (port \u006015008\u0060).\n\n## Conclusion\n\nIstio ambient mode achieves sidecar-free transparent traffic interception through the collaboration of Istio CNI Node Agent and ztunnel. Key features include:\n\n- **High compatibility**: Avoids conflicts with underlying CNI.\n- **Simplified operations**: No need for application code changes, reducing resource overhead.\n- **Enhanced security**: Enables end-to-end encrypted transmission with HBONE.\n\nIn future articles, I will explore advanced features of Istio ambient mode, including L7 traffic path analysis and network topology construction. Stay tuned!\n\n## References\n\n- [Maturing Istio Ambient: Compatibility Across Various Kubernetes Providers and CNIs](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/)\n- [Introducing Istio Ambient Mesh](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)\n- [Kubernetes Official Documentation: Network Plugins](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/compute-storage-net\/network-plugins\/)\n- [HBONE](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)\n- [ztunnel Traffic Redirection](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/traffic-redirection\/)\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/transparent-traffic-interception-in-istio-ambient-mode-a-comprehensive-explanation\/).', '\/en\/blog\/istio-ambient-traffic-interception\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrate-to-istio-telemetry-api/">Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 18, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh', 'Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.', '\nThe Istio Telemetry API is a modern approach to replace traditional MeshConfig telemetry configuration. It provides more flexible tools to define **Tracing**, **Metrics**, and **Access Logging** within the service mesh. Compared to conventional \u0060EnvoyFilter\u0060 and \u0060MeshConfig\u0060, the Telemetry API offers better modularity, dynamic updates, and multi-layered configuration capabilities.\n\nIn this article, we will detail how to use the Telemetry API to configure Istio telemetry features, covering the implementation of Tracing, Metrics, and Logging, as well as how to migrate from legacy MeshConfig configurations.\n\n## Evolution of Telemetry API\n\nIstio\u0027s telemetry capabilities initially relied on traditional methods such as **Mixer** and the \u0060configOverride\u0060 in **MeshConfig**. While these methods met basic needs, they struggled with complex use cases. To address these issues, Istio introduced the CRD-based **Telemetry API**.\n\n### Key Version Updates\n\nTo help readers understand the evolution of the Telemetry API, here are some important version milestones:\n\n1. **Istio 1.11**: Introduced the Telemetry API (Alpha), offering basic metrics and logging customization.\n2. **Istio 1.13**: Added support for OpenTelemetry logging, custom tracing service names, and enhanced log filtering.\n3. **Istio 1.18**: Deprecated the installation of Prometheus \u0060EnvoyFilter\u0060, relying entirely on Telemetry API for telemetry behavior.\n4. **Istio 1.22**: Graduated the Telemetry API to stable (v1), making it ready for production environments.\n\n## Why Migrate to Telemetry API?\n\nAlthough traditional MeshConfig and EnvoyFilter provided foundational telemetry capabilities, their configuration methods posed significant limitations in terms of flexibility, dynamism, and scalability. To better understand these limitations, let\u0027s explore several key aspects.\n\n### Complexity of MeshConfig and EnvoyFilter\n\nBefore diving into the issues, let’s clarify the roles of MeshConfig and EnvoyFilter: MeshConfig is used for global configurations, while EnvoyFilter allows for fine-grained customization. However, this separation of duties leads to management challenges.\n\n#### 1. Dispersed Configuration Methods\n\n- **MeshConfig** is used to define global mesh behaviors, such as access log paths, trace sampling rates, and metric dimensions. While suitable for simple scenarios, it cannot meet namespace- or workload-specific needs.\n- **EnvoyFilter** can override or extend Envoy configurations, enabling finer control. However, this method involves directly manipulating Envoy’s internal structures (xDS fields), which is complex and error-prone.\n\n  **Example: Configuring access logging via MeshConfig**\n  \u0060\u0060\u0060yaml\n  apiVersion: install.istio.io\/v1alpha1\n  kind: IstioOperator\n  spec:\n    meshConfig:\n      accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  **Issues**:\n  - Cannot set different log paths for specific services or namespaces.\n  - Requires reapplying the entire configuration, lacking dynamism.\n\n  **Example: Customizing metrics via EnvoyFilter**\n  \u0060\u0060\u0060yaml\n  apiVersion: networking.istio.io\/v1alpha3\n  kind: EnvoyFilter\n  metadata:\n    name: custom-metric-filter\n    namespace: mynamespace\n  spec:\n    workloadSelector:\n      labels:\n        app: myapp\n    configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n        listener:\n          filterChain:\n            filter:\n              name: envoy.filters.network.http_connection_manager\n              subFilter:\n                name: envoy.filters.http.router\n        proxy:\n          proxyVersion: \u0027^1\\\\.13.*\u0027\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: istio.stats\n          typed_config:\n            \u0027@type\u0027: type.googleapis.com\/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n            value:\n              config:\n                configuration:\n                  \u0027@type\u0027: type.googleapis.com\/google.protobuf.StringValue\n                  value: |\n                    {\n                      \u0022debug\u0022: \u0022false\u0022,\n                      \u0022stat_prefix\u0022: \u0022istio\u0022,\n                      \u0022disable_host_header_fallback\u0022: true\n                    }\n                root_id: stats_inbound\n                vm_config:\n                  code:\n                    local:\n                      inline_string: envoy.wasm.stats\n                  runtime: envoy.wasm.runtime.null\n                  vm_id: stats_inbound\n  \u0060\u0060\u0060\n  **Issues**:\n  - Syntax is complex and verbose, requiring deep understanding of Envoy’s structure.\n  - High potential for errors, leading to costly debugging and maintenance.\n\n#### 2. Lack of Dynamism\n\nWhile modern microservice environments emphasize dynamic configuration, MeshConfig and EnvoyFilter offer limited support for dynamism:\n\n- **MeshConfig**: Modifying configurations often requires restarting proxies or reapplying the entire setup, causing service disruptions.\n- **EnvoyFilter**: Updating even a single parameter necessitates redeployment of related proxy instances.\n\n#### 3. Challenges in Multi-Tenant Support\n\nIn multi-tenant environments, customizing telemetry configurations for different namespaces or workloads is crucial. However:\n\n- **MeshConfig**: Cannot provide differentiated settings for namespaces or workloads.\n- **EnvoyFilter**: Requires multiple filter configurations, increasing management complexity.\n\n#### 4. Limited Extensibility and Debugging\n\n- MeshConfig and EnvoyFilter are slow to support new requirements (e.g., OpenTelemetry).\n- Debugging EnvoyFilter configurations is challenging, requiring in-depth analysis of Envoy logs and behaviors.\n\n### Deprecating Legacy MeshConfig Telemetry Configuration\n\nGiven the limitations mentioned above, the Istio community has deprecated traditional MeshConfig telemetry configurations. The following examples illustrate their usage and shortcomings:\n\n- **Access Logging Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n- **Trace Sampling Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    enableTracing: true\n    extensionProviders:\n    - name: zipkin\n      zipkin:\n        service: zipkin.istio-system.svc.cluster.local\n        port: 9411\n  \u0060\u0060\u0060\n- **Custom Metrics Labels**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    telemetry:\n      v2:\n        prometheus:\n          configOverride:\n            inboundSidecar:\n              metrics:\n                - name: requests_total\n                  dimensions:\n                    user-agent: request.headers[\u0027User-Agent\u0027]\n  \u0060\u0060\u0060\n\nThese configurations demonstrate clear limitations in flexibility and scalability, making them unsuitable for complex production environments.\n\n## Advantages of Telemetry API\n\nBuilding upon traditional methods, the Telemetry API introduces several improvements, making it well-suited for modern service mesh management:\n\n1. **Modular Design**: Separate configurations for Tracing, Metrics, and Access Logging.\n2. **Dynamic Updates**: Supports real-time configuration updates without proxy restarts.\n3. **Layered Support**: Allows configurations at global, namespace, and workload levels.\n4. **Simplified Syntax**: Uses declarative syntax, eliminating the need for in-depth Envoy knowledge.\n\n## Example Configurations with Istio Telemetry API\n\n### Global Configuration Example\n\nTo illustrate the usage of the Telemetry API, here is an example of a global configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  accessLogging:\n    - providers:\n        - name: file-log\n  tracing:\n    - providers:\n        - name: \u0022skywalking\u0022\n      randomSamplingPercentage: 100.00\n  metrics:\n    - overrides:\n        - match:\n            metric: REQUEST_COUNT\n            mode: CLIENT\n          tagOverrides:\n            x_user_email:\n              value: |\n                \u0027x-user-email\u0027 in request.headers ? request.headers[\u0027x-user-email\u0027] : \u0027empty\u0027\n      providers:\n        - name: prometheus\n\u0060\u0060\u0060\n\nThe remaining sections demonstrate step-by-step how to configure and validate SkyWalking, as well as perform migration, ensuring readers can implement these practices seamlessly in their environments.\n\n### Configuring SkyWalking with Telemetry API\n\nHere, we will demonstrate how to use the Telemetry API to configure the sampling rate and span tags for SkyWalking.\n\n#### Verify Istio Version and CRD\n\n- If using Istio 1.22 or later, use \u0060telemetry.istio.io\/v1\u0060.\n- For Istio 1.18 to 1.21 users, use \u0060telemetry.istio.io\/v1alpha1\u0060.\n\nCheck whether the Telemetry API CRD is installed using the following command:\n\n\u0060\u0060\u0060bash\nkubectl get crds | grep telemetry\n\u0060\u0060\u0060\n\n#### Deploy SkyWalking\n\nDeploy the SkyWalking OAP service in your cluster:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\nCheck the service status:\n\n\u0060\u0060\u0060bash\nkubectl get pods -n istio-system -l app=skywalking-oap\n\u0060\u0060\u0060\n\n#### Add SkyWalking Provider to MeshConfig\n\nDefine the SkyWalking provider in Istio\u0027s \u0060MeshConfig\u0060.\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: istio\n  namespace: istio-system\ndata:\n  mesh: |-\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: \u0022tracing.istio-system.svc.cluster.local\u0022\n        port: 11800\n\u0060\u0060\u0060\n\n#### Configure Sampling Rate with Telemetry API\n\nUsing the Telemetry API, set SkyWalking as the default tracing provider and define the sampling rate.\n\nTelemetry API allows configuration at multiple levels. For brevity, we demonstrate namespace-level configuration here. For other levels, refer to the [Telemetry API documentation](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/).\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1\nkind: Telemetry\nmetadata:\n  name: namespace-override\n  namespace: default\nspec:\n  tracing:\n  - providers:\n      - name: skywalking\n    randomSamplingPercentage: 50\n    customTags:\n      env:\n        literal:\n          value: production\n\u0060\u0060\u0060\n\nExplanation:\n\n- \u0060providers.name\u0060: Specifies SkyWalking as the default tracing provider.\n- \u0060randomSamplingPercentage\u0060: Overrides namespace-level settings to set a 50% sampling rate.\n- \u0060customTags\u0060: Adds the \u0060env=production\u0060 tag to all trace data.\n\n### Validate Configuration\n\nGenerate traffic for the mesh services, such as using the [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) example application:\n\n\u0060\u0060\u0060bash\ncurl http:\/\/$GATEWAY_URL\/productpage\n\u0060\u0060\u0060\n\nView the trace data:\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nOpen your browser and navigate to \u0060http:\/\/localhost:8080\u0060 to access the tracing dashboard and inspect the generated traces.\n\n![Skywalking Tracing](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-tracing.webp)\n\nClick on a span to see the additional \u0060env: production\u0060 tag.\n\n![Skywalking Span](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-span.webp)\n\n## Summary\n\nThe Telemetry API significantly reduces the complexity of configuring telemetry in the service mesh through its modular design, dynamic updates, and multi-level support. Compared to MeshConfig and EnvoyFilter, the Telemetry API is a more flexible, efficient, and modern solution. We highly recommend migrating to the Telemetry API to take full advantage of its capabilities.\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-telemetry\/).\n', '\/en\/blog\/migrate-to-istio-telemetry-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-sidecar-vs-ambient-network-cost-performance/">Network Cost Comparison Between Istio Sidecar and Ambient Modes</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Network Cost Comparison Between Istio Sidecar and Ambient Modes', 'In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.', '\nIn the evolving landscape of service mesh architectures, understanding the network costs associated with different deployment modes is crucial for optimizing performance and resource efficiency. This blog post will compare the network costs of Istio’s sidecar mode and ambient mode, drawing insights from my recent article, [Which Data Plane Should I Use—Sidecar, Ambient, Cilium, or gRPC?](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/)\n\n## Sidecar Mode\n\nIstio’s sidecar mode intercepts traffic between services by deploying a sidecar proxy alongside each pod. This model introduces additional network hops, which may increase latency and resource usage. However, the mode includes important optimizations like [locality-aware load balancing](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/locality-load-balancing\/).\n\nFigure 1 illustrates the traffic path when Application 1 accesses Application 2 located in a different availability zone (AZ) under the sidecar model.\n\n![Figure 1: The traffic path for Application 1 in Istio Sidecar mode to access Application 2 located in a different availability zone (AZ).](sidecar-mode.svg)\n\n### Locality Awareness in Sidecar Mode\n\nTo better understand locality management, you can use the command \u0060istioctl proxy-config endpoint \u003cpod-name[.namespace]\u003e -o yaml\u0060 to view an endpoint table containing locality information. This helps visualize how locality is managed in sidecar mode.Below is a sample output snippet showing endpoint information for the cluster \u0060outbound|9080||reviews.default.svc.cluster.local\u0060:\n\n\u0060\u0060\u0060yaml\n- addedViaApi: true\n  circuitBreakers:\n    thresholds:\n    - maxConnections: 4294967295\n      maxPendingRequests: 4294967295\n      maxRequests: 4294967295\n      maxRetries: 4294967295\n    - maxConnections: 1024\n      maxPendingRequests: 1024\n      maxRequests: 1024\n      maxRetries: 3\n      priority: HIGH\n  edsServiceName: outbound|9080||reviews.default.svc.cluster.local\n  hostStatuses:\n  - address:\n      socketAddress:\n        address: 10.244.0.98\n        portValue: 9080\n    healthStatus:\n      edsHealthStatus: HEALTHY\n    locality:\n      region: us-central1\n      zone: us-central1-c\n    stats:\n    - name: cx_connect_fail\n    - name: cx_total\n    - name: rq_error\n    - name: rq_success\n    - name: rq_timeout\n    - name: rq_total\n    - name: cx_active\n      type: GAUGE\n    - name: rq_active\n      type: GAUGE\n    weight: 1\n  - address:\n    # Additional addresses omitted\n  - address:\n    # Additional addresses omitted\n  name: outbound|9080||reviews.default.svc.cluster.local\n  observabilityName: outbound|9080||reviews.default.svc.cluster.local;\n\u0060\u0060\u0060\n\nThis shows how the sidecar proxy in each pod manages fine-grained traffic control, including circuit breaker configurations like maxConnections, maxRequests, and maxRetries, along with traffic metrics and health status indicators. This level of detail aids in maintaining healthy, stable, and latency-efficient traffic at the pod level.\n\nIn sidecar mode, each proxy prioritizes routing traffic to services within the same AZ or region, minimizing cross-AZ traffic and reducing latency and associated costs. This approach optimizes network paths, preventing cross-regional bottlenecks.\n\nAlthough sidecar mode can be compute-intensive, its locality-aware functionality is instrumental in maintaining efficient traffic routing, particularly in multi-region cloud deployments, where it helps minimize cross-region traffic costs.\n\n## Ambient Mode\n\nThe following diagram shows the architecture of Istio’s ambient mode.\n\n![Figure 2: Istio ambient mode architecture](istio-ambient-layers.svg)\n\nIstio ambient mode has two layers:\n\n1. **Ztunnel Layer (L3\/L4 Traffic Management)**: In ambient mode, zTunnel manages traffic mainly at the network and transport layers, reducing overhead while ensuring basic connectivity and security requirements are met.\n2. **Waypoint Proxy Layer (L7 Traffic Management)**: This layer, which adds application-layer functionality like advanced routing, observability, and policy enforcement, requires optimal placement to avoid cross-AZ traffic. Waypoint proxies should be deployed within each AZ to ensure maximum performance.\n\n## Locality Awareness in Ambient Mode\n\nIn contrast to sidecar mode, ambient mode uses zTunnel and waypoint proxies for a different architectural approach. Like sidecar mode, zTunnel prioritizes routing traffic within the same AZ, limiting cross-AZ traffic and associated network costs.\n\nFigure 3 illustrates the traffic path for Application 1 accessing Application 2 in a different AZ in ambient mode.\n\n![Figure 3: The traffic path for Application 1 in Istio ambient mode to access Application 2 located in a different availability zone (AZ).](ambient-mode.svg)\n\nNote: In the figure, the waypoint proxy is shown separately for demonstration purposes; in practice, it is not bound to a specific node and can be colocated with zTunnel.\n\nTo gain further insights into locality in ambient mode, you can use \u0060istioctl ztunnel-config workload -o yaml\u0060, which provides detailed views of zTunnel configurations and traffic distribution.\n\nHere’s an example snippet:\n\n\u0060\u0060\u0060yaml\n- applicationTunnel:\n    protocol: \u0022\u0022\n  canonicalName: productpage\n  canonicalRevision: v1\n  clusterId: Kubernetes\n  hostname: \u0022\u0022\n  locality:\n    region: us-central1\n    zone: us-central1-c\n  name: productpage-v1-d5789fdfb-gmw5r\n  namespace: default\n  node: gke-cilium-default-pool-63a77182-f699\n  protocol: HBONE\n  serviceAccount: bookinfo-productpage\n  status: Healthy\n  trustDomain: cluster.local\n  uid: Kubernetes\/\/Pod\/default\/productpage-v1-d5789fdfb-gmw5r\n  workloadIps:\n    - 10.28.2.14\n  workloadName: productpage-v1\n  workloadType: deployment\n\u0060\u0060\u0060\n\nThis output demonstrates ztunnel’s locality-aware information, which centralizes traffic management for all pods on a node, including load balancing, health checks, and locality awareness.\n\n### Waypoint Proxies\n\nThe waypoint proxy, however, does not automatically have AZ awareness. To optimize for cost and performance, waypoint proxies must be deployed across AZs to enable local traffic handling. Otherwise, there is a risk of additional cross-AZ traffic and costs. Additionally, once traffic reaches a waypoint proxy, original locality information may be obscured, complicating route optimization.\n\nFor optimal cost and performance, waypoint proxies should be distributed within each AZ to process traffic locally. The proximity-aware communication design between ztunnel and waypoint proxies helps ensure traffic is routed to the nearest waypoint, further reducing cross-AZ costs and latency.\n\n## Visualizing with Kiali Dashboard\n\nWhen comparing sidecar and ambient modes, visualizing locality and routing behavior with Kiali dashboard can help illustrate ambient mode’s complexity. Kiali provides a graphical view of traffic paths in different modes, aiding in understanding ambient mode’s operational intricacies.\n\n![Kiali UI](kiali.webp)\n\n## Conclusion\n\nIn comparing the network costs of Istio’s sidecar and ambient modes, both architectures support locality-aware routing to minimize cross-AZ traffic. Sidecar mode offers more comprehensive locality management at each proxy, while ambient mode requires careful waypoint proxy deployment to avoid extra costs. Additionally, ambient mode’s sub-modes (with or without waypoint proxies) impact network cost and performance in distinct ways. For a deeper dive into the four primary service mesh data plane deployment modes, I encourage you to read the full article [here](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-cost-comparison\/).*\n', '\/en\/blog\/istio-sidecar-vs-ambient-network-cost-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 30, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from AWS App Mesh to Istio: A Comprehensive Guide', 'Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.', '\nWith[ AWS announcing the deprecation of AWS App Mesh effective September 30, 2026](https:\/\/aws.amazon.com\/cn\/blogs\/containers\/migrating-from-aws-app-mesh-to-amazon-ecs-service-connect\/), many organizations are evaluating alternatives to continue their service mesh journey. If you are one of those organizations, Istio presents itself as a robust and feature-rich option, especially for Kubernetes-native environments. In this post, I will provide an overview of the migration process from AWS App Mesh to Istio, compare the two service meshes, and introduce the Tetrate Istio Migration Tool—a convenient utility we developed to streamline this transition.\n\n## App Mesh vs Istio: Preparing for Migration\n\nWith AWS App Mesh being deprecated, it’s important to understand the similarities and differences between App Mesh and Istio to prepare for a successful migration. Below are some key points of comparison to help align your current infrastructure with what Istio offers:\n\n1. Comprehensive Features: Both App Mesh and Istio offer traffic management, observability, and security, but Istio provides more customizable options, including advanced traffic routing and enhanced telemetry.\n2. Cloud Agnostic: Unlike AWS App Mesh, which is tightly integrated with AWS, Istio is cloud-agnostic, allowing for greater flexibility across multi-cloud or hybrid environments.\n3. Advanced Security: Istio supports mTLS by default, offering more extensive security features and policies compared to App Mesh.\n\nAWS recommends ECS customers migrate to[ Service Connect](https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/developerguide\/service-connect.html) and EKS customers to[ VPC Lattice](https:\/\/aws.amazon.com\/vpc\/lattice\/). For a feature-rich, open source solution, Istio is a compelling choice. Let’s dive into the migration journey from AWS App Mesh to Istio, supported by Tetrate’s migration tool.\n\n## Comparing App Mesh, Service Connect, VPC Lattice and Istio\n\nBefore starting the migration, it’s essential to understand the key differences between AWS App Mesh, Service Connect, VPC Lattice, and Istio:\n\n| **Feature**                  | **App Mesh**                                                 | **Service Connect**                                          | **VPC Lattice**                                              | **Istio**                                                    |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Network Reliability**      | Uses[ Envoy](https:\/\/envoyproxy.io\/) as sidecar proxies for outlier detection, health checks, and retries with granular adjustments. | Uses Envoy as sidecar proxies with default configurations, only timeouts adjustable. | Built-in health checks and retries with AWS-managed reliability. No sidecar proxies are needed. | Supports both sidecar and ambient modes, using Envoy with full support for fine-tuning. |\n| **Advanced Traffic Routing** | Supports advanced traffic routing like A\/B testing and canary releases. | Does not support advanced traffic routing.                   | Supports basic traffic routing and load balancing.           | Supports advanced traffic control, including A\/B testing and canary releases. |\n| **Observability**            | Manual collection and monitoring of metrics.                 | Sends metrics to Amazon CloudWatch automatically.            | Integrated monitoring with AWS CloudWatch and X-Ray.         | Out-of-the-box observability with Prometheus, Grafana, and Jaeger. |\n| **Service Discovery**        | Integrates with AWS Cloud Map.                               | Uses AWS Cloud Map.                                          | Uses AWS service discovery mechanisms.                       | Uses Kubernetes-native service discovery.                    |\n| **Security**                 | Supports TLS with AWS PCA and mutual TLS (mTLS).             | Supports TLS, no mTLS.                                       | Supports mTLS.                                               | Supports mTLS, fine-grained security policies.               |\n| **Resource Sharing**         | Can share Mesh across multiple AWS accounts.                 | Cannot share namespaces across accounts.                     | Can share resources across multiple AWS accounts.            | Can be deployed across multiple clusters and clouds.         |\n\n## Introducing Tetrate’s Istio Migration Tool\n\nTo make the migration process smoother, Tetrate has developed an Istio Migration Toolkit, which is currently in a private state but can be used internally or by approved customers who request it through the[ form](https:\/\/resources.tetrate.dev\/app-mesh-istio?__hstc=218802950.edcf2542a8010c44aa57b98adaef028a.1721092227167.1729818643207.1730268606576.91\u0026__hssc=218802950.2.1730268606576\u0026__hsfp=872206273). The toolkit assists in automating the conversion of AWS App Mesh configurations to Istio equivalents, including Virtual Nodes, Virtual Routers, and other networking constructs.\n\n**Key Considerations**\n\n- **Service discovery**: App Mesh and Istio handle service discovery differently. Istio leverages Kubernetes-native service discovery, while App Mesh integrates with AWS Cloud Map. During the migration, it is critical to adjust your service definitions accordingly.\n- **Security**: Istio natively supports mTLS between services. While AWS App Mesh also offers mTLS, transitioning to Istio will require configuring the Certificate Authority (CA) and updating certificates to align with Istio’s security model.\n- **Traffic management**: Istio’s Virtual Services and Destination Rules offer more advanced traffic routing capabilities compared to App Mesh’s Virtual Routers and Nodes. As you migrate, plan for additional configuration steps to set up similar routing behavior in Istio.\n\n## Step-by-Step Migration Using Tetrate’s Migration Tool\n\nBelow, I’ll guide you through the steps to use this tool effectively.\n\n### Prerequisites\n\nTo start the migration, ensure you have the following installed:\n\n- [Go](https:\/\/golang.org\/doc\/install)\n- [kubectl](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)\n- [istioctl](https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/#download)\n\nMake sure your AWS App Mesh is properly installed and configured on an EKS cluster. You’ll also need a Kubernetes secret called tetrate-tis-creds for Istio installation, as detailed in the tool’s documentation.\n\nThe tool also helps verify compatibility, offering a precheck command to identify any potential blockers before starting the migration.\n\n### Running a Precheck\n\nTo verify that your setup is ready for migration, run:\n\n\u0060\u0060\u0060bash\ntim precheck\n\u0060\u0060\u0060\n\nThis command will scan your App Mesh environment and highlight any adjustments required to ensure a successful migration.\n\n### Migration Process\n\n1. Install Istio\n\n   Use the Istio Migration Toolkit to generate IstioOperator configurations, and install Istio:\n\n   \u0060\u0060\u0060bash\n   tim generate iop | istioctl install –skip-confirmation -f –\n   \u0060\u0060\u0060\n\n1. Apply Istio Networking Rules\n   Next, generate and apply Istio networking rules:\n\n   \u0060\u0060\u0060bash\n   tim generate networking | kubectl apply -f –\n   \u0060\u0060\u0060\n\n1. Remove AWS App Mesh Labels\n   Remove the existing App Mesh labels from your namespaces. For example, for the default namespace:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default \u0022appmesh.k8s.aws\/sidecarInjectorWebhook-\u0022\n   \u0060\u0060\u0060\n\n1. Enable Istio Sidecar Injection\n   Add a label to enable Istio’s automatic sidecar injection:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio-injection=enabled\n   \u0060\u0060\u0060\n\n1. Restart Deployments\n   To apply changes and initiate the new Envoy sidecar injection, restart your deployments:\n\n   \u0060\u0060\u0060bash\n   kubectl rollout restart deployment \u003cdeployment-name\u003e -n \u003cdeployment-namespace\u003e\n   \u0060\u0060\u0060\n\n### Migration Strategies\n\nWhen migrating apps from AWS App Mesh to Istio, there are strategies like in-place, canary, and blue\/green deployments, similar to those for migrating to VPC Lattice. The right strategy depends on app requirements like zero downtime or scheduling maintenance windows.\n\n1. **In-Place Migration**: Replace existing Kubernetes Pods instrumented with App Mesh with new Pods configured for Istio. This approach is suitable for applications that can tolerate downtime during the migration process, as each pod is recycled to remove the Envoy sidecar container and add Istio.\n2. **Blue\/Green Deployment**: Deploy a second copy of the application in a new namespace configured for Istio, while the original deployment remains operational with App Mesh. Gradually migrate traffic from App Mesh to Istio without downtime while both environments run simultaneously.\n3. **Canary Deployment**: Deploy Istio side-by-side with App Mesh and incrementally move a small percentage of traffic to Istio. Monitor performance and stability, and increase traffic as confidence grows.\n4. **Phased Migration**: Migrate components or services incrementally instead of all at once. This reduces risk and helps identify potential issues in smaller, manageable segments.\n5. **Testing and Validation**: Before cutting over entirely, conduct thorough testing to validate that service functionality, security, and performance metrics meet or exceed expectations.\n\n## Conclusion\n\nMigrating from AWS App Mesh to Istio can unlock new capabilities in traffic management, observability, and security. Tetrate’s Istio Migration Toolkit simplifies the process, providing a step-by-step approach to reduce manual configurations and ensure a seamless transition.\n\nIf you’re interested in trying out Tetrate’s Istio Migration Toolkit, feel free to reach out—the tool is currently available for private use, and we’d be happy to discuss access.\n\nThis migration is not just about adopting a new service mesh—it’s an opportunity to take advantage of Istio’s comprehensive features, support multi-cloud deployments, and enhance the resilience of your infrastructure.\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/).*\n', '\/en\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multi-Cluster PKI \u002b Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh', 'This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.', '\nAuthors: Cristofer TenEyck Senior Solution Engineer a Keyfactor and Jimmy Song Developer Advocate at Tetrate\n\n## Introduction\n\nIn the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge. \n\nIn this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes. \n\nWhy multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters. \n\n## Understanding PKI and its Role in Service Meshes \n\nPKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments. \n\nThe EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications. \n\n## Istio, EJBCA and cert-manager \n\nSetting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included: \n\n1. **Environment Preparation**: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA). \n2. **cert-manager Integration**: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates. \n3. **Automatic Certificate Renewal**: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters. \n\n![Architecture](arch.webp)\n\n## Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary \n\nThis section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found [here](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi).\n\nThe key steps include: \n\n1. **Install and Configure Helm Repositories**: Add necessary Helm repositories for Istio, cert-manager, and EJBCA. \n2. **Deploy cert-manager and EJBCA**: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets. \n3. **Configure Istio with EJBCA**: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration. \n4. **Install Istio Components**: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway. \n5. **Customization and Overrides**: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services. \n6. **Automatic Certificate Renewal:** The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications. \n\n![Certificate renew flow](cert-renew-flow.webp)\n\nAbove is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA. \n\n## PKI Best Practices and Compliance \n\nBuilding a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider: \n\n1. **Compliance with Regulations**: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices. \n2. **Crypto Agility and Quantum Readiness**: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important. \n3. **Collaboration with InfoSec**: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals. \n\n## Conclusion \n\nImplementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant. \n\nBy following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh. \n\nFor further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below. \n\n## Resources \n\n- [Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi)\n- [Istio documentation](https:\/\/istio.io\/latest\/docs\/)\n- [EJBCA Community edition](https:\/\/www.ejbca.org\/)\n- [cert-manager documentation](https:\/\/cert-manager.io\/docs\/)\n- [EU Cyber Resilience Act](https:\/\/digital-strategy.ec.europa.eu\/en\/policies\/cyber-resilience-act)\n- [US Executive Order on Cybersecurity](https:\/\/www.whitehouse.gov\/briefing-room\/statements-releases\/2021\/05\/12\/executive-order-on-improving-the-nations-cybersecurity\/)\n- [A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh](\/en\/blog\/seamless-cross-cluster-access-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh\/).*\n', '\/en\/blog\/multi-cluster-pki-istio-recipe\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/istio/page/7/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(53)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(7)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-l7-flow-analysis/">Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/envoy-ext-proc-guide/">Advanced Request and Response Processing in Microservice Architecture with Envoy&#39;s External Processing Filter</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/http2-envoy-tunnel-demo/">Implementing HTTP/2 CONNECT Tunnels with Envoy: Concepts and Practical Guide</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
