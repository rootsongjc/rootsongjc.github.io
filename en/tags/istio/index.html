<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                Resources
              </a>
              <div class="dropdown-menu">
                
                <a class="dropdown-item" href="/en/book">Books</a>
                
                <a class="dropdown-item" href="/en/slide">Slides</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/istio/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/beyond-sidecar/">Beyond Sidecar: A Deep Dive into Istio Ambient Mode Traffic Mechanism and Cost Efficiency</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 22, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Beyond Sidecar: A Deep Dive into Istio Ambient Mode Traffic Mechanism and Cost Efficiency', 'This post introduces the background, core components, traffic flow mechanisms, and comparisons between Ambient Mode and the traditional Sidecar model in Istio—helping you evaluate and get started with this new feature quickly.', '\nWelcome to my blog post — **\u0022Beyond Sidecar: A Deep Dive into Istio Ambient Mode Traffic Mechanism and Cost Efficiency.\u0022** \n\nThis post is based on my talk at KCD Beijing and focuses on Istio’s newly introduced data plane model — **Ambient Mode**. Its core idea is to remove the Sidecar proxy to reduce resource overhead and operational complexity.\n\nIn this article, I’ll explain Ambient Mode\u0027s background, core components, traffic routing mechanisms, and a comparison with the existing Sidecar model. The goal is to help you evaluate this new feature and confidently adopt it.\n\n[Click here to view the slides](\/en\/slide\/beyond-sidecar\/).\n\n## Why Care About Ambient Mode?\n\nLet’s start with a question: why should we care about—or even consider adopting—this new mode? Sidecar proxies have been working well in service meshes for years, so why remove them now?\n\nTo answer that, let’s look at some of the challenges service meshes currently face.\n\n### Challenges with Service Mesh\n\n- **Resource overhead** and **operational complexity** introduced by sidecar proxies \n- **Upgrading** or **restarting** Envoy often requires restarting all Pods \n- Growing demand for **high performance** and **lower costs**\n\n\u003e **Thought exercise**: Is there a way to retain the core capabilities of a service mesh—security, observability, traffic control—while reducing the per-Pod intrusion and extra resource consumption?\n\n### Common Service Mesh Deployment Models\n\n![Proxy Locations](proxy-location.svg)\n\nThe architecture of service meshes has long been exploring different proxy deployment strategies, such as:\n\n- **Sidecar**: Runs an Envoy proxy inside each Pod\n- **Ambient**: Moves the proxy out of Pods to the node level (which this post focuses on)\n- **Cilium Mesh**: Uses eBPF in the kernel space for L4, combined with Envoy for L7 capabilities\n- **gRPC**: Embeds mesh functionality directly into application SDKs\n\nEach of these models has trade-offs in terms of functionality, security, performance, and operational complexity. **Istio Ambient Mode** is a new attempt to address the Sidecar model’s overhead and operational burdens.\n\n### The Birth of Ambient Mode\n\n- A next-generation Istio architecture that **removes the Sidecar**, using **ztunnel \u002b Waypoint Proxy** to simplify the data plane\n- Saves resources and reduces operational complexity\n- Still supports **mTLS** and **policy enforcement**, with **Waypoint Proxy** optionally providing L7 capabilities\n\n![Deployment Model Quadrants](istio-data-plane-deployment-modes.svg)\n\nThe following table provides a quick comparison of some common service mesh deployment models:\n\n| **Mode**         | **Security**                         | **Efficiency**        | **Manageability**            | **Performance**                          |\n| ---------------- | ------------------------------------ | --------------------- | ---------------------------- | ---------------------------------------- |\n| **Sidecar**       | High isolation via per-Pod proxy     | High resource usage   | Centralized but complex      | Adds some latency                        |\n| **Ambient**       | Security via ztunnel (still evolving) | More efficient, shared | Easier to manage, still maturing | Good; cross-AZ traffic may add overhead |\n| **Cilium mesh**   | Moderate, kernel-based with eBPF     | Kernel-level efficiency | Complex to configure         | Depends on use case                      |\n| **gRPC**          | App-integrated, depends on the app   | Efficient              | Complex upgrade management    | Low latency, ideal for real-time use     |\n\n## Core Concepts of Istio Ambient Mode\n\nLet’s now move into the second part of our discussion, where we’ll explore the core components of Ambient Mode, including **ztunnel**, **Waypoint Proxy**, and the role of **Istio CNI**.\n\n### Key Components of Ambient Mode\n\n1. **ztunnel (L4)**\n   - Runs as a node-level proxy\n   - Responsible for **transparent traffic interception** and **mTLS encryption**\n   - Handles most traffic that only requires L4 forwarding\n\n2. **Waypoint Proxy (L7)**\n   - Optionally deployed (configurable by namespace, service, or pod granularity)\n   - Handles advanced functionality like **HTTP\/gRPC authentication, routing, and observability**\n\n3. **Istio CNI**\n   - Replaces the \u0060istio-init\u0060 container and handles traffic redirection\n   - Supports both **Sidecar** and **Ambient** modes\n   - Enables traffic redirection in **unprivileged mode** for enhanced security\n\n### Overview of Ambient Mode Architecture\n\n![Istio Ambient Mode Architecture](istio-ambient-layers.svg)\n\nIn Ambient Mode, the Istio data plane is split into two layers:\n\n1. **Security Layer (ztunnel)**: A lightweight L4 proxy is deployed on each node\n2. **Optional L7 Layer (Waypoint Proxy)**: Deployed only when HTTP\/gRPC proxying is needed\n\nThe **control plane** is still managed by **Istiod**, which distributes configurations and certificates to both ztunnel and Waypoint proxies.\n\n### Deployment Strategies for Waypoint Proxy\n\n- **Namespace-level** (default): Applies to all workloads in the namespace\n- **Service-level**: For services that require L7 processing only\n- **Pod-level**: Offers fine-grained control\n- **Cross-namespace**: Enables sharing via Gateway resources\n\n### Istio CNI\n\n- **Traffic Interception**: Replaces the \u0060istio-init\u0060 container, simplifying the installation process\n- **Dual-mode Support**: Compatible with both **Sidecar** and **Ambient** modes\n- **Unprivileged Mode Compatibility**: Enables traffic redirection for Pods running without elevated privileges\n- **CNI Chaining**: Adds Istio CNI as an additional plugin in the existing CNI configuration\n- **In-Pod Traffic Redirection (Ambient Mode)**:\n  - Uses \u0060iptables REDIRECT\u0060 rules inside the Pod’s network namespace\n  - Creates a local socket within the Pod to intercept and proxy traffic\n\nThe following diagram illustrates how Istio CNI integrates with Kubernetes network plugins like Calico or Cilium. Istio CNI modifies the node’s CNI configuration by appending itself to the CNI chain. After Kubernetes assigns a Pod IP, Istio CNI executes its interception logic and injects traffic redirection rules into the Pod’s network namespace.\n\nIt applies different \u0060iptables\u0060 rules depending on whether the Pod runs in Sidecar or Ambient mode, forming a chained CNI workflow that complements—rather than conflicts with—the existing network policies.\n\n![How Istio CNI Works](istio-cni.svg)\n\n### How the Istio CNI Plugin Works\n\nThe following diagram illustrates in detail what the Istio CNI does when a Pod starts:\n\n![How the Istio CNI Plugin Works](istio-cni-diagram.svg)\n\n1. It enters the Pod’s network namespace and creates a set of iptables rules to redirect traffic to the socket where **ztunnel** is listening.\n2. There’s no longer a need to inject an init container into each Pod, nor are elevated privileges required. This results in a cleaner and more secure deployment.\n3. **ztunnel** creates a socket inside each Pod’s network namespace, and does so for every Pod on the node.\n\n## Traffic Flow and Core Mechanisms\n\nAfter understanding the components, let’s dive into the heart of Ambient Mode: **the traffic path**. How do zTunnel and Waypoint intercept and forward traffic? We\u0027ll examine this through the lens of transparent traffic interception and the HBONE protocol.\n\n### Transparent Traffic Interception\n\nIn Ambient Mode, **Istio CNI** injects iptables rules into each Pod\u0027s network namespace to **transparently intercept outbound traffic** and redirect it to the local **ztunnel** process on the node. zTunnel then decides whether to forward traffic at L4 or send it to the **Waypoint Proxy** for L7 processing.\n\nAs shown in the diagram, when Kubelet starts a Pod on the node, this event is observed by the Istio CNI Agent. The agent enters the Pod’s network namespace, sets up iptables rules to redirect traffic to a local socket, and passes the Pod’s **file descriptor (FD)** to zTunnel. Once zTunnel receives the FD, it creates a socket within the Pod’s namespace.\n\nWhen the Pod sends traffic, it normally would go directly to the destination address. But because of the iptables rules, the traffic is intercepted and redirected to the local zTunnel process. zTunnel then determines whether the traffic needs L7 processing via Waypoint:\n\n- If not, it encrypts and forwards the traffic at **L4** directly to the destination Pod.\n- If **L7** functionality is needed (e.g., for authentication), it tunnels the traffic to the **Waypoint Proxy**.\n\n![Transparent Traffic Interception](transparent-traffic-interception.svg)\n\n### Packet Lifecycle Overview\n\n1. **Pod → ztunnel**: Traffic from the Pod is intercepted by the CNI and redirected to the local ztunnel on the same node.\n2. **ztunnel**: Resolves the destination address and applies mTLS encryption.\n3. **(If L7 policy is needed) ztunnel → Waypoint Proxy**: Handles HTTP authentication, routing, etc.\n4. **Waypoint Proxy**: After L7 processing, traffic is sent back to ztunnel.\n5. **ztunnel**: Decapsulates or forwards the traffic to the destination node’s ztunnel.\n6. **To the target Pod**: The destination ztunnel finally delivers the traffic to the target Pod.\n\n### The HBONE Protocol\n\nIn Ambient Mode, ztunnel and Waypoint Proxy use the **HBONE (HTTP\/2 \u002b CONNECT)** protocol to establish a secure tunnel. This enables **mTLS encryption** and multiplexing, reducing connection overhead and simplifying proxy forwarding logic.\n\n![HBONE Protocol](hbone-packet.svg)\n\nBelow is a simplified example of an HBONE CONNECT request, which uses headers like \u0060x-envoy-original-dst-host\u0060 and \u0060x-istio-auth-userinfo\u0060 to pass routing and authentication context:\n\n\u0060\u0060\u0060text\n:method: CONNECT\n:scheme: https\n:authority: Pod_B_IP:9080\n:path: \/api\/v1\/users?id=123\nx-envoy-original-dst-host: Pod_B_IP:9080\nx-forwarded-proto: hbone\nx-istio-attributes: ...\n...\n\u0060\u0060\u0060\n\nIn this example, assume ztunnel A is sending traffic to node B. The outer TCP connection is actually from \u0060ztunnel_A_IP:52368\u0060 to \u0060Node_B_IP:15008\u0060, where port 15008 is the HBONE listener on the destination node.\n\nAt the HTTP\/2 layer, a CONNECT request is initiated. The \u0060:authority\u0060 field shows \u0060Pod_B_IP:9080\u0060, indicating the actual destination port of Pod B. The \u0060x-envoy-original-dst-host\u0060 header carries the same target.\n\nYou’ll also notice custom headers like \u0060x-forwarded-proto\u0060 and \u0060x-istio-attributes\u0060, which carry routing context and security metadata for the receiving ztunnel or downstream proxy.\n\nThink of this as an “inner tunnel” built on top of HTTP\/2 CONNECT: the application-layer request (e.g., \u0060\/api\/v1\/users?id=123\u0060) is encapsulated inside, then unpacked by ztunnel B and forwarded to Pod B.\n\nThis entire process is transparent to the application. But by inspecting the CONNECT headers, we gain insight into how Ambient Mode performs traffic routing and identity verification at the HTTP\/2 layer. This flexibility makes HBONE a more adaptable alternative to traditional Sidecar-to-Sidecar communication, especially for implementing mTLS and L7 extensions.\n\n### Encrypted Traffic on the Same Node\n\nIf the source Pod and destination Pod happen to be on the same node, traffic goes through the ztunnel\u0027s L4 encryption path.\n\nAs shown here, ztunnel is deployed as a DaemonSet on each node and runs in the host network, sharing the host’s network namespace. Istio CNI intercepts the Pod\u0027s outbound traffic and redirects it to ztunnel’s port 15001. When both the source and destination Pods are on the same node, ztunnel performs encryption and decryption internally and directly forwards the traffic to the destination Pod.\n\nIf L7 traffic handling is required (e.g., authentication), ztunnel establishes an HBONE tunnel with the Waypoint proxy, and traffic is routed through the Waypoint before reaching the destination Pod.\n\n![Encrypted Traffic on the Same Node](ambient-traffic-on-the-same-node.svg)\n\n### Encrypted Traffic Across Nodes (L4)\n\nThis is the cross-node scenario, which is also the most common case:\n\nThe source node’s ztunnel encrypts the traffic via an HBONE tunnel and sends it to the destination node’s ztunnel. The destination ztunnel decapsulates the traffic and forwards it as plaintext to the destination Pod. As long as the traffic remains purely L4 and does not require L7 features, it avoids additional hops through a Waypoint proxy—reducing the proxy chain and improving efficiency.\n\n![Encrypted Traffic Across Nodes (L4)](ambient-traffic-on-the-same-node-l4.svg)\n\n### Encrypted Traffic Across Nodes (L7)\n\nWhen L7 processing is required, the traffic passes through an additional Waypoint proxy, following this flow:\n\n- The source ztunnel tunnels the traffic to the Waypoint proxy.\n- The Waypoint handles L7 logic like authentication and routing.\n- The Waypoint re-tunnels the traffic using HBONE to the destination ztunnel.\n- The destination ztunnel decapsulates the traffic and delivers it to the destination Pod.\n\n![Encrypted Traffic Across Nodes (L7)](ambient-traffic-on-the-same-node-l7.svg)\n\nThis process adds one extra proxy hop compared to L4-only traffic, but the benefit is that only traffic requiring L7 handling goes through this additional step—reducing unnecessary overhead.\n\n### Catch-All Traffic (Preventing Traffic Escape)\n\nFor traffic originating outside the Istio mesh that tries to access a Pod directly via its IP and port, Istio still needs to ensure such traffic is intercepted and managed by ztunnel to prevent it from bypassing the mesh.\n\nIf the traffic targets an application port, ztunnel checks whether the packet includes the \u00600x539\u0060 mark. If not, it redirects the traffic to port \u006015006\u0060, a plaintext port monitored by ztunnel. After processing, ztunnel adds the \u00600x539\u0060 mark and forwards it to the application port.\n\nIf the destination port is \u006015008\u0060, the packet is treated as HBONE traffic and directly handled by ztunnel.\n\n![Non-Mesh Traffic Routed into the Mesh](non-istio-mesh-pod-taffic-go-into-the-mesh.svg)\n\n### Differences Between L4 and L7 Traffic\n\n| Traffic Type | Processing Location             | Example Scenarios                                            |\n| ------------ | ------------------------------- | ------------------------------------------------------------ |\n| **L4**       | ztunnel (transparent forwarding) | TCP-level traffic that does not require application-layer policies |\n| **L7**       | ztunnel → Waypoint Proxy         | HTTP\/gRPC traffic requiring advanced features like auth, routing, observability, etc. |\n\nFor most traffic that only needs encryption and forwarding at the TCP layer, Ambient Mode relies solely on \u0060ztunnel\u0060. Only when HTTP-layer policies are required does the traffic get routed through the Waypoint proxy.\n\n## Ambient Mode vs. Sidecar Mode\n\nNow that we understand Ambient Mode, it\u0027s important to compare it with the traditional Sidecar model to evaluate which scenarios best fit each and what gaps remain.\n\n### Limitations of Ambient Mode\n\nCompared to the traditional Sidecar model, Ambient Mode still has some limitations:\n\n- When **mixing** Ambient and Sidecar modes, it’s difficult to apply fine-grained proxy configurations (e.g., \u0060EnvoyFilter\u0060) to individual Pods.\n- Support for **multi-cluster**, **multi-network**, and **VM** workloads is not yet mature and requires caution in production environments.\n- Some advanced customizations, such as **WASM plugins**, cannot be applied directly on a per-Pod basis in Ambient Mode.\n\n### Feature and Behavior Comparison\n\n| Criteria            | **Sidecar Mode**                                                   | **Ambient Mode**                                                  |\n| ------------------- | ------------------------------------------------------------------ | ----------------------------------------------------------------- |\n| **Proxy Location**  | Each Pod runs its own Envoy sidecar                                | Node-level **ztunnel** \u002b optional **Waypoint Proxy**              |\n| **Resource Overhead** | Higher CPU\/memory usage, especially in large-scale environments     | Lower overhead; proxies are shared at the node\/namespace level    |\n| **Operational Complexity** | Sidecar upgrades require rolling restarts of all affected Pods     | Upgrades are centralized to a few components (ztunnel\/Waypoint)   |\n| **Performance**     | Strong per-Pod isolation but added proxy cost per Pod              | Better L4 performance; L7 adds one more forwarding hop via Waypoint |\n| **Feature Completeness** | Mature and stable; supports multi-cluster, VMs, and hybrid networks  | Still evolving; multi-network, and VM support are under development |\n| **Typical Scenarios** | Scenarios requiring strict isolation or custom \u0060EnvoyFilter\u0060\/WASM   | Large-scale clusters, lightweight management, mostly L4 traffic   |\n\n### Recommendations\n\n1. If you\u0027re already using the **Sidecar** model and rely heavily on mature features, you can continue with Sidecar for now.\n2. If your priority is **resource savings** and **operational simplicity**, and most of your traffic is L4, try **Ambient Mode**.\n3. For hybrid needs, consider **mixed deployment**, but make sure to plan clearly around boundaries and policies for Sidecar vs. Ambient workloads.\n\n## Conclusion\n\nLet’s wrap up with a summary of Ambient Mode’s pros, cons, and where it fits best.\n\n### Key Takeaways\n\n1. **Ambient Mode** reduces per-Pod proxy overhead by removing the Sidecar, significantly lowering resource and operational costs.\n2. **ztunnel \u002b Waypoint architecture**: L7 functionality is only activated when necessary; all other traffic is forwarded efficiently at L4.\n3. Although Ambient Mode has reached **GA**, features like **multi-cluster \/ VM \/ multi-network** support still need further testing and validation.\n4. Recommended for: **large-scale clusters**, **primarily L4 traffic**, and teams with high demands on resource efficiency and centralized management.\n\nYou can find more cloud-native articles and practical insights on my blog at [jimmysong.io](https:\/\/jimmysong.io). If you have any questions about this post or Istio in general, feel free to leave a comment or join the community discussion. Thank you!', '\/en\/blog\/beyond-sidecar\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This post introduces the background, core components, traffic flow mechanisms, and comparisons between Ambient Mode and the traditional Sidecar model in Istio—helping you evaluate and get started with this new feature quickly.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-l7-flow-analysis/">Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 9, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy', 'An in-depth exploration of Istio ambient mode’s L7 traffic path, covering transparent interception, policy application, and traffic forwarding from ztunnel to waypoint proxy.', '\nIn Istio\u0027s ambient mode, **ztunnel** acts as a node-level security proxy responsible for L4 traffic interception and encryption between services. However, ztunnel doesn’t handle L7 tasks such as HTTP-based routing or policy enforcement. For L7 traffic management, **waypoint proxy**, powered by Envoy, processes HTTP requests and applies L7 policies. When ztunnel detects traffic requiring L7 processing, it forwards the traffic using the **HBONE protocol** to the waypoint proxy. The proxy applies policies, logs telemetry data, and forwards requests to the target Pod through ztunnel.\n\nThis post details this traffic forwarding path, breaking down how L7 traffic flows from **ztunnel** to **waypoint proxy** and ultimately to the target Pod.\n\n## Roles and Responsibilities in Ambient Mode\n\n### ztunnel (L4 Traffic Manager)\n\n- Intercepts traffic at L4 (TCP) level.\n- Secures traffic using mTLS encryption and authenticates service identities.\n\n### Waypoint Proxy (L7 Traffic Manager)\n\n- Manages L7 traffic policies such as HTTP routing, authentication, authorization, and telemetry.\n- Acts as an application-aware proxy, applying business-specific policies and sending metrics to the observability stack.\n\nWhen a request requires L7 handling (e.g., \u0060productpage\u0060 service calling \u0060reviews-v1\u0060), **ztunnel** **forwards traffic to waypoint proxy using HBONE**, enabling transparent policy application and telemetry collection.\n\n## L7 Traffic Path in Ambient Mode\n\nThe following diagram illustrates the L7 traffic path in Istio ambient mode:\n\n\u0060\u0060\u0060mermaid \u0022L7 Traffic Path in Ambient Mode\u0022\nsequenceDiagram\n    participant SP as Source Pod (productpage)\n    participant ZT1 as ztunnel (Source Node)\n    participant WP as Waypoint Proxy\n    participant ZT2 as ztunnel (Target Node)\n    participant DP as Target Pod (reviews-v1)\n\n    SP-\u003e\u003eZT1: HTTP Request (HTTP\/1.1)\n    Note over SP,ZT1: Traffic intercepted by ztunnel\n    ZT1-\u003e\u003eWP: Forward as HBONE Request (mTLS)\n    Note over ZT1,WP: Transparent interception \u0026 encryption\n    WP-\u003e\u003eZT2: Forward after applying L7 policies (mTLS)\n    Note over WP,ZT2: L7 policy applied and forwarded\n    ZT2-\u003e\u003eDP: Deliver to application port (TCP)\n    Note over ZT2,DP: Traffic redirected at target node\n    DP--\u003e\u003eZT2: Send back the response (TCP)\n    Note over DP,ZT2: Response generated by application\n    ZT2-\u003e\u003eWP: Forward response as HBONE (mTLS)\n    WP-\u003e\u003eZT1: Return response after applying policies (mTLS)\n    Note over WP,ZT1: Policy-applied response data\n    ZT1-\u003e\u003eSP: Return response (HTTP\/1.1)\n    Note over ZT1,SP: Response delivered back to application\n\u0060\u0060\u0060\n\n![L7 Traffic Path in Ambient Mode](447f9e24cd3cc95eb700cbd7e0b62816.svg)\n\nThe following two pictures respectively show the L7 traffic processing paths of the source Pod and the destination Pod in the same node and cross-node scenarios.\n\n![L7 traffic path of source pod and destination pod on the same node](hbone-same-node.svg)\n\n![L7 traffic path of source pod and destination pod on different nodes](hbone-cross-node.svg)\n\n### Traffic Path Breakdown\n\n### **1. Application Request Sent**\n\nThe \u0060productpage\u0060 service initiates an HTTP request to the \u0060reviews-v1\u0060 service at \u0060reviews.default.svc.cluster.local:9080\u0060.\n\n### 2. ztunnel L4 Traffic Interception\n\nZtunnel on the source node intercepts the outbound request from \u0060productpage\u0060 using Kubernetes’ \u0060iptables\u0060 rules. It inspects Istio\u0027s control plane configuration and determines that L7 policies must be applied.\n\n### 3. Forwarding Traffic Using HBONE Protocol\n\nZtunnel uses **HBONE protocol** instead of native Envoy-to-Envoy XDS or TCP\u002bmTLS tunneling. HBONE (HTTP-Based Overlay Network Environment) encapsulates traffic in HTTP\/2, enabling transparent forwarding of traffic for L7 processing.\n\nztunnel wraps the intercepted traffic into an HBONE tunnel and forwards it to waypoint proxy.\n\n### 4. L7 Processing and Policy Enforcement by Waypoint Proxy\n\nWaypoint proxy, built on Envoy, verifies the downstream client\u0027s mTLS credentials using SPIFFE IDs and contextual metadata for authentication. It then applies the following policies:\n\n- **HTTP Routing \u0026 Load Balancing:** Routes requests based on Host\/Path headers.\n- **Authorization Policies:** Validates access through headers and tokens.\n- **Traffic Shaping:** Injects faults, rate-limits requests, and implements retries.\n- **Telemetry Collection:** Tracks metrics, logs, traces, and request durations.\n\nWaypoint proxy forwards the processed traffic through HBONE to the target node’s ztunnel.\n\n### 5. Delivering Traffic to Target Pod\n\nztunnel on the target node receives traffic from waypoint proxy through HBONE, decapsulates the request, and forwards it to the target Pod (\u0060reviews-v1\u0060) on its application port.\n\n### Insights and Key Takeaways\n\n### 1. Transparent Routing via Waypoint Proxy\n\n- **Waypoint proxy** only knows the target Pod’s IP address and rewritten port \u006015008\u0060.\n- **ztunnel** manages traffic redirection using Kubernetes \u0060iptables\u0060.\n\n### 2. End-to-End Security\n\n- Mutual TLS (mTLS) with SPIFFE ID validation ensures secure traffic transmission.\n- Traffic **cannot bypass ztunnel**, enforcing a **Zero Trust Architecture**.\n\n### 3. Transparent Policy Enforcement\n\n- Developers don’t need to change the application code.\n- Traffic control, security, and telemetry are fully automated at the data plane level.\n\n## **How to Debug Ambient Mode?**\n\n### 1. ztunnel Debugging\n\nUse \u0060istioctl ztunnel\u0060 to inspect ztunnel configurations and states.\n\n### **2. Waypoint Proxy Debugging**\n\n- Use Envoy-specific commands such as \u0060istioctl pc\u0060 and \u0060istioctl ps\u0060 to inspect Envoy proxy configurations.\n- Use \u0060istioctl waypoint\u0060 for streamlined configuration inspection.\n\n## Conclusion\n\nIstio ambient mode uses **ztunnel** for L4 traffic processing, including transparent interception, mTLS encryption, and forwarding. L7 tasks such as HTTP-based routing, policy enforcement, and telemetry collection are managed by **waypoint proxy**, with communication between ztunnel and waypoint proxy facilitated by **HBONE protocol**.\n\nThis innovative design eliminates sidecars, simplifying operations while maintaining high performance, security, and observability.\n', '\/en\/blog\/istio-ambient-l7-flow-analysis\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth exploration of Istio ambient mode’s L7 traffic path, covering transparent interception, policy application, and traffic forwarding from ztunnel to waypoint proxy.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/http2-envoy-tunnel-demo/">Implementing HTTP/2 CONNECT Tunnels with Envoy: Concepts and Practical Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Feb 4, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Implementing HTTP\/2 CONNECT Tunnels with Envoy: Concepts and Practical Guide', 'A deep dive into creating transparent tunnels using HTTP\/2 CONNECT, including technical principles, practical workflows, and example code.', '\nAs part of my recent exploration into Istio Ambient mode, I discovered that the HTTP\/2 CONNECT method is a core technology for creating tunnels that enable transparent traffic interception and forwarding. HTTP\/2 CONNECT tunnel is a powerful tool that can create an efficient tunnel in an existing HTTP\/2 connection for transmitting raw TCP data. This article shows how to implement the basic functions of the HTTP\/2 CONNECT tunnel using Envoy through a simple Demo.\n\n## What Is HTTP\/2 CONNECT and HBONE Tunnel?\n\nThe HTTP\/2 CONNECT method provides a standardized approach for creating tunnels to transparently transmit data. In Istio Ambient mode, it offers an efficient way for proxy data planes to communicate. HBONE (HTTP-Based Overlay Network Environment) tunnel, built on HTTP\/2 CONNECT, is Istio’s implementation for transparent traffic interception and forwarding. Using HBONE, data can securely traverse the tunnel via HTTP\/2, offering a sidecar-less alternative. This innovative design simplifies the management and deployment of service meshes.\n\nHBONE, specific to Istio, is a secure tunneling protocol for communication between Istio components. Its current implementation incorporates three open standards:\n\n- **HTTP\/2**\n- **HTTP CONNECT**\n- **Mutual TLS (mTLS)**\n\nHTTP CONNECT establishes the tunnel, mTLS encrypts the connection, and HTTP\/2 multiplexes streams within the secure tunnel while transmitting stream-level metadata. For more details, see the [HBONE documentation](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/).\n\n## Basic Principles of HTTP\/2 CONNECT Tunnel Creation\n\nThe HTTP\/2 CONNECT method creates a VPN-like tunnel for secure data transmission. The basic steps are as follows:\n\n1. The client sends a standard TCP or HTTP request to the proxy.\n2. The proxy sends an HTTP\/2 CONNECT request to the target server on behalf of the client.\n3. If the server allows tunnel creation, it responds with an HTTP\/2 200 OK.\n5. Data flows bidirectionally between the client, proxy, and server through the tunnel.\n\nThis method ensures secure and transparent data transmission, particularly suited for scenarios requiring efficient communication and end-to-end encryption.\n\nBelow is a diagram showing the basic process of creating a tunnel using the HTTP\/2 CONNECT method:\n\n\u0060\u0060\u0060mermaid \u0022The basic process of establishing a tunnel using the HTTP2 Connect method\u0022\nsequenceDiagram\n    participant Client\n    participant Proxy\n    participant Server\n    Client-\u003e\u003eProxy: Standard TCP Request\n    Proxy-\u003e\u003eServer: CONNECT Request (HTTP\/2 CONNECT)\n    Server--\u003e\u003eProxy: HTTP\/2 200 OK\n    Proxy--\u003e\u003eClient: Forward 200 OK\n    Client-\u003e\u003eProxy: Start Data Transmission\n    Proxy-\u003e\u003eServer: Forward Data\n    Server-\u003e\u003eProxy: Return Processed Data\n    Proxy-\u003e\u003eClient: Forward Processed Data\n\u0060\u0060\u0060\n\n![The basic process of establishing a tunnel using the HTTP2 Connect method](6c8637147d93c860174fe0df8b21a0b3.svg)\n\n\n\n## Demo: Establishing an HTTP\/2 CONNECT Tunnel with Envoy\n\nIn this demo:\n\n- The **client** sends a text message to the **Envoy proxy**, which forwards it to the **server** through an **HTTP\/2 CONNECT tunnel**.\n- The **server** processes and replies to the message, with **Envoy** facilitating secure communication.\n- The **client** remains unaware of the tunnel\u0027s existence, experiencing a seamless connection.\n\nBelow is the architecture for this demo. To simplify the setup, we will configure TLS only for the server:\n\n\u0060\u0060\u0060mermaid \u0022Architecture Diagram\u0022\ngraph LR\n    Client[Client] --\u003e|TCP| Envoy[Envoy Proxy]\n    Envoy --\u003e|HTTP\/2 CONNECT \u002b TLS| Server[Server]\n\u0060\u0060\u0060\n\n![Architecture Diagram](b25a0e3bb0f015f7a0c8b280d1025f88.svg)\n\n### Directory Structure\n\nThe complete directory structure of this example is as follows:\n\n\u0060\u0060\u0060\nenvoy-http2-tunnel\/\n├── certs\/\n│   ├── openssl.cnf\n│   ├── server.crt\n│   ├── server.key\n├── client\/\n│   └── client.js\n├── docker-compose.yml\n├── envoy.yaml\n└── server\/\n    ├── Dockerfile\n    └── server.js\n\u0060\u0060\u0060\n\n### Key Steps in the Demo Setup\n\n1. **Generate Certificates:** Create self-signed certificates using OpenSSL.\n2. **Configure Envoy:** Define Envoy settings to accept client TCP connections and establish tunnels with the server.\n3. **Implement the Server:** Use Node.js to build an HTTP\/2 server that processes client messages.\n4. **Implement the Client:** Use Node.js to build a client that sends messages to the Envoy proxy.\n5. **Deploy Services:** Use Docker Compose to orchestrate Envoy and the server.\n6. **Test Communication:** Verify message flow from client to server and back through the HTTP\/2 CONNECT tunnel.\n\nBy following this guide, you can establish efficient, transparent, and secure traffic tunnels using HTTP\/2 CONNECT, a cornerstone of Istio\u0027s Ambient mode and HBONE technology.\n\n### Environment Preparation\n\n#### 1. Install Node.js\n\nEnsure that **Node.js** (version \u003e= **10.10.0**) is installed on your system, as the \u0060http2\u0060 module became stable starting with this version.\n\n- **Download Link:** [Node.js Official Website](https:\/\/nodejs.org\/)\n\n#### 2. Install Docker and Docker Compose\n\n- **Docker Download Link:** [Docker Official Website](https:\/\/www.docker.com\/get-started)\n- **Docker Compose Download Link:** [Docker Compose Official Documentation](https:\/\/docs.docker.com\/compose\/install\/)\n\n#### 3. Create a Project Directory\n\nCreate a new directory in your workspace and navigate to it:\n\n\u0060\u0060\u0060bash\nmkdir envoy-http2-tunnel\ncd envoy-http2-tunnel\n\u0060\u0060\u0060\n\n### Generating a Self-Signed Certificate\n\nTo enable encrypted communication between Envoy and the server, we need to generate a self-signed certificate with the correct configuration.\n\n#### 1. Create the Certificates Directory and OpenSSL Configuration File\n\nCreate the \u0060certs\u0060 directory:\n\n\u0060\u0060\u0060bash\nmkdir certs\ncd certs\n\u0060\u0060\u0060\n\nCreate an \u0060openssl.cnf\u0060 file with the following content:\n\n\u0060\u0060\u0060ini\n[ req ]\ndefault_bits       = 2048\ndefault_md         = sha256\nprompt             = no\ndistinguished_name = dn\nreq_extensions     = req_ext\n\n[ dn ]\nC            = US\nST           = California\nL            = San Francisco\nO            = My Company\nOU           = My Division\nCN           = server\n\n[ req_ext ]\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1   = server\nDNS.2   = localhost\n\u0060\u0060\u0060\n\n#### 2. Generate the Key and Certificate\n\nRun the following command to generate the key and certificate:\n\n\u0060\u0060\u0060bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout server.key -out server.crt -config openssl.cnf\n\u0060\u0060\u0060\n\nThis will generate the \u0060server.key\u0060 and \u0060server.crt\u0060 files in the \u0060certs\u0060 directory.\n\n### Configuring the Envoy Proxy\n\nWe need to configure Envoy to accept plain TCP connections from the client and forward the data to the server through an HTTP\/2 CONNECT tunnel.\n\n#### 1. Create the Envoy Configuration File\n\nIn the project root directory, create a file named \u0060envoy.yaml\u0060 with the following content:\n\n\u0060\u0060\u0060yaml\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        protocol: TCP\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.tcp_proxy\n        typed_config:\n          \u0022@type\u0022: type.googleapis.com\/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy\n          stat_prefix: tcp_stats\n          cluster: tunnel_cluster\n          tunneling_config:\n            hostname: server:8080\n          access_log:\n          - name: envoy.access_loggers.stdout\n            typed_config:\n              \u0022@type\u0022: type.googleapis.com\/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog\n              log_format:\n                json_format:\n                  start_time: \u0022%START_TIME%\u0022\n                  method: \u0022%REQ(:METHOD)%\u0022\n                  path: \u0022%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\u0022\n                  protocol: \u0022%PROTOCOL%\u0022\n                  response_code: \u0022%RESPONSE_CODE%\u0022\n                  response_flags: \u0022%RESPONSE_FLAGS%\u0022\n                  bytes_received: \u0022%BYTES_RECEIVED%\u0022\n                  bytes_sent: \u0022%BYTES_SENT%\u0022\n                  duration: \u0022%DURATION%\u0022\n                  upstream_service_time: \u0022%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\u0022\n                  x_forwarded_for: \u0022%REQ(X-FORWARDED-FOR)%\u0022\n                  user_agent: \u0022%REQ(USER-AGENT)%\u0022\n                  request_id: \u0022%REQ(X-REQUEST-ID)%\u0022\n                  upstream_host: \u0022%UPSTREAM_HOST%\u0022\n                  upstream_cluster: \u0022%UPSTREAM_CLUSTER%\u0022\n                  downstream_local_address: \u0022%DOWNSTREAM_LOCAL_ADDRESS%\u0022\n                  downstream_remote_address: \u0022%DOWNSTREAM_REMOTE_ADDRESS%\u0022\n  clusters:\n  - name: tunnel_cluster\n    connect_timeout: 5s\n    type: LOGICAL_DNS\n    lb_policy: ROUND_ROBIN\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \u0022@type\u0022: type.googleapis.com\/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        sni: server\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: \u0022\/certs\/server.crt\u0022\n          alpn_protocols: [ \u0022h2\u0022 ]\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: tunnel_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: server\n                port_value: 8080\n\u0060\u0060\u0060\n\n#### 2. Key Highlights of the Configuration\n\n- **TCP Proxy Listener:** Listens for incoming TCP connections on port \u006010000\u0060 and forwards traffic to the upstream server.\n- **HTTP\/2 Tunnel:** Configures Envoy to use HTTP\/2 CONNECT for tunneling traffic to the server.\n- **TLS Encryption:** Enables secure communication between Envoy and the upstream server using the generated \u0060server.crt\u0060 and \u0060server.key\u0060.\n- **Access Logs:** Configures detailed logs for request and response metrics.\n\nNext, proceed to set up the server and client components to test the tunnel functionality.\n\n### Implementing the Server\n\n#### 1. Create the Server Directory and Files\n\nCreate the \u0060server\u0060 directory in the project root:\n\n\u0060\u0060\u0060bash\nmkdir server\n\u0060\u0060\u0060\n\nInside the \u0060server\u0060 directory, create \u0060server.js\u0060 and \u0060Dockerfile\u0060.\n\n#### 2. Write \u0060server.js\u0060\n\nAdd the following code to \u0060server\/server.js\u0060:\n\n\u0060\u0060\u0060javascript\nconst http2 = require(\u0027http2\u0027);\nconst fs = require(\u0027fs\u0027);\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(\u0027\/certs\/server.key\u0027),\n  cert: fs.readFileSync(\u0027\/certs\/server.crt\u0027),\n});\n\nserver.on(\u0027stream\u0027, (stream, headers) =\u003e {\n  const method = headers[\u0027:method\u0027];\n  const path = headers[\u0027:path\u0027];\n\n  if (method === \u0027CONNECT\u0027) {\n    console.log(\u0060Received CONNECT request for ${path}\u0060);\n\n    \/\/ Respond with 200 to establish the tunnel\n    stream.respond({\n      \u0027:status\u0027: 200,\n    });\n\n    \/\/ Handle data within the tunnel\n    stream.on(\u0027data\u0027, (chunk) =\u003e {\n      const message = chunk.toString();\n      console.log(\u0060Received from client: ${message}\u0060);\n\n      \/\/ Respond to the client\n      const response = \u0060Echo from server: ${message}\u0060;\n      stream.write(response);\n    });\n\n    stream.on(\u0027end\u0027, () =\u003e {\n      console.log(\u0027Stream ended by client.\u0027);\n      stream.end();\n    });\n  } else {\n    \/\/ Return 404 for non-CONNECT requests\n    stream.respond({\n      \u0027:status\u0027: 404,\n    });\n    stream.end();\n  }\n});\n\n\/\/ Start the server and listen on port 8080\nserver.listen(8080, () =\u003e {\n  console.log(\u0027Secure HTTP\/2 server is listening on port 8080\u0027);\n});\n\u0060\u0060\u0060\n\n**Notes:**\n\n- It listens for the \u0060secureConnection\u0060 event to process TLS-secured sockets.\n- The server reads incoming data from the socket, processes client messages, and sends responses.\n\n#### 3. Create the \u0060Dockerfile\u0060\n\nAdd the following content to \u0060server\/Dockerfile\u0060:\n\n\u0060\u0060\u0060dockerfile\nFROM node:14\n\nWORKDIR \/app\n\nCOPY server.js .\n\nEXPOSE 8080\n\nCMD [\u0022node\u0022, \u0022server.js\u0022]\n\u0060\u0060\u0060\n\n### Implementing the Client\n\n#### 1. Create the Client Directory and Files\n\nCreate the \u0060client\u0060 directory in the project root:\n\n\u0060\u0060\u0060bash\nmkdir client\n\u0060\u0060\u0060\n\nInside the \u0060client\u0060 directory, create \u0060client.js\u0060.\n\n#### 2. Write \u0060client.js\u0060\n\nAdd the following code to \u0060client\/client.js\u0060:\n\n\u0060\u0060\u0060javascript\nconst net = require(\u0027net\u0027);\n\n\/\/ Create a TCP connection to Envoy\nconst client = net.createConnection({ port: 10000 }, () =\u003e {\n  console.log(\u0027Connected to Envoy.\u0027);\n\n  \/\/ Send messages to the server\n  let counter = 1;\n  const interval = setInterval(() =\u003e {\n    const message = \u0060Message ${counter} from client!\u0060;\n    client.write(message);\n    counter \u002b= 1;\n  }, 1000);\n\n  \/\/ Close the connection\n  setTimeout(() =\u003e {\n    clearInterval(interval);\n    client.end();\n  }, 5000);\n});\n\nclient.on(\u0027data\u0027, (data) =\u003e {\n  console.log(\u0060Received from server: ${data.toString()}\u0060);\n});\n\nclient.on(\u0027end\u0027, () =\u003e {\n  console.log(\u0027Disconnected from server.\u0027);\n});\n\nclient.on(\u0027error\u0027, (err) =\u003e {\n  console.error(\u0027Client error:\u0027, err);\n});\n\u0060\u0060\u0060\n\n**Explanation:**\n\n- The **client** establishes a standard TCP connection with **Envoy** and sends text messages.\n- This client\u0027s existence only triggers Envoy to establish a tunnel with the server.\n\n### Creating the Docker Compose File\n\nCreate \u0060docker-compose.yml\u0060 in the project root:\n\n\u0060\u0060\u0060yaml\nversion: \u00273.8\u0027\n\nservices:\n  envoy:\n    image: envoyproxy\/envoy:v1.32.1\n    volumes:\n      - .\/envoy.yaml:\/etc\/envoy\/envoy.yaml\n      - .\/certs:\/certs  # Mount the certificates directory\n    ports:\n      - \u002210000:10000\u0022\n    networks:\n      - envoy_network\n    depends_on:\n      - server\n    command: \/usr\/local\/bin\/envoy -c \/etc\/envoy\/envoy.yaml --service-cluster envoy --log-level debug\n\n  server:\n    build:\n      context: .\/server\n    networks:\n      - envoy_network\n    expose:\n      - \u00228080\u0022\n    volumes:\n      - .\/certs:\/certs  # Mount the certificates directory\n\nnetworks:\n  envoy_network:\n\u0060\u0060\u0060\n\nThis configuration sets up both the Envoy proxy and the server to operate within the same Docker network, facilitating seamless communication.\n\n### Running the Example\n\n#### 1. Start Docker Compose\n\nIn the project root directory, run:\n\n\u0060\u0060\u0060bash\ndocker-compose up --build\n\u0060\u0060\u0060\n\n**Expected Output:**\n\n- **Envoy Container:** Displays startup information and debug logs.\n- **Server Container:** Displays \u0060Secure HTTP\/2 server is listening on port 8080\u0060.\n\n#### 2. Run the Client\n\nOpen a new terminal, navigate to the \u0060client\u0060 directory:\n\n\u0060\u0060\u0060bash\ncd client\n\u0060\u0060\u0060\n\nRun the client:\n\n\u0060\u0060\u0060bash\nnode client.js\n\u0060\u0060\u0060\n\n**Expected Output:**\n\n\u0060\u0060\u0060\nConnected to Envoy.\nReceived from server: Echo from server: Message 1 from client!\nReceived from server: Echo from server: Message 2 from client!\nReceived from server: Echo from server: Message 3 from client!\nReceived from server: Echo from server: Message 4 from client!\nReceived from server: Echo from server: Message 5 from client!\nDisconnected from server.\n\u0060\u0060\u0060\n\n#### 3. Check Server Logs\n\nIn the Docker Compose output, you should see logs from the server:\n\n\u0060\u0060\u0060\nenvoy_1   | {\u0022downstream_remote_address\u0022:\u0022192.168.65.1:46306\u0022,\u0022path\u0022:null,\u0022request_id\u0022:null,\u0022bytes_sent\u0022:160,\u0022protocol\u0022:null,\u0022upstream_service_time\u0022:null,\u0022bytes_received\u0022:88,\u0022response_code\u0022:0,\u0022user_agent\u0022:null,\u0022downstream_local_address\u0022:\u0022172.21.0.3:10000\u0022,\u0022upstream_host\u0022:\u0022172.21.0.2:8080\u0022,\u0022start_time\u0022:\u00222024-12-03T11:37:59.542Z\u0022,\u0022upstream_cluster\u0022:\u0022tunnel_cluster\u0022,\u0022duration\u0022:5012,\u0022response_flags\u0022:\u0022-\u0022,\u0022method\u0022:null,\u0022x_forwarded_for\u0022:null}\nserver_1  | Secure HTTP\/2 server is listening on port 8080\nserver_1  | New secure connection established.\nserver_1  | Received from client: Message 1 from client!\nserver_1  | Received from client: Message 2 from client!\nserver_1  | Received from client: Message 3 from client!\nserver_1  | Received from client: Message 4 from client!\nserver_1  | Received from client: Message 5 from client!\nserver_1  | Connection ended by client.\n\u0060\u0060\u0060\n\n#### 4. Check Envoy Logs\n\nIn Envoy’s logs, you can see records of the connection established with the server using the **HTTP\/2 CONNECT tunnel**.\n\n### Testing the Communication\n\n- **The client** sends text messages to **Envoy** over a TCP connection.\n- **Envoy** forwards the client’s TCP traffic to the **server** via an **HTTP\/2 CONNECT tunnel**.\n- **The server** receives the messages, processes them, and replies to the client.\n- **Envoy** relays the server’s responses back to the **client** through the tunnel.\n- **The client** receives the responses from server.\n\n### Notes\n\n- **Certificate Management:** Ensure the certificates are properly configured and used in both Envoy and the server.\n- **Docker Networking:** Use Docker Compose-defined networks to allow containers to communicate using service names.\n- **Port Conflicts:** Ensure ports \u006010000\u0060 (Envoy) and \u00608080\u0060 (server) are not occupied.\n- **TLS Configuration:** In this example, communication between Envoy and the server is secured with TLS and HTTP\/2.\n\n## Tunnel Establishment Process\n\nThe following diagram illustrates the interaction between the client, Envoy proxy, and server, showing how data is transmitted and the tunnel connection is established:\n\n\u0060\u0060\u0060mermaid \u0022Tunnel Establishment Process\u0022\nsequenceDiagram\n\nparticipant Client\nparticipant Envoy\nparticipant Server\n\n%% Client connects to Envoy via TCP\nClient-\u003e\u003eEnvoy: TCP Connect\nEnvoy--\u003e\u003eClient: Connection Established\n\n%% Envoy creates a new TCP proxy session\nNote over Envoy: Create new TCP proxy session (ConnectionId: 0)\n\n%% Envoy connects to the upstream server\nEnvoy-\u003e\u003eServer: Connect to tunnel_cluster\nNote over Envoy,Server: Attempt to establish new connection (ConnectionId: 1)\n\n%% Envoy establishes HTTP\/2 connection with the server\nEnvoy-\u003e\u003eServer: Establish HTTP\/2 Connection\nServer--\u003e\u003eEnvoy: Connection Established\n\n%% Envoy establishes the HTTP\/2 CONNECT tunnel\nEnvoy-\u003e\u003eServer: HTTP\/2 CONNECT (hostname: server:8080)\nServer--\u003e\u003eEnvoy: 200 OK (Tunnel Established)\nNote over Envoy,Server: Tunnel established successfully\n\n%% Client sends data\nloop Send Messages\nClient-\u003e\u003eEnvoy: Data (Message N)\nEnvoy-\u003e\u003eServer: Forward Data (Message N)\nServer--\u003e\u003eEnvoy: Response (Echo Message N)\nEnvoy--\u003e\u003eClient: Forward Response (Echo Message N)\nServer--\u003e\u003eServer: Log \u0022Received from client: Message N from client!\u0022\nend\n\n%% Client closes the connection\nClient-\u003e\u003eEnvoy: FIN (Close Connection)\nEnvoy-\u003e\u003eServer: FIN (Close Tunnel)\nServer--\u003e\u003eEnvoy: ACK\nEnvoy--\u003e\u003eClient: ACK\nNote over Envoy,Server: Tunnel closed\nNote over Envoy,Client: Connection closed\n\n%% Log connection closure\nEnvoy--\u003e\u003eEnvoy: Log Connection Closed (ConnectionId: 0 \u0026 1)\nServer--\u003e\u003eServer: Log \u0022Stream ended by client.\u0022\n\u0060\u0060\u0060\n\n![Tunnel Establishment Process](e2f47e2631af2b2e8f72dadc4f82fe94.svg)\n\n\n\nExplanation:\n\n1. **Client connects to Envoy via TCP:**\n   - The client sends a TCP connection request to Envoy.\n   - Envoy accepts the connection and creates a new TCP proxy session (ConnectionId: 0).\n\n2. **Envoy establishes a connection with the server:**\n   - Envoy connects to the upstream cluster \u0060tunnel_cluster\u0060, creating a new connection (ConnectionId: 1).\n\n3. **Establishing the HTTP\/2 CONNECT tunnel:**\n   - Envoy establishes an HTTP\/2 connection with the server.\n   - Envoy sends an HTTP\/2 CONNECT request with the target hostname \u0060server:8080\u0060.\n   - The server responds with \u0060200 OK\u0060, successfully establishing the tunnel.\n\n4. **Data transmission:**\n   - **Message exchange loop:**\n     - The client sends data (\u0060Message N\u0060) to Envoy.\n     - Envoy forwards the data through the tunnel to the server.\n     - The server processes the data and responds (\u0060Echo Message N\u0060).\n     - Envoy forwards the response back to the client.\n   - **Logging:**\n     - The server logs each received message, e.g., \u0060Received from client: Message N from client!\u0060.\n\n5. **Closing the connection:**\n   - The client sends a FIN request to close the connection.\n   - Envoy forwards the FIN request to the server, closing the tunnel.\n   - The server acknowledges the FIN with an ACK.\n   - Envoy sends the ACK to the client, completing the connection closure.\n\n6. **Logging:**\n   - Envoy logs the closure of connections, including ConnectionId and stats.\n   - The server logs the closure, e.g., \u0060Stream ended by client.\u0060.\n\n## Conclusion\n\nAlthough this is an introductory example, it provides a solid foundation for understanding and further exploring the HTTP\/2 CONNECT tunnel function. In the next blog, I will explain the tunnel implemented by two Envoy proxies and take you to further understand the HBONE transparent tunnel in the Istio ambient mode.\n\n## References\n\n - [HTTP upgrades — envoy 1.33.0-dev-6d8d0b documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/http\/upgrades)\n - [envoy\/configs\/proxy\\_connect.yaml at 6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3 · envoyproxy\/envoy · GitHub](https:\/\/github.com\/envoyproxy\/envoy\/blob\/6d8d0b0ee2cc267b2cd9f57eb952863ddc8e49c3\/configs\/proxy_connect.yaml)\n', '\/en\/blog\/http2-envoy-tunnel-demo\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into creating transparent tunnels using HTTP/2 CONNECT, including technical principles, practical workflows, and example code.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-packet-lifecycle-optimization/">Packet Lifecycle and Traffic Optimization in Istio Ambient Mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 29, 2025</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Packet Lifecycle and Traffic Optimization in Istio Ambient Mode', 'An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.', '\nThis article provides an in-depth analysis of the packet lifecycle in Istio Ambient Mode. It covers everything from the interception and target resolution of initial packets to the fast forwarding and optimization strategies for subsequent packets, helping readers better understand the technical logic and performance practices behind Ambient Mode.\n\n## Overview of Packet Lifecycle: From Kernel Space to User Space\n\nIn Ambient Mode, packet processing starts in the kernel space network stack of a Pod, where packets are intercepted by iptables rules and then processed by zTunnel in user space. zTunnel handles tasks such as transparent proxying, policy enforcement, and encrypted tunnel creation. Packets are then sent back to the kernel space network for forwarding to the target service or another zTunnel. The core idea is to analyze and tag the first packet in detail to pave the way for subsequent packets, thereby reducing redundant overhead.\n\nThe diagram below illustrates the packet lifecycle from a Pod to zTunnel in Istio Ambient Mode.\n\n\u0060\u0060\u0060mermaid \u0022Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel\u0022\nsequenceDiagram\n    participant App as Application\n    participant PodKernel as Pod Kernel-Space Network Stack\n    participant ipt as iptables\n    participant ztunnel as ztunnel User-Space Processing\n    participant HostKernel as Host Kernel-Space\n    participant Service as Destination Service or Next ztunnel\n\n    rect rgb(240, 249, 255)\n    note over App: Initial Packet Path\n    App-\u003e\u003ePodKernel: Sends the first packet\n    PodKernel-\u003e\u003eipt: Checks iptables redirection rules\n    ipt-\u003e\u003eztunnel: Redirects packet to zTunnel transparent proxy port\n    ztunnel-\u003e\u003eztunnel: Extracts destination address \u0026 policy validation \u0026 establishes tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the processed packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\n    rect rgb(240, 255, 240)\n    note over App: Subsequent Packet Path\n    App-\u003e\u003ePodKernel: Sends subsequent packets\n    PodKernel-\u003e\u003ePodKernel: Matches existing connection using conntrack\n    PodKernel-\u003e\u003eztunnel: Packet directly enters ztunnel inbound socket (no iptables redirection needed)\n    ztunnel-\u003e\u003eztunnel: No need for re-parsing \u0026 reuses existing tunnel\/connection\n    ztunnel-\u003e\u003eHostKernel: Returns the packet\n    HostKernel-\u003e\u003eService: Forwards to the destination service or next ztunnel\n    end\n\u0060\u0060\u0060\n\n![Packet Lifecycle in Istio Ambient Mode from a Pod to ztunnel](0af66a9ca6d1db3f9e14e2e19e3210fb.svg)\n\nThe following sections will detail the processing paths for both the first packet and subsequent packets, analyzing the technical highlights and optimization strategies.\n\n## First Packet Path: From Interception to Destination Resolution\n\n### Initial Packet Emission\n\nWhen an application in a Pod emits a packet (e.g., an HTTP request), the packet is first processed by the Pod’s network namespace and kernel space network stack.\n\n### Transparent Interception via Iptables\n\n*iptables* rules filter outbound traffic. If the destination address is non-local and the packet lacks specific tags, it is redirected to zTunnel’s transparent proxy port (e.g., 15006 or 15008). Using *IP_TRANSPARENT* and *SO_ORIGINAL_DST* options, zTunnel can extract the packet’s original destination address in user space. This ensures transparent proxying for services located on the same node, across nodes, or outside the mesh.\n\n### Policy Validation and Processing in zTunnel User Space\n\nOnce in zTunnel, the first packet undergoes policy and security checks such as RBAC validation and mTLS encryption determination. For in-mesh traffic, an HTTP\/2 CONNECT tunnel (HBONE) is established for encrypted cross-node communication. For out-of-mesh traffic, direct TCP transmission is used.\n\n### Packet Egress and Connection Establishment\n\nAfter processing, zTunnel establishes an outbound socket (e.g., HTTP\/2 tunnel or plaintext TCP connection) based on the packet’s parsed details, sends it back to the kernel space, and routes it to the target service or zTunnel.\n\nAt this point, the first packet has completed a full journey from kernel space to user space and back. Connection states, policies, and tunnel information are recorded to optimize subsequent packets.\n\n## Subsequent Packet Path: Fast Forwarding with Conntrack and Tunnel Reuse\n\nOnce the first packet completes destination resolution and policy validation, the Linux kernel’s connection tracking (conntrack) records the connection state and tags it. Subsequent packets belonging to the same connection bypass complex iptables redirection and destination resolution, directly reaching zTunnel’s inbound socket.\n\n### Role of Conntrack\n\n*conntrack* tracks existing connections, providing a fast path for subsequent packets. This allows packets to be forwarded directly to zTunnel without repeatedly triggering *iptables* rules or undergoing policy checks.\n\n### Inbound Socket and User Space Processing\n\nSubsequent packets entering zTunnel’s inbound socket are directly identified by connection tags, skipping complex RBAC validation or encryption decisions. If an encrypted tunnel (HBONE) was established for the first packet, subsequent packets reuse this tunnel. For plaintext traffic, the existing TCP connection is used for direct transmission.\n\n### Optimization for Tunnel and Plaintext Paths\n\n- **HBONE Tunnel:** For in-mesh encrypted traffic, HTTP\/2 tunnels enable multiplexing, reducing repeated connection overhead.\n- **Plaintext Socket:** For local or external unencrypted traffic, subsequent packets use the existing plaintext connection, avoiding extra encapsulation.\n\nThese mechanisms greatly simplify the processing path for subsequent packets, improving performance and throughput.\n\n## Key Technical Points and Optimization Strategies\n\n1. **Transparent Proxying:** Using IP_TRANSPARENT and SO_ORIGINAL_DST, zTunnel seamlessly captures and parses non-local traffic, achieving true transparent proxying.\n2. **Efficient Kernel-User Space Switching:** By completing detailed parsing and policy validation for the first packet in user space, and leveraging conntrack and inbound socket mechanisms for subsequent packets, unnecessary context switching is minimized.\n3. **Multiplexed Tunnels:** HTTP\/2 CONNECT tunnels (HBONE) support encryption, load balancing, and multiplexing, enhancing efficiency for subsequent packet forwarding.\n\n## Practical Recommendations and Considerations\n\n- **Multi-Platform Adaptation:** Transparent proxying relies on Linux features. For non-Linux platforms (e.g., Windows, macOS), local proxies or alternative solutions may be required.\n- **Tuning and Observability:** Use zTunnel logs, connection tracking, and mesh observability tools to monitor traffic paths and performance. Fine-tune iptables rules, RBAC policies, and tunnel parameters based on data and results.\n\n## Conclusion\n\nIstio Ambient Mode introduces innovative designs for packet lifecycle and traffic optimization. By performing comprehensive policy parsing and encryption negotiation for the first packet, and leveraging conntrack for fast forwarding of subsequent packets, Ambient Mode strikes a balance between transparent proxying, scalability, and performance.\n\nAs the core component of Ambient Mode, zTunnel combines transparent application experience with underlying network optimization, meeting service mesh security and policy requirements while significantly reducing redundant overhead. This makes traffic processing more efficient and seamless.', '\/en\/blog\/istio-ambient-packet-lifecycle-optimization\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">An in-depth analysis of the detailed processing of initial packets in Istio Ambient Mode, followed by fast forwarding and traffic optimization strategies for subsequent packets.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 20, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('In-Pod IPtables Rule Injection in Istio Ambient Mode Explained', 'A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.', '\nIn my [previous blog post](\/en\/blog\/istio-ambient-traffic-interception\/), I provided an overview of the iptables rules injected within pod network namespaces in Istio ambient mode. This article takes a closer look at these rules, explaining how they achieve transparent traffic interception and redirection within pods.\n\n## iptables Rules Inside the Pod\n\nIn a pod\u0027s network namespace, the Istio CNI Node Agent sets up a series of iptables rules to enable transparent traffic interception and redirection. The following rules, injected into the \u0060mangle\u0060 and \u0060nat\u0060 tables, demonstrate how Istio processes inbound and outbound traffic.\n\n\u0060\u0060\u0060python\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*mangle\n:PREROUTING ACCEPT [99138:22880045]  # Default ACCEPT policy for the PREROUTING chain in the mangle table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the mangle table.\n:FORWARD ACCEPT [0:0]                # Default ACCEPT policy for the FORWARD chain in the mangle table.\n:OUTPUT ACCEPT [100900:34940164]     # Default ACCEPT policy for the OUTPUT chain in the mangle table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the mangle table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -m connmark --mark 0x111\/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\n# Restore connection mark 0x111\/0xfff for consistent connection tracking.\n\n-A ISTIO_PRERT -m mark --mark 0x539\/0xfff -j CONNMARK --set-xmark 0x111\/0xfff\n# Set connection mark to 0x111\/0xfff for packets marked 0x539\/0xfff in PREROUTING.\n\nCOMMIT  # Apply mangle table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\n# Generated by iptables-save v1.8.9 (nf_tables) on Thu Nov 14 08:43:17 2024\n*nat\n:PREROUTING ACCEPT [2:120]           # Default ACCEPT policy for the PREROUTING chain in the nat table.\n:INPUT ACCEPT [0:0]                  # Default ACCEPT policy for the INPUT chain in the nat table.\n:OUTPUT ACCEPT [119:9344]            # Default ACCEPT policy for the OUTPUT chain in the nat table.\n:POSTROUTING ACCEPT [0:0]            # Default ACCEPT policy for the POSTROUTING chain in the nat table.\n:ISTIO_OUTPUT - [0:0]                # Custom ISTIO_OUTPUT chain for handling outbound NAT traffic.\n:ISTIO_PRERT - [0:0]                 # Custom ISTIO_PRERT chain for handling prerouting NAT traffic.\n-A PREROUTING -j ISTIO_PRERT         # Direct all PREROUTING traffic to the ISTIO_PRERT chain.\n-A OUTPUT -j ISTIO_OUTPUT            # Direct all OUTPUT traffic to the ISTIO_OUTPUT chain.\n-A ISTIO_OUTPUT -d 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic destined for 169.254.7.127 (likely an internal Istio address).\n\n-A ISTIO_OUTPUT -p tcp -m mark --mark 0x111\/0xfff -j ACCEPT\n# Allow TCP traffic marked as 0x111\/0xfff.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -o lo -j ACCEPT\n# Allow traffic to the loopback interface excluding 127.0.0.1.\n\n-A ISTIO_OUTPUT ! -d 127.0.0.1\/32 -p tcp -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15001\n# Redirect outbound TCP traffic (not marked 0x539\/0xfff) destined outside 127.0.0.1 to port 15001 (outbound socket).\n\n-A ISTIO_PRERT -s 169.254.7.127\/32 -p tcp -m tcp -j ACCEPT\n# Allow TCP traffic originating from 169.254.7.127 in the PREROUTING chain.\n\n-A ISTIO_PRERT ! -d 127.0.0.1\/32 -p tcp -m tcp ! --dport 15008 -m mark ! --mark 0x539\/0xfff -j REDIRECT --to-ports 15006\n# Redirect inbound TCP traffic (not marked 0x539\/0xfff) to port 15006 (inbound socket) if its destination port is not 15008.\n\nCOMMIT  # Apply nat table rules.\n# Completed on Thu Nov 14 08:43:17 2024\n\u0060\u0060\u0060\n\n### Role of Specific Ports\n\nThese iptables rules differentiate and handle various types of traffic using specific ports:\n\n- **15008 (HBONE socket)**: Handles HTTP-based traffic transparently using the HBONE protocol.\n- **15006 (plaintext socket)**: Manages unencrypted traffic within the mesh for inter-pod communication.\n- **15001 (outbound socket)**: Controls outbound traffic and enforces policies for accessing external services.\n\nBy leveraging these ports, Istio enables transparent management and control of inbound, outbound, and internal traffic, enforcing fine-grained security policies and traffic controls. For more information, refer to [Istio Application Requirements](https:\/\/istio.io\/latest\/docs\/ops\/deployment\/application-requirements\/).\n\n### Significance of \u00600x539\u0060 Mark\n\nThe \u00600x539\u0060 mark identifies traffic originating from Istio proxies (e.g., ztunnel). This mark is applied to distinguish packets processed by proxies, ensuring they are not reprocessed or misrouted.\n\n### Significance of \u00600x111\u0060 Mark\n\nThe \u00600x111\u0060 mark is used for connection-level marking within the Istio mesh, indicating that a connection has been processed by a proxy. The \u0060CONNMARK\u0060 module in iptables extends this mark to the entire connection, speeding up subsequent packet matching.\n\n## Visualizing iptables Rules\n\nThe following diagram illustrates the execution path of traffic through iptables rules, helping to understand how traffic is matched and redirected:\n\n\u0060\u0060\u0060mermaid \u0022iptables Rules Visualization\u0022\ngraph TD\nA[Traffic enters pod namespace] --\u003e B{Traffic direction}\nB -- Inbound --\u003e C[PREROUTING chain]\nC --\u003e D[ISTIO_PRERT chain]\nD --\u003e E{Source is 169.254.7.127?}\nE -- Yes --\u003e F[ACCEPT]\nE -- No --\u003e G{Destination is 127.0.0.1?}\nG -- Yes --\u003e F[ACCEPT]\nG -- No --\u003e H{Destination port is 15008?}\nH -- Yes --\u003e F[ACCEPT]\nH -- No --\u003e I{Packet marked 0x539?}\nI -- Yes --\u003e F[ACCEPT]\nI -- No --\u003e J[REDIRECT to port 15006]\nB -- Outbound --\u003e K[OUTPUT chain]\nK --\u003e L[ISTIO_OUTPUT chain]\nL --\u003e M{Destination is 169.254.7.127?}\nM -- Yes --\u003e N[ACCEPT]\nM -- No --\u003e O{Packet marked 0x111?}\nO -- Yes --\u003e N[ACCEPT]\nO -- No --\u003e P{Destination is 127.0.0.1 and output interface is lo?}\nP -- Yes --\u003e N[ACCEPT]\nP -- No --\u003e Q{Packet marked 0x539?}\nQ -- Yes --\u003e N[ACCEPT]\nQ -- No --\u003e R[REDIRECT to port 15001]\n\u0060\u0060\u0060\n\n![iptables Rules Visualization](05fa21587176b2333b3857e039764cd4.svg)\n\nFor further details on how Istio CNI handles iptables, refer to the source code: [istio\/cni\/pkg\/iptables\/iptables.go at master · istio\/istio · GitHub](https:\/\/github.com\/istio\/istio\/blob\/master\/cni\/pkg\/iptables\/iptables.go).\n\nSure, here is the English translation:\n\n------\n\n## Traffic Routing Visualization\n\nThe following diagram illustrates the path of **cross-node encrypted L4 traffic**:\n\n![Cross-node encrypted traffic (L4)](ambient-traffic-on-the-different-node-l4.svg)\n\n1. **Application Sends Request**: Traffic is initiated by the application process and enters the pod\u0027s network namespace.\n2. **iptables Rule Matching**:\n   - **Outbound traffic** is matched in the \u0060OUTPUT\u0060 chain, where eligible traffic is redirected to the \u0060ISTIO_OUTPUT\u0060 chain.\n   - In the \u0060ISTIO_OUTPUT\u0060 chain, the traffic is marked and accepted.\n3. **REDIRECT Action**: Traffic is captured by iptables and redirected to ztunnel’s listening port (15006 for plaintext, 15008 for encrypted traffic).\n4. **ztunnel Processes Traffic**: ztunnel receives the traffic, performs policy checks, encryption, and other operations.\n5. **Traffic is Forwarded to Target Service**: ztunnel sends the processed traffic through the HBONE tunnel to the ztunnel on the destination node, which then decrypts and delivers it to the target service.\n\nFor more details on traffic routing across nodes, layers (L4\/L7), and how Istio Ambient prevents traffic bypass, see the blog [Beyond Sidecar: A Deep Dive Into Istio Ambient Mode Traffic Mechanism and Cost Efficiency](\/en\/blog\/beyond-sidecar\/).\n\n## Conclusion\n\nBy analyzing the iptables rules in Istio ambient mode, we see how Istio’s CNI plugin establishes a transparent traffic interception mechanism within pods. These rules ensure that traffic entering and leaving pods is correctly handled by ztunnel, enabling finer-grained traffic management and security policy enforcement. Stay tuned for more deep dives into Istio ambient mode networking!\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-iptables-rule-injection\/).*', '\/en\/blog\/istio-ambient-inpod-iptables\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into how iptables rules in Istio ambient mode enable transparent traffic interception and control within Pods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Detailed Explanation of Transparent Traffic Interception in Istio ambient mode', 'This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.', '\nThis is the first article in my series on Istio ambient mode. In the upcoming posts, I will delve deeper into the key components and their working principles, including how ztunnel forwards traffic to the waypoint proxy, how the waypoint proxy handles the traffic, and a comprehensive analysis of the traffic path using the Bookinfo example. Since traffic interception is the foundation of service mesh functionality, I chose to start with it to provide a solid understanding.\n\nIstio ambient mode is a service mesh implementation that eliminates the need for sidecar injection into each pod. By configuring transparent traffic interception and redirection within the pod\u0027s network namespace, applications can leverage service mesh capabilities without any modifications. The following content provides a detailed explanation of the transparent traffic interception process, covering components such as **Istio CNI Node Agent**, **ztunnel**, **network namespaces**, and **iptables rules**, illustrated with flowcharts and diagrams.\n\n## Background Knowledge\n\n### Linux Network Namespaces\n\n**Network namespaces** are a Linux kernel feature used to isolate the network environment of different processes. Each network namespace has its own network devices, IP addresses, routing tables, and iptables rules. Container technologies (e.g., Docker, Kubernetes) use network namespaces to provide each container (or pod) with an isolated network stack.\n\n### Istio CNI Node Agent\n\n**Istio CNI Node Agent** is a core component of ambient mode that operates on Kubernetes nodes, detecting pods joining the Ambient mesh and configuring traffic redirection rules for these pods. Note that this involves the Istio CNI Node Agent, not the traditional Istio CNI plugin. The Node Agent acts as a daemon working alongside ztunnel but does not directly perform network plugin tasks.\n\n### ztunnel\n\n**ztunnel** is a critical component in ambient mode, running as a DaemonSet on each node. Its responsibilities include:\n\n- Receiving and processing redirected traffic.\n- Enforcing L4 policies such as mTLS encryption and access control.\n- Communicating with the control plane to obtain configurations and certificates.\n\n### HBONE (HTTP-Based Overlay Network Encapsulation)\n\n**HBONE (HTTP-Based Overlay Network Encapsulation)** is a protocol introduced by Istio for transmitting arbitrary TCP traffic between ztunnel and waypoint proxy. HBONE leverages HTTP\/2 and HTTP\/3 multiplexing and encryption features for enhanced communication efficiency and security.\n\n## Detailed Traffic Interception Process\n\nIn ambient mode, application pods require no code changes or sidecar injection. Traffic interception and redirection occur entirely within the **pod\u0027s network namespace**, avoiding conflicts with the underlying CNI. Here’s an overview of the steps involved:\n\n\u0060\u0060\u0060mermaid \u0022Traffic Interception Process in Istio Ambient Mode\u0022\nsequenceDiagram\n    participant Kubelet\n    participant NodeAgent as Istio CNI Node Agent\n    participant podNetns as pod Network Namespace\n    participant ztunnel\n    participant pod as Application pod\n\n    Kubelet-\u003e\u003eNodeAgent: Notify new pod joins the Ambient mesh\n    NodeAgent-\u003e\u003epodNetns: Configure iptables rules\n    NodeAgent-\u003e\u003eztunnel: Pass pod network namespace FD\n    ztunnel-\u003e\u003ePodNetns: Start listening sockets in the pod network namespace\n    Pod-\u003e\u003ePodNetns: Application sends traffic\n    PodNetns-\u003e\u003eztunnel: Traffic redirected to ztunnel\n    ztunnel-\u003e\u003eTarget Service: Forward traffic via tunnel\n    Target Service--\u003e\u003eztunnel: Return response\n    ztunnel--\u003e\u003ePod: Send response back to application\n\u0060\u0060\u0060\n\n![Traffic Interception Process in Istio Ambient Mode](47a0230e39849d8e80ed6ab75bc34ebe.svg)\n\n### Detailed Steps of Traffic Interception\n\n1. **Pod Initialization and Network Configuration**:\n   - When Kubernetes creates a pod, it invokes the underlying CNI plugin (e.g., Calico, Cilium) via the Container Runtime Interface (CRI) to configure the pod’s network.\n   - At this stage, the pod’s network namespace (netns) is established.\n2. **Istio CNI Node Agent Configures Traffic Redirection**:\n   - The Istio CNI Node Agent detects that the new pod is marked for ambient mode (via the label \u0060istio.io\/dataplane-mode=ambient\u0060).\n   - It enters the pod’s network namespace and sets up iptables rules for traffic interception.\n   - The network namespace’s file descriptor (FD) is passed to ztunnel.\n3. **Ztunnel Starts Listening Sockets in Pod Network Namespace**:\n   - ztunnel receives the namespace FD and starts listening sockets within it to handle redirected traffic.\n4. **Transparent Traffic Interception and Processing**:\n   - Traffic originating from the application is intercepted by the iptables rules in the pod and transparently redirected to ztunnel.\n   - ztunnel performs policy checks, encryption, and other processing before forwarding traffic to the target service.\n   - Responses are decrypted by ztunnel and returned to the application.\n\nFor more details about how Istio CNI configures iptables, see my other blog post: [Analyzing iptables Rules in Istio ambient mode](\/en\/blog\/istio-ambient-inpod-iptables\/).\n\n## ztunnel Log Analysis\n\nYou can inspect all logs related to traffic interception in ztunnel using the following command, which helps you understand how ztunnel operates:\n\n\u0060\u0060\u0060bash\nkubectl -n istio-system logs -l app=ztunnel | grep -E \u0022inbound|outbound\u0022\n\u0060\u0060\u0060\n\nThe logs will look like the examples below, where \u0060inbound\u0060 and \u0060outbound\u0060 are relative to ztunnel.\n\n**Inbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:33:01.410751Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.19:58000 src.workload=\u0022bookinfo-gateway-istio-64fc6d75d6-s442s\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-gateway-istio\u0022 dst.addr=10.28.2.18:15008 dst.hbone_addr=10.28.2.18:9080 dst.service=\u0022productpage.default.svc.cluster.local\u0022 dst.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 direction=\u0022inbound\u0022 bytes_sent=9603 bytes_recv=2052 duration=\u00222110ms\u0022\n\u0060\u0060\u0060\n\nThis log describes inbound traffic from \u0060bookinfo-gateway-istio\u0060 to the \u0060productpage\u0060 service, passing through ztunnel’s port 15008, encrypted via HBONE, with identities verified through SPIFFE.\n\n**Outbound Traffic Example**\n\n\u0060\u0060\u0060text\n2024-11-16T10:32:59.360677Z\tinfo\taccess\tconnection complete\tsrc.addr=10.28.2.18:51960 src.workload=\u0022productpage-v1-57ffb6658c-tgbjs\u0022 src.namespace=\u0022default\u0022 src.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/bookinfo-productpage\u0022 dst.addr=10.28.2.14:15008 dst.hbone_addr=34.118.226.6:9080 dst.service=\u0022details.default.svc.cluster.local\u0022 dst.workload=\u0022waypoint-7594b5b786-vgjwz\u0022 dst.namespace=\u0022default\u0022 dst.identity=\u0022spiffe:\/\/cluster.local\/ns\/default\/sa\/waypoint\u0022 direction=\u0022outbound\u0022 bytes_sent=794 bytes_recv=414 duration=\u002240ms\u0022\n\u0060\u0060\u0060\n\nThis log shows outbound traffic from the \u0060productpage\u0060 pod to the \u0060details\u0060 service, routed through ztunnel using an HBONE tunnel to the waypoint pod (port \u006015008\u0060).\n\n## Conclusion\n\nIstio ambient mode achieves sidecar-free transparent traffic interception through the collaboration of Istio CNI Node Agent and ztunnel. Key features include:\n\n- **High compatibility**: Avoids conflicts with underlying CNI.\n- **Simplified operations**: No need for application code changes, reducing resource overhead.\n- **Enhanced security**: Enables end-to-end encrypted transmission with HBONE.\n\nIn future articles, I will explore advanced features of Istio ambient mode, including L7 traffic path analysis and network topology construction. Stay tuned!\n\n## References\n\n- [Maturing Istio Ambient: Compatibility Across Various Kubernetes Providers and CNIs](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/)\n- [Introducing Istio Ambient Mesh](https:\/\/istio.io\/latest\/blog\/2022\/introducing-ambient-mesh\/)\n- [Kubernetes Official Documentation: Network Plugins](https:\/\/kubernetes.io\/docs\/concepts\/extend-kubernetes\/compute-storage-net\/network-plugins\/)\n- [HBONE](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/hbone\/)\n- [ztunnel Traffic Redirection](https:\/\/istio.io\/latest\/docs\/ambient\/architecture\/traffic-redirection\/)\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/transparent-traffic-interception-in-istio-ambient-mode-a-comprehensive-explanation\/).', '\/en\/blog\/istio-ambient-traffic-interception\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article is the first in a series on Istio ambient mode, focusing on how transparent traffic interception enables a sidecar-free service mesh. It provides an in-depth analysis of the interactions among the Istio CNI Node Agent, ztunnel, and pod network namespaces.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrate-to-istio-telemetry-api/">Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 18, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh', 'Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.', '\nThe Istio Telemetry API is a modern approach to replace traditional MeshConfig telemetry configuration. It provides more flexible tools to define **Tracing**, **Metrics**, and **Access Logging** within the service mesh. Compared to conventional \u0060EnvoyFilter\u0060 and \u0060MeshConfig\u0060, the Telemetry API offers better modularity, dynamic updates, and multi-layered configuration capabilities.\n\nIn this article, we will detail how to use the Telemetry API to configure Istio telemetry features, covering the implementation of Tracing, Metrics, and Logging, as well as how to migrate from legacy MeshConfig configurations.\n\n## Evolution of Telemetry API\n\nIstio\u0027s telemetry capabilities initially relied on traditional methods such as **Mixer** and the \u0060configOverride\u0060 in **MeshConfig**. While these methods met basic needs, they struggled with complex use cases. To address these issues, Istio introduced the CRD-based **Telemetry API**.\n\n### Key Version Updates\n\nTo help readers understand the evolution of the Telemetry API, here are some important version milestones:\n\n1. **Istio 1.11**: Introduced the Telemetry API (Alpha), offering basic metrics and logging customization.\n2. **Istio 1.13**: Added support for OpenTelemetry logging, custom tracing service names, and enhanced log filtering.\n3. **Istio 1.18**: Deprecated the installation of Prometheus \u0060EnvoyFilter\u0060, relying entirely on Telemetry API for telemetry behavior.\n4. **Istio 1.22**: Graduated the Telemetry API to stable (v1), making it ready for production environments.\n\n## Why Migrate to Telemetry API?\n\nAlthough traditional MeshConfig and EnvoyFilter provided foundational telemetry capabilities, their configuration methods posed significant limitations in terms of flexibility, dynamism, and scalability. To better understand these limitations, let\u0027s explore several key aspects.\n\n### Complexity of MeshConfig and EnvoyFilter\n\nBefore diving into the issues, let’s clarify the roles of MeshConfig and EnvoyFilter: MeshConfig is used for global configurations, while EnvoyFilter allows for fine-grained customization. However, this separation of duties leads to management challenges.\n\n#### 1. Dispersed Configuration Methods\n\n- **MeshConfig** is used to define global mesh behaviors, such as access log paths, trace sampling rates, and metric dimensions. While suitable for simple scenarios, it cannot meet namespace- or workload-specific needs.\n- **EnvoyFilter** can override or extend Envoy configurations, enabling finer control. However, this method involves directly manipulating Envoy’s internal structures (xDS fields), which is complex and error-prone.\n\n  **Example: Configuring access logging via MeshConfig**\n  \u0060\u0060\u0060yaml\n  apiVersion: install.istio.io\/v1alpha1\n  kind: IstioOperator\n  spec:\n    meshConfig:\n      accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n  **Issues**:\n  - Cannot set different log paths for specific services or namespaces.\n  - Requires reapplying the entire configuration, lacking dynamism.\n\n  **Example: Customizing metrics via EnvoyFilter**\n  \u0060\u0060\u0060yaml\n  apiVersion: networking.istio.io\/v1alpha3\n  kind: EnvoyFilter\n  metadata:\n    name: custom-metric-filter\n    namespace: mynamespace\n  spec:\n    workloadSelector:\n      labels:\n        app: myapp\n    configPatches:\n    - applyTo: HTTP_FILTER\n      match:\n        context: SIDECAR_INBOUND\n        listener:\n          filterChain:\n            filter:\n              name: envoy.filters.network.http_connection_manager\n              subFilter:\n                name: envoy.filters.http.router\n        proxy:\n          proxyVersion: \u0027^1\\\\.13.*\u0027\n      patch:\n        operation: INSERT_BEFORE\n        value:\n          name: istio.stats\n          typed_config:\n            \u0027@type\u0027: type.googleapis.com\/udpa.type.v1.TypedStruct\n            type_url: type.googleapis.com\/envoy.extensions.filters.http.wasm.v3.Wasm\n            value:\n              config:\n                configuration:\n                  \u0027@type\u0027: type.googleapis.com\/google.protobuf.StringValue\n                  value: |\n                    {\n                      \u0022debug\u0022: \u0022false\u0022,\n                      \u0022stat_prefix\u0022: \u0022istio\u0022,\n                      \u0022disable_host_header_fallback\u0022: true\n                    }\n                root_id: stats_inbound\n                vm_config:\n                  code:\n                    local:\n                      inline_string: envoy.wasm.stats\n                  runtime: envoy.wasm.runtime.null\n                  vm_id: stats_inbound\n  \u0060\u0060\u0060\n  **Issues**:\n  - Syntax is complex and verbose, requiring deep understanding of Envoy’s structure.\n  - High potential for errors, leading to costly debugging and maintenance.\n\n#### 2. Lack of Dynamism\n\nWhile modern microservice environments emphasize dynamic configuration, MeshConfig and EnvoyFilter offer limited support for dynamism:\n\n- **MeshConfig**: Modifying configurations often requires restarting proxies or reapplying the entire setup, causing service disruptions.\n- **EnvoyFilter**: Updating even a single parameter necessitates redeployment of related proxy instances.\n\n#### 3. Challenges in Multi-Tenant Support\n\nIn multi-tenant environments, customizing telemetry configurations for different namespaces or workloads is crucial. However:\n\n- **MeshConfig**: Cannot provide differentiated settings for namespaces or workloads.\n- **EnvoyFilter**: Requires multiple filter configurations, increasing management complexity.\n\n#### 4. Limited Extensibility and Debugging\n\n- MeshConfig and EnvoyFilter are slow to support new requirements (e.g., OpenTelemetry).\n- Debugging EnvoyFilter configurations is challenging, requiring in-depth analysis of Envoy logs and behaviors.\n\n### Deprecating Legacy MeshConfig Telemetry Configuration\n\nGiven the limitations mentioned above, the Istio community has deprecated traditional MeshConfig telemetry configurations. The following examples illustrate their usage and shortcomings:\n\n- **Access Logging Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    accessLogFile: \/dev\/stdout\n  \u0060\u0060\u0060\n- **Trace Sampling Configuration**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    enableTracing: true\n    extensionProviders:\n    - name: zipkin\n      zipkin:\n        service: zipkin.istio-system.svc.cluster.local\n        port: 9411\n  \u0060\u0060\u0060\n- **Custom Metrics Labels**:\n  \u0060\u0060\u0060yaml\n  meshConfig:\n    telemetry:\n      v2:\n        prometheus:\n          configOverride:\n            inboundSidecar:\n              metrics:\n                - name: requests_total\n                  dimensions:\n                    user-agent: request.headers[\u0027User-Agent\u0027]\n  \u0060\u0060\u0060\n\nThese configurations demonstrate clear limitations in flexibility and scalability, making them unsuitable for complex production environments.\n\n## Advantages of Telemetry API\n\nBuilding upon traditional methods, the Telemetry API introduces several improvements, making it well-suited for modern service mesh management:\n\n1. **Modular Design**: Separate configurations for Tracing, Metrics, and Access Logging.\n2. **Dynamic Updates**: Supports real-time configuration updates without proxy restarts.\n3. **Layered Support**: Allows configurations at global, namespace, and workload levels.\n4. **Simplified Syntax**: Uses declarative syntax, eliminating the need for in-depth Envoy knowledge.\n\n## Example Configurations with Istio Telemetry API\n\n### Global Configuration Example\n\nTo illustrate the usage of the Telemetry API, here is an example of a global configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  accessLogging:\n    - providers:\n        - name: file-log\n  tracing:\n    - providers:\n        - name: \u0022skywalking\u0022\n      randomSamplingPercentage: 100.00\n  metrics:\n    - overrides:\n        - match:\n            metric: REQUEST_COUNT\n            mode: CLIENT\n          tagOverrides:\n            x_user_email:\n              value: |\n                \u0027x-user-email\u0027 in request.headers ? request.headers[\u0027x-user-email\u0027] : \u0027empty\u0027\n      providers:\n        - name: prometheus\n\u0060\u0060\u0060\n\nThe remaining sections demonstrate step-by-step how to configure and validate SkyWalking, as well as perform migration, ensuring readers can implement these practices seamlessly in their environments.\n\n### Configuring SkyWalking with Telemetry API\n\nHere, we will demonstrate how to use the Telemetry API to configure the sampling rate and span tags for SkyWalking.\n\n#### Verify Istio Version and CRD\n\n- If using Istio 1.22 or later, use \u0060telemetry.istio.io\/v1\u0060.\n- For Istio 1.18 to 1.21 users, use \u0060telemetry.istio.io\/v1alpha1\u0060.\n\nCheck whether the Telemetry API CRD is installed using the following command:\n\n\u0060\u0060\u0060bash\nkubectl get crds | grep telemetry\n\u0060\u0060\u0060\n\n#### Deploy SkyWalking\n\nDeploy the SkyWalking OAP service in your cluster:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.24\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\nCheck the service status:\n\n\u0060\u0060\u0060bash\nkubectl get pods -n istio-system -l app=skywalking-oap\n\u0060\u0060\u0060\n\n#### Add SkyWalking Provider to MeshConfig\n\nDefine the SkyWalking provider in Istio\u0027s \u0060MeshConfig\u0060.\n\n\u0060\u0060\u0060yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: istio\n  namespace: istio-system\ndata:\n  mesh: |-\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: \u0022tracing.istio-system.svc.cluster.local\u0022\n        port: 11800\n\u0060\u0060\u0060\n\n#### Configure Sampling Rate with Telemetry API\n\nUsing the Telemetry API, set SkyWalking as the default tracing provider and define the sampling rate.\n\nTelemetry API allows configuration at multiple levels. For brevity, we demonstrate namespace-level configuration here. For other levels, refer to the [Telemetry API documentation](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/).\n\n\u0060\u0060\u0060yaml\napiVersion: telemetry.istio.io\/v1\nkind: Telemetry\nmetadata:\n  name: namespace-override\n  namespace: default\nspec:\n  tracing:\n  - providers:\n      - name: skywalking\n    randomSamplingPercentage: 50\n    customTags:\n      env:\n        literal:\n          value: production\n\u0060\u0060\u0060\n\nExplanation:\n\n- \u0060providers.name\u0060: Specifies SkyWalking as the default tracing provider.\n- \u0060randomSamplingPercentage\u0060: Overrides namespace-level settings to set a 50% sampling rate.\n- \u0060customTags\u0060: Adds the \u0060env=production\u0060 tag to all trace data.\n\n### Validate Configuration\n\nGenerate traffic for the mesh services, such as using the [Bookinfo](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) example application:\n\n\u0060\u0060\u0060bash\ncurl http:\/\/$GATEWAY_URL\/productpage\n\u0060\u0060\u0060\n\nView the trace data:\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nOpen your browser and navigate to \u0060http:\/\/localhost:8080\u0060 to access the tracing dashboard and inspect the generated traces.\n\n![Skywalking Tracing](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-tracing.webp)\n\nClick on a span to see the additional \u0060env: production\u0060 tag.\n\n![Skywalking Span](https:\/\/jimmysong.io\/img\/blog\/migrate-to-istio-telemetry-api\/skywalking-span.webp)\n\n## Summary\n\nThe Telemetry API significantly reduces the complexity of configuring telemetry in the service mesh through its modular design, dynamic updates, and multi-level support. Compared to MeshConfig and EnvoyFilter, the Telemetry API is a more flexible, efficient, and modern solution. We highly recommend migrating to the Telemetry API to take full advantage of its capabilities.\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-telemetry\/).\n', '\/en\/blog\/migrate-to-istio-telemetry-api\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Improve Istio mesh tracing capabilities and flexibility by migrating to the Telemetry API and configuring the SkyWalking provider.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-sidecar-vs-ambient-network-cost-performance/">Network Cost Comparison Between Istio Sidecar and Ambient Modes</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Network Cost Comparison Between Istio Sidecar and Ambient Modes', 'In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.', '\nIn the evolving landscape of service mesh architectures, understanding the network costs associated with different deployment modes is crucial for optimizing performance and resource efficiency. This blog post will compare the network costs of Istio’s sidecar mode and ambient mode, drawing insights from my recent article, [Which Data Plane Should I Use—Sidecar, Ambient, Cilium, or gRPC?](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/)\n\n## Sidecar Mode\n\nIstio’s sidecar mode intercepts traffic between services by deploying a sidecar proxy alongside each pod. This model introduces additional network hops, which may increase latency and resource usage. However, the mode includes important optimizations like [locality-aware load balancing](https:\/\/istio.io\/latest\/docs\/tasks\/traffic-management\/locality-load-balancing\/).\n\nFigure 1 illustrates the traffic path when Application 1 accesses Application 2 located in a different availability zone (AZ) under the sidecar model.\n\n![Figure 1: The traffic path for Application 1 in Istio Sidecar mode to access Application 2 located in a different availability zone (AZ).](sidecar-mode.svg)\n\n### Locality Awareness in Sidecar Mode\n\nTo better understand locality management, you can use the command \u0060istioctl proxy-config endpoint \u003cpod-name[.namespace]\u003e -o yaml\u0060 to view an endpoint table containing locality information. This helps visualize how locality is managed in sidecar mode.Below is a sample output snippet showing endpoint information for the cluster \u0060outbound|9080||reviews.default.svc.cluster.local\u0060:\n\n\u0060\u0060\u0060yaml\n- addedViaApi: true\n  circuitBreakers:\n    thresholds:\n    - maxConnections: 4294967295\n      maxPendingRequests: 4294967295\n      maxRequests: 4294967295\n      maxRetries: 4294967295\n    - maxConnections: 1024\n      maxPendingRequests: 1024\n      maxRequests: 1024\n      maxRetries: 3\n      priority: HIGH\n  edsServiceName: outbound|9080||reviews.default.svc.cluster.local\n  hostStatuses:\n  - address:\n      socketAddress:\n        address: 10.244.0.98\n        portValue: 9080\n    healthStatus:\n      edsHealthStatus: HEALTHY\n    locality:\n      region: us-central1\n      zone: us-central1-c\n    stats:\n    - name: cx_connect_fail\n    - name: cx_total\n    - name: rq_error\n    - name: rq_success\n    - name: rq_timeout\n    - name: rq_total\n    - name: cx_active\n      type: GAUGE\n    - name: rq_active\n      type: GAUGE\n    weight: 1\n  - address:\n    # Additional addresses omitted\n  - address:\n    # Additional addresses omitted\n  name: outbound|9080||reviews.default.svc.cluster.local\n  observabilityName: outbound|9080||reviews.default.svc.cluster.local;\n\u0060\u0060\u0060\n\nThis shows how the sidecar proxy in each pod manages fine-grained traffic control, including circuit breaker configurations like maxConnections, maxRequests, and maxRetries, along with traffic metrics and health status indicators. This level of detail aids in maintaining healthy, stable, and latency-efficient traffic at the pod level.\n\nIn sidecar mode, each proxy prioritizes routing traffic to services within the same AZ or region, minimizing cross-AZ traffic and reducing latency and associated costs. This approach optimizes network paths, preventing cross-regional bottlenecks.\n\nAlthough sidecar mode can be compute-intensive, its locality-aware functionality is instrumental in maintaining efficient traffic routing, particularly in multi-region cloud deployments, where it helps minimize cross-region traffic costs.\n\n## Ambient Mode\n\nThe following diagram shows the architecture of Istio’s ambient mode.\n\n![Figure 2: Istio ambient mode architecture](istio-ambient-layers.svg)\n\nIstio ambient mode has two layers:\n\n1. **Ztunnel Layer (L3\/L4 Traffic Management)**: In ambient mode, zTunnel manages traffic mainly at the network and transport layers, reducing overhead while ensuring basic connectivity and security requirements are met.\n2. **Waypoint Proxy Layer (L7 Traffic Management)**: This layer, which adds application-layer functionality like advanced routing, observability, and policy enforcement, requires optimal placement to avoid cross-AZ traffic. Waypoint proxies should be deployed within each AZ to ensure maximum performance.\n\n## Locality Awareness in Ambient Mode\n\nIn contrast to sidecar mode, ambient mode uses zTunnel and waypoint proxies for a different architectural approach. Like sidecar mode, zTunnel prioritizes routing traffic within the same AZ, limiting cross-AZ traffic and associated network costs.\n\nFigure 3 illustrates the traffic path for Application 1 accessing Application 2 in a different AZ in ambient mode.\n\n![Figure 3: The traffic path for Application 1 in Istio ambient mode to access Application 2 located in a different availability zone (AZ).](ambient-mode.svg)\n\nNote: In the figure, the waypoint proxy is shown separately for demonstration purposes; in practice, it is not bound to a specific node and can be colocated with zTunnel.\n\nTo gain further insights into locality in ambient mode, you can use \u0060istioctl ztunnel-config workload -o yaml\u0060, which provides detailed views of zTunnel configurations and traffic distribution.\n\nHere’s an example snippet:\n\n\u0060\u0060\u0060yaml\n- applicationTunnel:\n    protocol: \u0022\u0022\n  canonicalName: productpage\n  canonicalRevision: v1\n  clusterId: Kubernetes\n  hostname: \u0022\u0022\n  locality:\n    region: us-central1\n    zone: us-central1-c\n  name: productpage-v1-d5789fdfb-gmw5r\n  namespace: default\n  node: gke-cilium-default-pool-63a77182-f699\n  protocol: HBONE\n  serviceAccount: bookinfo-productpage\n  status: Healthy\n  trustDomain: cluster.local\n  uid: Kubernetes\/\/Pod\/default\/productpage-v1-d5789fdfb-gmw5r\n  workloadIps:\n    - 10.28.2.14\n  workloadName: productpage-v1\n  workloadType: deployment\n\u0060\u0060\u0060\n\nThis output demonstrates ztunnel’s locality-aware information, which centralizes traffic management for all pods on a node, including load balancing, health checks, and locality awareness.\n\n### Waypoint Proxies\n\nThe waypoint proxy, however, does not automatically have AZ awareness. To optimize for cost and performance, waypoint proxies must be deployed across AZs to enable local traffic handling. Otherwise, there is a risk of additional cross-AZ traffic and costs. Additionally, once traffic reaches a waypoint proxy, original locality information may be obscured, complicating route optimization.\n\nFor optimal cost and performance, waypoint proxies should be distributed within each AZ to process traffic locally. The proximity-aware communication design between ztunnel and waypoint proxies helps ensure traffic is routed to the nearest waypoint, further reducing cross-AZ costs and latency.\n\n## Visualizing with Kiali Dashboard\n\nWhen comparing sidecar and ambient modes, visualizing locality and routing behavior with Kiali dashboard can help illustrate ambient mode’s complexity. Kiali provides a graphical view of traffic paths in different modes, aiding in understanding ambient mode’s operational intricacies.\n\n![Kiali UI](kiali.webp)\n\n## Conclusion\n\nIn comparing the network costs of Istio’s sidecar and ambient modes, both architectures support locality-aware routing to minimize cross-AZ traffic. Sidecar mode offers more comprehensive locality management at each proxy, while ambient mode requires careful waypoint proxy deployment to avoid extra costs. Additionally, ambient mode’s sub-modes (with or without waypoint proxies) impact network cost and performance in distinct ways. For a deeper dive into the four primary service mesh data plane deployment modes, I encourage you to read the full article [here](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-ambient-cost-comparison\/).*\n', '\/en\/blog\/istio-sidecar-vs-ambient-network-cost-performance\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In-depth comparison of network costs and performance between Istio sidecar and ambient modes, and analysis of their locality awareness and troubleshooting methods.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide/">Migrating from AWS App Mesh to Istio: A Comprehensive Guide</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 30, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Migrating from AWS App Mesh to Istio: A Comprehensive Guide', 'Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.', '\nWith[ AWS announcing the deprecation of AWS App Mesh effective September 30, 2026](https:\/\/aws.amazon.com\/cn\/blogs\/containers\/migrating-from-aws-app-mesh-to-amazon-ecs-service-connect\/), many organizations are evaluating alternatives to continue their service mesh journey. If you are one of those organizations, Istio presents itself as a robust and feature-rich option, especially for Kubernetes-native environments. In this post, I will provide an overview of the migration process from AWS App Mesh to Istio, compare the two service meshes, and introduce the Tetrate Istio Migration Tool—a convenient utility we developed to streamline this transition.\n\n## App Mesh vs Istio: Preparing for Migration\n\nWith AWS App Mesh being deprecated, it’s important to understand the similarities and differences between App Mesh and Istio to prepare for a successful migration. Below are some key points of comparison to help align your current infrastructure with what Istio offers:\n\n1. Comprehensive Features: Both App Mesh and Istio offer traffic management, observability, and security, but Istio provides more customizable options, including advanced traffic routing and enhanced telemetry.\n2. Cloud Agnostic: Unlike AWS App Mesh, which is tightly integrated with AWS, Istio is cloud-agnostic, allowing for greater flexibility across multi-cloud or hybrid environments.\n3. Advanced Security: Istio supports mTLS by default, offering more extensive security features and policies compared to App Mesh.\n\nAWS recommends ECS customers migrate to[ Service Connect](https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/developerguide\/service-connect.html) and EKS customers to[ VPC Lattice](https:\/\/aws.amazon.com\/vpc\/lattice\/). For a feature-rich, open source solution, Istio is a compelling choice. Let’s dive into the migration journey from AWS App Mesh to Istio, supported by Tetrate’s migration tool.\n\n## Comparing App Mesh, Service Connect, VPC Lattice and Istio\n\nBefore starting the migration, it’s essential to understand the key differences between AWS App Mesh, Service Connect, VPC Lattice, and Istio:\n\n| **Feature**                  | **App Mesh**                                                 | **Service Connect**                                          | **VPC Lattice**                                              | **Istio**                                                    |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Network Reliability**      | Uses[ Envoy](https:\/\/envoyproxy.io\/) as sidecar proxies for outlier detection, health checks, and retries with granular adjustments. | Uses Envoy as sidecar proxies with default configurations, only timeouts adjustable. | Built-in health checks and retries with AWS-managed reliability. No sidecar proxies are needed. | Supports both sidecar and ambient modes, using Envoy with full support for fine-tuning. |\n| **Advanced Traffic Routing** | Supports advanced traffic routing like A\/B testing and canary releases. | Does not support advanced traffic routing.                   | Supports basic traffic routing and load balancing.           | Supports advanced traffic control, including A\/B testing and canary releases. |\n| **Observability**            | Manual collection and monitoring of metrics.                 | Sends metrics to Amazon CloudWatch automatically.            | Integrated monitoring with AWS CloudWatch and X-Ray.         | Out-of-the-box observability with Prometheus, Grafana, and Jaeger. |\n| **Service Discovery**        | Integrates with AWS Cloud Map.                               | Uses AWS Cloud Map.                                          | Uses AWS service discovery mechanisms.                       | Uses Kubernetes-native service discovery.                    |\n| **Security**                 | Supports TLS with AWS PCA and mutual TLS (mTLS).             | Supports TLS, no mTLS.                                       | Supports mTLS.                                               | Supports mTLS, fine-grained security policies.               |\n| **Resource Sharing**         | Can share Mesh across multiple AWS accounts.                 | Cannot share namespaces across accounts.                     | Can share resources across multiple AWS accounts.            | Can be deployed across multiple clusters and clouds.         |\n\n## Introducing Tetrate’s Istio Migration Tool\n\nTo make the migration process smoother, Tetrate has developed an Istio Migration Toolkit, which is currently in a private state but can be used internally or by approved customers who request it through the[ form](https:\/\/resources.tetrate.dev\/app-mesh-istio?__hstc=218802950.edcf2542a8010c44aa57b98adaef028a.1721092227167.1729818643207.1730268606576.91\u0026__hssc=218802950.2.1730268606576\u0026__hsfp=872206273). The toolkit assists in automating the conversion of AWS App Mesh configurations to Istio equivalents, including Virtual Nodes, Virtual Routers, and other networking constructs.\n\n**Key Considerations**\n\n- **Service discovery**: App Mesh and Istio handle service discovery differently. Istio leverages Kubernetes-native service discovery, while App Mesh integrates with AWS Cloud Map. During the migration, it is critical to adjust your service definitions accordingly.\n- **Security**: Istio natively supports mTLS between services. While AWS App Mesh also offers mTLS, transitioning to Istio will require configuring the Certificate Authority (CA) and updating certificates to align with Istio’s security model.\n- **Traffic management**: Istio’s Virtual Services and Destination Rules offer more advanced traffic routing capabilities compared to App Mesh’s Virtual Routers and Nodes. As you migrate, plan for additional configuration steps to set up similar routing behavior in Istio.\n\n## Step-by-Step Migration Using Tetrate’s Migration Tool\n\nBelow, I’ll guide you through the steps to use this tool effectively.\n\n### Prerequisites\n\nTo start the migration, ensure you have the following installed:\n\n- [Go](https:\/\/golang.org\/doc\/install)\n- [kubectl](https:\/\/kubernetes.io\/docs\/tasks\/tools\/#kubectl)\n- [istioctl](https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/#download)\n\nMake sure your AWS App Mesh is properly installed and configured on an EKS cluster. You’ll also need a Kubernetes secret called tetrate-tis-creds for Istio installation, as detailed in the tool’s documentation.\n\nThe tool also helps verify compatibility, offering a precheck command to identify any potential blockers before starting the migration.\n\n### Running a Precheck\n\nTo verify that your setup is ready for migration, run:\n\n\u0060\u0060\u0060bash\ntim precheck\n\u0060\u0060\u0060\n\nThis command will scan your App Mesh environment and highlight any adjustments required to ensure a successful migration.\n\n### Migration Process\n\n1. Install Istio\n\n   Use the Istio Migration Toolkit to generate IstioOperator configurations, and install Istio:\n\n   \u0060\u0060\u0060bash\n   tim generate iop | istioctl install –skip-confirmation -f –\n   \u0060\u0060\u0060\n\n1. Apply Istio Networking Rules\n   Next, generate and apply Istio networking rules:\n\n   \u0060\u0060\u0060bash\n   tim generate networking | kubectl apply -f –\n   \u0060\u0060\u0060\n\n1. Remove AWS App Mesh Labels\n   Remove the existing App Mesh labels from your namespaces. For example, for the default namespace:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default \u0022appmesh.k8s.aws\/sidecarInjectorWebhook-\u0022\n   \u0060\u0060\u0060\n\n1. Enable Istio Sidecar Injection\n   Add a label to enable Istio’s automatic sidecar injection:\n\n   \u0060\u0060\u0060bash\n   kubectl label namespace default istio-injection=enabled\n   \u0060\u0060\u0060\n\n1. Restart Deployments\n   To apply changes and initiate the new Envoy sidecar injection, restart your deployments:\n\n   \u0060\u0060\u0060bash\n   kubectl rollout restart deployment \u003cdeployment-name\u003e -n \u003cdeployment-namespace\u003e\n   \u0060\u0060\u0060\n\n### Migration Strategies\n\nWhen migrating apps from AWS App Mesh to Istio, there are strategies like in-place, canary, and blue\/green deployments, similar to those for migrating to VPC Lattice. The right strategy depends on app requirements like zero downtime or scheduling maintenance windows.\n\n1. **In-Place Migration**: Replace existing Kubernetes Pods instrumented with App Mesh with new Pods configured for Istio. This approach is suitable for applications that can tolerate downtime during the migration process, as each pod is recycled to remove the Envoy sidecar container and add Istio.\n2. **Blue\/Green Deployment**: Deploy a second copy of the application in a new namespace configured for Istio, while the original deployment remains operational with App Mesh. Gradually migrate traffic from App Mesh to Istio without downtime while both environments run simultaneously.\n3. **Canary Deployment**: Deploy Istio side-by-side with App Mesh and incrementally move a small percentage of traffic to Istio. Monitor performance and stability, and increase traffic as confidence grows.\n4. **Phased Migration**: Migrate components or services incrementally instead of all at once. This reduces risk and helps identify potential issues in smaller, manageable segments.\n5. **Testing and Validation**: Before cutting over entirely, conduct thorough testing to validate that service functionality, security, and performance metrics meet or exceed expectations.\n\n## Conclusion\n\nMigrating from AWS App Mesh to Istio can unlock new capabilities in traffic management, observability, and security. Tetrate’s Istio Migration Toolkit simplifies the process, providing a step-by-step approach to reduce manual configurations and ensure a seamless transition.\n\nIf you’re interested in trying out Tetrate’s Istio Migration Toolkit, feel free to reach out—the tool is currently available for private use, and we’d be happy to discuss access.\n\nThis migration is not just about adopting a new service mesh—it’s an opportunity to take advantage of Istio’s comprehensive features, support multi-cloud deployments, and enhance the resilience of your infrastructure.\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/).*\n', '\/en\/blog\/migrating-from-aws-app-mesh-to-istio-a-comprehensive-guide\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Guide on migrating from AWS App Mesh to Istio. Focuses on benefits of cloud-native, Kubernetes-friendly solution. Explore differences, advanced features and Tetrate Istio Migration Tool for easy, efficient transition.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multi-Cluster PKI \u002b Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh', 'This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.', '\nAuthors: Cristofer TenEyck Senior Solution Engineer a Keyfactor and Jimmy Song Developer Advocate at Tetrate\n\n## Introduction\n\nIn the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge. \n\nIn this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes. \n\nWhy multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters. \n\n## Understanding PKI and its Role in Service Meshes \n\nPKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments. \n\nThe EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications. \n\n## Istio, EJBCA and cert-manager \n\nSetting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included: \n\n1. **Environment Preparation**: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA). \n2. **cert-manager Integration**: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates. \n3. **Automatic Certificate Renewal**: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters. \n\n![Architecture](arch.webp)\n\n## Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary \n\nThis section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found [here](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi).\n\nThe key steps include: \n\n1. **Install and Configure Helm Repositories**: Add necessary Helm repositories for Istio, cert-manager, and EJBCA. \n2. **Deploy cert-manager and EJBCA**: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets. \n3. **Configure Istio with EJBCA**: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration. \n4. **Install Istio Components**: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway. \n5. **Customization and Overrides**: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services. \n6. **Automatic Certificate Renewal:** The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications. \n\n![Certificate renew flow](cert-renew-flow.webp)\n\nAbove is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA. \n\n## PKI Best Practices and Compliance \n\nBuilding a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider: \n\n1. **Compliance with Regulations**: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices. \n2. **Crypto Agility and Quantum Readiness**: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important. \n3. **Collaboration with InfoSec**: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals. \n\n## Conclusion \n\nImplementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant. \n\nBy following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh. \n\nFor further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below. \n\n## Resources \n\n- [Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi)\n- [Istio documentation](https:\/\/istio.io\/latest\/docs\/)\n- [EJBCA Community edition](https:\/\/www.ejbca.org\/)\n- [cert-manager documentation](https:\/\/cert-manager.io\/docs\/)\n- [EU Cyber Resilience Act](https:\/\/digital-strategy.ec.europa.eu\/en\/policies\/cyber-resilience-act)\n- [US Executive Order on Cybersecurity](https:\/\/www.whitehouse.gov\/briefing-room\/statements-releases\/2021\/05\/12\/executive-order-on-improving-the-nations-cybersecurity\/)\n- [A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh](\/en\/blog\/seamless-cross-cluster-access-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh\/).*\n', '\/en\/blog\/multi-cluster-pki-istio-recipe\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/istio/page/7/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(54)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(8)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Connect on LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/leveraging-envoypatchpolicy-to-extend-the-capabilities-of-envoy-gateway/">Leveraging EnvoyPatchPolicy to Extend the Capabilities of Envoy Gateway</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/beyond-sidecar/">Beyond Sidecar: A Deep Dive into Istio Ambient Mode Traffic Mechanism and Cost Efficiency</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-l7-flow-analysis/">Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
