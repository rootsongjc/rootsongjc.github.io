<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.129.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.595949bd12db88434115e2a1e70965cf2928cc646e73acc6437c4cbbc323f585.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/book">Book</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/istio/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-configuration-safety-common-misconfigurations/">Istio Configuration Security: How to Avoid Misconfigurations</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio Configuration Security: How to Avoid Misconfigurations', 'Explore common Istio configuration errors and their solutions to enhance the security and stability of your service mesh.', '\nIstio is a powerful service mesh solution that provides zero-trust security, observability, and advanced traffic management without requiring code modifications. However, misconfigurations often lead to unexpected behavior. This article discusses several common Istio configuration errors, explains the principles behind them, and shows how to identify and resolve these issues through diagrams. We will also introduce the TIS Config Analyzer tool from Tetrate, designed to optimize Istio operation efficiency and security.\n\n## Incident Cases Caused by Configuration Errors\n\nHere are two typical incidents caused by configuration errors:\n\n1. **[Amazon Web Services 2017 Outage](https:\/\/www.theverge.com\/2017\/3\/2\/14792442\/amazon-s3-outage-cause-typo-internet-server)**: A simple typo led to widespread service disruptions, affecting thousands of online services and applications, highlighting that even a minor configuration error in mature cloud infrastructure can have severe consequences.\n\n2. **[GitLab 2017 Data Loss Incident](https:\/\/about.gitlab.com\/blog\/2017\/02\/01\/gitlab-dot-com-database-incident\/)**: Due to configuration errors, GitLab accidentally deleted a large amount of production data during database maintenance. Although backup mechanisms were configured, an incorrect configuration prevented timely data recovery.\n\nThese cases show the importance of proper configuration management in preventing service disruptions and data loss.\n\n## Common Types of Istio Configuration Errors\n\nIstio configuration errors can be broadly categorized as follows:\n\n1. **AuthorizationPolicy**: Non-existent namespaces, HTTP methods and fully qualified gRPC names only, host without matching service registry entries, fields requiring mTLS enabled, missing service accounts, etc.\n2. **DestinationRule**: Multiple destination rules for the same host subset combination, host without matching entries in the service registry, subset labels not found in any matching hosts, etc.\n3. **Gateway**: Multiple gateways for the same host-port combination, gateway selectors not finding matching workloads in the namespace, etc.\n4. **Port**: Port names must follow a specific format, application protocols for ports must follow a specific format, etc.\n5. **Service**: No deployments exposing the same ports as the service found, etc.\n6. **VirtualService**: Routes with target weights do not have a valid service, virtual services pointing to non-existent gateways, etc.\n\n## Common Istio Configuration Errors Examples\n\nIn daily use of Istio, here are some of the most common configuration errors:\n\n1. **Virtual services pointing to non-existent gateways**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n      gateways:\n        - non-existent-gateway\n    \u0060\u0060\u0060\n    In this case, the \u0060details\u0060 virtual service tries to route through a non-existent \u0060non-existent-gateway\u0060, leading to traffic management failure.\n\n2. **Virtual services referencing non-existent service subsets**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: VirtualService\n    metadata:\n      name: details\n      namespace: bookinfo\n    spec:\n      hosts:\n        - details\n    \u0060\u0060\u0060\n    If the \u0060details\u0060 service does not define the corresponding subsets, requests will be rejected due to not finding the correct service instances.\n\n3. **Gateways not finding specified server credentials**:\n\n    \u0060\u0060\u0060yaml\n    apiVersion: networking.istio.io\/v1beta1\n    kind: Gateway\n    metadata:\n      name: cert-not-found-gateway\n      namespace: bookinfo\n    spec:\n      selector:\n        istio: ingressgateway\n      servers:\n        - port:\n            number: 443\n            name: https\n            protocol: HTTPS\n          tls:\n            mode: SIMPLE\n            credentialName: \u0022not-exist\u0022\n    \u0060\u0060\u0060\n    This will lead to a TLS handshake failure because the specified credential \u0060not-exist\u0060 does not exist.\n\n## Configuration Verification\n\nTo reduce the risk of service disruptions due to configuration errors, configuration verification has become indispensable. Configuration verification can be divided into the following two types:\n\n- **Static Configuration Verification**: Verify configurations before they are applied to the system. This includes checking for syntax errors, completeness, and validity of configuration items.\n- **On-demand Configuration Verification**: Verify configurations that have already been applied but may need adjustments based on real-time data. This type of verification helps adapt to changes in dynamic environments, ensuring the ongoing correctness of configurations.\n\n### Recommended Configuration Verification Tools\n\n#### \u0060istioctl validate\u0060\n\n\u0060istioctl validate\u0060 is used to verify the syntax and basic structure of Istio configuration files (such as YAML files), ensuring that the configuration files comply with the Istio API specifications. It can detect syntax and format errors before configurations are applied to the cluster. This is a static analysis tool, often integrated into the CI process, to prevent invalid configuration files from being applied to the cluster.\n\n#### \u0060istioctl analyze\u0060\n\n[\u0060istioctl analyze\u0060](https:\/\/istio.io\/latest\/docs\/ops\/diagnostic-tools\/istioctl-analyze\/) is a powerful diagnostic tool used to analyze the operational state and consistency of configurations in an Istio cluster. It not only checks the syntax of configuration files but also examines the configurations applied in the cluster to identify potential problems and conflicts. \u0060istioctl analyze\u0060 provides dynamic analysis capabilities, capable of identifying configuration errors and potential issues during cluster operation.\n\nThe configuration process for \u0060istioctl analyze\u0060 is as follows:\n\n1. **Collect Configuration Data**: First, \u0060istioctl analyze\u0060 collects Istio configuration data from specified sources. These sources can be an active Kubernetes cluster or local configuration files.\n2. **Parse and Build Model**: The tool parses the collected configuration data and builds an internal model representing Istio configurations.\n3. **Apply Analysis Rules**: Subsequently, it applies a set of predefined rules to analyze this model, detecting potential configuration issues. These rules cover a range of potential issues from security vulnerabilities to performance problems.\n4. **Generate Report**: After the analysis is complete, \u0060istioctl analyze\u0060 outputs a detailed report containing all identified issues. If no issues are found, it informs the user that the configurations appear to be correct.\n\nThe following is a workflow diagram of \u0060istioctl analyze\u0060:\n\n\u0060\u0060\u0060mermaid istioctl analyze Workflow Diagram\nflowchart TD\n    A[Start] --\u003e B[Select Configuration Source]\n    B --Local Files--\u003e C[Load Local Configuration Files]\n    B --Live Cluster--\u003e D[Connect to Kubernetes Cluster]\n    B --Both--\u003e E[Combine Local Files and Cluster Configurations]\n    C --\u003e F[Parse Configuration Data]\n    D --\u003e F\n    E --\u003e F\n    F --\u003e G[Build Internal Configuration Model]\n    G --\u003e H[Apply Analysis Rules]\n    H --\u003e I{Find Issues?}\n    I --Yes--\u003e J[Generate Issue Report]\n    I --No--\u003e K[Output Configuration Okay]\n    J --\u003e L[End]\n    K --\u003e L\n\u0060\u0060\u0060\n\n![istioctl analyze Workflow Diagram](4eb4d5bbb7c8856d609944835aa03993.svg)\n\n#### Kiali\n\n[Kiali](https:\/\/kiali.io) is a crucial tool for managing and visualizing Istio service meshes, providing real-time insights into the mesh\u0027s health, performance, and configuration status. By integrating Kiali into your Istio environment, you can enhance configuration security through:\n\n- **Visualization**: Kiali offers a graphical representation of the service mesh, making it easier to spot configuration errors, such as incorrect routing or missing policies.\n- **Validation**: It helps validate Istio configurations, highlighting issues such as misconfigured gateways or destination rules before they cause problems.\n- **Security Insights**: Kiali provides visibility into security policies, ensuring that mTLS and authorization settings are correctly implemented.\n\nUsing Kiali alongside tools like \u0060istioctl validate\u0060 and \u0060istioctl analyze\u0060 ensures a more robust approach to preventing and resolving Istio configuration errors, contributing to a secure and efficient service mesh.\n\n## Introduction to TIS\u0027s Config Analyzer Tool\n\nTo help developers and operations staff avoid common configuration mistakes, Tetrate developed the [Config Analyzer](https:\/\/docs.tetrate.io\/istio-subscription\/dashboard\/analyzers\/config) tool in the TIS Dashboard. This tool automatically verifies Istio configurations, analyzes service mesh configuration issues based on best practices, and provides optimization suggestions. Config Analyzer can automatically detect configuration issues in the Istio service mesh, offering explanations and solutions, and supports on-demand error detection in configurations.\n\n![TIS Config Analyzer can detect configuration issues on-demand](config-validate.png)\n\n## Conclusion\n\nProperly configuring Istio is key to ensuring the healthy operation of the service mesh. By understanding and avoiding common configuration errors, and using advanced tools like Tetrate\u0027s TIS Config Analyzer, you can ensure the stability and security of your Istio environment. Remember, a small configuration error can lead to a failure of the entire service mesh, making continuous monitoring and auditing of configurations very necessary.\n\n## References\n\n- [Validation - kiali.io](https:\/\/kiali.io\/docs\/features\/validations\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-configuration-security-how-to-avoid-misconfigurations\/).*\n', '\/en\/blog\/istio-configuration-safety-common-misconfigurations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore common Istio configuration errors and their solutions to enhance the security and stability of your service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-integration-istio-mesh/">Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Integrating Envoy Gateway as an Ingress Gateway in Istio Service Mesh', 'This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.', '\n[Istio](https:\/\/istio.io) provides robust and flexible support for ingress gateways, utilizing the Envoy proxy in its sidecar mode. While Istio focuses on managing communication between services within a cluster, [Envoy Gateway](https:\/\/gateway.envoyproxy.io) is designed to expose applications to the external world, handle user requests, and support advanced features such as OIDC single sign-on. By combining the capabilities of the Istio service mesh with the advanced gateway features of Envoy Gateway, overall application accessibility and security can be enhanced.\n\nThe following diagram illustrates the traffic path of the ingress gateway in the Istio mesh.\n\n![Istio Ingress Gateway Traffic Path](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-ingress-sidecar.svg)\n\nThe next diagram shows how traffic flows from the edge of the Istio mesh into the internal network after introducing the Envoy Gateway.\n\n![Traffic Path After Introducing Envoy Gateway](https:\/\/jimmysong.io\/blog\/explore-tetrate-enterprise-gateway\/istio-teg-integration.svg)\n\n### Preparing for Interoperability between Envoy Gateway and Istio\n\nTo use Envoy Gateway as an ingress gateway for Istio, consider the following key points:\n\n- Avoid enabling the Ingress Gateway during Istio installation. We\u0027ll manually install and configure Envoy Gateway as the ingress gateway.\n- Since both Istio and Envoy Gateway use Envoy as a proxy, ensure Istio injects the Envoy sidecar into the Envoy Gateway\u0027s gateway pods to allow secure communication with Istio\u0027s data plane.\n- Configure the routing type of the Envoy proxy created by Envoy Gateway as \u0060Service\u0060 instead of \u0060Endpoint\u0060 to ensure proper routing.\n\nFollow the [quick start documentation](https:\/\/gateway.envoyproxy.io\/docs\/tasks\/quickstart\/) to install Envoy Gateway. Label the namespace of the Envoy Gateway to ensure the data plane gets the Istio sidecar injection:\n\n\u0060\u0060\u0060bash\nkubectl label namespace envoy-gateway-system --overwrite=true istio-injection=enabled\n\u0060\u0060\u0060\n\nConfigure the Envoy Gateway\u0027s sidecar to not intercept incoming gateway traffic. The injected sidecar ensures that the components of Envoy Gateway and its created proxies are included in the Istio mesh and mount the correct certificates for secure communication.\n\n{{\u003cinclude_code file=\u0022control-plane-tls.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch service -n envoy-gateway-system envoy-gateway --type strategic --patch-file control-plane-tls.yaml\n\u0060\u0060\u0060\n\nConfigure Envoy Gateway to not intercept inbound traffic:\n\n{{\u003cinclude_code file=\u0022teg-sidecars-no-inbound.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f teg-sidecars-no-inbound.yaml\n\u0060\u0060\u0060\n\nModify the GatewayClass configuration to apply the sidecar configuration to all \u0060EnvoyProxy\u0060 in the Envoy Gateway data plane:\n\n{{\u003cinclude_code file=\u0022gtwcls-use-envoyproxy.yaml\u0022\u003e}}\n\nApply the patch:\n\n\u0060\u0060\u0060bash\nkubectl patch gatewayclass teg --patch-file gtwcls-use-envoyproxy.yaml --type merge\n\u0060\u0060\u0060\n\n### Installing Istio\n\nDeploy Istio using the minimal profile to avoid deploying the Ingress Gateway:\n\n\u0060\u0060\u0060bash\nistioctl install --set profile=minimal -y\n\u0060\u0060\u0060\n\n### Restarting the Envoy Gateway Control Plane\n\nWith Istio\u0027s sidecar injection ready, restart all Envoy Gateway control plane pods:\n\n\u0060\u0060\u0060bash\nfor d in envoy-gateway envoy-ratelimit teg-envoy-gateway teg-redis;\n\tdo kubectl rollout restart deployment -n envoy-gateway-system $d; done\n\u0060\u0060\u0060\n\n### Deploying a Test Application\n\nDeploy test applications after installing Istio to ensure they also receive sidecar injections:\n\n\u0060\u0060\u0060bash\nkubectl create namespace httpbin\nkubectl label namespace httpbin --overwrite=true istio-injection=enabled\nkubectl apply -n httpbin -f https:\/\/raw.githubusercontent.com\/istio\/istio\/master\/samples\/httpbin\/httpbin.yaml\n\u0060\u0060\u0060\n\n### Configuring Envoy Gateway\n\nNow configure the Envoy Gateway to handle edge traffic:\n\n{{\u003cinclude_code file=\u0022apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f apps-gateway.yaml\n\u0060\u0060\u0060\n\nDeploy the application gateway, which includes the following containers:\n\n- \u0060istio-init\u0060: Injected by Istio to modify pod iptables.\n- \u0060envoy\u0060: Controlled by Envoy Gateway, acting as the ingress gateway.\n- \u0060istio-proxy\u0060: Injected by Istio, responsible for communication with internal cluster pods.\n- \u0060shutdown-manager\u0060: Controlled by Envoy Gateway, responsible for pod lifecycle management.\n\nCreate an HTTP route:\n\n{{\u003cinclude_code file=\u0022httpbin-route.yaml\u0022\u003e}}\n\nApply the route configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f httpbin-route.yaml\n\u0060\u0060\u0060\n\n### Sending a Test Request\n\nGet the load balancer IP address of the gateway and send a test request:\n\n\u0060\u0060\u0060bash\nexport GATEWAY_URL=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io\/owning-gateway-name=apps -o jsonpath=\u0027{.items[0].status.loadBalancer.ingress[0].ip}\u0027)\ncurl -v -H Host:www.example.com http:\/\/$GATEWAY_URL\/httpbin\/get\n\u0060\u0060\u0060\n\nYou should see a correct response from the \u0060httpbin\u0060 service:\n\n\u0060\u0060\u0060\n*   Trying 34.41.0.90:80...\n* Connected to 34.41.0.90 (34.41.0.90) port 80\n\u003e GET \/httpbin\/get HTTP\/1.1\n\u003e Host:www.example.com\n\u003e User-Agent: curl\/8.7.1\n\u003e Accept: *\/*\n\u003e\n* Request completely sent off\n\u003c HTTP\/1.1 200 OK\n\u003c server: envoy\n\u003c date: Wed, 31 Jul 2024 08:21:58 GMT\n\u003c content-type: application\/json\n\u003c content-length: 282\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 11\n\u003c\n{\n  \u0022args\u0022: {},\n  \u0022headers\u0022: {\n    \u0022Accept\u0022: \u0022*\/*\u0022,\n    \u0022Host\u0022: \u0022www.example.com\u0022,\n    \u0022User-Agent\u0022: \u0022curl\/8.7.1\u0022,\n    \u0022X-Envoy-Attempt-Count\u0022: \u00221\u0022,\n    \u0022X-Envoy-External-Address\u0022: \u0022123.120.227.173\u0022\n  },\n  \u0022origin\u0022: \u0022123.120.227.173\u0022,\n  \u0022url\u0022: \u0022http:\/\/www.example.com\/get\u0022\n}\n* Connection #0 to host 34.41.0.90 left intact\n\u0060\u0060\u0060\n\n### Enabling Strict mTLS\n\nEnable strict mTLS by applying the following configuration:\n\n{{\u003cinclude_code file=\u0022strict-mtls.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f strict-mtls.yaml\n\u0060\u0060\u0060\n\n### Enabling TLS for the Gateway\n\nCreate the root certificate and private key for service signing:\n\n\u0060\u0060\u0060bash\nmkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj \u0027\/O=example Inc.\/CN=example.com\u0027 -keyout example_certs\/example.com.key -out example_certs\/example.com.crt\n\u0060\u0060\u0060\n\nCreate the certificate and private key for \u0060www.example.com\u0060:\n\n\u0060\u0060\u0060bash\nopenssl req -out example_certs\/www.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs\/www.example.com.key -subj \u0022\/CN=www.example.com\/O=www organization\u0022\nopenssl x509 -req -sha256 -days 365 -CA example_certs\/example.com.crt -CAkey example_certs\/example.com.key -set_serial 0 -in example_certs\/www.example.com.csr -out example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nCreate a secret for the ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl create -n httpbin secret tls httpbin-credential --key=example_certs\/www.example.com.key --cert=example_certs\/www.example.com.crt\n\u0060\u0060\u0060\n\nConfigure the ingress gateway:\n\n{{\u003cinclude_code file=\u0022tls-apps-gateway.yaml\u0022\u003e}}\n\nApply the configuration:\n\n\u0060\u0060\u0060bash\nkubectl apply -f tls-apps-gateway.yaml\n\u0060\u0060\u0060\n\nSend a test request:\n\n\u0060\u0060\u0060bash\ncurl -v -H Host:www.example.com --resolve \u0022www.example.com:443:$GATEWAY_URL\u0022 --cacert example_certs\/example.com.crt \u0022https:\/\/www.example.com:443\/httpbin\/get\u0022\n\u0060\u0060\u0060\n\nYou should be able to access the \u0060httpbin\u0060 service within the mesh via HTTPS.\n\n### Conclusion\n\nBy integrating Envoy Gateway as an ingress gateway in your Istio service mesh, you can leverage the best of both worlds: Istio\u0027s robust service mesh capabilities and Envoy Gateway\u0027s advanced gateway features. This setup enhances the security, scalability, and flexibility of your applications, providing a seamless and secure user experience. With careful configuration and the right tools, managing traffic in and out of your service mesh becomes more efficient and effective, ensuring your applications are always accessible and secure. \n', '\/en\/blog\/envoy-gateway-integration-istio-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article describes how to integrate Envoy Gateway as an ingress gateway in the Istio service mesh to enhance application security and accessibility.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 10, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Securing Istio: Addressing Critical Security Gaps and Best Practices', 'Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.', '\n## Introduction\n\nRecently, the Wiz research team released a [blog post](https:\/\/www.wiz.io\/blog\/sapwned-sap-ai-vulnerabilities-ai-security) that uncovered tenant isolation vulnerabilities in AI services, generating widespread attention. This study detailed security flaws across several AI service providers, particularly the SAP AI Core platform. Researchers were able to execute arbitrary code through legitimate AI training processes, subsequently moving laterally to take over services and gain access to customers’ private files and cloud credentials. These findings highlight the challenges that cloud services and management platforms face in ensuring isolation and sandbox environments.\n\nIn this context, Istio, as a crucial service mesh solution, faces similar security issues, especially in key functionalities like sidecar injection and traffic management. This blog aims to discuss how to protect the security of the Istio service mesh and provide a comprehensive set of mitigation measures. We will also discuss how multi-layer security strategies can effectively enhance Istio\u0027s security to address challenges mentioned in the Wiz report.\n\n## Overview\n\nIstio primarily manages east-west traffic within Kubernetes, offering detailed traffic management features such as request routing, load balancing, and fault recovery policies. While Istio offers essential security features such as traffic encryption, authentication, and authorization, it should not be viewed as a standalone firewall solution. To maintain robust security for services within the Istio mesh, it is crucial to complement Istio\u0027s security capabilities with additional measures from the underlying network and infrastructure, such as Container Network Interface (CNI) plugins and secure container implementations.\n\nWhether in Sidecar or Ambient mode, traffic is hijacked from application pods to data plane proxies for processing and forwarding. If application traffic is not successfully intercepted or is impersonated by a rogue application masquerading as Istio, security vulnerabilities can arise.\n\nThe diagram below illustrates where security vulnerabilities due to bypassing or impersonating Istio system users might occur.\n\n![\u0022Security vulnerabilities\u0022 in bypassing Istio\u0027s traffic hijacking](bypass-sidecar-traffic-hijack.svg)\n\nNext, we will explore specific situations where \u0022security vulnerabilities\u0022 arise and the strategies to address them.\n\n## Bypassing Istio Sidecar Injection\n\n### At the Namespace Level\n\n- **Scenario**: Application teams misuse namespace labels to disable Istio Sidecar injection at the namespace level.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes namespace resources.\n- **Monitoring**: Use policy engines (like OPA Gatekeeper) to ensure compliance with namespace labels, and regularly review namespace configurations.\n\n### At the Pod Level\n\n- **Scenario**: Application teams misuse Pod labels to disable Istio Sidecar injection at the Pod level.\n- **Mitigation Strategy**:\n  - Force all Pods to specify a UID that is not 1337.\n  - Inspect all container images to check for UID 1337 and reject those images. This inspection can be performed using an admission webhook or by a central team managing the image registry.\n- **Monitoring**: Employ Admission Webhooks to enforce Sidecar injection, prohibit exclusion labels, and regularly scan and audit all pods to ensure every required pod has a Sidecar injected.\n\n## Bypassing Traffic Redirection to Istio Sidecar\n\n### Misuse of Traffic Redirection Annotations\n\n- **Scenario**: Application teams misuse Pod annotations to exclude certain inbound or outbound ports or IPs, thereby bypassing traffic redirection.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Use policy engines to detect and alert on non-compliant annotation use, regularly review Pod annotations.\n\n### Misuse of Pod UID\n\n- **Scenario**: Application teams misuse UID 1337 (the ID of the sidecar proxy) to bypass Istio\u0027s Iptables redirection rules.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Prohibit or restrict the use of UID 1337, regularly audit Pod UID configurations to ensure no bypassing occurs.\n\n### Misuse of Pod Capabilities (NET_ADMIN, NET_RAW)\n\n- **Scenario**: Application teams misuse NET_ADMIN and NET_RAW capabilities to remove Istio Iptables rules.\n- **Mitigation Strategy**: Platform teams enable Istio CNI (to avoid granting elevated privileges to application teams) and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Regularly review and monitor Pod permission configurations to ensure no over-privileged actions are taken.\n\n## Bypassing Inbound Traffic Constraints\n\n### Misuse of PeerAuthentication\n\n- **Scenario**: Application teams create a PeerAuthentication resource for each namespace\/workload, enabling the PERMISSIVE authentication mode.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio PeerAuthentication resources.\n- **Monitoring**: Regularly review PeerAuthentication configurations to ensure all inbound traffic is encrypted as required.\n\n## Bypassing Outbound Traffic Constraints\n\n### Misuse of ServiceEntry\n\n- **Scenario**: Application teams create a ServiceEntry to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio ServiceEntry resources.\n- **Monitoring**: Regularly review ServiceEntry configurations to ensure no bypassing occurs.\n\n### Misuse of ExternalName Services\n\n- **Scenario**: Application teams create a Kubernetes Service of type ExternalName to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Kubernetes Service resources.\n- **Monitoring**: Regularly review the types of Kubernetes Service configurations to ensure no bypassing occurs.\n\n## Uncontrollably Changing Istio Sidecar Configuration\n\n### Misuse of Sidecar Resources\n\n- **Scenario**: Application teams create an Istio Sidecar resource for each workload and set the \u0060outboundTrafficPolicy\u0060 field to \u0060ALLOW_ANY\u0060 (overriding the possible global value \u0060REGISTRY_ONLY\u0060).\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio Sidecar resources.\n- **Monitoring**: Regularly review Sidecar resource configurations to ensure no global settings are overridden.\n\n### Misuse of EnvoyFilter\n\n- **Scenario**: Application teams create an EnvoyFilter that conflicts with existing Istio objects, potentially causing DoS attacks or violating security policies.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio EnvoyFilter resources.\n- **Monitoring**: Regularly review EnvoyFilter configurations to ensure no improper use occurs.\n\n## Service Mesh as Part of a Layered Defense\n\nThe service mesh is described as a supplemental layer to existing security models, enhancing microservice security by adding finer-grained security policies on top of traditional security controls. However, the article emphasizes that service meshes cannot independently ensure comprehensive security for microservices but should be part of an overall security strategy.\n\n![Microservices security layered architecture](security-layers.svg)\n\nService meshes primarily manage and control network traffic by deploying a lightweight proxy (sidecar) next to each service instance. This allows for precise traffic control and policy enforcement at the network level, such as traffic encryption, authentication, and authorization. Although service meshes offer features like traffic control, service discovery, and circuit breakers, these are essentially management of network traffic and are not sufficient to address all security issues. For instance, they cannot replace traditional security measures like application layer firewalls, intrusion detection systems, and data security.\n\nFurthermore, service meshes rely on correct configuration and management, and improper configuration can lead to security vulnerabilities. Therefore, while service meshes are an indispensable part of modern microservices architectures, they should be combined with traditional security measures to form a comprehensive, multi-layered security strategy framework. Refer to [How Service Mesh Layers Microservices Security with Traditional Security to Move Fast Safely](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) for further insights on strengthening service mesh security.\n\n## Long-term Solutions and Community Collaboration\n\nThe Istio community conducts a security audit almost every year, see the results from [2021](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/) and [2022](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/). From these results, we can see that Istio\u0027s security posture has greatly improved. Ensure that your Istio service mesh adheres to [security best practices](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/). Additionally, keep an eye on the [Istio CVE Bulletins](https:\/\/istio.io\/latest\/news\/security\/) or use tools like [Tetrate Istio Subscription](https:\/\/tetrate.io\/tetrate-istio-subscription\/) that can scan for various CVEs in the Istio service mesh, deploying Istio versions that are FIPS compliant and FIPS certified.\n\n## Conclusion\n\nService meshes provide an additional layer of security for microservices architectures by managing control flows outside of the applications. This allows for enhanced communication security between services without impacting application performance. When deploying service meshes, it is recommended to use Istio’s Egress Gateway to manage outbound traffic, in conjunction with Kubernetes\u0027 NetworkPolicy, to ensure all outbound traffic must pass through the gateway, thus preventing potential data leaks and other security threats.\n\n## References\n\n- [How to enforce egress traffic using Istio’s authorization policies - tetrate.io](https:\/\/tetrate.io\/blog\/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies\/)\n- [Istio Security Best Practice - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n- [Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io](https:\/\/tetrate.io\/blog\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/)\n- [Istio publishes results of 2022 security audit - istio.io](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/)\n- [Announcing the results of Istio’s first security assessment - istio.io](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)\n', '\/en\/blog\/securing-istio-addressing-critical-security-gaps-and-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Migrate from Kubernetes Ingress to the Gateway API', 'This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.', '\nWith the release of Istio 1.22, the Istio API has officially been upgraded to version v1, coinciding with the update of the Kubernetes Gateway API to v1.1. This article aims to explore the connections and differences between the Ingress API, Istio API, and Kubernetes Gateway API, detailing their selection and migration strategies in practical applications.\n\n## Introduction\n\nPreviously, I wrote an article discussing [Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh](\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/). The article pointed out that as Kubernetes\u0027 original ingress gateway, Ingress\u0027s resource model is too simple to meet the demands of today\u0027s programmable networks. As its successor, the Gateway API has rapidly developed in recent years and has gained broad support, including many emerging open-source gateway projects like [Envoy Gateway](https:\/\/gateway.envoyproxy.io) choosing to develop based on the Gateway API. Additionally, some legacy gateway projects have started adapting to the Gateway API or using tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) to migrate.\n\nThe Gateway API, as the latest achievement in Kubernetes ingress gateways, separates concerns through role division and supports cross-namespace capabilities, making it more suitable for multi-cloud environments. It integrates the overlapping functions of ingress gateways (north-south) and service meshes (east-west, intra-cluster routing) to provide a new reference model for unified traffic management in the cloud-native era.\n\nIngress API, Gateway API, and Istio API can all implement gateway functions, but what are the connections and differences between them? This article will unveil this mystery and provide strategies for selecting and migrating gateways in Kubernetes environments.\n\n## Kubernetes Traffic Management\n\nWith the widespread adoption and increasing complexity of microservice architectures, Kubernetes\u0027 traffic management tools have also evolved to meet various technical needs. The Ingress API, Istio API, and Kubernetes Gateway API each represent different stages of this evolution.\n\n**Ingress API** offers basic traffic management capabilities in Kubernetes, allowing users to manage external access to services within the cluster through simple routing rules (e.g., HTTP and HTTPS). Although its design is straightforward, its functionality is limited and mainly suitable for smaller-scale, less complex applications.\n\nIn contrast, **Istio API**, as part of a service mesh, offers a range of advanced traffic management features, such as traffic mirroring, canary releases, and circuit breakers, suitable for large-scale microservice architectures requiring complex traffic management.\n\nTo overcome the limitations of the Ingress API and integrate advanced features similar to those of Istio, the **Kubernetes Gateway API** was developed. It not only provides greater flexibility and extensibility in its design but also, through broad community support, serves as a bridge connecting traditional Ingress implementations and modern service mesh technologies like Istio, with most mainstream open-source gateways being based on or adapted to the Gateway API.\n\nThe following table summarizes the core features and recommended use cases for each API:\n\n| API Name      | Object Type                | Status                  | Recommended Use Cases                                       |\n| ------------- | -------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API   | \u0060Ingress\u0060                  | Stable (Kubernetes v1.19)| Suitable for small-scale and simple scenarios, mainly for basic routing configurations |\n| Istio API     | \u0060VirtualService\u0060, \u0060Gateway\u0060| Stable (Istio 1.22)     | Suitable for highly complex microservice architectures, requiring fine-grained control and advanced traffic management features |\n| Gateway API   | \u0060HTTPRoute\u0060, \u0060Gateway\u0060     | Stable (Gateway API v1.1)| Suitable for new or existing deployments that require increased flexibility and scalability, especially when combined with Istio |\n\nThe launch of [Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/), especially its improvements in compatibility with existing Ingress configurations, provides a smooth migration path for users, making the transition from traditional Ingress solutions to more modern, feature-rich Gateway API easier.\n\n## Migrating from Ingress to Kubernetes Gateway API\n\nTo migrate from Ingress to Gateway API, follow these steps:\n\n1. **Understand Key Differences**: Compared to Ingress, the Gateway API introduces several new concepts and resource types, such as \u0060Gateway\u0060, \u0060HTTPRoute\u0060, and \u0060TLSRoute\u0060. These resources offer more configuration options and flexibility; refer to the [Gateway API documentation](https:\/\/gateway-api.sigs.k8s.io\/guides\/) for their configurations.\n2. **Configure Entry Points**: Create \u0060Gateway\u0060 resource configurations, clearly defining how to receive external traffic, including protocols, ports, and TLS terminations.\n3. **Map Old Resources**: Map existing Ingress resources to corresponding Gateway API resources. For example, host and path rules in Ingress need to be converted into route rules in HTTPRoute.\n4. **Test and Deploy**: Before officially migrating, test the new Gateway API configurations in a test environment to ensure all traffic routing is normal and there are no security vulnerabilities.\n\nTo simplify the migration process, you can use tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway), which can automatically convert Ingress configurations into Gateway API formats.\n\n## Practical Migration Example\n\nHere is a simple example of an HTTP gateway configuration demonstrating how to migrate from Ingress to the Gateway API.\n\nAssume you have an existing Ingress configuration as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\nTo migrate it to the Gateway API, first create a Gateway object:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds:\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\nEnsure that the \u0060gatewayClassName\u0060 refers to a valid GatewayClass configured in your cluster. The GatewayClass is usually set by the cluster administrator and provides a resource to configure the Gateway.\n\nNext, create an HTTPRoute resource to define routing rules that route traffic to the backend service:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\nIn this example, we see:\n\n- The rules from the \u0060Ingress\u0060 object are directly mapped to the \u0060HTTPRoute\u0060 object.\n- The hostname matching, path matching, and backend service configurations remain unchanged, but the object and field names differ.\n\n## Considerations and Challenges\n\nAlthough it is possible to migrate from Ingress to Gateway API and potentially run them simultaneously, there are several challenges and considerations for the necessity of migration:\n\n- **Feature Differences**: Certain features specific to some Ingress controllers may not have direct equivalents in the Gateway API, requiring additional configurations or custom resources to achieve similar functionalities.\n- **Multi-Resource Management**: Using the Gateway API may involve managing more resource types and complex configurations than Ingress, potentially increasing the complexity of administration.\n\nFor existing users of Ingress and Istio API, whether to migrate to the Gateway API depends on specific circumstances. Here are some migration recommendations:\n\n- **For New Deployments**: It is advisable to use the Gateway API directly to take advantage of its advanced features and anticipate future developments.\n- **For Existing Deployments**: If the existing system operates stably and does not require advanced features, you can continue using the current APIs. If you seek to leverage new features of the Gateway API or plan for long-term development, a gradual migration is a prudent choice.\n\nFor the support status of different gateways for the Gateway API, refer to the [Gateway API Implementation Conformance Report](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/) for more details.\n\n## Conclusion\n\nThe Ingress API, Istio API, and Kubernetes Gateway API each have distinct features suitable for different application scenarios and needs. Selecting the appropriate API and planning and managing effectively can significantly enhance system flexibility and stability. As the Gateway API continues to develop and mature, it is increasingly becoming the mainstream choice for future traffic management.\n\nChoosing the right gateway technology, combined with your specific needs and existing architecture, can better manage and optimize traffic to ensure efficient and stable application operation. As technology progresses and the community evolves, the Gateway API provides a powerful and flexible framework, making the transition from traditional Ingress to more modern solutions simpler and more effective.\n\n## References\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/kubernetes-ingress-to-gateway-api-migration\/).*', '\/en\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/seamless-cross-cluster-access-istio/">A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 25, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh', 'Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.', '\n## Introduction\n\nAs enterprise information systems increasingly adopt microservices architecture, how to achieve efficient and secure cross-cluster access to services in a multicluster environment has become a crucial challenge. Istio, as a popular service mesh solution, offers a wealth of features to support seamless inter-cluster service connections.\n\nThere are several challenges when deploying and using a multicluster service mesh:\n\n- Cross-cluster service registration, discovery, and routing\n- Identity recognition and authentication between clusters\n\nThis article will delve into how to achieve seamless cross-cluster access in a multicluster Istio deployment by implementing SPIRE federation and exposing services via east-west gateways. Through a series of configuration and deployment examples, this article aims to provide readers with a clear guide to understanding and addressing common issues and challenges in multicluster service mesh deployments.\n\n## Istio Deployment Models\n\nThe [Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/) divides various deployment models based on clusters, networks, control planes, meshes, trust domains, and tenants.\n\nThis article focuses on the hybrid deployment model of multi-cloud \u002b multi-mesh \u002b multi-control plane \u002b multi-trust domain. This is a relatively complex scenario. If you can successfully deploy this model, then other scenarios should also be manageable.\n\n## FQDN in Multicluster Istio Service Mesh\n\nFor services across different meshes to access each other, they must be aware of each other\u0027s Fully Qualified Domain Name (FQDN). FQDNs typically consist of the service name, namespace, and top-level domain (e.g., \u0060svc.cluster.local\u0060). In Istio\u0027s multi-cloud or multi-mesh setup, different mechanisms such as \u0060ServiceEntry\u0060, \u0060VirtualService\u0060, and \u0060Gateway\u0060 configurations are used to control and manage service routing and access, instead of altering the FQDN.\n\nThe FQDN in a multi-cloud service mesh remains the same as in a single cluster, usually following the format:\n\n\u0060\u0060\u0060\n\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local\n\u0060\u0060\u0060\n\nYou might think about using \u0060meshID\u0060 to distinguish meshes? The \u0060meshID\u0060 is mainly used to differentiate and manage multiple Istio meshes within the same environment or across environments, and it is not used to directly construct the service FQDN.\n\n{{\u003ccallout note  \u0022Main roles of \u0060meshID\u0060\u0022\u003e}}\n- **Mesh-level telemetry data aggregation**: Differentiates data from different meshes, allowing for monitoring and analysis on a unified platform.\n- **Mesh federation**: Establishes federation among meshes, allowing for sharing some configurations and services.\n- **Cross-mesh policy implementation**: Identifies and applies mesh-specific policies, such as security policies and access control.\n{{\u003c\/callout\u003e}}\n\n## Cross-Cluster Service Registration, Discovery, and Routing\n\nIn the Istio multi-mesh environment, the East-West Gateway plays a key role. It not only handles ingress and egress traffic between meshes but also supports service discovery and connectivity. When one cluster needs to access a service in another cluster, it routes to the target service through this gateway.\n\nThe diagram below shows the process of service registration, discovery, and routing across clusters.\n\nIn the configuration of Istio multi-mesh, the processes of service registration, discovery, and routing are crucial as they ensure that services in different clusters can discover and communicate with each other. Here are the basic steps in service registration, discovery, and routing in the Istio multi-mesh environment:\n\n### 1. Service Registration\n\nIn each Kubernetes cluster, when a service is deployed, its details are registered with the Kubernetes API Server. This includes the service name, labels, selectors, ports, etc.\n\n### 2. Sync to Istiod\n\nIstiod, serving as the control plane, is responsible for monitoring changes in the status of the Kubernetes API Server. Whenever a new service is registered or an existing service is updated, Istiod automatically detects these changes. Istiod then extracts the necessary service information and builds internal configurations of services and endpoints.\n\n### 3. Cross-Cluster Service Discovery\n\nTo enable a service in one cluster to discover and communicate with a service in another cluster, Istiod needs to synchronize service endpoint information across all relevant clusters. This is usually achieved in one of two ways:\n   - **DNS Resolution**: Istio can be configured to use CoreDNS or a similar service to return cross-cluster service endpoints in DNS queries. When a service tries to resolve another cluster\u0027s service, the DNS query returns the IP addresses of the accessible remote service. In this article, we enable Istio\u0027s [DNS proxy](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/) to achieve cross-cluster service discovery. If a service exists both locally and remotely, a local DNS query returns only the local service\u0027s ClusterIP. If the service exists only in a remote cluster, the DNS query returns the IP address of the East-West Gateway\u0027s load balancer in the remote cluster, which can also be used for cross-cluster failover.\n   - **Service Entry Synchronization**: By setting specific ServiceEntry configurations, an Envoy proxy in one cluster knows how to find and route to a service in another cluster through the East-West Gateway.\n\n### 4. Routing and Load Balancing\n\nWhen Service A needs to communicate with Service B, its Envoy proxy first resolves the name of Service B to get an IP address, which is the load balancer address of the East-West Gateway in Service B\u0027s cluster. Then, the East-West Gateway routes the request to the target service. Envoy proxies can select the best service instance to send requests based on configured load balancing strategies (e.g., round-robin, least connections, etc.).\n\n### 5. Traffic Management\n\nIstio offers a rich set of traffic management features, such as request routing, fault injection, and traffic mirroring. These rules are defined in the Istio control plane and pushed to the various Envoy proxies for execution. This allows for flexible control and optimization of communication between services in a cross-cluster environment.\n\n## Identity Recognition and Authentication Between Clusters\n\nWhen services running in different clusters need to communicate with each other, correct identity authentication and authorization are key to ensuring service security. Using SPIFFE helps to identify and verify the identities of services, but in a multi-cloud environment, these identities need to be unique and verifiable.\n\nTo this end, we will set up SPIRE federation to assign identities to services across multiple clusters and achieve cross-cluster identity authentication:\n\n- **Using SPIFFE to Identify Service Identities**: Under the SPIFFE framework, each service is assigned a unique identifier in the format \u0060spiffe:\/\/\u003ctrust-domain\u003e\/\u003cnamespace\u003e\/\u003cservice\u003e\u0060. In a multi-cloud environment, including the cluster name in the \u0022trust domain\u0022 ensures the uniqueness of identities. For example, \u0060spiffe:\/\/foo.com\/ns\/default\/svc\/service1\u0060 and \u0060spiffe:\/\/bar.com\/ns\/default\/svc\/service1\u0060 can be set to differentiate services with the same name in different clusters.\n- **Using SPIRE Federation to Manage Inter-Cluster Certificates**: This enhances the security of the multi-cloud service mesh. SPIRE (SPIFFE Runtime Environment) offers a highly configurable platform for service identity verification and certificate issuance. When using SPIRE federation, cross-cluster service authentication can be achieved by creating a Trust Bundle for each SPIRE cluster.\n\nHere are the steps for implementing SPIRE federation.\n\n### 1. Configuring Trust Domain\n\nEach cluster is configured as a separate trust domain. Thus, each service within a cluster will have a unique SPIFFE ID based on its trust domain. For instance, a service in cluster 1 might have the ID \u0060spiffe:\/\/cluster1\/ns\/default\/svc\/service1\u0060, while the same service in cluster 2 would be \u0060spiffe:\/\/cluster2\/ns\/default\/svc\/service1\u0060.\n\n### 2. Establishing Trust Bundle\n\nConfigure trust relationships in SPIRE to allow nodes and workloads from different trust domains to mutually verify each other. This involves exchanging and accepting each other\u0027s CA certificates or JWT keys between trust domains, ensuring the security of cross-cluster communication.\n\n### 3. Configuring SPIRE Server and Agent\n\nDeploy a SPIRE Server and SPIRE Agent in each cluster. The SPIRE Server is responsible for managing the issuance and renewal of certificates, while the SPIRE Agent handles the secure distribution of certificates and keys to services within the cluster.\n\n{{\u003ccallout warning \u0022Compatibility Issues with Workload Registration when Using SPIRE Federation in Istio\u0022\u003e}}\nIn this article, we use the traditional Kubernetes Workload Registrar in the SPRIE Server to handle workload registration within the cluster. The Kubernetes Workload Registrar has been deprecated from SPIRE v1.5.4 onwards, replaced by the SPIRE Controller Manager, which, in my testing, does not run well with Istio.\n{{\u003c\/callout\u003e}}\n\n### 4. Using the Workload API\n\nServices can request and update their identity certificates through SPIRE\u0027s Workload API. This way, services can continuously verify their identities and securely communicate with other services, even when operating in different clusters. We will configure the proxies in the Istio mesh to share the Unix Domain Socket in the SPIRE Agent, thus accessing the Workload API to manage certificates.\n\n### 5. Automating Certificate Rotation\n\nWe will use cert-manager as SPIRE\u0027s [UpstreamAuthority](https:\/\/github.com\/spiffe\/spire\/blob\/v1.9.5\/doc\/plugin_server_upstreamauthority_cert_manager.md) to configure automatic rotation of service certificates and keys, enhancing the system\u0027s security. With automated rotation, even if certificates are leaked, attackers can only use these certificates for a short period.\n\nThese steps allow you to establish a cross-cluster, secure service identity verification framework, enabling services in different clusters to securely recognize and communicate with each other, effectively reducing security risks and simplifying certificate management. This configuration not only enhances security but also improves the system\u0027s scalability and flexibility through distributed trust domains.\n\n## Multicluster Deployment\n\nThe diagram below shows the deployment model for Istio multi-cloud and SPIRE federation.\n\n![Multicloud Mesh Deployment Model](multi-cluster-deployment.svg)\n\nBelow, I will demonstrate how to achieve seamless cross-cluster access in a multi-cloud Istio mesh.\n\n1. Create two Kubernetes clusters in GKE, named \u0060cluster-1\u0060 and \u0060cluster-2\u0060.\n2. Deploy SPIRE and set up federation in both clusters.\n3. Install Istio in both clusters, paying attention to configure the trust domain, east-west gateways, ingress gateways, \u0060sidecarInjectorWebhook\u0060 mounting SPIFFE UDS\u0027s \u0060workload-socket\u0060, and enabling DNS proxy.\n4. Deploy test applications and verify seamless cross-cluster access.\n\nThe versions of the components we deployed are as follows:\n\n- Kubernetes: v1.29.4\n- Istio: v1.22.1\n- SPIRE: v1.5.1\n- cert-manager: v1.15.1\n\nI have saved all commands and step-by-step\n\n instructions on Github: [rootsongjc\/istio-multi-cluster](https:\/\/github.com\/rootsongjc\/istio-multi-cluster). You can follow the instructions in this project. Here are explanations for the main steps.\n\n### 1. Preparing Kubernetes Clusters\n\nOpen Google Cloud Shell or your local terminal, and make sure you have installed the \u0060gcloud\u0060 CLI. Use the following commands to create two clusters:\n\n\u0060\u0060\u0060bash\ngcloud container clusters create cluster-1 --zone us-central1-a --num-nodes 3\ngcloud container clusters create cluster-2 --zone us-central1-b --num-nodes 3\n\u0060\u0060\u0060\n\n### 2. Deploying cert-manager\n\nUse cert-manager as the root CA to issue certificates for istiod and SPIRE.\n\n\u0060\u0060\u0060bash\n.\/cert-manager\/install-cert-manager.sh\n\u0060\u0060\u0060\n\n### 3. Deploying SPIRE Federation\n\nBasic information for SPIRE federation is as follows:\n\n| Cluster Alias | Trust Domain |\n| ------------- | ------------ |\n| cluster-1     | foo.com      |\n| cluster-2     | bar.com      |\n\nNote: The trust domain does not need to match the DNS name but must be the same as the trust domain in the Istio Operator configuration.\n\nExecute the following command to deploy SPIRE federation:\n\n\u0060\u0060\u0060bash\n.\/spire\/install-spire.sh\n\u0060\u0060\u0060\n\nFor details on managing identities in Istio using SPIRE, refer to [Managing Certificates in Istio with cert-manager and SPIRE](\/en\/blog\/cert-manager-spire-istio\/).\n\n### 4. Installing Istio\n\nWe will use IstioOperator to install Istio, configuring each cluster with:\n\n- Automatic Sidecar Injection\n- Ingress Gateway\n- East-West Gateway\n- DNS Proxy\n- SPIRE Integration\n- Access to remote Kubernetes cluster secrets\n\nExecute the following command to install Istio:\n\n\u0060\u0060\u0060bash\nistio\/install-istio.sh\n\u0060\u0060\u0060\n\n## Verifying Traffic Federation\n\nTo verify the correctness of the multi-cloud installation, we will deploy different versions of the \u0060helloworld\u0060 application in both clusters and then access the \u0060helloworld\u0060 service from \u0060cluster-1\u0060 to test the following cross-cluster access scenarios:\n\n1. East-West Traffic Federation: Cross-cluster service redundancy\n2. East-West Traffic Federation: Handling non-local target services\n3. North-South Traffic Federation: Accessing services via a remote ingress gateway\n\nExecute the following command to deploy the \u0060helloworld\u0060 application in both clusters:\n\n\u0060\u0060\u0060bash\n.\/example\/deploy-helloword.sh\n\u0060\u0060\u0060\n\n### East-West Traffic Federation: Cross-Cluster Service Redundancy\n\nAfter deploying the \u0060helloworld\u0060 application, access the \u0060hellowrold\u0060 service from the \u0060sleep\u0060 pod in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nThe diagram below shows the deployment architecture and traffic routing path for this scenario.\n\n![East-West Traffic Federation: Cross-Cluster Service Redundancy](east-west-traffic-federation-between-clusters-without-dns-proxying.svg)\n\nThe response results including both \u0060helloworld-v1\u0060 and \u0060helloworld-v2\u0060 indicate that cross-cluster service redundancy is effective.\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the ClusterIP of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060.\n\n**Verifying Traffic Routing**\n\nNext, we will verify the cross-cluster traffic routing path by examining the Envoy proxy configuration.\n\nView the endpoints of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deployment\/sleep.sleep --context=cluster-1 --cluster \u0022outbound|5000||helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT               STATUS      OUTLIER CHECK     CLUSTER\n10.76.3.22:5000        HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n34.136.67.85:15443     HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThese two endpoints, one is the endpoint of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060, and the other is the load balancer address of the \u0060istio-eastwestgateway\u0060 service in \u0060cluster-2\u0060. Istio sets up SNI for cross-cluster TLS connections, and in \u0060cluster-2\u0060, the target service is distinguished by SNI.\n\nExecute the following command to query the endpoint in \u0060cluster-2\u0060 based on the previous SNI:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deploy\/istio-eastwestgateway.istio-system --context=cluster-2 --cluster \u0022outbound_.5000_._.helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will get output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT           STATUS      OUTLIER CHECK     CLUSTER\n10.88.2.4:5000     HEALTHY     OK                outbound_.5000_._.helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThis endpoint is the endpoint of the \u0060helloworld\u0060 service in the \u0060cluster-2\u0060 cluster.\n\nThrough the steps above, you should understand the traffic path for cross-cluster redundant services. Next, we will delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060. No configuration changes are needed in Istio to automatically achieve failover.\n\n### East-West Traffic Federation: Failover\n\nExecute the following command to scale down the replicas of \u0060helloworld-v1\u0060 in \u0060cluster-1\u0060 to 0:\n\n\u0060\u0060\u0060bash\nkubectl -n helloworld scale deploy helloworld-v1 --context=cluster-1 --replicas 0\n\u0060\u0060\u0060\n\nAccess the \u0060helloworld\u0060 service again from \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060.\n\nNow, directly delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl delete service helloworld -n helloworld --context=cluster-1\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060, indicating that cross-cluster failover is effective.\n\nThe diagram below shows the traffic path for this scenario.\n\n![East-West Traffic Federation: Failover](east-west-traffic-federation-between-clusters-failover.svg)\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the address and port 15443 of the East-West Gateway in \u0060cluster-2\u0060.\n\n### North-South Traffic Federation: Accessing Services via Remote Ingress Gateway\n\nAccessing services in a remote cluster through the ingress gateway is the most traditional way of cross-cluster access. The diagram below shows the traffic path for this scenario.\n\n![North-South Traffic Federation: Accessing Services via Remote Ingress Gateway](north-south-traffic-federation-between-clusters.svg)\n\nExecute the following command to create a Gateway and VirtualService in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nkubectl apply --context=cluster-2 \\\n\t-f .\/examples\/helloworld-gateway.yaml -n helloworld\n\u0060\u0060\u0060\n\nGet the address of the ingress gateway in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nGATEWAY_URL=$(kubectl -n istio-ingress --context=cluster-2 get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\nExecute the following validation to access the service via the remote ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=\u0022${CTX_CLUSTER1}\u0022 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -s http:\/\/$GATEWAY_URL\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will receive responses from \u0060helloworld-v2\u0060.\n\n## Verifying Identity\n\nExecute the following command to obtain the certificate from the \u0060sleep\u0060 pod in the \u0060cluster-1\u0060 cluster:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config secret deployment\/sleep -o json --context=cluster-1| jq -r \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in cert-aa\n\u0060\u0060\u0060\n\nIf you see the following fields in the output message, it indicates that the identity assignment is correct:\n\n\u0060\u0060\u0060\nSubject: C=US, O=SPIFFE\n\nURI:spiffe:\/\/foo.com\/ns\/sample\/sa\/sleep\n\u0060\u0060\u0060\n\nView the identity information in SPIRE:\n\n\u0060\u0060\u0060bash\nkubectl --context=cluster-1 exec -i -t -n spire spire-server-0 -c spire-server \\\n\t-- .\/bin\/spire-server entry show -socketPath \/run\/spire\/sockets\n\n\/server.sock --spiffeID spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 9b09080d-3b67-44c2-a5b8-63c42ee03a3a\nSPIFFE ID        : spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\nParent ID        : spiffe:\/\/foo.com\/k8s-workload-registrar\/cluster-1\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:sleep\nSelector         : k8s:pod-uid:6800aca8-7627-4a30-ba30-5f9bdb5acdb2\nFederatesWith    : bar.com\nDNS name         : sleep-86bfc4d596-rgdkf\nDNS name         : sleep.sleep.svc\n\u0060\u0060\u0060\n\n## Recommendations for Production Environments\n\nFor production environments, it is recommended to use a [Unified Gateway](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway), employing a Tier-2 architecture. In the Tier-1 edge gateway, configure global traffic routing. This edge gateway will send the transcribed Istio configuration to the various ingress gateways in the Tier-2 clusters.\n\nThe diagram below shows the deployment of an Istio service mesh using SPIRE federation and a Tier2 architecture with TSB.\n\n![Deployment of a Multicluster Istio Service Mesh with SPIRE and Tier2 Architecture Using TSB](tsb-multi-cluster-architeture.svg)\n\nWe have divided these four Kubernetes clusters into Tier1 cluster (\u0060tier1\u0060) and Tier2 clusters (\u0060cp-cluster-1\u0060, \u0060cp-cluster-2\u0060, and \u0060cp-cluster-3\u0060). An Edge Gateway is installed in T1, while bookinfo and httpbin applications are installed in T2. Each cluster will have an independent trust domain, and all these clusters will form a SPIRE federation.\n\nThe diagram below shows the traffic routing for users accessing bookinfo and httpbin services through the ingress gateway.\n\n![Unified Gateway Architecture Diagram](tsb-unified-gateway.svg)\n\nYou need to create a logical abstraction layer suitable for multi-cloud above Istio. For detailed information about the unified gateway in TSB, refer to [TSB Documentation](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway#scenario-1-cluster-based-routing-with-http-path-and-header-match).\n\n## Summary\n\nThis article has detailed the key technologies and methods for implementing service identity verification, DNS resolution, and cross-cluster traffic management in an Istio multi-cloud mesh environment. By precisely configuring Istio and SPIRE federation, we have not only enhanced the system\u0027s security but also improved the efficiency and reliability of inter-service communication. Following these steps, you will be able to build a robust, scalable multi-cloud service mesh to meet the complex needs of modern applications.\n\n## References\n\n- [Deploying a Federated SPIRE Architecture - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/architecture\/federation\/readme\/)\n- [Install Multi-Primary on different networks -istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Istio SPIRE Integration - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)\n- [DNS Proxying - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)\n- [Attesting Istio workload identities with SPIFFE and SPIRE - developer.ibm.com](https:\/\/developer.ibm.com\/articles\/istio-identity-spiffe-spire\/)\n- [Expanding into New Frontiers - Smart DNS Proxying in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Managing Certificates in Istio with cert-manager and SPIRE - jimmysong.io](\/en\/blog\/cert-manager-spire-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multicluster-istio\/).*', '\/en\/blog\/seamless-cross-cluster-access-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-integrate-third-party-registry-with-istio/">How to Integrating Third-Party Service Registries with Istio?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 28, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Integrating Third-Party Service Registries with Istio?', 'This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.', '\nIstio relies on Kubernetes for service discovery, which generally means that microservices must be deployed within a Kubernetes cluster and use Kubernetes service discovery. However, many existing microservice projects still utilize third-party service registries like Consul and Eureka. This article will explore how to integrate these existing service registries with Istio.\n\n## Support for Non-Kubernetes Services in Istio\n\nOriginally, Istio supported only Kubernetes services, but over time, to accommodate a broader range of application scenarios, it began supporting third-party service registries like Consul. By introducing the Mesh Configuration Protocol (MCP), Istio was able to communicate with various service discovery backends, such as Consul, thereby managing services in non-Kubernetes environments. With the introduction of the ServiceEntry resource in version 1.1, users were able to manually add external services to Istio\u0027s service registry. By version 1.8, direct support for Consul was removed in favor of a more flexible approach through [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/), allowing the integration and management of all services, whether hosted on Kubernetes or not.\n\n## High-Level Architecture of Istio Proxy Configuration\n\nThe following diagram illustrates the high-level architecture of Istio proxy configuration, showing how configurations are ingested, transformed, and ultimately served to the Envoy proxies.\n\n\u0060\u0060\u0060mermaid \u0022Istio Proxy Configuration High-Level Architecture\u0022\ngraph TD\n    subgraph Configuration Ingestion\n        subgraph Configuration Storage\n            xcs(XDS Client) --\u003e acs(Aggregate)\n            ccs(CRD Client) --\u003e acs(Aggregate)\n            fcs(Filesystem Client) --\u003e acs(Aggregate)\n        end\n        subgraph Service Discovery\n            kc(Kube Controller) --\u003e sd(Aggregate)\n            sec(ServiceEntry Controller) --\u003e sd(Aggregate)\n        end\n    end\n    subgraph Configuration Translation\n        acs \u0026 sd --\u003e ct(Configuration Translator)\n    end\n    subgraph \u0022Configuration Service (XDS)\u0022\n        ct --\u003e xds(XDS Server)\n    end\n    xds --\u003e ep(Envoy Proxies)\n\u0060\u0060\u0060\n\n![Istio Proxy Configuration High-Level Architecture](f02f7fa551ceb4c4b9fd0419b69ca6f4.svg)\n\n### Detailed Process of Configuration Ingestion\n\n- **Configuration Storage**: Responsible for reading various types of resources and aggregating them. Includes:\n    - **XDS Client**: Reads resources via the xDS protocol.\n    - **CRD Client**: Reads resources from Kubernetes Custom Resource Definitions (CRDs).\n    - **Filesystem Client**: Reads resources from the filesystem.\n- **Service Discovery**: Aggregates service-oriented internal resources. Components used include:\n    - **Kube Controller**: Operates based on core Kubernetes types.\n    - **ServiceEntry Controller**: Operates based on Istio types.\n\n### Configuration Translation and Service\n\nAfter aggregating configurations from Configuration Storage and Service Discovery, the **Configuration Translator** translates them into a format suitable for the proxies, which are then served by the **XDS Server**. This is the final step in applying dynamic configurations to the proxies.\n\n## Synchronization of Third-Party Registries\n\nTo integrate third-party service registries, we can implement an Operator that monitors third-party service registries and pushes services in the form of ServiceEntry and WorkloadEntry resources to the Kubernetes API server. The following flowchart illustrates this synchronization process.\n\n\u0060\u0060\u0060mermaid \u0022Synchronization of Third-Party Registries Flowchart\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as Third-Party Service Registry\n    participant K8s as Kubernetes API Server\n    participant I as Istiod\n    participant EP as Envoy Proxies\n\n    O-\u003e\u003e\u002bCM: Query Service Registry\n    CM--\u003e\u003e-O: Return Service Data\n    O-\u003e\u003eO: Transform Services to ServiceEntry\n    O-\u003e\u003e\u002bK8s: Push ServiceEntry\n    K8s--\u003e\u003e-I: Update Istio Configuration\n    I-\u003e\u003eEP: Update Proxy Configuration\n    Note over EP: Envoy Proxies Receive New Configuration\n\n    loop Monitor Changes\n        O-\u003e\u003e\u002bCM: Check for Updates\n        CM--\u003e\u003e-O: Notify on Change\n        O-\u003e\u003eO: Transform Updated Services\n        O-\u003e\u003e\u002bK8s: Update ServiceEntry\n        K8s--\u003e\u003e-I: Refresh Istio Configuration\n        I-\u003e\u003eEP: Refresh Proxy Configuration\n    end\n\u0060\u0060\u0060\n\n![Synchronization of Third-Party Registries Flowchart](094c8461ff42db96a7c04d7a1b92b0d2.svg)\n\n### Steps for Synchronization of Third-Party Service Registries\n\n1. The Operator initiates a service query to the Third-Party Service Registry.\n2. The Third-Party Service Registry returns the current registered service data.\n3. The Operator transforms the service data into Istio\u0027s ServiceEntry objects.\n4. The Operator pushes the transformed ServiceEntry to the Kubernetes API Server.\n5. The Kubernetes API Server notifies Istiod of the changes.\n6. Istiod updates the configurations of the Envoy Proxies.\n7. The Operator regularly checks the Third-Party Service Registry to monitor service changes, updating the ServiceEntry and re-pushing it to the Kubernetes API Server upon detection of changes, thus completing the service synchronization.\n\n## Istio Registry Sync\n\nDeveloped by Tetrate, [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) is an extension operator that can run as an add-on for [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/). It supports the integration of non-Kubernetes service registries (such as AWS Cloud Map and Consul) with Istio. This tool provides several use cases:\n\n- **Hybrid Application Integration**: In hybrid environments, traditional applications using Consul and microservices in AWS using Cloud Map can achieve seamless service discovery through Istio Registry Sync.\n- **Dynamic Endpoint Management**: In environments where services frequently scale, Istio Registry Sync quickly reflects changes from the configured registry, ensuring accurate traffic management strategies within Istio\u0027s service mesh.\n- **Unified Monitoring and Security Posture**: By integrating services from all environments into Istio, it leverages service health metrics and a unified security protocol, such as mTLS, to ensure encrypted and authenticated communication across all services.\n\n## Conclusion\n\nThrough the methods described above, you can effectively integrate Istio with third-party service registries, whether by developing a custom Operator or using the ready-made Istio Registry Sync tool. This not only maintains the modernization of services but also ensures efficient collaboration across different environments.\n\n## References\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n\n---\n\n*This blog was initially published at [tetrate.io](LINK).*', '\/en\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-delta-xds-for-envoy/">Introduction to Envoy xDS and Configuration Distribution in Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 24, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introduction to Envoy xDS and Configuration Distribution in Istio', 'This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.', '\nIn the early stages of the Istio project, configurations were pushed to Envoy proxies using the global State of the World (SotW) method. Whenever a service changed, the global configuration had to be pushed to all sidecars, causing significant network load and performance loss on the control plane. The Istio community began developing Incremental xDS a few years ago to address this issue and has supported Incremental xDS in recent Istio versions. In the recent [Istio 1.22 release](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/), Incremental xDS has become the default feature. This article will introduce you to xDS, Incremental xDS, and the method of configuration distribution in Istio.\n\n## What is xDS?\n\nxDS (Extensible Discovery Service) is a communication protocol used for managing service discovery and dynamic configuration in a microservices architecture. This mechanism is widely used in Envoy proxies and Istio service meshes to manage various types of resource configurations, such as routing, service discovery, load balancing settings, etc.\n\n### What discovery services are included in xDS?\n\nxDS includes the following main discovery services, each responsible for different types of network resource configurations:\n\n1. **LDS (Listener Discovery Service)**: Manages the configuration of Envoy listeners, which define how to receive and handle inbound connections.\n2. **RDS (Route Discovery Service)**: Provides routing information, defining how to route requests to different services based on specified rules.\n3. **CDS (Cluster Discovery Service)**: Manages cluster information, where a cluster represents a group of logically similar backend service instances.\n4. **EDS (Endpoint Discovery Service)**: Provides the network addresses of specific service instances that make up the clusters defined in CDS.\n5. **SDS (Secret Discovery Service)**: Manages security-related configurations, such as TLS certificates and private keys.\n6. **VHDS (Virtual Host Discovery Service)**: Provides virtual host configurations for RDS, allowing dynamic updates of virtual hosts without restarting connections.\n7. **SRDS (Scoped Route Discovery Service)**: Manages routing scopes, providing dynamic route selection based on different conditions (such as request headers).\n8. **RTDS (Runtime Discovery Service)**: Provides runtime configurations, which can be used for experimental features or fine-tuning system behavior.\n9. **ECDS (Extension Config Discovery Service)**: Supports dynamic configuration updates for a specific filter. Currently, ECDS is supported for network filters, HTTP filters and Listener filters. \n\nThese services collectively support the distribution and update of dynamic configurations, enabling Envoy-based application architectures to adapt in real-time to changes, enhancing scalability and flexibility. Each service can be implemented independently or managed collectively through an aggregated approach (such as ADS). CNCF has also established an [xDS API working group](https:\/\/github.com\/cncf\/xds) to promote the xDS API as the de facto standard for L4\/L7 data plane configuration, similar to the role OpenFlow plays in L2\/L3\/L4 in SDN.\n\n{{\u003ccallout note Tip\u003e}}\nFor a detailed introduction to the xDS protocol, such as xDS RPC services and variant methods, as well as the xDS request process, please refer to the [Envoy proxy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol).\n{{\u003c\/callout\u003e}}\n\n### Variants of the xDS Protocol\n\nThe xDS protocol primarily includes the following variants:\n1. **State of the World (SotW)**: A separate gRPC stream provides complete data for each type of resource, typically used during the initial startup of an Envoy proxy, and was the first type of xDS protocol used by Istio.\n2. **Incremental xDS (Delta xDS)**: Provides only the changed parts of the data for each type of resource, developed starting in 2021 and enabled by default in the Istio 1.22 version.\n3. **Aggregated Discovery Service (ADS)**: A single gRPC stream aggregates all types of resource data.\n4. **Incremental ADS (Delta ADS)**: A single gRPC stream aggregates all types of incremental data.\n\nThe table below summarizes the four variants of the xDS protocol, including explanations, usage scenarios, and a comparison of their advantages and disadvantages. These variants provide multiple options for different network environments and service needs, allowing you to choose the most suitable protocol variant to optimize service performance and resource use.\n\n{{\u003ctable \u0022Introduction to the four variants of the xDS protocol\u0022\u003e}}\n| Variant Type  | Explanation                                                 | Usage Scenario                                               | Advantages                                                | Disadvantages                                              |\n| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW          | Sends all configuration data each time, regardless of changes. | Suitable for stable environments with little configuration change. | Simple to implement, easy to understand and maintain.     | Large data transmission, not suitable for environments with frequent configuration updates. |\n| Delta xDS     | Transmits only changed configuration data, not all data.     | Suitable for environments with frequent changes needing quick response to updates. | Reduces unnecessary data transmission, increasing efficiency. | Complex implementation, requires client and server to manage configuration states. |\n| ADS           | Manages all configuration data through a single gRPC stream, eliminating the need for separate connections for each resource type. | Suitable for complex service architectures that need to manage multiple types of resources simultaneously. | Reduces the number of network connections, simplifying resource management. | In cases of poor network or service quality, a single point of failure could cause all configuration updates to fail. |\n| Delta ADS     | Combines the advantages of ADS and Incremental xDS, aggregating and transmitting only changes in resources through a single gRPC stream. | Suitable for highly dynamic environments that need to manage multiple types of resources and require frequent updates. | Provides maximum flexibility and efficiency, suitable for large-scale and highly dynamic service architectures. | Most complex implementation, high requirements for managing configuration logic and precise control over resource changes and transmission. |\n\n{{\u003c\/table\u003e}}\n\nService meshes using the xDS protocol can more flexibly manage communication and configurations between microservices, reducing the latency of configuration changes and improving system response speed and reliability.\n\nIn Istio, the DiscoveryServer acts as the implementation of Envoy\u0027s xDS API, responsible for listening to the gRPC interface and dynamically pushing configurations according to Envoy\u0027s needs. It can handle requests for various resource types and update Envoy configurations in real-time based on service changes. Additionally, it supports security features, such as verifying client certificates, ensuring only legitimate service instances can receive configuration data.\n\n### Configuration Examples for xDS Variants\n\nConfiguring xDS variants typically involves specifying the xDS server details in the configuration of the Envoy proxy or a similar service mesh. While the configuration details of different service meshes and proxy servers may vary, here are some common YAML configuration examples that illustrate how to specify xDS servers and how to use these protocol variants.\n\n#### State of the World (SotW)\n\nIn Envoy\u0027s configuration, you can use SotW either through static resources or by dynamically obtaining resources via API. Here\u0027s a simple Envoy configuration example showing how to statically define clusters and listeners:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n#### Incremental xDS\n\nIncremental xDS configuration requires the xDS server to support the incremental protocol, and the client configuration must specify the use of Incremental xDS. The Envoy startup configuration needs to add an API version to enable Incremental xDS:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Aggregated Discovery Service (ADS) \n\nWhen using ADS, the configuration of all resource types is aggregated through a single API endpoint. This is specified in the Envoy configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Incremental ADS\n\nIncremental ADS achieves more fine-grained updates by specifying the incremental API type in the ADS configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\nThese configuration examples need to be adjusted according to your specific environment and requirements. For more details and advanced configurations, you can refer to the [Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype).\n\n## How Does Istio Send Configurations to Envoy Sidecars?\n\nThanks to the xDS protocol, tools like Istio and Envoy Gateway can dynamically distribute configurations to Envoy proxies via API. The diagram below shows the configuration distribution process in Istio (Sidecar mode).\n\n\u0060\u0060\u0060mermaid \u0022Istio Configuration Distribution Process Diagram\u0022\nflowchart TB\n    Declarative_Configuration[Declarative Configuration] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio Configuration Distribution Process Diagram](f78ce8f5c5eb02d32a733e923a83fa5d.svg)\n\nThe main steps of the configuration distribution process in Istio are:\n\n1. **Declarative Configuration**: Users define the service mesh\u0027s configuration using YAML files or other configuration management tools. These configurations can include routing rules, security policies, telemetry settings, etc.\n2. **Kubernetes**: Istio configuration files are submitted to the Kubernetes cluster, usually through the \u0060kubectl apply\u0060 command or other CI\/CD tools. Kubernetes receives the configuration files and stores them in the etcd database.\n3. **Istiod**: Istiod is the control plane component of Istio, responsible for managing and distributing configurations. It listens for events coming from the Kubernetes API server, obtains relevant configuration changes, and processes them. Istiod parses the configuration files, generates corresponding routing rules and policies, and distributes these configurations to the data plane (Envoy proxies) via the xDS API.\n4. **xDS API**: Istiod uses the xDS API to send configurations to each Envoy proxy.\n5. **Envoy Proxy**: Envoy is the data plane component of Istio, running in a sidecar container alongside each service, intercepting and managing all inbound and outbound traffic. Envoy proxies receive configurations from Istiod via the xDS API and manage traffic, enforce policies, and collect telemetry data based on these configurations.\n6. **Pod**: Each service instance runs in a Pod, which contains an application container and an Envoy proxy container. The Envoy proxy intercepts all network traffic to and from the application container and processes it according to the configurations.\n\nThis configuration distribution process ensures that Istio can dynamically manage and configure all service instances in the service mesh, providing consistent traffic management and policy enforcement.\n\n## The Evolution of xDS and the Implementation of Delta xDS in Istio\n\nInitially, xDS adopted a \u0022global state\u0022 (State of the World, abbreviated as SotW) design, which meant that any configuration change required sending the complete state of all configurations to Envoy. This approach created a huge burden on the network and control plane, especially in large-scale service deployments.\n\nAt EnvoyCon 2021, Aditya Prerepa and John Howard shared How Istio Implements Delta xDS, an incremental implementation of xDS. Compared to the traditional SotW xDS, Delta xDS sends only the changed configurations, significantly reducing the amount of configuration data that needs to be sent over the network, thus improving efficiency and performance. This method is particularly suitable for environments where configurations change frequently, as it updates only the changed parts rather than the entire configuration.\n\nDuring the implementation of Delta xDS, the Istio\n\n team faced several challenges, including ensuring the correctness of configuration updates and avoiding potential resource leaks. They addressed these challenges by adopting a Dry-run mode to run the SotW and Delta generators in parallel, gradually identifying and fixing flaws in the implementation. Additionally, they introduced new Envoy types, such as the Virtual Host Discovery Service, to support more fine-grained configuration distribution.\n\n### Delta xDS Incremental Configuration\n\nThe diagram below illustrates the process of Delta xDS incremental configuration.\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS Incremental Configuration Process Diagram\u0022\nsequenceDiagram\n    participant CP as Control Plane\n    participant P as Proxy\n    CP-\u003e\u003eP: Initial Complete Configuration\n    P-\u003e\u003eCP: Subscribe to Configuration Changes\n    Note over CP,P: Any Configuration Change Occurs\n    CP-\u003e\u003eP: Check Configuration Changes\n    CP-\u003e\u003eP: Calculate Differences\n    CP-\u003e\u003eP: Send Only Differences\n    Note over P: Proxy Uses Differences for Updates\n\u0060\u0060\u0060\n\n![Delta xDS Incremental Configuration Process Diagram](9a1fc2d6009beb68cf596e0f077881ec.svg)\n\nThe Delta xDS configuration process is as follows:\n\n1. **Initial Complete Configuration**: The control plane sends the initial complete configuration to the proxy, using the StoW mode at this time.\n2. **Subscribe to Configuration Changes**: The proxy subscribes to configuration changes from the control plane.\n4. **Check Configuration Changes**: The control plane checks for configuration changes relative to the proxy\u0027s known state.\n5. **Calculate Differences**: The control plane calculates the differences (increments) between the current configuration and the previous configuration held by the proxy.\n6. **Send Only Differences**: The control plane sends only the changed configuration (differences) to the proxy, which applies these incremental updates to its configuration.\n\nThis process ensures that only necessary changes are transmitted and applied, improving efficiency and reducing the load on network and proxy resources.\n\n### SotW vs Delta xDS\n\nWhile Delta xDS solves the performance issues of configuration distribution in large-scale networks, the SotW mode still has its place, such as in the initial configuration delivery. The table below compares the two configuration distribution methods in Istio: SotW (State of the World) and Delta xDS.\n\n{{\u003ctable \u0022Comparison of Global State and Incremental xDS Configuration Distribution Methods in Istio\u0022\u003e}}\n| Comparison Item   | SotW                                                        | Delta XDS                                   |\n| ----------------- | ----------------------------------------------------------- | ------------------------------------------- |\n| **Data Volume**   | Transmits complete configuration data each time, regardless of whether there are changes. | Transmits only the changed configuration data, reducing data volume. |\n| **Efficiency**    | Acceptable efficiency in small or less changing environments. | Higher efficiency in large or frequently changing environments. |\n| **Complexity**    | Simple implementation, easy to understand and maintain.     | More complex implementation, requires fine tracking and management of changes. |\n| **Resource Usage** | May increase server and network load due to repeatedly sending large amounts of unchanged data. | Lower resource usage, as only changed parts are handled. |\n| **Timeliness**    | High immediacy as full configuration is sent immediately after updates. | Faster response by sending only changed parts, reducing processing time. |\n| **Applicability** | Suitable for small to medium deployments with infrequent configuration changes. | Suitable for environments with frequent configuration changes or large-scale deployments. |\n{{\u003c\/table\u003e}}\n\nThis table compares SotW and Delta XDS from multiple perspectives, including data volume, efficiency, complexity, resource usage, timeliness, and applicability, helping you make the appropriate choice in different usage environments.\n\n## Conclusion\n\nIn this article, I shared the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS. With Delta xDS becoming the default configuration in Istio version 1.22, this will help users easily use Istio in large-scale network environments.\n\n## References\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-delta-xds\/).', '\/en\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-22/">Deep Dive into Istio 1.22: New Features and Practical Application Advice</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 21, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Deep Dive into Istio 1.22: New Features and Practical Application Advice', 'Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.', '\nThe recent [release of Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) includes a plethora of significant updates. This article shares the new features and application recommendations brought by this release.\n\n## Ambient Mode Enters Beta Phase\n\nAlthough Ambient mode has now entered the Beta phase, this does not mean we can completely do away with Sidecars. While the Istio official claims that Ambient mode simplifies operations and significantly reduces memory and CPU usage, it still has limitations and potential complexity issues. For example, while Sidecars are eliminated, the introduction of new ztunnel and waypoint components may pose new challenges. For more detailed information about Ambient mode entering Beta, refer to the [Istio official blog](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/).\n\n**Challenges Introduced by Ambient Mode**\n\n- Management of L7 traffic in Ambient mode is not yet mature\n- mTLS is forced to be enabled at the namespace level, meaning you cannot disable mTLS in Ambient mode\n- Zero-downtime upgrades in Ambient mode have not been resolved\n- Lack of best practices for coexistence and migration from Sidecar mode\n\nFor a comparison of Sidecar mode and Ambient mode, see [Analysis of Limitations in Istio Ambient Mode](\/blog\/istio-ambient-mode-limitations\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nIf you are just starting with Istio, especially if you only need to automatically enable mTLS for services, you can consider using Ambient mode at this stage. However, for L7 functionalities, it is recommended to wait until Ambient mode is fully mature before considering it for production use.\n{{\u003c\/callout\u003e}}\n\n## Istio API Upgrades\n\nIn the Istio 1.22 release, key APIs related to traffic management, security, and telemetry have officially been upgraded to the \u0060v1\u0060 version. You only need to change the API version of your existing configuration to \u0060v1\u0060, with no other changes needed. These APIs are already mature, and you can safely use the \u0060v1\u0060 version. For environments requiring high stability, Istio has added [validating admission policies](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/) to ensure that only \u0060v1\u0060 APIs and fields can be used in the Istio API.\n\nFor example, the following AuthorizationPolicy example.\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\nOther extension-type APIs such as \u0060EnvoyFilter\u0060, \u0060WasmPlugin\u0060, \u0060ProxyConfig\u0060 are still in alpha or beta stages. For more information on API upgrades, please refer to the [v1 API blog](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor commonly used functionalities, you can confidently use the \u0060v1\u0060 API. For extension-type APIs that are not yet stable, enabling validating admission policies is recommended to ensure system stability.\n{{\u003c\/callout\u003e}}\n\n## Gateway API Upgrade\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) has been updated to version 1.1.0 and is now widely available. This update extends Istio\u0027s traffic management capabilities, but it is important to be cautious of compatibility issues between Istio\u0027s native APIs and the Gateway API when migrating to the new API to avoid relying on features that are not fully mature yet. For more details, check out the [Gateway API v1.1 blog](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor existing deployments that are already stable using Istio API, continue using them, especially in scenarios requiring advanced features. For new deployments, consider using the stable version of the Gateway API to take advantage of its modern traffic management capabilities. Due to existing compatibility issues, do not rashly migrate to the Gateway API, as it may not be worth the risk.\n{{\u003c\/ callout\u003e}}\n\n## Delta xDS Enabled by Default\n\nIstio 1.22 version now has delta xDS enabled by default, which is a mechanism to optimize configuration distribution. Compared to the traditional State of the World (SotW) mode, delta xDS only sends changed configurations to the Envoy proxies, thereby significantly reducing the amount of data transmitted over the network and the resource consumption of the control plane. This change is particularly suitable for large-scale deployment environments with frequent configuration updates, improving the efficiency and performance of configuration updates. Additionally, delta xDS also helps manage configuration updates more efficiently in complex network environments or dynamically changing configurations.\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nThe delta xDS has been developed several versions ago but was not enabled by default. Now that this feature is stable, you can use it with confidence.\n{{\u003c\/callout\u003e}}\n\nFor more on xDS, refer to the [Introduction to Envoy xDS and Configuration Distribution Process in Istio](\/blog\/istio-delta-xds-for-envoy\/).\n\n### Path Template Support with Wildcards for AuthorizationPolicy\n\nIn Istio 1.22, \u0060AuthorizationPolicy\u0060 has added support for [path templates](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation), greatly enhancing the flexibility and precision of path matching. Prior to this, \u0060AuthorizationPolicy\u0060 did not support wildcards in path configurations. This feature allows for defining paths in HTTP requests using URI templates based on Envoy, including simple wildcards (\u0060*\u0060 and \u0060**\u0060) or named variables, enabling precise matching of single or multiple path components. For example, the path template \u0060\/foo\/{*}\u0060 can match \u0060\/foo\/bar\u0060 but not \u0060\/foo\/bar\/baz\u0060, while \u0060\/foo\/{**}\/\u0060 can match any path starting with \u0060\/foo\/\u0060. This flexible path template design is particularly suitable for dynamic and complex routing rules, further strengthening Istio\u0027s security policy toolbox.\n\nThe diagram below illustrates the wildcard rules for path matching in AuthorizationPolicy.\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy Path Matching Wildcard Rules\u0022\ngraph LR\n    A[AuthorizationPolicy Path Matching] --\u003e B(Define Path Templates)\n    B --\u003e C{Path Template Operators}\n    C --\u003e D[\u0022* (Match single segment)\u0022]\n    C --\u003e E[\u0022** (Match multiple segments)\u0022]\n    C --\u003e F[\u0022{name} (Named variable matching one segment)\u0022]\n    C --\u003e G[\u0022{name=**} (Named variable matching multiple segments)\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} matches \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ matches \/foo\/bar\/, \/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} matches \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd matches \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy Path Matching Wildcard Rules](dfe9a5d5e2bc91e91e7e24017f56a3db.svg)\n\nFor more on the specific applications and rules of path templates, you can refer to [Envoy\u0027s official documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto).\n\n{{\u003c callout note \u0022Tip\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 finally supports templates in path matching, so you no longer need to manually add paths one by one in your configurations.\n{{\u003c\/callout\u003e}}\n\n## Summary\n\nThe Istio 1.22 release introduces several important updates and improvements. Although some features are widely publicized, they require detailed assessment and appropriate testing in practical use. Hopefully, this blog post helps you understand and apply these new features more deeply to achieve the best results in practice.\n\n## References\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-new-features-v1_22\/).', '\/en\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-cni-deep-dive/">Istio CNI Unveiled: Streamlining Service Mesh Connectivity</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio CNI Unveiled: Streamlining Service Mesh Connectivity', 'This article provides a detailed explanation of the design principles, implementation methods, and how to enhance security and permission management through Ambient Mode in the Istio CNI plugin.', '\nThis article delves into the design principles, implementation, and how Ambient Mode enhances security and permission management in Istio CNI plugins. The content includes:\n\n- Security risks of Init containers and their solutions.\n- Working principles and advantages of Istio CNI.\n- Implementation mechanism of Ambient Mode and its integration with CNI.\n\n## Overview of Istio Network Requirements and Solutions\n\nIstio service mesh intercepts and manages application traffic through the Sidecar mode. This mode injects a Sidecar Proxy and init containers into application pods and uses iptables rules to manage network traffic. For detailed deployment and operation processes, please refer to [Understanding Sidecar Injection, Transparent Traffic Hijacking, and Traffic Routing in Istio](\/en\/blog\/sidecar-injection-iptables-and-traffic-routing\/). Although this method is effective on most Kubernetes platforms, the high dependency on privileges raises security concerns in multi-tenant environments.\n\n### Limitations of Istio-init\n\nDuring its initial network configuration, Istio adopted the \u0060istio-init\u0060 container to initialize traffic interception rules, requiring containers to have advanced permissions to modify network configurations like IPTables rules. While this method effectively manages traffic, it significantly increases permission requirements and security risks. According to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/), the \u0060istio-init\u0060 container is injected into pods within the Istio mesh by default to hijack network traffic to Istio\u0027s Sidecar proxy. This process requires granting the Service Account deploying the pod the [\u0060NET_ADMIN\u0060 container permission](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/security-context\/#set-capabilities-for-a-container), which may contradict the security policies of some organizations.\n\n### Istio CNI Plugin\n\nIn response to this challenge, the Istio community introduced the [Istio CNI](https:\/\/github.com\/istio\/istio\/tree\/master\/cni) plugin, which avoids the need for init containers, allowing direct manipulation at the Kubernetes network layer, thereby reducing permission requirements and simplifying the deployment process, but with CNI compatibility issues.\n\n### Introduction of Ambient Mode\n\nIstio\u0027s Ambient Mode is an innovative sidecar-less solution that enhances network flexibility and security by [using Geneve tunnels](\/en\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/) or Istio CNI.\n\nOnly recently has the Istio community introduced a [universal solution compatible with any CNI](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/). This mode addresses compatibility issues with any CNI, enabling Istio to more effectively manage traffic between services without affecting existing network policies.\n\n## Security Considerations for NET_ADMIN Permissions\n\nIn containerized environments like Kubernetes and Docker, \u0060NET_ADMIN\u0060 permissions allow processes within containers to perform extensive network-related operations, including modifying iptables rules, changing network interface configurations, managing IP routing tables, and controlling kernel parameters related to networking. However, the use of these permissions raises security concerns, especially regarding overprivileged access and potential attack surfaces.\n\n**Best practices include**:\n\n- **Limiting scope of use**: Grant \u0060NET_ADMIN\u0060 permissions only when necessary and restrict them through Kubernetes network policies.\n- **Continuous monitoring and auditing**: Enforce strict logging and monitoring for containers using \u0060NET_ADMIN\u0060 permissions.\n\n## Working Principles of Istio CNI Plugin\n\nThe Istio CNI plugin is a binary file installed as an agent in the file system of each node. The following flowchart illustrates the working principles of the Istio CNI node agent:\n\n\u0060\u0060\u0060mermaid\nflowchart TB\n    subgraph istio_cni_node_agent[Istio CNI Node Agent]\n        direction LR\n        install_plugin[Install Istio CNI plugin]\n        update_config[Update node CNI config at \/etc\n\n\/cni\/net.d]\n        monitor_paths[Monitor plugin and config paths]\n        \n        subgraph sidecar_mode[\u0022Sidecar Mode\u0022]\n            sidecar_setup[Configure iptables for pods]\n        end\n        \n        subgraph ambient_mode[\u0022Ambient Mode\u0022]\n            ambient_server[Ambient Watch Server]\n            sync_events[Synchronize pod events]\n            configure_iptables[Configure iptables within pods]\n        end\n\n        install_plugin --\u003e update_config\n        update_config --\u003e monitor_paths\n        monitor_paths --\u003e sidecar_mode\n        monitor_paths --\u003e ambient_mode\n        ambient_mode --\u003e ambient_server\n        ambient_server --\u003e sync_events\n        sync_events --\u003e configure_iptables\n    end\n\u0060\u0060\u0060\n\n![Mermaid Diagram](f9aacefbdd8fb77216546b53eda78079.svg)\n\n- **Istio CNI Node Agent** acts as an agent installed on each node.\n- It installs the Istio CNI plugin and updates the node’s CNI configuration.\n- The agent monitors the CNI plugin and config paths for changes.\n- In **Sidecar Mode**, it handles sidecar networking setups using iptables for pods.\n- In **Ambient Mode**, it synchronizes pod events to an ambient watch server, which then configures iptables within pods.\n- Nodes require elevated privileges like \u0060CAP_SYS_ADMIN\u0060, \u0060CAP_NET_ADMIN\u0060, and \u0060CAP_NET_RAW\u0060 to function in either mode.\n\n## Resolving Conflicts Between Istio Ambient Mode and Kubernetes CNI\n\nIstio\u0027s Ambient Mode is designed to adapt to all CNIs, transparently handling traffic redirection within pods using ztunnel without affecting existing CNI configurations. In this mode, Ambient Mode manages traffic through ztunnel to flow through the Istio service mesh, while standard CNIs focus on providing standardized network access for pods.\n\nThe primary responsibilities of CNI are to address network connectivity between Kubernetes Pods, such as assigning IP addresses and forwarding packets. In contrast, Ambient Mode needs to import traffic into ztunnel, which may be incompatible with CNI\u0027s network configuration. The main issues include:\n\n- Mainstream CNI network configurations may conflict with Istio\u0027s CNI extensions, causing interruptions in traffic processing.\n- Using Istio CNI may affect the execution of these policies if the deployed network policies depend on CNI.\n\nTo address these issues, traffic redirection is managed by running ztunnel in the same user space as the pod, avoiding conflicts with the kernel space modified by CNI. Thus, pods can connect directly to ztunnel, bypassing the influence of CNI.\n\nThe following sequence diagram describes the process under Ambient mode:\n\n\u0060\u0060\u0060mermaid\nsequenceDiagram\n    participant K8s_API as Kubernetes API\n    participant Plugin as CNI Plugin\n    participant Agent as Ambient CNI Agent\n    participant Server as Ambient Watch Server\n    participant Ztunnel as ztunnel\n\n    Plugin-\u003e\u003eAgent: CmdAdd (Pod scheduled)\n    Agent-\u003e\u003eServer: Notify new pod\n    Server-\u003e\u003eK8s_API: Retrieve Pod Info\n    K8s_API--\u003e\u003eServer: Pod Details\n    Server-\u003e\u003eZtunnel: Setup iptables\n    Ztunnel-\u003e\u003eServer: Confirm Setup\n    Server-\u003e\u003eAgent: Configuration Complete\n    Agent-\u003e\u003ePlugin: CmdDel (Pod removed)\n    Server-\u003e\u003eZtunnel: Remove iptables\n    Ztunnel--\u003e\u003eServer: Confirmation\n\u0060\u0060\u0060\n\n![Mermaid Diagram](aa0472b4061c1a2ca71146c3243d2318.svg)\n\n- **Ambient CNI Agent** initiates interactions by listening for UDS events signaling pod creations.\n- **Ambient Watch Server** modifies iptables within pods to redirect traffic to ztunnel as needed.\n\n- **ztunnel** establishes connections and handles network traffic redirection within the Kubernetes cluster.\n\n## Resolving Conflicts Between Istio Ambient Mode and Kubernetes CNI\n\nTo mitigate these conflicts, Istio\u0027s Ambient Mode avoids dependencies on the kernel space modified by CNI:\n\n- **Run ztunnel in user space**: This strategy allows ztunnel to run in the same user space as the pod, avoiding direct conflicts with CNI.\n- **Ensure CNI compatibility**: Istio CNI configurations must be carried out without affecting existing CNI plugin configurations, ensuring normal communication between pods and traffic management.\n\nThese measures help Istio\u0027s Ambient Mode effectively manage traffic between services without disrupting existing CNI plugins.\n\n## Optimized Traffic Management with Istio Ambient Mode\n\nIstio\u0027s Ambient Mode employs an advanced traffic forwarding mechanism through **node-local Ztunnel**, allowing for the establishment of listening sockets within a Pod\u0027s network namespace. This setup facilitates effective redirection of encrypted (mTLS) and plaintext traffic originating from the service mesh. Not only does this approach enhance the flexibility of traffic management, but it also prevents potential conflicts with existing CNI plugins. Below is a detailed implementation flow of this mode:\n\n\u0060\u0060\u0060mermaid\ngraph TD\n    subgraph Kubernetes Cluster\n    A[Pod with istio.io\/dataplane-mode=ambient] --\u003e|Detected| B(istio-cni node agent)\n    B --\u003e C{Pod Status}\n    C --\u003e|Newly Started| D[CNI Plugin Triggered]\n    C --\u003e|Already Running| E[New Pod Event]\n    D \u0026 E --\u003e F[Configure Redirection]\n    F --\u003e|Enters Pod\u0027s Network Namespace| G[Establish Network Redirection]\n    G --\u003e H[Notify Node Ztunnel]\n    H --\u003e|Creates Listening Sockets in Pod\u0027s Namespace| I[Node-local Ztunnel Proxy Instance]\n    I --\u003e J[Traffic Redirection Established]\n    end\n\n    J --\u003e K{Traffic Type}\n    K --\u003e|mTLS| L[Encrypted Traffic Within Mesh]\n    K --\u003e|Plaintext| M[Handling Plaintext Traffic]\n\u0060\u0060\u0060\n\n![Mermaid Diagram](82841d7a95a98947c4ec6c7113c2ffb0.svg)\n\nThe specific steps involved are as follows:\n\n1. **Detection of Tags**: The Istio CNI node agent detects Pods tagged with \u0060istio.io\/dataplane-mode=ambient\u0060.\n2. **Triggering the CNI Plugin**: Based on Pod events (either a new start or an existing Pod joining the mesh), the CNI plugin is triggered, leading the Istio CNI node agent to configure traffic redirection.\n3. **Configuring Redirection Rules**: Network redirection rules are set up within the Pod’s network namespace to intercept and redirect traffic to the node-local ztunnel proxy.\n4. **Establishment of Listening Sockets**: The node-local ztunnel creates listening sockets within the Pod\u0027s network namespace to enable traffic redirection.\n5. **Traffic Handling**: The node-local ztunnel handles encrypted (mTLS) and plaintext traffic within the mesh, ensuring secure and efficient data transfer.\n\nThrough this approach, Istio Ambient Mode provides a more effective and secure solution for managing inter-service traffic in Kubernetes environments.\n\n## Conclusion\n\nThis article thoroughly analyzes the design principles, implementation, and advantages of the Istio CNI plugin, particularly how Istio CNI addresses the permission and security issues present in traditional \u0060istio-init\u0060 methods. Through these innovations, Istio has made significant progress in network security and operational simplicity, providing a more flexible and efficient method for implementing Istio in Kubernetes environments.\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-cni-unveiled-streamlining-service-mesh-connectivity\/) .*\n', '\/en\/blog\/istio-cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed explanation of the design principles, implementation methods, and how to enhance security and permission management through Ambient Mode in the Istio CNI plugin.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/istio/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/istio/page/6/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(44)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(11)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-configuration-safety-common-misconfigurations/">Istio Configuration Security: How to Avoid Misconfigurations</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/kubecon-china-2024-recap/">KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
