<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Istio - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/istio/" />
  <meta property="og:title" content="Istio | Jimmy Song" />
  <meta property="twitter:title" content="Istio | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/istio/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Istio
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/securing-istio-addressing-critical-security-gaps-and-best-practices/">Securing Istio: Addressing Critical Security Gaps and Best Practices</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 10, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Securing Istio: Addressing Critical Security Gaps and Best Practices', 'Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.', '\n## Introduction\n\nRecently, the Wiz research team released a [blog post](https:\/\/www.wiz.io\/blog\/sapwned-sap-ai-vulnerabilities-ai-security) that uncovered tenant isolation vulnerabilities in AI services, generating widespread attention. This study detailed security flaws across several AI service providers, particularly the SAP AI Core platform. Researchers were able to execute arbitrary code through legitimate AI training processes, subsequently moving laterally to take over services and gain access to customers’ private files and cloud credentials. These findings highlight the challenges that cloud services and management platforms face in ensuring isolation and sandbox environments.\n\nIn this context, Istio, as a crucial service mesh solution, faces similar security issues, especially in key functionalities like sidecar injection and traffic management. This blog aims to discuss how to protect the security of the Istio service mesh and provide a comprehensive set of mitigation measures. We will also discuss how multi-layer security strategies can effectively enhance Istio\u0027s security to address challenges mentioned in the Wiz report.\n\n## Overview\n\nIstio primarily manages east-west traffic within Kubernetes, offering detailed traffic management features such as request routing, load balancing, and fault recovery policies. While Istio offers essential security features such as traffic encryption, authentication, and authorization, it should not be viewed as a standalone firewall solution. To maintain robust security for services within the Istio mesh, it is crucial to complement Istio\u0027s security capabilities with additional measures from the underlying network and infrastructure, such as Container Network Interface (CNI) plugins and secure container implementations.\n\nWhether in Sidecar or Ambient mode, traffic is hijacked from application pods to data plane proxies for processing and forwarding. If application traffic is not successfully intercepted or is impersonated by a rogue application masquerading as Istio, security vulnerabilities can arise.\n\nThe diagram below illustrates where security vulnerabilities due to bypassing or impersonating Istio system users might occur.\n\n![\u0022Security vulnerabilities\u0022 in bypassing Istio\u0027s traffic hijacking](bypass-sidecar-traffic-hijack.svg)\n\nNext, we will explore specific situations where \u0022security vulnerabilities\u0022 arise and the strategies to address them.\n\n## Bypassing Istio Sidecar Injection\n\n### At the Namespace Level\n\n- **Scenario**: Application teams misuse namespace labels to disable Istio Sidecar injection at the namespace level.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes namespace resources.\n- **Monitoring**: Use policy engines (like OPA Gatekeeper) to ensure compliance with namespace labels, and regularly review namespace configurations.\n\n### At the Pod Level\n\n- **Scenario**: Application teams misuse Pod labels to disable Istio Sidecar injection at the Pod level.\n- **Mitigation Strategy**:\n  - Force all Pods to specify a UID that is not 1337.\n  - Inspect all container images to check for UID 1337 and reject those images. This inspection can be performed using an admission webhook or by a central team managing the image registry.\n- **Monitoring**: Employ Admission Webhooks to enforce Sidecar injection, prohibit exclusion labels, and regularly scan and audit all pods to ensure every required pod has a Sidecar injected.\n\n## Bypassing Traffic Redirection to Istio Sidecar\n\n### Misuse of Traffic Redirection Annotations\n\n- **Scenario**: Application teams misuse Pod annotations to exclude certain inbound or outbound ports or IPs, thereby bypassing traffic redirection.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Use policy engines to detect and alert on non-compliant annotation use, regularly review Pod annotations.\n\n### Misuse of Pod UID\n\n- **Scenario**: Application teams misuse UID 1337 (the ID of the sidecar proxy) to bypass Istio\u0027s Iptables redirection rules.\n- **Mitigation Strategy**: Platform teams abstract app deployment and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Prohibit or restrict the use of UID 1337, regularly audit Pod UID configurations to ensure no bypassing occurs.\n\n### Misuse of Pod Capabilities (NET_ADMIN, NET_RAW)\n\n- **Scenario**: Application teams misuse NET_ADMIN and NET_RAW capabilities to remove Istio Iptables rules.\n- **Mitigation Strategy**: Platform teams enable Istio CNI (to avoid granting elevated privileges to application teams) and restrict access to the raw Kubernetes Pod resources.\n- **Monitoring**: Regularly review and monitor Pod permission configurations to ensure no over-privileged actions are taken.\n\n## Bypassing Inbound Traffic Constraints\n\n### Misuse of PeerAuthentication\n\n- **Scenario**: Application teams create a PeerAuthentication resource for each namespace\/workload, enabling the PERMISSIVE authentication mode.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio PeerAuthentication resources.\n- **Monitoring**: Regularly review PeerAuthentication configurations to ensure all inbound traffic is encrypted as required.\n\n## Bypassing Outbound Traffic Constraints\n\n### Misuse of ServiceEntry\n\n- **Scenario**: Application teams create a ServiceEntry to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio ServiceEntry resources.\n- **Monitoring**: Regularly review ServiceEntry configurations to ensure no bypassing occurs.\n\n### Misuse of ExternalName Services\n\n- **Scenario**: Application teams create a Kubernetes Service of type ExternalName to directly access external services without going through an Egress gateway.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Kubernetes Service resources.\n- **Monitoring**: Regularly review the types of Kubernetes Service configurations to ensure no bypassing occurs.\n\n## Uncontrollably Changing Istio Sidecar Configuration\n\n### Misuse of Sidecar Resources\n\n- **Scenario**: Application teams create an Istio Sidecar resource for each workload and set the \u0060outboundTrafficPolicy\u0060 field to \u0060ALLOW_ANY\u0060 (overriding the possible global value \u0060REGISTRY_ONLY\u0060).\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio Sidecar resources.\n- **Monitoring**: Regularly review Sidecar resource configurations to ensure no global settings are overridden.\n\n### Misuse of EnvoyFilter\n\n- **Scenario**: Application teams create an EnvoyFilter that conflicts with existing Istio objects, potentially causing DoS attacks or violating security policies.\n- **Mitigation Strategy**: Platform teams restrict access to the raw Istio EnvoyFilter resources.\n- **Monitoring**: Regularly review EnvoyFilter configurations to ensure no improper use occurs.\n\n## Service Mesh as Part of a Layered Defense\n\nThe service mesh is described as a supplemental layer to existing security models, enhancing microservice security by adding finer-grained security policies on top of traditional security controls. However, the article emphasizes that service meshes cannot independently ensure comprehensive security for microservices but should be part of an overall security strategy.\n\n![Microservices security layered architecture](security-layers.svg)\n\nService meshes primarily manage and control network traffic by deploying a lightweight proxy (sidecar) next to each service instance. This allows for precise traffic control and policy enforcement at the network level, such as traffic encryption, authentication, and authorization. Although service meshes offer features like traffic control, service discovery, and circuit breakers, these are essentially management of network traffic and are not sufficient to address all security issues. For instance, they cannot replace traditional security measures like application layer firewalls, intrusion detection systems, and data security.\n\nFurthermore, service meshes rely on correct configuration and management, and improper configuration can lead to security vulnerabilities. Therefore, while service meshes are an indispensable part of modern microservices architectures, they should be combined with traditional security measures to form a comprehensive, multi-layered security strategy framework. Refer to [How Service Mesh Layers Microservices Security with Traditional Security to Move Fast Safely](https:\/\/tetrate.io\/blog\/how-service-mesh-layers-microservices-security-with-traditional-security-to-move-fast-safely\/) for further insights on strengthening service mesh security.\n\n## Long-term Solutions and Community Collaboration\n\nThe Istio community conducts a security audit almost every year, see the results from [2021](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/) and [2022](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/). From these results, we can see that Istio\u0027s security posture has greatly improved. Ensure that your Istio service mesh adheres to [security best practices](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/). Additionally, keep an eye on the [Istio CVE Bulletins](https:\/\/istio.io\/latest\/news\/security\/) or use tools like [Tetrate Istio Subscription](https:\/\/tetrate.io\/tetrate-istio-subscription\/) that can scan for various CVEs in the Istio service mesh, deploying Istio versions that are FIPS compliant and FIPS certified.\n\n## Conclusion\n\nService meshes provide an additional layer of security for microservices architectures by managing control flows outside of the applications. This allows for enhanced communication security between services without impacting application performance. When deploying service meshes, it is recommended to use Istio’s Egress Gateway to manage outbound traffic, in conjunction with Kubernetes\u0027 NetworkPolicy, to ensure all outbound traffic must pass through the gateway, thus preventing potential data leaks and other security threats.\n\n## References\n\n- [How to enforce egress traffic using Istio’s authorization policies - tetrate.io](https:\/\/tetrate.io\/blog\/istio-how-to-enforce-egress-traffic-using-istios-authorization-policies\/)\n- [Istio Security Best Practice - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/)\n- [Optimize Traffic Management and Security with These Service Mesh Best Practices - tetrate.io](https:\/\/tetrate.io\/blog\/optimize-traffic-management-and-security-with-these-service-mesh-best-practices\/)\n- [Istio publishes results of 2022 security audit - istio.io](https:\/\/istio.io\/latest\/blog\/2023\/ada-logics-security-assessment\/)\n- [Announcing the results of Istio’s first security assessment - istio.io](https:\/\/istio.io\/latest\/blog\/2021\/ncc-security-assessment\/)\n', '\/en\/blog\/securing-istio-addressing-critical-security-gaps-and-best-practices\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Exploring security gaps in Istio and effective mitigation strategies, combined with best practices for multi-layered security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/gateway-api-istio-ingress-evolution/">How to Migrate from Kubernetes Ingress to the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Migrate from Kubernetes Ingress to the Gateway API', 'This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.', '\nWith the release of Istio 1.22, the Istio API has officially been upgraded to version v1, coinciding with the update of the Kubernetes Gateway API to v1.1. This article aims to explore the connections and differences between the Ingress API, Istio API, and Kubernetes Gateway API, detailing their selection and migration strategies in practical applications.\n\n## Introduction\n\nPreviously, I wrote an article discussing [Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh](\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/). The article pointed out that as Kubernetes\u0027 original ingress gateway, Ingress\u0027s resource model is too simple to meet the demands of today\u0027s programmable networks. As its successor, the Gateway API has rapidly developed in recent years and has gained broad support, including many emerging open-source gateway projects like [Envoy Gateway](https:\/\/gateway.envoyproxy.io) choosing to develop based on the Gateway API. Additionally, some legacy gateway projects have started adapting to the Gateway API or using tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway) to migrate.\n\nThe Gateway API, as the latest achievement in [Kubernetes ingress gateways](https:\/\/tetrate.io\/learn\/kubernetes\/what-is-kubernetes-ingress\/), separates concerns through role division and supports cross-namespace capabilities, making it more suitable for multi-cloud environments. It integrates the overlapping functions of ingress gateways (north-south) and service meshes (east-west, intra-cluster routing) to provide a new reference model for unified traffic management in the cloud-native era.\n\nIngress API, Gateway API, and Istio API can all implement gateway functions, but what are the connections and differences between them? This article will unveil this mystery and provide strategies for selecting and migrating gateways in Kubernetes environments.\n\n## Kubernetes Traffic Management\n\nWith the widespread adoption and increasing complexity of microservice architectures, Kubernetes\u0027 traffic management tools have also evolved to meet various technical needs. The Ingress API, Istio API, and Kubernetes Gateway API each represent different stages of this evolution.\n\n**Ingress API** offers basic traffic management capabilities in Kubernetes, allowing users to manage external access to services within the cluster through simple routing rules (e.g., HTTP and HTTPS). Although its design is straightforward, its functionality is limited and mainly suitable for smaller-scale, less complex applications.\n\nIn contrast, **Istio API**, as part of a service mesh, offers a range of advanced traffic management features, such as traffic mirroring, canary releases, and circuit breakers, suitable for large-scale microservice architectures requiring complex traffic management.\n\nTo overcome the limitations of the Ingress API and integrate advanced features similar to those of Istio, the **[Kubernetes Gateway API](https:\/\/tetrate.io\/learn\/kubernetes\/what-is-kubernetes-ingress\/)** was developed. It not only provides greater flexibility and extensibility in its design but also, through broad community support, serves as a bridge connecting traditional Ingress implementations and modern service mesh technologies like Istio, with most mainstream open-source gateways being based on or adapted to the Gateway API.\n\nThe following table summarizes the core features and recommended use cases for each API:\n\n| API Name      | Object Type                | Status                  | Recommended Use Cases                                       |\n| ------------- | -------------------------- | ----------------------- | ------------------------------------------------------------ |\n| Ingress API   | \u0060Ingress\u0060                  | Stable (Kubernetes v1.19)| Suitable for small-scale and simple scenarios, mainly for basic routing configurations |\n| Istio API     | \u0060VirtualService\u0060, \u0060Gateway\u0060| Stable (Istio 1.22)     | Suitable for highly complex microservice architectures, requiring fine-grained control and advanced traffic management features |\n| Gateway API   | \u0060HTTPRoute\u0060, \u0060Gateway\u0060     | Stable (Gateway API v1.1)| Suitable for new or existing deployments that require increased flexibility and scalability, especially when combined with Istio |\n\nThe launch of [Gateway API v1.1](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/), especially its improvements in compatibility with existing Ingress configurations, provides a smooth migration path for users, making the transition from traditional Ingress solutions to more modern, feature-rich Gateway API easier.\n\n## Migrating from Ingress to Kubernetes Gateway API\n\nTo migrate from Ingress to Gateway API, follow these steps:\n\n1. **Understand Key Differences**: Compared to Ingress, the Gateway API introduces several new concepts and resource types, such as \u0060Gateway\u0060, \u0060HTTPRoute\u0060, and \u0060TLSRoute\u0060. These resources offer more configuration options and flexibility; refer to the [Gateway API documentation](https:\/\/gateway-api.sigs.k8s.io\/guides\/) for their configurations.\n2. **Configure Entry Points**: Create \u0060Gateway\u0060 resource configurations, clearly defining how to receive external traffic, including protocols, ports, and TLS terminations.\n3. **Map Old Resources**: Map existing Ingress resources to corresponding Gateway API resources. For example, host and path rules in Ingress need to be converted into route rules in HTTPRoute.\n4. **Test and Deploy**: Before officially migrating, test the new Gateway API configurations in a test environment to ensure all traffic routing is normal and there are no security vulnerabilities.\n\nTo simplify the migration process, you can use tools like [ingress2gateway](https:\/\/github.com\/kubernetes-sigs\/ingress2gateway), which can automatically convert Ingress configurations into Gateway API formats.\n\n## Practical Migration Example\n\nHere is a simple example of an HTTP gateway configuration demonstrating how to migrate from Ingress to the Gateway API.\n\nAssume you have an existing Ingress configuration as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: example-service\n            port:\n              number: 80\n\u0060\u0060\u0060\n\nTo migrate it to the Gateway API, first create a Gateway object:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: Gateway\nmetadata:\n  name: example-gateway\nspec:\n  gatewayClassName: example-gateway-class\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        kinds:\n          - kind: HTTPRoute\n\u0060\u0060\u0060\n\nEnsure that the \u0060gatewayClassName\u0060 refers to a valid GatewayClass configured in your cluster. The GatewayClass is usually set by the cluster administrator and provides a resource to configure the Gateway.\n\nNext, create an HTTPRoute resource to define routing rules that route traffic to the backend service:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1\nkind: HTTPRoute\nmetadata:\n  name: example-httproute\nspec:\n  parentRefs:\n  - name: example-gateway\n  hostnames:\n  - \u0022example.com\u0022\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \u0022\/\u0022\n    backendRefs:\n    - name: example-service\n      port: 80\n\u0060\u0060\u0060\n\nIn this example, we see:\n\n- The rules from the \u0060Ingress\u0060 object are directly mapped to the \u0060HTTPRoute\u0060 object.\n- The hostname matching, path matching, and backend service configurations remain unchanged, but the object and field names differ.\n\n## Considerations and Challenges\n\nAlthough it is possible to migrate from Ingress to Gateway API and potentially run them simultaneously, there are several challenges and considerations for the necessity of migration:\n\n- **Feature Differences**: Certain features specific to some Ingress controllers may not have direct equivalents in the Gateway API, requiring additional configurations or custom resources to achieve similar functionalities.\n- **Multi-Resource Management**: Using the Gateway API may involve managing more resource types and complex configurations than Ingress, potentially increasing the complexity of administration.\n\nFor existing users of Ingress and Istio API, whether to migrate to the Gateway API depends on specific circumstances. Here are some migration recommendations:\n\n- **For New Deployments**: It is advisable to use the Gateway API directly to take advantage of its advanced features and anticipate future developments.\n- **For Existing Deployments**: If the existing system operates stably and does not require advanced features, you can continue using the current APIs. If you seek to leverage new features of the Gateway API or plan for long-term development, a gradual migration is a prudent choice.\n\nFor the support status of different gateways for the Gateway API, refer to the [Gateway API Implementation Conformance Report](https:\/\/gateway-api.sigs.k8s.io\/implementations\/v1.1\/) for more details.\n\n## Conclusion\n\nThe Ingress API, Istio API, and Kubernetes Gateway API each have distinct features suitable for different application scenarios and needs. Selecting the appropriate API and planning and managing effectively can significantly enhance system flexibility and stability. As the Gateway API continues to develop and mature, it is increasingly becoming the mainstream choice for future traffic management.\n\nChoosing the right gateway technology, combined with your specific needs and existing architecture, can better manage and optimize traffic to ensure efficient and stable application operation. As technology progresses and the community evolves, the Gateway API provides a powerful and flexible framework, making the transition from traditional Ingress to more modern solutions simpler and more effective.\n\n## References\n\n- [Migrating from Ingress - gateway-api.sigs.k8s.io](https:\/\/gateway-api.sigs.k8s.io\/guides\/migrating-from-ingress\/)\n- [Extending Gateway API support in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2022\/gateway-api-beta\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/kubernetes-ingress-to-gateway-api-migration\/).*', '\/en\/blog\/gateway-api-istio-ingress-evolution\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article delves into the connections, differences, and migration strategies between Kubernetes Gateway API, Istio, and Ingress.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/seamless-cross-cluster-access-istio/">A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 25, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh', 'Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.', '\n## Introduction\n\nAs enterprise information systems increasingly adopt microservices architecture, how to achieve efficient and secure cross-cluster access to services in a multicluster environment has become a crucial challenge. Istio, as a popular service mesh solution, offers a wealth of features to support seamless inter-cluster service connections.\n\nThere are several challenges when deploying and using a multicluster service mesh:\n\n- Cross-cluster service registration, discovery, and routing\n- Identity recognition and authentication between clusters\n\nThis article will delve into how to achieve seamless cross-cluster access in a multicluster Istio deployment by implementing SPIRE federation and exposing services via east-west gateways. Through a series of configuration and deployment examples, this article aims to provide readers with a clear guide to understanding and addressing common issues and challenges in multicluster service mesh deployments.\n\n## Istio Deployment Models\n\nThe [Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/) divides various deployment models based on clusters, networks, control planes, meshes, trust domains, and tenants.\n\nThis article focuses on the hybrid deployment model of multi-cloud \u002b multi-mesh \u002b multi-control plane \u002b multi-trust domain. This is a relatively complex scenario. If you can successfully deploy this model, then other scenarios should also be manageable.\n\n## FQDN in Multicluster Istio Service Mesh\n\nFor services across different meshes to access each other, they must be aware of each other\u0027s Fully Qualified Domain Name (FQDN). FQDNs typically consist of the service name, namespace, and top-level domain (e.g., \u0060svc.cluster.local\u0060). In Istio\u0027s multi-cloud or multi-mesh setup, different mechanisms such as \u0060ServiceEntry\u0060, \u0060VirtualService\u0060, and \u0060Gateway\u0060 configurations are used to control and manage service routing and access, instead of altering the FQDN.\n\nThe FQDN in a multi-cloud service mesh remains the same as in a single cluster, usually following the format:\n\n\u0060\u0060\u0060\n\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local\n\u0060\u0060\u0060\n\nYou might think about using \u0060meshID\u0060 to distinguish meshes? The \u0060meshID\u0060 is mainly used to differentiate and manage multiple Istio meshes within the same environment or across environments, and it is not used to directly construct the service FQDN.\n\n{{\u003ccallout note  \u0022Main roles of \u0060meshID\u0060\u0022\u003e}}\n- **Mesh-level telemetry data aggregation**: Differentiates data from different meshes, allowing for monitoring and analysis on a unified platform.\n- **Mesh federation**: Establishes federation among meshes, allowing for sharing some configurations and services.\n- **Cross-mesh policy implementation**: Identifies and applies mesh-specific policies, such as security policies and access control.\n{{\u003c\/callout\u003e}}\n\n## Cross-Cluster Service Registration, Discovery, and Routing\n\nIn the Istio multi-mesh environment, the East-West Gateway plays a key role. It not only handles ingress and egress traffic between meshes but also supports service discovery and connectivity. When one cluster needs to access a service in another cluster, it routes to the target service through this gateway.\n\nThe diagram below shows the process of service registration, discovery, and routing across clusters.\n\nIn the configuration of Istio multi-mesh, the processes of service registration, discovery, and routing are crucial as they ensure that services in different clusters can discover and communicate with each other. Here are the basic steps in service registration, discovery, and routing in the Istio multi-mesh environment:\n\n### 1. Service Registration\n\nIn each Kubernetes cluster, when a service is deployed, its details are registered with the Kubernetes API Server. This includes the service name, labels, selectors, ports, etc.\n\n### 2. Sync to Istiod\n\nIstiod, serving as the control plane, is responsible for monitoring changes in the status of the Kubernetes API Server. Whenever a new service is registered or an existing service is updated, Istiod automatically detects these changes. Istiod then extracts the necessary service information and builds internal configurations of services and endpoints.\n\n### 3. Cross-Cluster Service Discovery\n\nTo enable a service in one cluster to discover and communicate with a service in another cluster, Istiod needs to synchronize service endpoint information across all relevant clusters. This is usually achieved in one of two ways:\n   - **DNS Resolution**: Istio can be configured to use CoreDNS or a similar service to return cross-cluster service endpoints in DNS queries. When a service tries to resolve another cluster\u0027s service, the DNS query returns the IP addresses of the accessible remote service. In this article, we enable Istio\u0027s [DNS proxy](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/) to achieve cross-cluster service discovery. If a service exists both locally and remotely, a local DNS query returns only the local service\u0027s ClusterIP. If the service exists only in a remote cluster, the DNS query returns the IP address of the East-West Gateway\u0027s load balancer in the remote cluster, which can also be used for cross-cluster failover.\n   - **Service Entry Synchronization**: By setting specific ServiceEntry configurations, an Envoy proxy in one cluster knows how to find and route to a service in another cluster through the East-West Gateway.\n\n### 4. Routing and Load Balancing\n\nWhen Service A needs to communicate with Service B, its Envoy proxy first resolves the name of Service B to get an IP address, which is the load balancer address of the East-West Gateway in Service B\u0027s cluster. Then, the East-West Gateway routes the request to the target service. Envoy proxies can select the best service instance to send requests based on configured load balancing strategies (e.g., round-robin, least connections, etc.).\n\n### 5. Traffic Management\n\nIstio offers a rich set of traffic management features, such as request routing, fault injection, and traffic mirroring. These rules are defined in the Istio control plane and pushed to the various Envoy proxies for execution. This allows for flexible control and optimization of communication between services in a cross-cluster environment.\n\n## Identity Recognition and Authentication Between Clusters\n\nWhen services running in different clusters need to communicate with each other, correct identity authentication and authorization are key to ensuring service security. Using SPIFFE helps to identify and verify the identities of services, but in a multi-cloud environment, these identities need to be unique and verifiable.\n\nTo this end, we will set up SPIRE federation to assign identities to services across multiple clusters and achieve cross-cluster identity authentication:\n\n- **Using SPIFFE to Identify Service Identities**: Under the SPIFFE framework, each service is assigned a unique identifier in the format \u0060spiffe:\/\/\u003ctrust-domain\u003e\/\u003cnamespace\u003e\/\u003cservice\u003e\u0060. In a multi-cloud environment, including the cluster name in the \u0022trust domain\u0022 ensures the uniqueness of identities. For example, \u0060spiffe:\/\/foo.com\/ns\/default\/svc\/service1\u0060 and \u0060spiffe:\/\/bar.com\/ns\/default\/svc\/service1\u0060 can be set to differentiate services with the same name in different clusters.\n- **Using SPIRE Federation to Manage Inter-Cluster Certificates**: This enhances the security of the multi-cloud service mesh. SPIRE (SPIFFE Runtime Environment) offers a highly configurable platform for service identity verification and certificate issuance. When using SPIRE federation, cross-cluster service authentication can be achieved by creating a Trust Bundle for each SPIRE cluster.\n\nHere are the steps for implementing SPIRE federation.\n\n### 1. Configuring Trust Domain\n\nEach cluster is configured as a separate trust domain. Thus, each service within a cluster will have a unique SPIFFE ID based on its trust domain. For instance, a service in cluster 1 might have the ID \u0060spiffe:\/\/cluster1\/ns\/default\/svc\/service1\u0060, while the same service in cluster 2 would be \u0060spiffe:\/\/cluster2\/ns\/default\/svc\/service1\u0060.\n\n### 2. Establishing Trust Bundle\n\nConfigure trust relationships in SPIRE to allow nodes and workloads from different trust domains to mutually verify each other. This involves exchanging and accepting each other\u0027s CA certificates or JWT keys between trust domains, ensuring the security of cross-cluster communication.\n\n### 3. Configuring SPIRE Server and Agent\n\nDeploy a SPIRE Server and SPIRE Agent in each cluster. The SPIRE Server is responsible for managing the issuance and renewal of certificates, while the SPIRE Agent handles the secure distribution of certificates and keys to services within the cluster.\n\n{{\u003ccallout warning \u0022Compatibility Issues with Workload Registration when Using SPIRE Federation in Istio\u0022\u003e}}\nIn this article, we use the traditional Kubernetes Workload Registrar in the SPRIE Server to handle workload registration within the cluster. The Kubernetes Workload Registrar has been deprecated from SPIRE v1.5.4 onwards, replaced by the SPIRE Controller Manager, which, in my testing, does not run well with Istio.\n{{\u003c\/callout\u003e}}\n\n### 4. Using the Workload API\n\nServices can request and update their identity certificates through SPIRE\u0027s Workload API. This way, services can continuously verify their identities and securely communicate with other services, even when operating in different clusters. We will configure the proxies in the Istio mesh to share the Unix Domain Socket in the SPIRE Agent, thus accessing the Workload API to manage certificates.\n\n### 5. Automating Certificate Rotation\n\nWe will use cert-manager as SPIRE\u0027s [UpstreamAuthority](https:\/\/github.com\/spiffe\/spire\/blob\/v1.9.5\/doc\/plugin_server_upstreamauthority_cert_manager.md) to configure automatic rotation of service certificates and keys, enhancing the system\u0027s security. With automated rotation, even if certificates are leaked, attackers can only use these certificates for a short period.\n\nThese steps allow you to establish a cross-cluster, secure service identity verification framework, enabling services in different clusters to securely recognize and communicate with each other, effectively reducing security risks and simplifying certificate management. This configuration not only enhances security but also improves the system\u0027s scalability and flexibility through distributed trust domains.\n\n## Multicluster Deployment\n\nThe diagram below shows the deployment model for Istio multi-cloud and SPIRE federation.\n\n![Multicloud Mesh Deployment Model](multi-cluster-deployment.svg)\n\nBelow, I will demonstrate how to achieve seamless cross-cluster access in a multi-cloud Istio mesh.\n\n1. Create two Kubernetes clusters in GKE, named \u0060cluster-1\u0060 and \u0060cluster-2\u0060.\n2. Deploy SPIRE and set up federation in both clusters.\n3. Install Istio in both clusters, paying attention to configure the trust domain, east-west gateways, ingress gateways, \u0060sidecarInjectorWebhook\u0060 mounting SPIFFE UDS\u0027s \u0060workload-socket\u0060, and enabling DNS proxy.\n4. Deploy test applications and verify seamless cross-cluster access.\n\nThe versions of the components we deployed are as follows:\n\n- Kubernetes: v1.29.4\n- Istio: v1.22.1\n- SPIRE: v1.5.1\n- cert-manager: v1.15.1\n\nI have saved all commands and step-by-step\n\n instructions on Github: [rootsongjc\/istio-multi-cluster](https:\/\/github.com\/rootsongjc\/istio-multi-cluster). You can follow the instructions in this project. Here are explanations for the main steps.\n\n### 1. Preparing Kubernetes Clusters\n\nOpen Google Cloud Shell or your local terminal, and make sure you have installed the \u0060gcloud\u0060 CLI. Use the following commands to create two clusters:\n\n\u0060\u0060\u0060bash\ngcloud container clusters create cluster-1 --zone us-central1-a --num-nodes 3\ngcloud container clusters create cluster-2 --zone us-central1-b --num-nodes 3\n\u0060\u0060\u0060\n\n### 2. Deploying cert-manager\n\nUse cert-manager as the root CA to issue certificates for istiod and SPIRE.\n\n\u0060\u0060\u0060bash\n.\/cert-manager\/install-cert-manager.sh\n\u0060\u0060\u0060\n\n### 3. Deploying SPIRE Federation\n\nBasic information for SPIRE federation is as follows:\n\n| Cluster Alias | Trust Domain |\n| ------------- | ------------ |\n| cluster-1     | foo.com      |\n| cluster-2     | bar.com      |\n\nNote: The trust domain does not need to match the DNS name but must be the same as the trust domain in the Istio Operator configuration.\n\nExecute the following command to deploy SPIRE federation:\n\n\u0060\u0060\u0060bash\n.\/spire\/install-spire.sh\n\u0060\u0060\u0060\n\nFor details on managing identities in Istio using SPIRE, refer to [Managing Certificates in Istio with cert-manager and SPIRE](\/en\/blog\/cert-manager-spire-istio\/).\n\n### 4. Installing Istio\n\nWe will use IstioOperator to install Istio, configuring each cluster with:\n\n- Automatic Sidecar Injection\n- Ingress Gateway\n- East-West Gateway\n- DNS Proxy\n- SPIRE Integration\n- Access to remote Kubernetes cluster secrets\n\nExecute the following command to install Istio:\n\n\u0060\u0060\u0060bash\nistio\/install-istio.sh\n\u0060\u0060\u0060\n\n## Verifying Traffic Federation\n\nTo verify the correctness of the multi-cloud installation, we will deploy different versions of the \u0060helloworld\u0060 application in both clusters and then access the \u0060helloworld\u0060 service from \u0060cluster-1\u0060 to test the following cross-cluster access scenarios:\n\n1. East-West Traffic Federation: Cross-cluster service redundancy\n2. East-West Traffic Federation: Handling non-local target services\n3. North-South Traffic Federation: Accessing services via a remote ingress gateway\n\nExecute the following command to deploy the \u0060helloworld\u0060 application in both clusters:\n\n\u0060\u0060\u0060bash\n.\/example\/deploy-helloword.sh\n\u0060\u0060\u0060\n\n### East-West Traffic Federation: Cross-Cluster Service Redundancy\n\nAfter deploying the \u0060helloworld\u0060 application, access the \u0060hellowrold\u0060 service from the \u0060sleep\u0060 pod in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nThe diagram below shows the deployment architecture and traffic routing path for this scenario.\n\n![East-West Traffic Federation: Cross-Cluster Service Redundancy](east-west-traffic-federation-between-clusters-without-dns-proxying.svg)\n\nThe response results including both \u0060helloworld-v1\u0060 and \u0060helloworld-v2\u0060 indicate that cross-cluster service redundancy is effective.\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the ClusterIP of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060.\n\n**Verifying Traffic Routing**\n\nNext, we will verify the cross-cluster traffic routing path by examining the Envoy proxy configuration.\n\nView the endpoints of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deployment\/sleep.sleep --context=cluster-1 --cluster \u0022outbound|5000||helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT               STATUS      OUTLIER CHECK     CLUSTER\n10.76.3.22:5000        HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n34.136.67.85:15443     HEALTHY     OK                outbound|5000||helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThese two endpoints, one is the endpoint of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060, and the other is the load balancer address of the \u0060istio-eastwestgateway\u0060 service in \u0060cluster-2\u0060. Istio sets up SNI for cross-cluster TLS connections, and in \u0060cluster-2\u0060, the target service is distinguished by SNI.\n\nExecute the following command to query the endpoint in \u0060cluster-2\u0060 based on the previous SNI:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config endpoints deploy\/istio-eastwestgateway.istio-system --context=cluster-2 --cluster \u0022outbound_.5000_._.helloworld.helloworld.svc.cluster.local\u0022\n\u0060\u0060\u0060\n\nYou will get output similar to the following:\n\n\u0060\u0060\u0060\nENDPOINT           STATUS      OUTLIER CHECK     CLUSTER\n10.88.2.4:5000     HEALTHY     OK                outbound_.5000_._.helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nThis endpoint is the endpoint of the \u0060helloworld\u0060 service in the \u0060cluster-2\u0060 cluster.\n\nThrough the steps above, you should understand the traffic path for cross-cluster redundant services. Next, we will delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060. No configuration changes are needed in Istio to automatically achieve failover.\n\n### East-West Traffic Federation: Failover\n\nExecute the following command to scale down the replicas of \u0060helloworld-v1\u0060 in \u0060cluster-1\u0060 to 0:\n\n\u0060\u0060\u0060bash\nkubectl -n helloworld scale deploy helloworld-v1 --context=cluster-1 --replicas 0\n\u0060\u0060\u0060\n\nAccess the \u0060helloworld\u0060 service again from \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=cluster-1 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -sS helloworld.helloworld:5000\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060.\n\nNow, directly delete the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl delete service helloworld -n helloworld --context=cluster-1\n\u0060\u0060\u0060\n\nYou will still receive responses from \u0060helloworld-v2\u0060, indicating that cross-cluster failover is effective.\n\nThe diagram below shows the traffic path for this scenario.\n\n![East-West Traffic Federation: Failover](east-west-traffic-federation-between-clusters-failover.svg)\n\n**Verifying DNS**\n\nAt this point, since the \u0060helloworld\u0060 service exists both locally and in the remote cluster, if you query the DNS name of the \u0060helloworld\u0060 service in \u0060cluster-1\u0060:\n\n\u0060\u0060\u0060bash\nkubectl exec -it deploy\/sleep --context=cluster-1 -n sleep -- nslookup helloworld.helloworld.svc.cluster.local\n\u0060\u0060\u0060\n\nYou will get the address and port 15443 of the East-West Gateway in \u0060cluster-2\u0060.\n\n### North-South Traffic Federation: Accessing Services via Remote Ingress Gateway\n\nAccessing services in a remote cluster through the ingress gateway is the most traditional way of cross-cluster access. The diagram below shows the traffic path for this scenario.\n\n![North-South Traffic Federation: Accessing Services via Remote Ingress Gateway](north-south-traffic-federation-between-clusters.svg)\n\nExecute the following command to create a Gateway and VirtualService in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nkubectl apply --context=cluster-2 \\\n\t-f .\/examples\/helloworld-gateway.yaml -n helloworld\n\u0060\u0060\u0060\n\nGet the address of the ingress gateway in \u0060cluster-2\u0060:\n\n\u0060\u0060\u0060bash\nGATEWAY_URL=$(kubectl -n istio-ingress --context=cluster-2 get service istio-ingressgateway -o jsonpath=\u0027{.status.loadBalancer.ingress[0].ip}\u0027)\n\u0060\u0060\u0060\n\nExecute the following validation to access the service via the remote ingress gateway:\n\n\u0060\u0060\u0060bash\nkubectl exec --context=\u0022${CTX_CLUSTER1}\u0022 -n sleep deployment\/sleep -c sleep \\\n\t-- sh -c \u0022while :; do curl -s http:\/\/$GATEWAY_URL\/hello; sleep 1; done\u0022\n\u0060\u0060\u0060\n\nYou will receive responses from \u0060helloworld-v2\u0060.\n\n## Verifying Identity\n\nExecute the following command to obtain the certificate from the \u0060sleep\u0060 pod in the \u0060cluster-1\u0060 cluster:\n\n\u0060\u0060\u0060bash\nistioctl proxy-config secret deployment\/sleep -o json --context=cluster-1| jq -r \u0027.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes\u0027 | base64 --decode \u003e chain.pem\nsplit -p \u0022-----BEGIN CERTIFICATE-----\u0022 chain.pem cert-\nopenssl x509 -noout -text -in cert-ab\nopenssl x509 -noout -text -in cert-aa\n\u0060\u0060\u0060\n\nIf you see the following fields in the output message, it indicates that the identity assignment is correct:\n\n\u0060\u0060\u0060\nSubject: C=US, O=SPIFFE\n\nURI:spiffe:\/\/foo.com\/ns\/sample\/sa\/sleep\n\u0060\u0060\u0060\n\nView the identity information in SPIRE:\n\n\u0060\u0060\u0060bash\nkubectl --context=cluster-1 exec -i -t -n spire spire-server-0 -c spire-server \\\n\t-- .\/bin\/spire-server entry show -socketPath \/run\/spire\/sockets\n\n\/server.sock --spiffeID spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\n\u0060\u0060\u0060\n\nYou will see output similar to the following:\n\n\u0060\u0060\u0060\nFound 1 entry\nEntry ID         : 9b09080d-3b67-44c2-a5b8-63c42ee03a3a\nSPIFFE ID        : spiffe:\/\/foo.com\/ns\/sleep\/sa\/sleep\nParent ID        : spiffe:\/\/foo.com\/k8s-workload-registrar\/cluster-1\/node\/gke-cluster-1-default-pool-18d66649-z1lm\nRevision         : 1\nX509-SVID TTL    : default\nJWT-SVID TTL     : default\nSelector         : k8s:node-name:gke-cluster-1-default-pool-18d66649-z1lm\nSelector         : k8s:ns:sleep\nSelector         : k8s:pod-uid:6800aca8-7627-4a30-ba30-5f9bdb5acdb2\nFederatesWith    : bar.com\nDNS name         : sleep-86bfc4d596-rgdkf\nDNS name         : sleep.sleep.svc\n\u0060\u0060\u0060\n\n## Recommendations for Production Environments\n\nFor production environments, it is recommended to use a [Unified Gateway](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway), employing a Tier-2 architecture. In the Tier-1 edge gateway, configure global traffic routing. This edge gateway will send the transcribed Istio configuration to the various ingress gateways in the Tier-2 clusters.\n\nThe diagram below shows the deployment of an Istio service mesh using SPIRE federation and a Tier2 architecture with TSB.\n\n![Deployment of a Multicluster Istio Service Mesh with SPIRE and Tier2 Architecture Using TSB](tsb-multi-cluster-architeture.svg)\n\nWe have divided these four Kubernetes clusters into Tier1 cluster (\u0060tier1\u0060) and Tier2 clusters (\u0060cp-cluster-1\u0060, \u0060cp-cluster-2\u0060, and \u0060cp-cluster-3\u0060). An Edge Gateway is installed in T1, while bookinfo and httpbin applications are installed in T2. Each cluster will have an independent trust domain, and all these clusters will form a SPIRE federation.\n\nThe diagram below shows the traffic routing for users accessing bookinfo and httpbin services through the ingress gateway.\n\n![Unified Gateway Architecture Diagram](tsb-unified-gateway.svg)\n\nYou need to create a logical abstraction layer suitable for multi-cloud above Istio. For detailed information about the unified gateway in TSB, refer to [TSB Documentation](https:\/\/docs.tetrate.io\/service-bridge\/howto\/gateway\/unified-gateway#scenario-1-cluster-based-routing-with-http-path-and-header-match).\n\n## Summary\n\nThis article has detailed the key technologies and methods for implementing service identity verification, DNS resolution, and cross-cluster traffic management in an Istio multi-cloud mesh environment. By precisely configuring Istio and SPIRE federation, we have not only enhanced the system\u0027s security but also improved the efficiency and reliability of inter-service communication. Following these steps, you will be able to build a robust, scalable multi-cloud service mesh to meet the complex needs of modern applications.\n\n## References\n\n- [Deploying a Federated SPIRE Architecture - spiffe.io](https:\/\/spiffe.io\/docs\/latest\/architecture\/federation\/readme\/)\n- [Install Multi-Primary on different networks -istio.io](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/)\n- [Istio SPIRE Integration - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/integrations\/spire)\n- [DNS Proxying - istio.io](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/dns-proxy\/)\n- [Attesting Istio workload identities with SPIFFE and SPIRE - developer.ibm.com](https:\/\/developer.ibm.com\/articles\/istio-identity-spiffe-spire\/)\n- [Expanding into New Frontiers - Smart DNS Proxying in Istio - istio.io](https:\/\/istio.io\/latest\/blog\/2020\/dns-proxy\/)\n- [Managing Certificates in Istio with cert-manager and SPIRE - jimmysong.io](\/en\/blog\/cert-manager-spire-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multicluster-istio\/).*', '\/en\/blog\/seamless-cross-cluster-access-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore how to effectively implement cross-cluster seamless access in the Istio multicluster mesh using SPIRE federation, DNS proxy, and east-west gateway technologies. This guide provides detailed configuration examples and steps to help you overcome deployment challenges and ensure efficient, secure communication between services.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-integrate-third-party-registry-with-istio/">How to Integrating Third-Party Service Registries with Istio?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 28, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Integrating Third-Party Service Registries with Istio?', 'This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.', '\nIstio relies on Kubernetes for service discovery, which generally means that microservices must be deployed within a Kubernetes cluster and use Kubernetes service discovery. However, many existing microservice projects still utilize third-party service registries like Consul and Eureka. This article will explore how to integrate these existing service registries with Istio.\n\n## Support for Non-Kubernetes Services in Istio\n\nOriginally, Istio supported only Kubernetes services, but over time, to accommodate a broader range of application scenarios, it began supporting third-party service registries like Consul. By introducing the Mesh Configuration Protocol (MCP), Istio was able to communicate with various service discovery backends, such as Consul, thereby managing services in non-Kubernetes environments. With the introduction of the ServiceEntry resource in version 1.1, users were able to manually add external services to Istio\u0027s service registry. By version 1.8, direct support for Consul was removed in favor of a more flexible approach through [ServiceEntry](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/service-entry\/), allowing the integration and management of all services, whether hosted on Kubernetes or not.\n\n## High-Level Architecture of Istio Proxy Configuration\n\nThe following diagram illustrates the high-level architecture of Istio proxy configuration, showing how configurations are ingested, transformed, and ultimately served to the Envoy proxies.\n\n\u0060\u0060\u0060mermaid \u0022Istio Proxy Configuration High-Level Architecture\u0022\ngraph TD\n    subgraph Configuration Ingestion\n        subgraph Configuration Storage\n            xcs(XDS Client) --\u003e acs(Aggregate)\n            ccs(CRD Client) --\u003e acs(Aggregate)\n            fcs(Filesystem Client) --\u003e acs(Aggregate)\n        end\n        subgraph Service Discovery\n            kc(Kube Controller) --\u003e sd(Aggregate)\n            sec(ServiceEntry Controller) --\u003e sd(Aggregate)\n        end\n    end\n    subgraph Configuration Translation\n        acs \u0026 sd --\u003e ct(Configuration Translator)\n    end\n    subgraph \u0022Configuration Service (XDS)\u0022\n        ct --\u003e xds(XDS Server)\n    end\n    xds --\u003e ep(Envoy Proxies)\n\u0060\u0060\u0060\n\n![Istio Proxy Configuration High-Level Architecture](f02f7fa551ceb4c4b9fd0419b69ca6f4.svg)\n\n### Detailed Process of Configuration Ingestion\n\n- **Configuration Storage**: Responsible for reading various types of resources and aggregating them. Includes:\n    - **XDS Client**: Reads resources via the xDS protocol.\n    - **CRD Client**: Reads resources from Kubernetes Custom Resource Definitions (CRDs).\n    - **Filesystem Client**: Reads resources from the filesystem.\n- **Service Discovery**: Aggregates service-oriented internal resources. Components used include:\n    - **Kube Controller**: Operates based on core Kubernetes types.\n    - **ServiceEntry Controller**: Operates based on Istio types.\n\n### Configuration Translation and Service\n\nAfter aggregating configurations from Configuration Storage and Service Discovery, the **Configuration Translator** translates them into a format suitable for the proxies, which are then served by the **XDS Server**. This is the final step in applying dynamic configurations to the proxies.\n\n## Synchronization of Third-Party Registries\n\nTo integrate third-party service registries, we can implement an Operator that monitors third-party service registries and pushes services in the form of ServiceEntry and WorkloadEntry resources to the Kubernetes API server. The following flowchart illustrates this synchronization process.\n\n\u0060\u0060\u0060mermaid \u0022Synchronization of Third-Party Registries Flowchart\u0022\nsequenceDiagram\n    participant O as Operator\n    participant CM as Third-Party Service Registry\n    participant K8s as Kubernetes API Server\n    participant I as Istiod\n    participant EP as Envoy Proxies\n\n    O-\u003e\u003e\u002bCM: Query Service Registry\n    CM--\u003e\u003e-O: Return Service Data\n    O-\u003e\u003eO: Transform Services to ServiceEntry\n    O-\u003e\u003e\u002bK8s: Push ServiceEntry\n    K8s--\u003e\u003e-I: Update Istio Configuration\n    I-\u003e\u003eEP: Update Proxy Configuration\n    Note over EP: Envoy Proxies Receive New Configuration\n\n    loop Monitor Changes\n        O-\u003e\u003e\u002bCM: Check for Updates\n        CM--\u003e\u003e-O: Notify on Change\n        O-\u003e\u003eO: Transform Updated Services\n        O-\u003e\u003e\u002bK8s: Update ServiceEntry\n        K8s--\u003e\u003e-I: Refresh Istio Configuration\n        I-\u003e\u003eEP: Refresh Proxy Configuration\n    end\n\u0060\u0060\u0060\n\n![Synchronization of Third-Party Registries Flowchart](094c8461ff42db96a7c04d7a1b92b0d2.svg)\n\n### Steps for Synchronization of Third-Party Service Registries\n\n1. The Operator initiates a service query to the Third-Party Service Registry.\n2. The Third-Party Service Registry returns the current registered service data.\n3. The Operator transforms the service data into Istio\u0027s ServiceEntry objects.\n4. The Operator pushes the transformed ServiceEntry to the Kubernetes API Server.\n5. The Kubernetes API Server notifies Istiod of the changes.\n6. Istiod updates the configurations of the Envoy Proxies.\n7. The Operator regularly checks the Third-Party Service Registry to monitor service changes, updating the ServiceEntry and re-pushing it to the Kubernetes API Server upon detection of changes, thus completing the service synchronization.\n\n## Istio Registry Sync\n\nDeveloped by Tetrate, [Istio Registry Sync](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction) is an extension operator that can run as an add-on for [TIS](https:\/\/docs.tetrate.io\/istio-subscription\/). It supports the integration of non-Kubernetes service registries (such as AWS Cloud Map and Consul) with Istio. This tool provides several use cases:\n\n- **Hybrid Application Integration**: In hybrid environments, traditional applications using Consul and microservices in AWS using Cloud Map can achieve seamless service discovery through Istio Registry Sync.\n- **Dynamic Endpoint Management**: In environments where services frequently scale, Istio Registry Sync quickly reflects changes from the configured registry, ensuring accurate traffic management strategies within Istio\u0027s service mesh.\n- **Unified Monitoring and Security Posture**: By integrating services from all environments into Istio, it leverages service health metrics and a unified security protocol, such as mTLS, to ensure encrypted and authenticated communication across all services.\n\n## Conclusion\n\nThrough the methods described above, you can effectively integrate Istio with third-party service registries, whether by developing a custom Operator or using the ready-made Istio Registry Sync tool. This not only maintains the modernization of services but also ensures efficient collaboration across different environments.\n\n## References\n\n- [Istio Pilot Architecture - github.com](https:\/\/github.com\/istio\/istio\/blob\/master\/pilot\/doc\/architecture.md)\n- [Istio Registry Sync Documentation - docs.tetrate.io](https:\/\/docs.tetrate.io\/istio-subscription\/integrations\/registry-sync\/introduction)\n\n---\n\n*This blog was initially published at [tetrate.io](LINK).*', '\/en\/blog\/how-to-integrate-third-party-registry-with-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed introduction on how to integrate third-party service discovery mechanisms such as Consul and Eureka with Istio, achieving seamless service discovery integration.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-delta-xds-for-envoy/">Introduction to Envoy xDS and Configuration Distribution in Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 24, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introduction to Envoy xDS and Configuration Distribution in Istio', 'This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.', '\nIn the early stages of the Istio project, configurations were pushed to Envoy proxies using the global State of the World (SotW) method. Whenever a service changed, the global configuration had to be pushed to all sidecars, causing significant network load and performance loss on the control plane. The Istio community began developing Incremental xDS a few years ago to address this issue and has supported Incremental xDS in recent Istio versions. In the recent [Istio 1.22 release](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/), Incremental xDS has become the default feature. This article will introduce you to xDS, Incremental xDS, and the method of configuration distribution in Istio.\n\n## What is xDS?\n\nxDS (Extensible Discovery Service) is a communication protocol used for managing service discovery and dynamic configuration in a microservices architecture. This mechanism is widely used in Envoy proxies and Istio service meshes to manage various types of resource configurations, such as routing, service discovery, load balancing settings, etc.\n\n### What discovery services are included in xDS?\n\nxDS includes the following main discovery services, each responsible for different types of network resource configurations:\n\n1. **LDS (Listener Discovery Service)**: Manages the configuration of Envoy listeners, which define how to receive and handle inbound connections.\n2. **RDS (Route Discovery Service)**: Provides routing information, defining how to route requests to different services based on specified rules.\n3. **CDS (Cluster Discovery Service)**: Manages cluster information, where a cluster represents a group of logically similar backend service instances.\n4. **EDS (Endpoint Discovery Service)**: Provides the network addresses of specific service instances that make up the clusters defined in CDS.\n5. **SDS (Secret Discovery Service)**: Manages security-related configurations, such as TLS certificates and private keys.\n6. **VHDS (Virtual Host Discovery Service)**: Provides virtual host configurations for RDS, allowing dynamic updates of virtual hosts without restarting connections.\n7. **SRDS (Scoped Route Discovery Service)**: Manages routing scopes, providing dynamic route selection based on different conditions (such as request headers).\n8. **RTDS (Runtime Discovery Service)**: Provides runtime configurations, which can be used for experimental features or fine-tuning system behavior.\n9. **ECDS (Extension Config Discovery Service)**: Supports dynamic configuration updates for a specific filter. Currently, ECDS is supported for network filters, HTTP filters and Listener filters. \n\nThese services collectively support the distribution and update of dynamic configurations, enabling Envoy-based application architectures to adapt in real-time to changes, enhancing scalability and flexibility. Each service can be implemented independently or managed collectively through an aggregated approach (such as ADS). CNCF has also established an [xDS API working group](https:\/\/github.com\/cncf\/xds) to promote the xDS API as the de facto standard for L4\/L7 data plane configuration, similar to the role OpenFlow plays in L2\/L3\/L4 in SDN.\n\n{{\u003ccallout note Tip\u003e}}\nFor a detailed introduction to the xDS protocol, such as xDS RPC services and variant methods, as well as the xDS request process, please refer to the [Envoy proxy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol).\n{{\u003c\/callout\u003e}}\n\n### Variants of the xDS Protocol\n\nThe xDS protocol primarily includes the following variants:\n1. **State of the World (SotW)**: A separate gRPC stream provides complete data for each type of resource, typically used during the initial startup of an Envoy proxy, and was the first type of xDS protocol used by Istio.\n2. **Incremental xDS (Delta xDS)**: Provides only the changed parts of the data for each type of resource, developed starting in 2021 and enabled by default in the Istio 1.22 version.\n3. **Aggregated Discovery Service (ADS)**: A single gRPC stream aggregates all types of resource data.\n4. **Incremental ADS (Delta ADS)**: A single gRPC stream aggregates all types of incremental data.\n\nThe table below summarizes the four variants of the xDS protocol, including explanations, usage scenarios, and a comparison of their advantages and disadvantages. These variants provide multiple options for different network environments and service needs, allowing you to choose the most suitable protocol variant to optimize service performance and resource use.\n\n{{\u003ctable \u0022Introduction to the four variants of the xDS protocol\u0022\u003e}}\n| Variant Type  | Explanation                                                 | Usage Scenario                                               | Advantages                                                | Disadvantages                                              |\n| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |\n| SotW          | Sends all configuration data each time, regardless of changes. | Suitable for stable environments with little configuration change. | Simple to implement, easy to understand and maintain.     | Large data transmission, not suitable for environments with frequent configuration updates. |\n| Delta xDS     | Transmits only changed configuration data, not all data.     | Suitable for environments with frequent changes needing quick response to updates. | Reduces unnecessary data transmission, increasing efficiency. | Complex implementation, requires client and server to manage configuration states. |\n| ADS           | Manages all configuration data through a single gRPC stream, eliminating the need for separate connections for each resource type. | Suitable for complex service architectures that need to manage multiple types of resources simultaneously. | Reduces the number of network connections, simplifying resource management. | In cases of poor network or service quality, a single point of failure could cause all configuration updates to fail. |\n| Delta ADS     | Combines the advantages of ADS and Incremental xDS, aggregating and transmitting only changes in resources through a single gRPC stream. | Suitable for highly dynamic environments that need to manage multiple types of resources and require frequent updates. | Provides maximum flexibility and efficiency, suitable for large-scale and highly dynamic service architectures. | Most complex implementation, high requirements for managing configuration logic and precise control over resource changes and transmission. |\n\n{{\u003c\/table\u003e}}\n\nService meshes using the xDS protocol can more flexibly manage communication and configurations between microservices, reducing the latency of configuration changes and improving system response speed and reliability.\n\nIn Istio, the DiscoveryServer acts as the implementation of Envoy\u0027s xDS API, responsible for listening to the gRPC interface and dynamically pushing configurations according to Envoy\u0027s needs. It can handle requests for various resource types and update Envoy configurations in real-time based on service changes. Additionally, it supports security features, such as verifying client certificates, ensuring only legitimate service instances can receive configuration data.\n\n### Configuration Examples for xDS Variants\n\nConfiguring xDS variants typically involves specifying the xDS server details in the configuration of the Envoy proxy or a similar service mesh. While the configuration details of different service meshes and proxy servers may vary, here are some common YAML configuration examples that illustrate how to specify xDS servers and how to use these protocol variants.\n\n#### State of the World (SotW)\n\nIn Envoy\u0027s configuration, you can use SotW either through static resources or by dynamically obtaining resources via API. Here\u0027s a simple Envoy configuration example showing how to statically define clusters and listeners:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=24\u0022\u003e}}\nstatic_resources:\n  listeners:\n    - address:\n        socket_address: { address: 0.0.0.0, port_value: 80 }\n      filter_chains:\n        - filters:\n            - name: envoy.http_connection_manager\n              config:\n                stat_prefix: ingress_http\n                codec_type: auto\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: local_service\n                      domains: [\u0022*\u0022]\n                      routes:\n                        - match: { prefix: \u0022\/\u0022 }\n                          route: { cluster: local_service }\n                    http_filters:\n                      - name: envoy.router\n                  clusters:\n        - name: local_service\n            connect_timeout: 0.25s\n            type: STATIC\n            lb_policy: ROUND_ROBIN\n            hosts: [{ socket_address: { address: 127.0.0.1, port_value: 80 } }]\n{{\u003c\/highlight\u003e}}\n\n#### Incremental xDS\n\nIncremental xDS configuration requires the xDS server to support the incremental protocol, and the client configuration must specify the use of Incremental xDS. The Envoy startup configuration needs to add an API version to enable Incremental xDS:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=4 10\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n  lds_config:\n    api_config_source:\n      api_type: DELTA_GRPC\n      grpc_services:\n        envoy_grpc:\n          cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Aggregated Discovery Service (ADS) \n\nWhen using ADS, the configuration of all resource types is aggregated through a single API endpoint. This is specified in the Envoy configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=6 7\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n lds_config:\n    ads: {}\n  ads_config:\n    api_type: GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\n#### Incremental ADS\n\nIncremental ADS achieves more fine-grained updates by specifying the incremental API type in the ADS configuration:\n\n{{\u003chighlight yaml \u0022linenos=table,hl_lines=8 9\u0022\u003e}}\ndynamic_resources:\n  cds_config:\n    ads: {}\n    resource_api_version: V3\n  lds_config:\n    ads: {}\n    resource_api_version: V3\n  ads_config:\n    api_type: DELTA_GRPC\n    grpc_services:\n      envoy_grpc:\n        cluster_name: xds_cluster\n{{\u003c\/highlight\u003e}}\n\nThese configuration examples need to be adjusted according to your specific environment and requirements. For more details and advanced configurations, you can refer to the [Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/config\/core\/v3\/config_source.proto#envoy-v3-api-enum-config-core-v3-apiconfigsource-apitype).\n\n## How Does Istio Send Configurations to Envoy Sidecars?\n\nThanks to the xDS protocol, tools like Istio and Envoy Gateway can dynamically distribute configurations to Envoy proxies via API. The diagram below shows the configuration distribution process in Istio (Sidecar mode).\n\n\u0060\u0060\u0060mermaid \u0022Istio Configuration Distribution Process Diagram\u0022\nflowchart TB\n    Declarative_Configuration[Declarative Configuration] --\u003e Kubernetes\n    Kubernetes \u003c--\u003e Istiod\n\n    subgraph Istiod [Istiod]\n        xDS_API[xDS API]\n    end\n\n    xDS_API \u003c--\u003e Pod1\n    xDS_API \u003c--\u003e Pod2\n    xDS_API \u003c--\u003e Pod3\n\n    subgraph Pod1 [Pod]\n        Envoy_Proxy1[Envoy Proxy] \u003c--\u003e Application1[Application]\n    end\n\n    subgraph Pod2 [Pod]\n        Envoy_Proxy2[Envoy Proxy] \u003c--\u003e Application2[Application]\n    end\n\n    subgraph Pod3 [Pod]\n        Envoy_Proxy3[Envoy Proxy] \u003c--\u003e Application3[Application]\n    end\n\u0060\u0060\u0060\n\n![Istio Configuration Distribution Process Diagram](f78ce8f5c5eb02d32a733e923a83fa5d.svg)\n\nThe main steps of the configuration distribution process in Istio are:\n\n1. **Declarative Configuration**: Users define the service mesh\u0027s configuration using YAML files or other configuration management tools. These configurations can include routing rules, security policies, telemetry settings, etc.\n2. **Kubernetes**: Istio configuration files are submitted to the Kubernetes cluster, usually through the \u0060kubectl apply\u0060 command or other CI\/CD tools. Kubernetes receives the configuration files and stores them in the etcd database.\n3. **Istiod**: Istiod is the control plane component of Istio, responsible for managing and distributing configurations. It listens for events coming from the Kubernetes API server, obtains relevant configuration changes, and processes them. Istiod parses the configuration files, generates corresponding routing rules and policies, and distributes these configurations to the data plane (Envoy proxies) via the xDS API.\n4. **xDS API**: Istiod uses the xDS API to send configurations to each Envoy proxy.\n5. **Envoy Proxy**: Envoy is the data plane component of Istio, running in a sidecar container alongside each service, intercepting and managing all inbound and outbound traffic. Envoy proxies receive configurations from Istiod via the xDS API and manage traffic, enforce policies, and collect telemetry data based on these configurations.\n6. **Pod**: Each service instance runs in a Pod, which contains an application container and an Envoy proxy container. The Envoy proxy intercepts all network traffic to and from the application container and processes it according to the configurations.\n\nThis configuration distribution process ensures that Istio can dynamically manage and configure all service instances in the service mesh, providing consistent traffic management and policy enforcement.\n\n## The Evolution of xDS and the Implementation of Delta xDS in Istio\n\nInitially, xDS adopted a \u0022global state\u0022 (State of the World, abbreviated as SotW) design, which meant that any configuration change required sending the complete state of all configurations to Envoy. This approach created a huge burden on the network and control plane, especially in large-scale service deployments.\n\nAt EnvoyCon 2021, Aditya Prerepa and John Howard shared How Istio Implements Delta xDS, an incremental implementation of xDS. Compared to the traditional SotW xDS, Delta xDS sends only the changed configurations, significantly reducing the amount of configuration data that needs to be sent over the network, thus improving efficiency and performance. This method is particularly suitable for environments where configurations change frequently, as it updates only the changed parts rather than the entire configuration.\n\nDuring the implementation of Delta xDS, the Istio\n\n team faced several challenges, including ensuring the correctness of configuration updates and avoiding potential resource leaks. They addressed these challenges by adopting a Dry-run mode to run the SotW and Delta generators in parallel, gradually identifying and fixing flaws in the implementation. Additionally, they introduced new Envoy types, such as the Virtual Host Discovery Service, to support more fine-grained configuration distribution.\n\n### Delta xDS Incremental Configuration\n\nThe diagram below illustrates the process of Delta xDS incremental configuration.\n\n\u0060\u0060\u0060mermaid \u0022Delta xDS Incremental Configuration Process Diagram\u0022\nsequenceDiagram\n    participant CP as Control Plane\n    participant P as Proxy\n    CP-\u003e\u003eP: Initial Complete Configuration\n    P-\u003e\u003eCP: Subscribe to Configuration Changes\n    Note over CP,P: Any Configuration Change Occurs\n    CP-\u003e\u003eP: Check Configuration Changes\n    CP-\u003e\u003eP: Calculate Differences\n    CP-\u003e\u003eP: Send Only Differences\n    Note over P: Proxy Uses Differences for Updates\n\u0060\u0060\u0060\n\n![Delta xDS Incremental Configuration Process Diagram](9a1fc2d6009beb68cf596e0f077881ec.svg)\n\nThe Delta xDS configuration process is as follows:\n\n1. **Initial Complete Configuration**: The control plane sends the initial complete configuration to the proxy, using the StoW mode at this time.\n2. **Subscribe to Configuration Changes**: The proxy subscribes to configuration changes from the control plane.\n4. **Check Configuration Changes**: The control plane checks for configuration changes relative to the proxy\u0027s known state.\n5. **Calculate Differences**: The control plane calculates the differences (increments) between the current configuration and the previous configuration held by the proxy.\n6. **Send Only Differences**: The control plane sends only the changed configuration (differences) to the proxy, which applies these incremental updates to its configuration.\n\nThis process ensures that only necessary changes are transmitted and applied, improving efficiency and reducing the load on network and proxy resources.\n\n### SotW vs Delta xDS\n\nWhile Delta xDS solves the performance issues of configuration distribution in large-scale networks, the SotW mode still has its place, such as in the initial configuration delivery. The table below compares the two configuration distribution methods in Istio: SotW (State of the World) and Delta xDS.\n\n{{\u003ctable \u0022Comparison of Global State and Incremental xDS Configuration Distribution Methods in Istio\u0022\u003e}}\n| Comparison Item   | SotW                                                        | Delta XDS                                   |\n| ----------------- | ----------------------------------------------------------- | ------------------------------------------- |\n| **Data Volume**   | Transmits complete configuration data each time, regardless of whether there are changes. | Transmits only the changed configuration data, reducing data volume. |\n| **Efficiency**    | Acceptable efficiency in small or less changing environments. | Higher efficiency in large or frequently changing environments. |\n| **Complexity**    | Simple implementation, easy to understand and maintain.     | More complex implementation, requires fine tracking and management of changes. |\n| **Resource Usage** | May increase server and network load due to repeatedly sending large amounts of unchanged data. | Lower resource usage, as only changed parts are handled. |\n| **Timeliness**    | High immediacy as full configuration is sent immediately after updates. | Faster response by sending only changed parts, reducing processing time. |\n| **Applicability** | Suitable for small to medium deployments with infrequent configuration changes. | Suitable for environments with frequent configuration changes or large-scale deployments. |\n{{\u003c\/table\u003e}}\n\nThis table compares SotW and Delta XDS from multiple perspectives, including data volume, efficiency, complexity, resource usage, timeliness, and applicability, helping you make the appropriate choice in different usage environments.\n\n## Conclusion\n\nIn this article, I shared the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS. With Delta xDS becoming the default configuration in Istio version 1.22, this will help users easily use Istio in large-scale network environments.\n\n## References\n\n- [xDS REST and gRPC protocol - envoyproxy.io](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-delta-xds\/).', '\/en\/blog\/istio-delta-xds-for-envoy\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article shares the components of xDS and the process of configuration distribution in Istio, as well as the two modes of xDS, SotW and Delta xDS.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-22/">Deep Dive into Istio 1.22: New Features and Practical Application Advice</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 21, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Deep Dive into Istio 1.22: New Features and Practical Application Advice', 'Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.', '\nThe recent [release of Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) includes a plethora of significant updates. This article shares the new features and application recommendations brought by this release.\n\n## Ambient Mode Enters Beta Phase\n\nAlthough Ambient mode has now entered the Beta phase, this does not mean we can completely do away with Sidecars. While the Istio official claims that Ambient mode simplifies operations and significantly reduces memory and CPU usage, it still has limitations and potential complexity issues. For example, while Sidecars are eliminated, the introduction of new ztunnel and waypoint components may pose new challenges. For more detailed information about Ambient mode entering Beta, refer to the [Istio official blog](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/).\n\n**Challenges Introduced by Ambient Mode**\n\n- Management of L7 traffic in Ambient mode is not yet mature\n- mTLS is forced to be enabled at the namespace level, meaning you cannot disable mTLS in Ambient mode\n- Zero-downtime upgrades in Ambient mode have not been resolved\n- Lack of best practices for coexistence and migration from Sidecar mode\n\nFor a comparison of Sidecar mode and Ambient mode, see [Analysis of Limitations in Istio Ambient Mode](\/blog\/istio-ambient-mode-limitations\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nIf you are just starting with Istio, especially if you only need to automatically enable mTLS for services, you can consider using Ambient mode at this stage. However, for L7 functionalities, it is recommended to wait until Ambient mode is fully mature before considering it for production use.\n{{\u003c\/callout\u003e}}\n\n## Istio API Upgrades\n\nIn the Istio 1.22 release, key APIs related to traffic management, security, and telemetry have officially been upgraded to the \u0060v1\u0060 version. You only need to change the API version of your existing configuration to \u0060v1\u0060, with no other changes needed. These APIs are already mature, and you can safely use the \u0060v1\u0060 version. For environments requiring high stability, Istio has added [validating admission policies](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/) to ensure that only \u0060v1\u0060 APIs and fields can be used in the Istio API.\n\nFor example, the following AuthorizationPolicy example.\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\nOther extension-type APIs such as \u0060EnvoyFilter\u0060, \u0060WasmPlugin\u0060, \u0060ProxyConfig\u0060 are still in alpha or beta stages. For more information on API upgrades, please refer to the [v1 API blog](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor commonly used functionalities, you can confidently use the \u0060v1\u0060 API. For extension-type APIs that are not yet stable, enabling validating admission policies is recommended to ensure system stability.\n{{\u003c\/callout\u003e}}\n\n## Gateway API Upgrade\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) has been updated to version 1.1.0 and is now widely available. This update extends Istio\u0027s traffic management capabilities, but it is important to be cautious of compatibility issues between Istio\u0027s native APIs and the Gateway API when migrating to the new API to avoid relying on features that are not fully mature yet. For more details, check out the [Gateway API v1.1 blog](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor existing deployments that are already stable using Istio API, continue using them, especially in scenarios requiring advanced features. For new deployments, consider using the stable version of the Gateway API to take advantage of its modern traffic management capabilities. Due to existing compatibility issues, do not rashly migrate to the Gateway API, as it may not be worth the risk.\n{{\u003c\/ callout\u003e}}\n\n## Delta xDS Enabled by Default\n\nIstio 1.22 version now has delta xDS enabled by default, which is a mechanism to optimize configuration distribution. Compared to the traditional State of the World (SotW) mode, delta xDS only sends changed configurations to the Envoy proxies, thereby significantly reducing the amount of data transmitted over the network and the resource consumption of the control plane. This change is particularly suitable for large-scale deployment environments with frequent configuration updates, improving the efficiency and performance of configuration updates. Additionally, delta xDS also helps manage configuration updates more efficiently in complex network environments or dynamically changing configurations.\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nThe delta xDS has been developed several versions ago but was not enabled by default. Now that this feature is stable, you can use it with confidence.\n{{\u003c\/callout\u003e}}\n\nFor more on xDS, refer to the [Introduction to Envoy xDS and Configuration Distribution Process in Istio](\/blog\/istio-delta-xds-for-envoy\/).\n\n### Path Template Support with Wildcards for AuthorizationPolicy\n\nIn Istio 1.22, \u0060AuthorizationPolicy\u0060 has added support for [path templates](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation), greatly enhancing the flexibility and precision of path matching. Prior to this, \u0060AuthorizationPolicy\u0060 did not support wildcards in path configurations. This feature allows for defining paths in HTTP requests using URI templates based on Envoy, including simple wildcards (\u0060*\u0060 and \u0060**\u0060) or named variables, enabling precise matching of single or multiple path components. For example, the path template \u0060\/foo\/{*}\u0060 can match \u0060\/foo\/bar\u0060 but not \u0060\/foo\/bar\/baz\u0060, while \u0060\/foo\/{**}\/\u0060 can match any path starting with \u0060\/foo\/\u0060. This flexible path template design is particularly suitable for dynamic and complex routing rules, further strengthening Istio\u0027s security policy toolbox.\n\nThe diagram below illustrates the wildcard rules for path matching in AuthorizationPolicy.\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy Path Matching Wildcard Rules\u0022\ngraph LR\n    A[AuthorizationPolicy Path Matching] --\u003e B(Define Path Templates)\n    B --\u003e C{Path Template Operators}\n    C --\u003e D[\u0022* (Match single segment)\u0022]\n    C --\u003e E[\u0022** (Match multiple segments)\u0022]\n    C --\u003e F[\u0022{name} (Named variable matching one segment)\u0022]\n    C --\u003e G[\u0022{name=**} (Named variable matching multiple segments)\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} matches \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ matches \/foo\/bar\/, \/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} matches \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd matches \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy Path Matching Wildcard Rules](dfe9a5d5e2bc91e91e7e24017f56a3db.svg)\n\nFor more on the specific applications and rules of path templates, you can refer to [Envoy\u0027s official documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto).\n\n{{\u003c callout note \u0022Tip\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 finally supports templates in path matching, so you no longer need to manually add paths one by one in your configurations.\n{{\u003c\/callout\u003e}}\n\n## Summary\n\nThe Istio 1.22 release introduces several important updates and improvements. Although some features are widely publicized, they require detailed assessment and appropriate testing in practical use. Hopefully, this blog post helps you understand and apply these new features more deeply to achieve the best results in practice.\n\n## References\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-new-features-v1_22\/).', '\/en\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-cni-deep-dive/">Istio CNI Unveiled: Streamlining Service Mesh Connectivity</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Istio CNI Unveiled: Streamlining Service Mesh Connectivity', 'This article provides a detailed explanation of the design principles, implementation methods, and how to enhance security and permission management through Ambient Mode in the Istio CNI plugin.', '\nThis article delves into the design principles, implementation, and how Ambient Mode enhances security and permission management in Istio CNI plugins. The content includes:\n\n- Security risks of Init containers and their solutions.\n- Working principles and advantages of Istio CNI.\n- Implementation mechanism of Ambient Mode and its integration with CNI.\n\n## Overview of Istio Network Requirements and Solutions\n\nIstio service mesh intercepts and manages application traffic through the Sidecar mode. This mode injects a Sidecar Proxy and init containers into application pods and uses iptables rules to manage network traffic. For detailed deployment and operation processes, please refer to [Understanding Sidecar Injection, Transparent Traffic Hijacking, and Traffic Routing in Istio](\/en\/blog\/sidecar-injection-iptables-and-traffic-routing\/). Although this method is effective on most Kubernetes platforms, the high dependency on privileges raises security concerns in multi-tenant environments.\n\n### Limitations of Istio-init\n\nDuring its initial network configuration, Istio adopted the \u0060istio-init\u0060 container to initialize traffic interception rules, requiring containers to have advanced permissions to modify network configurations like IPTables rules. While this method effectively manages traffic, it significantly increases permission requirements and security risks. According to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/setup\/additional-setup\/cni\/), the \u0060istio-init\u0060 container is injected into pods within the Istio mesh by default to hijack network traffic to Istio\u0027s Sidecar proxy. This process requires granting the Service Account deploying the pod the [\u0060NET_ADMIN\u0060 container permission](https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/security-context\/#set-capabilities-for-a-container), which may contradict the security policies of some organizations.\n\n### Istio CNI Plugin\n\nIn response to this challenge, the Istio community introduced the [Istio CNI](https:\/\/github.com\/istio\/istio\/tree\/master\/cni) plugin, which avoids the need for init containers, allowing direct manipulation at the Kubernetes network layer, thereby reducing permission requirements and simplifying the deployment process, but with CNI compatibility issues.\n\n### Introduction of Ambient Mode\n\nIstio\u0027s Ambient Mode is an innovative sidecar-less solution that enhances network flexibility and security by [using Geneve tunnels](\/en\/blog\/traffic-interception-with-geneve-tunnel-with-istio-ambient-mesh\/) or Istio CNI.\n\nOnly recently has the Istio community introduced a [universal solution compatible with any CNI](https:\/\/istio.io\/latest\/blog\/2024\/inpod-traffic-redirection-ambient\/). This mode addresses compatibility issues with any CNI, enabling Istio to more effectively manage traffic between services without affecting existing network policies.\n\n## Security Considerations for NET_ADMIN Permissions\n\nIn containerized environments like Kubernetes and Docker, \u0060NET_ADMIN\u0060 permissions allow processes within containers to perform extensive network-related operations, including modifying iptables rules, changing network interface configurations, managing IP routing tables, and controlling kernel parameters related to networking. However, the use of these permissions raises security concerns, especially regarding overprivileged access and potential attack surfaces.\n\n**Best practices include**:\n\n- **Limiting scope of use**: Grant \u0060NET_ADMIN\u0060 permissions only when necessary and restrict them through Kubernetes network policies.\n- **Continuous monitoring and auditing**: Enforce strict logging and monitoring for containers using \u0060NET_ADMIN\u0060 permissions.\n\n## Working Principles of Istio CNI Plugin\n\nThe Istio CNI plugin is a binary file installed as an agent in the file system of each node. The following flowchart illustrates the working principles of the Istio CNI node agent:\n\n\u0060\u0060\u0060mermaid\nflowchart TB\n    subgraph istio_cni_node_agent[Istio CNI Node Agent]\n        direction LR\n        install_plugin[Install Istio CNI plugin]\n        update_config[Update node CNI config at \/etc\n\n\/cni\/net.d]\n        monitor_paths[Monitor plugin and config paths]\n        \n        subgraph sidecar_mode[\u0022Sidecar Mode\u0022]\n            sidecar_setup[Configure iptables for pods]\n        end\n        \n        subgraph ambient_mode[\u0022Ambient Mode\u0022]\n            ambient_server[Ambient Watch Server]\n            sync_events[Synchronize pod events]\n            configure_iptables[Configure iptables within pods]\n        end\n\n        install_plugin --\u003e update_config\n        update_config --\u003e monitor_paths\n        monitor_paths --\u003e sidecar_mode\n        monitor_paths --\u003e ambient_mode\n        ambient_mode --\u003e ambient_server\n        ambient_server --\u003e sync_events\n        sync_events --\u003e configure_iptables\n    end\n\u0060\u0060\u0060\n\n![Mermaid Diagram](f9aacefbdd8fb77216546b53eda78079.svg)\n\n- **Istio CNI Node Agent** acts as an agent installed on each node.\n- It installs the Istio CNI plugin and updates the node’s CNI configuration.\n- The agent monitors the CNI plugin and config paths for changes.\n- In **Sidecar Mode**, it handles sidecar networking setups using iptables for pods.\n- In **Ambient Mode**, it synchronizes pod events to an ambient watch server, which then configures iptables within pods.\n- Nodes require elevated privileges like \u0060CAP_SYS_ADMIN\u0060, \u0060CAP_NET_ADMIN\u0060, and \u0060CAP_NET_RAW\u0060 to function in either mode.\n\n## Resolving Conflicts Between Istio Ambient Mode and Kubernetes CNI\n\nIstio\u0027s Ambient Mode is designed to adapt to all CNIs, transparently handling traffic redirection within pods using ztunnel without affecting existing CNI configurations. In this mode, Ambient Mode manages traffic through ztunnel to flow through the Istio service mesh, while standard CNIs focus on providing standardized network access for pods.\n\nThe primary responsibilities of CNI are to address network connectivity between Kubernetes Pods, such as assigning IP addresses and forwarding packets. In contrast, Ambient Mode needs to import traffic into ztunnel, which may be incompatible with CNI\u0027s network configuration. The main issues include:\n\n- Mainstream CNI network configurations may conflict with Istio\u0027s CNI extensions, causing interruptions in traffic processing.\n- Using Istio CNI may affect the execution of these policies if the deployed network policies depend on CNI.\n\nTo address these issues, traffic redirection is managed by running ztunnel in the same user space as the pod, avoiding conflicts with the kernel space modified by CNI. Thus, pods can connect directly to ztunnel, bypassing the influence of CNI.\n\nThe following sequence diagram describes the process under Ambient mode:\n\n\u0060\u0060\u0060mermaid\nsequenceDiagram\n    participant K8s_API as Kubernetes API\n    participant Plugin as CNI Plugin\n    participant Agent as Ambient CNI Agent\n    participant Server as Ambient Watch Server\n    participant Ztunnel as ztunnel\n\n    Plugin-\u003e\u003eAgent: CmdAdd (Pod scheduled)\n    Agent-\u003e\u003eServer: Notify new pod\n    Server-\u003e\u003eK8s_API: Retrieve Pod Info\n    K8s_API--\u003e\u003eServer: Pod Details\n    Server-\u003e\u003eZtunnel: Setup iptables\n    Ztunnel-\u003e\u003eServer: Confirm Setup\n    Server-\u003e\u003eAgent: Configuration Complete\n    Agent-\u003e\u003ePlugin: CmdDel (Pod removed)\n    Server-\u003e\u003eZtunnel: Remove iptables\n    Ztunnel--\u003e\u003eServer: Confirmation\n\u0060\u0060\u0060\n\n![Mermaid Diagram](aa0472b4061c1a2ca71146c3243d2318.svg)\n\n- **Ambient CNI Agent** initiates interactions by listening for UDS events signaling pod creations.\n- **Ambient Watch Server** modifies iptables within pods to redirect traffic to ztunnel as needed.\n\n- **ztunnel** establishes connections and handles network traffic redirection within the Kubernetes cluster.\n\n## Resolving Conflicts Between Istio Ambient Mode and Kubernetes CNI\n\nTo mitigate these conflicts, Istio\u0027s Ambient Mode avoids dependencies on the kernel space modified by CNI:\n\n- **Run ztunnel in user space**: This strategy allows ztunnel to run in the same user space as the pod, avoiding direct conflicts with CNI.\n- **Ensure CNI compatibility**: Istio CNI configurations must be carried out without affecting existing CNI plugin configurations, ensuring normal communication between pods and traffic management.\n\nThese measures help Istio\u0027s Ambient Mode effectively manage traffic between services without disrupting existing CNI plugins.\n\n## Optimized Traffic Management with Istio Ambient Mode\n\nIstio\u0027s Ambient Mode employs an advanced traffic forwarding mechanism through **node-local Ztunnel**, allowing for the establishment of listening sockets within a Pod\u0027s network namespace. This setup facilitates effective redirection of encrypted (mTLS) and plaintext traffic originating from the service mesh. Not only does this approach enhance the flexibility of traffic management, but it also prevents potential conflicts with existing CNI plugins. Below is a detailed implementation flow of this mode:\n\n\u0060\u0060\u0060mermaid\ngraph TD\n    subgraph Kubernetes Cluster\n    A[Pod with istio.io\/dataplane-mode=ambient] --\u003e|Detected| B(istio-cni node agent)\n    B --\u003e C{Pod Status}\n    C --\u003e|Newly Started| D[CNI Plugin Triggered]\n    C --\u003e|Already Running| E[New Pod Event]\n    D \u0026 E --\u003e F[Configure Redirection]\n    F --\u003e|Enters Pod\u0027s Network Namespace| G[Establish Network Redirection]\n    G --\u003e H[Notify Node Ztunnel]\n    H --\u003e|Creates Listening Sockets in Pod\u0027s Namespace| I[Node-local Ztunnel Proxy Instance]\n    I --\u003e J[Traffic Redirection Established]\n    end\n\n    J --\u003e K{Traffic Type}\n    K --\u003e|mTLS| L[Encrypted Traffic Within Mesh]\n    K --\u003e|Plaintext| M[Handling Plaintext Traffic]\n\u0060\u0060\u0060\n\n![Mermaid Diagram](82841d7a95a98947c4ec6c7113c2ffb0.svg)\n\nThe specific steps involved are as follows:\n\n1. **Detection of Tags**: The Istio CNI node agent detects Pods tagged with \u0060istio.io\/dataplane-mode=ambient\u0060.\n2. **Triggering the CNI Plugin**: Based on Pod events (either a new start or an existing Pod joining the mesh), the CNI plugin is triggered, leading the Istio CNI node agent to configure traffic redirection.\n3. **Configuring Redirection Rules**: Network redirection rules are set up within the Pod’s network namespace to intercept and redirect traffic to the node-local ztunnel proxy.\n4. **Establishment of Listening Sockets**: The node-local ztunnel creates listening sockets within the Pod\u0027s network namespace to enable traffic redirection.\n5. **Traffic Handling**: The node-local ztunnel handles encrypted (mTLS) and plaintext traffic within the mesh, ensuring secure and efficient data transfer.\n\nThrough this approach, Istio Ambient Mode provides a more effective and secure solution for managing inter-service traffic in Kubernetes environments.\n\n## Conclusion\n\nThis article thoroughly analyzes the design principles, implementation, and advantages of the Istio CNI plugin, particularly how Istio CNI addresses the permission and security issues present in traditional \u0060istio-init\u0060 methods. Through these innovations, Istio has made significant progress in network security and operational simplicity, providing a more flexible and efficient method for implementing Istio in Kubernetes environments.\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-cni-unveiled-streamlining-service-mesh-connectivity\/) .*\n', '\/en\/blog\/istio-cni-deep-dive\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article provides a detailed explanation of the design principles, implementation methods, and how to enhance security and permission management through Ambient Mode in the Istio CNI plugin.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-introduction/">Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API', 'This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.', '\nSelecting the right networking tool in a Kubernetes environment is crucial. According to [Tetrate\u0027s discussion](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/), the choice depends on the type of network traffic: north-south or east-west. For services primarily handling external requests, Envoy Gateway is the ideal choice. It not only efficiently manages traffic but also seamlessly integrates as you transition to a microservices architecture.\n\nThis article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.\n\n## Overview of Envoy Gateway and its Role in Service Mesh\n\nEnvoy Gateway is a Kubernetes-native API gateway built around Envoy Proxy. It aims to lower the barrier for users adopting Envoy as an API gateway and lays the foundation for vendors to build value-added products like [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/).\n\nEnvoy Gateway is not only an ideal choice for managing north-south traffic but also serves as a crucial component for connecting and securing services within the service mesh. It enhances communication efficiency and security among microservices by providing features such as secure data transmission, traffic routing, load balancing, and fault recovery. Leveraging its built-in Envoy Proxy technology, Envoy Gateway can handle a large number of concurrent connections and complex traffic management policies while maintaining low latency and high throughput.\n\nFurthermore, the tight integration of Envoy Gateway with the Kubernetes Gateway API allows for declarative configuration and management, significantly simplifying the deployment and update processes of gateways within the service mesh. This integration not only improves operational efficiency but also enables Envoy Gateway to seamlessly collaborate with solutions like Istio without adding extra complexity.\n\nThe figure below illustrates the relationship between Envoy Gateway and the service mesh.\n\n\u0060\u0060\u0060mermaid\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes Cluster\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022Services\u0022]\n        pods[\u0022Pods\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022Manages North-South Traffic\u0022 --\u003e svcs\n        eg -- \u0022Configured by\u0022 --\u003e gwapi\n        gwapi -. \u0022Defines routing specs\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022Service Mesh\u0022]\n        smc[\u0022Service Mesh Control Plane (e.g., Istio, Linkerd)\u0022]\n        smp[\u0022Service Mesh Data Plane (Envoy Sidecars)\u0022]\n        smc -- \u0022Configures\u0022 --\u003e smp\n        smp -- \u0022Handles East-West Traffic\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022Part of\u0022 .-\u003e SM\n    svcs -- \u0022Connects to\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Mermaid Diagram](17a407873a0c96afbde9bb6b252814d4.svg)\n\n\n\nIn a Kubernetes cluster, Envoy Gateway is responsible for managing north-south traffic, i.e., traffic entering and leaving the cluster, and is configured through the Kubernetes Gateway API, which defines routing specifications for services. Services within the cluster directly connect to pods. In the service mesh, the control plane (e.g., Istio or Linkerd) configures Envoy sidecars in the data plane, which handles east-west traffic within the cluster. In this system, Envoy Gateway can collaborate with the service mesh, but they independently manage traffic in different directions.\n\nThink of Envoy Gateway as the main entry point to a city (e.g., customs), where all traffic (like various vehicles) must pass through. It acts as a strict gatekeeper, responsible for inspection and guidance, ensuring each packet (like each passenger) is accurately delivered to its destination. In the city of Kubernetes, Envoy Gateway manages all inbound traffic, ensuring data flows securely and efficiently into the city and is accurately delivered to services within the city.\n\nOnce inside the city, the service mesh takes over, acting as a series of transportation networks within the city. Envoy sidecars in the service mesh are like taxis or buses within the city, responsible for transporting packets from the port to their specific destinations within the city. Envoy Gateway ensures smooth entry for external requests, and then the service mesh efficiently handles these requests within the cluster.\n\nThe support for Kubernetes Gateway API by Envoy Gateway can be seen as a significant upgrade to our city\u0027s traffic signal system. It not only provides clearer and more personalized guidance for incoming data flows but also makes the entire city\u0027s traffic operations more intelligent.\n\n## Core Features and Advantages of Envoy Gateway\n\nEnvoy Gateway offers several core features that make it a prominent choice for an API gateway:\n\n- **Simplified Configuration**: Through direct integration with the Kubernetes Gateway API, Envoy Gateway allows developers to use Kubernetes custom resources to declaratively configure routing rules, security policies, and traffic management.\n- **Performance and Scalability**: Built on battle-tested Envoy Proxy, it delivers outstanding performance and scalability, effortlessly handling thousands of services and millions of requests per second.\n- **Security Features**: Built-in support for various security measures such as SSL\/TLS termination, OAuth2, OIDC authentication, and fine-grained access control.\n- **Observability**: Provides comprehensive monitoring capabilities including detailed metrics, logs, and tracing, crucial for diagnosing and understanding traffic behavior.\n\n## Relationship with Gateway API\n\nThe introduction of the Gateway API in Kubernetes provides a powerful new way to integrate and configure ingress gateways, offering higher flexibility and functionality compared to traditional ingress. As discussed in [this blog](https:\/\/tetrate.io\/blog\/introducing-the-gateway-api\/), the Gateway API simplifies gateway management, allowing developers to define custom routing rules, TLS termination policies, and traffic policies using Kubernetes-native resources.\n\nThe Kubernetes Gateway API serves as the cornerstone of Envoy Gateway, providing a more expressive, flexible, and role-based approach to configuring gateways and routes within the Kubernetes ecosystem. This API offers custom resource definitions (CRDs) such as GatewayClass, Gateway, HTTPRoute, etc. Envoy Gateway utilizes these resources to create a user-friendly and consistent configuration model that aligns with Kubernetes\u0027 native principles.\n\n{{\u003ccallout note \u0022What is an API Gateway?\u0022\u003e}}\n\nAn API Gateway is a comprehensive management and hosting service for APIs. Serving as an intermediary layer between applications and backend services, it not only handles lifecycle events like creation, maintenance, deployment, running, and retiring but also performs additional critical functions. A robust API Gateway should provide the following features to enhance and extend its basic definition:\n\n1. **Traffic Control**: Ability to manage and control traffic to backend services, including request routing, load balancing, circuit breaking, and rate limiting, ensuring the stability and high availability of backend services.\n2. **Security Assurance**: Authentication, authorization, and encryption capabilities to effectively manage and protect API security. This involves authentication mechanisms, API key management, OAuth, JWT, mTLS, etc., ensuring that only authorized users and services can access the API.\n3. **Monitoring and Analytics**: Real-time monitoring and logging functionalities to track API usage, performance metrics, anomaly detection, and traffic pattern analysis, optimizing API performance and responsiveness.\n4. **Change Management**: Support for managing API changes, including version control and progressive deployment (such as blue-green or canary release), for seamless transition to new versions while minimizing impact on end users.\n5. **Request and Response Transformation**: Allow transformation of incoming and outgoing API calls, such as from REST to GraphQL, or adding, removing, and modifying request and response headers.\n6. **Cross-Origin Resource Sharing (CORS) Support**: Manage and control cross-origin requests, allowing frontend applications from different domains to securely call backend APIs.\n7. **Quotas and Billing**: Set quota limits for API usage, while also supporting billing functionalities for commercialized API offerings.\n8. **Developer-Friendly Developer Portal**: Provide a developer-facing portal, enabling third-party developers to easily discover, test, and integrate APIs.\n9. **Protocol Support**: Support for various network protocols, including HTTP\/HTTPS, WebSocket, gRPC, etc., ensuring compatibility with a variety of clients and services.\n10. **Plug-ability and Extensibility**: Allow extension of API Gateway functionality through plugins or middleware, enabling flexible adaptation to various middleware services based on business requirements.\n11. **Service Governance**: Integration with service registration and discovery mechanisms to accommodate the dynamics of services in a microservices architecture.\n\nIn conclusion, the role of an API Gateway extends far beyond simple API lifecycle management. It is a key component in realizing microservices architecture, ensuring service security, improving operational efficiency, and optimizing user experience. Through these extensive functionalities, the API Gateway becomes an indispensable part of modern cloud-native applications.\n\n{{\u003c\/callout\u003e}}\n\n## Overview of Envoy Gateway Architecture\n\nThe architecture of Envoy Gateway is designed to be lightweight and concise. It consists of a control plane that dynamically configures an Envoy proxy running as the data plane. This separation of concerns ensures that the gateway can scale with increasing traffic without affecting the efficiency of the control plane.\n\nThe architecture diagram of Envoy Gateway is shown below.\n\n![Envoy Gateway Architecture Diagram](envoy-gateway-arch.svg)\n\nAt the core of this architecture is the Envoy Gateway, which is an instance of the Envoy proxy responsible for handling all traffic in and out of the Kubernetes cluster. Upon initial startup, Envoy Gateway provides static configuration through configuration files, establishing the basic parameters of its operation.\n\nThe dynamic aspect of Envoy Gateway configuration is handled by providers, which define the interaction between the gateway and Kubernetes or other dynamic configuration input sources. The resource monitor is responsible for monitoring changes to Kubernetes resources, with particular attention to CRUD operations related to custom resource definitions (CRDs).\n\nAs changes occur, resource transformers intervene to translate these external resources into a form understandable by Envoy Gateway. This transformation process is further facilitated by provider-specific infrastructure managers, which are responsible for managing resources related to specific clouds or infrastructure providers, shaping the infrastructure into an intermediate representation crucial for the gateway\u0027s functionality.\n\nThis intermediate representation then transforms into the xDS intermediate representation, serving as the precursor to the final xDS configuration understood and executed by Envoy. The xDS translator plays the role of converting this intermediate representation into specific xDS configurations.\n\nThese configurations are delivered and executed by xDS servers, which act as services diligently managing Envoy instances based on the xDS configurations they receive. As the actual running proxy, Envoy ultimately receives these configurations from xDS servers, interprets them, and implements them to effectively manage traffic requests.\n\nUltimately, all requests are redirected to the final destination of Envoy Gateway routes for traffic, which are the backend services.\n\n## Comparison with Other Gateways\n\nCompared to other popular solutions such as Istio\u0027s Ingress Gateway or NGINX Ingress, Envoy Gateway stands out with its native integration with Kubernetes and its focus on leveraging the full potential of Envoy. The table below compares various open-source API gateways from multiple aspects.\n\n| **API Gateway** | **Supported Authentication \u0026 Authorization Strategies**      | **Supported Service Discovery Components** | **Supported Protocols**          | **Control Plane Configuration Distribution Method** | **Supported Plugin Extension Mechanism** | **Foundation Affiliation** |\n| --------------- | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------- | --------------------------------------------------- | ---------------------------------------- | -------------------------- |\n| Envoy Gateway   | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                            | HTTP, HTTPS, gRPC                | xDS                                                 | Envoy Filter Based                       | CNCF                       |\n| Kuma            | mTLS, JWT                                                    | Kubernetes, Consul                         | HTTP, HTTPS, gRPC, TCP           | REST, gRPC                                          | Lua, Go Based                            | CNCF                       |\n| NGINX Ingress   | RBAC                                                         | Kubernetes                                 | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD                                      | Nginx Module Based                       | N\/A                        |\n| APISIX          | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID, and others | Kubernetes, DNS, Consul, Nacos, Eureka     | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI                                   | Lua, Wasm Based                          | Apache Software Foundation |\n| Kong            | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                    | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI                                  | Lua Based                                | N\/A                        |\n| Emissary        | Basic Auth                                                   | Kubernetes                                 | HTTP, HTTPS, gRPC                | Kubernetes CRD                                      | Lua, Go Based                            | CNCF                       |\n\n## Quick Start with Envoy Gateway\n\nTo quickly get started with Envoy Gateway, you can set up a local experimental environment using the following simplified steps. First, start a local Kubernetes cluster:\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\nNext, deploy the Gateway API CRD and Envoy Gateway itself:\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\nThen, install the gateway configuration and deploy a sample application:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\nTo expose the LoadBalancer service, here we use port forwarding as an example. You can also choose to use \u0060minikube tunnel\u0060 or install [MetalLB](https:\/\/metallb.universe.tf\/installation\/) as a load balancer:\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\nTest if your Envoy Gateway is working properly with the following command:\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\nFor more detailed installation and configuration steps, visit the Envoy Gateway website. With these steps, you can quickly start exploring the capabilities of Envoy Gateway.\n\n## Conclusion\n\nEnvoy Gateway not only optimizes Layer 7 gateway configuration in the cloud-native era but also provides a smooth transition from edge gateways to service meshes. As the promotion of service meshes faces some challenges, such as the intrusiveness to applications and issues driving by operations teams, edge gateways are more readily accepted by development teams. Envoy Gateway, with its simplified Kubernetes Gateway API, enhances traffic management and observability capabilities. Additionally, the transition from Envoy Gateway to Istio is a confident technical advancement for teams already familiar with Envoy features, supporting seamless switching from the standard Kubernetes Gateway API to Istio Ingress Gateway or continuing to collaborate with Istio as a custom solution. These features make Envoy Gateway a gateway choice worth investing in the cloud-native era.\n\nStay tuned for the subsequent parts of this blog series, where we will delve into configuring and optimizing Envoy Gateway, providing practical guides, and showcasing a wider range of real-world use cases.\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/envoy-microservices-overview\/).\n', '\/en\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it&#39;s the ideal choice for exposing services to the public internet.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-ambient-mode-limitations/">Analysis of the Limitations of Istio Ambient Mode</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Analysis of the Limitations of Istio Ambient Mode', 'In-depth discussion on the Ambient mode in Istio 1.22, comparison with the traditional Sidecar mode, and its limitations.', '\n[Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) marks the official beta release of Ambient mode, accompanied by a blog titled [Say goodbye to your sidecars: Istio\u0027s ambient mode reaches Beta in v1.22](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/), claiming that Layer 4 and Layer 7 features are now production-ready. This milestone was actually announced by the community at KubeCon EU a month earlier. Such exciting promotion seems to suggest that we can completely abandon the Sidecar mode, but is this really the case?\n\n### Why Not Hurry to Say Goodbye to Sidecar Mode?\n\nWhile I am open to new technologies, it may be premature to completely abandon the Sidecar mode. Each mode has its specific application scenarios, advantages, and disadvantages. Below, I will share in detail some of the limitations of the Ambient mode compared to the Sidecar mode, to help everyone better understand the differences between the two.\n\n### Key Differences Between Ambient Mode and Sidecar Mode\n\n#### Traffic Management\n\nThe L7 traffic management support in Ambient mode is not yet mature and production-ready. In contrast, Sidecar mode is more stable and reliable in this regard.\n\n#### Security\n\nIn Ambient mode, mTLS is enforced at the namespace level, whereas Sidecar mode gives users more flexibility to choose whether to enable mTLS. This flexibility is particularly important for certain application scenarios.\n\n#### Observability\n\nFor L7 layer telemetry data, it remains questionable whether Ambient mode can provide precise monitoring and tracing for each pod as effectively as Sidecar mode. Sidecar mode has been widely validated in terms of observability and is more mature.\n\n#### Operations\n\nIn terms of deployment, Ambient mode recommends using Helm and only supports the Kubernetes platform, while Sidecar mode also supports VMs and hybrid cloud environments. Additionally, Ambient mode has not yet received official support from major cloud vendors. During upgrades, Ambient mode has a larger blast radius and currently does not support canary releases, recommending blue-green deployments instead. There is still a lack of best practices for migrating from Sidecar mode to Ambient mode or coexisting with both.\n\n#### Extensibility\n\nCurrently, support for Wasm plugins in Ambient mode is still unclear, whereas Sidecar mode already has relatively complete support in this area.\n\n#### Other Functional Features\n\nWhile Dual Stack mode is still experimental in Sidecar mode, it has at least some implementation, whereas it remains unclear whether Ambient mode supports this feature.\n\n### Conclusion\n\nAlthough Istio 1.22 brings the exciting Ambient mode, we need to carefully consider these limitations and differences before completely saying goodbye to Sidecar mode. Each mode has its unique advantages and applicable scenarios, and users should make informed choices based on their own needs. I will continue to test and track Ambient mode, so stay tuned to this blog for more in-depth analysis.', '\/en\/blog\/istio-ambient-mode-limitations\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In-depth discussion on the Ambient mode in Istio 1.22, comparison with the traditional Sidecar mode, and its limitations.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/tetrate-vulnerability-scaner/">TVS: Istio and Envoy CVE Scanning Solution</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Apr 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('TVS: Istio and Envoy CVE Scanning Solution', 'This article will introduce Tetrate’s newly launched tool – Tetrate Vulnerability Scanner (TVS), a CVE scanner customized for Istio and Envoy. ', '\nThis article will introduce Tetrate’s newly launched tool – [Tetrate Vulnerability Scanner (TVS)](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/), a CVE scanner customized for Istio and Envoy. Before diving into the specific features of TVS, let’s briefly review the concept of CVE and its core role in software security.\n\n## Overview of CVE\n\nCVE (Common Vulnerabilities and Exposures) is a public vulnerability database maintained by MITRE Corporation. It provides a standardized way to reference vulnerabilities in open-source software. Each CVE record has an identifier, description, and at least one public reference. CVE does not provide severity ratings for vulnerabilities. CVEs are not only an important resource for cybersecurity professionals but also a tool for developers and organizations to receive critical security updates. CVE Numbering Authorities (CNAs) are an integral part of the CVE program, assigning unique IDs to new CVEs. These IDs help find information related to vulnerabilities, including severity ratings (maintained by NIST’s NVD), affected software systems, and steps for remediation and damage control. For example, the well-known Log4j vulnerability in 2021 ([CVE-2021-44228](https:\/\/www.cve.org\/CVERecord?id=CVE-2021-44228)) had a severity rating of 10 due to its wide impact.\n\n### Practical Scenarios for CVEs\n\nIntegrating CVE scanning into CI\/CD pipelines is a common practice aimed at automatically identifying and preventing code with known vulnerabilities from entering the main branch. This approach helps ensure that applications do not rely on third-party packages or libraries with security vulnerabilities, enhancing application security. For example, GitHub’s [Dependabot](https:\/\/docs.github.com\/en\/code-security\/supply-chain-security\/understanding-your-software-supply-chain\/about-supply-chain-security#what-is-dependabot) can automatically detect CVEs in project dependencies and suggest fixes, making it an effective tool for maintaining project security. You may receive CVE notifications like [jQuery Cross-Site Scripting vulnerability](https:\/\/github.com\/advisories\/GHSA-257q-pv89-v3xv) whenever there is a vulnerability in your PR or commit. Then, you can choose to tolerate the vulnerability or apply a patch.\n\n## What is TVS?\n\nIstio often releases CVE notices on its official website, such as [ISTIO-SECURITY-2024-001](https:\/\/istio.io\/latest\/news\/security\/istio-security-2024-001\/). Previously, you had to track these notices manually, but now you can automate CVE scanning tasks with TVS, significantly reducing the workload of security teams.\n\nThe following figure shows the result of TVS.\n\n![TVS CLI](tvs.jpg)\n\nCurrently, TVS only provides a command-line tool, and it will be integrated as a service into TIS in the future.\n\nThe following diagram illustrates the workflow of TVS.\n\n\u0060\u0060\u0060mermaid \u0022TVS Workflow\u0022\ngraph TD\n    A([Start]) --\u003e B(Istio Containers Installed)\n    B --\u003e C(Collect SHA Digests)\n    C --\u003e D(Send Digests to Tetrate\u0027s APIs)\n    D --\u003e E{Is CVE Detected?}\n    E --\u003e|Yes| F[Log SHA Digests Without Personal Info]\n    E --\u003e|No| G[End, No Action Required]\n    F --\u003e H[Notify Users]\n    H --\u003e I[Apply Patches\/Workarounds]\n    I --\u003e J([End])\n\u0060\u0060\u0060\n\n![TVS Workflow](9232ba9319ac498b7fcf50bb60bff86b.svg)\n\n\n\n1. Begins after Istio installation.\n2. Collects SHA digests of installed Istio containers.\n3. Sends digests to Tetrate’s API.\n4. API detects CVE presence.\n   - If CVE is detected, logs SHA digests without personal information and notifies users.\n   - If no CVE is detected, no action is required.\n5. Upon receiving notification, users apply patches or mitigations.\n6. Process ends.\n\nTVS is available for free download and use by everyone. However, registration is required before performing CVE scans, as outlined in the [TIS documentation](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/).\n\n## Supply Chain Security Recommendations\n\nA [report](https:\/\/www.slim.ai\/blog\/container-report-2023) indicates that even the latest versions of the most popular containers have hundreds of CVEs.\n\nHere are some recommendations for ensuring security:\n\n- Start vulnerability scanning and remediation early, rather than waiting until the end.\n- Integrate vulnerability scanning tools into CI\/CD.\n- Regularly update Istio and Envoy to the latest versions.\n- Use Istio’s officially released [distroless images](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/security\/harden-docker-images\/) or [TID](https:\/\/docs.tetrate.io\/istio-distro\/) to reduce the attack surface and minimize vulnerabilities.\n- Follow the [best practices for the software supply chain](https:\/\/github.com\/cncf\/tag-security\/blob\/main\/supply-chain-security\/supply-chain-security-paper\/sscsp) introduced by CNCF.\n- Follow [Istio security best practices](https:\/\/istio.io\/latest\/docs\/ops\/best-practices\/security\/).\n\n## Unique Value of TVS\n\nTVS provides a convenient CVE scanning operation through its command-line tool and is planned to be integrated into Kubernetes and Tetrate Istio Subscription (TIS) in the future to further simplify CVE management processes for Istio and Envoy. TIS provides CVE patches and backward compatibility support for up to 14 months from the Istio release, helping users get security updates on time while keeping the system stable.\n\nTVS is freely available for all users to download and use, with simple registration required before performing CVE scans. Additionally, you can register on the [Istio and Envoy alerts and patches page](https:\/\/tetrate.io\/register-for-istio-and-envoy-security-bulletins\/) to receive CVE notifications and patches as soon as they are available. For more information, refer to the [TIS documentation](https:\/\/docs.tetrate.io\/istio-subscription\/tools\/tvs\/).\n\nBy adopting TVS, an automated CVE scanning tool, enterprises can more effectively identify and address security vulnerabilities in Istio and Envoy, enhance infrastructure security, and reduce the burden on security teams, thereby promoting efficient security management processes.\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/tvs-istio-and-envoy-cve-scanning-solution\/) .*\n', '\/en\/blog\/tetrate-vulnerability-scaner\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will introduce Tetrate’s newly launched tool – Tetrate Vulnerability Scanner (TVS), a CVE scanner customized for Istio and Envoy. </p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/istio/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/en/tags/istio/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/istio/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/4/" class="page-link">
             4
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
             
           
         
         
         
       
       
       
       
         <li class="page-item">
           <a href="/en/tags/istio/page/5/" class="page-link">
             5
           </a>
         </li>
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
       
       
       
         
         
         
           
           
         
         
         
       
       
       
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/istio/page/3/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/istio/page/7/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(51)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-packet-lifecycle-optimization/">Packet Lifecycle and Traffic Optimization in Istio Ambient Mode</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
