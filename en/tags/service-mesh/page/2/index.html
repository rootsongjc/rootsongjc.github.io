<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.145.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                Resources
              </a>
              <div class="dropdown-menu">
                
                <a class="dropdown-item" href="/en/book">Books</a>
                
                <a class="dropdown-item" href="/en/slide">Slides</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/service-mesh/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/beyond-istio-oss/">The Current State and Future of the Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 18, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Current State and Future of the Istio Service Mesh', 'This article explains the background of Istio\u0027s birth, its position in the cloud-native technology stack, and the development direction of Istio.', '\nThis article reviews the development of Istio open source in the past five years and looks forward to the future direction of Istio. The main points of view in this article are as follows:\n\n- Due to the popularity of Kubernetes, microservices, DevOps, and cloud-native architectures, the rise of service mesh technology.\n- The rise of Kubernetes and programmable proxies has laid the technical groundwork for Istio\u0027s implementation.\n- While eBPF can accelerate transparent traffic hijacking in Istio, it can not replace sidecars in service meshes.\n- The future of Istio is to build a zero-trust network.\n\nNext, we start this article with the background of the birth of Istio.\n\n## The eve of the birth of Istio\n\nSince 2013, with the explosion of the mobile Internet, enterprises have had higher requirements for the efficiency of application iteration. Application architecture has begun to shift from monolithic to microservices, and DevOps has also become popular. In the same year, with the open source of Docker, the problems of application encapsulation and isolation were solved, making it easier to schedule applications in the orchestration system. In 2014, Kubernetes and Spring Boot were open-sourced, and Spring framework development of microservice applications became popular. In the next few years, a large number of RPC middleware open source projects appeared, such as Google released gRPC 1.0 in 2016. The service framework is in full bloom. In order to save costs, increase development efficiency, and make applications more flexible, more and more enterprises are migrating to the cloud, but this is not just as simple as moving applications to the cloud. In order to use cloud computing more efficiently, a set of \u0022cloud native\u0022 methods and concepts are also on the horizon.\n\n## Istio Open Source Timeline\n\nLet\u0027s briefly review the major events of Istio open source:\n\n- **September 2016**: Since Envoy is an important part of Istio, Istio\u0027s open source timeline should have an Envoy part. At first, Envoy was only used as an edge proxy inside Lyft, and it was verified in large-scale production inside Lyft before Envoy was open sourced. In fact, Envoy was open sourced before it was open sourced, and it got the attention of Google engineers. At that time, Google was planning to launch an open source project of service mesh, and initially planned to use Nginx as a proxy. In 2017, Envoy donated to [CNCF](https:\/\/cncf.io\/).\n- **May 2017**: Istio was announced as open source by Google, IBM, and Lyft. The microservices architecture was used from the beginning. The composition of the data plane, control plane, and sidecar pattern were determined.\n- **March 2018**: Kubernetes successfully became the first project to graduate from CNCF, becoming more and more \u0022boring\u0022. The basic API has been finalized. In the second edition, CNCF officially wrote the service mesh into the cloud native first definition. The company I currently work for, [Tetrate](https:\/\/tetrate.io\/), was founded by the Google Istio team.\n- **July 2018**: Istio 1.0 is released, billed as \u0022production ready\u0022.\n- **March 2020**: Istio 1.5 was released, the architecture returned to a monolithic application, the release cycle was determined, a major version was released every three months, and the API became stable.\n- **From 2020 to the present**: The development of Istio mainly focuses on Day 2 operation, performance optimization, and extensibility. Several open source projects in the Istio ecosystem have begun to emerge, such as [Slime](https:\/\/github.com\/slime-io\/slime\/), [Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki), and [Merbridge](https:\/\/github.com\/merbridge\/merbridge).\n\n## Why did Istio come after Kubernetes?\n\nThe emergence mentioned here refers to the birth of the concept of \u0022service mesh\u0022. After microservices and containerization, the increase in the use of heterogeneous languages, the surge in the number of services, and the shortened life cycle of containers are the fundamental reasons for the emergence of service meshes.\n\nTo make it possible for developers to manage traffic between services with minimal cost, Istio needs to solve three problems:\n\n1. Transparent traffic hijacks traffic between applications, which means that developers can quickly use the capabilities brought by Istio without modifying applications.\n1. Another point is the operation and maintenance level; how to inject the proxy into each application and manage these distributed sidecar proxies efficiently.\n1. An efficient and scalable sidecar proxy that can be configured through an API.\n\nThe above three conditions are indispensable for the Istio service mesh, and we can see from them that these requirements are basically the requirements for the sidecar proxy. The choice of this proxy will directly affect the direction and success of the project.\n\nIn order to solve the three problems above, Istio chose:\n\n1. Container Orchestration and Scheduling Platform: Kubernetes\n1. Programable proxy: Envoy\n\nFrom the figure below, we can see the transition of the service deployment architecture from Kubernetes to Istio, with many changes and constants.\n\n![Schematic diagram of the architectural change from Kubernetes to Istio](kubernetes-to-istio.svg)\n\nFrom Kubernetes to Istio, in a nutshell, the deployment architecture of the application has the following characteristics:\n\n- Kubernetes manages the life cycle of applications, specifically, application deployment and management (scaling, automatic recovery, and release).\n- Automatic sidecar injection based on Kubernetes to achieve transparent traffic interception. First, the inter-service traffic is intercepted through the sidecar proxy, and then the behavior of the microservice is managed through the control plane configuration. Nowadays, the deployment mode of service mesh has also ushered in new challenges. A sidecar is no longer necessary for Istio service mesh. The proxyless service mesh based on gRPC is also being tested.\n- The service mesh decouples traffic management from Kubernetes, and the traffic inside the service mesh does not need the support of the kube-proxy component. Through the abstraction close to the microservice application layer, the traffic between services is managed to achieve security and observability functions.\n- The control plane issues proxy configuration to the data plane through the xDS protocol. The proxies that have implemented xDS include [Envoy](https:\/\/envoyproxy.io\/) and the open source [MOSN](https:\/\/mosn.io\/).\n- When a client outside the Kubernetes cluster accesses the internal services of the cluster, it was originally through [Kubernetes Ingress](https:\/\/tetrate.io\/learn\/kubernetes\/what-is-kubernetes-ingress\/), but after Istio is available, it will be accessed through Gateway.\n\n### Transparent traffic hijacking\n\nIf you are using middleware such as gRPC to develop microservices, after integrating the SDK into the program, the interceptor in the SDK will automatically intercept the traffic for you, as shown in the following figure.\n\n![Interceptor diagram of gRPC](grpc.svg)\n\nHow to make the traffic in the Kubernetes pod go through the proxy? The answer is to inject a proxy into each application pod, share the network space with the application, and then modify the traffic path within the pod so that all traffic in and out of the pod goes through the sidecar. Its architecture is shown in the figure below.\n\n![Diagram of transparent traffic hijacking in Istio](istio-route-iptables.svg)\n\nFrom the figure, we can see that there is a very complex set of iptables traffic hijacking logic. The advantage of using iptables is that it is applicable to any Linux operating system. But this also has some side effects:\n\n1. All services in the Istio mesh need to add a network hop when entering and leaving the pod. Although each hop may only be two or three milliseconds, as the dependencies between services and services in the mesh increase, this latency may increase significantly, which may not be suitable for service meshes for services that pursue low latency.\n1. Because Istio injects a large number of sidecars into the data plane, especially when the number of services increases, the control plane needs to deliver more Envoy proxy configurations to the data plane, which will cause the data plane to occupy a lot of system memory and network resources.\n\nHow to optimize the service mesh in response to these two problems?\n\n1. Use proxyless mode: remove the sidecar proxy and go back to the SDK.\n1. Optimize the data plane: reduce the frequency and size of proxy configurations delivered to the data plane.\n1. eBPF: it can be used to optimize network hijacking.\n\nThis article will explain these details in the section on performance optimization later on.\n\n### Sidecar operation and maintenance management\n\nIstio is built on top of Kubernetes, which can leverage Kubernetes\u0027 container orchestration and lifecycle management to automatically inject sidecars into pods through admission controllers when Kubernetes creates pods. \n\nIn order to solve the resource consumption problem of Sidecar, some people have proposed four deployment modes for the service mesh, as shown in the following figure.\n\n![Schematic diagram of four deployment modes of service mesh](deployment-model.svg)\n\nThe following table compares these four deployment methods in detail. Each of them has advantages and disadvantages. The specific choice depends on the current situation.\n\n{{\u003ctable \u0022Comparison of four deployment modes of service mesh\u0022\u003e}}\n\n| **Mode**                                 | **Memory overhead**                                          | **Security**                                                 | **Fault domain**                                             | **Operation and maintenance**                                |\n| :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **Sidecar proxy**                        | The overhead is greatest because a proxy is injected per pod. | Since the sidecar must be deployed with the workload, it is possible for the workload to bypass the sidecar. | Pod-level isolation, if the proxy fails, only the workload in the Pod is affected. | A workload\u0027s sidecar can be upgraded independently without affecting other workloads. |\n| **Node sharing proxy**                   | There is only one proxy on each node, shared by all workloads on that node, with low overhead. | There are security risks in the management of encrypted content and private keys. | Node-level isolation, if a version conflict, configuration conflict, or extension incompatibility occurs when a shared proxy is upgraded, it may affect all workloads on that node. | There is no need to worry about injecting sidecars.          |\n| **Service Account \/ Node Sharing Proxy** | All workloads under the service account\/identity use a shared proxy with little overhead. | Authentication and security of connections between workloads and proxy cannot be guaranteed. | The level isolation between nodes and service accounts, the fault is the same as \u0022node sharing proxy\u0022. | Same as \u0022node sharing proxy\u0022 mode.                           |\n| **Shared remote proxy with micro-proxy** | Because injecting a micro-proxy for each pod, the overhead is relatively large. | The micro-proxy handles mTLS exclusively and is not responsible for L7 routing, which can ensure security. | When a Layer 7 policy needs to be applied, the traffic of the workload instance is redirected to the L7 proxy, and can be bypassed directly if it is not needed. The L7 proxy can run as a shared node proxy, a per-service account proxy, or a remote proxy | Same as \u0022sidecar proxy\u0022 mode.                                |\n\n{{\u003c\/table\u003e}}\n\n### Programmable proxy\n\nZhang Xiaohui of Flomesh explained the evolution of proxy software. I will quote some of his views below to illustrate the key role of programmable proxies in Istio.\n\nThe following figure shows the evolution process of the proxy software from configuration to programmable mode, and the representative proxy software in each stage.\n\n![Schematic diagram of the evolution of proxy software](proxy-evolution.svg)\n\nThe entire proxy evolution process is as the application moves from local and monolithic to large-scale and distributed. Below, I will briefly outline the evolution of the proxy software:\n\n- **The era of configuration files**: almost all software has configuration files, and proxy software is more inseparable from configuration files because of its relatively complex functions. The proxy at this stage is mainly developed using the C language, including its extension module, which highlights the ability of the proxy itself. This is also the most primitive and basic form of our use of proxies, including Nginx, Apache HTTP Server, [Squid](http:\/\/www.squid-cache.org\/), etc.\n- **Configuration language era**: Proxies in this era are more extensible and flexible, such as dynamic data acquisition and matching logic judgment. Varnish and HAProxy are two examples of representative software.\n- **The era of scripting languages**: Since the introduction of scripting languages, proxy software has become programmable. We can use scripts to add dynamic logic to proxies more easily, increasing development efficiency. The representative software is Nginx and its supported scripting languages.\n- **The era of clusters**: With the popularity of cloud computing, large-scale deployment and dynamic configuration of APIs have become necessary capabilities for proxies, and with the increase in network traffic, large-scale proxy clusters have emerged as the times require. The representative proxy software of this era includes Envoy, Kong, etc.\n- **Cloud-native era**: Multi-tenancy, elasticity, heterogeneous hybrid cloud, multi-cluster, security, and observability are all higher requirements for proxies in the cloud-native era. This will also be a historical opportunity for service meshes, with representative software such as Istio, Linkerd, and [Pypi](https:\/\/flomesh.io\/).\n\n## Are these all service meshes?\n\nSo, is it possible to build a service mesh with proxies? Now I will list the existing service mesh projects, and let\u0027s explore the development law and nature of service mesh together. The table below compares the current popular open source \u0022service mesh\u0022 projects.\n\n{{\u003ctable \u0022Service mesh open source project comparison table\u0022\u003e}}\n\n| Contrast           | Istio                                                        | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)                       |\n| :----------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | :-------------------------------------------- |\n| Current version   | 1.14                                                         | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0l                                          |\n| License           | Apache License 2.0                                           | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                            |\n| Initiator          | Google, IBM, Lyft                                            | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                                     |\n| Service proxy | Envoy, which supports proxyless mode for gRPC                | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | Default is [Envoy](https:\/\/www.envoyproxy.io\/) , replaceable | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/)           |\n| Ingress controller | Envoy, custom Ingress, supports Kubernetes Gateway API       | no built-in                                                 | Envoy, with support for the Kubernetes Gateway API           | no built-in                                                  | Kong                                | Support Contour, Nginx, compatible with other |\n| Governance         | Istio Community and Open Usage Commons, proposed to donate to CNCF | CNCF                                                        | View [Contribution Guidelines](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | View [Contribution Guidelines](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                          |\n| Comment | It is one of the most popular service mesh projects at present. | The earliest service mesh, the creator of the concept of \u0022Service Mesh\u0022, the first service mesh project to enter CNCF, using a lightweight proxy developed with Rust. | Consul service mesh, using Envoy as a sidecar proxy. | A service mesh project launched by Traefik, using Traefik Proxy as a sidecar and supporting SMI (mentioned below). | A service mesh project launched by Kong that uses Envoy as a sidecar proxy, using Kong\u0027s own gateway as ingress. | An open source service mesh created by Microsoft, using Envoy as a sidecar, compatible with SMI (also proposed by Microsoft). |\n\n{{\u003c \/table \u003e}}\n\nThe open source projects in the above table are summarized below, and several projects closely related to service mesh are added, as follows:\n\n- [Envoy](https:\/\/envoyproxy.io\/): Envoy is a cloud-native proxy, frequently used as a sidecar in other Envoy-based service meshes and for building API Gateways.\n- [Service Mesh Performance (SMP)](https:\/\/smp-spec.io\/): Metrics that capture details of infrastructure capacity, service mesh configuration, and workload metadata to standardize service mesh values and describe the performance of any deployment.\n- [Service Mesh Interface (SMI)](https:\/\/smi-spec.io\/): It is not a service mesh, but a set of service mesh implementation standards. Similar to OAM, SPIFFE, CNI, CSI, etc., it defines interface standards, and the specific implementation varies. Currently, Traefik Mesh and Open Service Mesh claim to support this specification.\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/): It\u0027s worth mentioning this project because it\u0027s often mistaken for a service mesh. In fact, it is oriented towards a three-layer network, and it can be used to connect multi-cloud\/hybrid clouds without changing the CNI plug-in. It\u0027s not a \u0022service mesh\u0022 as we define it, but a powerful complement to a service mesh (albeit a somewhat confusing name with a service mesh in it).\n\nLooking at the so-called \u0022service mesh\u0022 projects mentioned above, we can see that most service mesh project initiators start out as proxies, and then do the control plane. And Istio, Consul Connect, Open Service Mesh, and Kuma all use Envoy as a sidecar proxy. Only Linkerd and Traefik Mesh have launched their own proxies. And all service mesh projects support the sidecar pattern. Apart from Istio, Linkerd, and Consul Connect, which have been used in production, other service mesh projects are currently only \u0022toys\u0022.\n\n## Performance optimization for Istio\n\nAfter Istio 1.5 had a stable architecture, the community\u0027s main focus was on optimizing Istio\u0027s performance. Below, I will give you a detailed introduction to performance optimization methods in Istio, including:\n\n- Use the Proxyless mode.\n- Use eBPF to optimize traffic hijacking.\n- Optimization of control plane performance.\n- Optimization of data plane performance.\n\n### Proxyless mode\n\nProxyless mode is an experimental feature proposed by Istio in version 1.11-a service mesh without sidecar proxy based on gRPC and Istio. Using this pattern allows you to add gRPC services directly to Istio without injecting an Envoy proxy into the Pod. The figure below shows a comparison of sidecar mode and proxyless mode.\n\n![Sidecar vs Proxyless](sidecar-to-proxyless.svg)\n\nAs we can see from the above figure, although proxyless mode does not use a proxy for data plane communication, it still needs an agent for initialization and communication with the control plane. First, the agent generates a bootstrap file at startup, in the same way that it generates bootstrap files for Envoy. This tells the gRPC library how to connect to Istiod, where to find certificates for data plane communication, and what metadata to send to the control plane. Next, the agent acts as an xDS proxy, connecting and authenticating with \u0060Istiod\u0060. Finally, the agent obtains and rotates the certificate used in the data plane communication.\n\n\u003e *The essence of a service mesh is not a sidecar model, nor a configuration center, or transparent traffic interception, but a standardized inter-service communication standard.*\n\nSome people say that the proxyless model has returned to the old way of developing microservices based on SDK, and the advantages of service meshes have been lost. Can it still be called service mesh? In fact, this is also a compromise on performance—if you mainly use gRPC to develop microservices, you only need to maintain gRPC versions in different languages; that is, you can manage microservices through the control plane.\n\n\u003e *Envoy xDS has become the de facto standard for communication between cloud-native application services.*\n\n### Optimizing traffic hijacking with eBPF\n\nIn the section on transparent traffic hijacking, we can see the iptables rules and paths that an inter-service traffic passes through when it reaches the destination pod, which needs to go through multiple iptables rules, such as \u0060PREROUTING\u0060, \u0060ISTIO_INBOUND\u0060, \u0060ISTIO_IN_REDIRECT\u0060, \u0060OUTPUT\u0060, \u0060ISTIO_OUTPUT\u0060, and so on. Suppose now that there is a service A that wants to call service B in another pod on a non-localhost through the network stack, as shown in the figure below.\n\n![Service request path between pods not on the same host (iptables mode)](iptables-process.svg)\n\nFrom the figure, we can see that there are four iptables passes in the whole calling process. Among them, the outbound (iptables2) from Envoy in Pod A and the inbound (iptables3) from eth0 in Pod B are unavoidable. So can the remaining two, iptables1 and iptables4 be optimized? Wouldn\u0027t it be possible to shorten the network path by letting the two sockets communicate directly? This requires programming through eBPF such that:\n\n- Service A\u0027s traffic is sent directly to Envoy\u0027s inbound socket.\n- After Envoy in Pod B receives the inbound traffic, it has determined that the traffic is to be sent to the local service and directly connects the outbound socket to Service B.\n\nThe transparent traffic interception network path using eBPF mode is shown in the following figure.\n\n![Service request path between pods not on the same host (eBPF mode)](ebpf-diff-node.svg)\n\nIf service A and service B to be accessed are on the same node, the network path will be shorter.\n\n![Network request path between the same host Pod (eBPF mode)](ebpf-same-node.svg)\n\nAccess between services in the same node completely bypasses the TCP\/IP stack and becomes direct access between sockets.\n\n{{\u003ccallout note \u0022What is eBPF?\u0022\u003e}}\n\nWe know that modifying the Linux kernel code is difficult, and it takes a long time for new features to be released into the kernel. eBPF is a framework that allows users to load and run custom programs within the operating system\u0027s kernel. That is, with eBPF, you can extend and change the behavior of the kernel without directly modifying the kernel. I will briefly introduce eBPF to you below.\n\n- After the eBPF program is loaded into the kernel, it needs to pass the verification of the verifier before it can run. The verifier can prevent the eBPF program from accessing beyond its authority, ensuring the kernel\u0027s security.\n- eBPF programs are attached to kernel events and are triggered when there is an entry or exit from a kernel function.\n- In kernel space, eBPF programs must be written in a language that supports a compiler that generates eBPF byte code. Currently, you can write eBPF programs in C and Rust.\n- The eBPF program has compatibility issues with different Linux versions.\n\nSince the eBPF program can directly monitor and operate the Linux kernel, it has a perspective on the lowest level of the system and can play a role in traffic management, observability, and security.\n\n{{\u003c\/callout\u003e}}\n\nThe open source project [Merbridge](https:\/\/github.com\/merbridge\/merbridge) uses eBPF to shorten the path of transparent traffic hijacking and optimize the performance of the service mesh. For some details on the Merbridge implementation, please refer to the [Istio blog](https:\/\/istio.io\/latest\/blog\/2022\/merbridge\/) .\n\n{{\u003ccallout warning Notice\u003e}}\nThe eBPF functions used by Merbridge require a Linux kernel version ≥ 5.7.\n{{\u003c\/callout\u003e}}\n\nAt first glance, eBPF seems to implement the functions of Istio at a lower level and has a greater tendency to replace sidecar. But eBPF also has many limitations that make it impossible to replace service meshes and sidecars in the foreseeable future. Removing the sidecar in favor of a proxy-per-host model would result in:\n\n1. The explosion radius of a proxy failure is expanded to the entire node.\n2. It makes the security problem more complicated because too many certificates are stored on a node. Once attacked, there will be a risk of key leakage.\n3. On the host, traffic contention between Pods.\n\nMoreover, eBPF is mainly responsible for Layer 3\/4 traffic and can run together with CNI, but it is not suitable to use eBPF for Layer 7 traffic.\n\n\u003e *In the near future, eBPF technology will not be able to replace service meshes and sidecars.*\n\n### Control plane performance optimization\n\nThe above two optimizations are carried out for the data plane. Let\u0027s look at the performance optimization of the control plane. You can think of a service mesh as a show, where the control plane is the director and the data plane is all the actors. The director is not involved in the show but directs the actors. If the plot of the show is simple and the duration is very short, then each actor will be allocated very few scenes, and rehearsal will be very easy; if it is a large-scale show, the number of actors is large and the plot is very complicated. To rehearse the show well, one director may not be enough. He can\u0027t direct so many actors, so we need multiple assistant directors (expanding the number of control plane instances); we also need to prepare lines and scripts for actors, if actors It is also possible to perform a series of lines and scenes in one shot (reduce the interruption of the data plane and push updates in batches), so is our rehearsal more efficient?\n\nFrom the above analogy, you should be able to find the direction of control plane performance optimization, that is:\n\n- Reduce the size of the configuration that needs to be pushed.\n- Push batch proxy.\n- To expand the scale of the control plane.\n\n#### Reduce the configuration that needs to be pushed out\n\nThe easiest and most straightforward way to optimize control plane performance is to reduce the size of the configuration to be pushed. Assuming that there is workload A, if the proxy configuration related to A, that is, the configuration of the service that A needs to access, is pushed to A, instead of pushing the configuration of all services in the mesh to A, it can greatly reduce the number of services to be pushed. The size and application range of the configuration. The Sidecar resource in Istio can help us do this. The following is an example of a sidecar configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: us-west-1\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022us-west-1\/*\u0022\n\u0060\u0060\u0060\n\nWe can use the \u0060workloadSelector\u0060 field  to limit the scope of workloads that the sidecar configuration applies to, and the \u0060egress\u0060 field is used to determine the scope of services for the workload, so that the control plane can only push the configuration of its dependent services to service A, greatly reducing the need to push to the data plane. The configuration size of the service mesh reduces the memory and network consumption of the service mesh.\n\n#### Batch push the proxy configurations\n\nThe process of pushing the proxy configuration from the control plane Istiod to the data plane is complex. The following figure shows the process.\n\n![Flowchart of Istiod pushing proxy configuration to the data plane](istiod-push.svg)\n\nAfter an administrator configures the Istio mesh, the process for pushing proxy configuration in Istiod is as follows:\n\n1. The event that the administrator updates the configuration will trigger the configuration synchronization of the data plane.\n1. After listening to these events, Istio\u0027s \u0060DiscoveryServer\u0060 components will not push the configuration to the data plane immediately, but will add these events to the queue and continue to merge events within a period of time. This process is called debouncing, which is to prevent frequent updates to the data plane configuration.\n1. After the debouncing period, these events will be pushed to the queue.\n1. To expedite push progress, Istiod will limit the number of simultaneous push requests.\n1. Envoy configuration push data plane workloads are translated into events.\n\nFrom the above process, we can see that the key to optimizing configuration push is the debounce period in step 2 and the current limit setting in step 4. There are several environmental variables that can help you set up control plane push:\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060: The time after which the event will be added to the push queue.\n- \u0060PILOT_DEBOUNCE_MAX\u0060: This defines the maximum amount of time an event can debounce.\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060: Specifies whether endpoint updates meet debounce rules or have priority and fall into the push queue immediately.\n- \u0060PILOT_PUSH_THROTTLE\u0060: Controls how many push requests are processed at once.\n\nPlease refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars) for the default values and specific configuration of these environment variables .\n\nHow to set these values can follow the following principles:\n\n- If control plane resources are idle, to speed up the propagation of configuration updates, you can:\n  - Shorten the debounce period and increase the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n- If the control plane is saturated, to reduce performance bottlenecks, you can:\n  - Delay the debounce cycle to reduce the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n\nAs for how to set the optimal solution, you need to debug it in conjunction with your observable system.\n\n#### Scale up the control plane\n\nIf setting up debounce batch processing and sidecar cannot optimize the performance of the control plane, the final choice is to expand the scale of the control plane, including expanding the resources of a single Istiod instance and increasing the number of Istiod instances. Which expansion method is used depends on the situation:\n\n- When the resource occupancy of a single Istiod is saturated, it is recommended that you increase the instance size of Istiod. This is usually because there are too many resources in the service mesh (Istio\u0027s custom resources, such as VirtualService, DestinationRule, etc.) that need to be processed.\n- Then increase the number of instances of Istiod, which can spread the workloads to be managed by each instance.\n\n### Data plane performance optimization\n\nApache SkyWalking can serve as an observability tool for Istio and can also help us analyze the performance of services in dynamic debugging and troubleshooting. Its newly launched Apache SkyWalking Rover component can use eBPF technology to accurately locate Istio\u0027s key performance issues.\n\nOn the data plane, we can increase Envoy\u0027s throughput to optimize Istio\u0027s performance by:\n\n- Disable Zipkin tracing or reduce the sample rate.\n- Simplified access log format.\n- Disable Envoy\u0027s Access Log Service (ALS).\n\nFor data on the impact of the above optimizations on Envoy throughput, see Using eBPF to pinpoint key performance issues for service meshes.\n\n## Envoy: the service mesh\u0027s leading actor\n\nWe know that the service mesh is composed of the data plane and the control plane. From the above list of service mesh open source projects, we can see that most of the service mesh open source projects are based on Envoy, and then develop their own control plane. Remember when I likened a service mesh to a gig earlier in this article? In this service mesh performance, there is no way to think that Envoy is the leading actor. The xDS protocol, invented by Envoy, has basically become a general API for service meshes. Many open source projects for service meshes use Envoy as the data plane. Shown below is the architecture diagram of Envoy.\n\n![Envoy Architecture Diagram](envoy-arch.svg)\n\nxDS is the core that differentiates Envoy from other proxies because its code and parsing process are very complex and it is difficult to expand. The following is a topology diagram of Istio components. From the figure, we can see that there is not only one \u0060envoy\u0060 process but a \u0060pilot-agent\u0060.\n\n{{\u003cfigure title=\u0022Istio component topology\u0022 alt=\u0022image\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\nThe role of the \u0060pilot-agent\u0060 process is as follows:\n\n- As \u0060the\u0060 parent process of, responsible for the lifecycle management of Envoy.\n- Receive pushes from the control plane, configure the proxy and certificates.\n- Collect Envoy statistics and aggregate sidecar statistics for Prometheus to collect.\n- A built-in local DNS proxy is used to resolve the internal domain name of the cluster that cannot be resolved by Kubernetes DNS.\n- Health checks for Envoy and DNS proxy.\n\nFrom the above functions, we can see that the \u0060pilot-agent\u0060 process is mainly used to interact with Istiod and play a commanding and auxiliary role for Envoy. The core component of Istio is Envoy. So will Envoy \u0022act and guide,\u0022 no longer cooperate with Istio, and build its own control plane?\n\n\u003e *In a Sidecar container, the \u0060pilot-agent\u0060 is like Envoy\u0027s \u0022Sidecar\u0022.*\n\n{{\u003ccallout note \u0022Readers to think about\u0022\u003e}}\nCan the \u0060pilot-agent\u0060 function be built directly into Envoy, thus eliminating the \u0060pilot-agent\u0060?\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway unified service mesh gateway\n\nIn Kubernetes, the first resource object used to expose services in a cluster, in addition to the service resource object, is Ingress. Using Ingress you simply open an external access point for the cluster, routing traffic to specific services via HTTP Hosts and \u0060path\u0060. Compared with exposing services directly to service resources , it can reduce the network access point (PEP) of the cluster and reduce the risk of the cluster being attacked by the network. The following figure shows the process of using Ingress to access services in the cluster.\n\n![Kubernetes Ingress traffic access flow chart](ingress.svg)\n\nBefore Kubernetes, API Gateway software was widely used as edge routing. When referring to Istio, Istio\u0027s custom Gateway resources are added, which makes accessing resources in the Istio service mesh one more option, as shown in the following figure.\n\n![Ways to access services in the Istio mesh](access-cluster.svg)\n\nNow, to expose services in a single Istio mesh, how do I choose between \u0060NodePort\u0060, \u0060LoadBalancer\u0060, Istio Gateway, Kubernetes Ingress, and API Gateway software? If it is a multi-cluster service mesh, how do clients access services within the mesh? Our service mesh lead, Envoy, has done this well and is used in many forms:\n\n- Istio, Kuma, and Consul Connect all use Envoy as a sidecar proxy.\n- Kubernetes Ingress Controller\/API Gateway: [Contour](https:\/\/github.com\/projectcontour\/contour), [Emissary](https:\/\/github.com\/emissary-ingress\/emissary), [Hango](https:\/\/github.com\/hango-io\/hango-gateway), [Gloo](https:\/\/github.com\/solo-io\/gloo).\n\nThese projects utilize Envoy to implement service meshes and API gateways, with a lot of functional overlap, proprietary features, or a lack of community diversity due to the fact that the Envoy community does not provide a control plane implementation. In order to change the status quo, the Envoy community initiated the Envoy Gateway project, which will not change the Envoy core proxy, xDS, and go-control-plane. The project aims to combine the experience of existing Envoy-based API Gateway related projects. Some Envoy-specific extensions to the Kubernetes Gateway API lower the barrier to entry for Envoy users to use gateways. Because the Envoy Gateway still issues configuration to the Envoy proxy through xDS, you can also use it to manage gateways that support xDS, such as the Istio Gateway.\n\nThe gateways we have seen now are basically used as ingress gateways in a single cluster and can do nothing for multi-cluster and multi-mesh. To cope with multiple clusters, we need to add another layer of gateways on top of Istio and a global control plane to route traffic between multiple clusters, as shown in the figure below.\n\n![Schematic diagram of two-level gateway with multi-cluster and multi-mesh](t2-gateway.svg)\n\n{{\u003ccallout note \u0022A brief introduction to two-tire gateways\u0022\u003e}}\n- The Tire-1 gateway (hereinafter referred to as T1) is located at the application edge and is used in a multi-cluster environment. The same application is hosted on different clusters at the same time, and the T1 gateway routes the application\u0027s request traffic between these clusters.\n- The Tire-2 gateway (hereafter referred to as T2) is located at the edge of a cluster and is used to route traffic to services within that cluster managed by the service mesh.\n{{\u003c\/callout\u003e}}\n\nMulti-cluster service mesh management is achieved by adding a layer of global control plane and APIs in addition to the Istio control plane. Deploying T1 gateways as a cluster prevents a single point of failure. To learn more about two-tier gateways, refer [to Routing Service Mesh Traffic Through Two-Tier Gateway Designs](https:\/\/cloudnativecn.com\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/) .\n\nThe configuration of the T1 gateway is as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\nThis configuration exposes \u0060servicea.example.com\u0060  service through the T1 gateway and forwards \u006075%\u0060 of the traffic accessing the service to cluster1 and \u006025%\u0060 of the traffic to cluster2. In addition, in order to deal with the traffic, services, and security configurations in multiple clusters, Tetrate\u0027s flagship product, [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/), a series of group APIs have also been added to the TSB documentation for details.\n\n## Istio open source ecosystem\n\nIstio has been open source for more than five years, and many open source projects have emerged in the past two years, among which the more representative ones are:\n\n- Slime (NetEase open source)\n- Tencent\u0027s open source initiatives Aeraki\n- Istio\u0027s official support for Wasm plugins\n\nTheir presence makes Istio more intelligent and expands the scope of Istio.\n\n### Slime\n\nSlime is an Istio-based smart mesh manager open-sourced by the NetEase Shufan microservices team. Slime has been implemented based on Kubernetes Operator and can be used as the CRD manager of Istio. It can define dynamic service governance policies without any customization of Istio, so as to achieve the purpose of automatically and conveniently using the high-level functions of Istio and Envoy.\n\nIn the previous control plane performance optimization, we mentioned optimizing the performance of Istio by \u0022reducing the configuration that needs to be pushed\u0022, but Istio cannot automatically identify and cannot rely on the proxy configuration that needs to be pushed to each sidecar to optimize. Slime provides a  \u0060lazyload\u0060 controller, which can help us implement lazy loading of configuration. Users do not need to configure the \u0060SidecarScope\u0060 manually. Istio can load service configuration and service discovery information on demand.\n\nThe following figure shows the flow chart of updating the data plane configuration with Slime as the management plane of Istio.\n\n![Flowchart for updating Istio data plane configuration using Slime](slime-process.svg)\n\nThe specific steps for updating the data plane configuration are as follows:\n\n1. The Slime Operator completes the initialization of Slime components in Kubernetes according to the administrator\u0027s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to the Kubernetes cluster.\n3. Slime queries the monitoring data of related services saved in Prometheus, converts Slime CRD to Istio CRD in combination with the configuration of the adaptive part in Slime CRD, and pushes it to Global Proxy at the same time.\n4. Istio monitors the creation of Istio CRDs.\n5. Istio sends the Sidecar Proxy\u0027s configuration information to the corresponding Sidecar Proxy on the data plane.\n\nBecause the first invocation of all services in the data plane passes through the Global Proxy, the Proxy can record the invocation and dependency information of all services, and update the configuration of the Sidecar resource in Istio according to the dependency information. When the routing information is redefined, the original record of the Global Proxy becomes invalid, and a new data structure is required to maintain the calling relationship of the service. Slime created a  \u0060ServiceFence\u0060 to maintain the service invocation relationship and solve the problem of missing service information.\n\n### Aeraki\n\nAeraki Mesh is a service mesh project open sourced by Tencent Cloud in March 2021. It expands support for seven-layer protocols based on Istio and focuses on solving the service governance of **non-HTTP protocols** in Istio.  It entered the CNCF sandbox in June 2022.\n\nThe following figure shows the architectural diagram of Aeraki.\n\n![Aeraki Architecture Diagram](aeraki-arch.svg)\n\nThe process of using Aeraki to serve non-HTTP into an Istio mesh is as follows:\n\n1. Aeraki\u0027s X2Istio component connects to the service registry, obtains the registration information of non-HTTP services, and generates a ServiceEntry to register with Istio.\n2. Aeraki, as the management plane on top of Istio, obtains the ServiceEntry configuration from Istio.\n3. Aeraki judges the protocol type of the service (e.g. \u0060tcp-metaprotocol-dubbo\u0060) through the port command, then generates the MetaProtocol Proxy Filter (compatible with EnvoyFilter) configuration, and at the same time modifies the RDS address to point it to Aeraki.\n4. Istio uses the xDS protocol to deliver the configuration (LDS, CDS, EDS, etc.) to the data plane.\n5. Aeraki generates routing rules based on the information in the service registry and user settings and sends them to the data plane through RDS.\n\nThe key to the whole process of accessing non-HTTP services in Istio is the **MetaProtocol Proxy**. Istio supports HTTP\/HTTP2, TCP and gRPC protocols by default, and experimentally supports Mongo, MySQL and Redis protocols. To use Istio to route traffic for other protocols not only requires a lot of work to modify the Istio control plane and extend Envoy, but also a lot of duplication because different protocols share common control logic. The Envoy MetaProtocol Proxy is a general seven-layer protocol proxy implemented based on Envoy. The MetaProtocol Proxy is an extension based on the Envoy code. It implements basic capabilities such as service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for the seven-layer protocol, which greatly reduces the difficulty of third-party protocol development for Envoy.\n\nThe following figure shows the architecture diagram of MetaProtocol Proxy.\n\n![MetaProtocol Proxy Architecture Diagram](metaprotocol-proxy.svg)\n\nWhen we want to extend Istio to support other seven-layer protocols such as Kafka, Dubbo, and Thrift, we only need to implement the codec interfaces (Decode and Encode) in the above figure, and then we can quickly develop a third-party protocol plug-in based on MetaProtocol. Because MetaProtocol Proxy is an extension of Envoy, you can still develop filters for it in different languages and use \u0060EnvoyFilter\u0060 resources to deliver configuration to the data plane.\n\n### WasmPlugin API\n\nWasmPlugin is an API introduced in Istio 1.12. As a proxy extension mechanism, we can use it to add custom and third-party Wasm modules to the data plane. The diagram below shows how a user can use the WasmPlugin in Istio.\n\n![Flowchart of using WasmPlugin in Istio](wasmplugin.svg)\n\nSpecific steps are as follows:\n\n1. Users use the Proxy-Wasm SDK (currently available in AssemblyScript, C\u002b\u002b, Rust, Zig, and Go) to develop extensions and build them into OCI images (such as Docker images) to upload to the mirror repository.\n2. The user writes the \u0060WasmPlugin\u0060 configuration and applies it to Istio.\n3. The \u0060WasmPlugin\u0060 configuration for the workload in the configuration is selected by the Istio control plane, and the Wasm module is injected into the specified Pod.\n4. The \u0060pilot-agent\u0060 in the sidecar loads the Wasm modules from remote or local files and run them in Envoy.\n\n## Who should use Istio?\n\nWell, having said that, what does this have to do with you? Istio\u0027s relationship with you depends on your role.\n\n- If you are the platform leader, after applying the service mesh, you may enhance the observability of your platform and have a unified platform to manage microservices. You will be the direct beneficiary and the main implementer of the service mesh.\n- If you are an application developer, you will also benefit from a service mesh because you can be more dedicated to the business logic and not worry about other non-functional issues such as retry policies, TLS, etc..\n\nThe following diagram shows the adoption path for service meshes.\n\n![The path to adopt service mesh](adopt.svg)\n\nWhether to adopt a service mesh depends on your technology development stage, whether the application implements containerization and microservices, the need for multi-language, whether mTLS is required, and the acceptance of performance loss.\n\n## Service mesh positioning in the cloud native technology stack\n\nThe development of technology is changing with each passing day. In the past two years, some new technologies have appeared, which seem to challenge the status of the service mesh. Some people claim that it can directly replace the existing service mesh of the classic sidecar model. We should not be confused by the noise of the outside world, correcting the positioning of service mesh in the cloud native technology stack.\n\n\u003e *Blindly promoting a technology and ignoring its applicable scenarios is hooliganism.*\n\nThe diagram below shows the cloud-native technology stack.\n\n![Cloud native technology stack diagram](cloud-native-stack.svg)\n\nWe can see that the \u0022cloud infrastructure\u0022, \u0022middleware\u0022, and \u0022application\u0022 layers in the cloud native technology stack diagram all enumerate some iconic open source projects that build standards in their fields:\n\n- In the field of cloud infrastructure, Kubernetes unifies the standards for container orchestration and application life cycle management, and the Operator mode lays the standards for extending the Kubernetes API and third-party application access.\n- In the field of middleware, the service mesh assumes some or all of the responsibilities of the seven-layer network, observability, and security in the cloud native technology stack. It runs in the lower layer of the application and is almost imperceptible; Dapr (distributed application runtime) defines the capability model of cloud-native middleware. Developers can integrate Dapr\u0027s multi-language SDK into their applications and programs for the distributed capabilities provided by Dapr, without caring about the applications running on them. environment and docking back-end infrastructure. Because the Dapr runtime (Sidecar mode deployment, which contains various building blocks) is running in the same Pod as the application, it automatically connects us with the backend components;\n- In the application field, OAM aims to establish an application model standard, an application through components, characteristics, policies, and workflows.\n\nThe diagram below shows how Istio is positioned for seven-tier mesh management in a cloud-native deployment.\n\n![Istio is positioned in a seven-layer network in a cloud-native architecture](istio-role.svg)\n\n{{\u003ccallout note \u0022What is the relationship between Dapr and Istio?\u0022\u003e}}\n\nSimilarities between Istio and Dapr:\n\n- Both Istio and Dapr can use the sidecar mode deployment model.\n- Both belong to middleware and can also manage communication between services.\n\nDifferences between Istio and Dapr:\n\n- Different goals: Istio\u0027s goal is to build a zero-trust network and define inter-service communication standards, while Dapr\u0027s goal is to build a standard API for middleware capabilities.\n- Different architectures: Istio = Envoy \u002b transparent traffic hijacking \u002b control plane; Dapr = multilingual SDK \u002b standardized API \u002b distributed capability components.\n- However, the application of Istio is almost imperceptible to developers and mainly requires the implementation of the infrastructure operation and maintenance team, while the application of Dapr requires developers to independently choose to integrate the Dapr SDK.\n\n{{\u003c\/callout\u003e}}\n\n## The future of service mesh\n\nIn the above article, I introduced the development context and open source ecosystem of Istio. Next, I will introduce the future trends of Istio service mesh:\n- Zero trust network\n- Hybrid cloud\n\n\u003e *The future of service meshes lies in being the infrastructure for zero-trust networks and hybrid clouds.*\n\nThis is also the direction of Tetrate, the enterprise-level service mesh provider of the author\u0027s company. We are committed to building an application-aware network suitable for any environment and any load and providing a zero-trust hybrid cloud platform. Shown below is the architecture diagram of Tetrate\u0027s flagship product, Tetrate Service Bridge.\n\n![TSB Architecture Diagram](tsb.svg)\n\nTetrate was founded by the founders of the Istio project, and TSB is based on open source Istio, Envoy, and Apache SkyWalking. We also actively contributed to the upstream community and participated in the creation of the Envoy Gateway project to simplify the use of Envoy gateways (XCP in the figure above is a gateway built with Envoy).\n\n## Zero trust\n\nZero Trust is an important topic at IstioCon 2022. Istio is becoming an important part of zero trust, the most important of which is **identity-oriented control** rather than network-oriented control.\n\n{{\u003ccallout note \u0022What is Zero Trust?\u0022\u003e}}\n\nZero Trust is a security philosophy, not a best practice that all security teams follow. The concept of zero trust was proposed to bring a more secure network to the cloud-native world. Zero trust is a theoretical state where all consumers within a network not only have no authority but also have no awareness of the surrounding network. The main challenges of zero trust are the increasingly granular authorization and time limit for user authorization.\n\n{{\u003c\/callout\u003e}}\n\n### Authentication\n\nIstio 1.14 adds support for SPIRE. SPIRE (SPIFFE Runtime Environment, CNCF Incubation Project) is an implementation of SPIFFE (Secure Production Identity Framework For Everyone, CNCF Incubation Project). In Kubernetes, we use ServiceAccount to provide identity information for workloads in Pods, and its core is based on Token (using Secret resource storage) to represent workload identity. A token is a resource in a Kubernetes cluster. How to unify the identities of multiple clusters and workloads running in non-Kubernetes environments (such as virtual machines)? That\u0027s what SPIFFE is trying to solve.\n\nThe purpose of SPIFFE is to establish an open and unified workload identity standard based on the concept of zero trust, which helps to establish a fully identifiable data center network with zero trust. The core of SPIFFE is to define a short-lived encrypted identity document—SVID (SPFFE Verifiable Identity Document)—through a simple API, which is used as an identity document (based on an X.509 certificate or JWT token) for workload authentication. SPIRE can automatically rotate SVID certificates and keys according to administrator-defined policies, dynamically provide workload identities, and Istio can dynamically consume these workload identities through SPIRE.\n\nThe Kubernetes-based SPIRE architecture diagram is shown below.\n\n![Architecture diagram of SPIRE deployed in Kubernetes](spire-with-kubernetes.svg)\n\nIstio originally used the Citadel service in Istiod to be responsible for certificate management in the service mesh, and issued the certificate to the data plane through the xDS (to be precise, SDS API) protocol. With SPIRE, the work of certificate management is handed over to SPIRE Server. SPIRE also supports the Envoy SDS API. After we enable SPIRE in Istio, the traffic entering the workload pod will be authenticated once after being transparently intercepted into the sidecar. The purpose of authentication is to compare the identity of the workload with the environment information it runs on (node, Pod\u0027s ServiceAccount and Namespace, etc.) to prevent identity forgery. Please refer to How to Integrate SPIRE in Istio to learn how to use SPIRE for authentication in Istio.\n\nWe can deploy SPIRE in Kubernetes using the Kubernetes Workload Registrar, which automatically registers the workload in Kubernetes for us and generates an SVID. The registration machine is a Server-Agent architecture, which deploys a SPIRE Agent on each node, and the Agent communicates with the workload through a shared UNIX Domain Socket. The following diagram shows the process of using SPIRE for authentication in Istio.\n\n![Schematic diagram of the SPIRE-based workload authentication process in Istio\u0022](workload-attestation.svg)\n\nThe steps to using SPIRE for workload authentication in Istio are as follows:\n\n1. To obtain the SIVD, the SPIRE Agent is referred to as pilot-agent via shared UDS.\n1. The SPIRE Agent asks Kubernetes (to be precise, the kubelet on the node) for load information.\n1. The kubelet returns the information queried from the API server to the workload validator.\n1. The validator compares the result returned by the kubelet with the identity information shared by the sidecar. If it is the same, it returns the correct SVID cache to the workload. If it is different, the authentication fails.\n\nPlease refer to the SPIRE documentation for the detailed process of registering and authenticating workloads.\n\n### NGAC\n\nWhen each workload has an accurate identity, how can the permissions of these identities be restricted? RBAC is used by default in Kubernetes for access control. As the name suggests, this access control is based on roles. Although it is relatively simple to use, there is a role explosion problem for large-scale clusters—that is, there are too many roles, and the types are not static, making it difficult to track and audit role permission models. In addition, the access rights of roles in RBAC are fixed, and there is no provision for short-term use rights, nor does it take into account attributes such as location, time, or equipment. Enterprises using RBAC have difficulty meeting complex access control requirements to meet the regulatory requirements that other organizations demand.\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying user management capabilities with a high level of granularity. NGAC was developed by NIST (National Institute of Standards and Technology) and is currently used for rights management in Tetrate Service Bridge. For more information on why you should choose NGAC over ABAC and RBAC, please refer to the blog post Why you should choose NGAC as your permission control model.\n\n## Hybrid cloud\n\nIn practical applications, we may deploy multiple Kubernetes clusters in various environments for reasons such as load balancing; isolation of development and production environments; decoupling of data processing and data storage; cross-cloud backup and disaster recovery; and avoiding vendor lock-in. The Kubernetes community provides a \u0022cluster federation\u0022 function that can help us create a multi-cluster architecture, such as the common Kubernetes multi-cluster architecture shown in the figure below, in which the host cluster serves as the control plane and has two member clusters, namely West and East.\n\n![Kubernetes Cluster Federation Architecture](multicluster.svg)\n\nCluster federation requires that the networks between the host cluster and member clusters can communicate with each other but does not require network connectivity between member clusters. The host cluster serves as the API entry, and all resource requests from the outside world to the host cluster will be forwarded to the member clusters. The control plane of the cluster federation is deployed in the host cluster, and the \u0022Push Reconciler\u0022 in it will propagate the identities, roles, and role bindings in the federation to all member clusters. Cluster federation simply \u0022connects\u0022 multiple clusters together, replicating workloads among multiple clusters, and the traffic between member clusters cannot be scheduled, nor can true multi-tenancy be achieved.\n\nCluster federation is not enough to realize hybrid clouds. In order to realize hybrid clouds in the true sense, it is necessary to achieve interconnection between clusters and realize multi-tenancy at the same time. TSB builds a general control plane for multi-cluster management on top of Istio and then adds a management plane to manage multi-clusters, providing functions such as multi-tenancy, management configuration, and observability. Below is a diagram of the multi-tenancy and API of the Istio management plane.\n\n![Schematic diagram of TSB\u0027s management plane built on top of Istio](tsb-management-plane.svg)\n\nIn order to manage the hybrid cloud, TSB built a management plane based on Istio, created tenant and workspace resources, and applied the gateway group, traffic group, and security group to the workloads in the corresponding cluster through selectors. For the detailed architecture of TSB, please refer to the [TSB documentation](https:\/\/docs.tetrate.io\/service-bridge).\n\nThanks for reading.\n', '\/en\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains the background of Istio&#39;s birth, its position in the cloud-native technology stack, and the development direction of Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-service-mesh-book/">In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 15, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('In-Depth Understanding of Istio: Announcing the Publication of a New Istio Book', 'By the Cloud Native Community(China)', '\n![](book.jpg)\n\nIt\u0027s been more than 5 years since Google, IBM, and Lyft unveiled the Istio open source project in May 2017. The Istio project has developed from a seed to a tall tree in these years. Many domestic books on the Istio service mesh were launched in the two years following the release of Istio 1.0 in 2018. My country is at the forefront of the world in the field of Istio book publishing.\n\n## Service mesh: one of the core technologies of cloud native\n\nToday, Istio is nearly synonymous with service mesh in China. The development of service mesh, as one of the core cloud-native technologies described by CNCF (Cloud Native Computing Foundation), has gone through the following stages.\n\n- 2017-2018: Exploratory Phase\n- 2019-2020: Early Adopter Phase\n- 2021 to present: Implementation on a large scale and ecological development stage\n\nCloud native technology enables enterprises to design and deploy elastically scalable applications in new dynamic settings such as public, private, and hybrid clouds, according to the CNCF. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs are examples of cloud native technology.\n\nService mesh has been included to the CNCF definition of cloud native, indicating that it is one of the representative technologies of cloud native. Google is donating Istio to CNCF today, and we have reason to expect that as a CNCF project, Istio\u0027s community will be more open, and its future development will be more smooth.\n\n## Service mesh and cloud native applications\n\nCloud-native development is gaining traction. Despite the frequent emergence of new technologies and products, service mesh has maintained its place as \u0022cloud-native network infrastructure\u0022 as part of the overall cloud-native technology stack throughout the past year. The cloud-native technology stack model is depicted in the diagram below, with representative technologies for each layer to define the standard. Service mesh and other cloud-native technologies complement each other as a new era of middleware emerges. Dapr (Distributed Application Runtime) defines the cloud-native middleware capability model, OAM defines the cloud-native application model, and so on, whereas service mesh Lattice defines a cloud-native seven-layer network model.\n\n![Cloud Native Application Model](model.jpg)\n\n## Why you need a service mesh\n\nUsing a service mesh isn\u0027t tantamount to abandoning Kubernetes; it just makes sense. The goal of Kubernetes is to manage application lifecycles through declarative configuration, whereas the goal of service mesh is to provide traffic control, security management, and observability amongst apps. How do you set up load balancing and flow management for calls between services after a robust microservice platform has been developed with Kubernetes?\n\nMany open source tools, including Istio, Linkerd, MOSN, and others, support Envoy\u0027s xDS protocol. The specification of xDS is Envoy\u0027s most significant contribution to service mesh or cloud native. Many various usage cases, such as API gateways, sidecar proxies in service meshes, and edge proxies, are derived from Envoy, which is simply a network proxy, a modern version of the proxy configured through the API.\n\nIn a nutshell, the move from Kubernetes to Istio was made for the following reasons.\n\n- Application life cycle management, specifically application deployment and management, is at the heart of Kubernetes (scaling, automatic recovery, and release).\n- Kubernetes is a microservices deployment and management platform that is scalable and extremely elastic.\n- Transparent proxy is the cornerstone of service mesh, which intercepts communication between microservices via sidecar proxy and then regulates microservice behavior via control plane settings. The deployment mode of service meshes has introduced new issues today. For service meshes, sidecar is no longer required, and an agentless service mesh based on gRPC is also being tested.\n- xDS is a protocol standard for configuring service meshes, and a gRPC-based xDS is currently being developed.\n- Kubernetes traffic management is decoupled with the service mesh. The kube-proxy component is not required to support traffic within the service mesh. The traffic between services is controlled by an abstraction close to the microservice application layer to achieve security and observability features.\n- In Kubernetes, service mesh is an upper-level abstraction of service, and Serverless is the next stage, which is why Google released Knative based on Kubernetes and Istio following Istio.\n\n## Open source in the name of the community\n\nThe ServiceMesher community was founded in May 2018 with the help of Ant Financial. Following that, a tornado of service meshes erupted in China, and the community-led translation of Istio\u0027s official documentation reached a fever pitch.\n\nI became aware of a dearth of Chinese resources for systematically teaching Istio over time, so in September 2018, I began to plan and create an Istio book, launching the Istio Handbook open source e-book project on GitHub. I met many friends who are also interested in Istio and service mesh technology in the online and offline events of the community a few months later, with the promotion of service mesh technology and the expansion of the ServiceMesher community. We unanimously agreed to collaborate on an open source Istio e-book, which will compile the community\u0027s important writings and experience into a logical text and make it available to the majority of developers.\n\nHundreds of people volunteered and began co-authoring the book in March 2019 under the auspices of the Community Stewardship Council. In May 2020, we created a cloud-native community that incorporated the original ServiceMesher community in order to further promote cloud-native technology and expand the technical knowledge supplied by the community. The scope of community operations has also widened, moving away from service mesh to more extensive cloud-native tools.\n\nThe editorial board for this book, which includes me, Ma Ruofei, Wang Baiping, Wang Wei, Luo Guangming, Zhao Huabing, Zhong Hua, and Guo Xudong, was founded in October 2020. We performed further version updates, improvements, and optimizations to this book under the supervision and assistance of the publishing business. This book, \u0022In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh,\u0022 finally met you after many iterations.\n\n![The book cover](cover.jpg)\n\n## About this book\n\nAfter version 1.5, Istio underwent considerable architectural modifications, and various new or better features were added, including the addition of a smart DNS proxy, additional resource objects, increased support for virtual machines, and more.\n\nThis book is based on the new edition of Istio, and it aims to provide readers with the most up-to-date and comprehensive content possible by following the newest trends in the Istio community. Furthermore, several of the book\u0027s authors are front-line development or operation and maintenance engineers with extensive Istio expertise, offering detailed and useful reference cases for the book.\n\nThis book is currently available on the [JD.com](https:\/\/item.jd.com\/13200745.html). Please read \u0022In-depth Understanding of Isito: Advanced Practice of Cloud Native Service Mesh\u0022 if you want to learn more about Istio!\n', '\/en\/blog\/istio-service-mesh-book\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">By the Cloud Native Community(China)</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-13/">What&#39;s New in Istio 1.13?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Mar 28, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('What\u0027s New in Istio 1.13?', 'In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.', '\nIstio 1.13 is the first release of 2022, and, not surprisingly, the Istio team will continue to release new versions every quarter. Overall, the new features in this release include:\n\n- Support for newer versions of Kubernetes\n- New API – ProxyConfig, for configuring sidecar proxies\n- Improved Telemetry API\n- Support for hostname-based load balancers with multiple network gateways\n\n### Support for Kubernetes Versions\n\nI often see people asking in the community which Istio supports Kubernetes versions. Istio’s website has a clear list of supported Kubernetes versions. You can see [here](https:\/\/istio.io\/latest\/docs\/releases\/supported-releases\/#support-status-of-istio-releases) that Istio 1.13 supports Kubernetes versions 1.20, 1.21, 1.22, and 1.23, and has been tested but not officially supported in Kubernetes 1.16, 1.17, 1.18, 1.19.\n\nWhen configuring Istio, there are a lot of checklists. I noted them all in the [Istio cheatsheet](https:\/\/github.com\/tetratelabs\/istio-cheatsheet). There are a lot of cheat sheets about configuring Istio, using resources, dealing with everyday problems, etc., in this project, which will be online soon, so stay tuned.\n\nThe following screenshot is from the Istio cheatsheet website, it shows the basic cheat sheet for setting up Istio.\n\n![Istio cheatsheet](istio-cheatsheet.jpg)\n\n### Introducing the new ProxyConfig API\n\nBefore Istio version 1.13, if you wanted to customize the configuration of the sidecar proxy, there were two ways to do it.\n\n**MeshConfig**\n\nUse MeshConfig and use IstioOperator to modify it at the Mesh level. For example, use the following configuration to alter the default discovery port for istiod.\n\n\u0060\u0060\u0060yaml\napVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nspec:\n  meshConfig:\n\t  defaultConfig:\n      discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\n**Annotation in the Pods**\n\nYou can also use annotation at the Pod level to customize the configuration. For example, you can add the following annotations to Pod to modify the default port for \u0060istiod\u0060 of the workload:\n\n\u0060\u0060\u0060yaml\nanannotations:\n  proxy.istio.io\/config: |\n    discoveryAddress: istiod:15012\n\u0060\u0060\u0060\n\nWhen you configure sidecar in either of these ways, the fields set in annotations will completely override the default fields in MeshConfig. Please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#ProxyConfig) for all configuration items of ProxyConfig.\n\n**The new API – ProxyConfig**\n\nBut in 1.13, a new top-level custom resource, ProxyConfig, has been added, allowing you to customize the configuration of your sidecar proxy in one place by specifying a namespace and using a selector to select the scope of the workload, just like any other CRD. Istio currently has limited support for this API, so please refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/proxy-config\/) for more information on the ProxyConfig API.\n\nHowever, no matter which way you customize the configuration of the sidecar proxy, it does not take effect dynamically and requires a workload restart to take effect. For example, for the above configuration, because you changed the default port of istiod, all the workloads in the mesh need to be restarted before connecting to the control plane.\n\n### Telemetry API\n\n[MeshConfig](https:\/\/istio.io\/latest\/docs\/reference\/config\/istio.mesh.v1alpha1\/#MeshConfig-ExtensionProvider) customized extensions and configurations in the Istio mesh. The three pillars of observability– Metrics, Telemetry, and Logging– can each be docked to different providers. The [Telemetry API](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/telemetry\/) gives you a one-stop place for flexible configuration of them. Like the ProxyConfig API, the Telemetry API follows the configuration hierarchy of Workload Selector \u003e Local Namespace \u003e Root Configuration Namespace. The API was introduced in Istio 1.11 and has been further refined in that release to add support for OpenTelemetry logs, filtered access logs, and custom tracing service names. See [Telemetry Configuration](https:\/\/istio.io\/latest\/docs\/reference\/config\/telemetry\/) for details.\n\n### Automatic resolution of multi-network gateway hostnames\n\nIn September 2021, a member of the Istio community [reported an issue](https:\/\/szabo.jp\/2021\/09\/22\/multicluster-istio-on-eks\/) with the EKS load balancer failing to resolve when running multi-cluster Istio in AWS EKS. Workloads that cross cluster boundaries need to be communicated indirectly through a dedicated east-west gateway for a multi-cluster, multi-network mesh. You can follow the instructions on [Istio’s website](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/multi-primary_multi-network\/) to configure a multi-network, primary-remote cluster, and Istio will automatically resolve the IP address of the load balancer based on the hostname.\n\n### Istio 1.13.1 fixing the critical security vulnerabilities\n\nIstio 1.13.1 was released to fix a known [critical vulnerability](https:\/\/cve.mitre.org\/cgi-bin\/cvekey.cgi?keyword=CVE-2022-23635) that could lead to an unauthenticated control plane denial of service attack.\n\nThe figure below shows a multi-cluster primary-remote mesh where istiod exposes port 15012 to the public Internet via a gateway so that a pod on another network can connect to it.\n\n![Multi-network Mesh](multi-network-mesh.jpg)\n\nWhen installing a multi-network, primary-remote mode Istio mesh, for a remote Kubernetes cluster to access the control plane, an east-west Gateway needs to be installed in the Primary cluster, exposing port 15012 of the control plane istiod to the Internet. An attacker could send specially crafted messages to that port, causing the control plane to crash. If you set up a firewall to allow traffic from only some IPs to access this port, you will be able to reduce the impact of the problem. It is recommended that you upgrade to Istio 1.13.1 immediately to resolve the issue completely.\n\n### IstioCon 2022\n\n![IstioCon 2022](istiocon-2022.jpg)\n\nFinally, as a committee member for the last and current IstioCon, I call on everyone to register for [IstioCon 2022](https:\/\/events.istio.io\/istiocon-2022\/), which will be held online on April 25! It will be an industry-focused event, a platform to connect contributors and users to discuss the uses of Istio in different architectural setups, its limitations, and where to take the project next. The main focus on end-user companies, as we look forward to sharing a diversity of case studies showing how to use Istio in production.\n', '\/en\/blog\/what-is-new-in-istio-1-13\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In February 2022, Istio released 1.13.0 and 1.13.1. This blog will give you an overview of what’s new in these two releases.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-in-2021/">Service Mesh in 2021: The Ecosystem Is Emerging</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 12, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh in 2021: The Ecosystem Is Emerging', 'A review of the development of Service Mesh in 2021.', '\nAs the service mesh architecture concept gains traction and the scenarios for its applications emerge, there is no shortage of discussions about it in the community. I have worked on service mesh with the community for 4 years now, and will summarize the development of service mesh in 2021 from this perspective. Since Istio is the most popular service mesh, this article will focus on the technical and ecological aspects of Istio.\n\n## Service mesh: a critical tech for Cloud Native Infrastructure \n\nAs one of the vital technologies [defined by CNCF](https:\/\/github.com\/cncf\/toc\/blob\/main\/DEFINITION.md) for cloud native, Istio has been around for five years now. Their development has gone through the following periods.\n\n- Exploration phase: 2017-2018\n- Early adopter phase: 2019-2020\n- Large-scale landing and ecological development phase: 2021-present\n\nService mesh has crossed the “chasm”(refer [Crossing the Chasm](https:\/\/thinkinsights.net\/strategy\/crossing-the-chasm\/) theory) and is in between the “early majority” and “late majority” phases of adoption. Based on feedback from the audience of [Istio Weekly,](https:\/\/github.com\/tetratelabs\/istio-weekly\/) users are no longer blindly following new technologies for experimentation and are starting to consider whether they need them in their organization dialectically.\n\n![Cross the chasm](008i3skNly1gysddnj9i2j30sg0fqaaz.jpg)\n\nWhile new technologies and products continue to emerge, the service mesh, as part of the cloud native technology stack, has continued to solidify its position as the “cloud native network infrastructure” over the past year. The diagram below illustrates the cloud native technology stack model, where each layer has several representative technologies that define the standard. As new-age middleware, the service mesh mirrors other cloud native technologies, such as [Dapr](https:\/\/dapr.io\/) (Distributed Application Runtime), which represents the capability model for cloud native middleware, [OAM](https:\/\/oam.dev\/), which defines the cloud native application model, and the service mesh, which defines the L7 network model.\n\n![Cloud Native Stack](008i3skNly1gysddogtenj30sg0qlwgs.jpg)\n\nA layered view of the cloud native application platform technology stack\n\n## Optimizing the mesh for large scale production applications with different deployment models\n\nOver the past year, the community focused on the following areas.\n\n- Performance optimization: performance issues of service mesh in large-scale application scenarios.\n- Protocol and extensions: enabling service mesh to support arbitrary L7 network protocols.\n- Deployment models: Proxyless vs. Node model vs. Sidecar model.\n- eBPF: putting some of the service mesh’s capabilities to the kernel layer.\n\n### Performance optimization\n\nIstio was designed to serve service to service traffic by “proto-protocol forwarding”. The goal is making the service mesh as “transparent” as possible to applications. Thus using IPtables to hijack the traffic, according to the community-provided test results Istio 1.2 adds only 3 ms to the baseline latency for a mesh with 1000 RPS on 16 connections. However, because of issues inherent in the IPtables conntrack module, Istio’s performance issues begin to emerge as the mesh size increases. To optimize the performance of the Istio sidecar for resource usage and network latency, the community gave the following solutions.\n\n- Sidecar configuration: By configuring service dependencies manually or by adding an Operator to the control plane, the number of service configurations sent to Sidecar can be reduced, thus reducing the resource footprint of the data plane; for more automatic and intelligent configuration of Sidecar, the open source projects [Slime](https:\/\/github.com\/slime-io\/slime) and [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) both offer their innovative configuration loading solutions.\n- The introduction of eBPF: eBPF can be a viable solution to optimize the performance of the service mesh. Some Cilium-based startups even radically propose to use eBPF to replace the Sidecar proxy completely. Still, the Envoy proxy\/xDS protocol has become the proxy for the service mesh implementation and supports the Layer 7 protocol very well. We can use eBPF to improve network performance, but complex protocol negotiation, parsing, and user scaling remain challenging to implement on the user side.\n\n### Protocol and extensions\n\nExtensibility of Istio has always been a significant problem, and there are two aspects to Istio’s extensibility.\n\n- Protocol level: allowing Istio to support all L7 protocols\n- Ecological: allowing Istio to run more extensions\n\nIstio uses Envoy as its data plane. Extending Istio is essentially an extension of Envoy’s functionality. Istio’s official solution is to use WebAssembly, and in Istio 1.12, the [Wasm plugin configuration API](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was introduced to extend the Istio ecosystem. Istio’s extension mechanism uses the [Proxy-Wasm Application Binary Interface (ABI)](https:\/\/github.com\/proxy-wasm\/spec) specification to provide a set of proxy-independent streaming APIs and utilities that can be implemented in any language with an appropriate SDK. Today, Proxy-Wasm’s SDKs are AssemblyScript (similar to TypeScript), C\u002b\u002b, Rust, Zig, and Go (using the TinyGo WebAssembly System Interface).\n\nThere are still relatively few WebAssembly extensions available, and many enterprises choose to customize their CRD and build a service mesh management plane based on Istio. In addition, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is also in strong demand for end-users. It allows them to migrate applications from traditional loads to service mesh easily. Finally, there is the hybrid cloud traffic management with multiple clusters and mesh, which is a more advanced requirement.\n\n### Deployment models\n\nWhen the service mesh concept first emerged, there was a debate between the Per-node and Sidecar models, represented by Linkerd and Istio. eBPF later proposed a kernel to sink the service mesh, which led to more service mesh deployment models, as shown in the figure below.\n\n![Service Mesh Deployment Models](008i3skNly1gysddpco2mj30qz0sgwhk.jpg)\n\nThese four deployment methods have their own advantages and disadvantages, the specific choice of which depends on the actual situation.\n\n### Development of the Istio ecosystem and the projects that support Istio\n\n2021 was also an exciting year for the Istio community, with a series of events and tutorials.\n\n- February, the first Istio distribution, [Tetrate Istio Distro (TID)](https:\/\/istio.tetratelabs.io\/).\n- February, the first [IstioCon](https:\/\/events.istio.io\/istiocon-2021\/) was held online, with over 2,000 participants.\n- March, the first free online [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals) is released.\n- May, the first [Certification Istio Administrator exam](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator) be released.\n- May, ServiceMeshCon Europe was held online.\n- July, [Istio Meetup China](https:\/\/istio.io\/latest\/zh\/blog\/2021\/istiomeetups-china\/) was held in Beijing with more than 100 attendees.\n- October, ServiceMeshCon North America was held in Los Angeles.\n\nThere are also numerous open source projects related to Istio Service Mesh, as shown in the table below.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\nNote: Data is as of January 6, 2022\n\n## Summary\n\nLooking back, we can see that, unlike previous years where users were experimenting, users in 2021 looked for more practical uses for service mesh before implementing them. Their position as the infrastructure of cloud native networks is further strengthened, and more importantly, the service mesh ecosystem is emerging. Looking ahead, in 2022, two technologies to watch are eBPF and WebAssembly(Wasm). We believe that more good examples of service mesh practices will emerge, taking the ecology and standardization a step further.\n', '\/en\/blog\/service-mesh-in-2021\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A review of the development of Service Mesh in 2021.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-extensions-slime-and-aeraki/">Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 10, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Slime and Aeraki in the Evolution of Istio Open-Source Ecosystem', 'In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.', '\nIt’s been more than [four years](https:\/\/www.tetrate.io\/blog\/happy-istio-4th-anniversary-retrospect-and-outlook\/) since Istio launched in May 2017, and while the project has had a strong following on GitHub and 10\u002b releases, its growing open-source ecosystem is still in its infancy. \n\nRecently added support for [WebAssembly extensions](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) has made the most popular open source service mesh more extensible than ever. This table lists the open-source projects in the Istio ecosystem as of November 11, 2021, sorted by open-source date. These projects enhance the Istio service mesh with gateways, extensions, utilities, and more. In this article, I’ll highlight the two new projects in the category of extensions.\n\n| **Project**                                                  | **Value**                                                    | **Relationship with Istio**                                  | **Category** | **Launch Date** | **Dominant company** | **Number of stars** |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | --------------- | -------------------- | ------------------- |\n| [Envoy](https:\/\/github.com\/envoyproxy\/envoy)                 | Cloud native high-performance edge\/middle-service proxy      | The default data plane                                       | proxy        | September 2016  | Lyft                 | 18700               |\n| [Istio](https:\/\/github.com\/istio\/istio\/)                     | Connection, secure, control, and observation services.       | Control plane                                                | service mesh | May 2017        | Google               | 29100               |\n| [Emissary Gateway](https:\/\/github.com\/emissary-ingress\/emissary) | Kubernetes native API gateway for microservices, built on Envoy | Connectable to Istio                                         | gateway      | February 2018   | Ambassador           | 3600                |\n| [APISIX](https:\/\/github.com\/apache\/apisix)                   | Cloud native API gateways                                    | It can run as a data plane for Istio or as a gateway on its own | gateway      | June 2019       | API7                 | 8100                |\n| [MOSN](https:\/\/github.com\/mosn\/mosn)                         | Cloud native edge gateways \u0026 agents                          | Available as Istio data plane                                | proxy        | December 2019   | Ant                  | 3500                |\n| [Slime](https:\/\/github.com\/slime-io\/slime)                   | Intelligent service mesh manager based on Istio              | Adding a management plane to Istio                           | extensions   | January 2021    | NetEase              | 236                 |\n| [GetMesh](https:\/\/github.com\/tetratelabs\/getmesh)            | Istio integration and command-line management tools          | Utility for Istio multi-version management                   | tools        | February 2021   | Tetrate              | 95                  |\n| [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki)         | Manage any of Istio’s seven layers of load                   | Extended multi-protocol support                              | extensions   | March 2021      | Tencent              | 330                 |\n| [Layotto](https:\/\/github.com\/mosn\/layotto\/)                  | Cloud native application runtime                             | Using as a data plane for Istio                              | runtime      | June 2021       | Ant                  | 393                 |\n| [Hango Gateway](https:\/\/github.com\/hango-io\/hango-gateway)   | API gateways built on Envoy and Istio                        | Integrates with Istio                                        | gateway      | August 2021     | NetEase              | 253                 |\n\n### **Slime: an intelligent service mesh manager for Istio**\n\n[Slime](https:\/\/github.com\/slime-io\/slime) is an Istio-based, intelligent mesh manager open-sourced by NetEase’s microservices team. Based on the Kubernetes Operator implementation, Slime can be used as a CRD manager that seamlessly interfaces with Istio without needing any customization or definition of dynamic service governance policies. This achieves automatic and convenient use of Istio and Envoy’s advanced features.\n\nSlime addresses the following issues:\n\n- Implementing higher-level extensions in Istio. For example, extending the HTTP plugin; adaptive traffic limiting based on the resource usage of the service.\n- Poor performance arising from Istio sending all the configurations within the mesh to each sidecar proxy.\n\nSlime solves these problems by building an Istio management plane. Its main purpose are\n\n- to build a pluggable controller to facilitate the extension of new functions.\n- to obtain data by listening to the data plane to intelligently generate the configuration for Istio.\n- to build a higher-level CRD for the user to configure, which Slime converts into an Istio configuration.\n\nThe following diagram shows the flow chart of Istio as an Istio management plane.\n\n![Slime architecture](slime-arch.png)\n\nThe specific steps for Slime to manage Istio are as follows.\n\n1. Slime operator completes the initialization of Slime components in Kubernetes based on the administrator’s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to Kubernetes clusters.\n3. Slime queries the monitoring data of the relevant service stored in Prometheus and converts the Slime CRD into an Istio CRD, in conjunction with the configuration of the adaptive part of the Slime CRD while pushing it to the Global Proxy.\n4. Istio listens for the creation of Istio CRDs.\n5. Istio pushes the configuration information of the Sidecar Proxy to the corresponding Sidecar Proxy in the data plane.\n\nThe diagram below shows the internal architecture of Slime.\n\n![Slime Internal](slime-internal.png)\n\nWe can divide Slime internally into three main components.\n\n- **slime-boot**: operator for deploying Slime modules on Kubernetes.\n- **slime-controller**: the core component of Slime that listens to the Slime CRD and converts it to an Istio CRD.\n- **slime-metric**: the component used to obtain service metrics information. slime-controller dynamically adjusts service governance rules based on the information it receives.\n\nThe following diagram shows the architecture of Slime Adaptive Traffic Limiting.\n![Slime smart limiter](slime-smart-filter.png)\n\nSlime dynamically configures traffic limits by interfacing with the Prometheus metric server to obtain real-time monitoring.\n\nSlime’s adaptive traffic limitation process has two parts: one that converts SmartLimiter to[ EnvoyFilter](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/envoy-filter\/) and the other that monitors the data. Slime also provides an external monitoring data interface (Metric Discovery Server) that allows you to sync custom monitoring metrics to the traffic limiting component via MDS.\n\nThe CRD SmartLimiter created by Slime is used to configure adaptive traffic limiting. Its configuration is close to natural semantics, e.g., if you want to trigger an access limit for Service A with a limit of 30QPS when the CPU exceeds 80%, the corresponding SmartLimiter is defined as follows.\n\n\u0060\u0060\u0060yaml\napiVersion: microservice.netease.com\/v1alpha1\nkind: SmartLimiter\nmetadata:\n  name: a\n  namespace: default\nspec:\n  descriptors:\n  -  action:\n       fill_interval:\n         seconds: 1\n         quota: \u002230\/{pod}\u0022 # 30 is the quota for this service. If there are three pods, the limit is 10 per pod.\n       condition: \u0022{cpu}\u003e0.8\u0022 # Auto-fill the template based on the value of the monitor {cpu}\n\u0060\u0060\u0060\n\n### **Aeraki: A Non-Invasive Istio Extension Toolset**\n\n[Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) is a service mesh project open sourced by Tencent Cloud in March 2021. Aeraki provides an end-to-end cloud-native service mesh protocol extension solution that provides Istio with powerful third-party protocol extension capabilities in a non-intrusive way, supporting traffic management for Dubbo, Thrift, Redis, and private protocols in Istio. Aeraki’s architecture is shown in the following diagram.\n\n![Aeraki architecture](aeraki-architecture.png)\n\nAeraki architecture, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nAs seen in the Aeraki architecture diagram, the Aeraki protocol extension solution consists of two components.\n\n- **Aeraki**: Aeraki runs as an Istio enhancement component on the control plane, providing user-friendly traffic rule configurations to operations via CRDs. Aeraki translates these traffic rule configurations into Envoy configurations distributed via Istio to sidecar proxies on the data plane. Aeraki also acts as an RDS server providing dynamic routing to the MetaProtocol Proxy on the data plane. The RDS provided by Aeraki differs from Envoy’s RDS in that Envoy RDS primarily offers dynamic routing for the HTTP protocol, while Aeraki RDS is designed to provide dynamic routing capabilities for all L7 protocols developed on the MetaProtocol framework.\n- **MetaProtocol Proxy**: A generic L7 protocol proxy based on Envoy implementation. MetaProtocol Proxy is an extension of Envoy. It unifies the basic capabilities of service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for L7 protocols, which greatly reduces the difficulty of developing third-party protocols on Envoy and allows you to quickly create a third-party protocol plug-in based on MetaProtocol by only implementing the codec interface.\n\nBefore the introduction of MetaProtocol Proxy, if you wanted to use Envoy to implement an L7 protocol to implement routing, traffic limiting, telemetry, etc., you needed to write a complete TCP filter, which would have required a lot of work. For most L7 protocols, the required traffic management capabilities are similar, so there is no need to duplicate this work in each L7 filter implementation. The Aeraki project uses a MetaProtocol Proxy to implement these unified capabilities, as shown in the following figure.\n\n![MetaProtocol proxy](metaprotocol-proxy.png)\n\nMetaProtocol proxy, source [Istio blog](https:\/\/istio.io\/latest\/blog\/2021\/aeraki\/).\n\nBased on MetaProtocol Proxy, we only need to implement the codec interface part of the code to write a new L7 protocol Envoy Filter. In addition, without adding a single line of code, Aeraki can provide configuration distribution and RDS dynamic routing configuration for this L7 protocol at the control plane.\n\n### **Make Istio work for all environments and workloads**\n\nWe have seen that NetEase and Tencent are scaling Istio mainly by building Operator. However, this scaling is not enough for multi-cluster management. We know that much of our current infrastructure is transitioning to cloud native or containerized, which means containers, virtual machines, and other environments co-exist. How do we unify traffic management of these different environments? It is possible to do so using Istio.\n\nYou have to again build a management plane on top of Istio and add an abstraction layer to add CRDs that apply to cluster management, such as cluster traffic configuration, policy configuration, etc. Additionally, you have to deploy a Gateway in each cluster that connects uniformly to an edge proxy that interconnects all the groups. \n\nTo learn more about Tetrate Service Bridge (TSB), which provides this layer of infrastructure, you can go [here](https:\/\/www.tetrate.io\/tetrate-service-bridge\/). TSB is built on the open source Istio with enhancements, it follows the concept of the above two open source projects, and also builds a management plane to support heterogeneous environments.\n\nAs we can see, the Istio-based projects and the open source environment are booming and companies like Tetrate are doing useful jobs of productizing and making Istio available to all workloads.\n\n', '\/en\/blog\/istio-extensions-slime-and-aeraki\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">In this article, I’ll introduce you two Istio extension projects: Aeraki and Slime.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/the-debate-in-the-community-about-istio-and-service-mesh/">The Debate in the Community About Istio and Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 17, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Debate in the Community About Istio and Service Mesh', 'There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.', '\nYou can use Istio to do [multi-cluster management](https:\/\/www.tetrate.io\/blog\/multicluster-management-with-kubernetes-and-istio\/), [API Gateway](https:\/\/www.tetrate.io\/blog\/istio-servicemesh-api-gateway\/), and manage applications on Kubernetes or [virtual machines](https:\/\/www.tetrate.io\/blog\/istio-18-a-virtual-machine-integration-odyssey\/). In my [last blog](https:\/\/www.tetrate.io\/blog\/why-is-service-mesh-a-necessary-part-of-cloud-native\/), I talked about how service mesh is an integral part of cloud native applications. However, building infrastructure can be a big deal. There is no shortage of debate in the community about the practicability of service mesh and Istio– here’s a list of common questions and concerns, and how to address them.\n\n- Is anyone using Istio in production?\n- What is the impact on application performance due to the many resources consumed by injecting sidecar into the pod?\n- Istio supports a limited number of protocols; is it scalable?\n- Will Istio be manageable? – Or is it too complex, old services too costly to migrate, and the learning curve too steep?\n\nI will answer each of these questions below.\n\n### Istio is architecturally stable, production-ready, and ecologically emerging\n\n[Istio 1.12](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/) was just released in November – and has evolved significantly since the explosion of service mesh in 2018 (the year Istio co-founders established Tetrate). Istio has a large community of providers and [users](https:\/\/istio.io\/latest\/about\/case-studies\/). The Istio SIG of Cloud Native Community has held eight Istio Big Talk (Istio 大咖说), with Baidu, Tencent, NetEase, Xiaohongshu(小红书), and Xiaodian Technology(小电科技) sharing their Istio practices. According to [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), about 50% of the companies surveyed are using a service mesh in production or planning to in the next year, and about half (47%) of organizations using a service mesh in production are using Istio.\n\nMany companies have developed extensions or plugins for Istio, such as Ant, NetEase, eBay, and Airbnb. Istio’s architecture has been stable since the 1.5 release, and the release cycle is fixed quarterly, with the current project’s main task being Day-2 Operations. \n\nThe Istio community has also hosted various events, with the first IstioCon in March 2021, the Istio Meetup China in Beijing in July, and the Service Mesh Summit 2022 in Shanghai in January 2022.\n\nSo we can say that the Istio architecture is stable and production-ready, and the ecosystem is budding.\n\n### The impact of service mesh on application performance\n\nA service mesh uses iptables to do traffic hijacking by default to be transparent to applications. When the number of services is large, there are a lot of iptables rules that affect network performance. You can use techniques like [eBPF](https:\/\/cloudnativecn.com\/blog\/how-ebpf-streamlines-the-service-mesh\/) to provide application performance, but the method requires a high version of the operating system kernel, which few enterprises can achieve.\n\n![Istio DNS](008i3skNly1gxgyfcfm5oj30sg0djmxt.jpg)\n\nIn the early days, Istio distributed the routing information of all services in the mesh to all proxy sidecars, which caused [sidecar](https:\/\/istio.io\/latest\/docs\/reference\/config\/networking\/sidecar\/)s to take up a lot of resources. [Aeraki](https:\/\/github.com\/aeraki-framework\/aeraki) and [Slime](https:\/\/github.com\/slime-io\/slime) can achieve configuration lazy loading. We will introduce these two open-source projects in the Istio open-source ecosystem.\n\nFinally, there is a problem related to Sidecar proxy operation and maintenance: upgrading all Envoy proxies while ensuring constant traffic. A solution is using the [SidecarSet](https:\/\/xie.infoq.cn\/article\/23ae6d3f0d0260b4797a708a0) resource in the open-source project [OpenKruise](https:\/\/github.com\/openkruise\/kruise).\n\nThe resource consumption and network latency associated with the introduction of Sidecar are also within reasonable limits, as you can see from the [service mesh benchmark performance tests](https:\/\/istio.io\/latest\/blog\/2019\/performance-best-practices\/).\n\n### Extending the Istio service mesh\n\nThe next question is about extending the Istio service mesh. The current solution given by the Istio community is to use [WebAssembly](https:\/\/www.tetrate.io\/blog\/istio-wasm-extensions-and-ecosystem\/), an extension that is still relatively little used in production by now and has performance concerns. Most of the answers I’ve observed are CRDs that build a service mesh management plane based on Istio.\n\nAlso, making Istio support heterogeneous environments for all workloads, such as virtual machines and containers, is in strong demand for end-users. It allows them to migrate applications from traditional loads to cloud native easily. Finally, hybrid cloud traffic management for multiple clusters and meshes is a more advanced requirement.\n\n### Steep learning curve\n\nMany people complain that Istio has too little learning material. Istio has been open source for four years, and there are a lot of learning resources now:\n\n- [Istio Documentation](https:\/\/istio.io\/)\n- [IstioCon 2021](https:\/\/events.istio.io\/istiocon-2021\/)\n- [Istio Big Talk\/Istio Weekly](https:\/\/github.com\/tetratelabs\/istio-weekly)\n- [Istio Fundamentals Course](https:\/\/academy.tetrate.io\/courses\/istio-fundamentals)\n- [Certified Istio Administrator](https:\/\/academy.tetrate.io\/courses\/certified-istio-administrator)\n\nYes, Istio is complex, but it’s been getting more and more manageable with every release. In my next blog, I will introduce you to two open source projects that extend Istio and give you some insight into what’s going on in the Istio community.\n', '\/en\/blog\/the-debate-in-the-community-about-istio-and-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">There is no shortage of debate in the community about the practicability of service mesh and Istio – here’s a list of common questions and concerns, and how to address them.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-an-integral-part-of-cloud-native-apps/">Service Mesh - An Integral Part of Cloud-Native Applications</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 12, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh - An Integral Part of Cloud-Native Applications', 'This article will explore the relationship between service mesh and cloud native.', '\nIf you don’t know what Istio is, you can read my previous articles below:\n\n- [What Is Istio and Why Does Kubernetes Need it?](https:\/\/www.tetrate.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)\n- [Why do you need Istio when you already have Kubernetes?](https:\/\/www.tetrate.io\/blog\/why-do-you-need-istio-when-you-already-have-kubernetes\/)\n\nThis article will explore the relationship between service mesh and cloud native.\n\n### Service mesh – the product of the container orchestration war\n\nIf you’ve been following the cloud-native space since its early days, you’ll remember the container orchestration wars of 2015 to 2017. Kubernetes won the container wars in 2017, the idea of microservices had taken hold, and the trend toward containerization was unstoppable. Kubernetes architecture matured and slowly became boring, and service mesh technologies, represented by Linkerd and Istio, entered the CNCF-defined cloud-native critical technologies on the horizon.\n\nKubernetes was designed with the concept of cloud-native in mind. A critical idea in cloud-native is the architectural design of microservices. When a single application is split into microservices, how can microservices be managed to ensure the SLA of the service as the number of services increases? The service mesh was born to solve this problem at the architectural level, free programmers’ creativity, and avoid tedious service discovery, monitoring, distributed tracing, and other matters.\n\nThe service mesh takes the standard functionality of microservices down to the infrastructure layer, allowing developers to focus more on business logic and thus speed up service delivery, which is consistent with the whole idea of cloud-native. You no longer need to integrate bulky SDKs in your application, develop and maintain SDKs for different languages, and just use the service mesh for Day 2 operations after the application is deployed.\n\nThe service mesh is regarded as the next generation of microservices. In the diagram, we can see that many of the concerns of microservices overlap with the functionality of Kubernetes. Kubernetes focuses on the application lifecycle, managing resources and deployments with little control over services. The service mesh fills this gap. The service mesh can connect, control, observe and protect microservices.\n\n### **Kubernetes vs. xDS vs. Istio**\n\nThis diagram shows the layered architecture of Kubernetes and Istio.\n\n![Kubernetes vs xDS vs Istio](008i3skNly1gxgxss9mamj30n90d73zs.jpg)\n\nThe diagram indicates that the kube-proxy settings are global and cannot be controlled at a granular level for each service. All Kubernetes can do is topology-aware routing, routing traffic closer to the Pod, and setting network policies in and out of the Pod.\n\nIn contrast, the service mesh takes traffic control out of the service layer in Kubernetes through sidecar proxies, injects proxies into each Pod, and manipulates these distributed proxies through a control plane. It allows for more excellent resiliency.\n\nKube-proxy implements traffic load balancing between multiple pod instances of a Kubernetes service. But how do you finely control the traffic between these services — such as dividing the traffic by percentage to different application versions (which are all part of the same service, but on other deployments), or doing canary releases and blue-green releases?\n\nThe Kubernetes community gives a way to do canary releases using Deployment, assigning different pods to deployed services by modifying the pod’s label.\n\n![Envoy Architecture](008i3skNly1gxgxsswmoij30sg0kl76r.jpg)\n\nCurrently, the most popular open-source implementation of service mesh in the world is Istio. From the [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf), we know that Istio is the most used service mesh in production today. Many companies have built their service mesh based on Istio, such as Ant, Airbnb, eBay, NetEase, Tencent, etc.\n\n![CNCF Survey Report 2020](008i3skNly1gxgxstgg4qj30sg0gg0ts.jpg)\n\nFigure from [CNCF Survey Report 2020](https:\/\/www.cncf.io\/wp-content\/uploads\/2020\/11\/CNCF_Survey_Report_2020.pdf)\n\nIstio is developed based on Envoy, which has been used by default as its distributed proxy since the first day it was open-sourced. Envoy pioneered the creation of the xDS protocol for distributed gateway configuration, greatly simplifying the configuration of large-scale distributed networks. Ant Group open source MOSN also supported xDS In 2019. Envoy was also one of the first projects to graduate from CNCF, tested by large-scale production applications.\n\n### Service mesh – the cloud-native networking infrastructure\n\nWith the above comparison between Kubernetes and service mesh in mind, we can see the place of service mesh in the cloud-native application architecture. That is, building a cloud-native network infrastructure specifically provides:\n\n- Traffic management: controlling the flow of traffic and API calls between services, making calls more reliable, and enhancing network robustness in different environments.\n- Observability: understanding the dependencies between services and the nature and flow of traffic between them provides the ability to identify problems quickly.\n- Policy enforcement: controlling access policies between services by configuring the mesh rather than by changing the code.\n- Service Identification and Security: providing service identifiability and security protection in the mesh.\n', '\/en\/blog\/service-mesh-an-integral-part-of-cloud-native-apps\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article will explore the relationship between service mesh and cloud native.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/istio-servicemesh-api-gateway/">Using Istio Service Mesh as API Gateway</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Aug 6, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Using Istio Service Mesh as API Gateway', 'What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.', '\nAPI gateways have been around for a long time as the entry point for clients to access the back-end, mainly to manage “north-south” traffic, In recent years, service mesh architectures have become popular, mainly for managing internal systems,(i.e. “east-west” traffic), while a service mesh like Istio also has built-in gateways that bring traffic inside and outside the system under unified control. This often creates confusion for first-time users of Istio. What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.\n\n## Key Insights\n\n- The service mesh was originally created to solve the problem of managing internal traffic for distributed systems, but API gateways existed long before it.\n- While the Gateway is built into Istio, you can still use a custom Ingress Controller to proxy external traffic.\n- API gateways and service mesh are converging.\n\n## How do I expose services in the Istio mesh?\n\nThe following diagram shows four approaches to expose services in the Istio mesh using Istio Gateway, Kubernetes Ingress, API Gateway, and NodePort\/LB.\n\n![Exposing services through Istio Ingress Gateway](access-cluster.svg)\n\nThe Istio mesh is shaded, and the traffic in the mesh is internal (east-west) traffic, while the traffic from clients accessing services within the Kubernetes cluster is external (north-south) traffic. \n\n| **Approach**          | **Controller**     | **Features**                                                 |\n| --------------------- | ------------------ | ------------------------------------------------------------ |\n| NodePort\/LoadBalancer | Kubernetes         | Load balancing                                               |\n| Kubernetes Ingress    | Ingress controller | Load balancing, TLS, virtual host, traffic routing           |\n| Istio Gateway         | Istio              | Load balancing, TLS, virtual host, advanced traffic routing, other advanced Istio features |\n| API Gateway           | API Gateway        | Load balancing, TLS, virtual host, advanced traffic routing, API lifecycle management, billing, rate limiting, policy enforcement, data aggregation |\n\nSince NodePort\/LoadBalancer is a basic way to expose services built into Kubernetes, this article will not discuss that option. Each of the other three approaches will be described below.\n\n## Using Kubernetes Ingress to expose traffic\n\nWe all know that clients of a Kubernetes cluster cannot directly access the IP address of a pod because the pod is in a network plane built into Kubernetes. We can expose services inside Kubernetes outside the cluster using NodePort or Load Balancer Kubernetes service type. To support virtual hosting, hiding and saving IP addresses, you can use Ingress resources to expose services in Kubernetes.\n\n![Kubernetes Ingress to expose services](ingress.svg)\n\nIngress is a Kubernetes resource that controls the behavior of an ingress controller that does the traffic touring, which is the equivalent of a load-balanced directional proxy server such as Nginx, Apache, etc., which also includes rule definitions, i.e., routing information for URLs, which is provided by the [Ingress controller](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/#ingress-controllers).\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io\/ingress.class: istio\n  name: ingress\nspec:\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/status\/*\n        backend:\n          serviceName: httpbin\n          servicePort: 8000\n\u0060\u0060\u0060\n\nThe *kubernetes.io\/ingress.class: istio* annotation in the example above indicates that the Ingress uses the Istio Ingress Controller which in fact uses Envoy proxy. \n\n## Using Istio Gateway to expose services\n\nIstio is a popular service mesh implementation that has evolved from Kubernetes that implements some features that Kubernetes doesn’t. (See [What is Istio and why does Kubernetes need Istio?](https:\/\/www.tetrate.io\/blog\/what-is-istio-and-why-does-kubernetes-need-it\/)) It makes traffic management transparent to the application, moving this functionality from the application to the platform layer and becoming a cloud-native infrastructure.\n\nIstio used Kubernetes Ingress as the traffic portal in versions prior to Istio 0.8, where Envoy was used as the Ingress Controller. From Istio 0.8 and later, Istio created the Gateway object. Gateway and VirtualService are used to represent the configuration model of Istio Ingress, and the default implementation of Istio Ingress uses the same Envoy proxy. In this way, the Istio control plane controls both the ingress gateway and the internal sidecar proxy with a consistent configuration model. These configurations include routing rules, policy enforcement, telemetry, and other service control functions.\n\nThe Istio Gateway resources function similarly to the Kubernetes Ingress in that it is responsible for north-south traffic to and from the cluster. The Istio Gateway acts as a load balancer to carry connections to and from the edge of the service mesh. The specification describes a set of open ports and the protocols used by those ports, as well as the SNI configuration for load balancing, etc.\n\nThe Istio Gateway resource itself can only be configured for L4 through L6, such as exposed ports, TLS settings, etc.; however, the Gateway can be bound to a VirtualService, where routing rules can be configured on L7, such as versioned traffic routing, fault injection, HTTP redirects, HTTP rewrites, and all other routing rules supported within the mesh.\n\nBelow is an example of a Gateway binding to a VirtualService. The pod with the “istio: ingressgateway” label will act as the Ingress controller and route HTTP traffic to port 80 of the httpbin.example.com virtual host. The biggest difference between this and using Kubernetes Ingress is that it requires us to manually bind the VirtualService to the Gateway and specify the pod where the Gateway is located. This configuration is equivalent to opening up an entry point to Kubernetes for external access.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \u0022httpbin.example.com\u0022\n\u0060\u0060\u0060\n\nThe VirtualService below is bound to the gateway above via *gateways* to accept traffic from that gateway.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\nspec:\n  hosts:\n  - \u0022httpbin.example.com\u0022\n  gateways:\n  - httpbin-gateway\n  http:\n  - match:\n    - uri:\n        prefix: \/status\n    route:\n    - destination:\n        port:\n          number: 8000\n        host: httpbin\n\u0060\u0060\u0060\n\n## Using an API Gateway\n\nAPI gateways are API management tools that sit between the client and the back-end service and are widely used in microservices as a way to separate the client interface from the back-end implementation. When a client makes a request, the API gateway breaks it down into multiple requests, then routes them to the correct location, generates a response, and keeps track of everything. \n\nThe API Gateway is a special type of service in the microservices architecture that serves as the entry point for all microservices and is responsible for performing routing requests, protocol conversions, aggregating data, authentication, rate limiting, circuit breaking, and more. Most enterprise APIs are deployed through API Gateways, which typically handle common tasks across API service systems, such as TLS termination, authentication and authorization, rate limiting, and statistical information.\n\nThere can be one or more API Gateways in the mesh. The responsibilities of the API Gateway are\n\n- Request routing and version control\n- Facilitating the transition of monolithic applications to microservices\n- Permission authentication\n- Data aggregation: monitoring and billing\n- Protocol conversion\n- Messaging and caching\n- Security and alerting\n\nMany of the above basic functions such as routing and permission authentication can also be achieved through Istio Gateway, but some mature API gateways may be more advantageous in terms of feature richness and scalability.\n\n- The introduction of API Gateway requires consideration of the deployment, operation and maintenance, load balancing, and other scenarios of API Gateway itself, which increases the complexity of back-end services.\n- An API Gateway carries a large number of interface adaptations, which makes it difficult to maintain.\n- For some scenarios, the addition of a hop may lead to a reduction in performance.\n\nCurrently, some API Gateway imitations are building their own service mesh by deploying them in the sidecar.\n\n## Summary\n\nIn the Istio mesh, you can use a variety of Kubernetes Ingress Controllers to act as entry gateways, but of course, you can also use Istio’s built-in Istio Gateway directly, for policy control, traffic management, and usage monitoring. The advantage of this is that the gateway can be managed directly through Istio’s control plane, without the need for additional tools. But for functions such as API statement cycle management, complex billing, protocol conversion, and authentication, a traditional API gateway may be a better fit for you. So, you can choose according to your needs, or you can use a combination.\n\nSome traditional reverse proxies are also moving towards Service Mesh, such as Nginx with Nginx Service Mesh and Traefik with Traefik Mesh, and some API gateway products are also moving towards Service Mesh, such as Kong with Kuma, and in the future, we will see more convergence of API gateways, reverse proxies, and service meshes.\n', '\/en\/blog\/istio-servicemesh-api-gateway\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multicluster-management-with-kubernetes-and-istio/">Multicluster Management With Kubernetes and Istio</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 12, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multicluster Management With Kubernetes and Istio', 'This article explains three patterns\/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.', '\nDo you have multiple Kubernetes clusters and a service mesh? Do your virtual machines and services in a Kubernetes cluster need to interact? This article will take you through the process and considerations of building a hybrid cloud using Kubernetes and an Istio Service Mesh. Together, Kubernetes and Istio can be used to bring hybrid workloads into a mesh and achieve interoperability for multicluster. But another layer of infrastructure — a management plane — is helpful for managing multicluster or multimesh deployments.\n\n## Kubernetes\n\nUsing Kubernetes enables rapid deployment of a distributed environment that enables cloud interoperability and unifies the control plane on the cloud. It also provides resource objects, such as Service, Ingress and [Gateway](https:\/\/kubernetes.io\/blog\/2021\/04\/22\/evolving-kubernetes-networking-with-the-gateway-api\/), to handle application traffic. The Kubernetes API Server communicates with the kube-proxy component on each node in the cluster, creates iptables rules for the node, and forwards requests to other pods.\n\nAssuming that a client now wants to access a service in Kubernetes, the request is first sent to the Ingress\/Gateway, then forwarded to the backend service (Service A in the diagram below) based on the routing configuration in the Ingress\/Gateway. Then Service A polls an instance of Service B for the traffic requested by Service B. Lastly, the traffic requested by Service A for Service B is polled forward to Service B’s instance.\n\n![Kubernetes](008i3skNly1gsgg6a11l1j31lu0u042s.jpg)\n\n## Kubernetes Multicluster\n\nThe most common usage scenarios for multicluster management include:\n\n- service traffic load balancing\n- isolating development and production environments\n- decoupling data processing and data storage\n- cross-cloud backup and disaster recovery\n- flexible allocation of compute resources\n- low-latency access to services across regions\n- avoiding vendor lock-in\n\nThere are often multiple Kubernetes clusters within an enterprise; and the [KubeFed](https:\/\/github.com\/kubernetes-sigs\/kubefed) implementation of Kubernetes cluster federation developed by [Multicluster SIG](https:\/\/github.com\/kubernetes\/community\/blob\/master\/sig-multicluster\/README.md) enables multicluster management capabilities, which allows all Kubernetes clusters to be managed through the same interface.\n\nThere are several general issues that need to be addressed when using cluster federation:\n\n- Configuring which clusters need to be federated\n- API resources need to be propagated across the clusters\n- Configuring how API resources are distributed to different clusters\n- Registering DNS records in clusters to enable service discovery across clusters\n\nThe following is a multicluster architecture for [KubeSphere](https:\/\/kubesphere.io\/) — one of the most commonly used Kubernetes multicluster management architectures — where the Host Cluster serves as the control plane with two member clusters, West and East.\n\n![Multicluster](008i3skNly1gsgg7a2ojvj31aa0u0491.jpg)\n\nThe Host Cluster needs to be able to access the API Server of the Member Cluster, but the network connectivity between Member Clusters is not required. The Host Cluster is independent of the Member Cluster it manages and the Member Cluster is not aware of the existence of the Host Cluster. The advantage of this is that when the control plane fails, the Member Cluster will not be affected and the deployed load can still operate normally without being affected.\n\nThe Host Cluster also assumes the role of API portal, and the Host Cluster forwards the resource requests to the Member Cluster — which is convenient for aggregation and also facilitates unified authority authentication. We see that there is a Federation Control Plane in the Host Cluster, where the Push Reconciler propagates the identity, role, and role binding from the Federation Cluster to all Member Clusters.\n\n## Istio Service Mesh\n\nConsider using the Istio service mesh when we have multilingual, multiversion microservices running in Kubernetes and need finer-grained canary publishing and unified security policy management for inter-service observability. Istio enables intelligent application-aware load balancing from the application layer to other Service Mesh-enabled services in the cluster, by transparently intercepting all traffic to and from the application using IPTables, and bypassing the primary kube-proxy load balancing. The Istio control plane communicates with the Kubernetes API Server to obtain information about all registered services in the cluster.\n\nThe following diagram illustrates the basics of Istio, where all nodes belong to the same Kubernetes cluster.\n\n![Istio Service Mesh](008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg)\n\nYou may end up with at least a few Kubernetes clusters, each hosting microservices. Multiple [deployment models](https:\/\/istio.io\/latest\/docs\/setup\/install\/multicluster\/) exist for Istio’s multicluster deployments — depending on network isolation, primary and backup — which can be specified by declaration when deploying using Istio Operator. Communication between these microservices in a cluster can be enhanced by a service mesh. Within the cluster, Istio provides common communication patterns to improve resiliency, security and observability.\n\nAll of the above is about application load management on Kubernetes, but for legacy applications on virtual machines: how can they be managed in the same plane? Istio supports applications on virtual machines, so why do we need a management plane?\n\n## Management Plane\n\nTo manage gateways, traffic and security groupings, and apply them to different clusters and namespaces, you’ll need to add another layer of abstraction on top of Istio: a management plane. The diagram below shows the multitenant model of Tetrate Service Bridge (TSB). TSB uses Next Generation Access Control (NGAC) — a fine-grained authorization framework — to manage user access and also facilitate the construction of a zero-trust network.\n\n![Management Plane](008i3skNly1gsgg8ndcajj31il0u00z9.jpg)\n\nIstio provides workload identification, protected by strong mTLS encryption. This zero-trust model is better than trusting workloads based on topology information, such as source IP. A common control plane for multicluster management is built on top of Istio. Then a management plane is added to manage multiple clusters — providing multitenancy, management configuration, observability, and more.\n\nThe diagram below shows the architecture of Tetrate Service Bridge.\n\n![Tetrate Service Bridge](008i3skNly1gsgg951mknj314g0u0dnf.jpg)\n\n## Summary\n\nInteroperability of heterogeneous clusters is achieved with Kubernetes. Istio brings containerized and virtual machine loads into a single control plane, to unify traffic, security and observability within the clusters. However, as the number of clusters, network environments and user permissions become more complex, there is a need to build another management plane above Istio’s control plane (for example, [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/)) for hybrid cloud management.\n', '\/en\/blog\/multicluster-management-with-kubernetes-and-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains three patterns/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/">How to Debug Microservices in Kubernetes With Proxy, Sidecar or Service Mesh?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 5, 2021</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Debug Microservices in Kubernetes With Proxy, Sidecar or Service Mesh?', 'This article explains three patterns\/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.', '\nKubernetes is arguably the best environment for running microservices so far, but the experience of debugging microservices in a Kubernetes environment may not be as user-friendly. This article will show you how to debug microservices in Kubernetes, introduce common tools, and explain how the introduction of Istio impacts debugging microservices.\n\n## Debugging microservices is vastly different from traditional monolithic applications\n\nThe debugging of microservices has been a long-standing problem for software developers. This challenge does not exist in traditional monolithic applications because developers can leverage the debugger in IDEs to add breakpoints, modify environment variables, single-step execution, etc. for their applications, all of which provide great help in software debugging. With the popularity of Kubernetes, the debugging of microservices becomes a thorny issue, where the following issues are more complicated than the debugging of traditional monolithic applications.\n\n### Multiple dependencies\n\nA microservice often depends on multiple other microservices, some shared volumes across multiple microservices, and authorizations based on service accounts. When debugging a microservice, how do you deploy other dependent services to quickly build a latest set of staging environments?\n\n### Access from a local machine\n\nWhen microservices are running on a developer’s local computer, there is usually no direct access to the services in a Kubernetes cluster. How can you debug microservices deployed in a Kubernetes cluster as if they were local services?\n\n### Slow development loop\n\nUsually, it takes a long process to update the code and build it into an image before pushing it to the cluster. How do you speed up the development cycle? Let’s look at the tools that address those challenges.\n\n## Tools\n\nThe main solutions for debugging microservices in Kubernetes are:\n\n- Proxy: by building a VPN, deploying a proxy in the Kubernetes cluster, and adding local debug endpoints to make the services in Kubernetes directly accessible to local applications, your architecture will look like [ local service ] \u003c-\u003e [ proxy ] \u003c-\u003e [ app in Kubernetes ].\n- Sidecar: Inject a sidecar into the pod of the microservice to be debugged to intercept all traffic to and from the service, so that the service can be tracked and monitored, and the service can also be debugged in this sidecar.\n- Service Mesh: To get an overall picture of the application, inject sidecars into all microservices so that you can get a dashboard that monitors global status.\n\nHere are three typical open source projects that implement the above solutions, each of which can help you debug microservices from a different perspective. You can apply them at different stages of software development and they can be said to be complementary to each other.\n\n### Proxy – debugging microservices with Telepresence\n\n[Telepresence](https:\/\/www.telepresence.io\/) is essentially a local proxy that proxies data volumes, environment variables, and networks in a Kubernetes cluster locally. The following diagram shows the main usage scenarios for Telepresence.\n\n![Proxy mode: Telepresence](telepresence.jpg)\n\nUsers need to manually execute the telepresence command locally, which will automatically deploy the agent to Kubernetes. Once the agent has been deployed,\n\n- Local services will have complete access to other services in the Kubernetes cluster, environment variables, Secret, ConfigMap, etc.\n- Services in the cluster also have direct access to the locally exposed endpoints.\n\nHowever, this approach requires users to run multiple commands while debugging locally, and in some network environments it may not be possible to establish a VPN connection to the Kubernetes cluster.\n\n### Sidecar – debugging microservices with Nocalhost\n\n[Nocalhost](https:\/\/nocalhost.dev\/) is a Kubernetes-based cloud development environment. To use it, you just need to install a plugin in your IDE – VS Code to extend Kubernetes and shorten the development feedback cycle. The development environment can be isolated by creating different namespaces for different users and using ServiceAccount when binding to different user corners. Nocalhost also provides a web console and API for administrators to manage different development environments.\n\n![Sidecar mode: Nocalhost](sidecar-nocalhost.jpg)\n\nAs long as you have a Kubernetes cluster and have admin rights to the cluster, you can refer to the Nocalhost documentation to quickly start trying it out. To use the Nocalhost plugin in VS Code, you need to configure the Kubernetes cluster in the plugin first.\n\n1. Select the Kubeconfig file you just exported or copy and paste the contents of the file directly into the configuration.\n2. Then select the service you need to test and select the corresponding Dev Container. VS Code will automatically open a new code window.\n\nHere is an example of the [bookinfo sample](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/) provided by Istio. You can open the cloned code in your local IDE and click the hammer next to the code file to enter development mode. Selecting the corresponding DevContainer and Nocalhost will automatically inject a development container sidecar into the pod and automatically enter the container in the terminal, as shown in the following figure.\n\n![Nocalhost VS code](nocalhost-vs-code.jpg)\n\nIn development mode, the code is modified locally without rebuilding the image, and the remote development environment takes effect in real time, which can greatly accelerate the development speed. At the same time, Nocalhost also provides a server for managing the development environment and user rights, as shown in the following figure.\n\n![Nocalhost Web](nocalhost-web-admin.jpg)\n\n### Service Mesh – debugging microservices with Istio\n\nThe above method of using proxy and sidecar can only debug one service at a time. You’ll need a mesh to get the global status of the application, such as the metrics of the service obtained, and debug the performance of the service by understanding the dependency and invocation process of the service through distributed tracing. These observability features need to be implemented by injecting sidecar uniformly for all services. And, when your services are in the process of migrating from VMs to Kubernetes, using Istio can bring VMs and Kubernetes into a single network plane (as shown below), making it easy for developers to debug and do incremental migrations.\n\n![Service Mesh mode: Istio](istio-service-mesh.jpg)\n\nOf course, these benefits do not come without a “cost.” With the introduction of Istio, your Kubernetes services will need to adhere to the Istio naming convention and you’ll need to know how to debug microservices using the Istioctl command line and logging.\n\n- Use the *istioctl analyze* command to debug the deployment of microservices in your cluster, and you can use YAML files to examine the deployment of resources in a namespace or across your cluster.\n- Use *istioctl proxy-config secret* to ensure that the secret of a pod in a service mesh is loaded correctly and is valid.\n\n## Summary\n\nIn the process of microservicing applications and migrating from virtual machines to Kubernetes, developers need to make a lot of changes in their mindset and habits. By building a VPN between local and Kubernetes via proxy, developers can easily debug services in Kubernetes as if they were local services. By injecting a sidecar into the pod, you can achieve real-time debugging and speed up the development process. Finally, the Istio service mesh truly enables global observability, and you can also use tools like [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/) to manage heterogeneous platforms, helping you gradually move from monolithic applications to microservices.\n', '\/en\/blog\/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains three patterns/tools for debugging microservices in Kubernetes and the changes brought by the introduction of Istio for debugging microservices.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/service-mesh/">
         ««
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a href="/en/tags/service-mesh/" class="page-link">
         «
       </a>
     </li>
     
     
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/tags/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/service-mesh/page/3/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/service-mesh/page/3/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(54)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(8)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Connect on LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/leveraging-envoypatchpolicy-to-extend-the-capabilities-of-envoy-gateway/">Leveraging EnvoyPatchPolicy to Extend the Capabilities of Envoy Gateway</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/beyond-sidecar/">Beyond Sidecar: A Deep Dive into Istio Ambient Mode Traffic Mechanism and Cost Efficiency</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-l7-flow-analysis/">Understanding L7 Traffic Management in Istio Ambient Mode: From ztunnel to Waypoint Proxy</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2025 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
