<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8">
  
  <title>Service Mesh - Jimmy Song</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta name="description" content="Jimmy Song&#39;s Blog">
  <meta name="author" content="Jimmy Song">
  <meta name="generator" content="Hugo 0.136.0">

  <!-- CSS plugins -->
  
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
    
    
      
    
  
  
  <link rel="preload" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" as="style">
  <link rel="stylesheet" href="/css/combined.7ac6b2864cb09c5595ac8ca79f8ca0db6c69a657edac885ba2c2412080d68da0.css" media="screen">
  

  <!-- Main Stylesheet -->
  
  <link rel="preload" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" as="style">
  <link rel="stylesheet" href="/scss/style.min.784204edcd29c092198e88494fa2ae755eba9ae231d6fa7faf8e7da3207b4623.css" media="screen">

  <!-- Bigger picture css -->
  
  <link rel="stylesheet" href="/plugins/bigger-picture/bigger-picture.min.css" media="print" onload="this.media='all'">
  <!--Favicon generate by https://realfavicongenerator.net-->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="200x200" href="/images/favicon.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">

  <link href='/opensearchdescription.xml' rel='search' title='Content search' type='application/opensearchdescription+xml'/>

  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="jimmysong.io" />
  <meta name="twitter:creator" content="@jimmysongio" />
  <meta property="og:url" content="https://jimmysong.io/en/tags/service-mesh/" />
  <meta property="og:title" content="Service Mesh | Jimmy Song" />
  <meta property="twitter:title" content="Service Mesh | Jimmy Song" />

  
  <meta property="og:description" content="Jimmy Song&#39;s Blog" />
  <meta property="twitter:description" content="Jimmy Song&#39;s Blog" />

  
  <meta property="og:image" content="https://jimmysong.io/images/banner/default.jpg" />
  <meta property="twitter:image" content="https://jimmysong.io/images/banner/default.jpg" />

  
  
</head>
<body>
<header class="fixed-top header">
  
  
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i></button>
  
  <div class="navigation w-100 ">
    <div class="container-xl">
      <nav class="navbar navbar-expand-lg navbar-light p-0">
        <a class="navbar-brand" href="/en">
            
            <b>JIMMY SONG</b>
            
        </a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/blog">Blog</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/tags">Tags</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/notice">Notice</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/contact">Contact</a>
              
            </li>
            
            
            
            <li class="nav-item">
              
              <a class="nav-link" href="/en/about">About</a>
              
            </li>
            
            

          
          
          <li class="nav-item">
            
            
            
              
              
                
                
                
                  
                    
                    
                  
                
              
              
              
                
                  
                    
                    <a class="nav-link" href="/tags/service-mesh/">中文</a>
                    
                  
                
                
                
              
          </li>
          
          
          <!-- search -->
           <button type="button" class="search-btn js-search" id="searchOpen" aria-label="Search">
              <div class="search-container d-flex justify-content-center">
              <span class="search-content">
                  <i class="fa fa-search"></i>
                  <span>Search</span>
              </span>
              <span class="search-shortcuts d-none d-sm-block">
                  <kbd class="cmd-key">⌘</kbd>
                  <kbd class="k-key">K</kbd>
              </span>
              </div>
          </button>
          
          </ul>
        </div>
      </nav>
    </div>
  </div>
</header>


            <aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between">
        <div class="col-6 search-title">
          <p>Search</p> 
        </div>
        <div class="col-6 col-search-close">
          <div class="js-search" aria-label="Close"><i class="fa-solid fa-circle-xmark text-muted" aria-hidden="true"></i></div>
        </div>
      </div>

      <div id="search-box">
        <i class="fa-solid fa-magnifying-glass" id="search-icon" aria-hidden="true"></i>
        <input name="q" id="search-query" placeholder="Input the keyword" autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control" aria-label="Input the keyword">
        
        <div class="mt-4">
          <span>Search type: </span>
          <span>
            <input type="radio" id="all" name="search_type" value="all" checked>
            <label for="all">All</label>
            
              <input type="radio" id="blog" name="search_type" value="blog">
              <label for="blog">Blog</label>
            
            <input type="radio" id="book" name="search_type" value="book">
            <label for="book">Book</label>
            <input type="radio" id="notice" name="search_type" value="notice">
            <label for="notice">Notice</label>
          </span>
        </div>
      </div>
      
    </section>
    <section class="section-search-results">
      <div id="search-results-count" class="search-results-count"></div>
      <div id="search-hits">
        
      </div>
    </section>
  </div>
</aside>

        
        
            

<section class="bg-cover page-title-section overlay" style="background-image: url('/images/backgrounds/circle.svg'),url('/images/backgrounds/page-title.webp');background-size: cover;">
    <div class="container-xl">
        <div class="row">
            <div class="col-12">
                <p class="h1">
                    Service Mesh
                </p>
                <p class="page-description">
                    
                </p>
                
            </div>
        </div>
    </div>
</section>

        


<section class="section-sm book-list-section bg-gray">
  <div class="container-xl">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          
          
          
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/multi-cluster-pki-istio-recipe/">Multi-Cluster PKI &#43; Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Oct 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Multi-Cluster PKI \u002b Istio Recipe: Practical Example for a Trusted and Scalable PKI for Your Service Mesh', 'This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.', '\nAuthors: Cristofer TenEyck Senior Solution Engineer a Keyfactor and Jimmy Song Developer Advocate at Tetrate\n\n## Introduction\n\nIn the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge. \n\nIn this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes. \n\nWhy multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters. \n\n## Understanding PKI and its Role in Service Meshes \n\nPKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments. \n\nThe EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications. \n\n## Istio, EJBCA and cert-manager \n\nSetting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included: \n\n1. **Environment Preparation**: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA). \n2. **cert-manager Integration**: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates. \n3. **Automatic Certificate Renewal**: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters. \n\n![Architecture](arch.webp)\n\n## Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary \n\nThis section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found [here](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi).\n\nThe key steps include: \n\n1. **Install and Configure Helm Repositories**: Add necessary Helm repositories for Istio, cert-manager, and EJBCA. \n2. **Deploy cert-manager and EJBCA**: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets. \n3. **Configure Istio with EJBCA**: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration. \n4. **Install Istio Components**: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway. \n5. **Customization and Overrides**: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services. \n6. **Automatic Certificate Renewal:** The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications. \n\n![Certificate renew flow](cert-renew-flow.webp)\n\nAbove is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA. \n\n## PKI Best Practices and Compliance \n\nBuilding a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider: \n\n1. **Compliance with Regulations**: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices. \n2. **Crypto Agility and Quantum Readiness**: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important. \n3. **Collaboration with InfoSec**: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals. \n\n## Conclusion \n\nImplementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant. \n\nBy following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh. \n\nFor further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below. \n\n## Resources \n\n- [Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider](https:\/\/docs.keyfactor.com\/ejbca\/latest\/tutorial-deploy-istio-service-mesh-in-a-multi)\n- [Istio documentation](https:\/\/istio.io\/latest\/docs\/)\n- [EJBCA Community edition](https:\/\/www.ejbca.org\/)\n- [cert-manager documentation](https:\/\/cert-manager.io\/docs\/)\n- [EU Cyber Resilience Act](https:\/\/digital-strategy.ec.europa.eu\/en\/policies\/cyber-resilience-act)\n- [US Executive Order on Cybersecurity](https:\/\/www.whitehouse.gov\/briefing-room\/statements-releases\/2021\/05\/12\/executive-order-on-improving-the-nations-cybersecurity\/)\n- [A Definitive Guide to Cross-Cluster Seamless Access in Multicluster Istio Service Mesh](\/en\/blog\/seamless-cross-cluster-access-istio\/)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh\/).*\n', '\/en\/blog\/multi-cluster-pki-istio-recipe\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article focuses on implementing PKI for Istio in a multi-cluster environment. It details the combination of EJBCA and cert-manager, including setup steps and emphasizes the importance of PKI best practices for secure and compliant service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/introducing-kmesh-kernel-native-service-mesh/">Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 19, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Introducing Kmesh: Revolutionizing Service Mesh Data Planes with Kernel-Native Technology', 'Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.', '\nIn the world of microservices and cloud-native applications, service meshes have become essential for managing service-to-service communication. However, traditional sidecar-based architectures introduce significant latency and resource overhead, posing challenges for latency-sensitive and large-scale applications. **Kmesh** emerges as a groundbreaking solution—a high-performance, kernel-native service mesh data plane that leverages eBPF and kernel enhancements to deliver unparalleled efficiency and performance.\n\n## Background\n\nService meshes like Istio have become integral in managing complex microservices architectures, providing features like traffic management, security, and observability. The sidecar model, where a proxy runs alongside each service instance, has been the predominant approach. While effective in functionality, this architecture introduces significant latency and resource overhead.\n\n{{\u003ccallout note \u0022Note\u0022\u003e}}\n\nAll data presented in this article is quoted from [A New Choice for Istio Data Plane: Architectural Innovation for a Brand-New Performance Experience](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no). I have not verified the accuracy of these data. You are requested to judge and verify the reliability of these data on your own.\n\n{{\u003c\/callout\u003e}}\n\n## Limitations of Traditional Sidecar Architectures\n\n1. **Latency Overhead**: The addition of sidecar proxies results in increased network hops and context switches, introducing an extra **2 to 3 milliseconds** of latency per service call. For latency-sensitive applications, this delay is unacceptable.\n\n2. **Resource Consumption**: Each sidecar consumes CPU and memory resources. In large-scale deployments with thousands of services, the accumulated resource overhead is huge. Although it can be optimized through certain technical means, it still reduces deployment density and increases operating costs.\n\nPerformance measurements of Istio reveal that even without traffic distribution, there\u0027s an inherent latency overhead of approximately 3 milliseconds. As the number of connections grows, latency increases correspondingly, highlighting the inefficiency of the sidecar model for high-performance applications.\n\n## Industry Attempts to Address the Challenges\n\nSeveral solutions have been proposed to mitigate the drawbacks of sidecar architectures:\n\n### Cilium Service Mesh\n\n- **Approach**: Combines eBPF with Envoy to create a sidecar-less service mesh.\n- **Mechanism**:\n  - **L4 Traffic**: Uses eBPF for efficient kernel-level data routing.\n  - **L7 Traffic**: Relies on Envoy for application-layer parsing.\n- **Limitations**:\n  - **Extra Hops for L7**: L7 governance through Envoy introduces additional network hops.\n  - **Fault Isolation**: Challenges in ensuring governance fault isolation.\n\n### Istio Ambient Mesh\n\n- **Approach**: Introduces sidecar-less architecture using **ztunnel** and **waypoint** proxies.\n- **Mechanism**:\n  - **User-Space Processing**: All traffic interception and management occur in user space.\n- **Limitations**:\n  - **Complex Traffic Interception**: User-space interception increases complexity.\n  - **Increased Hops**: L7 connections involve multiple network hops, adding latency.\n\nThese solutions, while innovative, do not fully resolve the latency and resource overhead issues inherent in sidecar architectures.\n\n## Introducing Kmesh: A Kernel-Native Approach\n\nKmesh defines a new service mesh data plane by directly integrating traffic governance into the operating system kernel. Utilizing eBPF (Extended Berkeley Packet Filter) and kernel enhancements, Kmesh provides high-performance, low-latency, and resource-efficient service mesh capabilities.\n\n### Technical Architecture\n\n![Kmesh Architecture](kmesh-arch.svg)\n\n**Core Components**:\n\n- **Kmesh-Daemon**: A per-node management component responsible for:\n  - Managing eBPF programs.\n  - Subscribing to xDS configurations from the control plane (e.g., Istiod).\n  - Handling observability and metrics collection.\n\n- **eBPF Orchestration**: Implements traffic interception and management at the kernel level, supporting:\n  - L4 load balancing.\n  - Traffic encryption and decryption.\n  - Monitoring and simple L7 dynamic routing.\n\n- **Waypoint Proxy (Optional in Dual Engine Mode)**: Handles advanced L7 traffic governance, deployed per namespace or per service as needed.\n\n### Key Advantages\n\n![Kmesh vs Sidecar vs Ambient ([Source](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYWy\/a-new-choice-for-istio-data-plane-architectural-innovation-for-a-brand-new-performance-experience-istioxiao-zha-sao-daepxia-mo-zha-zhonghu-xu-huawei?iframe=no))](performance.webp)\n\n1. **High Performance**:\n   - **Latency Reduction**: Kernel-native L7 management reduces forwarding latency by over **60%** compared to traditional sidecar architectures.\n   - **Improved Application Startup**: Application bootstrap times improve by **40%** due to the elimination of sidecar initialization.\n\n2. **Low Resource Overhead**:\n   - **Resource Efficiency**: Eliminates the need for sidecar proxies, reducing resource consumption by over **70%**.\n\n3. **High Availability**:\n   - **Seamless Upgrades**: Kernel-level traffic management ensures that upgrading or restarting Kmesh components does not disrupt existing service connections.\n\n4. **Security Isolation**:\n   - **Enhanced Security**: Utilizes BPF-based virtual machine security and cgroup-level governance isolation to ensure secure multi-tenancy.\n\n5. **Flexible Governance Model**:\n   - **Deployment Modes**: Offers both Kernel-Native Mode for maximum performance and Dual Engine Mode for deployment flexibility.\n\n6. **Seamless Compatibility**:\n   - **Control Plane Integration**: Fully compatible with the xDS protocol, allowing integration with Istio\u0027s control plane and supporting Istio APIs and Gateway APIs.\n\n## Two Operational Modes of Kmesh\n\nKmesh provides two operational modes to cater to different deployment needs:\n\n### Kernel-Native Mode\n\n**Overview**:\n\n- **Ultimate Performance**: Achieves the lowest possible latency with no additional network hops for both L4 and L7 traffic.\n- **Mechanism**:\n  - **Kernel Enhancements**: Enhances the kernel using eBPF and kernel modules (ko).\n  - **Fake TCP Connections**: Utilizes forged connections to manage complex application-layer traffic within the kernel.\n  - **Traffic Management**: Directly manages traffic as soon as the client initiates communication, eliminating unnecessary context switches and data copies.\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces forwarding latency by over 60%.\n- **No Dependency on User-Space Proxies**: Entire traffic management is handled within the kernel.\n\n**Considerations**:\n\n- **Kernel Version Requirements**: May require specific kernel versions or enhancements, which could impact deployment flexibility.\n\n### Dual Engine Mode\n\n**Overview**:\n\n- **Flexible Governance**: Balances performance with broader compatibility and flexibility.\n- **Mechanism**:\n  - **Kernel-Level Interception**: Uses eBPF to intercept traffic in the kernel space.\n  - **Waypoint Proxy**: Deploys a remote waypoint proxy to handle complex L7 traffic management.\n  - **Layer Separation**: Splits L4 and L7 governance between kernel space (eBPF) and user space (waypoint).\n\n**Benefits**:\n\n- **Latency Reduction**: Reduces latency by **30%** compared to Istio\u0027s Ambient Mesh.\n- **Simplified Traffic Interception**: Kernel-space interception is more secure and simpler than user-space interception.\n- **Lower Adoption Threshold**: Reduced dependency on specific kernel versions, making it easier for users to adopt.\n\n**Comparison with Ambient Mesh**:\n\n- **Fewer Network Hops**: Kmesh adds only one extra hop for L7 connections, whereas Ambient Mesh may add up to three.\n- **Simpler Architecture**: Kernel-level interception avoids the complexity of user-space interception mechanisms.\n\n## Deep Dive into Kmesh\u0027s Technology\n\n### eBPF and Kernel Enhancements\n\n**eBPF (Extended Berkeley Packet Filter)** is a powerful technology that allows the injection of custom code into the Linux kernel safely and efficiently. Kmesh leverages eBPF to:\n\n- **Intercept Network Traffic**: Attach eBPF programs to network events, enabling real-time interception and manipulation of packets.\n- **Implement Load Balancing**: Direct traffic to appropriate service instances based on policies.\n- **Perform Traffic Encryption**: Handle mTLS encryption and decryption within the kernel, reducing overhead.\n- **Collect Observability Data**: Gather metrics and telemetry data without impacting application performance.\n\n### Traffic Interception and Management\n\nIn the Kernel-Native Mode:\n\n- **Forged Connections**: Kmesh creates fake TCP connections within the kernel to manage traffic without involving user-space proxies.\n- **Direct Packet Manipulation**: Packets are intercepted and redirected at the kernel level, eliminating context switches and data copies that occur when moving packets between user space and kernel space.\n\nIn the Dual Engine Mode:\n\n- **eBPF Interception**: eBPF programs handle initial traffic interception and basic L4 management.\n- **Waypoint Proxy**: For advanced L7 features like routing, retries, and header manipulation, traffic is forwarded to a waypoint proxy deployed per service or namespace.\n\n### Security and Isolation\n\n- **BPF Virtual Machine Security**: eBPF runs in a restricted virtual machine within the kernel, ensuring that injected code cannot compromise kernel stability.\n- **Cgroup-Level Isolation**: Governance policies are applied at the cgroup level, providing isolation between different services and workloads.\n- **mTLS Support**: Mutual TLS is implemented within the kernel (Under development. Planned to be supported by the end of 2024), providing zero-trust security without the overhead of user-space encryption.\n\n## Performance Analysis\n\n**Test Setup**:\n\n- **Benchmark Tool**: Used [Fortio](https:\/\/github.com\/fortio\/fortio) to generate load and measure latency.\n- **Comparisons**: Measured performance across four configurations:\n  1. **Baseline**: Direct communication without any service mesh.\n  2. **Istio Sidecar**: Traditional sidecar-based deployment.\n  3. **Istio Ambient Mesh**: Sidecar-less deployment with ztunnel and waypoint.\n  4. **Kmesh**: Both Kernel-Native and Dual Engine modes.\n\n**Results**:\n\n- **Latency**:\n  - **Kmesh Kernel-Native Mode**: Achieved over **60%** reduction in forwarding latency compared to Istio Sidecar.\n  - **Kmesh Dual Engine Mode**: Reduced latency by **30%** compared to Istio Ambient Mesh.\n- **Resource Consumption**:\n  - **CPU and Memory**: Kmesh reduced resource overhead by over **70%**, as it eliminates the need for sidecar proxies.\n- **Application Startup Time**:\n  - Improved by **40%**, as applications no longer wait for sidecar initialization.\n\n**Interpretation**:\n\n- Kmesh approaches baseline performance, making the overhead of the service mesh negligible.\n- The elimination of context switches and data copies contributes significantly to performance gains.\n- The kernel-native approach ensures consistent performance even as the number of services scales.\n\n## Cloud-Native Integration and Compatibility\n\n- **Kubernetes Native**: Kmesh runs seamlessly on Kubernetes, managing traffic to and from pods without requiring changes to application code.\n- **Control Plane Integration**:\n  - **xDS Protocol Support**: Subscribes to xDS configurations from Istiod, ensuring compatibility with Istio\u0027s control plane.\n  - **Istio API Compatibility**: Supports existing Istio APIs, allowing users to leverage familiar configurations and policies.\n- **Gateway API Support**: Compatible with Gateway APIs, enabling more flexible and expressive traffic management.\n- **Observability**:\n  - Integrates with Prometheus for metrics collection.\n  - Utilizes eBPF for efficient data gathering without impacting performance.\n- **Security Policies**:\n  - Supports existing Istio security policies, including authentication and authorization.\n\n## Future Roadmap\n\n**Short-Term Goals (2024)**:\n\n- **September 2024**:\n  - Implement circuit breaking and rate limiting.\n  - Enhance support for mTLS and upstream extensions.\n  - Ensure seamless restarts without affecting traffic.\n- **December 2024 (Release 1.0)**:\n  - Introduce locality-aware load balancing.\n  - Add multi-cluster support for federated deployments.\n  - Enhance DNS and headless service handling.\n  - Integrate with gateway components for edge traffic management.\n\n**Long-Term Vision (2025 and Beyond)**:\n\n- **AI Integration**:\n  - Incorporate AI capabilities to improve traffic governance decisions.\n  - Enhance problem diagnostics and anomaly detection.\n- **Multi-VPC Support**:\n  - Extend support to multi-Virtual Private Cloud environments.\n- **Advanced Observability**:\n  - Leverage eBPF and Application Performance Management tools for deeper insights.\n  - Provide end-to-end tracing and metrics.\n\n## Conclusion\n\nKmesh represents a paradigm shift in service mesh technology by moving traffic management into the kernel. By leveraging eBPF and kernel enhancements, it addresses the critical challenges of latency and resource overhead inherent in traditional sidecar architectures. Kmesh offers a flexible, high-performance solution suitable for modern cloud-native applications, particularly those requiring low latency and high throughput.\n\n**Key Takeaways**:\n\n- **Performance**: Achieves near-baseline performance by eliminating unnecessary overhead.\n- **Resource Efficiency**: Reduces CPU and memory consumption, enabling higher deployment densities.\n- **Flexibility**: Provides multiple operational modes to suit different deployment scenarios.\n- **Security**: Enhances security through kernel-level enforcement and isolation mechanisms.\n- **Compatibility**: Integrates seamlessly with existing cloud-native ecosystems, including Kubernetes and Istio.\n\nAs microservices architectures continue to evolve, solutions like Kmesh will play a crucial role in enabling efficient, scalable, and secure service communication. By addressing the limitations of traditional service mesh designs, Kmesh sets a new standard for performance and resource efficiency in the service mesh landscape.\n', '\/en\/blog\/introducing-kmesh-kernel-native-service-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Kmesh utilizes eBPF and kernel enhancements to achieve a high-performance, low-latency service mesh data plane. It revolutionizes the traditional Sidecar architecture, reduces resource consumption, and is suitable for modern cloud-native applications.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/service-mesh-data-plane-deployment-modes/">Service Mesh Data Plane Deployment Modes Explanation</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 13, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/service-mesh"> 
             Service Mesh
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Service Mesh Data Plane Deployment Modes Explanation', 'This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.', '\nThis article will introduce you to the four plane deployment modes of the Istio service mesh, analyzing their strengths and weaknesses to offer suggestions based on their performance, reliability, and security.\n\n## What is a Service Mesh?\n\nA service mesh is an infrastructure layer that typically employs application proxies to facilitate various functionalities. Taking Istio as an example, it enables users to programmatically manage traffic aware of applications, ensure robust observability, and maintain solid security within the network. Istio ensures resilience in cloud-native and distributed systems, enabling modern enterprises to maintain their workloads across various platforms while ensuring connectivity and protection. Its capabilities include zero-trust security, policy management, access control for security and governance, as well as canary deployments, A\/B testing, load balancing, and fault recovery for network functions. It also provides observability across all network traffic. Istio is unrestricted by any single cluster, network, or runtime and can incorporate services running on Kubernetes or virtual machines within a single mesh, whether across multi-cloud, hybrid, or on-premises environments. Its design is scalable and supported by an extensive ecosystem.\n\nThe architecture of a service mesh is divided into the control plane and the data plane. In the case of Istio, \u0060istiod\u0060 acts as the control plane, while the data plane offers two deployment modes: sidecar or ambient.\n\n![Architecture of the Istio Service Mesh (Source: [istio.io](https:\/\/istio.io\/latest\/about\/service-mesh\/))](service-mesh.svg)\n\nIn fact, there are more than these two modes for deploying the service mesh data plane. Including Istio\u0027s [proxyless gRPC service mesh](https:\/\/istio.io\/latest\/blog\/2021\/proxyless-grpc\/) and the [Cilium service mesh](https:\/\/cilium.io\/use-cases\/service-mesh\/), there are a total of four deployment modes.\n\n## Data Plane Deployment Modes\n\nThe following table compares the service mesh data plane deployment modes across several dimensions.\n\n{{\u003ctable \u0022Comparison of Four Service Mesh Deployment Modes\u0022\u003e}}\n\n| **Data plane modes**                                   | **Platform security** Threat assessment, risk                | **Resource Efficiency** – infra\/resource consumption, etc.   | **Manageability** – upgrades, vulnerabilities, etc.          | **Performance** – Latency, etc.                              |\n| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **Sidecar mode:** L4 and L7 Proxy per Service Instance | High security, as each service instance has an independent proxy, reducing the attack surface. Risk management depends on control plane configuration. | Higher resource consumption, as each instance requires an independent proxy. | Centralized management and configuration required, upgrades are relatively complex, but can be simplified through the control plane. | May increase latency as requests need to be forwarded through the proxy. |\n| **Ambient mode:** Shared L4 – L7 per Service Model     | Designed for security with ztunnel for local routing. However, shared proxies can introduce risks, and its overall security maturity is still evolving. | Higher efficiency as multiple services share the same proxy. | Relatively simple management, but may face vulnerabilities due to the shared proxy. | Good performance with local routing, but may incur cross-AZ costs with waypoint proxies. |\n| **Cilium mesh mode:** Shared L4 and L7 Model           | Moderate security with a focus on eBPF and fine-grained access control. However, there are known issues with identity and trust models. | Efficiency due to kernel-level processing, reducing infrastructure expenses. | Management is more complex, needing to handle configurations for multiple services. | Variable performance; certain scenarios might introduce significant latency. |\n| **gRPC mode:** L4 and L7 Part of the Application Model | While gRPC integrates proxy functions within the application, theoretically reducing the attack surface, the application\u0027s complexity and variability can actually expand it. The security of the gRPC mode depends on specific use cases and needs careful evaluation of potential threats and attack surfaces. | Higher efficiency because the proxy is implemented inline in the same process as the app. | Complex management, regular updates and maintenance of application layer proxy required. | Superior performance with low latency, suitable for real-time applications. |\n\n{{\u003c\/table\u003e}}\n\nYou can see a more visual comparison of these four modes in terms of cost and security from the diagram below:\n\n![Comparison of Service Mesh Deployment Modes](istio-data-plane-deployment-modes.svg)\n\nThese four deployment modes are differentiated based on how proxies are associated with service instances.\n\nThe following diagram illustrates potential locations for proxies in different deployment modes of the service mesh data plane.\n\n![Potential Locations of Proxies in the Data Plane](overview.svg)\n\n- **Sidecar Mode**: The proxy is in the same Pod as the application container.\n- **Ambient Mode**: The L4 proxy is on the same node as the application container, while the L7 proxy may not be on the same node.\n- **Cilium Mode**: The L4 and L7 proxies are combined and located on the same node as the application container.\n- **gRPC Mode**: The gRPC framework is integrated into the application and deployed within the same container.\n\n## Sidecar Mode: L4 and L7 Proxy per Service Instance\n\nThe diagram below shows the communication paths in sidecar mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Sidecar Mode: L4 and L7 Proxy per Service Instance](sidecar-mode.svg)\n\nThis is the most common deployment mode for service meshes and was the initial mode supported by [Istio](https:\/\/istio.io\/). Each service instance is accompanied by a proxy (such as [Envoy](https:\/\/envoyproxy.io\/)), which handles all inbound and outbound network communications, including L4 and L7 layers.\n\n- **Advantages**: High security, as each service instance is isolated, reducing potential attack surfaces.\n- **Disadvantages**: High resource consumption, as each service instance requires a separate proxy, increasing infrastructure costs.\n- **Maturity**: The maturity of the Istio Sidecar mode has reached the production level. They have undergone extensive testing and are ready for use in actual environments. \n\n## Ambient Mode: Shared L4 – L7 per Service Model\n\nThe diagram below illustrates the communication paths in ambient mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Ambient Mode: Node-shared L4 Proxy, Service Account-shared L7 Proxy](ambient-mode.svg)\n\nIn this mode, a shared L4 proxy on each node serves all service instances on the same physical host, while each service account has a dedicated L7 proxy.\n\n- **Advantages:** Lower costs, as the proxy is shared among multiple services.\n- **Disadvantages:** Although the ztunnel component is designed for security, shared proxies can introduce risks. The security maturity of this model is still evolving.\n- **Maturity**: The Istio ambient mode is currently in the beta stage; there are no large-scale production-level best practices yet, and it does not support multi-clusters.\n\n## Cilium Mesh Mode: Shared L4 and L7 Model\n\nThe diagram below displays the communication paths in Cilium mesh mode where Application 1 accesses Application 2 on the same node and Application 3 across nodes.\n\n![Cilium Mesh Mode: Shared L4 and L7 Proxies](cilium-mesh-mode.svg)\n\nThis mode is a middle ground between fully independent and fully shared setups, with each node having a shared L7 proxy. However, there are known issues with identities and trust models. The Cilium service mesh, which uses eBPF, allows for network policies without a proxy through kernel programs.\n\n- **Advantages**: Kernel-level efficiency can reduce infrastructure costs in specific scenarios.\n- **Disadvantages**: Management is more complex, and certain scenarios may result in increased latency.\n- **Maturity**: Cilium mesh manages L4 traffic directly through eBPF and configures the Envoy proxy on each node to control L7 traffic via CRDs (such as CiliumEnvoyConfig). However, there are concerns about its security due to inconsistent identity models.\n\n\u003e **Note**: *This model is not the data plane of Istio.*\n\n## gRPC Mode: L4 and L7 Part of the Application Model\n\nIn the gRPC mode, no external proxies are deployed; instead, proxy functions are directly integrated into the application using the RPC framework, leading to significant intrusion into the application. The service mesh control plane uses a set of discovery APIs known as xDS APIs to dynamically configure the application. The gRPC client libraries within the application provide extensive support for the xDS APIs. With this capability, the service mesh control plane can program L4 and L7 proxy functions directly within this library inside the service container.\n\nThe diagram below illustrates how, in Istio’s gRPC mode, the control plane communicates with the application.\n\n![gRPC Mode: L4 and L7 Proxies Integrated into the Application](grpc-mode.svg)\n\nIn this mode, when a gRPC service communicates with the control plane, a traditional Sidecar proxy is not needed; instead, a specific agent is used for initialization and communication with the control plane. This design reduces resource consumption and deployment complexity while still enabling functions such as service discovery and traffic management.\n\n- **Advantages**: High performance, as the proxy is tightly integrated with the application, reducing network hops and additional overhead.\n- **Disadvantages**: High complexity, as complex network processing functions need to be implemented within the application, which may increase development costs.\n- **Security Considerations**: The security of this model is debated. While integrating proxy functions within the application theoretically reduces the external attack surface, the application\u0027s diversity and complexity could expand the overall attack surface. Therefore, when considering the security of the gRPC mode, it is crucial to carefully analyze the security threat model and attack risks in specific use cases.\n- **Maturity**: The gRPC mode in Istio is still in the experimental stage.\n\n## Which Mode Should I Use?\n\nAs previously introduced, several factors influence the choice of a service mesh data plane deployment mode:\n\n- Maturity\n- Enterprise security needs\n- Resource constraints\n- Performance requirements\n- Network overhead\n- Tolerance for management complexity\n\n### Maturity\n\nWhen considering the deployment modes of the service mesh data plane, maturity is a key factor. The maturity level of each mode affects its reliability and support in production environments:\n\n- **Sidecar Mode**: This is the most mature service mesh deployment mode, widely adopted in production environments and well-supported.\n- **Ambient Mode**: While this mode offers some cost and performance advantages, it is still in the early stages and may lack mature best practices and broad ecosystem support.\n- **Cilium Mesh Mode**: As a relatively new option, it offers unique technological advantages, especially in scenarios using eBPF. However, concerns about its security model and identity management suggest it may not be as mature or reliable as other modes.\n- **gRPC Mode**: Despite excellent performance, the complexity and intrusiveness of this mode mean it may require more custom development and is still in the experimental stage.\n\n### Enterprise Security Needs\n\nIf your business has high security requirements, such as in the financial or healthcare sectors, then the **Sidecar Mode** might be the best choice. This mode provides strong security by ensuring each service instance has its own independent proxy, thus maximizing service isolation. For those exploring newer models like **Ambient Mode**, it\u0027s essential to understand that while ztunnel aims for secure local routing, the model\u0027s overall security strategy is still evolving.\n\n### Resource Constraints\n\nIn resource-constrained environments, deploying a separate proxy for each service instance may not be practical. In such cases, consider the **gRPC Mode** or **Ambient Mode**. **gRPC Mode** is particularly suitable for organizations that already use gRPC extensively and are willing to handle complex networking functions internally within the application. The **Ambient Mode**, on the other hand, uses a shared proxy to reduce resource consumption.\n\n### Performance Requirements\n\nFor applications requiring high performance and low latency, the **gRPC Mode** provides optimal performance because it eliminates the additional network hops introduced by traditional proxies. However, it\u0027s important to note that the gRPC Mode is still experimental and may not support all features of Istio. Consider your service mesh functionality needs accordingly.\n\n### Network Overhead\n\nEach data plane mode has distinct characteristics affecting network overhead. **Sidecar mode**, with locality-aware routing, reduces cross-zone traffic but adds network hops, increasing latency and compute use. **Ambient mode** uses ztunnels for local routing but may incur cross-AZ costs with waypoint proxies. **Cilium mode** places proxies on the same node as applications, potentially reducing inter-node traffic but could introduce more latency. **gRPC mode** integrates RPC framework into the application, minimizing network hops and overhead, ideal for high-performance, low-latency needs.\n\n### Tolerance for Management Complexity\n\nManagement complexity is also a significant consideration when choosing a service mesh data plane mode. **Sidecar Mode** and **gRPC Mode** may require more complex configurations and maintenance, while the **Ambient Mode** might offer a more streamlined management experience in some deployment environments. **Cilium Mode** could require complex management due to its reliance on eBPF and multiple configuration points.\n\n## Conclusion\n\nChoosing the right service mesh data plane deployment mode depends on specific factors including maturity, security, resource constraints, performance, and management complexity. Here’s a quick guide:\n\n- **Sidecar Mode**: Best for high security needs, offering the most isolation.\n- **gRPC Mode**: Suitable for environments with high-performance demands where gRPC is already in use.\n- **Ambient Mode**: Good for cost-effectiveness and lower isolation needs, but the security model is evolving.\n- **Cilium Mesh Mode**: Could be good for infrastructures utilizing eBPF technology, but consider security and management complexity.\n\nThe best choice will align with your application requirements, security policies, and technical familiarity. It’s essential to understand each mode’s strengths and limitations to make an informed decision that balances benefits, risks, and costs.\n\n## References\n\n- [Service Mesh Proxy Models for Cloud-Native Applications](https:\/\/csrc.nist.gov\/pubs\/sp\/800\/233\/ipd)\n\n---\n\n*This blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/ambient-vs-sidecar\/).*\n', '\/en\/blog\/service-mesh-data-plane-deployment-modes\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the four plane deployment modes of service meshes, analyzing their advantages and disadvantages, and provides recommendations based on their performance, reliability, and security.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/kubecon-china-2024-recap/">KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Sep 12, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/cloud-native"> 
             Cloud Native
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('KubeCon China 2024 Recap: Leading the Frontiers of Cloud Native Technology', 'A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio\u0027s Ambient mode and API gateways and their profound impact on the industry.', '\nThis year\u0027s [KubeCon China](https:\/\/events.linuxfoundation.org\/kubecon-cloudnativecon-open-source-summit-ai-dev-china\/) marked its first-ever occurrence in Hong Kong, spanning three days. As a participant and a panel moderator, I will share in this article the highlights of the conference and the in-depth discussions on service meshes and gateway technologies.\n\n![KubeCon China Scene](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-hall.webp)\n\n## Key Themes\n\nThis edition of KubeCon introduced a theme on AI and developers, here are some of the focal points:\n\n1. **Practical Applications of Cloud Native Technologies in Industries**: Especially in the electric vehicle and cybersecurity sectors, such as the joint discussion by Huawei and NIO on how cloud native technologies can accelerate innovation in electric vehicles.\n\n2. **The Power of the Kubernetes Community**: Detailed discussions on the influence of China\u0027s Kubernetes community and its role in advancing regional cloud native activities.\n\n3. **The Integration of Open Source Technology and Artificial Intelligence**: Discussions on the advanced position of China and Hong Kong in the fields of open source and AI technologies and how these are driving regional technological innovation and development.\n\n4. **Latest Developments in Service Meshes and API Gateways**: Including updates on service mesh technologies and how they work in conjunction with Kubernetes schedulers to enhance system throughput.\n\n5. **New Strategies for Supply Chain Security**: Focusing on the latest developments in securing supply chains, particularly practical guidelines on SLSA compliance.\n\n6. **Multicluster Management and Edge Computing**: Discussions on strategies for effective management and innovation across different architectures and systems.\n\n7. **Optimization of AI Large Model Inference Performance**: Discussion on performance acceleration in serverless architectures for AI large model inference and related technological advancements.\n\n## Istio and Modern API Gateways: Exploring the Future of Service Meshes\n\nIn a [roundtable discussion](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYY6\/istio-and-modern-api-gateways-navigating-the-future-of-service-meshes-istiorejiong-apijie-daepqiu-jie-zha-jimmy-song-jianpeng-he-tetrate-jiaqi-zhang-alibaba-cloud-jintao-zhang-kong-inc-xunzhuo-liu-tencent) that I participated in with industry leaders from Tetrate, Alibaba Cloud, and Kong Inc., we delved deeply into the latest developments and integrations of Istio and API gateways.\n\n![KubeCon China 2024 Istio and Modern API Gateways Panel](https:\/\/jimmysong.io\/img\/blog\/kubecon-china-2024-recap\/kubecon-china-2024-panel.webp)\n\n1. **Innovations in Istio**: We discussed the latest version update of Istio (Istio 1.123) and key features such as optimizations in the Ambient mode, a new architectural choice that reduces resource consumption while enhancing performance.\n\n2. **Practical Comparison Between Ambient and Sidecar Modes**:\n   - **When to Choose Sidecar**: When high isolation and detailed traffic management are required.\n   - **When to Choose Ambient**: When pursuing ultimate performance and resource efficiency.\n\n3. **Challenges in the Development of Ambient Mode**: Despite its advantages, Ambient mode still faces challenges in complex traffic management and multi-tenant environments.\n\n4. **Service Mesh Optimization Strategies**: Discussing methods to enhance the performance and efficiency of cloud applications through service mesh improvements.\n\n5. **Integration of Service Meshes and API Gateways**: Demonstrating how these two technologies work together to support more complex deployment and operational modes.\n\n## Future Perspectives on Istio\n\nIn the [presentation by Zhonghu Xu and Jianpeng He](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcG\/what-is-the-future-of-service-mesh-sidecar-or-sidecarless-jie-zha-dyagsyi-wu-pi-yi-wu-zhonghu-xu-huawei), we gained insights into the possible future directions of Istio:\n\n- **Dual Mode Drive**: Istio is likely to support both the Ambient mode and the traditional Sidecar mode simultaneously. Ambient mode suits users seeking performance and cost optimization, while the Sidecar mode will continue to support users requiring comprehensive functionalities.\n\n- **Support for Gateway API**: Istio\u0027s support for the Gateway API provides users with more flexible routing and policy configuration options.\n\n- **Application of Waypoints Strategies**: Waypoints need not be limited to Istio or Envoy. Using the Gateway API and GAMMA, any standard-compliant implementation can serve as a Waypoint, offering greater flexibility and scalability for service meshes.\n\n### Sandwich Waypoint\n\nThey emphasized the Sandwich Waypoint, which supports:\n\n- **Traffic Redirection**: By setting the \u0060istio.io\/use-waypoint: {namespace}\/{gateway-name}\u0060 annotation, traffic to a target service, pod, or within a namespace can be redirected to the same Waypoint.\n- **Waypoint Deployment**: Users can deploy a Waypoint by creating a Gateway object. Unlike the original implementation of Waypoint, the new deployment method will include associated services and service accounts, not just the Waypoint instance.\n- **Routing and Policy Configuration**: Using the Gateway API for routing and policy configuration provides more customization options for users and providers.\n\nThis represents a mode in Istio\u0027s Ambient mode for capturing layer 7 traffic, as illustrated below.\n\n![Sandwich Waypoint Traffic Capture](istio-ambient-traffic-capture.svg)\n\nThe steps for capturing layer 7 traffic with Istio Sandwich Waypoint are as follows:\n\n1. Terminate the HBONE connection via zTunnel, arriving at the Waypoint, with zTunnel responsible for decoding the HBONE protocol.\n2. Waypoint extracts destination addresses, source addresses, etc., to handle traffic and determine forwarding locations.\n3. Waypoint expands or parses the transport layer encapsulation (TLV) data, with proxies supporting TLV processing to provide additional context.\n4. Waypoint communicates with the peer zTunnel, coordinating with the server-side zTunnel to ensure correct traffic transfer.\n5. Encapsulate HBONE, sent by the server-side zTunnel to the final server destination, achieving fine-grained traffic management and routing in an Istio environment while maintaining compatibility with existing network protocols.\n\n## Cutting-Edge Extensions in Envoy Gateway\n\nIn a [presentation](https:\/\/kccncossaidevchn2024.sched.com\/event\/1eYcX\/gateway-api-and-beyond-introducing-envoy-gateways-gateway-api-extensions-jie-api-daeptao-envoyjie-zha-jie-api-huabing-zhao-tetrate) at KubeCon, Huabing Zhao discussed how Envoy Gateway enhances its capabilities and flexibility by extending the Kubernetes Gateway API, covering a wide range of matching and routing capabilities, new resource and policy models, and details of security policies.\n\n- **Gateway API Compatibility**: Envoy Gateway is fully compatible with the Gateway API and offers a wide range of matching and routing options. These include HTTP host and path matching, HTTP header-based operations, weighted load balancing, and support for gRPC, UDP, and TCP routing.\n- **Policies for Advanced Traffic Management:** The introduction of ClientTrafficPolicy and BackendTrafficPolicy provides users with more granular control over traffic management for both upstream and downstream connections, including features such as rate limiting, retries, load balancing, circuit breakers, and more.\n- **Enhancement of Security and Authentication**: The introduced SecurityPolicy supports CORS, HTTP basic authentication, OIDC, JWT authentication, and can integrate with various identity providers. It also provides detailed access control, allowing authorization based on the requester\u0027s original IP, JWT claims, etc.\n- **Expanding Functionality with Custom Extensions:** Envoy Gateway offers support for custom extensions through WASM (WebAssembly) and external process extensions. This allows users to enhance the gateway’s functionality by integrating their own customized extensions, tailored to specific use cases and operational needs.\n- **Future Exploration**: Future versions are expected to support non-Kubernetes environments deployment, optimize memory usage in the control plane, and expand authorization capabilities.\n\n## Conclusion\n\nThrough this conference, we gained insights into Istio\u0027s Ambient mode and the developments in Envoy Gateway. The discussions on these technologies not only forecast future trends but also provided practical insights to facilitate the implementation and innovation of technologies.', '\/en\/blog\/kubecon-china-2024-recap\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">A deep dive into the cloud native technology developments at KubeCon China 2024, focusing on the integration of Istio&#39;s Ambient mode and API gateways and their profound impact on the industry.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/what-is-new-in-istio-1-22/">Deep Dive into Istio 1.22: New Features and Practical Application Advice</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jun 21, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Deep Dive into Istio 1.22: New Features and Practical Application Advice', 'Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.', '\nThe recent [release of Istio 1.22](https:\/\/istio.io\/latest\/news\/releases\/1.22.x\/announcing-1.22\/) includes a plethora of significant updates. This article shares the new features and application recommendations brought by this release.\n\n## Ambient Mode Enters Beta Phase\n\nAlthough Ambient mode has now entered the Beta phase, this does not mean we can completely do away with Sidecars. While the Istio official claims that Ambient mode simplifies operations and significantly reduces memory and CPU usage, it still has limitations and potential complexity issues. For example, while Sidecars are eliminated, the introduction of new ztunnel and waypoint components may pose new challenges. For more detailed information about Ambient mode entering Beta, refer to the [Istio official blog](https:\/\/istio.io\/latest\/blog\/2024\/ambient-reaches-beta\/).\n\n**Challenges Introduced by Ambient Mode**\n\n- Management of L7 traffic in Ambient mode is not yet mature\n- mTLS is forced to be enabled at the namespace level, meaning you cannot disable mTLS in Ambient mode\n- Zero-downtime upgrades in Ambient mode have not been resolved\n- Lack of best practices for coexistence and migration from Sidecar mode\n\nFor a comparison of Sidecar mode and Ambient mode, see [Analysis of Limitations in Istio Ambient Mode](\/blog\/istio-ambient-mode-limitations\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nIf you are just starting with Istio, especially if you only need to automatically enable mTLS for services, you can consider using Ambient mode at this stage. However, for L7 functionalities, it is recommended to wait until Ambient mode is fully mature before considering it for production use.\n{{\u003c\/callout\u003e}}\n\n## Istio API Upgrades\n\nIn the Istio 1.22 release, key APIs related to traffic management, security, and telemetry have officially been upgraded to the \u0060v1\u0060 version. You only need to change the API version of your existing configuration to \u0060v1\u0060, with no other changes needed. These APIs are already mature, and you can safely use the \u0060v1\u0060 version. For environments requiring high stability, Istio has added [validating admission policies](https:\/\/kubernetes.io\/docs\/reference\/access-authn-authz\/validating-admission-policy\/) to ensure that only \u0060v1\u0060 APIs and fields can be used in the Istio API.\n\nFor example, the following AuthorizationPolicy example.\n\n\u0060\u0060\u0060yaml {linenos=table,hl_lines=1}\napiVersion: security.istio.io\/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: finance-to-supply-chain\n  namespace: finance\nspec:\n  selector:\n    matchLabels:\n      app: finance-app\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        namespaces: [\u0022finance\u0022]\n    to:\n    - operation:\n        methods: [\u0022GET\u0022, \u0022POST\u0022]\n        paths: [\u0022\/api\/supply1\u0022, \u0022\/api\/supply2\u0022]\n    when:\n    - key: request.headers[:authority]\n      values: [\u0022supply-chain-service.supply-chain.svc.cluster.local\u0022]\n\u0060\u0060\u0060\n\nOther extension-type APIs such as \u0060EnvoyFilter\u0060, \u0060WasmPlugin\u0060, \u0060ProxyConfig\u0060 are still in alpha or beta stages. For more information on API upgrades, please refer to the [v1 API blog](https:\/\/istio.io\/latest\/blog\/2024\/v1-apis\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor commonly used functionalities, you can confidently use the \u0060v1\u0060 API. For extension-type APIs that are not yet stable, enabling validating admission policies is recommended to ensure system stability.\n{{\u003c\/callout\u003e}}\n\n## Gateway API Upgrade\n\n[Gateway API](\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/) has been updated to version 1.1.0 and is now widely available. This update extends Istio\u0027s traffic management capabilities, but it is important to be cautious of compatibility issues between Istio\u0027s native APIs and the Gateway API when migrating to the new API to avoid relying on features that are not fully mature yet. For more details, check out the [Gateway API v1.1 blog](https:\/\/istio.io\/latest\/blog\/2024\/gateway-mesh-ga\/).\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nFor existing deployments that are already stable using Istio API, continue using them, especially in scenarios requiring advanced features. For new deployments, consider using the stable version of the Gateway API to take advantage of its modern traffic management capabilities. Due to existing compatibility issues, do not rashly migrate to the Gateway API, as it may not be worth the risk.\n{{\u003c\/ callout\u003e}}\n\n## Delta xDS Enabled by Default\n\nIstio 1.22 version now has delta xDS enabled by default, which is a mechanism to optimize configuration distribution. Compared to the traditional State of the World (SotW) mode, delta xDS only sends changed configurations to the Envoy proxies, thereby significantly reducing the amount of data transmitted over the network and the resource consumption of the control plane. This change is particularly suitable for large-scale deployment environments with frequent configuration updates, improving the efficiency and performance of configuration updates. Additionally, delta xDS also helps manage configuration updates more efficiently in complex network environments or dynamically changing configurations.\n\n{{\u003c callout note \u0022Recommendation\u0022\u003e}}\nThe delta xDS has been developed several versions ago but was not enabled by default. Now that this feature is stable, you can use it with confidence.\n{{\u003c\/callout\u003e}}\n\nFor more on xDS, refer to the [Introduction to Envoy xDS and Configuration Distribution Process in Istio](\/blog\/istio-delta-xds-for-envoy\/).\n\n### Path Template Support with Wildcards for AuthorizationPolicy\n\nIn Istio 1.22, \u0060AuthorizationPolicy\u0060 has added support for [path templates](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/#Operation), greatly enhancing the flexibility and precision of path matching. Prior to this, \u0060AuthorizationPolicy\u0060 did not support wildcards in path configurations. This feature allows for defining paths in HTTP requests using URI templates based on Envoy, including simple wildcards (\u0060*\u0060 and \u0060**\u0060) or named variables, enabling precise matching of single or multiple path components. For example, the path template \u0060\/foo\/{*}\u0060 can match \u0060\/foo\/bar\u0060 but not \u0060\/foo\/bar\/baz\u0060, while \u0060\/foo\/{**}\/\u0060 can match any path starting with \u0060\/foo\/\u0060. This flexible path template design is particularly suitable for dynamic and complex routing rules, further strengthening Istio\u0027s security policy toolbox.\n\nThe diagram below illustrates the wildcard rules for path matching in AuthorizationPolicy.\n\n\u0060\u0060\u0060mermaid \u0022AuthorizationPolicy Path Matching Wildcard Rules\u0022\ngraph LR\n    A[AuthorizationPolicy Path Matching] --\u003e B(Define Path Templates)\n    B --\u003e C{Path Template Operators}\n    C --\u003e D[\u0022* (Match single segment)\u0022]\n    C --\u003e E[\u0022** (Match multiple segments)\u0022]\n    C --\u003e F[\u0022{name} (Named variable matching one segment)\u0022]\n    C --\u003e G[\u0022{name=**} (Named variable matching multiple segments)\u0022]\n\n    D --\u003e H[\u0022\/foo\/{*} matches \/foo\/bar\u0022]\n    E --\u003e I[\u0022\/foo\/{**}\/ matches \/foo\/bar\/, \/foo\/bar\/baz.txt\u0022]\n    F --\u003e J[\u0022\/videos\/{file} matches \/videos\/1080p5000_00001.m4s\u0022]\n    G --\u003e K[\u0022\/**.mpd matches \/content\/123\/india\/dash\/55\/manifest.mpd\u0022]\n\u0060\u0060\u0060\n\n![AuthorizationPolicy Path Matching Wildcard Rules](dfe9a5d5e2bc91e91e7e24017f56a3db.svg)\n\nFor more on the specific applications and rules of path templates, you can refer to [Envoy\u0027s official documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-v3\/extensions\/path\/match\/uri_template\/v3\/uri_template_match.proto).\n\n{{\u003c callout note \u0022Tip\u0022\u003e}}\n\u0060AuthorizationPolicy\u0060 finally supports templates in path matching, so you no longer need to manually add paths one by one in your configurations.\n{{\u003c\/callout\u003e}}\n\n## Summary\n\nThe Istio 1.22 release introduces several important updates and improvements. Although some features are widely publicized, they require detailed assessment and appropriate testing in practical use. Hopefully, this blog post helps you understand and apply these new features more deeply to achieve the best results in practice.\n\n## References\n\n- [Gateway API v1.1: Service mesh, GRPCRoute, and a whole lot more - kubernetes.io](https:\/\/kubernetes.io\/blog\/2024\/05\/09\/gateway-api-v1-1\/)\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/istio-service-mesh-new-features-v1_22\/).', '\/en\/blog\/what-is-new-in-istio-1-22\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">Explore the new features and practical advice of Istio 1.22, including the delta xDS, path template support, and API upgrades, to optimize service mesh management.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/envoy-gateway-introduction/">Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               May 16, 2024</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/envoy"> 
             Envoy
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Envoy Gateway Overview: Modern Kubernetes Ingress with Envoy Gateway and the Gateway API', 'This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.', '\nSelecting the right networking tool in a Kubernetes environment is crucial. According to [Tetrate\u0027s discussion](https:\/\/tetrate.io\/blog\/do-i-need-a-gateway-or-a-service-mesh\/), the choice depends on the type of network traffic: north-south or east-west. For services primarily handling external requests, Envoy Gateway is the ideal choice. It not only efficiently manages traffic but also seamlessly integrates as you transition to a microservices architecture.\n\nThis article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it\u0027s the ideal choice for exposing services to the public internet.\n\n## Overview of Envoy Gateway and its Role in Service Mesh\n\nEnvoy Gateway is a Kubernetes-native API gateway built around Envoy Proxy. It aims to lower the barrier for users adopting Envoy as an API gateway and lays the foundation for vendors to build value-added products like [Tetrate Enterprise Gateway for Envoy](https:\/\/tetrate.io\/tetrate-enterprise-gateway-for-envoy\/).\n\nEnvoy Gateway is not only an ideal choice for managing north-south traffic but also serves as a crucial component for connecting and securing services within the service mesh. It enhances communication efficiency and security among microservices by providing features such as secure data transmission, traffic routing, load balancing, and fault recovery. Leveraging its built-in Envoy Proxy technology, Envoy Gateway can handle a large number of concurrent connections and complex traffic management policies while maintaining low latency and high throughput.\n\nFurthermore, the tight integration of Envoy Gateway with the Kubernetes Gateway API allows for declarative configuration and management, significantly simplifying the deployment and update processes of gateways within the service mesh. This integration not only improves operational efficiency but also enables Envoy Gateway to seamlessly collaborate with solutions like Istio without adding extra complexity.\n\nThe figure below illustrates the relationship between Envoy Gateway and the service mesh.\n\n\u0060\u0060\u0060mermaid\ngraph TB\n    subgraph Kubernetes[\u0022Kubernetes Cluster\u0022]\n        eg[\u0022Envoy Gateway\u0022]\n        svcs[\u0022Services\u0022]\n        pods[\u0022Pods\u0022]\n        gwapi[\u0022Kubernetes Gateway API\u0022]\n        eg -- \u0022Manages North-South Traffic\u0022 --\u003e svcs\n        eg -- \u0022Configured by\u0022 --\u003e gwapi\n        gwapi -. \u0022Defines routing specs\u0022 .-\u003e svcs\n    end\n\n    subgraph SM[\u0022Service Mesh\u0022]\n        smc[\u0022Service Mesh Control Plane (e.g., Istio, Linkerd)\u0022]\n        smp[\u0022Service Mesh Data Plane (Envoy Sidecars)\u0022]\n        smc -- \u0022Configures\u0022 --\u003e smp\n        smp -- \u0022Handles East-West Traffic\u0022 --\u003e pods\n    end\n\n    eg -.-\u003e smp\n    svcs -. \u0022Part of\u0022 .-\u003e SM\n    svcs -- \u0022Connects to\u0022 --\u003e pods\n\u0060\u0060\u0060\n\n![Mermaid Diagram](17a407873a0c96afbde9bb6b252814d4.svg)\n\n\n\nIn a Kubernetes cluster, Envoy Gateway is responsible for managing north-south traffic, i.e., traffic entering and leaving the cluster, and is configured through the Kubernetes Gateway API, which defines routing specifications for services. Services within the cluster directly connect to pods. In the service mesh, the control plane (e.g., Istio or Linkerd) configures Envoy sidecars in the data plane, which handles east-west traffic within the cluster. In this system, Envoy Gateway can collaborate with the service mesh, but they independently manage traffic in different directions.\n\nThink of Envoy Gateway as the main entry point to a city (e.g., customs), where all traffic (like various vehicles) must pass through. It acts as a strict gatekeeper, responsible for inspection and guidance, ensuring each packet (like each passenger) is accurately delivered to its destination. In the city of Kubernetes, Envoy Gateway manages all inbound traffic, ensuring data flows securely and efficiently into the city and is accurately delivered to services within the city.\n\nOnce inside the city, the service mesh takes over, acting as a series of transportation networks within the city. Envoy sidecars in the service mesh are like taxis or buses within the city, responsible for transporting packets from the port to their specific destinations within the city. Envoy Gateway ensures smooth entry for external requests, and then the service mesh efficiently handles these requests within the cluster.\n\nThe support for Kubernetes Gateway API by Envoy Gateway can be seen as a significant upgrade to our city\u0027s traffic signal system. It not only provides clearer and more personalized guidance for incoming data flows but also makes the entire city\u0027s traffic operations more intelligent.\n\n## Core Features and Advantages of Envoy Gateway\n\nEnvoy Gateway offers several core features that make it a prominent choice for an API gateway:\n\n- **Simplified Configuration**: Through direct integration with the Kubernetes Gateway API, Envoy Gateway allows developers to use Kubernetes custom resources to declaratively configure routing rules, security policies, and traffic management.\n- **Performance and Scalability**: Built on battle-tested Envoy Proxy, it delivers outstanding performance and scalability, effortlessly handling thousands of services and millions of requests per second.\n- **Security Features**: Built-in support for various security measures such as SSL\/TLS termination, OAuth2, OIDC authentication, and fine-grained access control.\n- **Observability**: Provides comprehensive monitoring capabilities including detailed metrics, logs, and tracing, crucial for diagnosing and understanding traffic behavior.\n\n## Relationship with Gateway API\n\nThe introduction of the Gateway API in Kubernetes provides a powerful new way to integrate and configure ingress gateways, offering higher flexibility and functionality compared to traditional ingress. As discussed in [this blog](https:\/\/tetrate.io\/blog\/introducing-the-gateway-api\/), the Gateway API simplifies gateway management, allowing developers to define custom routing rules, TLS termination policies, and traffic policies using Kubernetes-native resources.\n\nThe Kubernetes Gateway API serves as the cornerstone of Envoy Gateway, providing a more expressive, flexible, and role-based approach to configuring gateways and routes within the Kubernetes ecosystem. This API offers custom resource definitions (CRDs) such as GatewayClass, Gateway, HTTPRoute, etc. Envoy Gateway utilizes these resources to create a user-friendly and consistent configuration model that aligns with Kubernetes\u0027 native principles.\n\n{{\u003ccallout note \u0022What is an API Gateway?\u0022\u003e}}\n\nAn API Gateway is a comprehensive management and hosting service for APIs. Serving as an intermediary layer between applications and backend services, it not only handles lifecycle events like creation, maintenance, deployment, running, and retiring but also performs additional critical functions. A robust API Gateway should provide the following features to enhance and extend its basic definition:\n\n1. **Traffic Control**: Ability to manage and control traffic to backend services, including request routing, load balancing, circuit breaking, and rate limiting, ensuring the stability and high availability of backend services.\n2. **Security Assurance**: Authentication, authorization, and encryption capabilities to effectively manage and protect API security. This involves authentication mechanisms, API key management, OAuth, JWT, mTLS, etc., ensuring that only authorized users and services can access the API.\n3. **Monitoring and Analytics**: Real-time monitoring and logging functionalities to track API usage, performance metrics, anomaly detection, and traffic pattern analysis, optimizing API performance and responsiveness.\n4. **Change Management**: Support for managing API changes, including version control and progressive deployment (such as blue-green or canary release), for seamless transition to new versions while minimizing impact on end users.\n5. **Request and Response Transformation**: Allow transformation of incoming and outgoing API calls, such as from REST to GraphQL, or adding, removing, and modifying request and response headers.\n6. **Cross-Origin Resource Sharing (CORS) Support**: Manage and control cross-origin requests, allowing frontend applications from different domains to securely call backend APIs.\n7. **Quotas and Billing**: Set quota limits for API usage, while also supporting billing functionalities for commercialized API offerings.\n8. **Developer-Friendly Developer Portal**: Provide a developer-facing portal, enabling third-party developers to easily discover, test, and integrate APIs.\n9. **Protocol Support**: Support for various network protocols, including HTTP\/HTTPS, WebSocket, gRPC, etc., ensuring compatibility with a variety of clients and services.\n10. **Plug-ability and Extensibility**: Allow extension of API Gateway functionality through plugins or middleware, enabling flexible adaptation to various middleware services based on business requirements.\n11. **Service Governance**: Integration with service registration and discovery mechanisms to accommodate the dynamics of services in a microservices architecture.\n\nIn conclusion, the role of an API Gateway extends far beyond simple API lifecycle management. It is a key component in realizing microservices architecture, ensuring service security, improving operational efficiency, and optimizing user experience. Through these extensive functionalities, the API Gateway becomes an indispensable part of modern cloud-native applications.\n\n{{\u003c\/callout\u003e}}\n\n## Overview of Envoy Gateway Architecture\n\nThe architecture of Envoy Gateway is designed to be lightweight and concise. It consists of a control plane that dynamically configures an Envoy proxy running as the data plane. This separation of concerns ensures that the gateway can scale with increasing traffic without affecting the efficiency of the control plane.\n\nThe architecture diagram of Envoy Gateway is shown below.\n\n![Envoy Gateway Architecture Diagram](envoy-gateway-arch.svg)\n\nAt the core of this architecture is the Envoy Gateway, which is an instance of the Envoy proxy responsible for handling all traffic in and out of the Kubernetes cluster. Upon initial startup, Envoy Gateway provides static configuration through configuration files, establishing the basic parameters of its operation.\n\nThe dynamic aspect of Envoy Gateway configuration is handled by providers, which define the interaction between the gateway and Kubernetes or other dynamic configuration input sources. The resource monitor is responsible for monitoring changes to Kubernetes resources, with particular attention to CRUD operations related to custom resource definitions (CRDs).\n\nAs changes occur, resource transformers intervene to translate these external resources into a form understandable by Envoy Gateway. This transformation process is further facilitated by provider-specific infrastructure managers, which are responsible for managing resources related to specific clouds or infrastructure providers, shaping the infrastructure into an intermediate representation crucial for the gateway\u0027s functionality.\n\nThis intermediate representation then transforms into the xDS intermediate representation, serving as the precursor to the final xDS configuration understood and executed by Envoy. The xDS translator plays the role of converting this intermediate representation into specific xDS configurations.\n\nThese configurations are delivered and executed by xDS servers, which act as services diligently managing Envoy instances based on the xDS configurations they receive. As the actual running proxy, Envoy ultimately receives these configurations from xDS servers, interprets them, and implements them to effectively manage traffic requests.\n\nUltimately, all requests are redirected to the final destination of Envoy Gateway routes for traffic, which are the backend services.\n\n## Comparison with Other Gateways\n\nCompared to other popular solutions such as Istio\u0027s Ingress Gateway or NGINX Ingress, Envoy Gateway stands out with its native integration with Kubernetes and its focus on leveraging the full potential of Envoy. The table below compares various open-source API gateways from multiple aspects.\n\n| **API Gateway** | **Supported Authentication \u0026 Authorization Strategies**      | **Supported Service Discovery Components** | **Supported Protocols**          | **Control Plane Configuration Distribution Method** | **Supported Plugin Extension Mechanism** | **Foundation Affiliation** |\n| --------------- | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------- | --------------------------------------------------- | ---------------------------------------- | -------------------------- |\n| Envoy Gateway   | OAuth2, JWT, mTLS, OIDC                                      | Kubernetes, EDS                            | HTTP, HTTPS, gRPC                | xDS                                                 | Envoy Filter Based                       | CNCF                       |\n| Kuma            | mTLS, JWT                                                    | Kubernetes, Consul                         | HTTP, HTTPS, gRPC, TCP           | REST, gRPC                                          | Lua, Go Based                            | CNCF                       |\n| NGINX Ingress   | RBAC                                                         | Kubernetes                                 | HTTP, HTTPS, TCP, UDP            | Kubernetes CRD                                      | Nginx Module Based                       | N\/A                        |\n| APISIX          | OAuth2, JWT, Key Auth, Basic Auth, mTLS, OIDC, LDAP, OpenID, and others | Kubernetes, DNS, Consul, Nacos, Eureka     | HTTP, HTTPS, TCP, UDP, WebSocket | REST, CLI, Web UI                                   | Lua, Wasm Based                          | Apache Software Foundation |\n| Kong            | OAuth2, JWT, Basic Auth, Key Auth                            | Kubernetes, DNS, Consul                    | HTTP, HTTPS, gRPC, WebSocket     | REST, gRPC, Web UI                                  | Lua Based                                | N\/A                        |\n| Emissary        | Basic Auth                                                   | Kubernetes                                 | HTTP, HTTPS, gRPC                | Kubernetes CRD                                      | Lua, Go Based                            | CNCF                       |\n\n## Quick Start with Envoy Gateway\n\nTo quickly get started with Envoy Gateway, you can set up a local experimental environment using the following simplified steps. First, start a local Kubernetes cluster:\n\n\u0060\u0060\u0060bash\nminikube start --driver=docker --cpus=2 --memory=2g\n\u0060\u0060\u0060\n\nNext, deploy the Gateway API CRD and Envoy Gateway itself:\n\n\u0060\u0060\u0060bash\nhelm install eg oci:\/\/docker.io\/envoyproxy\/gateway-helm --version v1.0.1 -n envoy-gateway-system --create-namespace\n\u0060\u0060\u0060\n\nThen, install the gateway configuration and deploy a sample application:\n\n\u0060\u0060\u0060bash\nkubectl apply -f https:\/\/github.com\/envoyproxy\/gateway\/releases\/download\/v1.0.1\/quickstart.yaml -n default\n\u0060\u0060\u0060\n\nTo expose the LoadBalancer service, here we use port forwarding as an example. You can also choose to use \u0060minikube tunnel\u0060 or install [MetalLB](https:\/\/metallb.universe.tf\/installation\/) as a load balancer:\n\n\u0060\u0060\u0060bash\nexport ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io\/owning-gateway-namespace=default,gateway.envoyproxy.io\/owning-gateway-name=eg -o jsonpath=\u0027{.items[0].metadata.name}\u0027)\nkubectl -n envoy-gateway-system port-forward service\/${ENVOY_SERVICE} 8888:80 \u0026\n\u0060\u0060\u0060\n\nTest if your Envoy Gateway is working properly with the following command:\n\n\u0060\u0060\u0060bash\ncurl --verbose --header \u0022Host: www.example.com\u0022 http:\/\/localhost:8888\/get\n\u0060\u0060\u0060\n\nFor more detailed installation and configuration steps, visit the Envoy Gateway website. With these steps, you can quickly start exploring the capabilities of Envoy Gateway.\n\n## Conclusion\n\nEnvoy Gateway not only optimizes Layer 7 gateway configuration in the cloud-native era but also provides a smooth transition from edge gateways to service meshes. As the promotion of service meshes faces some challenges, such as the intrusiveness to applications and issues driving by operations teams, edge gateways are more readily accepted by development teams. Envoy Gateway, with its simplified Kubernetes Gateway API, enhances traffic management and observability capabilities. Additionally, the transition from Envoy Gateway to Istio is a confident technical advancement for teams already familiar with Envoy features, supporting seamless switching from the standard Kubernetes Gateway API to Istio Ingress Gateway or continuing to collaborate with Istio as a custom solution. These features make Envoy Gateway a gateway choice worth investing in the cloud-native era.\n\nStay tuned for the subsequent parts of this blog series, where we will delve into configuring and optimizing Envoy Gateway, providing practical guides, and showcasing a wider range of real-world use cases.\n\n---\n\nThis blog was initially published at [tetrate.io](https:\/\/tetrate.io\/blog\/envoy-microservices-overview\/).\n', '\/en\/blog\/envoy-gateway-introduction\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explores the advantages of deploying Envoy Gateway on Kubernetes, its relationship with other service mesh components, and why it&#39;s the ideal choice for exposing services to the public internet.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/distributed-tracing-with-skywalking-in-istio/">How to Use SkyWalking for Distributed Tracing in Istio?</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jan 4, 2023</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How to Use SkyWalking for Distributed Tracing in Istio?', 'This blog will guide you to use SkyWalking for distributed tracing with Istio.', '\nIn cloud native applications, a request often needs to be processed through a series of APIs or backend services, some of which are parallel and some serial and located on different platforms or nodes. How do we determine the service paths and nodes a call goes through to help us troubleshoot the problem? This is where distributed tracing comes into play.\n\nThis article covers:\n\n- How distributed tracing works\n- How to choose distributed tracing software\n- How to use distributed tracing in Istio\n- How to view distributed tracing data using Bookinfo and SkyWalking as examples\n\n## Distributed Tracing Basics\n\nDistributed tracing is a method for tracing requests in a distributed system to help users better understand, control, and optimize distributed systems. There are two concepts used in distributed tracing: TraceID and SpanID. You can see them in Figure 1 below.\n\n- **TraceID** is a globally unique ID that identifies the trace information of a request. All traces of a request belong to the same TraceID, and the TraceID remains constant throughout the trace of the request.\n- **SpanID** is a locally unique ID that identifies a request’s trace information at a certain time. A request generates different SpanIDs at different periods, and SpanIDs are used to distinguish trace information for a request at different periods.\n\nTraceID and SpanID are the basis of distributed tracing. They provide a uniform identifier for request tracing in distributed systems and facilitate users’ ability to query, manage, and analyze the trace information of requests.\n\n![Figure 1: Trace and span](basic.svg)\n\nThe following is the process of distributed tracing:\n\n- When a system receives a request, the distributed tracing system assigns a TraceID to the request, which is used to chain together the entire chain of invocations.\n- The distributed trace system generates a SpanID and ParentID for each service call within the system for the request, which is used to record the parent-child relationship of the call; a Span without a ParentID is used as the entry point of the call chain.\n- TraceID and SpanID are to be passed during each service call.\n- When viewing a distributed trace, query the full process of a particular request by TraceID.\n\n## How Istio Implements Distributed Tracing\n\nIstio’s distributed tracing is based on information collected by the Envoy proxy in the data plane. After a service request is intercepted by Envoy, Envoy adds tracing information as headers to the request forwarded to the destination workload. The following headers are relevant for distributed tracing:\n\n- As TraceID: x-request-id\n- Used to establish parent-child relationships for Span in the LightStep trace: x-ot-span-context\u003c\/li\n- Used for Zipkin, also for Jaeger, SkyWalking, see [b3-propagation](https:\/\/github.com\/openzipkin\/b3-propagation):\n  - *x-b3-traceid*\n  - *x-b3-traceid*\n  - *x-b3-spanid*\n  - *x-b3-parentspanid*\n  - *x-b3-sampled*\n  - *x-b3-flags*\n  - *b3*\n- For Datadog:\n  - *x-datadog-trace-id*\n  - *x-datadog-parent-id*\n  - *x-datadog-sampling-priority*\n- For SkyWalking: *sw8*\n- For AWS X-Ray: *x-amzn-trace-id*\n\nFor more information on how to use these headers, please see the [Envoy documentation](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/http\/http_conn_man\/headers).\n\nRegardless of the language of your application, Envoy will generate the appropriate tracing headers for you at the Ingress Gateway and forward these headers to the upstream cluster. However, in order to utilize the distributed tracing feature, you must modify your application code to attach the tracing headers to upstream requests. Since neither the service mesh nor the application can automatically propagate these headers, you can integrate the agent for distributed tracing into the application or manually propagate these headers in the application code itself. Once the tracing headers are propagated to all upstream requests, Envoy will send the tracing data to the tracer’s back-end processing, and then you can view the tracing data in the UI.\n\nFor example, look at the code of the Productpage service in the [Bookinfo application](https:\/\/istio.io\/latest\/docs\/examples\/bookinfo\/). You can see that it integrates the Jaeger client library and synchronizes the header generated by Envoy with the HTTP requests to the Details and Reviews services in the *getForwardHeaders (request)* function.\n\n\u0060\u0060\u0060python\ndef getForwardHeaders(request):\n    headers = {}\n\n    # Using Jaeger agent to get the x-b3-* headers\n    span = get_current_span()\n    carrier = {}\n    tracer.inject(\n        span_context=span.context,\n        format=Format.HTTP_HEADERS,\n        carrier=carrier)\n\n    headers.update(carrier)\n\n    # Dealing with the non x-b3-* header manually\n    if \u0027user\u0027 in session:\n        headers[\u0027end-user\u0027] = session[\u0027user\u0027]\n    incoming_headers = [\n        \u0027x-request-id\u0027,\n        \u0027x-ot-span-context\u0027,\n        \u0027x-datadog-trace-id\u0027,\n        \u0027x-datadog-parent-id\u0027,\n        \u0027x-datadog-sampling-priority\u0027,\n        \u0027traceparent\u0027,\n        \u0027tracestate\u0027,\n        \u0027x-cloud-trace-context\u0027,\n        \u0027grpc-trace-bin\u0027,\n        \u0027sw8\u0027,\n        \u0027user-agent\u0027,\n        \u0027cookie\u0027,\n        \u0027authorization\u0027,\n        \u0027jwt\u0027,\n    ]\n\n    for ihdr in incoming_headers:\n        val = request.headers.get(ihdr)\n        if val is not None:\n            headers[ihdr] = val\n\n    return headers\n\u0060\u0060\u0060\n\nFor more information, the [Istio documentation](https:\/\/istio.io\/latest\/about\/faq\/#distributed-tracing) provides answers to frequently asked questions about distributed tracing in Istio.\n\n## How to Choose A Distributed Tracing System\n\nDistributed tracing systems are similar in principle. There are many such systems on the market, such as [Apache SkyWalking](https:\/\/github.com\/apache\/skywalking), [Jaeger](https:\/\/github.com\/jaegertracing\/jaeger), [Zipkin](https:\/\/github.com\/openzipkin\/zipkin\/), Lightstep, [Pinpoint](https:\/\/github.com\/pinpoint-apm\/pinpoint), and so on. For our purposes here, we will choose three of them and compare them in several dimensions. Here are our inclusion criteria:\n\n- They are currently the most popular open-source distributed tracing systems.\n- All are based on the OpenTracing specification.\n- They support integration with Istio and Envoy.\n\n| Items               | Apache SkyWalking                                            | Jaeger                                       | Zipkin                                       |\n| ------------------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| Implementations     | Language-based probes, service mesh probes, eBPF agent, third-party instrumental libraries (Zipkin currently supported) | Language-based probes                        | Language-based probes                        |\n| Database            | ES, H2, MySQL, TiDB, Sharding-sphere, BanyanDB               | ES, MySQL, Cassandra, Memory                 | ES, MySQL, Cassandra, Memory                 |\n| Supported Languages | Java, Rust, PHP, NodeJS, Go, Python, C\u002b\u002b, .Net, Lua          | Java, Go, Python, NodeJS, C#, PHP, Ruby, C\u002b\u002b | Java, Go, Python, NodeJS, C#, PHP, Ruby, C\u002b\u002b |\n| Initiator           | Personal                                                     | Uber                                         | Twitter                                      |\n| Governance          | Apache Foundation                                            | CNCF                                         | CNCF                                         |\n| Version             | 9.3.0                                                        | 1.39.0                                       | 2.23.19                                      |\n| Stars               | 20.9k                                                        | 16.8k                                        | 15.8k                                        |\n\nAlthough Apache SkyWalking’s agent does not support as many languages as Jaeger and Zipkin, SkyWalking’s implementation is richer and compatible with Jaeger and Zipkin trace data, and development is more active, so it is one of the best choices for building a telemetry platform.\n\n## Demo\n\nRefer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/tasks\/observability\/distributed-tracing\/skywalking\/) to install and configure Apache SkyWalking.\n\n### Environment Description\n\nThe following is the environment for our demo:\n\n- Kubernetes 1.24.5\n- Istio 1.16\n- SkyWalking 9.1.0\n\n### Install Istio\n\nBefore installing Istio, you can check the environment for any problems:\n\n\u0060\u0060\u0060bash\n$ istioctl experimental precheck\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\n  To get started, check out https:\/\/istio.io\/latest\/docs\/setup\/getting-started\/\n\u0060\u0060\u0060\n\nThen install Istio and configure the destination for sending tracing messages as SkyWalking:\n\n\u0060\u0060\u0060bash\n# Initial Istio Operator\nistioctl operator init\n# Configure tracing destination\nkubectl apply -f - \u003c\u003cEOF\napiVersion: install.istio.io\/v1alpha1\nkind: IstioOperator\nmetadata:\n  namespace: istio-system\n  name: istio-with-skywalking\nspec:\n  meshConfig:\n    defaultProviders:\n      tracing:\n      - \u0022skywalking\u0022\n    enableTracing: true\n    extensionProviders:\n    - name: \u0022skywalking\u0022\n      skywalking:\n        service: tracing.istio-system.svc.cluster.local\n        port: 11800\nEOF\n\u0060\u0060\u0060\n\n## Deploy Apache SkyWalking\n\nIstio 1.16 supports distributed tracing using Apache SkyWalking. Install SkyWalking by executing the following code:\n\n\u0060\u0060\u0060bash\nkubectl apply -f \nhttps:\/\/raw.githubusercontent.com\/istio\/istio\/release-1.16\/samples\/addons\/extras\/skywalking.yaml\n\u0060\u0060\u0060\n\nIt will install the following components under the *istio-system* namespace:\n\n- SkyWalking Observability Analysis Platform (OAP): Used to receive trace data, supports SkyWalking native data formats, Zipkin v1 and v2 and Jaeger format.\n- UI: Used to query distributed trace data.\n\nFor more information about SkyWalking, please refer to the SkyWalking documentation.\n\n## Deploy the Bookinfo Application\n\nExecute the following command to install the bookinfo application:\n\n\u0060\u0060\u0060bash\nkubectl label namespace default istio-injection=enabled\nkubectl apply -f samples\/bookinfo\/platform\/kube\/bookinfo.yaml\nkubectl apply -f samples\/bookinfo\/networking\/bookinfo-gateway.yaml\n\u0060\u0060\u0060\n\nLaunch the SkyWalking UI:\n\n\u0060\u0060\u0060bash\nistioctl dashboard skywalking\n\u0060\u0060\u0060\n\nFigure 2 shows all the services available in the bookinfo application:\n\n![Figure 2: SkyWalking General Service page](general-service.jpg)\n\nYou can also see information about instances, endpoints, topology, tracing, etc. For example, Figure 3 shows the service topology of the bookinfo application:\n\n![Figure 3: Topology diagram of the Bookinfo application](topology.jpg)\n\nTracing views in SkyWalking can be displayed in a variety of formats, including list, tree, table, and statistics. See Figure 4:\n\n![Figure 4: SkyWalking General Service trace supports multiple display formats](gs-styles.jpg)\n\nTo facilitate our examination, set the sampling rate of the trace to 100%:\n\n\u0060\u0060\u0060bash\nkubectl apply -f - \u003c\u003cEOF\napiVersion: telemetry.istio.io\/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: istio-system\nspec:\n  tracing:\n  - randomSamplingPercentage: 100.00\nEOF\n\u0060\u0060\u0060\n\n\u003e **Important:** *It’s generally not good practice to set the sampling rate to 100% in a production environment. To avoid the overhead of generating too many trace logs in production, please adjust the sampling strategy (sampling percentage).*\n\n## Uninstall\n\nAfter experimenting, uninstall Istio and SkyWalking by executing the following command.\n\n\u0060\u0060\u0060bash\nsamples\/bookinfo\/platform\/kube\/cleanup.sh\nistioctl unintall --purge\nkubectl delete namespace istio-system\n\u0060\u0060\u0060\n\n## Understanding the Bookinfo Tracing Information\n\nNavigate to the General Service tab in the Apache SkyWalking UI, and you can see the trace information for the most recent *istio-ingressgateway* service, as shown in Figure 5. Click on each span to see the details.\n\n![Figure 5: The table view shows the basic information about each span.](span-table.jpg)\n\nSwitching to the list view, you can see the execution order and duration of each span, as shown in Figure 6:\n\n![Figure 6: List display](trace-list.jpg)\n\nYou might want to know why such a straightforward application generates so much span data. Because after we inject the Envoy proxy into the pod, every request between services will be intercepted and processed by Envoy, as shown in Figure 7:\n\n![Figure 7: Envoy intercepts requests to generate a span](span.svg)\n\nThe tracing process is shown in Figure 8:\n\n![Figure 8: Trace of the Bookinfo application](bookinfo-spans-with-time.svg)\n\nWe give each span a label with a serial number, and the time taken is indicated in parentheses. For illustration purposes, we have summarized all spans in the table below.\n\n| No.  | Endpoint     | Total Duration (ms) | Component Duration (ms) | Current Service      | Description                                 |\n| ---- | ------------ | ------------------- | ----------------------- | -------------------- | ------------------------------------------- |\n| 1    | \/productpage | 190                 | 0                       | istio-ingressgateway | Envoy Outbound                              |\n| 2    | \/productpage | 190                 | 1                       | istio-ingressgateway | Ingress -\u003e Productpage network transmission |\n| 3    | \/productpage | 189                 | 1                       | productpage          | Envoy Inbound                               |\n| 4    | \/productpage | 188                 | 21                      | productpage          | Application internal processing             |\n| 5    | \/details\/0   | 8                   | 1                       | productpage          | Envoy Outbound                              |\n| 6    | \/details\/0   | 7                   | 3                       | productpage          | Productpage -\u003e Details network transmission |\n| 7    | \/details\/0   | 4                   | 0                       | details              | Envoy Inbound                               |\n| 8    | \/details\/0   | 4                   | 4                       | details              | Application internal processing             |\n| 9    | \/reviews\/0   | 159                 | 0                       | productpage          | Envoy Outbound                              |\n| 10   | \/reviews\/0   | 159                 | 14                      | productpage          | Productpage -\u003e Reviews network transmission |\n| 11   | \/reviews\/0   | 145                 | 1                       | reviews              | Envoy Inbound                               |\n| 12   | \/reviews\/0   | 144                 | 109                     | reviews              | Application internal processing             |\n| 13   | \/ratings\/0   | 35                  | 2                       | reviews              | Envoy Outbound                              |\n| 14   | \/ratings\/0   | 33                  | 16                      | reviews              | Reviews -\u003e Ratings network transmission     |\n| 15   | \/ratings\/0   | 17                  | 1                       | ratings              | Envoy Inbound                               |\n| 16   | \/ratings\/0   | 16                  | 16                      | ratings              | Application internal processing             |\n\nFrom the above information, it can be seen that:\n\n- The total time consumed for this request is 190 ms.\n- In Istio sidecar mode, each traffic flow in and out of the application container must pass through the Envoy proxy once, each time taking 0 to 2 ms.\n- Network requests between Pods take between 1 and 16ms.\n- This is because the data itself has errors and the start time of the Span is not necessarily equal to the end time of the parent Span.\n- We can see that the most time-consuming part is the Reviews application, which takes 109 ms so that we can optimize it for that application.\n\n## Summary\n\nDistributed tracing is an indispensable tool for analyzing performance and troubleshooting modern distributed applications. In this tutorial, we’ve seen how, with just a few minor changes to your application code to propagate tracing headers, Istio makes distributed tracing simple to use. We’ve also reviewed [Apache SkyWalking](https:\/\/skywalking.apache.org\/) as one of the best distributed tracing systems that Istio supports. It is a fully functional platform for cloud native application analytics, with features such as metrics and log collection, alerting, Kubernetes monitoring, [service mesh performance diagnosis using eBPF](https:\/\/skywalking.apache.org\/blog\/diagnose-service-mesh-network-performance-with-ebpf\/), and more.\n\n---\n\nIf you’re new to service mesh and Kubernetes security, we have a bunch of free online courses [available at Tetrate Academy](https:\/\/tetr8.io\/academy) that will quickly get you up to speed with Istio and Envoy.\n\nIf you’re looking for a fast way to get to production with Istio, check out [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid). TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.\n\nOnce you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient [here](https:\/\/tetr8.io\/tsb), or [contact us for a quick demo](https:\/\/tetr8.io\/contact).\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/how-to-use-skywalking-for-distributed-tracing-in-istio\/).*\n', '\/en\/blog\/distributed-tracing-with-skywalking-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This blog will guide you to use SkyWalking for distributed tracing with Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/understanding-the-tls-encryption-in-istio/">How Istio’s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 24, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('How Istio’s mTLS Traffic Encryption Works as Part of a Zero Trust Security Posture', 'This article introduces TLS and mTLS, and describes how to enable mTLS in Istio and its application scenarios.', '\nThe Istio service mesh offers cloud native deployments a standard way to implement automatic [mutual transport layer security (mTLS)](https:\/\/en.wikipedia.org\/wiki\/Mutual_authentication#mTLS). This reduces the attack surface of network communication by using strong identities to establish encrypted channels between workloads within the mesh that are both confidential and tamper-resistant. mTLS is a key component for building zero-trust application networks. To understand mTLS traffic encryption in Istio, this article will cover the following:\n\n- An overview of TLS, mTLS, and TLS termination\n- An introduction to howTLS encryption works in Istio\n- How to use Istio to implement mTLS in Kubernetes\n- A discussion of when you do and don’t need mTLS\n\n## What Is TLS and mTLS?\n\nTLS, the successor to Secure Sockets Layer (SSL), is a widely adopted security protocol used to create authenticated and encrypted connections between networked computers. For this reason, people often use the terms TLS and SSL interchangeably. In this article, we will refer to them collectively as TLS. TLS 1.0 was released in 1999, and the latest version is 1.3 (released in August 2018); versions 1.0 and 1.1 are deprecated.\n\nThe HTTPS we see when browsing the web uses TLS, as shown in Figure 1, which is built on top of TCP as the session layer in the OSI model. To ensure compatibility, TLS usually uses port 443, but you can use any port you want.\n\n![Figure 1: HTTP vs. HTTPS](http-vs-https.svg)\n\nTLS encryption is required when a client needs to confirm the identity of the server in order to guard against man-in-the-middle attacks and ensure communication security. Figure 2 shows how TLS-encrypted communication proceeds.\n\n![Figure 2: simplified TLS handshake flow](tls-flow.svg)\n\n1. The server applies for and obtains a certificate (X.509 certificate) from a trusted [certificate authority](https:\/\/en.wikipedia.org\/wiki\/Certificate_authority) (CA).\n2. A request from the client to the server containing information such as the TLS version and password combination supported by the client.\n3. The server responds to the client request and attaches a digital certificate.\n4. The client verifies the status, validity, and digital signature of the certificate and confirms the identity of the server.\n5. Encrypted communication commences between the client and the server using a shared private key.\n\nThe above is only an outline description of the TLS communication flow. If you’re interested in the details, please see [this in-depth discussion of the complete TLS handshake process.](https:\/\/www.cloudflare.com\/learning\/ssl\/what-happens-in-a-tls-handshake\/)\n\nFrom the above process, you will find that the certificate is the critical element representing the server’s identity. The server must use a certificate issued by an authoritatively certified CA in order to provide public services over the Internet. In contrast, you can manage certificates using your own public key infrastructure (PKI) for services inside of a private environment.\n\nMutual TLS, also referred to as mTLS, is the use of a two-way encrypted channel between a server and a client that necessitates certificate exchange and identity authentication between the parties.\n\n## What Is TLS Termination?\n\nTLS termination is the process of decrypting TLS-encrypted traffic before it is forwarded to a web server. Offloading TLS traffic to an ingress gateway or specialized device improves web application performance while securing encrypted traffic. TLS termination is typically implemented at cluster ingress. All communication between the ingress and servers in the cluster will be conducted directly over HTTP in plaintext, enhancing service performance.\n\n![Figure 3: TLS termination](tls-termination.svg)\n\nBy default, Istio enables mTLS for mesh-based services and ends TLS at the ingress gateway. Furthermore, you can pass through traffic to back-end services for processing.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: Gateway\nmetadata:\n  name: sample-gateway\nspec:\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: PASSTHROUGH\n\u0060\u0060\u0060\n\nSee [Gateway TLS Configuration](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/traffic-management\/tls-configuration\/#gateways) for details.\n\n## How to Implement Automatic mTLS in Istio\n\nFigure 4 depicts the security architecture of Istio. This figure clearly shows that at the entry point, JSON Web Token (JWT) \u002b TLS authentication and encryption are used, and that mTLS is enabled between all services within the Istio mesh.\n\n![Istio 安全架构图](istio-security.svg)\n\nIstio includes a built-in CA, and [Secret Discovery Service (SDS)](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/configuration\/security\/secret)—one of the discovery services in Envoy [xDS](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/api-docs\/xds_protocol)—enables the issuance and rotation of SVID certificates. The mTLS flow in the Istio mesh is as follows:\n\n1. The sidecar of every service requests a certificate from Istiod on behalf of the workload at startup, and Istiod issues the [SVID](https:\/\/spiffe.io\/docs\/latest\/spiffe-about\/spiffe-concepts\/#spiffe-verifiable-identity-document-svid) certificate (the process is more complex, and I will explain it in a future blog).\n2. The sidecar of every workload intercepts all client requests within the pod.\n3. The client sidecar starts an mTLS handshake with the server sidecar. During the handshake, the [JWT](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/security\/jwt_authn_filter) and [authentication filter](https:\/\/www.envoyproxy.io\/docs\/envoy\/latest\/intro\/arch_overview\/security\/ext_authz_filter) in the client sidecar will authenticate the identity of the request, and store the identity in the filter metadata after the authentication. Then the request will go through the authorization filter to determine if the request is allowed.\n4. If the request is authenticated and authorized, the client and the server start to establish a connection for communication.\n\nIn Istio, authentication and authorization between services can be configured using one of three resource objects:\n\n- **[RequestAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/request_authentication\/):** To specify the service’s only currently supported request-level authentication method, JWT.\n- **[PeerAuthentication](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/peer_authentication\/):** To enable mTLS or plaintext requests, set the transport authentication mode.\n- **[AuthorizationPolicy](https:\/\/istio.io\/latest\/docs\/reference\/config\/security\/authorization-policy\/):** To specify who can do what when traffic between services is authorized? For instance, subject A either permits (ALLOW) or forbids (DENY) traffic from subject B.\n\n## How to Enable Automatic mTLS in Istio\n\nIn PeerAuthentication, you can specify the mTLS mode that will be used for the target workload. Peer authentication is supported in the following modes:\n\n- PERMISSIVE: The workload’s default setting that allows it to accept either mTLS or plain text traffic.\n- STRICT: The workload accepts only mTLS traffic.\n- DISABLE: Disable mTLS. From a security perspective, mTLS should not be disabled unless you have your own security solution.\n- UNSET: Inherited from the parent, with the following priority: service specific \u003e namespace scope \u003e mesh scope setting.\n\nIstio’s peer authentication uses *PERMISSIVE* mode by default, automatically sending *mTLS* traffic to these workloads and clear text traffic to workloads without a sidecar. After including Kubernetes services in the Istio mesh, we can use *PERMISSIVE* mode first to prevent services from failing *mTLS*. We can use one of two ways to enable strict mTLS mode for certain services:\n\n- Use PeerAuthentication to define how traffic is transferred between sidecars.\n- Use DestinationRule to define the TLS settings in the traffic routing policy.\n\nThe reviews service’s mTLS configuration in the default namespace can be seen in the example below.\n\n### Use PeerAuthentication to Set mTLS for Workloads\n\nFor instance, the following configuration can be used to specify that a workload under a namespace has strict mTLS enabled.\n\n\u0060\u0060\u0060yaml\napiVersion: security.istio.io\/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: foo-peer-policy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: reviews\n  mtls:\n    mode: STRICT\n\u0060\u0060\u0060\n\nAccording to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/tasks\/security\/authentication\/mtls-migration\/), you can also enable strict mTLS for all services in the mesh by configuring strict mTLS for the namespace istio-system where Istio is installed.\n\n### Use DestinationRule to Set up mTLS for Workloads\n\nTraffic routing policies, such as load balancing, anomaly detection, TLS settings, etc., are set using DestinationRule. In the TLS settings, there are various modes. As shown below, use ISTIO_MUTUAL mode to enable Istio’s workload-based automatic TLS.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1beta1\nkind: DestinationRule\nmetadata:\n  name: reviews\n  namespace: default\nspec:\n  host: reviews\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n\u0060\u0060\u0060\n\n## When Should You Use mTLS?\n\nThe short answer is that you should use mTLS for network communication between application components that you have some control over—like between microservices in a cluster.\n\nOne-way TLS is typically used by Internet clients to connect to Web services, which means that only the server needs to show identification and is unconcerned with the identity of the client. One-way TLS allows you to use passwords, tokens, two-factor authentication, and other methods when you need to confirm the identity of the client. However, when using a service mesh, mTLS operates outside the application and doesn’t require many changes to the application logic, whereas such an authentication method requires internal application support.\n\nAs you can see from the example above, mTLS implementation calls for certificate exchange between services. As the number of services rises, managing numerous certificates becomes a laborious task. You can implement automatic mTLS and fix the certificate management issue with the aid of a service mesh.\n\n## When Shouldn’t You Use mTLS?\n\nAlthough mTLS is the preferred protocol for securing inter-service communication in cloud-native applications, implementing mTLS necessitates a more complex, symmetric encryption and decryption process than one-way TLS. In some cases where there is high traffic volume or CPU utilization must be optimized, terminatingTLS at the traffic entry point and turning on mTLS internally for specific services only can help minimize request response times and decrease compute resource consumption for some traffic with lower security levels.\n\nAdditionally, it is necessary to [disable probe rewriting for pods](https:\/\/istio.io\/latest\/docs\/ops\/configuration\/mesh\/app-health-check\/#disable-the-http-probe-rewrite-for-a-pod) when using services that cannot obtain certificates, such as health checks performed via HTTP on Kubelet and the inability to access the service’s health check endpoint via TLS.\n\nFinally, when mesh services access some external services, mTLS is also not necessary.\n\n## Summary\n\nmTLS is a crucial component of creating a zero-trust application network, which makes it possible to encrypt traffic within the mesh. Istio makes it simple to enable automatic mTLS for Kubernetes services, doing away with the need to manage certificates. At the same time, we can selectively enable mTLS for a subset of the mesh’s services, enabling us to move services from Kubernetes to the mesh. In a subsequent blog, we’ll go into more detail about Istio’s certificate management system. Stay tuned.\n\n---\n\nIf you’re new to service mesh and Kubernetes security, we have a bunch of free online courses [available at Tetrate Academy](https:\/\/tetr8.io\/academy) that will quickly get you up to speed with Istio and Envoy.\n\nIf you’re looking for a fast way to get to production with Istio, check out [Tetrate Istio Distribution (TID)](https:\/\/tetr8.io\/tid). TID is Tetrate’s hardened, fully upstream Istio distribution, with FIPS-verified builds and support available. It’s a great way to get started with Istio knowing you have a trusted distribution to begin with, have an expert team supporting you, and also have the option to get to FIPS compliance quickly if you need to.Once you have Istio up and running, you will probably need simpler ways to manage and secure your services beyond what’s available in Istio, that’s where Tetrate Service Bridge comes in. You can learn more about how Tetrate Service Bridge makes service mesh more secure, manageable, and resilient [here](https:\/\/tetr8.io\/tsb), or [contact us for a quick demo](https:\/\/tetr8.io\/contact).\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/how-istios-mtls-traffic-encryption-works-as-part-of-a-zero-trust-security-posture\/).*\n', '\/en\/blog\/understanding-the-tls-encryption-in-istio\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces TLS and mTLS, and describes how to enable mTLS in Istio and its application scenarios.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/why-gateway-api-is-the-future-of-ingress-and-mesh/">Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Dec 13, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/kubernetes"> 
             Kubernetes
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('Why the Gateway API Is the Unified Future of Ingress for Kubernetes and Service Mesh', 'This article introduces the ingress gateway and Gateway API in Kubernetes, the new trend of them with service mesh.', '\nIn this blog, you will learn about the Kubernetes Ingress Gateway, the Gateway API, and the emerging Gateway API trend, which enables the convergence of Kubernetes and service mesh.\n\n## Takeaways\n\n- Ingress, the original gateway for Kubernetes, has a resource model that is too simple to fit into today’s programmable networks.\n- The [Gateway API](https:\/\/gateway-api.sigs.k8s.io\/), the latest addition to the Kubernetes portal gateway, separates concerns through role delineation and provides cross-namespace support to make it more adaptable to multi-cloud environments. Most API gateways already support it.\n- The Gateway API provides a new reference model for the convergence of ingress gateways (north-south) and service mesh (east-west, cross-cluster routing), where there is a partial functional overlap.\n\n## History of the Kubernetes ingress gateway\n\nWhen Kubernetes was launched in June 2014, only NodePort and LoadBalancer-type Service objects were available to expose services within the cluster to the outside world. Later, [Ingress ](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/)was introduced to offer more control over incoming traffic.. To preserve its portability and lightweight design, the Ingress API matured more slowly than other Kubernetes APIs; it was not upgraded to GA until Kubernetes 1.19.\n\nIngress’ primary objective is to expose HTTP applications using a straightforward declarative syntax. When creating an Ingress or setting a default *IngressClass* in Kubernetes, you can deploy several Ingress Controllers and define the controller the gateway uses via *IngressClass*. Kubernetes currently supports only AWS, GCE, and Nginx Ingress controllers by default; many [third-party ingress controllers](https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress-controllers\/) are also supported.\n\nThe following diagram illustrates the workflow of Kubernetes Ingress.\n\n![Figure 1: Kubernetes ingress workflow](ingress-flow.svg)\n\nThe detailed process is as follows:\n\n- Kubernetes cluster administrators deploy an Ingress Controller in Kubernetes.\n- The Ingress Controller continuously monitors changes to *IngressClass* and Ingress objects in the Kubernetes API Server.\n- Administrators apply *IngressClass* and Ingress to deploy the gateway.\n- Ingress Controller creates the corresponding ingress gateway and configures the routing rules according to the administrator’s configuration.\n- If in the cloud, the client accesses the load balancer for that ingress gateway.\n- The gateway will route the traffic to the corresponding back-end service based on the host and path in the HTTP request.\n\nIstio supports both the Ingress and Gateway APIs. Below is an example configuration using the Istio Ingress Gateway, which will be created later using the Gateway API:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.k8s.io\/v1\nkind: IngressClass\nmetadata:\n  name: istio\nspec:\n  controller: istio.io\/ingress-controller\n---\napiVersion: networking.k8s.io\/v1\nkind: Ingress\nmetadata:\n  name: ingress\nspec:\n  ingressClassName: istio\n  rules:\n  - host: httpbin.example.com\n    http:\n      paths:\n      - path: \/\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port: 8000\n\u0060\u0060\u0060\n\nNote: You must specify the *IngressClass* in the *ingressClassName* field in the Ingress spec. Otherwise, the ingress gateway will not be created.\n\n## Limitations of Kubernetes Ingress\n\nAlthough IngressClass decouples the ingress gateway from the back-end implementation, it still has significant limitations.\n\n- Ingress is too simple for most real-world use and it only supports HTTP protocol routing.\n- It only supports host and path matching, and there is no standard configuration for advanced routing features, which can only be achieved through annotation, such as URL redirection using Nginx Ingress Controller, which requires configuration of *nginx.ingress.kubernetes.io\/rewrite-target* annotation, which is no longer adaptable to the needs of a programmable proxy.\n- The situation where services in different namespaces must be bound to the same gateway often arises in practical situations where the ingress gateway cannot be shared across multiple namespaces.\n- No delineation of responsibilities for creating and managing ingress gateways, resulting in developers having to not only configure gateway routes but also create and manage gateways themselves.\n\n## Kubernetes Gateway API\n\nThe Gateway API is a collection of API resources: *GatewayClass*, *Gateway*, *HTTPRoute*, *TCPRoute*, *ReferenceGrant*, etc. The Gateway API exposes a more generic proxy API that can be used for more protocols than HTTP and models more infrastructure components, providing better deployment and management options for cluster operations.\n\nIn addition, the Gateway API achieves configuration decoupling by separating resource objects that people can manage in different roles. The following diagram shows the roles and objects in the Gateway API.\n\n![Figure: Roles and componentes in Kubernetes Gateway API](gateway-api-roles.svg)\n\nThe following is an example of using the Gateway API in Istio.\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: istio-ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: default\n    hostname: \u0022*.example.com\u0022\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io\/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: http\n  namespace: default\nspec:\n  parentRefs:\n  - name: gateway\n    namespace: istio-ingress\n  hostnames: [\u0022httpbin.example.com\u0022]\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \/\n    backendRefs:\n    - name: httpbin\n      port: 8000\n\u0060\u0060\u0060\n\nSimilar to Ingress, Gateway uses *gatewayClassName* to declare the controller it uses, which needs to be created by the platform administrator and allows client requests for the **.example.com* domain. Application developers can create routing rules in the namespace where their service resides, in this case, default, and bind to the Gateway via parentRefs, but only if the Gateway explicitly allows them to do so (via the rules set in the *allowRoutes* field).\n\nWhen you apply the above configuration, Istio will automatically create a load-balancing gateway for you. The following diagram shows the workflow of the Gateway API.\n\n![Figure 3: Gateway API workflow](gateway-api-flow.svg)\n\nThe detailed process is as follows:\n\n- The infrastructure provider provides *GatewayClass* and Gateway Controller.\n- Platform operator deploy Gateway (multiple deployments possible, or using different *GatewayClasses*).\n- Gateway Controller continuously monitors changes to the *GatewayClass* and *Gateway* objects in the Kubernetes API Server.\n- Gateway controller will create the corresponding gateway based on cluster operations and maintenance configuration.\n- Application developers apply *xRoutes* and bind them to the service.\n- If in the cloud, the client accesses the load balancer for that ingress gateway.\n- The gateway will route to the corresponding back-end service based on the matching criteria in the traffic request.\n\nFrom the above steps, we can see that the Gateway API has a clear division of roles compared to Ingress and that routing rules can be decoupled from the gateway configuration, significantly increasing management flexibility.\n\nThe following diagram shows the route flow after it is accessed at the gateway and processed.\n\n![Figure 4: Gateway API route flow](traffic-flow.svg)\n\nFrom this figure, we can see that the route is bound to the gateway. The route is generally deployed in the same namespace as its backend services. Suppose the route is in a different namespace, and you need to explicitly give the route cross-namespace reference rights in \u0060ReferenceGrant\u0060, for example. In that case, the following HTTPRoute foo in the foo namespace can refer to the bar namespace bar service in the bar namespace.\n\n\u0060\u0060\u0060yaml\nkind: HTTPRoute\nmetadata:\n  name: foo\n  namespace: foo\nspec:\n  rules:\n  - matches:\n    - path: \/bar\n    forwardTo:\n      backend:\n      - name: bar\n        namespace: bar\n---\nkind: ReferenceGrant\nmetadata:\n  name: bar\n  namespace: bar\nspec:\n  from:\n  - group: networking.gateway.k8s.io\n    kind: HTTPRoute\n    namespace: foo\n  to:\n  - group: \u0022\u0022\n    kind: Service\n\u0060\u0060\u0060\n\nCurrently, the Gateway API only supports HTTPRoute, and the TCPRoute, UDPRoute, TLSRoute and GRCPRoute are still in the experimental stage. The Gateway API is already supported by a large number of gateway and service mesh projects, and please [check the support status in the official Gateway documentation.](https:\/\/gateway-api.sigs.k8s.io\/implementations\/)\n\n## Ingress Gateway and Service Mesh\n\nThe service mesh focuses on east-west traffic, i.e., traffic within a Kubernetes cluster, but most service meshes, including Istio, also provide ingress gateway functionality. But, since Istio’s ingress functionality and API are more advanced than we need for this example, we’ll use [Service Mesh Interface (SMI)](https:\/\/smi-spec.io\/) to illustrate the relationship between the ingress gateway and the service mesh.\n\nSMI is a CNCF incubation project, open-sourced in 2019, that defines a common standard for vendor-independent service mesh running in Kubernetes.\n\nThe following diagram illustrates the overlap between the Gateway API and the SMI.\n\n![Figure 5: Gateway API vs SMI](gateway-smi-overlay.svg)\n\nFrom the diagram, we can see a clear overlap between the Gateway API and SMI in the traffic specification section. These overlaps result in the same functionality that needs to be implemented repeatedly in both the Gateway API and the service mesh.\n\n## Traffic Management in the Istio Service Mesh\n\nOf course, not all service meshes are fully SMI-compliant. Istio, the most popular service mesh implementation, provides rich traffic management features but does not have a separate policy API for these features, instead coupling them in *VirtualService* and *DestinationRule*, as shown below.\n\n### VirtualService\n\n- Routing: canary release, matching routes based on HTTP header, URI, etc.\n- Error injection: HTTP error code injection, HTTP delay injection.\n- Traffic splitting: percentage-based traffic splitting.\n- Traffic mirroring: mirroring a certain percentage of traffic to other clusters.\n- Timeout: set the timeout period, after which the request will fail.\n- Retry: set the retry policy, such as trigger conditions, number of retries, interval time, etc.\n\n### DestinationRule\n\nLoad balancing: setting up load balancing policies, such as simple load balancing, locality-aware load balancing, and area-weighted load balancing.\nCircuit Breaking: Outlier detection and connection pool settings to remove anomalous nodes from the load balancing pool.\n\n*VirtualService* mainly handles routing-related functions, while *DestinationRule* is responsible for adding and ejecting nodes from the cluster and load balancing.\n\nGateway API Converging the Ingress Gateway from Kubernetes and Service Mesh\n\nAs mentioned above, there is a partial functional intersection between the Gateway API and the service mesh. To reduce duplication of development and enable the modeling of common concerns between the Gateway API and the service mesh, the Gateway API Working Group has proposed the [Gateway API Mesh Management and Administration](https:\/\/gateway-api.sigs.k8s.io\/contributing\/gamma\/) (GAMMA) initiative.\n\nUnder this initiative, advanced traffic management features that vary in detail across gateway implementations, such as timeouts, retries, health checks, etc., will all be implemented by individual providers through [policy attachment](https:\/\/gateway-api.sigs.k8s.io\/references\/policy-attachment\/). You can specify the resource object to which the policy attachment is attached via the *targetRef* field, as shown below.\n\n\u0060\u0060\u0060yaml\napiVersion: networking.acme.io\/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: foo\nspec:\n  override:\n    maxRetries: 10\n  default:\n    maxRetries: 5\n  targetRef:\n    group: gateway.networking.k8s.io\/v1alpha2\n    kind: HTTPRoute\n    name: foo\n\u0060\u0060\u0060\n\nIn this example, the retry policy is attached to a resource named *foo* and *HTTPRoute*. Policy attachments are connected to different resource objects with varying priorities for effectiveness. For instance, GatewayClass is a cluster-level resource and will take precedence if the policy attachment is overlaid on it.\n\nYou can assign override and default values to additional policies whose priority in the ingress and the different resources in the mesh hierarchy are shown in the figure below.\n\n![Figure 6: Kubernetes Ingress and Mesh with Overrides and Default Priorities](policy-attachment-priority.svg)\n\nCurrently, the Gateway API is being explored to handle mesh traffic, and several [design options](https:\/\/docs.google.com\/document\/d\/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU\/edit#heading=h.6ks49gf06yii) have been proposed.\n\n## Envoy Gateway\n\nThe first open-source version of Envoy Gateway, [v0.2, was released](https:\/\/blog.envoyproxy.io\/introducing-envoy-gateway-ad385cc59532) in October 2022. It was created based on the Envoy proxy’s compliance with the Gateway API, of which [Tetrate ](https:\/\/tetrate.io\/)is a core sponsor. Its expressive, scalable, role-oriented API design through ingress and L4\/L7 traffic routing makes it the foundation for vendors to build value-added API gateway products.\n\nLong before Envoy Gateway was released, Envoy was massively adopted as one of the most popular cloud-native proxies, with several Gateway software builds based on Envoy, and the Istio service mesh used it as the default sidecar proxy and configured these distributed proxies via the xDS protocol. Envoy Gateway also uses xDS to configure the Envoy fleet. The following diagram illustrates the architecture of Envoy Gateway.\n\n![Figure: Envoy Gateway architecture](envoy-gateway-arch.svg)\n\nThe infrastructure provider will provide you with GatewayGlass. You can create an Envoy Gateway by creating a Gateway declaration. Your routing and policy attachments in the Gateway will be sent to the Envoy fleet via the xDS protocol.\n\nFor further information about Envoy Gateway, please read\n\n- [Hands on with the New Kubernetes Gateway API, Using Envoy Gateway 0.2](https:\/\/tetrate.io\/blog\/hands-on-with-the-gateway-api-using-envoy-gateway-0-2\/)\n- [Gateway to the Future: the New Kubernetes Gateway API and Envoy Gateway 0.2](https:\/\/tetrate.io\/blog\/gateway-to-the-future-the-new-gateway-api-and-envoy-gateway-0-2\/)\n\n## Summary\n\nThe Gateway API, as the next-generation Kubernetes Ingress API, provides a better degree of API specification for Kubernetes gateway providers as opposed to the Ingress API before, enriching the functionality of the ingress gateway while ensuring its portability and facilitating the management of gateways by different stakeholders through the separation of concerns. Finally, the GAMMA initiative is promoting the integration of the Ingress Gateway with the Gateway API for service mesh, and policy attachments may further extend the functionality of the Gateway API to east-west gateways.\n\n---\n\n*This blog was originally published at [tetrate.io](https:\/\/tetrate.io\/blog\/why-the-gateway-api-is-the-unified-future-of-ingress-for-kubernetes-and-service-mesh\/).*\n', '\/en\/blog\/why-gateway-api-is-the-future-of-ingress-and-mesh\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article introduces the ingress gateway and Gateway API in Kubernetes, the new trend of them with service mesh.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
              <div class="col-sm-6 mb-3">
  <article class="card rounded-0 border-bottom border-primary border-top-0 border-left-0 border-right-0 hover-shadow">
    
    
    <div class="card-body blog-list-card-body">
      <p class="card-title"><a href="/en/blog/beyond-istio-oss/">The Current State and Future of the Istio Service Mesh</a></p>
      
      <div class="blog-list-metadata">
          <ul class="list-inline">
             
             <li class="list-inline-item mr-2 mb-md-0"><i class="fa-regular fa-calendar"></i>
               Jul 18, 2022</li>
             <li class="list-inline-item mr-2 md-md-0"><i class="fa-regular fa-folder-open"></i>
             
             <a href="/en/categories/istio"> 
             Istio
             </a>
             
             </li>
             
             <li class="list-inline-item mr-2 mb-md-0">
              

             </li>
             
             <li class="list-inline-item mr-2 mb-md-0 export-button" style="display: none;">
              <a href="#" onclick="exportToMarkdown('The Current State and Future of the Istio Service Mesh', 'This article explains the background of Istio\u0027s birth, its position in the cloud-native technology stack, and the development direction of Istio.', '\nThis article reviews the development of Istio open source in the past five years and looks forward to the future direction of Istio. The main points of view in this article are as follows:\n\n- Due to the popularity of Kubernetes, microservices, DevOps, and cloud-native architectures, the rise of service mesh technology.\n- The rise of Kubernetes and programmable proxies has laid the technical groundwork for Istio\u0027s implementation.\n- While eBPF can accelerate transparent traffic hijacking in Istio, it can not replace sidecars in service meshes.\n- The future of Istio is to build a zero-trust network.\n\nNext, we start this article with the background of the birth of Istio.\n\n## The eve of the birth of Istio\n\nSince 2013, with the explosion of the mobile Internet, enterprises have had higher requirements for the efficiency of application iteration. Application architecture has begun to shift from monolithic to microservices, and DevOps has also become popular. In the same year, with the open source of Docker, the problems of application encapsulation and isolation were solved, making it easier to schedule applications in the orchestration system. In 2014, Kubernetes and Spring Boot were open-sourced, and Spring framework development of microservice applications became popular. In the next few years, a large number of RPC middleware open source projects appeared, such as Google released gRPC 1.0 in 2016. The service framework is in full bloom. In order to save costs, increase development efficiency, and make applications more flexible, more and more enterprises are migrating to the cloud, but this is not just as simple as moving applications to the cloud. In order to use cloud computing more efficiently, a set of \u0022cloud native\u0022 methods and concepts are also on the horizon.\n\n## Istio Open Source Timeline\n\nLet\u0027s briefly review the major events of Istio open source:\n\n- **September 2016**: Since Envoy is an important part of Istio, Istio\u0027s open source timeline should have an Envoy part. At first, Envoy was only used as an edge proxy inside Lyft, and it was verified in large-scale production inside Lyft before Envoy was open sourced. In fact, Envoy was open sourced before it was open sourced, and it got the attention of Google engineers. At that time, Google was planning to launch an open source project of service mesh, and initially planned to use Nginx as a proxy. In 2017, Envoy donated to [CNCF](https:\/\/cncf.io\/).\n- **May 2017**: Istio was announced as open source by Google, IBM, and Lyft. The microservices architecture was used from the beginning. The composition of the data plane, control plane, and sidecar pattern were determined.\n- **March 2018**: Kubernetes successfully became the first project to graduate from CNCF, becoming more and more \u0022boring\u0022. The basic API has been finalized. In the second edition, CNCF officially wrote the service mesh into the cloud native first definition. The company I currently work for, [Tetrate](https:\/\/tetrate.io\/), was founded by the Google Istio team.\n- **July 2018**: Istio 1.0 is released, billed as \u0022production ready\u0022.\n- **March 2020**: Istio 1.5 was released, the architecture returned to a monolithic application, the release cycle was determined, a major version was released every three months, and the API became stable.\n- **From 2020 to the present**: The development of Istio mainly focuses on Day 2 operation, performance optimization, and extensibility. Several open source projects in the Istio ecosystem have begun to emerge, such as [Slime](https:\/\/github.com\/slime-io\/slime\/), [Areaki](https:\/\/github.com\/aeraki-mesh\/aeraki), and [Merbridge](https:\/\/github.com\/merbridge\/merbridge).\n\n## Why did Istio come after Kubernetes?\n\nThe emergence mentioned here refers to the birth of the concept of \u0022service mesh\u0022. After microservices and containerization, the increase in the use of heterogeneous languages, the surge in the number of services, and the shortened life cycle of containers are the fundamental reasons for the emergence of service meshes.\n\nTo make it possible for developers to manage traffic between services with minimal cost, Istio needs to solve three problems:\n\n1. Transparent traffic hijacks traffic between applications, which means that developers can quickly use the capabilities brought by Istio without modifying applications.\n1. Another point is the operation and maintenance level; how to inject the proxy into each application and manage these distributed sidecar proxies efficiently.\n1. An efficient and scalable sidecar proxy that can be configured through an API.\n\nThe above three conditions are indispensable for the Istio service mesh, and we can see from them that these requirements are basically the requirements for the sidecar proxy. The choice of this proxy will directly affect the direction and success of the project.\n\nIn order to solve the three problems above, Istio chose:\n\n1. Container Orchestration and Scheduling Platform: Kubernetes\n1. Programable proxy: Envoy\n\nFrom the figure below, we can see the transition of the service deployment architecture from Kubernetes to Istio, with many changes and constants.\n\n![Schematic diagram of the architectural change from Kubernetes to Istio](kubernetes-to-istio.svg)\n\nFrom Kubernetes to Istio, in a nutshell, the deployment architecture of the application has the following characteristics:\n\n- Kubernetes manages the life cycle of applications, specifically, application deployment and management (scaling, automatic recovery, and release).\n- Automatic sidecar injection based on Kubernetes to achieve transparent traffic interception. First, the inter-service traffic is intercepted through the sidecar proxy, and then the behavior of the microservice is managed through the control plane configuration. Nowadays, the deployment mode of service mesh has also ushered in new challenges. A sidecar is no longer necessary for Istio service mesh. The proxyless service mesh based on gRPC is also being tested.\n- The service mesh decouples traffic management from Kubernetes, and the traffic inside the service mesh does not need the support of the kube-proxy component. Through the abstraction close to the microservice application layer, the traffic between services is managed to achieve security and observability functions.\n- The control plane issues proxy configuration to the data plane through the xDS protocol. The proxies that have implemented xDS include [Envoy](https:\/\/envoyproxy.io\/) and the open source [MOSN](https:\/\/mosn.io\/).\n- When a client outside the Kubernetes cluster accesses the internal services of the cluster, it was originally through Kubernetes Ingress, but after Istio is available, it will be accessed through Gateway.\n\n### Transparent traffic hijacking\n\nIf you are using middleware such as gRPC to develop microservices, after integrating the SDK into the program, the interceptor in the SDK will automatically intercept the traffic for you, as shown in the following figure.\n\n![Interceptor diagram of gRPC](grpc.svg)\n\nHow to make the traffic in the Kubernetes pod go through the proxy? The answer is to inject a proxy into each application pod, share the network space with the application, and then modify the traffic path within the pod so that all traffic in and out of the pod goes through the sidecar. Its architecture is shown in the figure below.\n\n![Diagram of transparent traffic hijacking in Istio](istio-route-iptables.svg)\n\nFrom the figure, we can see that there is a very complex set of iptables traffic hijacking logic. The advantage of using iptables is that it is applicable to any Linux operating system. But this also has some side effects:\n\n1. All services in the Istio mesh need to add a network hop when entering and leaving the pod. Although each hop may only be two or three milliseconds, as the dependencies between services and services in the mesh increase, this latency may increase significantly, which may not be suitable for service meshes for services that pursue low latency.\n1. Because Istio injects a large number of sidecars into the data plane, especially when the number of services increases, the control plane needs to deliver more Envoy proxy configurations to the data plane, which will cause the data plane to occupy a lot of system memory and network resources.\n\nHow to optimize the service mesh in response to these two problems?\n\n1. Use proxyless mode: remove the sidecar proxy and go back to the SDK.\n1. Optimize the data plane: reduce the frequency and size of proxy configurations delivered to the data plane.\n1. eBPF: it can be used to optimize network hijacking.\n\nThis article will explain these details in the section on performance optimization later on.\n\n### Sidecar operation and maintenance management\n\nIstio is built on top of Kubernetes, which can leverage Kubernetes\u0027 container orchestration and lifecycle management to automatically inject sidecars into pods through admission controllers when Kubernetes creates pods. \n\nIn order to solve the resource consumption problem of Sidecar, some people have proposed four deployment modes for the service mesh, as shown in the following figure.\n\n![Schematic diagram of four deployment modes of service mesh](deployment-model.svg)\n\nThe following table compares these four deployment methods in detail. Each of them has advantages and disadvantages. The specific choice depends on the current situation.\n\n{{\u003ctable \u0022Comparison of four deployment modes of service mesh\u0022\u003e}}\n\n| **Mode**                                 | **Memory overhead**                                          | **Security**                                                 | **Fault domain**                                             | **Operation and maintenance**                                |\n| :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **Sidecar proxy**                        | The overhead is greatest because a proxy is injected per pod. | Since the sidecar must be deployed with the workload, it is possible for the workload to bypass the sidecar. | Pod-level isolation, if the proxy fails, only the workload in the Pod is affected. | A workload\u0027s sidecar can be upgraded independently without affecting other workloads. |\n| **Node sharing proxy**                   | There is only one proxy on each node, shared by all workloads on that node, with low overhead. | There are security risks in the management of encrypted content and private keys. | Node-level isolation, if a version conflict, configuration conflict, or extension incompatibility occurs when a shared proxy is upgraded, it may affect all workloads on that node. | There is no need to worry about injecting sidecars.          |\n| **Service Account \/ Node Sharing Proxy** | All workloads under the service account\/identity use a shared proxy with little overhead. | Authentication and security of connections between workloads and proxy cannot be guaranteed. | The level isolation between nodes and service accounts, the fault is the same as \u0022node sharing proxy\u0022. | Same as \u0022node sharing proxy\u0022 mode.                           |\n| **Shared remote proxy with micro-proxy** | Because injecting a micro-proxy for each pod, the overhead is relatively large. | The micro-proxy handles mTLS exclusively and is not responsible for L7 routing, which can ensure security. | When a Layer 7 policy needs to be applied, the traffic of the workload instance is redirected to the L7 proxy, and can be bypassed directly if it is not needed. The L7 proxy can run as a shared node proxy, a per-service account proxy, or a remote proxy | Same as \u0022sidecar proxy\u0022 mode.                                |\n\n{{\u003c\/table\u003e}}\n\n### Programmable proxy\n\nZhang Xiaohui of Flomesh explained the evolution of proxy software. I will quote some of his views below to illustrate the key role of programmable proxies in Istio.\n\nThe following figure shows the evolution process of the proxy software from configuration to programmable mode, and the representative proxy software in each stage.\n\n![Schematic diagram of the evolution of proxy software](proxy-evolution.svg)\n\nThe entire proxy evolution process is as the application moves from local and monolithic to large-scale and distributed. Below, I will briefly outline the evolution of the proxy software:\n\n- **The era of configuration files**: almost all software has configuration files, and proxy software is more inseparable from configuration files because of its relatively complex functions. The proxy at this stage is mainly developed using the C language, including its extension module, which highlights the ability of the proxy itself. This is also the most primitive and basic form of our use of proxies, including Nginx, Apache HTTP Server, [Squid](http:\/\/www.squid-cache.org\/), etc.\n- **Configuration language era**: Proxies in this era are more extensible and flexible, such as dynamic data acquisition and matching logic judgment. Varnish and HAProxy are two examples of representative software.\n- **The era of scripting languages**: Since the introduction of scripting languages, proxy software has become programmable. We can use scripts to add dynamic logic to proxies more easily, increasing development efficiency. The representative software is Nginx and its supported scripting languages.\n- **The era of clusters**: With the popularity of cloud computing, large-scale deployment and dynamic configuration of APIs have become necessary capabilities for proxies, and with the increase in network traffic, large-scale proxy clusters have emerged as the times require. The representative proxy software of this era includes Envoy, Kong, etc.\n- **Cloud-native era**: Multi-tenancy, elasticity, heterogeneous hybrid cloud, multi-cluster, security, and observability are all higher requirements for proxies in the cloud-native era. This will also be a historical opportunity for service meshes, with representative software such as Istio, Linkerd, and [Pypi](https:\/\/flomesh.io\/).\n\n## Are these all service meshes?\n\nSo, is it possible to build a service mesh with proxies? Now I will list the existing service mesh projects, and let\u0027s explore the development law and nature of service mesh together. The table below compares the current popular open source \u0022service mesh\u0022 projects.\n\n{{\u003ctable \u0022Service mesh open source project comparison table\u0022\u003e}}\n\n| Contrast           | Istio                                                        | Linkerd                                                     | Consul Connect                                               | Traefik Mesh                                                 | Kuma                                | Open Service Mesh (OSM)                       |\n| :----------------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------- | :-------------------------------------------- |\n| Current version   | 1.14                                                         | 2.11                                                        | 1.12                                                         | 1.4                                                          | 1.5                                 | 1.0l                                          |\n| License           | Apache License 2.0                                           | Apache License 2.0                                          | Mozilla License                                              | Apache License 2.0                                           | Apache License 2.0                  | Apache License 2.0                            |\n| Initiator          | Google, IBM, Lyft                                            | Buoyant                                                     | HashiCorp                                                    | Traefik Labs                                                 | Kong                                | Microsoft                                     |\n| Service proxy | Envoy, which supports proxyless mode for gRPC                | [Linkerd2-proxy](https:\/\/github.com\/linkerd\/linkerd2-proxy) | Default is [Envoy](https:\/\/www.envoyproxy.io\/) , replaceable | [Traefik Proxy](https:\/\/traefik.io\/traefik\/)                 | [Envoy](https:\/\/www.envoyproxy.io\/) | [Envoy](https:\/\/www.envoyproxy.io\/)           |\n| Ingress controller | Envoy, custom Ingress, supports Kubernetes Gateway API       | no built-in                                                 | Envoy, with support for the Kubernetes Gateway API           | no built-in                                                  | Kong                                | Support Contour, Nginx, compatible with other |\n| Governance         | Istio Community and Open Usage Commons, proposed to donate to CNCF | CNCF                                                        | View [Contribution Guidelines](https:\/\/github.com\/hashicorp\/consul\/blob\/master\/.github\/CONTRIBUTING.md) | View [Contribution Guidelines](https:\/\/github.com\/traefik\/mesh\/blob\/master\/CONTRIBUTING.md) | CNCF                                | CNCF                                          |\n| Comment | It is one of the most popular service mesh projects at present. | The earliest service mesh, the creator of the concept of \u0022Service Mesh\u0022, the first service mesh project to enter CNCF, using a lightweight proxy developed with Rust. | Consul service mesh, using Envoy as a sidecar proxy. | A service mesh project launched by Traefik, using Traefik Proxy as a sidecar and supporting SMI (mentioned below). | A service mesh project launched by Kong that uses Envoy as a sidecar proxy, using Kong\u0027s own gateway as ingress. | An open source service mesh created by Microsoft, using Envoy as a sidecar, compatible with SMI (also proposed by Microsoft). |\n\n{{\u003c \/table \u003e}}\n\nThe open source projects in the above table are summarized below, and several projects closely related to service mesh are added, as follows:\n\n- [Envoy](https:\/\/envoyproxy.io\/): Envoy is a cloud-native proxy, frequently used as a sidecar in other Envoy-based service meshes and for building API Gateways.\n- [Service Mesh Performance (SMP)](https:\/\/smp-spec.io\/): Metrics that capture details of infrastructure capacity, service mesh configuration, and workload metadata to standardize service mesh values and describe the performance of any deployment.\n- [Service Mesh Interface (SMI)](https:\/\/smi-spec.io\/): It is not a service mesh, but a set of service mesh implementation standards. Similar to OAM, SPIFFE, CNI, CSI, etc., it defines interface standards, and the specific implementation varies. Currently, Traefik Mesh and Open Service Mesh claim to support this specification.\n- [Network Service Mesh](https:\/\/networkservicemesh.io\/): It\u0027s worth mentioning this project because it\u0027s often mistaken for a service mesh. In fact, it is oriented towards a three-layer network, and it can be used to connect multi-cloud\/hybrid clouds without changing the CNI plug-in. It\u0027s not a \u0022service mesh\u0022 as we define it, but a powerful complement to a service mesh (albeit a somewhat confusing name with a service mesh in it).\n\nLooking at the so-called \u0022service mesh\u0022 projects mentioned above, we can see that most service mesh project initiators start out as proxies, and then do the control plane. And Istio, Consul Connect, Open Service Mesh, and Kuma all use Envoy as a sidecar proxy. Only Linkerd and Traefik Mesh have launched their own proxies. And all service mesh projects support the sidecar pattern. Apart from Istio, Linkerd, and Consul Connect, which have been used in production, other service mesh projects are currently only \u0022toys\u0022.\n\n## Performance optimization for Istio\n\nAfter Istio 1.5 had a stable architecture, the community\u0027s main focus was on optimizing Istio\u0027s performance. Below, I will give you a detailed introduction to performance optimization methods in Istio, including:\n\n- Use the Proxyless mode.\n- Use eBPF to optimize traffic hijacking.\n- Optimization of control plane performance.\n- Optimization of data plane performance.\n\n### Proxyless mode\n\nProxyless mode is an experimental feature proposed by Istio in version 1.11-a service mesh without sidecar proxy based on gRPC and Istio. Using this pattern allows you to add gRPC services directly to Istio without injecting an Envoy proxy into the Pod. The figure below shows a comparison of sidecar mode and proxyless mode.\n\n![Sidecar vs Proxyless](sidecar-to-proxyless.svg)\n\nAs we can see from the above figure, although proxyless mode does not use a proxy for data plane communication, it still needs an agent for initialization and communication with the control plane. First, the agent generates a bootstrap file at startup, in the same way that it generates bootstrap files for Envoy. This tells the gRPC library how to connect to Istiod, where to find certificates for data plane communication, and what metadata to send to the control plane. Next, the agent acts as an xDS proxy, connecting and authenticating with \u0060Istiod\u0060. Finally, the agent obtains and rotates the certificate used in the data plane communication.\n\n\u003e *The essence of a service mesh is not a sidecar model, nor a configuration center, or transparent traffic interception, but a standardized inter-service communication standard.*\n\nSome people say that the proxyless model has returned to the old way of developing microservices based on SDK, and the advantages of service meshes have been lost. Can it still be called service mesh? In fact, this is also a compromise on performance—if you mainly use gRPC to develop microservices, you only need to maintain gRPC versions in different languages; that is, you can manage microservices through the control plane.\n\n\u003e *Envoy xDS has become the de facto standard for communication between cloud-native application services.*\n\n### Optimizing traffic hijacking with eBPF\n\nIn the section on transparent traffic hijacking, we can see the iptables rules and paths that an inter-service traffic passes through when it reaches the destination pod, which needs to go through multiple iptables rules, such as \u0060PREROUTING\u0060, \u0060ISTIO_INBOUND\u0060, \u0060ISTIO_IN_REDIRECT\u0060, \u0060OUTPUT\u0060, \u0060ISTIO_OUTPUT\u0060, and so on. Suppose now that there is a service A that wants to call service B in another pod on a non-localhost through the network stack, as shown in the figure below.\n\n![Service request path between pods not on the same host (iptables mode)](iptables-process.svg)\n\nFrom the figure, we can see that there are four iptables passes in the whole calling process. Among them, the outbound (iptables2) from Envoy in Pod A and the inbound (iptables3) from eth0 in Pod B are unavoidable. So can the remaining two, iptables1 and iptables4 be optimized? Wouldn\u0027t it be possible to shorten the network path by letting the two sockets communicate directly? This requires programming through eBPF such that:\n\n- Service A\u0027s traffic is sent directly to Envoy\u0027s inbound socket.\n- After Envoy in Pod B receives the inbound traffic, it has determined that the traffic is to be sent to the local service and directly connects the outbound socket to Service B.\n\nThe transparent traffic interception network path using eBPF mode is shown in the following figure.\n\n![Service request path between pods not on the same host (eBPF mode)](ebpf-diff-node.svg)\n\nIf service A and service B to be accessed are on the same node, the network path will be shorter.\n\n![Network request path between the same host Pod (eBPF mode)](ebpf-same-node.svg)\n\nAccess between services in the same node completely bypasses the TCP\/IP stack and becomes direct access between sockets.\n\n{{\u003ccallout note \u0022What is eBPF?\u0022\u003e}}\n\nWe know that modifying the Linux kernel code is difficult, and it takes a long time for new features to be released into the kernel. eBPF is a framework that allows users to load and run custom programs within the operating system\u0027s kernel. That is, with eBPF, you can extend and change the behavior of the kernel without directly modifying the kernel. I will briefly introduce eBPF to you below.\n\n- After the eBPF program is loaded into the kernel, it needs to pass the verification of the verifier before it can run. The verifier can prevent the eBPF program from accessing beyond its authority, ensuring the kernel\u0027s security.\n- eBPF programs are attached to kernel events and are triggered when there is an entry or exit from a kernel function.\n- In kernel space, eBPF programs must be written in a language that supports a compiler that generates eBPF byte code. Currently, you can write eBPF programs in C and Rust.\n- The eBPF program has compatibility issues with different Linux versions.\n\nSince the eBPF program can directly monitor and operate the Linux kernel, it has a perspective on the lowest level of the system and can play a role in traffic management, observability, and security.\n\n{{\u003c\/callout\u003e}}\n\nThe open source project [Merbridge](https:\/\/github.com\/merbridge\/merbridge) uses eBPF to shorten the path of transparent traffic hijacking and optimize the performance of the service mesh. For some details on the Merbridge implementation, please refer to the [Istio blog](https:\/\/istio.io\/latest\/blog\/2022\/merbridge\/) .\n\n{{\u003ccallout warning Notice\u003e}}\nThe eBPF functions used by Merbridge require a Linux kernel version ≥ 5.7.\n{{\u003c\/callout\u003e}}\n\nAt first glance, eBPF seems to implement the functions of Istio at a lower level and has a greater tendency to replace sidecar. But eBPF also has many limitations that make it impossible to replace service meshes and sidecars in the foreseeable future. Removing the sidecar in favor of a proxy-per-host model would result in:\n\n1. The explosion radius of a proxy failure is expanded to the entire node.\n2. It makes the security problem more complicated because too many certificates are stored on a node. Once attacked, there will be a risk of key leakage.\n3. On the host, traffic contention between Pods.\n\nMoreover, eBPF is mainly responsible for Layer 3\/4 traffic and can run together with CNI, but it is not suitable to use eBPF for Layer 7 traffic.\n\n\u003e *In the near future, eBPF technology will not be able to replace service meshes and sidecars.*\n\n### Control plane performance optimization\n\nThe above two optimizations are carried out for the data plane. Let\u0027s look at the performance optimization of the control plane. You can think of a service mesh as a show, where the control plane is the director and the data plane is all the actors. The director is not involved in the show but directs the actors. If the plot of the show is simple and the duration is very short, then each actor will be allocated very few scenes, and rehearsal will be very easy; if it is a large-scale show, the number of actors is large and the plot is very complicated. To rehearse the show well, one director may not be enough. He can\u0027t direct so many actors, so we need multiple assistant directors (expanding the number of control plane instances); we also need to prepare lines and scripts for actors, if actors It is also possible to perform a series of lines and scenes in one shot (reduce the interruption of the data plane and push updates in batches), so is our rehearsal more efficient?\n\nFrom the above analogy, you should be able to find the direction of control plane performance optimization, that is:\n\n- Reduce the size of the configuration that needs to be pushed.\n- Push batch proxy.\n- To expand the scale of the control plane.\n\n#### Reduce the configuration that needs to be pushed out\n\nThe easiest and most straightforward way to optimize control plane performance is to reduce the size of the configuration to be pushed. Assuming that there is workload A, if the proxy configuration related to A, that is, the configuration of the service that A needs to access, is pushed to A, instead of pushing the configuration of all services in the mesh to A, it can greatly reduce the number of services to be pushed. The size and application range of the configuration. The Sidecar resource in Istio can help us do this. The following is an example of a sidecar configuration:\n\n\u0060\u0060\u0060yaml\napiVersion: networking.istio.io\/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: us-west-1\nspec:\n  workloadSelector:\n    labels:\n      app: app-a\n  egress:\n  - hosts:\n    - \u0022us-west-1\/*\u0022\n\u0060\u0060\u0060\n\nWe can use the \u0060workloadSelector\u0060 field  to limit the scope of workloads that the sidecar configuration applies to, and the \u0060egress\u0060 field is used to determine the scope of services for the workload, so that the control plane can only push the configuration of its dependent services to service A, greatly reducing the need to push to the data plane. The configuration size of the service mesh reduces the memory and network consumption of the service mesh.\n\n#### Batch push the proxy configurations\n\nThe process of pushing the proxy configuration from the control plane Istiod to the data plane is complex. The following figure shows the process.\n\n![Flowchart of Istiod pushing proxy configuration to the data plane](istiod-push.svg)\n\nAfter an administrator configures the Istio mesh, the process for pushing proxy configuration in Istiod is as follows:\n\n1. The event that the administrator updates the configuration will trigger the configuration synchronization of the data plane.\n1. After listening to these events, Istio\u0027s \u0060DiscoveryServer\u0060 components will not push the configuration to the data plane immediately, but will add these events to the queue and continue to merge events within a period of time. This process is called debouncing, which is to prevent frequent updates to the data plane configuration.\n1. After the debouncing period, these events will be pushed to the queue.\n1. To expedite push progress, Istiod will limit the number of simultaneous push requests.\n1. Envoy configuration push data plane workloads are translated into events.\n\nFrom the above process, we can see that the key to optimizing configuration push is the debounce period in step 2 and the current limit setting in step 4. There are several environmental variables that can help you set up control plane push:\n\n- \u0060PILOT_DEBOUNCE_AFTER\u0060: The time after which the event will be added to the push queue.\n- \u0060PILOT_DEBOUNCE_MAX\u0060: This defines the maximum amount of time an event can debounce.\n- \u0060PILOT_ENABLE_EDS_DEBOUNCE\u0060: Specifies whether endpoint updates meet debounce rules or have priority and fall into the push queue immediately.\n- \u0060PILOT_PUSH_THROTTLE\u0060: Controls how many push requests are processed at once.\n\nPlease refer to the [Istio documentation](https:\/\/istio.io\/latest\/docs\/reference\/commands\/pilot-agent\/#envvars) for the default values and specific configuration of these environment variables .\n\nHow to set these values can follow the following principles:\n\n- If control plane resources are idle, to speed up the propagation of configuration updates, you can:\n  - Shorten the debounce period and increase the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n- If the control plane is saturated, to reduce performance bottlenecks, you can:\n  - Delay the debounce cycle to reduce the number of pushes.\n  - Increase the number of push requests processed simultaneously.\n\nAs for how to set the optimal solution, you need to debug it in conjunction with your observable system.\n\n#### Scale up the control plane\n\nIf setting up debounce batch processing and sidecar cannot optimize the performance of the control plane, the final choice is to expand the scale of the control plane, including expanding the resources of a single Istiod instance and increasing the number of Istiod instances. Which expansion method is used depends on the situation:\n\n- When the resource occupancy of a single Istiod is saturated, it is recommended that you increase the instance size of Istiod. This is usually because there are too many resources in the service mesh (Istio\u0027s custom resources, such as VirtualService, DestinationRule, etc.) that need to be processed.\n- Then increase the number of instances of Istiod, which can spread the workloads to be managed by each instance.\n\n### Data plane performance optimization\n\nApache SkyWalking can serve as an observability tool for Istio and can also help us analyze the performance of services in dynamic debugging and troubleshooting. Its newly launched Apache SkyWalking Rover component can use eBPF technology to accurately locate Istio\u0027s key performance issues.\n\nOn the data plane, we can increase Envoy\u0027s throughput to optimize Istio\u0027s performance by:\n\n- Disable Zipkin tracing or reduce the sample rate.\n- Simplified access log format.\n- Disable Envoy\u0027s Access Log Service (ALS).\n\nFor data on the impact of the above optimizations on Envoy throughput, see Using eBPF to pinpoint key performance issues for service meshes.\n\n## Envoy: the service mesh\u0027s leading actor\n\nWe know that the service mesh is composed of the data plane and the control plane. From the above list of service mesh open source projects, we can see that most of the service mesh open source projects are based on Envoy, and then develop their own control plane. Remember when I likened a service mesh to a gig earlier in this article? In this service mesh performance, there is no way to think that Envoy is the leading actor. The xDS protocol, invented by Envoy, has basically become a general API for service meshes. Many open source projects for service meshes use Envoy as the data plane. Shown below is the architecture diagram of Envoy.\n\n![Envoy Architecture Diagram](envoy-arch.svg)\n\nxDS is the core that differentiates Envoy from other proxies because its code and parsing process are very complex and it is difficult to expand. The following is a topology diagram of Istio components. From the figure, we can see that there is not only one \u0060envoy\u0060 process but a \u0060pilot-agent\u0060.\n\n{{\u003cfigure title=\u0022Istio component topology\u0022 alt=\u0022image\u0022 id=\u0022istio-components\u0022 src=\u0022istio-components.svg\u0022\u003e}}\n\nThe role of the \u0060pilot-agent\u0060 process is as follows:\n\n- As \u0060the\u0060 parent process of, responsible for the lifecycle management of Envoy.\n- Receive pushes from the control plane, configure the proxy and certificates.\n- Collect Envoy statistics and aggregate sidecar statistics for Prometheus to collect.\n- A built-in local DNS proxy is used to resolve the internal domain name of the cluster that cannot be resolved by Kubernetes DNS.\n- Health checks for Envoy and DNS proxy.\n\nFrom the above functions, we can see that the \u0060pilot-agent\u0060 process is mainly used to interact with Istiod and play a commanding and auxiliary role for Envoy. The core component of Istio is Envoy. So will Envoy \u0022act and guide,\u0022 no longer cooperate with Istio, and build its own control plane?\n\n\u003e *In a Sidecar container, the \u0060pilot-agent\u0060 is like Envoy\u0027s \u0022Sidecar\u0022.*\n\n{{\u003ccallout note \u0022Readers to think about\u0022\u003e}}\nCan the \u0060pilot-agent\u0060 function be built directly into Envoy, thus eliminating the \u0060pilot-agent\u0060?\n{{\u003c\/callout\u003e}}\n\n## Envoy Gateway unified service mesh gateway\n\nIn Kubernetes, the first resource object used to expose services in a cluster, in addition to the service resource object, is Ingress. Using Ingress you simply open an external access point for the cluster, routing traffic to specific services via HTTP Hosts and \u0060path\u0060. Compared with exposing services directly to service resources , it can reduce the network access point (PEP) of the cluster and reduce the risk of the cluster being attacked by the network. The following figure shows the process of using Ingress to access services in the cluster.\n\n![Kubernetes Ingress traffic access flow chart](ingress.svg)\n\nBefore Kubernetes, API Gateway software was widely used as edge routing. When referring to Istio, Istio\u0027s custom Gateway resources are added, which makes accessing resources in the Istio service mesh one more option, as shown in the following figure.\n\n![Ways to access services in the Istio mesh](access-cluster.svg)\n\nNow, to expose services in a single Istio mesh, how do I choose between \u0060NodePort\u0060, \u0060LoadBalancer\u0060, Istio Gateway, Kubernetes Ingress, and API Gateway software? If it is a multi-cluster service mesh, how do clients access services within the mesh? Our service mesh lead, Envoy, has done this well and is used in many forms:\n\n- Istio, Kuma, and Consul Connect all use Envoy as a sidecar proxy.\n- Kubernetes Ingress Controller\/API Gateway: [Contour](https:\/\/github.com\/projectcontour\/contour), [Emissary](https:\/\/github.com\/emissary-ingress\/emissary), [Hango](https:\/\/github.com\/hango-io\/hango-gateway), [Gloo](https:\/\/github.com\/solo-io\/gloo).\n\nThese projects utilize Envoy to implement service meshes and API gateways, with a lot of functional overlap, proprietary features, or a lack of community diversity due to the fact that the Envoy community does not provide a control plane implementation. In order to change the status quo, the Envoy community initiated the Envoy Gateway project, which will not change the Envoy core proxy, xDS, and go-control-plane. The project aims to combine the experience of existing Envoy-based API Gateway related projects. Some Envoy-specific extensions to the Kubernetes Gateway API lower the barrier to entry for Envoy users to use gateways. Because the Envoy Gateway still issues configuration to the Envoy proxy through xDS, you can also use it to manage gateways that support xDS, such as the Istio Gateway.\n\nThe gateways we have seen now are basically used as ingress gateways in a single cluster and can do nothing for multi-cluster and multi-mesh. To cope with multiple clusters, we need to add another layer of gateways on top of Istio and a global control plane to route traffic between multiple clusters, as shown in the figure below.\n\n![Schematic diagram of two-level gateway with multi-cluster and multi-mesh](t2-gateway.svg)\n\n{{\u003ccallout note \u0022A brief introduction to two-tire gateways\u0022\u003e}}\n- The Tire-1 gateway (hereinafter referred to as T1) is located at the application edge and is used in a multi-cluster environment. The same application is hosted on different clusters at the same time, and the T1 gateway routes the application\u0027s request traffic between these clusters.\n- The Tire-2 gateway (hereafter referred to as T2) is located at the edge of a cluster and is used to route traffic to services within that cluster managed by the service mesh.\n{{\u003c\/callout\u003e}}\n\nMulti-cluster service mesh management is achieved by adding a layer of global control plane and APIs in addition to the Istio control plane. Deploying T1 gateways as a cluster prevents a single point of failure. To learn more about two-tier gateways, refer [to Routing Service Mesh Traffic Through Two-Tier Gateway Designs](https:\/\/cloudnative.to\/blog\/designing-traffic-flow-via-tier1-and-tier2-ingress-gateways\/) .\n\nThe configuration of the T1 gateway is as follows:\n\n\u0060\u0060\u0060yaml\napiVersion: gateway.tsb.tetrate.io\/v2\nkind: Tier1Gateway\nmetadata:\n  name: service1-tier1\n  group: demo-gw-group\n  organization: demo-org\n  tenant: demo-tenant\n  workspace: demo-ws\nspec:\n  workloadSelector:\n    namespace: t1\n    labels:\n      app: gateway-t1\n      istio: ingressgateway\n  externalServers:\n  - name: service1\n    hostname: servicea.example.com\n    port: 80\n    tls: {}\n    clusters:\n    - name: cluster1\n      weight: 75\n    - name: cluster2\n      weight: 25 \n\u0060\u0060\u0060\n\nThis configuration exposes \u0060servicea.example.com\u0060  service through the T1 gateway and forwards \u006075%\u0060 of the traffic accessing the service to cluster1 and \u006025%\u0060 of the traffic to cluster2. In addition, in order to deal with the traffic, services, and security configurations in multiple clusters, Tetrate\u0027s flagship product, [Tetrate Service Bridge](https:\/\/www.tetrate.io\/tetrate-service-bridge\/), a series of group APIs have also been added to the TSB documentation for details.\n\n## Istio open source ecosystem\n\nIstio has been open source for more than five years, and many open source projects have emerged in the past two years, among which the more representative ones are:\n\n- Slime (NetEase open source)\n- Tencent\u0027s open source initiatives Aeraki\n- Istio\u0027s official support for Wasm plugins\n\nTheir presence makes Istio more intelligent and expands the scope of Istio.\n\n### Slime\n\nSlime is an Istio-based smart mesh manager open-sourced by the NetEase Shufan microservices team. Slime has been implemented based on Kubernetes Operator and can be used as the CRD manager of Istio. It can define dynamic service governance policies without any customization of Istio, so as to achieve the purpose of automatically and conveniently using the high-level functions of Istio and Envoy.\n\nIn the previous control plane performance optimization, we mentioned optimizing the performance of Istio by \u0022reducing the configuration that needs to be pushed\u0022, but Istio cannot automatically identify and cannot rely on the proxy configuration that needs to be pushed to each sidecar to optimize. Slime provides a  \u0060lazyload\u0060 controller, which can help us implement lazy loading of configuration. Users do not need to configure the \u0060SidecarScope\u0060 manually. Istio can load service configuration and service discovery information on demand.\n\nThe following figure shows the flow chart of updating the data plane configuration with Slime as the management plane of Istio.\n\n![Flowchart for updating Istio data plane configuration using Slime](slime-process.svg)\n\nThe specific steps for updating the data plane configuration are as follows:\n\n1. The Slime Operator completes the initialization of Slime components in Kubernetes according to the administrator\u0027s configuration.\n2. Developers create configurations that conform to the Slime CRD specification and apply them to the Kubernetes cluster.\n3. Slime queries the monitoring data of related services saved in Prometheus, converts Slime CRD to Istio CRD in combination with the configuration of the adaptive part in Slime CRD, and pushes it to Global Proxy at the same time.\n4. Istio monitors the creation of Istio CRDs.\n5. Istio sends the Sidecar Proxy\u0027s configuration information to the corresponding Sidecar Proxy on the data plane.\n\nBecause the first invocation of all services in the data plane passes through the Global Proxy, the Proxy can record the invocation and dependency information of all services, and update the configuration of the Sidecar resource in Istio according to the dependency information. When the routing information is redefined, the original record of the Global Proxy becomes invalid, and a new data structure is required to maintain the calling relationship of the service. Slime created a  \u0060ServiceFence\u0060 to maintain the service invocation relationship and solve the problem of missing service information.\n\n### Aeraki\n\nAeraki Mesh is a service mesh project open sourced by Tencent Cloud in March 2021. It expands support for seven-layer protocols based on Istio and focuses on solving the service governance of **non-HTTP protocols** in Istio.  It entered the CNCF sandbox in June 2022.\n\nThe following figure shows the architectural diagram of Aeraki.\n\n![Aeraki Architecture Diagram](aeraki-arch.svg)\n\nThe process of using Aeraki to serve non-HTTP into an Istio mesh is as follows:\n\n1. Aeraki\u0027s X2Istio component connects to the service registry, obtains the registration information of non-HTTP services, and generates a ServiceEntry to register with Istio.\n2. Aeraki, as the management plane on top of Istio, obtains the ServiceEntry configuration from Istio.\n3. Aeraki judges the protocol type of the service (e.g. \u0060tcp-metaprotocol-dubbo\u0060) through the port command, then generates the MetaProtocol Proxy Filter (compatible with EnvoyFilter) configuration, and at the same time modifies the RDS address to point it to Aeraki.\n4. Istio uses the xDS protocol to deliver the configuration (LDS, CDS, EDS, etc.) to the data plane.\n5. Aeraki generates routing rules based on the information in the service registry and user settings and sends them to the data plane through RDS.\n\nThe key to the whole process of accessing non-HTTP services in Istio is the **MetaProtocol Proxy**. Istio supports HTTP\/HTTP2, TCP and gRPC protocols by default, and experimentally supports Mongo, MySQL and Redis protocols. To use Istio to route traffic for other protocols not only requires a lot of work to modify the Istio control plane and extend Envoy, but also a lot of duplication because different protocols share common control logic. The Envoy MetaProtocol Proxy is a general seven-layer protocol proxy implemented based on Envoy. The MetaProtocol Proxy is an extension based on the Envoy code. It implements basic capabilities such as service discovery, load balancing, RDS dynamic routing, traffic mirroring, fault injection, local\/global traffic limiting, etc. for the seven-layer protocol, which greatly reduces the difficulty of third-party protocol development for Envoy.\n\nThe following figure shows the architecture diagram of MetaProtocol Proxy.\n\n![MetaProtocol Proxy Architecture Diagram](metaprotocol-proxy.svg)\n\nWhen we want to extend Istio to support other seven-layer protocols such as Kafka, Dubbo, and Thrift, we only need to implement the codec interfaces (Decode and Encode) in the above figure, and then we can quickly develop a third-party protocol plug-in based on MetaProtocol. Because MetaProtocol Proxy is an extension of Envoy, you can still develop filters for it in different languages and use \u0060EnvoyFilter\u0060 resources to deliver configuration to the data plane.\n\n### WasmPlugin API\n\nWasmPlugin is an API introduced in Istio 1.12. As a proxy extension mechanism, we can use it to add custom and third-party Wasm modules to the data plane. The diagram below shows how a user can use the WasmPlugin in Istio.\n\n![Flowchart of using WasmPlugin in Istio](wasmplugin.svg)\n\nSpecific steps are as follows:\n\n1. Users use the Proxy-Wasm SDK (currently available in AssemblyScript, C\u002b\u002b, Rust, Zig, and Go) to develop extensions and build them into OCI images (such as Docker images) to upload to the mirror repository.\n2. The user writes the \u0060WasmPlugin\u0060 configuration and applies it to Istio.\n3. The \u0060WasmPlugin\u0060 configuration for the workload in the configuration is selected by the Istio control plane, and the Wasm module is injected into the specified Pod.\n4. The \u0060pilot-agent\u0060 in the sidecar loads the Wasm modules from remote or local files and run them in Envoy.\n\n## Who should use Istio?\n\nWell, having said that, what does this have to do with you? Istio\u0027s relationship with you depends on your role.\n\n- If you are the platform leader, after applying the service mesh, you may enhance the observability of your platform and have a unified platform to manage microservices. You will be the direct beneficiary and the main implementer of the service mesh.\n- If you are an application developer, you will also benefit from a service mesh because you can be more dedicated to the business logic and not worry about other non-functional issues such as retry policies, TLS, etc..\n\nThe following diagram shows the adoption path for service meshes.\n\n![The path to adopt service mesh](adopt.svg)\n\nWhether to adopt a service mesh depends on your technology development stage, whether the application implements containerization and microservices, the need for multi-language, whether mTLS is required, and the acceptance of performance loss.\n\n## Service mesh positioning in the cloud native technology stack\n\nThe development of technology is changing with each passing day. In the past two years, some new technologies have appeared, which seem to challenge the status of the service mesh. Some people claim that it can directly replace the existing service mesh of the classic sidecar model. We should not be confused by the noise of the outside world, correcting the positioning of service mesh in the cloud native technology stack.\n\n\u003e *Blindly promoting a technology and ignoring its applicable scenarios is hooliganism.*\n\nThe diagram below shows the cloud-native technology stack.\n\n![Cloud native technology stack diagram](cloud-native-stack.svg)\n\nWe can see that the \u0022cloud infrastructure\u0022, \u0022middleware\u0022, and \u0022application\u0022 layers in the cloud native technology stack diagram all enumerate some iconic open source projects that build standards in their fields:\n\n- In the field of cloud infrastructure, Kubernetes unifies the standards for container orchestration and application life cycle management, and the Operator mode lays the standards for extending the Kubernetes API and third-party application access.\n- In the field of middleware, the service mesh assumes some or all of the responsibilities of the seven-layer network, observability, and security in the cloud native technology stack. It runs in the lower layer of the application and is almost imperceptible; Dapr (distributed application runtime) defines the capability model of cloud-native middleware. Developers can integrate Dapr\u0027s multi-language SDK into their applications and programs for the distributed capabilities provided by Dapr, without caring about the applications running on them. environment and docking back-end infrastructure. Because the Dapr runtime (Sidecar mode deployment, which contains various building blocks) is running in the same Pod as the application, it automatically connects us with the backend components;\n- In the application field, OAM aims to establish an application model standard, an application through components, characteristics, policies, and workflows.\n\nThe diagram below shows how Istio is positioned for seven-tier mesh management in a cloud-native deployment.\n\n![Istio is positioned in a seven-layer network in a cloud-native architecture](istio-role.svg)\n\n{{\u003ccallout note \u0022What is the relationship between Dapr and Istio?\u0022\u003e}}\n\nSimilarities between Istio and Dapr:\n\n- Both Istio and Dapr can use the sidecar mode deployment model.\n- Both belong to middleware and can also manage communication between services.\n\nDifferences between Istio and Dapr:\n\n- Different goals: Istio\u0027s goal is to build a zero-trust network and define inter-service communication standards, while Dapr\u0027s goal is to build a standard API for middleware capabilities.\n- Different architectures: Istio = Envoy \u002b transparent traffic hijacking \u002b control plane; Dapr = multilingual SDK \u002b standardized API \u002b distributed capability components.\n- However, the application of Istio is almost imperceptible to developers and mainly requires the implementation of the infrastructure operation and maintenance team, while the application of Dapr requires developers to independently choose to integrate the Dapr SDK.\n\n{{\u003c\/callout\u003e}}\n\n## The future of service mesh\n\nIn the above article, I introduced the development context and open source ecosystem of Istio. Next, I will introduce the future trends of Istio service mesh:\n- Zero trust network\n- Hybrid cloud\n\n\u003e *The future of service meshes lies in being the infrastructure for zero-trust networks and hybrid clouds.*\n\nThis is also the direction of Tetrate, the enterprise-level service mesh provider of the author\u0027s company. We are committed to building an application-aware network suitable for any environment and any load and providing a zero-trust hybrid cloud platform. Shown below is the architecture diagram of Tetrate\u0027s flagship product, Tetrate Service Bridge.\n\n![TSB Architecture Diagram](tsb.svg)\n\nTetrate was founded by the founders of the Istio project, and TSB is based on open source Istio, Envoy, and Apache SkyWalking. We also actively contributed to the upstream community and participated in the creation of the Envoy Gateway project to simplify the use of Envoy gateways (XCP in the figure above is a gateway built with Envoy).\n\n## Zero trust\n\nZero Trust is an important topic at IstioCon 2022. Istio is becoming an important part of zero trust, the most important of which is **identity-oriented control** rather than network-oriented control.\n\n{{\u003ccallout note \u0022What is Zero Trust?\u0022\u003e}}\n\nZero Trust is a security philosophy, not a best practice that all security teams follow. The concept of zero trust was proposed to bring a more secure network to the cloud-native world. Zero trust is a theoretical state where all consumers within a network not only have no authority but also have no awareness of the surrounding network. The main challenges of zero trust are the increasingly granular authorization and time limit for user authorization.\n\n{{\u003c\/callout\u003e}}\n\n### Authentication\n\nIstio 1.14 adds support for SPIRE. SPIRE (SPIFFE Runtime Environment, CNCF Incubation Project) is an implementation of SPIFFE (Secure Production Identity Framework For Everyone, CNCF Incubation Project). In Kubernetes, we use ServiceAccount to provide identity information for workloads in Pods, and its core is based on Token (using Secret resource storage) to represent workload identity. A token is a resource in a Kubernetes cluster. How to unify the identities of multiple clusters and workloads running in non-Kubernetes environments (such as virtual machines)? That\u0027s what SPIFFE is trying to solve.\n\nThe purpose of SPIFFE is to establish an open and unified workload identity standard based on the concept of zero trust, which helps to establish a fully identifiable data center network with zero trust. The core of SPIFFE is to define a short-lived encrypted identity document—SVID (SPFFE Verifiable Identity Document)—through a simple API, which is used as an identity document (based on an X.509 certificate or JWT token) for workload authentication. SPIRE can automatically rotate SVID certificates and keys according to administrator-defined policies, dynamically provide workload identities, and Istio can dynamically consume these workload identities through SPIRE.\n\nThe Kubernetes-based SPIRE architecture diagram is shown below.\n\n![Architecture diagram of SPIRE deployed in Kubernetes](spire-with-kubernetes.svg)\n\nIstio originally used the Citadel service in Istiod to be responsible for certificate management in the service mesh, and issued the certificate to the data plane through the xDS (to be precise, SDS API) protocol. With SPIRE, the work of certificate management is handed over to SPIRE Server. SPIRE also supports the Envoy SDS API. After we enable SPIRE in Istio, the traffic entering the workload pod will be authenticated once after being transparently intercepted into the sidecar. The purpose of authentication is to compare the identity of the workload with the environment information it runs on (node, Pod\u0027s ServiceAccount and Namespace, etc.) to prevent identity forgery. Please refer to How to Integrate SPIRE in Istio to learn how to use SPIRE for authentication in Istio.\n\nWe can deploy SPIRE in Kubernetes using the Kubernetes Workload Registrar, which automatically registers the workload in Kubernetes for us and generates an SVID. The registration machine is a Server-Agent architecture, which deploys a SPIRE Agent on each node, and the Agent communicates with the workload through a shared UNIX Domain Socket. The following diagram shows the process of using SPIRE for authentication in Istio.\n\n![Schematic diagram of the SPIRE-based workload authentication process in Istio\u0022](workload-attestation.svg)\n\nThe steps to using SPIRE for workload authentication in Istio are as follows:\n\n1. To obtain the SIVD, the SPIRE Agent is referred to as pilot-agent via shared UDS.\n1. The SPIRE Agent asks Kubernetes (to be precise, the kubelet on the node) for load information.\n1. The kubelet returns the information queried from the API server to the workload validator.\n1. The validator compares the result returned by the kubelet with the identity information shared by the sidecar. If it is the same, it returns the correct SVID cache to the workload. If it is different, the authentication fails.\n\nPlease refer to the SPIRE documentation for the detailed process of registering and authenticating workloads.\n\n### NGAC\n\nWhen each workload has an accurate identity, how can the permissions of these identities be restricted? RBAC is used by default in Kubernetes for access control. As the name suggests, this access control is based on roles. Although it is relatively simple to use, there is a role explosion problem for large-scale clusters—that is, there are too many roles, and the types are not static, making it difficult to track and audit role permission models. In addition, the access rights of roles in RBAC are fixed, and there is no provision for short-term use rights, nor does it take into account attributes such as location, time, or equipment. Enterprises using RBAC have difficulty meeting complex access control requirements to meet the regulatory requirements that other organizations demand.\n\nNGAC, or Next Generation Access Control, takes the approach of modeling access decision data as a graph. NGAC enables a systematic, policy-consistent approach to access control, granting or denying user management capabilities with a high level of granularity. NGAC was developed by NIST (National Institute of Standards and Technology) and is currently used for rights management in Tetrate Service Bridge. For more information on why you should choose NGAC over ABAC and RBAC, please refer to the blog post Why you should choose NGAC as your permission control model.\n\n## Hybrid cloud\n\nIn practical applications, we may deploy multiple Kubernetes clusters in various environments for reasons such as load balancing; isolation of development and production environments; decoupling of data processing and data storage; cross-cloud backup and disaster recovery; and avoiding vendor lock-in. The Kubernetes community provides a \u0022cluster federation\u0022 function that can help us create a multi-cluster architecture, such as the common Kubernetes multi-cluster architecture shown in the figure below, in which the host cluster serves as the control plane and has two member clusters, namely West and East.\n\n![Kubernetes Cluster Federation Architecture](multicluster.svg)\n\nCluster federation requires that the networks between the host cluster and member clusters can communicate with each other but does not require network connectivity between member clusters. The host cluster serves as the API entry, and all resource requests from the outside world to the host cluster will be forwarded to the member clusters. The control plane of the cluster federation is deployed in the host cluster, and the \u0022Push Reconciler\u0022 in it will propagate the identities, roles, and role bindings in the federation to all member clusters. Cluster federation simply \u0022connects\u0022 multiple clusters together, replicating workloads among multiple clusters, and the traffic between member clusters cannot be scheduled, nor can true multi-tenancy be achieved.\n\nCluster federation is not enough to realize hybrid clouds. In order to realize hybrid clouds in the true sense, it is necessary to achieve interconnection between clusters and realize multi-tenancy at the same time. TSB builds a general control plane for multi-cluster management on top of Istio and then adds a management plane to manage multi-clusters, providing functions such as multi-tenancy, management configuration, and observability. Below is a diagram of the multi-tenancy and API of the Istio management plane.\n\n![Schematic diagram of TSB\u0027s management plane built on top of Istio](tsb-management-plane.svg)\n\nIn order to manage the hybrid cloud, TSB built a management plane based on Istio, created tenant and workspace resources, and applied the gateway group, traffic group, and security group to the workloads in the corresponding cluster through selectors. For the detailed architecture of TSB, please refer to the [TSB documentation](https:\/\/docs.tetrate.io\/service-bridge).\n\nThanks for reading.\n', '\/en\/blog\/beyond-istio-oss\/')">
                <i class="fas fa-file-download"></i>
              </a>
             </li>
          </ul>
      </div>
      <p class="card-text">This article explains the background of Istio&#39;s birth, its position in the cloud-native technology stack, and the development direction of Istio.</p>
    </div>
  </article>
</div>


<script>
  function convertImageLinks(rawContent, permalink) {
      
      const baseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const blogPath = permalink.replace(/^\/|\/$/g, ''); 
      return rawContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, function(match, altText, relativePath) {
          
          if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
              return match; 
          }
          return `![${altText}](${baseUrl}${blogPath}/${relativePath})`;
      });
  }
  
  function convertRelativeLinks(rawContent) {
      
      const domain = 'https://jimmysong.io'; 
      return rawContent.replace(/\[([^\]]+)\]\((\/[^)]+)\)/g, function(match, linkText, relativePath) {
          return `[${linkText}](${domain}${relativePath})`;
      });
  }
  
  function exportToMarkdown(title, description, rawContent, permalink) {
      const githubBaseUrl = 'https://raw.githubusercontent.com/rootsongjc/rootsongjc.github.io/master/'; 
      const filename = title + '.md';
  
      
      const convertedContent = convertImageLinks(rawContent, permalink);
      
      
      const contentWithLinks = convertRelativeLinks(convertedContent);
  
      
      const contentWithHeader = `> ${description}\n>\n> 阅读原文请转到：https://jimmysong.io${permalink}\n${contentWithLinks}`;
  
      
      const contentWithFooter = `${contentWithHeader}\n\n---\n`;
  
      
      const element = document.createElement('a');
      element.setAttribute('href', 'data:text/markdown;charset=utf-8,' + encodeURIComponent(contentWithFooter));
      element.setAttribute('download', filename);
  
      element.style.display = 'none';
      document.body.appendChild(element);
  
      element.click();
  
      document.body.removeChild(element);
  }
  
  
  if (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1") {
      document.querySelectorAll('.export-button').forEach(function(button) {
          button.style.display = 'inline';
      });
  }
</script>
          
          <div class="col-12">
 
 
 
 
 
 
 
 
 
 
 
 <nav aria-label="Page navigation">
   <ul class="pagination justify-content-center">
     
     
     
     
     
     
       
       
       
         
       
       
       
         <li class="page-item page-item active ">
           <a href="/en/tags/service-mesh/" class="page-link">
             1
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/tags/service-mesh/page/2/" class="page-link">
             2
           </a>
         </li>
       
     
       
       
       
         
       
       
       
         <li class="page-item">
           <a href="/en/tags/service-mesh/page/3/" class="page-link">
             3
           </a>
         </li>
       
     
     
     
     <li class="page-item">
       <a href="/en/tags/service-mesh/page/2/" class="page-link">
         »
       </a>
     </li>
     
     
     
     <li class="page-item">
       <a class="page-link" href="/en/tags/service-mesh/page/3/">
         »»
       </a>
     </li>
     
   </ul>
 </nav>
 
</div>

        </div>
      </div>
      <!-- sidebar -->
      <aside class="col-lg-4 order-1 order-lg-2 d-none d-sm-block">
          <div class="sidebar">
          <!-- categories -->
<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Columns
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/istio" class="sidebar-item">
            <span>Istio</span>
            <span>(50)</span>
        </a>
      
        <a href="/en/categories/service-mesh" class="sidebar-item">
            <span>Service Mesh</span>
            <span>(12)</span>
        </a>
      
        <a href="/en/categories/envoy" class="sidebar-item">
            <span>Envoy</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/cloud-native" class="sidebar-item">
            <span>Cloud Native</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/essays" class="sidebar-item">
            <span>Essays</span>
            <span>(5)</span>
        </a>
      
        <a href="/en/categories/ai" class="sidebar-item">
            <span>AI</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/kubernetes" class="sidebar-item">
            <span>Kubernetes</span>
            <span>(2)</span>
        </a>
      
        <a href="/en/categories/open-source" class="sidebar-item">
            <span>Open Source</span>
            <span>(2)</span>
        </a>
  </div>
</div>

<div class="blog-categories mb-4">
  <p class="sidebar-title">
      Book
  </p>
  
  
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
        
      
      
  
  <div class="bg-gray">
      
        <a href="/en/categories/translation" class="sidebar-item">
            <span>Translation</span>
            <span>(6)</span>
        </a>
      
        <a href="/en/categories/original" class="sidebar-item">
            <span>Original</span>
            <span>(2)</span>
        </a>
  </div>
</div>





          </div>
      </aside>
      <!-- /sidebar -->
    </div>
  </div>
</section>




<footer>
  
  <div class="footer bg-footer section-sm border-bottom overlay ">
    <div class="container-xl">
      <div class="row">
        <div class="col col-xl-4 d-sm-none mb-2 mb-lg-0 d-xl-block d-none">
          
          <p class="h3 text-white mb-4 text-uppercase">Contact</p>
          
          <ul class="list-unstyled">
            
            
            <li class="mb-4 text-color">Jimmy&rsquo;s LinkedIn</li>
            
            
            <li class="mb-4"><img src="/images/jimmysong-linkedin.png" width="118px" height="118px" alt="footer image"></li>
            
            
            
          
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Blog</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-inpod-iptables/">In-Pod IPtables Rule Injection in Istio Ambient Mode Explained</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/istio-ambient-traffic-interception/">Detailed Explanation of Transparent Traffic Interception in Istio ambient mode</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/blog/migrate-to-istio-telemetry-api/">Migrating from MeshConfig to Istio Telemetry API: Enhancing Observability and Flexibility in the Mesh</a></li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">links</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="/awesome-cloud-native/" >
                  Awesome Cloud Native
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://gateway.envoyproxy.io" target="_blank" rel="noopener noreferrer">
                  Envoy Gateway
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://istio.io" target="_blank" rel="noopener noreferrer">
                  Istio
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://tetrate.io/?jimmysong" target="_blank" rel="noopener noreferrer">
                  Tetrate - Service Mesh Company
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://docs.tetrate.io/istio-subscription/" target="_blank" rel="noopener noreferrer">
                  Tetrate Istio Subscription
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">Courses</p>
          <ul class="list-unstyled">
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/envoy-fundamentals" target="_blank" rel="noopener noreferrer">
                  Envoy Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
            <li class="mb-3">
              <a class="text-color" href="https://academy.tetrate.io/courses/istio-fundamentals" target="_blank" rel="noopener noreferrer">
                  Istio Fundamentals
                  
                  <i class="fa-solid fa-arrow-up-right-from-square icon-small"></i>
                  
              </a>
            </li>
            
          </ul>
        </div>

        
        <div class="col col-xl-2 col-6 col-sm-3 mb-2">
          <p class="h3 text-white mb-4 text-uppercase">new notice</p>
          <ul class="list-unstyled">
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-china-2024-panel/">KubeCon China 2024 panel Preview: Istio and Modern API Gateways – Leading the Future of Service Mesh</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/website-revamp-notice/">Website Revamp Notice</a></li>
            
            <li class="mb-3"><a class="text-color" href="/en/notice/kubecon-eu-2024/">See you in KubeCon Paris!</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

  
  <div class="copyright py-4 bg-footer overlay">
    <div class="container-xl">
      <div class="row">
        <div class="col-sm-6 text-sm-left text-center">
          <p class="mb-0 text-color">© 2017-2024 Jimmy Song All Right Reserved</p>
        </div>
        <div class="col-sm-6 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://twitter.com/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-x-twitter text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/contact/" >
                    <i class="fa-brands fa-weixin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://github.com/rootsongjc" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-github text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="https://linkedin.com/in/jimmysongio" target="_blank" title="Social link" rel="noopener noreferrer">
                    <i class="fa-brands fa-linkedin text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="mailto:rootsongjc@gmail.com" >
                    <i class="fa-solid fa-envelope text-white"></i>
              </a>
            </li>
            
            <li class="list-inline-item">
              <a class="d-inline-block p-2" href="/en/blog/index.xml" >
                    <i class="fa-solid fa-rss text-white"></i>
              </a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>


<!-- JS Plugins -->

<script src="/plugins/popper/popper.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>

<script src="/plugins/anchor/anchor.min.js"></script>

<script src="/plugins/tocbot/tocbot.min.js"></script>

<script src="/plugins/bigger-picture/bigger-picture.min.js"></script>


<!-- Main Script -->

<script src="/js/script.min.f94c22b1d478bfc9e2e0a7d954429e47b7e6d36edd423758482e04154ae1842e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESY906ZWZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ESY906ZWZ0');
</script>


<!-- Baidu analysis -->
<meta name="baidu-site-verification" content="g8IYR9SNLF" />










<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>






  





<script src="/js/wowchemy-search.min.ce03c611044441cf6e84f9e4bef20818.js" type="module"></script>
<script id="search-hit-fuse-template" type="text/x-template">
  <div class="search-hit" id="summary-{{key}}">
    <div class="search-hit-content border-bottom">
      <div class="search-hit-name">
        <div class='search-hit-link'><a href="{{relpermalink}}">{{title}}</a></div>
        <div class="search-hit-metadata d-flex">
            <span class="mr-1"><i class="fa-regular fa-calendar mr-1"></i>{{date}}</span>
            <span class="mr-1"><i class="fa-regular fa-folder-open mr-1"></i>{{section}}</span>
            <span class="d-sm-block d-none"><i class="fa-solid fa-link mr-1"></i>{{relpermalink}}</span>
        </div>
        <div class="search-hit-description">{{snippet}}</div>
      </div>
    </div>
  </div>
</script>



    </body>
</html>
